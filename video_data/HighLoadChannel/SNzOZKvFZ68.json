{
  "video_id": "SNzOZKvFZ68",
  "channel": "HighLoadChannel",
  "title": "Postgres vs Mongo / Олег Бартунов (Postgres Professional)",
  "views": 139856,
  "duration": 3154,
  "published": "2017-06-28T07:04:11-07:00",
  "text": "Дело в том что я очень рад что я успел на эту конференцию потому что я прилетел из славной страны Непал можно сказать прямо с базового лагеря верест вот преодолел всякие трудности и успел вовремя Это говорит о том что то что я буду говорить оно сказать правильная Вот кто из вас понимает что нарисовано вот на этой картинке то есть вот слон Слона вы понимаете слон - это рес это уверенные хорошее доброе животное которое может очень долго помнить то что требуется от базы данных а вот этот хвостик закруглённый Это между прочим логотип Джейсона То есть это бесконечный Тор вот наш художник попытался изобразить что Современный постгрес он как бы дружит с джем И вот так у нас удалось сделать что хобот в виде бесконечного торуса И мне очень нравится эта картинка я представляю компанию здесь пог профессиональный и также Московский университет где я работаю научным сотрудником государственно астрономическом институте Прежде чем начать вообще полную весь доклад Я хочу немного остановиться предпосылках откуда появилось вообще слово SQ Откуда это всё взялось Дело в том что многие сейчас молодые ребята начинают пользоваться которые начинают работать в it технологиях они очень любят громкие слова и слово SQL им как кажется очень скучным и надо учить а вот но SQ означает что-то такое новое Яркое и легко с лёгким порогом хода вот я на своей памяти писал свои базы данных вот когда был ещ студентом аспирантом примерно в вашем возрасте я писал сам свои базы данных то есть сам использовал при этом в виде хранилища использовал магнитные ленты и в своей программе сам ходил по поинте доставал записи сортировать а просто то железо на котором Мы работали оно было очень медленное и надо было всё оптимизировать самому То есть я занимался этой физической организацией рубо говоря данных работа с ними вот и когда появились реляционные базы данных я был настолько шокирован когда я познакомился с ними я познакомился я ээ с ингри зом я был настолько шокирован что ничего мне этого делать не надо а просто-напросто говорить то что я хочу сделать и оно всё работало мне было это очень интересно но я долго не мог этим пользоваться потому что действительно железо было слабое потому что все вот эти ээ таблицы реализованные весь этот абстракция э хранения она давала значительны Вот Но со временем вот уже когда мы начали делать да сказать уже появились 500 герцовые компьютеры с ги с гигабайтами памяти и там по у нас залета и по там использовался как интеграционная база данных то есть что такое интеграционная база данных вы что-то меняете и сразу во всех местах эти Изя вид пото приложения они работали используя эту базу данных было очень удобно данные всегда конн меняется Всё в одном месте всё очень хорошо при этом используется язык SQL SQL как сказал рекер - это Межгалактический язык работ общения Ну с данными то есть удобный декларативный язык вот всё было очень хорошо но SQL он как бы все кто работает понимат что существуют некие трудности с реляционными базами потому что мир меняется и меняется очень быстро вот особенно сейчас это заметно То есть вы делаете какой-то проект прибегает менеджер и говорит вам срочно нужно значит ещё какое-то поле добавить завтра нужно уже опубликовать вот с реляционными база данных это может пром при сде там миллиард записи придётся очень долго-долго подождать Это как говорится раздражало людей люди говорили о том что им нужно делать быстрые релизы а реляционные базы такие медленные И неповоротливые тем более что появились вот эти э баз ворды как Big Data много данных быстро меняются разные форматы данных а SQL как бы он застыл и непоколебим То есть он очень хороший нормальный но он очень медленно меняется И в тоже время архитектура веб приложений она стала другой теперь уже веб-приложение это не просто одно монолитное приложение а это разные сервисы и каждый веб-сервис он в принципе это же обычная программа Да она может вполне собой заниматься цело проверкой ска целостно данных выс всякие агрегаты для несов плюс единичку делать и всё для них не нужна вся эта мощь реляционной база данных достаточно просто простой структуры данных ключ значения и вот оттуда появились как раз вот эти самые но SQL то есть уже люди обрадовались и поняли что мы можем легко развязаться от большой монолитной базы данных на маленькое на большое количество сервисов каждый из которых может работать со своей базой данных вот эти базки данных они получили название говорят потом стали говорить Что что некоторые что SQ мы можем выучить но предпочитаем работать не см напрямую скажем и основным типом данных вот так получилось что стал который там одно время был очень развивался был очень популяр мене он популярен используется и на него есть Стандарт на него есть rfc и так далее Вот и таким образом nql базы данных Они они позволили людям во-первых очень быстро менять свои схемы данных Вот то есть сделать быстрые релизы Они были очень хорошо масштабируемые потому что это очень простые данные KV от них не требовалась Асид то есть полно конн когда вот вы сделали изменение и тут же получили значит что в базе они произошли и видны всем А вы все уже привыкли что существует такое понятие как Event cons знаете такое да то есть есть игро слов и - это кислота А - это щёлочь то есть вот реляционные базы данных относительно база данных это как кислота относительно лочи это две такие разные жидкости вчем приятные Вот и в нашей обычной жизни мы привыкли к этой к этой cons То есть когда данные будут целостно не сейчас а когда-то потом ну все пользуются фейсбуком да Вот я например смотрю у меня столько-то лайков там 37 лайков Интересно кто же ткнул на него смотрю а там написано не 37 А 85 Ну просто потому что в принципе мне это всё равно то есть когда-нибудь Потом оно всё синхронизм хорошо но на самом деле Люди уже привыкли что когда вы выйти э в банкомате снимаете деньги вам приходит эсэмэска и вы становитесь довольными что Да действительно баланси у вас поправился Но если Вы посмотрите в базу данных в базе данных этого ничего не будет это будет записано только в лог и только ночью когда будут проходить эти самые операции обновления эти транзакции накат и у вас получится целостно целостная то есть мы к этому привыкли и сетевые операторы к этому привыкли то есть где-то там ты 50 руб не доплати или 10 руб доплати Это уже никого не волнует это уже входит в техническое задание что возможно некоторое разночтения Вот это маленькие такие маленькие возможности несоответствия они на самом деле дают очень большой вклад в в производительность и в то что как ль база данных масштабируется действительно базы они очень хороши для Вот таких приложений вот вопрос заключается в том что этих баз данных бесконечное количество вот какой-то год я сделал вот такой снимок с Википедии сейчас посмотрел там сотни то есть этих баз данных Миллион Ну очень много каждая нормальная уважающая себя команда хочет написать свою ключ значение баз данных но это не отнять любой программист хочет написать свою базу данных и это Дат полный Простор Однако проблема есть такая что А что если вы хотите иметь и целостность данных то есть полный Да но при этом иметь гибкость но SQL то есть хочется усидеть на двух стульях и например что что для этого нужно для этого нужно просто-напросто как я бу для себя понял что возм добавим туда и тогда мы полум эту и вс будет хорошо потому что по Как вы знаете очень хорошая база данных она расширяемая она обладает просто гигантской функциональностью с которой никакая SQL база но SQL база данных не сравнится вот не хватает действительно вот такие вещи Как как гибкость чтобы Вы могли в любой момент поменять схему при этом мы тели мы поставили задачу что мы хотим чтобы полностью поддерживались слабо структурированные данные то есть был ч были операторы и функции над этими были был это работало очень быстро и было интегрирование с ядром То есть все запросы которые вы писали Они понимали с ядром правильно оптимизировали выполнялись и так далее Вот и тут как раз вот я хочу вам сказать что на самом деле постгрес ещё с 2003 года уже как бы обладал возможностью данных вот гибкостью с в 2003 году я и Фе сигаев сделали тип данных H вот тип данных составляет вот всего лишь навс видите табличку вот ID пять колонок таких важных по которым надо искать и там сотня может пять сотен колонок которые не нужны никому а только при показе То есть вы ищете вот по этим пяти колонкам да А все остальные Вы показываете табличку просто что и как это было не просто так нами Придумано мы делали проект для единую базу данных для субъектов Министерства Образования Вот как раз там мы узнали такую страшную вещь что оказывается субъект видов субъектов образования у нас больше п Ну то есть школа колледж техникум институт университет дашту около п колонок одинаковых адрес там не знаю телефон там е что такие обычные вещи положение его и так далее и очень много специфических атрибутов для каждого вида где-то он назывался директор где-то назывался завуч где-то там ещё кто-то так далее они все были разные и когда мы попробовали сделать вот единую портя единую табличку спом на экра нам было это очень неудобно работать и тогда мы сделали так возм все эти 495 колонок и скажем что это ключ значения и захн строку и обзо этот тип вот скажем вот этот отдельная колоно то есть грубо говоря мы сделали место где можно хранить разный мусор туда можно было в любой момент добавить любое ние что это имело бинарное хранение можно было искать там делать операторы и так далее и так далее наступило Счастье то есть вы действительно легко Работаете Вы можете в любой момент добавить любое поле с другой стороны Вы имеете все операторы для того чтобы там что-то поискать Вот то есть уже в 2003 году мы уже имели в постгрес И не только мы потому что с 2006 года это сть по иче много людем до сих пор пользуется Счастливо и и радостно То есть hst он давал возможность посу схема less feature как я назвал То есть можно было спокойно работать в чём был недостаток недостаток был в том что во-первых hstore он не был стандартом Но это Понятно Потому что J Как вы все знаете появился только в 2008 году описание его то есть тогда когда мы делали 2003 2006 просто не было Джейсона Если был бы мы может быть его и сделали плюс H он был плоский там нельзя было хранить массивы там объекты и так далее просто ключ значения самый простой вариант базы данных вот здесь краткая история как в пос развивался вот эти фичи видите 2003 2006 в 2012 году у нас появился тип J но он появился такой очень странный тип он как бы его разработчики не верили что н очень нужен просто сделали его в виде хранения такого в виде строки то есть проверили синтаксис положили и всё Никаких особых операций с ним делать невозможно было потому что это было медленно каждый раз надо было парсить что-то делать там и так далее То есть хранилось вот я тогда немного покритиковать hore Тем более что нас многие спрашивали давайте делайте H с вложенной hore то есть Мо было массивы делать И вот через несколько лет мы уже сделали этот вложенный Когда нам Вдруг пришла здравая идея что зачем нам делать А лучше сделать сразу улучшенный и назвали его J вот некоторые говорят что это некоторые говорят что это лучший вот я сам не знаю какой это но уже бинарное хранение нормальные J операции больше 6 функций операторов Для этого J B он там безумная гибкость хорошо всё работает и как вы видите вот синенький график это популярность JB а красненький - это hore видно что как только мы выпустили Jon B он стал резко расти А популярность hore осталась на нормальном уровне но уже падает это картинкам я е сам придумал а нарисовал с помощью Google Trend вот сервиса а Google Trend он так сказать отслеживает такие все ключевые слова причём популярные то есть hstore и Jon B они являются популярными для Гугла имеют хорошую статистику вот а вот у нас появляется вот такая картинка то есть слева у нас как появились но SQL базы данных как они эволюционировали видите сначала была примитивная KV база данных потом люди поняли что просто им недостаточно им нужно чтобы был бы упорядоченный сделали упорядоченный ключ значения потом Вот видите как у Кассандры Table широкие колонки появились То есть у Кандры Да когда часто используемые колоночки атрибуты вы объединяет рядом Там фамилия имя отчество Вот они лежат рядом это уже усложнение моде ключения вот появились полнотекстовые базы данных и вот вершина всего это вот уже графы когда появились уже связи между э записями А с правой стороны эволюция No SQL в постгрес и вот как раз есть такая картинка у нас когда вышел вышла версия 94 этот релиз Вот видите назвали No SQL oned то есть Кислотный такой то есть с двух сторон идёт конвергенция с одной стороны ключ значения обычный базы данных они начинают усложняться усложняться а с другой стороны реляционные базы стали в виде поса стали потихоньку приближаться Ну интегрировать себя всякие фичи в частности хочу вам сказать был первый базы данных реляционный крупный которые в которой появилась поддержка дна то есть не орак появилось позже в этой работе вот эта картинка показывает что у нас исторически получилось что у нас два есть типа данных J вот один тип J B и первый J исторический просто надо понимать что J - это текстовый тип данных Как вы положили J со всеми его пробелами дублирован ключами и так далее так оно и будет лежать а J B это уже бинарное хранение в НМ уже нет никаких пробелов вот все ключи отсортированы для того чтобы можно было очень быстро искать и он имеет бинарное хранение Что означает что каждый раз при обращении к джейсону для вытаскивания какого-то ключа вам не нужно его парсить вот скажем например в оракле Да скажем реализован как в контейнере 2 или в сило Когда вы хоте чтото достать вам при Егор как хорошо И когда м нужно что-нибудь достать вы просто берёте по указателю и доста благодаря этому в десятки раз быстрее чем то есть это реально ну хорошо тип данных которым можно пользоваться реально дальше я вот солю на вот этот доклад Кристо туса моего коллеги сделал прекрасный доклад где после 0 там 90 по-моему слайдов вы поймёте что Джейсон B в посе очень и очень хорош и очень-очень много чего может просто времени мало Я поэтому на него СОШ единственный Вывод что Джейсон B хороший но у него нет языка запросов Дело в том что SQL запрос SQL был разработан в то время когда все типы данных были атомарные Ну то есть целая строка не было внутренней структуры а Джейсон - это тот тип данных в которых имеется структура и как раз SQL он не может он не мог скажем так сейчас скажу более мягче не мог ходить понимать структуру навить по структуре вытаскивать кусочки этой структуры то что нужно вот реально веб программистам то есть ДСО B Он по-прежнему был очень мощный хороший но это как чёрный ящик для Эля Вот например если Вы посмотрите на эту табличку к примеру Здесь всего дев записей это вот и запрос такой найти что-нибудь красненькое То есть если вы хотите найти что-нибудь красненькое с помощью Эля вот среди такого простого Ну предположим это вот всякие товары коммерции хотите найти что-нибудь красненькое девушка приходит в магазин говорит хочу купить красненькое как вы это Решите с помою вам прид видите на одной страничке вот ещё на второй стандарт SQL вам это позволит Но вам придётся очень-очень долго попотеть ещё непонятно как это будет долго работать видите получаете ответ Там шесть записей то есть с помощью сэ это можно сделать тем более по грессо у которого есть сабск развитый богатый SQL Но вам придётся очень долго попотеть вот мы в четырнадцатом году придумали значит я Саша и Федя придумали расширение для поса А по это расширяемая база данных То есть можно сбоку язык запросов мы его назвали и с помощью к можно сделать вот такой запрос и он будет работать Видите какой красненьким очень просто если кто не знает он лежит на гитхабе мы его поддерживаем его можно скачать поставить и пользоваться с удовольствием то есть этот это расширение позволяет работать структурой мы старались сделать его простым и чтобы все эти операторы они были е индексируемые то есть чтобы это не просто можно было сделать а можно было сделать быстро то есть в кре не только операторы функции но и индексы То есть существует хорошая индексная поддержка для И тут вдруг мы какже нормально без всяких расширений как вот в декабре 2016 года Я получаю вот такой стандарт новый стандарт SQL Встречайте его 2016 и в нём есть вот такое слово ДСО Как работать с Джейсоном в скле то есть свершилось реляционные базы данных SQL они проснулись и сказали что J - это хорошая штука И мы должны включить его в Стандарт то есть теперь J является не просто там прерогативы там монгодб там или ещё других там этих кауч db многих таких А уже есть спецификации рабочие спецификации Джейсона в SQL стандарте и причём не просто там видите здесь SQL Jon па Language это тот самый язык запросов по которому вы можете уже используя его очень легко ходить по дереву Джейсона и вытаскивать кусочки делать разные запросы и так далее Это большой Шаг вперёд и постгрес естественно что мы здесь вот есть се ссылки вот Естественно что мы подняли это обсуждение сначала нашей совещании разработчика Брюсселе Вот Потом мы очень быстро сделали патч для новой версии постгрес но его вот в эту десятку к сожалению не приняли потому что 16.000 роче кода и 5.000 строчек тестов как вот так просто нельзя интегрировать в такую сложную программу как база данных пому Мы надеемся её в одиннадцатую версию включить то есть это наш вклад в Open Source и мы его реализовали в посе не как новый тип данных Вот то есть мы взяли просто J и оказалось что J он является под множеством вот этого модели данных S То есть это уникальные для того чтобы работать для веб-приложения Это нормальное такое подмножество плюс мы реализовали Jon Pass query Language и язык запросов и девять функций которые ээ вот для построения Джейсона и для поиска для для запросов Ну вот например Видите вот Jon Pass то есть Он позволяет делать Вот такие операции например массивы ссылаться на массива фильтры то есть внутри этого Джейсон паса Вы можете указывать ещё фильтры вопросительный знак скобочка вот для всех значений X бо 10 можно методы указывать Сейчас функция Type Вот то есть это достаточно такой богатый язык хороший нам о понравился Мы даже подумали что нужно добавить его много всяких расширений Но это об этом будет позже вот примеры например запроса Jon Exist функция Вы видите что первый аргумент - это J B это сам вот второй аргумент - это Pass где Вы посмотрите на вытаскивайте те ключи у которых значения там больше чем X и меньше чем Y а значения Иса и и они передаются как переменные то есть Пан с помощью то есть конечно писать надо немного больше но по крайней мере появилась какая-то СХ будет ещ немного покажу примеров то есть есть SQL Construction функции то есть с помощью которых Вы можете делать объекты массивы агрегаты и так далее То есть это прямо стандарт описано не то что мы там придумали и вот для того чтобы вытаскивать значение жены J value J quy очень мощная функция это J Table и вот из J J J вот опять же вот примеры Какие можно делать но вот здесь не буду на них сейчас останавливаться Мне очень понравилось что с помощью теперь SQL Вы можете делать костре костре Когда вы делаете вы можете навесить кучу всяких констрейнт достаточно сложно вот здесь вот могу показать примеры как вот есть такой пример Я использовал Del букки это известный Такой тип известный датасет он выглядит примерно Вот так это букмарк я могу его превратить значит соответственно в реляционный вид то есть видите здесь используется J Table п котом можно было стмп видите планы внизу То есть это выглядит как абракадабра конечно но он сам по себе такой не очень так что ничего ту страшного Главное что после вот этого запроса мы получаем просто из Del BM получаем вот такую реляционную таблицу и у неё размер видите 2000 в два раза почти больше чем дновская таблица кстати никто не задумался что Хорошо иногда использовать для того чтобы компрессировать данные вот у нас Нако на поне вот которая была в марте конференции ребята рассказывали как они 60 ТБ данных превратили в 10 теб данных только только используя наш J это очень интересно так с запомните этот Хак не просто вы чтобы иметь 200 точек 200 строчек Да вы их просто храните как значение в и они лежат рядом Вы можете уменьшается размер и ещё доступ к данным улучшается Вот и теперь с помощью сна тот же самый запрос Вот который большой монстро видный его можно выразить ви стандарт способом вы можете с помою так вот показал что Что даёт в первую очередь он даёт стандартизацию То есть если вы пишете запросы или в постс или они все будут выглядеть одинаково Ну во втором случае ещё говорит о том что наконец-то мы можем с помощью S работать структурой здесь вот я привёл ссылки То есть те кто хотят попробовать можно просто с гитхаба взять SQL вот у нас есть там целый документ Там килобайт на 100 S примеры и те кто не хотят вообще даже компилировать есть Вот веб-интерфейс то есть можно прямо вводить запросы и потренироваться Вот то есть что требуется от вас от вас ремы Будем очень рады если Вы нам сообщите о каких-то багах несоответствия поняли стандарт Дело в том что стандарт написан на таком английском что сами англичане не понимают такой язык специфический но мы постарались его как бы развернуть в нормальное программисте и теперь вот та картинка она теперь уже выглядит немного по-другому Да видите что у нас теперь появился слон повернулся лицом к базам данных и идт действительно конвергенция но SQL базы начинает понимать что жизнь не так проста как ключ значения Вот и надо что-то больше а реализаци онная базы данных в виде порса они реализовали внутри себя э такие фичи ну SQL которые нужны многим людям э здесь вот видите что мы ещё над чем работаем SQL tod то есть очень много всего вплоть того что люди начали думать о том что не реализовать ли нам лямбда лямбда в этом языке что можно было совсем что угодно писать вот Вот такой наш индексы Естественно что индексы поддерживаются все знаете что в пос есть функциональные индексы То есть вы всегда можете сделать индекс по выражению по какому-то ключу и всё будет прекрасно работать обычный B индекс прекрасно работает другое дело что в имеем сразу весь То есть вам не нужно думать Какой ключ вам нужно проиндексировать а сразу весь Вот Но для пока что работает вот этот подход с функциональными индексами компрессия компрессия это ещё один проект который мы сейчас ведём и Надеемся в одиннадцатую версию включить Дело в том что люди как правило любят использовать название ключей в виде Таких вот таких выражений больших очень больших подб понял всё но они занимают места много поэтому мы естественно люди потребовали от нас чтобы не взяли хранить эти ключи название ключей в каком-нибудь словаре а вместо них использовать какие-нибудь аиш Ну собственно этому посвящён Этот проект компрессия который тоже реализован написан юзерс интерфейс интерфейс к нему Вот и соответственно какие-то вот есть примеры и результаты Вот то есть вот мы использовали два датасета один из них Del бук а второй - это C из амазона Вот они отличаются разным разными немного данными Одни из них имеют длинные ключи другие имеют массивы вот которые достаточно эффективно можно сжать и вот такие вот результаты здесь мы впервые косм Мон Вот это это джм и компрессия то есть здесь указан размер мегабайтах Чем больше тем хуже Мы видим что монго она для двух датов Мон она действительно достаточно хороша хорошо сжимается вот приятно смотреть на неё Вот она но реляционное представление меньше чем использу словарную компрессию то есть мы видим что словарная компрессия действительно работают причём для одного типа данных для одних данных Она работает лучше для других немного хуже Но тем не менее он как бы Вполне себе действительно они сделали хорошую работу компрессия у них действительно Хорошая работа если вы помните в предыдущих версиях я снива разн и Мон больше чеча они сделали вот э версия 3то тако последнем буквально вот месяц назад Они сделали очень хорошую поддержку компрессии Однако компрессия са по себе она не нужна нужно чтобы это было нужна ещё производительность Поэтому вот здесь привели Чим мы видим тут вот что здесь время в миллисекундах Чем больше тем хуже Мы видим что Jon BC реально быстрее То есть вы видите реально быстрее чем монго А если мы ещё включим параллельность то производительность Jon bc в несколько раз становится быстрее чем у монго Вы знаете что по с некоторых пор обладает уже поддержкой параллельно выполнения запроса То есть если у вас имее всякие ядра Да там то они могут использоваться так вот мы специально наши бенчмарки вот эти делали без выключали выключали эту параллельность А если включить параллельность то мы видим Вот они данные сразу уменьшаются это всё делалось на по-моему сколько там ядер в В общем мы делали как раз четыре ядра параллельно включали и она достаточно хорошо показывает Вот видите а е у нас есть вот такая штука cfs zsd это у нас есть свой Enterprise Edition как говорится в которой у нас есть такая веь как компрессия файловая система и вот на ней с помощью ещ она здесь указан метод компрессии ZD от Фейсбука Мы видим что и вот что производить ещё лучше то есть о Вполне себе хороша размер у неё сильно меньше чем у монго db вот здесь кстати сравнивается второй ещё один на другом датасете Мы тоже видим что здесь вот здесь не очень всё хорошо у моги то есть производительность Jon B она просто ну сильно меньше сильно лучше вернее чем у Мон db это нас очень радует Ну я хочу остановиться дальше на том что текст сч появился он уже закон в десятке То есть если вы хотите делать полноте свой поиск по джейсону теперь это можно делать Прямо стандартным способом И всё работает То есть раньше мы как бы не уделяли этому внимание Но вот в этом в этом релизе сделал Дима Долгов вот этот патч который уже просто доступен десятке Вот видите приме Ну Однако всё это хорошо функциональность а теперь нужно проверить как насколько он быстрый действительно Вот это первый этот слайд который я сделал в тринадцатом году Да когда мы в Дублине первый раз рассказывали Это пример чисто не научных бенчмарком То есть я на своём лэптопе интерактивно гонял запросы и был очень рад Вот видите первые цифры что мы оказывается у на 07 кун мис и тое я начал кричать что Кошмар Т то есть поре при всей своей осино и так далее он быстрее чем монго мне никто не поверил Но на всякий случай похлопали вот потом компания Enterprise db выпустила свои свой чма и тоже показала что пос лучше чем Мон вот компания уже была более сказать весомая появился пресс-релиз в приятных местах разных Это уже хорошо но народ очень скептично отнёсся к этим бенчмарка потому что все эти бенчмарки были сделаны по ЗАГСов людьми Ну то есть понятно Да так сказать а во-вторых люди Они любят верить тем бенчмарка которые как бы являются научными бенчмарка то есть где-то на wdb лежит статья посвящённая этому бенчмарк Да там А эти бенчмарки можно скачать Они воспроизводимые они поддерживают много разных баз данных они поддерживают разные ворды и доступ вот поэтому Никто особо нашим беч маркам не верил но в принципе соглашались что по Хорош Вот теперь настало время показать насколько он хорош то есть мы взяли просто-напросто мерку SQL ба данных то есть ycsb Яш бенчмарк вот есть здесь все ссылки ссылка на статью научную можете читать всякие графики и так далее мы проли на для поса mysql и для нашей версии ent поса то есть мы при этом делали так что во-первых Деги битный свич между клиентом и сервером клиент и Сервер - это вот чех ядерные 48 ГБ памяти и мы нагружать соответственно полностью Как как положено здесь вот написано сколько мы использовали видите это когда 50% чтения и записей б - это когда 95 чтения и 5% записи Ну и так далее вот интересны 100% запис и сказать сам весь бенчмарк он даёт возможности генерить данные гонять и так далее То есть это можно это очень хорошая мерка я не скажу что она пря такая идеальна но по кране ре Она более старова иди с результаты вот мы её прогнали здесь видите деталей много вот для поста 96 мастера мы использовали асинхрон on и Анну comit Off Но для того чтобы хоть как-то сравняться с монгой дело что анх это такой жёсткий режим Когда все всё синхронизируется на диск А у Мон у него по умолчанию там ну как бы изменения в памяти держится и для того чтобы мы естественно сделали первый у нас случай что изменения держатся в памяти логи вот сдела 1 и5 записей а для жёсткого случая нам не удалось сделать для монг потому что монго настолько начала тупить что просто нам удалось только для 100.000 записей провести действительно когда монге говоришь вот W1 опции такие Да так сказать Ну кто знает те понимают то есть они синхрони на диск начинает просто ну просто тормозить вот поэтому мы использовали два разных значения анута для поса так сказать со всеми оптимизация и тестировали функциональные индексы ндекс Потом значит с компрессией выть он к сча Когда у вас имеется короткий 10 полей и большой 200 поле и соответственно результаты вот сейчас мы можем показывать здесь вот клиентские машины как они были нагружены серверные машины были как нагружены то есть как бы всё в пределах и вот как детали прям конкретные детали Как создавались табли вот мы даже нашли проблему для Джейсона действительно что хо апдейт который очень важен для Джейсона вот Саш по-моему рассказывал должен был на лекции э действительно не работает и мы сделали патчи который пойдёт в астрим вот Пример например как ход апдейт очень важен то есть э видите зелёное - Это мо db Wi Tager оранжеве - это mysql B3 индекс вот красненькая Ну не красненькая фиолетовая Да не фиолетовая даже в общем вы поняли это это постгрес ванильный Мы видим что он начинает при большом количестве клиентов по X Это количество клиентов параллельных работающих То есть он начинает загибаться и становится хуже чем мон и Даже хуже чем mysql вот когда мы Поли поправили эту проблему сдем то она ста немного сине вот все следующие верси все следующие картинки это Бут уже с этим с этим вылечены багом вот результаты Здесь много картинок это использовалась 1 Милн записей короткий 10 полей и вытаскивать все поля вот ну мы видим что синенький - это постс это что постгрес на всех клоуда видите шесть клодо да Для всех клодо и даже для апдейта сильных постгрес быстрее чем мо db и mysql причём он как говорится в несколько раз и даже очень даже хорошо масштабируется монгодб видите начинает заваливаться при большом количестве клиентов То есть это серьёзный такой бенчмарк мы несколько раз это проверяли и очень рады что действительно пог здесь Вполне себе конкурентоспособная картинка когда мы вытаскиваем только одно поле то есть так же самое количество запис 10 полей только одно поле вытаскиваем мы действительно видим что под действительно здесь продолжает лидировать вот увеличили количество записей продолжаем видеть что подрез синенький лучше чем зелёненькая то есть это вот очень хорошие резуль дальше мы сделали такой вот как я сказал уже включили журнал на диск и в монго и в постгрес нам удалось всего лишь навсего прогнать 100.000 записей потому что ждать Миллион Ну время терять очень долго было пришлось и мы видим что вот здесь как вот монго сильно-сильно проигрывает полису Это здесь количество транзакций в секунду а это разные лоды а и так далее Мы видим что везде монго выше чем чем подрез практически наоборот А вот здесь мы начинаем немного проигрывать то есть здесь на на на Клод А и B мы лучше для 200 полей Дело в том что 200 полей для Посри са мы выбрали не не не зря а просто у Посри са такая такое хранение что если строка длинная то она начинает тоси Ну грубо говоря появляется дополнительная таблица в которой лежит ВС это данные больше чем 2 КБ а они лежат где-то там далеко в другом месте и приходится грубо говоря заниматься внутренним Джоном то есть и мы видим что здесь конечно Мон начинает лучше скажем на Мон на Для нас это сигнал о том что нам нужно работать скажем с оптимизацией толсто и мы будем это делать но вывод такой что пос он видите получше чем монго вот серьёзно Но идея В чём заключается Вот вы тут молодые Все да слю новое и хорошее им ного транзакций вку Хотя даже Немного непонятно иногда зачем то есть если вы хотите ещё больше Вы заметили цифры 200.000 транзакций в секунду То есть вот для запросов да для запросов пос выдавал около 200.000 транзакций в секунду ну а Вполне себе таком обычном сервере вот если вам это не хватает то вы что можете сделать Вы можете использовать партишен в посе вот такой пример который говорит о том что например позволяет например видите мы можем получить производительность там по сравнению с ванильным пом в 500 раз лучше То есть если вы действительно сейчас име так получилось что в ванильном посе существует один партин а мы ещё развиваем другой немного другой подход называется вот который обладает некоторыми более такими крутыми характеристиками вот здесь просто пример такой Если вы хотите ещ больше транзакций в секунду тогда Используйте шардинг это вот шардинг на котором сейчас мы работаем используя наш мультимастер и наш наш мультимастер и подход для шардов вотт они все доступны в онлайне с сеча на этим работаем вот и вот хочу сразу закончить быстро что самое важное что Вы уже поняли что это хороший база данных и у неё есть очень Ясный такой правильный То есть через версию мы получим уже вообще стандартны стандартную работу сном Вот чтобы проблем на пото что по обладает гораздо большей функциональностью Вот вы смеётесь да между прочим я видел людей которые начинали использовать SQL и радовались жизни до тех пор пока им не приходилось например писать алгоритмы для двух таблиц А потом когда Ему приходилось сделать третью табличку он уже вы используете JavaScript вы берёте данные из таблиц у вас там миллион записей в другой таблице ещё миллион вы качаете эти два миллиона запис к себе и начинаете писать на своём этом жава скрипте вот Join двух таблиц во-первых вы клиента убиваете своего да во-вторых у вас трафик трафик в-третьих вы ломаете голову над задачами которые реализация базы данных решили давным-давно то есть реляционная база данных вам выполнить на сервере всё это дела и вернёт там 10 строчек и всё Поэтому э легко Ну SQL Чем интересно легко начать легко как бы взлететь но потом вы остановитесь в её функциональности как только вам потребуется например сделать что-нибудь такое гисо ское вы начнёте изобретать велосипед Как там сейчас монго изобретает в постгрес это делается даже не в ядре просто люди взяли написали постс Да это расширение которая даёт вам Ну все стандарты гиса это стандарт Как говорится осов у поса Это причём говорю что это только один из примеров Сколько всего может дать релион ная база данных очень много просто напросто получилось как я вот моё мнение выскажу что Да мне уже Говорят что на кончать что на самом деле у баз данных практически вот скажем Мон нету будущего лавою пото Он полностью начинает занимать ВС предлагает ту же саму что и Мон но при этом гораздо Ну там больше 20 лет надёжной работы вот большое осорно сообщество по расширяемый То есть если вам-то нехватает може даже сва проми рабочи ведра и плюс К тому что учтите что э железо Становится всё более быстрым и шустрым то есть там где абстракция Ну общность э реляционных баз данных вам мешала ТО на новом витке развития железа вы просто этого не заметите то есть ну SQL просто был сделан для того чтобы решить задачи когда реляционных баз данных не хватало ни по производительности ни по функциональности я вам показал что функциональность у нас уже есть и всё впереди и производительность уже сейчас поз на современном железе бьёт монг вот и всё так Большое спасибо Давайте поблагодарим Олега за такой зажигательный доклад Да у нас есть время ровно на один вопрос Это вот меж прочим люди Великий Рандом Нам сейчас поможет с вопросом у кого вот есть наверно первые первый человек вопросом все остальные вопросы можно в кулуарах будет задать А спасибо за доклад А какое железо использовалось для этих тестов то есть Сколько памяти потреблял постгрес Сколько памяти потреблял монго Там я написал Сколько памяти и клиент и монго то есть мы оптимизировали чтобы всё было всё было заполнено естественно то есть 24 ядра 48 ГБ памяти и между ними десяти гигабитный свич Спасибо Да ну Спасибо Олег"
}