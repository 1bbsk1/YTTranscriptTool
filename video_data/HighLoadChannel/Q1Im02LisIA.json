{
  "video_id": "Q1Im02LisIA",
  "channel": "HighLoadChannel",
  "title": "Байт-код — это просто! Как сделать Dependency Injection по-настоящему быстрым / Григорий Юрков",
  "views": 270,
  "duration": 2257,
  "published": "2025-01-17T02:28:20-08:00",
  "text": "Всем привет Меня зовут Григорий ерков Я из команды Яндекс Маркета Всем спасибо что пришли на мою презентацию сегодня речь пойдёт о том как я смог ускорить наше приложение Яндекс Маркета с помощью модификации байт кода вообще Цель этого доклада не просто чтобы вы вынесли отсюда какие-то знания в вакууме про байт код которым можно будет выпи перед друзьями или на собеседовании А я хочу чтобы вы поняли что bcde - это мощный инструмент с помощью которого можно решать настоящие задачи дисклеймер я не кнд разработчик я Android разработчик возможно я не смогу ответить на ваши кэндес вопросы после доклада но это не значит что сам доклад не будет Вам интересен Итак начнём историю с того что в Маркете есть свой Di фреймворк под названием Скаут А что такое фре Надеюсь объяснять не нужно объясню что в мобильном приложении очень важна скорость старта поэтому поэтому когда мы жали на наш Di Framework Scout мы мы сильно замедлили скорость старта и это поставило проект по переходу под угрозу Возможно вы тогда Спросите А зачем мы вообще переезжали на наш наш Di фреймворк есть же другие фреймворки от Гугла например Дар dager 2 с которого мы переезжали на самом деле у мобильных разработчиков есть два стула один стул - это Di frw который frw который решает Граф зависимости во время компиляции это Это означает что мы нагружая компиляцию но зато R работает Быстро и в нашем случае скау - это R frw Это означает что всё в решение графи зависимости переходит на но компиляция из-за этого не страдает вот Ну и как говорил Ведьмак если есть два зла то я предпочитаю не выбирать не выбирать Вовсе и поэтому мы стали думать над том как ускорять наш наш Di фреймворк Итак сервис локатор Причём здесь сервис локатор можете его спросить а на самом деле ранта фреймворки фреймворки это сервис локаторы и может кто-то поспорить что Di не является сервис локатором но мы мобильные разработчики так сервис локатор называем тоже И как выглядит простейший сервис локатор на языке котн как-то Так у нас есть с мы инициализирует для даблов и потом с помощи метода Get достаём значение и вот в данном случае напечатается My string и 42 Исходный код класса с выглядит как-то так и даже если вы знаете котлин он может показаться вам достаточно сложным и непонятным на первый взгляд но я воспользуюсь одной фишкой котлина Это то что он компилируется в jav код и если переписать весь код на jav становится намного проще У нас есть хш Мапа мы Илим эту хш мапу с помощью метода кладём неё Factory для стрингов по классу string и к для даблов по классу и дальше мы Ну создаём уже объекты получается Мы достаём из этих fact по ключу вызываем методы Create и в данном случае вот опять напечатается и 42 и в м же здесь проблема пому у нас замедлился Старт приложения на старте происходит инициализация и вот кто-нибудь посмотрев на инициализацию может увидеть Почему чему Мы замедлились Мы сначала копали копали и пришли к выводу что это виноват в этом динг напомню для тех кто не знает что такое Клодин или подзабыл очень если очень кратко то это загрузка класса с диска в оперативную память Но на самом деле там не только загрузка класса там ещё и парсинг верификация байт кода и так далее И где же в нашем случае происходит лон который замедляет инициализацию вот здесь получается когда мы получаем объект класс класса то это не явно триггерит его Клодин и с этим надо было как-то бороться а ну да и на на данном примере у нас всего лишь две Factory А в настоящем приложении таких Factory могут быть десятки тысяч и триггерить ласун десяток тысяч классов - это Это достаточно долгая операция и у нас есть график Вот это мы жили спокойно спокойно и переехали на наш D Framework и с 450 миллисекунд выросло до 650 кто-то может сказать что это не так много на само но мобильное приложени скорость старта очень просто посчитать и сконвертируйте небудь заменить на классы инты Ну сделать бинарное отношение получается мы здесь в данном случае стринги заменяем на единицу а даблы там допустим на двойку и в целом код работает также но мы избавились от клас лоун и даже можно будет потом хэш мапу переписать на какую-нибудь свою мапу которая у которой ключи инты и который будет работать побыстрее чем шма что я придумал создать такой класс а точнее метод Create в который можно будет обернуть наши ключи классы для чего это сделаем для чего это нужно сделать а для того чтобы пометить эти классы как ключи для нашей для для нашей хш мапы И как вы можете заметить в методе Create он не реализован Почему так типа если мы запустим всё же упадёт Но мы сделаем один один трюк во время после того как мы скомпилированный Ну как минимум такое название существует в c+ Вот например на самом ко вы вызва этот метод о вызва оме нацию ВН сча но ЕС у ва в просо есть такая инци примеси и синус Хотя они присутствуют в исходном коде но когда Java исполняет эти методы Ну и в данном случае я говорю про хотс то она на самом деле не вызывает эти методы она подставляет нужные инструкции процессора тоже это ускорение в котлине котли на самом деле очень много таких Бин методов которые во время компиляции на что-то заменяются но есть метод сирона в Джаве - это блок А в котлине это метод функция И она тоже во время компиляции заменяется на нужные инструкции Monitor Enter и Monitor exit Ну и в нашем случае получается у нас есть метод Create статический который принимает класс и его нужно заменить на какую-то константу 42 и вопрос как же это сделать первая идея которая возникла написать плагин на компилятор котлина и каким-то образом там находить эти вызовы метода и заменять на константы но ни у кого не было опыта с этим и вообще даже непонятно было как подходить к этой проблеме Да и вообще плагины на компилятор славятся тем что там нестабильна А поэтому нам нам это необходи но возникла у меня идея сделать это с помощью байт кода сейчас начинается самая интересная часть доклада Я попробую на простых концепциях рассказать как работает обратной польской записи кто-нибудь знает что такое обратная польская запись да Есть есть люди а напомню или расскажу тем кто не знает что это такое Вот это математическое выражение написано в инфиксной записи 1 + 2 То есть это запись которой мы все пользуемся в обратной польской записи а оператор идёт после операндов То есть получается 1 + 2 заменяется на 1 2 если у нас несколько операторов то в принципе ничего меняется просто переносим операторы за опен получается 1 2 п 3 п с разными операми всё тоже самое 1 2 у 3 мину А вот здесь уже интересней в инфиксной записи мы знаем что умножение идт перед сложением но в обратной польской записи у операторов нет приоритетов поэтому сначала нужно выполнить умножение 23 умножить А уже в конце оди плюс скобки скобки тоже нужны для того чтобы расставлять приоритету операции и поэтому в обратной поиске записи их не существует в данном случае сначала выполняется сложение Поэтому 1п потом сложение 3 4 п и в самом конце умножения скобок Как видите нет и с функциями всё в принципе тоже самое в данном случае самым первым выполняется деление поэтому P2 делить потом сложение x П И в самом конце уже вычисляется косинус получается ко Для чего я вообще это рассказал вообще зачем существует обратная поиска запись она очень она сложна для понимания людей но компьютеры могут Очень просто вычислять выражение В обратной польской записи и возьмём пример 1 П 2 у на 3 в инфиксной записи в обратной польской записи будет выглядеть как-то так вот я расположил их подряд 2 уп чтобы вычислить выражение обратной поис записи нам нужна стековая машина вот заведём стековый машину сейчас в ней пустой стек и пробега по нашему выражению обратной поис записи сначала кладём двойку в стек потом тройку А дальше мы встречаем умножить А что делает умножить она два два верхних значения на стеке умножает и кладёт результат на этот же стек получается 23 Уно 2 x на 3 - это 6 в итоге у нас сейчас на стеке лежит шесть дальше встречаем единицу кладём её на стек и плюс также складывает два верхние значения на стеке и кладёт результат обратно на стек и в итоге мы пробежались по всему выражению в стеке у нас оказалось число семь Это означает что 1 + 2 x 3 ра се Итак подведём небольшие итоги У нас есть выражение в инфиксной записи которое просто читать человеку но сложно исполнять машине Давайте назовём это исходным кодом У нас есть выражение В обратной польско записи это это выражение сложно читать человеку ного просто читать просто исполнять компьютеру давайте это назовём байт кодом У нас есть процесс перехода из исходного кода ВД Давайте нам процесс компиляции и у нас есть какой-то исполнитель который умеет исполнять байт-код Давайте назовём это виртуальной машиной и вот так плавно из обратной польской записи Мы перек перешли К устройству байт кода Ну и разберём пример на Java всё тоже самое только мы ещё дополнительно выводим результат в консо опустим тот факт что 100 + 200 у 300 можно Кои и jav компилятор естественно это сделает И подставит с сразу константу туда Итак что первым Какая первая операция в данном выражении умножение Поэтому нам нужно загрузить 200 и 300 на СТК это делается с помощью команды LDC То есть загружаем 200 300 потом умножаем чис поиска записи А кто кому интересно что Что означает буква I в самом начале это операция над целыми числами а также у нас есть числа с плавающей запятой там если я не ошибаюсь первая буква - это д потом загружаем 100 на СТК выполняем операцию сложения и теперь нам нужно напечатать результат и первые операции которые происходят А после того как мы вычислили 100 + 200 X 300 это получение статического поля System Out для этого есть инструкция Get Static и в самом самом конце мы уже вызываем не статический метод println для этого есть инструкция inv Virtual и всё мылу мы разобрали мы перевели компилировать наш Java CDE bcde и теперь его Также можно исполнить для этого существует не стековая машина а виртуальная машина в байт коде но у неё также есть стек и пробегам по байт коду сначала загружаем 200 на стек потом 300 потом операция умножения умножает два верхних значения на стейки кладёт результат потом загружаем 100 на стек складываем два значения потом загружаем статическую переменную Си на и в самом конце вызываем не статический метод и так как он возвращает то на стеке ничего не остаётся и всё и где-то в консоли напечатал наш результат немного о точка лафа ниб кониум Да почти все я вижу вот е я думаю вы замечали что на 99% J архивы состоят из точка класс файлов что это такое а каждый класс из исходного кода компилируется в эти точко класс файлы и мы знаем что наши инструкции байт кода не живут где-то в вакууме они живут в методах а методах живут вкла и в том кстати в точка класс файла компилируется не только самый вот Обычный класс который здесь изображён туда включены и анонимные классы и вложенные классы и лямбды и я думаю какие-нибудь синтетические классы тоже там создаются Вот немного о структуре из чего он состоит первая точка идт заголовок там содержится информация о том что у нас за класс то есть название его его Суперкласс Какие интерфейсы он реализовывает версия байт кода и кстати самое интересное в самом начале точка класс файла в самом заголовке идёт магическая Константа называется cofe bape Возможно вы её где-нибудь видели А после заголовка идёт Pull костан у точка клас файла а P constant содержит все данные из нашего класса это все константы все ссылки на методы ссылки на поля ссылки на классы сигнатуры методов сигнатуры полей да такие тоже есть и так далее Короче все данные которые есть в класса они складываются в пул констант потом идут поля класса и методы класса и всё больше ничего нет возможно А вы Спросите а где конструкторы где статические блоки инициализации не статический блоки инициализации на самом деле это всё методы просто с особыми названиями А и Например у константы яма на самом деле это его статические поля просто помеченные особым флагом Итак мы разобрались байт кодом как он работает и нам нужно понять как модифицировать исполнение метода в нашем случае Так у нас есть K Create какой-то класс и наша цель заменить его на константу 42 попробуем разложить байт код вызов метода Create первая инструкция - это будет загрузка класса сам класс и потом вызов статического метода K Create через инструкцию inv STA и нам нужно это заменить на одну инструкцию LDC 42 Так мы заменим вызов метода сразу на константу нужно было выбрать библиотеку с помощью которой модифицировать код Я выбрал потому что у него удобный понятный лично для меня был кто-то может не согласиться сказать что есть более намного более совмен Биб если честно мало что получилось а у реально очень удобны и вы не вчитайтесь код просто посмотрите ну его достаточно мало чтобы заменить одну инструкцию на другую вот слева мы пробега по всем методам класса а справа по всем инструкциям методов и заменяем две инструкции на нашу одну система сбор Который модифицирует наш байт код нам нужно это как-то встроить нашу сборку То есть пока вы когда вы нажимаете на кнопку Play чтобы чтобы наш код отрабатывал и модифицировал байт код в Андроиде используется gradle как система сборки и Как видим код тоже простейший мы прибегаем по всем таскам находим все таски с названием компиляции котлина и проем по всем классам которые выплёвывает э таска и вызываем наш наш клас наш метод мо которым как раз мы меняем меняем код Я думаю мало кто из вас работал с глом что популярен больше в Android разработке но я думаю в Мане будет ну плюс-минус такой же код Мы вернулись к прежним значениям дагера результат был успешен и наш проект был Спан по переходу на на наш собственный фво Но зачем останавливаться здесь возникла идея второго улучшения если мы посмотрим на наш текущий уже модифицированный код мы заметим что из инициализации не кон нам илон кроме Ключей у нас ещё существует и значения в наши Factory и думаю вы знаете что лямбды на самом деле являются классами Да может кто-то может сейчас сказать что с восьмой джавы у нас лямбды могут компилировать в особую инструкцию invoke Dynamic но в Андроиде почему-то эту инструкцию Не используют и лямда там также компилируется в обычные классы так вот из того что лямбда - это обычные классы мы получается создаём очень много лямбд и это также триггерит динг их классов от этого тоже можно будет как-нибудь избавиться а возникла такая идея заменить сами вызовы конструктору улям на название этих классов и во время создания объекта чере рефлексию получается мы сильно разгружаем инициализацию потому что вот эти вот вызовы Т Они они прям практически бесплатные даже если там будет сотни тысяч этих путов но создание объекта мы чуть-чуть замедлили используя рефлекси Но на самом деле это не так важно потому чтом нуж атно все обеты сразу что кода запускаешь приложение нужен какая-то конкретная фича которой не так много объектов немного прокс Почему я его сюда вставил потому что мы инстан лямбды с помощью instance вообще он в три раза быстрее чем instance почему он быстрее потому что он спает вызов конструктора у класса И на самом деле CL - это чудо которое которое есть в Джаве потому что оно приносит частичку такого нативного кода в джаву кроме такой такого странного метода Как instance там есть а Memory который может аллоцировать память аналог Ну естественно если есть Memory то есть и который освобождает память в томс есть и арифметика над пойнтера и даже самое вот самое хардкорное что я там нашёл там есть emory барьеры вот такой аналог я нашёл Или c+ я честно не помню вот возможно кто-то из вас узнает этот код итоги результаты второго улучшения накидал небольшой опрос все варианты которые могли произойти Я хочу чтобы вы сейчас подумали и проголосовали за тот результат который принёс принесло второе улучшение Итак Кто думает что мы ускорились в принципе так же Кто думает что мы ускорились ещё больше уже побольше людей Кто думает что мы вообще не ускорились А И кто самый подлый думает что мы замедлились три человек четыре и барабанная дробь Мы замедлились в два раза Почему мы не знаем точно до сих пор А я Я думаю мы можем потом обсудить после доклада Если у вас есть какие-то идеи но прикол в том что мы я когда я это делал я проверял всё на дме и прям действительно было ускорение всё было хорошо Я уже всё там а отточить это на реальных устройствах У нас есть ферма в Яндексе с реальными устройствами где можно проверить как раз скорость старта приложения то мы получение вот замедления 118 про а немного про другие библиотеки которые также используют модификацию байт кода думаю самое популярное - это Makita Если вы никогда не понимали каким оно таким волшебным образом создаёт для классов то как раз Это происходит с помощью инъекции байт кода также расчёт покрытия происходит с помощью модификации байт кода я с этим не очень знаком Но я нагул что там есть ленивые ти которые также работают с помощью модификации байда Ну если тут есть разработчики то точно знаете библиотеку он подменяет наследников у классов те которые вы пометили с помощью аннотации Android ent Point какие выводы можно сделать первый вывод проверяйте свои гипотезы на практике и будьте готовы к неожиданным результатам пото что как мы видим было много положено усилий на второе на второе ускорение но как мы толь перелик про на прати в два раза и пытайтесь находить экстравагантное решение задач Я пытался показать что код является таким экстравагантным решением и как я говорил в начале код - Это не просто какая-то вещь которую можно выпендриться перед друзьями или на собеседовании байд - это очень крутой инструмент который можно решать сложные технические задачи и как мы знаем экстравагантные решения могут приводить к экстравагантным результатом как положительным так и отрицательным У меня всё спасибо Григорий большое спасибо Я бегу на сцену для начала хотелось бы напомнить что у нас есть чат зала туда можно задавать вопросы а если вы в онлайне и смотрите конференцию через платформу туда тоже можно задавать вопросы там есть специальная кнопка Ну и приступаем к вопросам и ответам и тебе напомню ещё что надо будет выбирать лучший вопрос запоминай У нас их много вот первый ряд три вопроса начнём вот так вот прям с первого А спасибо да спасибо за доклад у меня такой вопрос покрывали ли вы модифицированные классы в которых там изменили байт-код тестами и как это использовалось в CD А конечно покрывали у нас на самом деле Скаут вынесен в отдельный репозиторий на самом деле это Open Source библиотека и естественно у нас есть отдельный модули где тестируется не просто работоспособность там тестируется и скорость уже модифицированные классы уже модифицированные конечно там есть и не там у скаута можно и модифицированный класс и не модифицированный Спасибо там переключается флагом Да идём также по первому ряду вот вопрос прямо по центру пока вопрос не задали у меня небольшое напоминание у нас можно оценить доклад пожалуйста делайте оставляйте свои отзывы это очень помогает как конференции так и спикеру ваш вопрос да зра Здравствуйте вот в начале вы сказали что у вас фреймворк ран таймов но Насколько я понял всё-таки вы на этапе компиляции модифицируется можете прокомментировать как-то ран тайму имеется в виду что граф зависимости решается в ран тайме и Ну да мы что-то компилирует есть по факту это всё-таки копай Time а не динамически через ае он может рабо он может работать без э вот этого улучшения которое я сказал просто вот если во время компиляции прогнать Вот это улучшение то сильно он он ускоряется да у нас получается у нас Франкенштейн получается интайм и и есть вот компиляции с я понял Нормально Можно да можно да за Давайте здравствуйте Спасибо за доклад Владимир Зайцев Арена дата А я хотел уточнить Чем всё-таки вам так вас так не устроил дагер 2 он сильно сильно сильно ухудшает время компиляции прям вот настолько прям настолько сильно Да мы думали на том вообще стоит выпиливать или нет но у нас если я не пом не ошибаюсь минут 20 собиралось приложение и для Android приложение это достаточно много и и это сильно влияло на на то как разработчик выкатывает фичу Потому что когда ты нажимаешь на кнопку П сидишь 20 минут уже не хочется ничего что делать Не ну 20 минут Понятно спасибо И второй вопрос Если можно вы говорили про стекко машину да Но это же просто это относится к хотспоте код транслируется в байт код для другой машины и она даже вроде как регистровая очень хороший вопрос Да я кстати про него даже забыл да кто не знал сво виртуальная машина которая называется и она не использует к она использует регистры но когда ты берёшь свой код на Джаве или на котлине и пытаешься создаёшь из него ПК сначала этот код перегоняет в jav код Вот на этом этапе мы как раз и внедряем изме после этого происходит компия в ставишь ап кашку на на своё устройство там уже переходит компиляция из Да кода в нативный код Так что в Андроиде Аж три этапа компиляции не знаю возможно действительно там тем более приложение большое много факторов влияет которые на скорость Следующий вопрос по центру Добрый день ещ раз спасибо за доклад очень интересный как я понял вы для модификации кода на этапе компиляции Используйте возможности системы сборки а не было попыток через механизмы компиляции через какие-то экстеншн компиляции или процессоры аннотации или вообще каким-нибудь ещё образом вмешаться именно в процесс непосредственно компиляции а не постпроцессор аннотации тут не подходит потому что они Понятно иные экшены не я говорил что была идея с делать через компилятор ой через плагин компилятора котлен но у нас не было ни у кого опыта с этим вообще на самом деле это вот самое идеальное решение реально будет через компилятор через плагин компилятора потому что можно будет поддерживать несколько платформ потому что котлен компилируется не только в gvm а Но мы его как-то быстрое решение набросали которое работает через систему сборки работает оно вообще отлично стабильно Спасибо У нас есть вопрос опять первый ряд да идут с другой стороны с правой части зала Я до вопроса ещё напомню у нас пока нет вопросов из онлайна ребята задавайте вопрос в онлайне если что подарок нашу кастомизированный матрёшку можно получить даже если вы задали вопрос из онлайна вот пожалуйста у меня просто вопрос был Я не совсем понял вот зачем было вообще трогать вот эту компиляцию то есть во-первых хоче сказать что отличный доклад Просто мне не совсем было понятно Вот именно зачем было то есть там вот то что показывался код Допустим можно было сделать с помощью допусти вот какого-нибудь файл маппинга То есть у вас есть название класса строка и допустим строка Ну название то есть название класса интерфейса который вы хотите допустим имплементировать и дальше идёт именно указание класса опять-таки Factory этот файл можно Вычитать допустим на этапе запуска приложения допустим проанализировать его как-то и загружать То есть тут мне былом совсем непонятно было Зачем нужно вообще было городить всё это дело заморачиваться с байт кодом там сильно сильно далеко там А в самом начале Ну да ну то есть есть что-то типа вот SPI допустим такие вот вещи как бендерский эндерс Ну да то есть не нуно в целом если что у нас будет дискуссионная зона можно будет там прямо ноутбук открыть собой Ну и в принципе у меня был как раз вопрос под я специально во время презентации перечитал ещё статью на Александра мироновиче это ваш наверное этот сотрудник и там тоже вот буквально один абзац был почему дагер не подходит И как раз вот ну вы уже ответили человеку то что вот он работает слишком медленно компилируется А в принципе так что вопрос Вы говорите что вот этот этап можно сделать вещ Ну то есть у вас Допустим можно это выгрузить в один файл который вот строка это вот название класса и который вы хотите допустим Factory для которого запровадити потом сам этот класс тайн Ну то есть мне проще поэтом будет объяснить это всё я думаю обсудим но я думаю что можно будет прям показать мы выйдем в дискуссионную зону и вот третий ряд девушка прямо рядышком спасибо спасибо за доклад у меня такой вопрос Вот вы говорили что метрики получается поднятия приложения стало быстрее кого е раз Ну то что приложение стало быстрее запуска вотре какие-нибудь метрики как-то повлияли может что-то замедлилось что-то ускорилось другое нет больше ничего чего то есть быстро стало подниматься приложение Да успех конечно Ну вообще-то в целом Да не У нас конечно есть метрики на открытие разных экранов но они никак не изменились я понял окей ребят ещё вопросы не вижу рук всё да мы завершаем с вопросами Хорошо сейчас я быстренько проверю онлайн Да потому что я обещал матрёшку в онлайн чат не проверил О'кей вроде вопросов нету тогда Григорий самое приятное выбираем самый лучший вопрос самый лучший вопрос тут два человека Алексей и Владимир Почему в два Ну задавали по очереди зада Владимир Владимир Владимир Да всё хорошо байт код Спасибо большое Ну и конечно у нас для тебя тоже есть подарок от конференции сейчас мы тебе его вручим Большое спасибо за доклад Было очень классно И от меня большое класно выступать Аплодисменты ребята"
}