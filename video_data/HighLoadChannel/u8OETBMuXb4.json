{
  "video_id": "u8OETBMuXb4",
  "channel": "HighLoadChannel",
  "title": "Go в Domain Driven Design / Дмитрий Анисов (GS Labs)",
  "views": 250,
  "duration": 2611,
  "published": "2024-10-29T02:48:13-07:00",
  "text": "я приглашаю на сцену Дмитрия для продолжение этой темы Всем привет Меня зовут анисон Дмитрий и мы сегодня поговорим о дой дри дизайне А в частности О тактическом проектировании как организовывать код Как писать архитектуру И как это всё устроено в го и не только давайте пару фактов обо мне Я являюсь ведущим энд разработчиком компании JS labs Наша компания занимается разработкой для цифрового ТВ И в частности одним из наших клиентов является Триколор я пишу ногой пайтоне а также занимаюсь девопсом за свою карьеру Я пописал как большие сложные монолитные системы так и маленькие микросервисы и понял что Спустя какое-то время наш код превращается в такое понятие как большой ком грязи И с ним достаточно Трудно работать особенно если вы хотите что-то поде менять и так далее и первый вопрос который я хочу вам задать кто сталкивался вот с таким понятием как большой ком грязи когда вы правите что-то в одном месте а ломается в другом поднимите пожалуйста руки Отлично вот как раз ддд нам поможет с этим и посмотрим далее как оно это решает и как раз благодаря ддд В текущей компании я смог сократить разработку и поддержку новых сервисов с помощью данной методологии для начала опять же к вам вопрос Кто знаком с ддд кто уже его писал у себя на продакшене Покажи поднимите пожалуйста руки Угу А кто слышал отлично ещё лучше супер А ну давайте для начала повторим ддд - это подход к разработке программного обеспечение А и он нацелен в первую очередь на бизнес-требования а не на технические детали допустим у нас м как обычно мы делаем мы думаем какую базу данных мы будем использовать как сервисы будут общаться между друг другом и так далее а ддд не про это он про то что мы должны оперировать бизнес сущностями бизнес правилами общаться с экспертами предметной области и вот такая Синергия разработчиков и экспертов приводит к хорошему программному продукту Когда стоит использовать domain driven Design ddd - это не серебряная пуля конечно же и у неё есть определённые зоны когда мы его можем использовать и в первую очередь одна из Больших зон это то что вы должны его использовать в наиболее важных областях бизнеса там где наиболее важная ценность конкретного вашего продукта но это не всегда возможно извиняюсь Это не всегда возможно Потому что м иногда то что является максимально ценным не должно быть написано в ддд потому что это сложная инфраструктурная задача Но если у вас есть какой-то какая-то м предметная область или ограниченный контекст где очень часто меняется бизнес-требования постоянно то в этом случае конечно же нужно писать в ддд и вы сможете улучшить А ваше по а конкретно вы сможете улучшить из-за того что вы будете уверены что ваш код соответствует вашему бизнесу потому что вы описываете те же самые сущности те же самые бизнес правила это всё вы описываете и ваш код точно соответствует и в конце концов когда вы будете писать в таком подходе в рамках всей компании онбординг новых сотрудников будет сильно упрощёнке в рамках одной компании будут переходить из одного отдела в другой это будет значительно лучше потому что вы будете писать код примерно одинаково но ддд имеет определённые проблемы и когда я начинал проектировать я с ними столкнулся Я думаю что с ними столкнётся и вы и Давайте их Обсудим в первую очередь м Когда вы читаете Эти прекрасные статьи смотрите м определение у вас возникает вопрос А как же проектировать код как он должен быть структурирован как он должен выглядеть как он должен взаимодействовать эти все вопросы актуальны А всё это возникает из-за того что нет какого-то единого стандарта и есть различные архитектурные стили и по итогу у вас возникает вопрос А где же писать бизнес-курс от фреймворка и технологий чтобы а оперировать Только бизнес сущностями и вы в конце понимаете М что это долго и дорого может быть не стоит использовать наш ддд А тут хочу подчеркнуть что поначалу пока Вы не привыкли пока Вы не написали пару сервисов это будет сложно и долго но потом поддержка развитие создание новых сервисов будет проще и о чём же сегодня пойдёт речь в докладе в докладе в первую очередь речь пойдёт о тактическом проектировании и о том как организовать внутреннюю архитектуру сервиса под внутренней архитектурой сервиса я понимаю Не только шаблоны и паттерны проектирования которые используются а то как он структурирован как он выглядит Как он используется Какая идея в нём заложена это всё и есть внутренняя архитектура сервиса мы посмотрим на организацию кода на примере одного сервиса который является сервисом который формирует плейлисты для пользователей и конечно же отвечу на самые частые вопросы которые возникали у меня в процессе работы с этой методологией и предоставлю общую информацию Извините с чего же начать начинаем Мы с двух конечно же вещей стратегическая проектирование и тактическое проектирование стратегическое проектирование мы сегодня рассматривать не будем оно было рассмотрено частично в прошлом докладе мы сделаем акцент на тактическом проектировании но есть маленький нюанс в стратегическом проектировании не только вот первые два пункта но ещ и выбор архитектурного стиля Почему Потому что если вы не выберете архитектурный стиль в рамках своей компании то когнитивная сложность проекта сильно возрастёт у каждого разработчика и команд разработчиков есть свой подход свои идея кто-то разобрался лучше кто-то хуже и Поэтому возникает проблема что каждый разработчик или команда пишет код по-разному когнитивная сложность возрастает и для того чтобы её уменьшить в стратегическом проектировании Вы должны сделать некий шаблон сервиса который будут использоваться внутри вашей команды компании и так далее тактическое проектирование оно конечно же сложнее стратегического и оно работает в рамках ограниченного контекста Ну допустим пользователь корзина товар это всё ограниченные контексты вашей предметной области могут быть и вы используете определённые шаблоны проектирования мы сегодня их рассмотрим не полноценно точечно а Посмотрим как они взаимодействуют в коде как они реализовывается как они работают выбор Ахи туры Это первый вопрос который с которым вы Тесь и какую же архитектуру выбрать насколько большие различия это три популярные архитектуры Давайте на них посмотрим сначала очень быстро гексагональная архитектура луковая луковая и чистая архитектура вопрос есть ли большие различия между ними Ну на самом деле Вот так на первый взгляд не кажется и это не просто так в первую очередь надо немножко истории в 2005 году появилась гексагональная архитектура она стала самой первой она основана на портах и адаптера и была про родительница в 2008 году появилась луковая архитектура она стала максимально объёмной полноценной на следовала идея гексагональный И позволила действительно хорошо реализовывать сервисы писать сложный код объёмный код А главное она хорошо разграничивать слои и в 2012 году дядюшкой Бобом была представлена чистая архитектура она была основана на идеях луковой но немножко по-другому называла слои по-другому была реализована и была самое главное шина хорошо подходила для микросервисов но для каких-то более больших чуть-чуть больших сервисов где сложная доменная логика она уже не так идеально подходило и конечно же я вижу это следующим образом я знаю что тут много людей кто пишет в чистом подходе а но почему я это так вижу а мы развились до Луку архитектуры и она предоставила предоставляла нам огромное количество возможностей где описать бизнес логику как структурировать в чистой же архитектуры это всё дело упростили опять же если вы уже используете чистый подход и вы пишете код с помощью этой архитектуры это уже круто вы уже используете шаблоны вы проектирование вы уже а используете стратегическое проектирование и ваш код действительно выглядит хорошо и правильно но зачем нам соглашаться На меньшее если мы можем использовать большее архитектуру которая позволяет нам хорошо писать как маленькие сервисы так и большие Давайте сначала обсудим для начала чи минусы чистой архитектуры Какие же у неё есть минусы вот мы можем посмотреть на слайды и увидеть что Да понимаю немножко мелко но извиняюсь а то что мм Она имеет общие принципы но выглядит по-разному везде немножко И самое главное вы не видите тут чёткого разграничение слоёв м и к чему это приводит к тому что в корне как на скриншоте пять могут появиться адаптеры А в первом скриншоте там лайзер какие-то непонятные то есть нет какой-то единой структуры она может расширяться как вот очень сильно расширяться это не очень здорово м также э непонятно где находятся интерфейсы у всех они находятся в разных кто-то выделяет в отдельную директорию кто-то пишет прямо в корне кто-то пишет интерфейс рядом с имплементации и всё это приводит к тому что нарушается принцип зависимости и скорее всего ваш код опять же может превратиться в большой ком грязи если за этим хорошо не следить и тут могут быть такие проблемы я это подчеркиваю конечно же наиболее важной вещью является то что вся бизнес логика в таком подходе находится исключительно в одном месте вке в том что вы не можете разделять бизнес логику если она вас сложная вы не можете её правильно представлять следующий минус который также часто используется в чистой архитектуре это Амина модель данных то есть модель данных без поведения это тоже считается антипаттерны Зачем нам нужен единый стиль Я хочу сначала задать вам вопрос кто сталкивался с такой проблемой что вы работаете там в компании и у разных разработчиков у разных команд абсолютно раз подход абсолютно разный архитектурный стиль вот поднимите пожалуйста руку кто с этим сталкивался думаю это не очень приятно и каждый раз Вам приходится заново разбираться что же там ра работает Как это работает Как это структурировано и у вас возникает вопросы почему так и вот для того чтобы это решить Я сегодня и говорю про луковый подход про ddd как раз он нужен для того чтобы внедрить новых разработчиков было максимально легко Особенно если это разработчики в рамках одной компании это приведёт к к единообразию а ну и конечно же к лучшему проектированию к поддержке и созданию новых сервисов Давайте наконец-то посмотрим на код а тут хочу сделать определённую оговорку то что свои идеи я взял из книги вон Верона Я основывают на идеях вон Верона и не просто так когда я задался вопросом а как же мне правильно спроектировать Мне нужно было опереться на что-то действительно стоящее и то что используется в мире давно и действительно зарекомендовало где есть ответы на мои вопросы и книга ворона мне в этом помогла Давайте посмотрим на мою структуру проекта с лева представлен код на го а посередине код на питоне В чём плюс в том что Несмотря на то что это разные предметные области разные ограниченные контексты соответственно код очень похож И когда вы пишете в рамках одной компании разный код на разных языках в разных предметных областях Вы можете очень легко между ними переключаться вам не нужно вспоминать каждый раз что же там происходит Как это работает Как взаимодействует когнитивная сложность снижается в этом большой плюс Также вы сможете увидеть чётко разг с то что тут нет как в чистой архитектуре бесконечного количество непонятных папок структурированных тут Есть конкретные слои Application до инфраструктура и entation основные слои они констант никогда не меняются в этом плюс данного подхода Давайте посмотрим на упрощённую последовательность вызова сначала в слой приходит польский запрос Он обрабатывает данные и получает данны какие-то от пользователя от другого сервиса неважно он эти данные переда который начинает исполнять некоторую бизнес логику а также является нашим дирижёром там происходит валидация создание сущностей агрегатов там идёт непосредственно работа с со сторонними базами данных со сторонними сервисами и конечно же всё это крутится вокруг домена вокруг наших предметных сущностях наших доменных объектов и вот таким вот образом вся эта система вот на Верхнем уровне работает а теперь разберёмся с каждым слоем первый слой доменный слой там находятся Тити агрегаты и конечно же могут ходиться могут находиться доменные сервисы и безусловные интерфейсы Давайте посмотрим на структуру слоя мы видим это же отражение абсолютно тут у нас есть домен У нас есть ти интерфейсы и сервисы если вам кажется это избыточным и у Вас совсем маленький сервис там на пару тысяч строк кода Вы можете это упрощать то есть ваша основная структура она не поменяется но в домене вы можете написать только interf gog И тем самым эта архитектура будет хорошо подходить под самые маленькие сервисы но также и под большие первый что мы обсудим Первое - это Тити и агрегаты наши доменные объекты и тут сразу вопрос к вам как думаете В чём тут ошибка вот что тут сделано не так это было немножко обсужден и на прошлом докладе Да структурные теги структурных тегов быть не должно потому что иначе мы завязываем нашу логику домена на логику КТУ То есть как нашему доменному объекту быть преобразованы в ту или иную сущность или обратно в таком подходе плохо то что когда вам понадобится изменить какую-то логику инфраструктуры вы будете менять ваши доменные объекты то есть документация они у вас не меняются а тут меняются Поэтому вот так вот завязывать не стоит Но я не просто так привожу данный слайд тут потому что у нас возникает определённый нюанс то что такой подход часто используется его можно часто найти на просторах интернета в компаниях и так далее не просто так это удобно безусловно и если вы используете для того что это удобно Вы должны просто помнить в будущем что такой код стоит ареф вынести это всё в д тошкини это всё в антикоп Леры в какое-то другое преобразование чтобы этого избежать Но если вам нужно для простоты это сделать Вот вы скорее всего достаточно часто можете это увидеть но опять же стоит об этом помнить и стоит таких ошибок желательно не допускать агрегаты У меня всё находится в рамках сущностей агрегаты в данном сервисе не используются и Многие могут спросить Нужны ли нам вообще агрегаты агрегаты - такие большие доменные объекты которые состоят из нескольких сущностей и у меня ответ прост если вам агрегаты не нужны Вы можете их не использовать работать только с помощью обычных сущностей это подтверждает и мой опыт и опыт соответственно вон Верона А следующий вопрос который мы обсудим - это нимич или немич или не анемия модель данных анемия модель данных - это это модель данных без поведения то есть модель данных доменный Объект который не имеет никакой бизнес логики это считается плохим подходом Почему если вы решите выносить определённую бизнес логику в другие места допустим в доменные сервисы или в юзкейс как в чистой архитектуре часто используется то вы нарушаете ваши бизнес-процессы Потому что если ваша сущность должна знать как сменить статус Или допустим как сгенерировать какой-то айди ник или ещё что-то она должна это делать и не нужно выносить логику в какую-то другую часть положение тем самым нарушая некоторые базовые принципы потому что вы потом не ну не будете понимать почему вот в документации там в разговорах с бизнесом у вас конкретная сущность как-то меняется что-то с ней делается а логика находится не в самой сущности а в каком-то другом месте и вот тут могут быть проблемы доменные сервисы доменные сервисы в них находится непосредственно наша бизнес-карте которая возвращает экземпляр структуры куда внедряются определённые зависимости в данном случае интерфейсы или другие доменные сервисы это один из подходов и как раз в доменных сервисах мы пишем уже какую-то нашу самую важную самую главную бизнес логику Вот она находится в домене А в сервисах вот так вот это всё дело структурировано второй пример А вы можете спросить а обязательно чтобы наши доменные сервисы зависели от других интерфейсов других доменных сервисов на самом деле нет И такой подход Я предпочитаю больше потому что а он буквально на да ну сейчас на данный момент мне удобнее Я выношу в доменные сервисы только самую важную самую основную бизнес-курс со сторонними системами службами базами данных Я выношу в Application сервисы О чём пойдёт речь и такой подход Я сейчас более предпочитаю и благодаря такому подходу Вы можете очень хорошо тестировать ваш код в разных местах интерфейсы это как всем вам известно просто контракты которые описывают взаимодействие со сторонними системами базами данных службами и так далее и они также находятся в домене в доме слое в папочке interfaces или могут быть чуть выше просто ией то Go если у Вас совсем маленький сервис А тут думаю достаточно просто Ну понятно то что мы пишем контракт как мы взаимодействуем с сторонними компонентами А где же нам эти интерфейсы реализовывать И для этого есть инфраструктурный слой где мы будем уже реализовывать нашу логику по взаимодействию с сторонними системами базами данных службами Давайте на неё посмотрим таким вот образом выглядит структура слоя у нас есть infrastructure и у нас в ней находятся репозитории и сервисы А как же выглядит наконец-то код код выглядит следующим образом он похож у нас также есть функция конструктор которая а создаёт экземпляр структуры которые соответствует данному интерфейсу И в чём плюс вообще подхода с точки зрения интерфейсов и такого разделения Мы точно знаем что интерфейс у нас находится в домене а реализация в совершенно в другом месте благодаря этому ваша допустим общение с базой данных или со сторонним сервисом К тому же это легко тестировать Вы можете спокойно тестировать разные реализации по-разному это всё дело подключать и самый большой плюс допустим если к вам приходит прокт менеджер или там тимлид и говорит А давайте мы изменим взаимодействие с нашей сторонней системой с http на grpc в этом подходе ваш контракт останется таким же абсолютно одинаковым но при этом реализация изменится И тем самым Вы можете даже в зависимости от тестовой среды подключать раз реализации и очень удобно с этим работать самое главное конечно как я говорил тестировать Application layer Это следующий слой Где самое важное - это Application сервисы Давайте на них немножко посмотрим Ну и структуру слоя она выглядит вот таким вот плоским фрагментом и если вам нужна большая структура Вы можете это сделать как я говорил основная структура приложения не поменяется и в зависимости от масштаба сервиса Вы можете либо её расширять либо уменьшать таким вот образом Вы можете работать а следующее мы как раз рассмотрим Application сервисы тут ровно такой же способ как и в доменных сервисах Application сервисы принимают в себя некоторые зависимости и у него у этого Application сервиса есть определённые методы которые выполняют ту или иную бизнес логику И как раз благодаря вот такому разделению Вы можете на разных этапах по-разному контролировать вашу ваш бизнес-процесс что-то в доменах сервисах что-то в алике сервисах А самое главное Application сервисы также не зависит от какой реализации они зависят только от интерфейсов и вот таким вот образом они также через функцию конструктор создаются второй пример А я ва тут специально привожу Потому что у нас был пример с доменным сервисом где у нас доменный сервис не зависит от сторонних систем компонентов служб баз данных и так далее и вся эта логика выносится конкретно в Application Service как раз туда выносятся все зависимости туда внедряются все вот эти а компоненты и уже в самих х Мы с ними взаимодействуем мы какие-то данные получаем обрабатываем производим какую-то бизнес логику и вс вот у нас вот работает через какие-то определённые методы у данной структуры и у вас может возникнуть вопрос конечно же логичный А как же лучше делать что выносить куда вот мы проговорили про доменные сервисы Про алике Сервис и про амину миную модель данных ТХ каких-то правил Конечно же нет но я выделяю онные рекомендации работаю конкретно с нашими базами данных сторонними системами компонентами публикую события в доменных сервисах Я выношу ту бизнес логику которая не может быть написана в са самой модели данных и та бизнес логика которая является максимально важной максимально нужной для вашего бизнеса которая должна быть хорошо протестирована а в не анемий модели данных в самих методах сущностей или агрегатов я непосредственно реализую те правила которые касаются конкретно данных сущностей данных а объектов и в чём самый большой плюс данного подхода в отличие от чистой архитектуры Вы можете соответственно в данном подходе писать бизнес логику в разных местах тем самым по-разному её группировать по-разному тестировать и выбирать самостоятельно как этот человек а в это на этой картинке где же нам писать нашу а бизнес-курс но у вас скорее всего может возникнуть логичный вопрос А где же это дело всё собирается вот у нас есть доменные сервисы там Application сервисы должно быть внедрение зависимости где зависимости нужно внедрять для этого я выделяю специальный компонент он называется registry вообще в Go часто принято это всё выносить там в main.go или в какой-то другой файл или бывали примеры что можно это всё дело создавать прямо При запросе от пользователя собирать а нужный компонент Но я выделяю это в рест и именно в стри я это всё реализую Давайте посмотрим Это самый базовый самый простой пример всё работает через нашу функцию конструктор куда внедряются все зависимости и мы соответственно дальше получаем а при старте сервиса готовый экземпляр и дальше Мы можем с ним работать но если вам нужна более сложная логика допустим как я говорил у вас есть клиент на jpc и у вас есть клиент на http Это один и тот же контракт они выполняют исполняют А и реализуют точнее А и вы хотите в зависимости от а допустим переменных окружения там тестовой среды там ещё каких-то определённых нужных вам задач реализовать там м разное подключение и с помощью вот такого способа Вы можете с помощью условий переменных окружения реализовывать подключение разных соответственно а репозиториев там или других инфраструктурных вещей следующий слой и последний в данной схеме - это слой pres presentation как я говорил в самом начале Вы не должны зависеть ни от фреймворка ни от технологии ни от чего-либо ещё в данном плане и как раз слой позволяет вам это дело реализовать Давайте посмотрим на этот слайд У нас есть допустим F который у нас принимает польский запрос что он делает он принял польский запрос минимально точнее вытащил оттуда польские данные и дальше передал их в инсу бизнес логику Али сервиса и там непосредственно происходит вся основная работа то есть публикация событий обработка бизнес логика общение со сторонними системами и так далее И если к вам допустим придёт прокт менеджер и скажет А давайте-ка мы сделаем jpc вы скажете Окей не проблема в entation создаёте Новую директорию jpc И что Какая у вас стоит задача Вы должны просто взять польский польские данные независимо от технологий там от фреймворка и так далее Вы должны просто польски данные дальше их минимально отваливаться вся основная валидация там будет создание объектов и вся основная наша бизнес логика вот таким вот образом вы можете это всё дело компоновать по-разному и Давайте посмотрим теперь в итоговую схему и обсудим вот полноценно как это дело всё работает чтобы было ещ лучше понятней на Первом шаге У нас есть слой и там ну неважно Какая технология используется неважно какой фреймворк вы получаете польский запрос entation идёт в registry и там уже непосредственно берёт готовую структуру у готовой структуры мы вызываем определённые бизнес методы и вы эти бизнес методы уже исполняют нашу логику он они идут в инфраструктурные сервисы тут подчеркну что инфраструктурные сервис это не только сервисы там сторонние но ещё это может быть допустим валидация gvt то что не является ва основной бизнес логика и то что является неким техническим компонентом он идёт в репозитории получает оттуда данные далее он может идти в доменные сервисы Если они у вас есть как-то минимально эти данные валидировать обрабатывать что-то производить и у него получается какой-то там ответ и также он может публиковать события далее Когда у вас появился вот этот ответ вы отдаёте это всё дальше на шаг один и в слое entation непосредственно Вы уже преобразуете в нужный формат ответа вашей технологии идате пользователю ответ и вот таким вот образом вся эта система и работает Давайте теперь обсудим один самых частых вопросов которые возникают по ddd А как же работать нам с транзакциями и тут есть три основных правила а два хороших и одно Ну такое среднее назовём его так первое конечно же транзакция должна быть в рамках одного агрегата То есть у нас есть какой-то агрегат или сущность и она тракционное непосредственно у нас в какую-то базу данных и там у нас транзакции всё это дело работает но у вас может возникнуть вопрос А что делать если бизнес требует чтобы два агрегата совершенно разных сохранялись одновременно такие ситуации могут быть допустим удобство польского интерфейса и вы можете придумать а давайте создадим один большой агрегат который состоит из других агрегатов но тут так делать конечно же не стоит потому что скорее всего в вашем подходе что-то неправильно из-за того что вы начинаете создавать какой-то лишне агрегат который не соответствует Никакому а доменному объекту какой-то бизнес сущности вы его создали исключительно для а ваших технических нужд и поэтому скорее всего вы делаете что-то неправильное и так делать не стоит Но какой же у нас тогда есть вариант конечно же передача транзакций через контекст этот подход не очень сильно люди любят потому что а контекст начинает влиять на наши как бы бизнес-плане дрт какой-то технический компонент а техническую сущность в наши методы поэтому транзакции в таком плане не любит но сам н Верон и в том числе я этот подход использую только в его книге как и допустим на моих сервисах на питоне используется декоратор transaction и там это работает именно через декоратор и работает под капотом в Гонг Мы это можем реализовать через контекст и конечно же наверное самым интересным принципом является принцип итоговой согласованности А и он конечно же тоже спорный потому что в каких-то бизнесах он Хорошо подходит а каких-то вообще невозможно вам нужна транзакция это то что вы должны обсуждать с вашим прожект менеджером с вашим бизнесом насколько принцип и того согласованности возможно возможен В вашем проекте и также вы должны понимать что в этом случае когда вы публикуете какое-то событие и другие сервисы или этот же самое Это событие подхватывает и обрабатывает создаёт новые агрегаты новые сущности Вы должны понимать что транзакция Ну точнее итогово согласованность Может быть достигнута как сразу ну плюс-минус так и через 10 секунд так и через час а так может быть не достигнуто никогда И вам нужно что-то как-то откатывать эти транзакции и что-то с этим делать это то что вы должны обсуждать с бизнесом насколько В вашем случае это уместно но этот подход наверное один из самых интересных и самых используемых в ддд М что же по итогу почитать я ссылался в этом докладе очень часто на книгу вон Верона Всем советую вы сможете найти большое количество ответов на свои вопросы конечно же Эрика эванса А давайте подведём краткие итоги что же мы сегодня с вами разобрали мы разобрали а зачем нам нужен ДД мы разобрали его плюсы и минусы и конечно же мы посмотрели на архитектурный стиль на то как код организован как он разбивается на слои мы ответили на самые частые вопросы нужно Нужна ли нам допустим анемия модель данных или не нужна Нужны ли нам структурные теги как я сказал Конечно же лучше их не использовать мы разобрали такие важные вопросы где нужно писать бизнес логику там в доменных сервисах а апликейшн сервисах или в Неа немич модели данных а также разобрали важные вопросы такие как как не зависеть от фреймворка и протокола и как работать с транзакциями Я надеюсь что вам понравился мой доклад буду рад очень сильно оценкам А И надеюсь вы будете использовать данный подход у себя в компании Всем спасибо за внимание у меня на этом всё спасибо большое за доклад Есть ли в зали вопросы если есть Пожалуйста поднимайте руки к вам подойдут с микрофоном задавайте ваши вопросы в микрофон держите его близко Кок рту Говорите пожалуйста Чётко и ясно Не давайте сразу два микрофона в руки чтобы у нас два человека не разговаривали одновременно Давайте начнём с того вопроса так как молодой человек поднялся а потом перейдём к вам У нас маленькая Техническая заминка с тем микрофоном Давайте передадим слово и потом сразу же вернёмся раз раз раз слышно Привет Меня зовут Денис у меня парочку философских вопросов тебе по всему этому Вот предположим у меня вот есть некий сервис который написан на Clean architecture да Вот хотелось бы подумать как можно перенести его на домейн и пожалуй первый вопрос - Это чем всё-таки домейн отличается от кейса да то есть Понятно Ну смотрите если вы используете Клин архитек это уже ddd это надо первый понимать Это просто разные подходы У нас есть луковая архитектура У нас есть чистая архитектура архитек и вот как же это дело всё переписать А вам нужно вот ваши кейсы зайти и посмотреть какая у вас там бизнес-карте что у Вас какая-то бизнес логика должна быть точно вынесена в сами сущности это первое что нужно перенести второе у вас появился вот такой вот юзкейс чуть сократился и с ним нужно тоже что-то делать а и вы начинаете разделять во-первых в зависимости от объёма сервиса если он у нас большой там сложная предметная область и так далее вы вот то что является самым основным самым важным для бизнеса выносите в доменные сервисы в доменные сервисы А в кейсах вы оставляете общение с базы данных с репозитория с валидация публикацию событий и как раз какую-то небольшую может быть бизнес логику тоже можно оставить но основную самую важно выносите в доменные сервисы Да хорошо но просто общение с базой данных это уже немного другой уровень это уже слой пониже доменного должен ити это рери именно через интерфейс обща из базы данных То есть вы внедряется зависимости и уже общаетесь с базой данных Вот это идеальна подводка к моему второму вопросу А почему интерфейсы репозитория должны находиться в домене а не в репозитория а потому что если мы посмотрим на вот эти прекрасные наши картинки а и м поймём что наш домен вот если вот прямо именно с точки зрения теории он как раз должен иметь в себе сущности интерфейсы и бизнес-планов же там оказались интерфейсы они оказались там не не просто так и в первую очередь потому что они также являются тем логическим элементом который позволяет исполнять вашу бизнес-курс логику И он должен взаимодействовать с другими сервисами и оттуда забирать данные исполнять что-то у них тоже есть какие-то методы и это вот всё общение оно как раз как бы проектируется и оно должно находиться в именно в домене вот как-то так могу ответить на а то есть краткая сари то что опять же интерфейс взаимодействия Сними элементами будь тот же rpc будеь то - это часть бизнес логики верно нет не важно как Какая технология используется если там gpc htp имплементация не важна Она имплементация находится в слой infrastructure А в домене просто контракты вот я про контра знаете Вы знаете я прям чувствую что это диалог это интересный диалог но диалог - это про дискуссионную зону Давайте философские вопросы и дальнейшие рассуждения на эту тему перенесём в дискуссионную зону также я вас очень прошу когда к вам обращаются наши хелперы Отдайте пожалуйста микрофон Отдайте им микрофон это значит что кому-нибудь это нужно Спасибо большое Давайте перейдём к тому вопрос Который изначально задавали Здравствуйте Большое спасибо за доклад очень интересно А вы в своём докладе упомянули такой термин как ограниченный контекст хотя в принципе в структуре проектов на скриншотах вы этого не показали несколько контекстов Я имею в виду только один контекст всегда был представлен но допустим у нас проект состоит из нескольких контекстов и мне интересен вопрос использования одного контекста внутри второго Обязательно ли для этого нужна какая-нибудь третья сущность шина или вообще недопустимо там использовать один контекст внутри второго в моём подходе Я конечно же разделяю всё на микросервисы то есть у меня есть микросервис с одним контекстом микросервис с другим контекстом и они как бы взаимодействует Но если вашем как бы приложении Нужно сделать два контекста это конечно же сделать можно но с Но это будет выглядеть достаточно странно потому что у вас будет один контекст В одной папке и в другой папке другой контекст с такой же структурой и между ними может быть шал как в теории и между ними будет общение через какую-то шину то есть самая основная задача ограниченного контекста в том что если вы его пишете реализуете в коде в рамках одного допустим Като там одной большой системы вынести его в будущем для вас не должно стать никакой проблемой вы просто её выносите и у вас всё работает а вот и поэтому вот таким вот образом можно это дело разграничивать Но я конечно же рекомендую Ну разделять это всё на разные сервисы конечно Спасибо большое Я Напоминаю что вопросы Также можно задавать в чат по QR коду если будет Вопрос задавайте Я его зачитаю если он будет интересный внутри чата с хэштегом вопрос Без хэштега вопрос Мне будет очень сложно его найти сейчас вопрос зала Андрей Наумов ядро Спасибо за доклад У меня вопрос на последней схеме скажем так у тебя получился циклический ты не видишь в этом проблему при тестировании и собственно при расширение вот между 1 2 и 3 нет не вижу Потому что он Берт из сервиса наши функции которые создают нам структуры и соответственно у нас при старте сервиса У нас есть просто готовая некая структура и в первом шаге Мы у неё уже вызываем методы То есть это вот да у неё есть некая такая цикличность но ну на графике Но на самом деле её нет потому что у нас вот в регистре Мы создали структуру в первом шаге мы пошли туда за этой структурой вызвали у неё бизнес метод и уже передали туда данные и обратно из сервиса возвращаются просто данные какие-то объекты ти сущности агрегаты это может быть д Тошка это может быть презентер то есть есть несколько вариаций возвращения данных я забыл Это в докладе самом сказать вот таким вот образом это работает Спасибо большое из первого ряда есть вопрос Привет Игорь пандекс Спасибо большое за доклад смотри мы знаем что в чире есть это переходы между слоями подскажи пожалуйста в й архитектуре где вот эти переходы расположены Ну грубо говоря где ты перемалювати либо в обычных каких-то а объектах либо вот в энтити агрегатах сущностях д Тошка Но если допустим мы у нас есть инфраструктура и она обращается к стороннему сервису и получает оттуда данные в самом реализации Ну вот этой инфраструктуры каком-то репозитории конкретном я беру данные сторо стороннего сервиса и их уже там перемалювати или агрегат вот таким вот образом спасибо а поднимите пожалуйста руки у кого есть вопрос Да я вижу Вашу руку Не волнуйтесь просто на всякий случай проверяю количество вопросов в зале чтобы мы не отставали по тайминга вопрос Спасибо за интересный доклад вопрос вот такой вот представим ситуацию что нам необходимо добавить какое-то поле в модель и Ну это По всей видимости придётся сделать проделать какую-то работу на каждом из слоёв и во входной модели и в домене и в базе данных и в репозитории как это вообще всё провернуть аккуратно и безопасно и вторая часть вопрос как это вообще сочетается с принципом единой ответственности о том что код меняющийся поно причине должен быть рядом Угу Ну вот отвечу сначала на первый вопрос то что вот если вам нужно добавить какое-то поле и нужно понимать это техническое поле или бизнес поле это первое А если это действительно бизнес поле остановимся на этом варианте А вы добавляете М допустим у вас есть общение с базой данных вы добавляете его сначала в сущность или агрегат вы его добавили А дальше в самом инфраструктурным слое Когда вы получаете данные из базы данных вы также ну вытаскивайте это поле и когда инфраструктура создаёт некий агрегат или сущность А там же вот внедряется это поле у вас получается что что в домене образовывается вот полностью Ну соответственно вашей там документации сущность и дальше эта сущность она отдаётся А в сервис А и из сервиса она уже отдаётся на слой первый на слой pres presentation и там она преобразовывается в нужный там формат вид ответа клиенту это поле может быть названо там по-другому как-то е о Может быть там ну короче просто названо по-другому в зависимости там от технологии от того какой у вас API и прочее вот таким вот образом а принципа единой ответственности Ну я в данном случае ну не вижу как бы проблемы потому что мы крутимся вокруг нашего домена наш домен - это самое важное наши сущности вот в Тити в доменном слое Они самые важные А как у нас эти данные представлены в базе данных нас не волнуют потому что данные могут быть по-другому реализованы браться из других баз данных там сторонних каких-то систем и вот мы в самом сервисе это всё дело как бы собираем и формируем и отдаём дальше Спасибо ответили на вопрос супер Есть ли ещё вопросы в зале Если есть поднимите пожалуйста руку а пока я прочитаю вопрос из чата со Сколькими агрегатами могут взаимодействовать доны один сервис оперировать несколькими агрегатами через их репозитории с несколькими агрегатами Нет не может один репозиторий один контракт один агрегат хорошо спасибо есть вопрос ещё из первого ряда ряда Это было слово реад да Привет ещё раз вопрос такой На каком слое происходит инжект и экстракт транзакции которые в контекст засовываю и достаём Как правильно это делать В текущей архитектуре в данном случае как я сказал всё работает через контекст А и как раз вся вот если Точнее я отвечу двумя пунктами если мы работаем в рамках одного агрегата и у нас нет проблемы с нашими как бы составления агрегатов вся транзакция её создание её там комит всё находится в инфраструктуре и только если у нас уже есть какая-то какие-то нарушения этих правил и причины нарушения самое главное мы передаём контекст и в контексте У нас вот это всё дело имеется и как раз Ну я в данном случае реализую в большей степени именно в Application сервисе Вот именно там это всё дело реализую на данный момент Но тут можно опять же делать по-разному потому что это уже нарушение А и В целом Можно наверное использовать какой-то ещё подход но в в своей реальной практике это всё у меня в Application сервисах в этом плане я лишний раз не заморачиваюсь Спасибо большое Есть ли ещё вопросы Из зала я вижу тянет руку в последнем ряду Давайте донесёт да спасибо за доклад большое тоже Продолжение по транзакциям вопрос а можно какой-то базовый пример как третий вариант реализуется eventual consistency кой а он реализуется через публикацию событий и публикация событий происходит на алике слое а соответственно у нас публикуется событие и это событие должно быть где-то принято оно принимается в инфраструктуре это событие будет принято и обработано соответственно логикой есть это один из вариантов возможных второй вариант который я также реализовал в своих проектах вот публикуется события я его должен где-то принять я это выношу выношу в слой presentation и в соответственно entation слое Я принимаю данное событие А далее м у не когда я принял это событие там вызывается Ну вынимаются данные и дальше по той же самой схеме как в случае с фанком там Fiber jpc и так далее вот таким образом я сейчас на данный момент это реализовывать Спасибо большое Есть ли ещё вопросы в зале поднимите пожалуйста руки нет супер давайте выберем с вами вопрос который вам понравился больше всего для того чтобы мы подарили подарок от нашего партнёра Угу давайте коллеги За первого ряда за два хороших вопро за два хороших вопроса да спасибо большое за два вопроса мы дарим вам подарок нашего партнёра газпромнефти вас Мы тоже Хотим поблагодарить Большое спасибо за выступление Явно же шуа тема Давайте Поа оди нашему докладчику и мы хотим Подарить вам подарок от нашей конференции Приходите к нам ещё пожалуйста читать доклады ну а мы с вами прощаемся N"
}