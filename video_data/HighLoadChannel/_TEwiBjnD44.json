{
  "video_id": "_TEwiBjnD44",
  "channel": "HighLoadChannel",
  "title": "Тесты на Codeception для PHP-сервисов. Как остаться без регресса / Павел Сташевский (Lamoda)",
  "views": 2659,
  "duration": 3070,
  "published": "2020-07-17T06:29:37-07:00",
  "text": "эти знакомиться меня зовут сташевский паша я тестировщик ничего страшного все хорошо мне очень приятно выступать на конференции для разработчиков тестирования больше 10 лет и на текущий момент работы в компании ламода где я занимаюсь различными внутренними продуктами сегодня я буду говорить про cordyceps он про то как мы его используем для автоматизации тестирования и как с помощью него мы остаемся без регресса для начала мне есть маленькая история когда я пришёл в моду это чуть менее двух лет назад в отделе был лозунг давайте избавимся от ручного регрессионного тестирования напишем кучу авто тестов и будем их использовать собственно прошло два года и это работает и сегодня я хочу рассказать о том собственно как это у нас работает для начала давайте обсудим что в нашем понимании означает остаться без регресса ну во-первых если мы говорим про релиз про выпуск релиза это означает что на этом релизе нет никакого ручного в регрессионного тестирования все тестирование проходит с помощью авто тестов и все эти авто тесты должны проходить кроме того естественно у нас мы делаем какие-то фичи фичи делаются в отдельных ветках на этих отдельных ветках точно так же проходит регрессионное тестирование с помощью авто тестов и эти тесты тоже должны всегда проходить ну естественно в этих ветках есть какой-то новый функционал который предполагает все-таки ручное тестирование вот ну и если у вас 2 авто тест а то как бы очень сложно говорить о том что вы избавились от регресса у нас есть определенные требования к уровню покрытия как минимум это все критичные с точки зрения бизнеса в кейса ok поговорим немножко про сервисы и которые мы тестируем их автоматизируем тестирование которых и собственно про тесты которые мы пишем если говорить про сервисы павла моде помимо клиентских приложений вроде сайта мобильных приложений их непосредственно багандов есть очень много различных внутренних сервисов которые мы называем глубокими бэг-энда my настолько глубокими что они не видны непосредственным нашим пользователям это доставка это колл-центр это автоматизация фотостудии это processing заказов большинство из этих систем написанные как раз на печке и стыки то есть там пички последних версий symfony воскрес либо мускул в качестве базы кафка rabbit ну это все крутится на определенной инфраструктуре докер кубер нити с граф она и так далее вот собственно вот такие вот сервис и поговорим немножко пройти тесты которые мы пишем на данном слайде приведена достаточно стандартные пирамида тестирования которое начинается от unit тестов и заканчивается какими-то intent тестами которые тестируют уже бизнес цепочки вот про нижние 2 уровня мы сегодня не говорим то есть это тесты на код который пишет у нас исключительно разработчики тестировщики если касается этих тестов то только заходя в пул request и иногда review их иногда оставляя комментарии что что-то у вас тут не все до покрыта вот мы будем говорить про высокоуровневые тесты которые тестируют непосредственно самого приложения я их достаточно условно поделил на две ступеньки системные тесты и нтн тесты давайте посмотрим настенный тестер ну во первых у наших сервисов как правило есть api по большей части это резкое где есть saab ручки эти ручки естественно мы все тестируем также наши системы много общаются с другими нашими внутренними и не внутренними системами и эти взаимодействия тоже нужно тестировать ну и поскольку это система которые автоматизируют бизнес процесс у меня их достаточно много бизнес-логике и эту бизнес-логику тоже нужно тестировать поговорим немножко про and went тесты я их достаточно условно поделил на два подвида первый вид тестов который проверяет связку frontal бэг-энда и второй вид тестов мы их называем flow тестами это тесты которые проверяют весь бизнес процесс для определенных критичных для определенных критичных объектов системы там от начала до конца например если мы говорим про систему управления процессинга заказов то это от создания заказа и его доставки такие тесты это действительно intent с ты потому что иногда там нужно дернуть обе ручки сходить в какие-то внешние системы что-то прочитать из кафки или из ребята загрузить какой-то файлик то есть полностью тестируется бизнес-процесс несколько комментариев еще к этим тестом если говорить про white с ты то там часто не так важно кроссбраузерность поскольку пользователи наших систем это наши внутренние пользователи очень часто нам не нужно тестировать его их browse и иногда это облегчает тестированию вот второй момент вы систем систем много общаются с другими системами то есть них много внешних зависимостей с этим нужно как-то работать тестах и чуть попозже мы поговорим о том как мы это делаем ну и flow тесты очень часто работают как документация и вне зависимости от того тестировщик разработчиках пишет новый он очень быстро погружается в то что происходит в системе с помощью таких тестов окей мы сразу скажу вам достаточно много внимания уделяем таким тестом просто потому что наши внутренние системы как правило завязаны на деньги они завязаны на заказы и на их доставку и если вдруг что-то идет не так то это все сразу можно посчитать в деньгах поэтому к тому как мы покрываем что мы покрываем и к уровню покрытия в целом мы относимся достаточно строго для автоматизации тестирования мы используем такой фреймворк как концепция я видел по рукам зале что не только мы используем когда сэмпсон это радует на самом деле здесь логично задать вопрос почему мы все таки выбрали именно когда section но когда я приходил в компанию когда собственно уже был выбран поэтому вот прям так сходу почему он изначально был выбран я наверное не скажу но поработав с ним какое-то время я могу сказать чем когда с общим для нас хорош во первых на когда сообщение может написать тест и любого уровня то есть если посмотреть на пирамиду тестирования от uni dmtn тестов на концепции не вы можете писать тесты для любого из этого из этих уровней второе когда собственно достаточно мощный комбайн в нем очень много модулей стандартной библиотеки а если он что то не хватает и стандартной библиотеки вы можете открыть страничку с аддонами и там еще что не поискать и обязательно найти для себя полезного то есть вам не нужно ни писать никакие обвязки и там для общения по сети и работы с файлами с базой данных это все из когда сообщение подключаете используете вот ну и третий пункт это наверно больше актуально для больших компаний тесты плюс-минус одинаково выглядят во всех проектах и поэтому если вы переключаетесь на какой-то другой проект то это будет достаточно быстро по крайней мере в плане написание поддержки тестов парочку слов скажу про самка deception потому что не все все-таки его использовали концепт когда вы затягиваете когда степченко себе в проект он генерирует примерно такую файловую структуру работает он по модели акторов вот в этих вот в этих ямал файлах у вас хранится конфигурация то есть вы описываете там те модули которые вы используете ваших тестов ну и соответственно под каждый вид под каждый вид тестов у вас есть своя папочка и еще есть три такие вспомогательные папочки в них хранятся какие то данные и общий код для тестов сразу скажу вот тестов и код приложения во всех проектов у нас лежит в одном репозитории это очень удобно надеюсь что и у вас также поговорим про модули когда собственно ну и наверное по большей части рассказ про кодос общем будет это рассказ про модули что мы используем как мы используем и чего нам не хватает но это стандартные модули кдц пшена в которых нам все хватает мы их используем и радуемся жизни вот я не буду про них в принципе что то рассказывать я думаю что про них можно почитать все в официальной документации и это будет гораздо полезней просто скажу несколько их особенностей важных для нас вот есть такой модуль под номером один называется пищи браузер это такая обертка над козлом которая позволяет взаимодействовать с вашим приложением почте теперь то есть открывать страничке вводить какие-то данные в поля нажимать кнопочки загружать файлике и в принципе если дома для вас не важно не критично и на браузерное тестирование если у вас нет сложного г с а если вы в принципе ничего не планируете проверять на страничке а планируете только с ней взаимодействовать во многих случаях печки браузера достаточно подключаете используете его и все окей если этого вам недостаточно в кадис общине есть модуль webdriver это модуль обертка собственно selenium webdriver am подключаете его запускаете браузер и проводите свои in this ты в браузере что еще интересного есть такой модуль деби для работы с базами данных чуть подробнее money им поговорим попозже но недавно в одних из последних релизах добавилось работа с несколькими базами данных поэтому если у вас приложение несколько баз данных то теперь вы все это работает из коробки он не нужно ничего дописывать вот и модуль ntp модуль для работ собственно с очередями поимки при протоколу маленькая ремарка официально он протестирован на рыбе think you поэтому если у вас вдруг там силы актив в общем что то другое то что-то может не работать или могут быть какие-то артефакты у нас rabbit и нам очень хорошо поговорим о том чего нам не хватило в стандартной библиотеке и что пришлось немножечко доработать под себя ну во первых как я сказал что у нас в наших сервисах кое-где есть sap ручки естественно их тоже нужно тестировать на них нужно писать автотесты но в когда сообщение в принципе есть модули он так и называется об для тестирования таких сервисов здесь на слайде показано как его можно сконфигурировать послать запрос и что-то там потом проверить в ответе вот все хорошо но если вдруг у вас в приложении несколько sap поинтов то есть несколько выстрелит то вы их из коробки не сможете тестировать потому что модуль настраивается только на одну в стельку и процедуры вы можете дергать только из нее но когда общин поддерживает динамическое ри конфигурирование модулей поэтому вам достаточно написать обертку которая просто будет получать этот модуль заново ivory конфигурировать на новый point на новую схему и собственно использовать эту обертку вместо реального sap модуля тогда вы можете ее получить сконфигурировать и уже отправить запрос на нужный порт если вам нужно его поменять заново конфигурируете отправляете запрос на новый янкуль все хорошо парковку помимо rabbit им kill как я уже сказал у нас используется кафка кафка это конечно очень хорошо но в когда сообщение нет ничего в стандартной библиотеке и по крайней мере полгода назад ничего не было в аддонах для работы с кафкой из тестов но в этом нет ничего страшного пишем свой модуль писать модули для от и до сапсана не очень сложно наследуете класс от когда сообщено модуля и самый главный вопрос возникает как его сконфигурировать ну вот так вот вы дели выглядит конфигурация кафка модуля в ямал конфиге то есть мы конфигурируем брокер конфигурируем там настройки топиков все его модули реализуем функцию и ниша вайс в которой с помощью там всяких вспомогательных функций когда собственно загружаем нужную конфигурацию создаем контент-продюсер и все и работаем с кафкой очень хорошо другой вопрос который часто встает в наших тестах это работа с файловыми стенами на текущий момент нам нужно работать с тремя файловыми системами это видов это sweetie pie и это с 3 вот ну еще есть всякие другие файловые системы с которыми возможно он тоже приходится работать это все хорошо и в принципе если поковыряться в стандартной библиотеке когда совершенное в аддонах то практически для каждой файловой системы что то есть это можно брать и использовать но это же как бы файловые системы со всеми ними хочется работать плюс-минус одинаково вот поэтому мы написали свой модуль когда сообщил fly систем это оберточка над fly системам в которой сейчас поддерживается три файловой системы этой sweetie pie видов из 3 собственно то что нам нужно и как вы можете посмотреть на слайд со всеми файловыми системами теперь можно работать по одному еперь этот модуль волошина гид хоп кроме того он добавлен в на страничку аддонов когда собственно вот поэтому его можно брать и использовать своих тестов сразу так сказать не отходя от кассы поговорим про хелперы хелперы это в принципе те же самые модули на концепте не просто модули это не что базовая работа с некоторыми ресурсами а хелперы мы вносим все что некоторый общий код который используется во всех тестах что же мы вносим хелперы во-первых мы выносим некоторые кастомные сердце то есть если у нас есть какой-то объект системе например заказ и мы написали для него какую-то сложную проверку через базу данных посмотреть в 1 и во 2 в 3 таблички все упаковали это в метод положили это в helper и его используем во всех тестах это различные взаимодействия с ей причем джек ты просто какие-то методы которые заполняют какие-то формы это запуск различных сил команд внутри приложения это подготовка файлов с данными нужной структурой и все то что вы можете перес пользовать своих тестах все это нужно можно и очень хорошо выносить в хелперы как я уже сказал хелперы это почти модули потому что они точно так же наследуются от k до собственно модуля единственное обычно у них есть после helper они точно также подключаются через ямал конфигурацию единственное наверное вам в этих хелперов понадобятся какие-то другие модули но в когда сообщение о модуле есть поддержка dependency injection то есть вы можете добавить в helper метод inject перечислить те модуль которые понадобятся в этом hell перри и потом их использовать ну и прописать их как зависимость потом в ямал конфигурацию поговорим про базы данных это такой очень важный вопрос для для тестов на мой взгляд в тестах с базами данных нужно делать три главные задачи во первых нужно каким-то образом раскатать базу данных нужной структуры во вторых нужно ее каким-то образом уметь заполнять тестовыми данными ну и третья задача это делать определенной выборки и проверки опять же в кдц пишу не для всего есть этого есть два модуля модуль т.п. и модуль fixtures с помощью модуля тебе можно раскатать базу и саске льдам по с помощью например модуля fixtures можно создать fix туры они тогда будут выглядеть как такие большие массивы которые purchase of таблички ну и модуль деби использовать для выборок и проверок мы используем только третий вариант для первых двух у нас немножко не сказать что свое решение но мы делаем по другому каким образом мы делаем во первых мы поднимаем контейнер стоит с той базой данных которая реально используется в в этом сервисы либо контейнер с подвесом либо контейнер с мускульным чтобы раскатать структуры баз данных мы используем доктрины creations с помощью него раскатывается вся структура и накатываются все справочники ну и дальше для того чтобы добавлять данные для тестов мы тоже используем симфонии вы бандл доктрин fixtures который позволяет собственно из некоторых объектов предметной области а точнее эти объекты пир чистить в табличке при этом в плане данных тесты у нас атомарные то есть перед каждым тестом мы чистим нужные таблички и добавляем нужные данные поэтому тесты можно запускать в любом порядке в плане данных они никаким образом не будут зависеть вот это очень удобно на данном слайде просто приведён пример того как выглядят текстуры реализованы с помощью доктрины fixtures бангла вот почему мы используем их они используя модуль fixtures ну просто потому что с ним гораздо удобнее работать удобнее создавать цепочки связанных объектов если у вас вдруг произошло какое-то изменение структуры базы данных то массивы вы точно будете править а вот fix туры виде объектов не факт ну и в конце концов на такой код смотреть немножечко поприятнее поговорим про мокин будем говорить не про те муки которые используются в uni тестах а поскольку мы говорим про высокоуровневые тест это и томоки прежде всего на http cyma действия с другими внешними сервисами каким образом мы подходим к этому вопросу во-первых если у вас например в тесте есть взаимодействие с какими-то двумя внешними системами то оба эти взаимодействия будут замок анны кроме того мы проверим не только какой-то позитивный сценарий мы проверим еще и негативные сценарии когда сторонние системы возвращают осознанную ошибку либо возвращают какую пятисотую ошибку вот это все позволяет избавиться от нестабильности и зависимости от каких-то внешних окружений внешних сервисов вот используйте мокии все будет хорошо для этого мы используем такой инструмент как vr мог если вы зайдёте на страничку аддонов к да собственно то там и есть предложение использовать http мог ну vr мог немножечко помощнее кроме того у него есть тоже модуль для когда сообщено поэтому его легко подключить и работает это все вот так сначала картинку покажу у вас поднимается докер-контейнер свр моком а это вот собственно ваше приложение которое которому нужно по всем а действовать какой-то внешней системой но она идет не к этой системе она идет на vr мог с определенным запросам vr мог смотрит что запрос пришел у него есть так называемый request маппинге и он среди них пытается найти в общем смо пить ваш запрос на определенный ответ и если у него удалось все это сделать то он собственно его и отдаёт моки можно создать статический и заранее положить в этот контейнер то есть когда контейнер поднимется моки уже будут доступны это кстати очень удобно использовать в ручном тестирование либо моки можно создать динамически прям в тесте здесь показан пример того как создается мог я думаю что здесь все понятно потому что создание мокко очень такой декларативное видим какой бы метод хотим замок ать на какой url должен придти запрос и собственно что мы хотим отдать кроме того что мы можем создать этот мог мы еще можем потом проверить а ушел ли запрос на этот мог и там есть еще варианты проверить собственно что ушло на этот мог вот кроме того у vr мокко есть удобная фишка мне есть много чего ну вот на мой взгляд есть два полезных запроса первый запрос это посмотреть какие маппинге сейчас есть в ярмуке второй запрос это посмотреть какие request и уходили на vr мог когда вы отлаживайте тест и разбирайтесь с упавшими тестами это бывает очень полезным ну и какие же автотесты без отчетов для отчетов мы используем аллюр valery есть много всяких различных возможностей но в аннотациях мы используем всего три аннотации это фьючерс это stories и это ну некоторый уровень критичности то есть каждый тест у нас описывает некоторую фичу некоторый вариант использования этой фичи и насколько этот тест критичным вот это очень полезно даже по большей части не в качестве отчетов о когда вы открываете код тестов и вообще пытайтесь понять среди всех тысяч тестов что вот конкретный тест пытается сделать кроме того для очень длинных тестов например такие the flow тесты мы используем алё рабские степы они выглядят вот так и они тоже позволяют добавить некоторое описание к конкретному шагу но потом если посмотреть на отчет то это будет фича это будет история а если кликнуть на этот тест вы получите список степов вот иногда бывает очень полезно ну и лаура очень много всяких различных отчетов один из наиболее полезных на мой взгляд это отчет таймлайна me периодически мы его открываем смотрим на эти тесты которые очень медленные если такие есть и пытаемся их каким-то образом оптимизировать проката сцеплен поговорили поговорим немножечко о том как запускаются наш тест и собственно в качестве инструментов для запуска наверное два главных все в докере и запускается все на бомбу больше тут особо сказать нечего каким образом выглядит запуск с началом убил тем контейнеры приложения нужной версии потом поднимаем окружении что я понимаю под окружением во первых это контейнер и самого приложения это различные вспомогательные сервисы кафка rabbits sweetie pie webdav в общем все что нужно для работы этого сервиса это база данных и на базу данных накатываются миграции вот на себя это все поднимается с помощью докер compal за ну на bayou все все сервисы крутится в кубер нитью и все дальше запускаются когда общин ран запускаются тесты если говорить про время всего этого выполнения то вот холодный старт до запуска тестов обычно занимает несколько минут но не больше 10 минут тесты в зависимости от проекта до 30 минут могут выполняться на текущий момент вот так вот выглядит запуск и поговорим немножко о том как у нас встроено процессы что это в принципе все работает я выделил некоторые главные принципы которые мы используем и вот наверное из всех главных принципов это самый главный мы вообще товарищи нетолерантные к красным тестом у нас есть 2 правила во первых если мы releasing the test и всегда на релизе должны быть зеленые даже если мы выкатываем какой-то hotfix если это hotfix который не может подождать пока у нас пройдут тест это скорее всего будет просто рубль релизом и второе правило если задача пришла в тестировании и на ней подарит тесты то это повод тестировщику вернуть эту задачу в нет fixing второй момент с авто тестами у нас следит вся команда как я уже сказал вот эти вот высокоуровневые то я ст у нас пишут и тестировщики и разработчики и разработчики при этом фло выглядит примерно следующим образом разработчик делает свою задачу пищит на нее unit тесты и в том числе пишет некоторый минимальный набор функциональных тестов которые как минимум покрывают некоторых эпос тестировщик когда берёт задачу в тестировании понимает хватает тут или не хватает этих тестов и либо дописывают эти тесты либо просто заводе задачку чтобы это все та же в будущем до покрыть ну и поскольку все хранится в одном репозитории и код приложение код тестов то все пол request и и разработчиков и тестировщиков проходят командные review и это очень хорошо ну и про новые проекты тогда запускаются новые проекты есть великий соблазн запустить их без тестов а потом их дописать либо запустить спадающими тестами мы такое стараемся не практиковать особенно если дедлайн сильно не горит у проекта вот и стараемся сделать покрытие юниты функциональных тестов на этом проекте так чтобы дальше его можно было релизе без ручного регресс ну и подведем итоги итоге будут немножечко капитанские но давайте все равно их подведем регрессионное тестирование это конечно очень хорошо вот если а если она автоматизировано это еще лучше если она не у вас не автоматизировано то давайте его автоматизировать вот если вы вдруг решите использовать conception тон он решит большинство ваших задач но возможно что то придется под себя доделать вот запускаете тесты чаще тем чаще вы будете понимать что у вас происходит с приложением но если тесты падает то их нужно чинить и поддерживать их всегда зелеными всем всем спасибо за внимание я готов ответить на вопросы правил связь высота клад мы выражаем тебя благодарность вам покажи всем сертификат колоночка напоминаю что тебе нужно будет выбрать лучший вопрос поэтому постарайся запомнить хорошо задачу здравствуйте спасибо за доклад подскажите если у вас проблема мигающих тестов если есть как вы с ней и живете но такие тесты периодически появляются мы стараемся обычно как бы сразу с ними каким-то образом работать просто вот это вот мигание тестов она может быть по различным причинам либо у вас какая-то проблема в самих тестах на стоят статические слепа например статические тайм-аут и на проверку там чего-то и иногда их не хватает это могут быть проблемы с самим приложением там всего архитектурой с чем таким либо могут быть проблемы с инфраструктурой на которые вы запускаете вот поэтому зависимости от того где проблема ну немножко разная flow его решение но если мы встречаем такой мигающий тест то ну мы стараемся ето пофиксить как можно быстрее потому что это все обычно эффекте на процесс релизов вот здравствуйте спасибо за доклад мотивирует прокачать свои скиллы тестирование очень вопрос по тестированию внешних сервисов когда мы макаем их ответы различные это очень круто а как защититься от той ситуации когда другой сервис разрабатывает человек с которым ты не сидишь рядом он изменил ответ ты об этом не знал тесты прошли выкатили в против все упало ну очень печальная ситуация что я могу сказать ну вообще если говорить про опыт ламода если вдруг меняется взаимодействие в каком-то обмене то естественно задачи сначала проходит ручное тестирование и поскольку это изменение в обмене где общаются две системы то будет проведена такое интеграционное тестирование между двумя системами то есть мы стараемся если меняется какой-то обмен то другая команда будет знать что этот обмен изменится и это нужно протестировать чтобы ничего не сломалось более организационный вопрос чем прямо про тестирование был эта проблема более организационный внутри команд чем до этого проблему более организму такая она решается больше процессами чем чем архитектурой тестов благодарю вас спасибо за доклад подскажите какое на ваших проектах средний процент покрытия тестами и количество тестов на разных проектах в среднем спасибо про процент покрытие но вот если говорить про вот эти тесты высокоуровневые то там как правило процент не считается потому что немножко не тени и не тест iq для которых нужно считать процент мы обычно особенно когда запускается новый проект тестировщики у нас составляет некоторый чек-лист который ему как бы описывают полный регресс этого сервиса и потом мы уже автоматизируем сопоставляя как бы вот пишем авто тесты и вот этот вот checklist но если говорить в этом плане то тогда покрытие но там близка к ста процентам потому что практически все кейсы из регресса они покрываются если говорить про количество тестов очень сильно зависит от сервиса это может быть несколько десятков может быть несколько сотен может быть несколько тысяч вот порядке такие привет спасибо за доклад действительно очень мотивирует мотивирует следи за своими тестами писать их а такой вопрос а как вы тестируете тесты то есть как быть уверенным что твой тест написано правильно и тестирует правильно твое предложение но могу сказать что мы больше организационно к этому подходим и вот то что я говорил то что у нас построен процесс так что тестировщики например тоже участвует в кадре view и если появился какой-то pull request его могут review it разработчики другие могут review и тестировщики и они . ходят-смотрят код в частности code of the тестов и когда они берут задачу в тестировании они тоже смотрят какие авто тесты на эту задачу написаны и ну а тестировщика по крайней мере у наших тестировщика хватает competing компетенции понять всего ли тут проверяется и все ли проверяется так как проверялась бы в тестировании но все таки стараемся писать автотесты которые ну похоже на то что тестировщик проверяет как бы в реальной жизни здравствуйте и спасибо за доклад есть пор вопросов 1 вот вы используете варлок его ермак вы что не слышали про пакт фреймворк нет что это это типа то же самое что там то что вы используете я не уверен как он отыграется складов совершено он решает проблему предыдущего вопроса где есть коллизии между разными системами например вы себе ставите этот фреймворк конфигурируете то что вы отправляете это что и в нем то что он вам ответит другая система делает то же самое то есть то что вы отправите то что они ответят и у вас есть овощи конфигурации типа того но это немножко про другое все таки вот эти мог сервисы они просто работают как заглушки как заглушки для других сервисов но бывают конечно там умные заглушки но они никаким образом не не не гарантирует того что ответ внешней систему поменяется окей а вы как то внутри между продуктами задаете какие-то тест например от вас одна система и другая внутри 2 например и 1 знает что ответе другая востока имеется но в каком плане у нас если в рамках теста тест знает как должна ответить другая система и другая система знает что вы пришлете у нас в одном тесте обычно не тестируется несколько систем сразу то есть у нас тестируется одна система а вот все взаимодействия с другими системами они будут собаками ну и поскольку они будут вам окон и мы как бы знаем что нам должны ответить вот эти сторонние систему вы не используете систем парализации типа пара теста вот мы сейчас думаем потому что но 30 минут для тестов уже многовато вообще у к достаточно есть там свое решение с помощью библиотеки роба для того чтобы параллели тесты но там есть много вопросов по поводу инфраструктуры как что поднимать там сколько нужно контейнеров и прочее можно ли что там делать базой данных и так далее в общем пока мы думаем пока не могу ничего сказать конкретно спаси большое здравствуй пасибо за доклад такой вопрос по поводу говорит что вас тесты в районе до 30 минут идут что касается хотфиксов если вам нужно выложить определенную задачу и она не проходит тесты и вы тратите еще дополнительное время на после исправления еще раз тестируете после этого выкладываете или есть какой-то другой warhol ну фиксы у нас проходит по тому же самому flow то есть если нужно выкатить fix готовится релизную версию с этим фиксом прогоняется автотесты если они прошли to fix выкатывается если они не прошли там и с этим что то делаем либо fixin проблема в приложении либо fixin проблема в тестах если это если мы выкатили релиз и понимаем что у нас есть проблема которую нужно пофиксить и она не может подождать того пока у нас пройдут тест и такое как я уже говорил у нас кресел будет rollback релиза и мы пофиксим проблему и потом заново выкатим этот релиз еще второй вопрос не замеряли сколько времени насколько время увеличивается разработка релиза при внедрении тестов если бы ее их на борт не было при заводке нет но таких сознательных экспериментов мы не проводил в означали на мой лоб от вас же неполное было покрыть и тестами но меньшей степени так скажем ну да да ну я не могу сказать просто конкретных цифр просто тогда больше времени гораздо тратится на ручное тестирование потому что понимаешь что у тебя нет вот какой-то страховочной сетки в виде авто тестов и ты стараешься проверить по максимум там какие-то соседней области с функционалом вот ну в общем больше времени на тестирование и на fixing тратится а если у вас нет авто тестов спасибо за доклад хотелось бы задать вопрос к тестируете ли вы как-то взаимодействия между различными сервисами на при когда в один из сервисов вносятся изменения которые могут затрагивать работу других сервисов допустим чтобы не было такой ситуации когда она про какой-то api поменялось и за него там отваливать что-то другое когда формально все тесты при этом проходит если не мог явиться у вас спасибо да ну и я мне кажется уже отвечал на этот вопрос если у нас меняется какой-то обмен в общении между системами то прежде всего это будет проверено на ручном тестирование то есть это будет ну как бы больше в процессе вот ну и понятно что если мы будем знать что у нас меняется какой-то обмен в том числе и мы переделаем наш автотесты под новый формат ответа здравствуйте имеет смысл задавать вопрос потому как устроены текстуры каким образом они загружаются на каждый отдельный тест но мы используем симфонией бандл вот как бы всю работу по тому как объекты предметной области пирсе стеца в базу данных и потом чистятся делает он просто у нас есть текстуры у нас происходит текстуру слова тест со ран и у нас сейчас возникла проблема что слишком много fix тур друг на друга накладываются и мы думаем как загружать перед каждым тестом конкретные текстуры но мои загружаем перед каждым конкретным тестом то есть у нас перед каждым тестом чистятся нужные таблички и загружаются те данные которые нужны именно для этого теста но и вот как вот это реализовано с помощью symfony вова бангла что то есть ну просто минимум бан-лист вот он загружает все что есть fix турах там то есть если у вас интернете юзер у вас все юзеры под теста грузится или юзер есть под конкретный тест каждый как-то отделены но текстуры у нас могут быть перес пользоваться между тестами но вот физически сами данные загрузи очистятся и загрузится перед каждым тестом понятно спасибо драсти спасибо большое за доклад было очень интересно у меня вопрос касательно вот параллельного запуска тестов вы говорили что есть роба но я так понял вы его не используете и вот хотел понять почему мы не используем и вопрос потому что пока мы еще до него не добрались но я говорю вот сейчас уже 30 минут выполнения тестов немножечко как бы напрягает вот поэтому я думаю что в ближайшем будущем мы его за используем и надеюсь раз параллель им наши тесты спасибо и второй вопрос касательно того что вы говорите вот когда запускается тест он что-то записывает в базу кто-то проверяет и потом некоторое время тратится на очистку этих данных которые ты записал туда но почему нельзя сделать чтобы и тест выполнялся каждый тест выполнялся в отдельную транзакцию и просто в конце делает в rollback и то есть отдал вам где быстрее и и вот эти тесты можно будет проверен и запускать но пока не по крайней мере не рассматривали такую возможность чтобы там тесты в отдельных транзакциях запускать ничего не могу сказать о вас и так давайте зададим еще один вопрос если он еще есть я видел вот на первом ряду у кого-то скажите вот продолжение вопроса про тестирования тестов есть такая интересная техника коммутационное тестирование и про него сейчас пошли доклады есть несколько инструментов выпечки или вы не в этом направлении смотрели вот использовать такие техники для тестирования уж их тестов то есть менять код мутации делать и проверять недостаток прямо практических результатов нас нет у нас тут больше разработчики думают про мутационная тестирование о том какого по использовать и она больше на мой взгляд для проверки качества unit тестов и чем высокоуровневых тестов вот но пока по крайней мере практически мы его не использовали хотя много слышали и читаю понять спасибо а на какие тесты вы делаете большой упор на юнита функциональные ли интеграционные нет но мы делаем упор на все тесты на юниты на функциональные раз посмотрел что вот у вас разработчики пишут и юниты и чуть функциональных а там уже вот функциональные целиком то есть получается все таки юнита 2 получается чуть поменьше потому что есть отдельные люди которые занимаются ими функциональными и могут написать соответственно но мы делаем упор на все тесты мы просто как бы соблюдаем пирамиду тестирования что unit тестов у нас самое большое количество а дальше все меньше и меньше и меньше единственное что у нас разработчики могут писать абсолютно все тесты по всей как бы пирамиде тестирование от стирол щеки занимаются только вот ck уровнем ими тестами и так был давай выберем самый интересный под моему мнению wars вот тут был молодой человек который говорил про мокии прав реворк который может сконектить две системы да вот сейчас волонтеры и передадут ему тэгу и далее вы сможете продолжить общение в дискуссионной зоне мы будем готовиться к следующему доклада спасибо да пасибо всем"
}