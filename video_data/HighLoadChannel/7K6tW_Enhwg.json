{
  "video_id": "7K6tW_Enhwg",
  "channel": "HighLoadChannel",
  "title": "Собираем Docker-образы быстро и удобно / Дмитрий Столяров (Флант)",
  "views": 20456,
  "duration": 3551,
  "published": "2017-04-22T14:48:27-07:00",
  "text": "Ну Итак здравствуйте все очень приятно что вас много очень надеюсь что то что я вам расскажу вам будет действительно полезно и понравится и будет интересно Итак Меня зовут Дмитрий леров Я работаю техническим директором компании флан с момента здания последнее Ну уже СРО 9 лет Ну и собственно Сегодня я буду рассказывать как собирать доке Прим буду рассказывать о том как собирать докер образы я расскажу о том какие Ну у нас возникают проблемы мы написали на питоне свой докер который назывался джейр в честь в честь Угадайте чего в честь ных джело Ну мы очень очень сильно мечтали о докере и нам очень очень много чего хотелось но Докера тогда не было в 2013 Осенью я начал активно следить за Докера А 6 июня 2014 я точно совершенно знаю что у нас заработали первые докер контейнеры в продакшене Ну соответственно сейчас там два с чем-то года эксплуатации Докера в проде А весной я рассказывал о том как сделать Continuous deliveries docker был такой большой обзорный доклад который рассказывал как В целом построить всю цепочку Ну как из Гита доставить исходники до до продакшена И как дальше там с ними жить а сейчас я буду рассказывать исключительно про стадию сборки То есть я буду говорить как собирать докер контейнера в условиях continous Delivery в условиях Когда нам нужно собирать докер контейнеры не один раз а в условиях Когда нам нужно собирать докер контейнеры постоянно много много постоянно Прежде чем говорить о том как собирать я расскажу какие есть проблемы и зачем вообще нам докер И зачем нам докер образы и какие решаются дором проблемы буду рассказывать только кусочек который касается именно сборки значит смотрите есть базовая проблема с воспроизводимость которая выглядит следующим образом дальше сейчас начинаю очень быстро потому что потому что программисты Шат вми Ну то есть это вот тот мир который который есть отдел программирования отдел администрирования да такой старый мир значит говорит всё классно админы катят на прод и по какой-то причине прод летит вулкан Ну по какой как бы Кто так делает все знают да то есть чтото в окружении оза не тем Като не теси пакетов чтото не во Мы катим из Гита оди сервак используем зеркало пакетов в одном состоянии пока идт распределённый плой на второй сервак зеркало обновилось пакетик чуть-чуть другой Ну и второй сервак у нас улетает вулкан и Любой человек который пл шефом на 50 Серков он с этой проблемой Ну хотя бы раз там сталкивался если не шефом то шем аблом чем понят что все эти проблемы можно победить есть е Вот такая тема с воспроизводимость Ну просто эта тема Она имеет ещё развитие ещё вот такое как бы ну как бы и что то есть да ну и в общем с воспроизводимость есть вот как бы набор кейсов воспроизводимость между тестовым окружением и Продакшен воспроизводимость при выкате на кучу Серков воспроизводимость при выкате на несколько площадок не знаю там в Америку и в Австралию локальный запуск точной копии запуск старых версий если кто-нибудь пытался поднять версию приложения двухлетней давности Ну и там Поставить все ти зависимости которые вам тогда нужны были то знает ту боль 2 года Это о а если короче с помощью докер идже можно сделать классную гарантию воспроизводимости выглядит так программисты шат ВД собирается в докер образ образ оди лежащий Бинар со всеми зависимости со всем что нам надо используется на всех площадках на тесте на проде на у программистов на компьютерах на других площадках и складывается в архив отсюда правило правило имеет номер д потому что вырезано из предыдущего доклада раз звук пропадал Нет я не шевелю окей кусок второй про инфраструктуру есть два бранча пусть будет девелопмент и мастер А пусть будет в Мастере у нас текущая версия которая на проде в девелопменте у нас новая версия которая пока в разработке пусть будет два контура йн и продакшн там два окружения два мента как хотите Называйте пусть у нас ППШ проект и пусть старая версия работает с PHP 55 новая версия работает с php7 разработчики начали пользоваться не знаю что там ВМ появилось Ну чем-то начали пользоваться и Когда разработчики делают меж а потом это катят на про Ну понятно что версию PHP 557 мало кто мало кто забудет обновить есть если такие люди работают в вашей компании лучше им там не работать наверно как бы или вам работать в другой компании Но если вопрос про версию какой-нибудь там не знаю ме ска была решение очень простое нужно информацию о том какая версия PHP используется положить в гивы Реп так чтобы информация об инфраструктуре лежала вместе с кодом приложения и тогда Разумеется Когда будет происхо Ну ещё рема Да соответственно и надо выкатывать С тех самых образов которые собираются контейнеры и PHP должно быть частью этих контейнеров и когда мы делаем мерч Разумеется м как бы мы не забудем отсюда правило инфраструктура - это код ты должна жить с ним м Но это был на самом деле Ну как бы это был рассказ про то что такой mutable инфраструктура и про то почему почему инфраструктура должна лежать с кодом но есть ещё неочевидные моменты смотрите м Если у нас есть фронт и к а хотя в современных приложениях обычно слоёв там сильно больше да и допустим у нас старая версия приложения не использует ве сокеты новая версия приложения использует весо а поддержка весо поддержка проксирование сокетов появилась в нсе начиная с версии 1.3 Ну слайд немножко уже такой с бородой потому что н нынче совсем не 1.3 Да но но был такой момент и как бы Какая история история опять такая же когда мы и проблема точно таже самая решение очень простое в Реп с исходниками положить кроме информации о том какая Какой ещё информацию о всех других слоях инфраструктуры Какие могут быть слоя там не знаю может быть вас приложение собирается в неко разных образов и какой-нибудь вокер Да ну то есть если это микросервисы ну и О'кей значит программисты девопс работают с одним гитом из этого Гита собираются а несколько докер образов то есть вот целевая схема по работе такая и такая схема даёт Ну гарантию того что мы не забудем м ну и правило написано на слайде Окей допустим у вас микросервисная архитектура и у вас куча проектов или просто вы Большая компания у вас просто много проектов А может быть у вас много проектов с микросервисной архитектурой тогда их ещё больше да А и у вас есть гид с каким-то проектом в котором есть код и ну инструкции для сборки ин такие нужен новый проект вы ско написали новый код скопировали н ну обычное поведение тут Ремарка да девопс Если у вас есть отдел девопса в департаменте Айла Значит короче они обычно не очень классные разработчики То есть если они пришли из демира Они конечно хорошие разработчики и тут проблем нет но если они пришли больше из акого мира не очень любят обобщать и картинка выглядит следующим образом скопировали поменяли скопировали поменяли скопировали скопировали поменяли поменяли и не Ну у кого такая история есть Ну в общем она есть Этот способ разработки называется мы любим печатать напиши всё что пишешь минимуд и А есть другой принцип программирования который называется не повторяй А это нормально что да подсказывают что батарейка села Ну окей и раз два по-хорошему несколько проектов должны голо вы помогаете а перетычиха раз спасибо большое сори всем Я тут ни при чём а несколько проектов по-хорошему должно выглядеть следующим образом у нас есть первый проект когда мы Ну заводим второй Разумеется мы вместо того чтобы копировать выносим в модуль делаем версионирование Ну и пошло поехало там надо внести изменения мы вносим изменения в модуль изменяем ver костре Ну и так далее да то есть нормальная командная Работа нормальная модульность Ну и правило звучит следующим образом что да инфраструктура - это код и раз инфраструктура - это Код надо с ней перестать работать как с Ну как привыкли В общем скопировали и поправили Окей это были вводные и тут Капитанская часть заканчивается давайте я подведу итог значит что мы хотим от сборки докер образов когда мы говорим что это сборка докер образов для CD У нас есть то реп в нём есть наше приложение есть информация о том как собирать н с этим приложением Есть возможно модуль в который вынесена Общая часть есть информация о том как собирать фронтенд есть общая часть в которую вынесена информация для сборки фронтенда разработчики работают с этим ре пом девопс работают с этим Рем девопс работают ещё с модулями которые лежат в отдельных Гита когда собирается backend используется модуль он собирается в отдельный докер когда собирается frontend опять и вот тут началась Интересная история Ну когда Мы начинали работать с дором у нас докер ид получались Ну иногда там 500 м иногда 700 иногда по гиб там по разным причинам и со временем это даёт очень большую боль Потому что если речь идёт про continous Delivery то это Куча коммитов и по-хорошему надо доч собирать при каждом комете для того чтобы потом там по нему прогнать тесты ещё что-то это занимает кучу места Ну и мы пришли к какому-то такому верче правилу что желательно чтобы имидж был маленьким маленьким для нас меньше 200 МБ понятно что как бы вопрос там частный Но вот мы считаем что если имидж меньше 200 м это нормально базовый имид у бунты весят 130 МБ Ну то есть 70 Мб надо как-то в них укладываться Но это один кусочек то есть мы хотим чтобы имиджи были маленькие вторая тема что мы хотим когда разработчик добавляет 10 КБ кода меняет кода в общем размер комита 10Б чтобы у на не появлялось п Да вот это как классика сборки Докера а появлялось плю 10 КБ и это реально важно потому что когда вы делаете 200 в день 200 на 400 МБ это много Ну ну понятно что если вы мыслите колоссальными объёмами данных то команде опять А может надо стоять здесь чтобы не колонна Короче если у вас куча народу в команде и ку Серков то у вас не 1000 Коми в день а 5 кото в день и Ну она ВС равно есть третья Тема что надо собирать эти докер иджи не за 2 минуты не за 30 минут А желательно в среднем секунд за 10 так чтобы мы пуш нули и Пока Мы открываем наш C оно уже собралось и показалось что Да всё хорошо и уже тесты начали выполняться и Ну дальше я знаю что только на этой конференции пяток докладов про то как там inte тесты параллельно гонять вот ну дальше это не моя тема сегодня да О'кей Ну и вот эти докер иджи используются используются Везде как конечный продукт вот целевая схема Вот так мы видим процесс работы с докеров что так должно быть а как мы это решаем первый вопрос значит что должно быть в стандартной библиотеке и есть два варианта все функции которые могут вообще кому-нибудь понадобится и функции которые могут понадобиться всем Ну разумеется ответ что если э библиотека стандартная да то ну как бы там только те функции которые нужны вообще всем Ну а в нестандартных библиотеках уже там какой-то дополнительный функционал смотрим докер уних есть фа первый ну это не первый но один из принципов говорит о том что у всех очень разные проблемы и мы должны решать только те ту часть проблем которая общая У всех да Ну и как бы докер - это решение общая которая решает тот срез проблем которого касается каждый вторая тема важная для Докера контейнеры должны быть по Я знаю что сегодня есть доклад про то как запускать кубер на Ну это часть часть Докера Да а третья важная тема с точки зрения Докера и любого большого проекта что вы не можете добавлять вы раз Вы не можете добавлять фичи бездумно потому что как только вы фичу добавили Вы должны пожизненно её поддерживать бы вы публичный проект Миллионы людей навас рают добавили они начинают пользоваться вы убираете а они все вас ненавидят А мы сделали утилиту которая решает частный случай вот прям частный и я сейчас буду рассказывать параллельно про эту утилиту и про то как решать все эти проблемы собственно какой частный случай это сборка Докера для CD Ну тут сразу про то как поставить мы утилиты написа на Рух нуж Руби бо 21 ста одной командоконтроллер набе и счастье Ну или github с тревисо и та же цепочка ой слайды поехали Окей значит что делает э утилита Ну конфигурация описывается в файлики который называется Дафа Ну Make File docker File вы знаете ещё 300 названий других файлов А сейчас это руб DSL но скорее всего мы перейдём на я для того чтобы быть проще для того чтобы избежать там ну куче потенциальных ошибок принцип очень простой один репозиторий гивы Ну я надеюсь что вы не программирует один репозиторий - это один Проект Один проект - это один Дафа Ну то есть как бы связь такая очень простая при этом помните Да я в начале говорил что в одном проекте Скорее всего будет много доке иже то есть вот сколько там доке иже неважно Но все они описываются в одном Дафа этоа инфраструктура всего прость всеми зависимостями Как собирать Как собирать другие кусочки требуемой нам инфраструктуры наши принципы проектирования портали кто-нибудь из вас депт приложение на rasberry Да и портали нас абсолютно не интересует Потому что всегда Когда делаете совершенно знаете И на что вы будете деплоить в обозримой перспективе по крайней мере у вас нет варианта что вы может быть завтра Смените архитектуру с x86 на Ну как бы вы перейдёте с амазона на Google Cloud или с на на Но не с x86 на Security сборка дофа долж быть безопасной это важный принцип то есть вы долж иметь возможность скать из инте и Ваша машина не должна от этого сломаться в случае CD У нас есть наша команда ну или там не наша команда Ну в общем команда людей и да файл не распространяется да то есть это штука и Безопасность работы доб файла не актуальная тема что для нас важно Для нас важно чтобы это было очень просто и удобно использовать чтобы не надо было как с дофа для ы очень быстро и эффективно чтобы имиджи собирались за 10 секунд по 200 МБ И по плю 10 КБ Вот это важно а и я начинаю с примеров синтаксиса на котором мне будет просто проще объяснять секция для доке говорим что у нас сборка идёт из Ubuntu 1604 секция для шела мы говорим что на стадии Install Расскажу позже Что такое стадии а идёт вызов Командо upg update и Командо upg Install netcut И говорим что при запуске этого имиджа будет запускаться такая Командо кто может сказать что мы капитаны есть у кого-то ощущение что мы делаем что-то не то Ну я вижу по аудитории конечно То есть пока что это выглядит абсолютно как докер файл справа приведён синтаксис докер файла Ну то есть что мы поменяли шил на мыло А ну Разумеется нет я пришёл сюда не для того чтобы рассказывать как мы Ну научились делать то же самое Что делает А Итак фича первая которую мы добавили Ну во-первых как работает обычная сборка Докера У вас есть Командо в докер файле каждая Командо в докер файле создаёт отдельный слой дорно имиджа когда мы говорим у нас качается базовый интой когда мы добавляем каждый ран у нас создаётся новый слой если мы поменяли какую-то Командо например вот эту вот вот вот вот эту Командо то у нас этот слой пересобрать Ну вызвали ещё раз Build этот слой пересобрать и эти слои становятся Не ну невалидные неактуальными да и последующие команды пересобрать так работает штат на докер у него есть проблема в том что он умеет это делать только локально То есть вы не можете использовать несколько C раннеродовой умеет Каширова А это вводная была да А вообще что нам нужно делать при сборке нашего проекта для прода Ну я так сейчас с разных сторон подойду к вопросу прежде всего Нам нужно добавить код в Image Ну потому что зачем мы собираем Image если в нём нет исходного кода нашего проекта Ну даже если мы компилируемые приложение то нам надо добавить не Исходный код А ну результат но это в общем и целом тоже код установить системное по системно знаю mysql ron PHP Ну какая-то какие-то системные пакеты то что вы делаете атом установить системные зависимости Не знаю кани ли xml прикладные зависимости сейчас каждый Ну не сейчас последние 10 лет каждый уважающий себя язык имеет свой менеджер там в Ну в общем у каждого языка есть свой package медр и у каждого менеджера есть Файлик в котором описаны зависимости Да прикладные зависимости то есть нам надо сначала поставить системное Ну какой-нибудь либо xml потом прикладные которые использую Да настроить системное по не знаю там локали добавить в системе ког Иса ког там ну mysql в do контей это не очень здоровая тема но настроить наши поне для нас вот вот примерно список дел но В какой последовательности это делать с учётом того чтобы это было правильно сшиваем сначала добавили код потом поставили системное по потом зависимости потом так потом так или сначала системное по которая может быть тяжёлым Ну например там ну если мы ставим PHP это всё равно там 50 Мб в идж а потом прикладные зависимости потом потом так потом так Или может быть так Ну то есть возникает вопрос В какой последовательности собирать и фундамент у этого вопроса какой значит что нам нужно нам нужно чтобы собиралось быстро да ну то есть чтобы мы не ждали там по 15 минут пока у нас качаются все пакеты ещё одного языка программирования Да и чтобы при пересборка комит не создавал 200 300 400 там гиб места чтобы не использовалась куча лишнего места И при этом мы хотим чтобы ещ и конечный ИЖ был маленьким Ну то есть мы вроде как хотим зашивать всё что ставим но ну хотим Ну не хотим кэшировать Ну и как бы чтобы это решить Нам нужен Ну вообще я думаю что здесь большинство вс-таки разработчики и все разработчики Я как разработчик люблю паттерны па сечас используют там mvc фреймворки Почему ну прежде всего потому что сочинение писать в свободной форме всегда менее удобно чем писать сочинение по шаблону Да ну так проще Зачем каждый раз придумывать что-то своё и мы придумали классный паттерн Ну с первого взгляда кажется что это капитанство но это не так мы разбили сборку на четыре стадии Ну Set и две стадии и делаем примерно следующее в before Install мы говорим что нужно складывать всё что тяжёлое и редко изменяется к этому мы относим настройки операционки очень редко вы меняете что-то касающееся локали в системе что-то касающееся версии Как как часто в вашем проекте меняете версию персон каждый день Ну понятно да что как бы вот тяжёлая и редко меняющаяся часть - это настройки OS и системное по например Вам нужен ru какой-то конкретной версии версию ru вы меняете гораздо чаще чем версию операционки но не каждый день и скорее всего не каждый спринт да И точно не в каждом комете мы проанализировали 50 примерно 50 проектов Точно не скажу на разных языках программирования абсолютно от разных команд разработчиков друг друг про друга не знающих и друг с другом не связанных и по нашей статистике меньше 1% коммитов вообще касаются изменений версии языка и Окей в Инста прикладные зависимости Ну то есть это Ко ble Вот это всё по нашей статистике 5% коммитов меняют так или иначе прикладные зависимости добавляют какую-то новую липку убирают липку меняют версию ещё что-то в сепе конфиги по нашей внутренней статистике 2% котов менят ко в основном для симметрии Ну как бы мы как любые разработчики любим симметрию А ну и потому что он иногда бывает полезен для того чтобы настроить что-то что мы используем в Сета Ну например если мы конфиг ЮА или конфиг рельсов генерируем каким-нибудь таском встроенным фреймворк то прежде чем это использовать нам нужно сгенерить какой-то кусочек конфига для этого фреймворка О'кей м прошлый пример оставляем ну в нём есть слово Ил Да понятно теперь что это стадия Install по-хорошему этот пример разбить на два кусочка из Инста вытащить в before inst update и получается так что в before инле мы качаем список пакетов в Инста мы ставим ncat а при этом когда мы меняем версию нетта у нас не перебирается весь а перебирается только это выполняется на голой системе 2 минуты выполняется 5 секунд мы типа классно выиграли Ну разумеется мы можем там добавить ещ од Командо и опять у нас тся только но все Кто собирал докеры поймут что здесь есть очень большой подвох причём этот же подвох есть в обычном доке фале смотрите docker From взяли Image сун before Install скачал 40 МБ в систему чего 40 МБ списков пакетов из репозитарий качает 400 м ну как бы вот у ямаш 400 м То есть у нас идж стал из 127 в случае центо 500 527 Ну и как бы это не здорово а Install добавил 700 кб с дм Бинар и что мы получили то есть мы получили опять как бы полную чушь в докер файле в докер файле выглядит точно так же то есть есть если разбить на стадии выглядит так и получается что мы собираем Ну Взяли у бунту вот эту часть слепить в одну в одну в один стейдж и добавить туда RM мину RF warli Up Но это что означает это означает что мы когда хотим поменять эту версию Нет Ката Ну ладно версию ncat вообще кто ncat в доч собирает это ну ерунда Да но в реальности же у нас там куча куча куча команд которая которые ставят нашу систему Да и получается что если мы делаем так то всё классно 200 КБ потому что мы лишнюю информацию удалили но у нас не работает кэш значит при каждой сборке мы опять ждём пока у нас качаются пакет и получается ну как бы конфликт то есть с одной стороны Мы хотим иметь информацию для того чтобы в следующих шагах или в следующих сборках делать быстро с другой стороны у нас есть очень сильное желание не иметь эту информацию в конечном имидже которую мы катим там на две сотни серверов или 2.000 серверов или и мы не хотим эту информацию из имы вычищать вручную потому что ну это неудобно об этом надо каждый раз думать А ну все разработчики знают что Ну если есть вещи которые надо каждый раз думать Вы каждый раз будете её забывать сделать и мы придумали такую штуку Ну то есть на самом деле не мы придумали она очень очевидная любой бы человек который этим занимался е придумал внешний контекст выглядит следующим образом мы добавляем конструкцию Mount И говорим что папка War lip upt лежит не в имидже а лежит в некотором билди и этой штукой Мы решили полностью проблему Ну у нас получается что кэш есть он доступен но он лежит не в имидже а у бунта в before Install создаёт однобайтовом весит 127 с по МБ и собирается пересом чи Как это работает git в нём Дафа вызываем уту Build Она когда собирает поднимает контейнер в этот контейнер монтируется Папочка build а ну и когда контейнер внутри этого контейнера выполняются все эти шл скрипты которые там что-то настраивают и когда настройка закончена этот контейнер превращается в кроме Builder У нас есть р Разница в том что Builder - это папка которая живёт все сборки проекта Ну сколько раз мы не вызываем команду db Build А eder - это папка которая живёт в процессе одной сборки то есть мы один раз собираем Ну сколько стей у нас не с Каширова столько собирается вот она жива Ну и вот эту штуку мы называем внешним контекстом то есть диром и получается что есть на самом деле как бы подводный камень да то есть теперь для сборки нам недостаточно Гита теперь для сборки Нам нужен ещё дир но любая сийка современная Ну все известные мне сики современные позволяют что-то кэшировать между сборками какую-то папочку gitlab C позволяет tris C позволяет Jin позволяет Team C позволяет всё позволяет то есть вот эту папку buer можно таскать между сборками через C Ну или если вы собираете на одном сборщики Вы можете просто положить её локально икать или если вы собираете там на сборщика в одном Дант можете положить е на сервак пошарить Ну в общем как-то как-то с этим жить Окей Зачем нам нужен внешний контекст менеджер встроенную систему очень помогает все прикладные пад менеджеры очень помогает Но есть И вот такой ме ком c+ приложение плюсе приложение на каком-нибудь бусте с кучей шаблонов может компилировать ну 2 часа например да аа а кстати я не знаю работает ли c+ Plus для c+ Plus C cash Ну допустим вы компилируется большое сиш приложение не знаю зачем-то Вам надо Да вы можете включить C cash который позволяет кэшировать результат м компиляции отдельных файлив сиш их э в объектные файлы и этому скшу указать папку которая будет во внешнем контексте и то же самое вы просто а вот под словом ассеты Я подразумеваю сейчас никто не программирует на жава скрипте никто не программирует на цсе все пишут cpt SAS CSS Ну и куча куча разных других технологий которые копируют ассеты вот под асета Я подразумеваю то что компилируется для фронта да и ну большинство проектов используют эти технологии большинство проектов при сборке должны спилить ассеты Да и соответственно Многие известные мне компиляторы асетов позволяют также Каширова Ну какой-то промежуточный результат и сильно ускоряться Короче эта штука будет очень полезна для всего что касается компиляции неплохо но это это ещё только начало значит 1% в стале 5% в Инста 2% в сепе А 90% коммитов что наших делают Ну разумеется они добавляют по до этого мы только инфраструктуру ставили а на самом деле большая часть котов у на просто меняют исходники не знаю там кнопочку в меню двигают Ну что делают и когда мы добавляем исходники из Гита в до нас на самом деле возникает куча вопросов Ну то есть добавлять их каждый раз или или неж КАТО в котором много кода Ну хотя бы 20 МБ И мы будем каждый раз добавлять то это уже напрягает потому что ну потому что мы поправили 10 КБ а добавили 20 МБ а другой вопрос вот у нас есть вот эти стадии before Install inst before setup setup а при добавлении Гита какую Какие при добавлении новых исходников какие из этих стадий перебирать и такой вопрос постоянно возникает То есть если вы писали свой докер файл вы там пишете там кор Install потом Add у вас проблема что вы добавляете исходники Ну то есть вам композер нужны исходники хорошо наоборот проблема что добавляются каждый раз Ну в общем проблемы проблемы Проблемы ещё бывает такая задача что вам нужно вырезать часть исходников там положить в одну папочку часть исходников в другую папочку Ну в общем много вопросов и мы сделали очень классный для добавления исходника docker IM смотрите Ну я сначала расскажу как он работает потом покажу как это в синтаксисе в синтаксисе это прямо очень круто в DSL а перед после be Иста до Инста у нас появляется й который называется git АВ и когда мы первый раз собираем в этот й Командо git ахв добавляется архив на момент первой сборки при каждой последующей сборке у нас последним стей добавляется просто патч Ну то есть мы на до накладываем Гито Ну самый настоящий Гито пач и получается так что ну как бы каждый следующий комит - это добавление дельты между архивом и ну и последней сборкой но с точки зрения команд например на стадии before inst мы вызвали поставили PHP поставили mysql поставили это для PHP пример с PHP можете заменить на B неважно на стадии и мы вызвали Командо comper у неё уже есть исходники из архива там уже есть Файлик по которому работать и оно поставило прикладные зависимости Но ведь получается что у нас вот этот Файлик по которому работает композер он на стадии inst выполнился у нас только один раз это беда и разуме нам при изменении этого файла надо обязательно переть и наш DS позволяет указать что при изменении вот этого файлика добавляй патч вон туда и соответственно сборка произойдёт только Ну как бы с нужного кусочка с нужного места более того вот эти патчи мы позволяем накладывать в любом месте более того в самом конце мы па по-моему размером в Мега не удаляем есть как только накопилось Мега изменений вставляем их в сеть и добавляем следующий патч количество слоёв в докере сейчас около двух сотен и у нас там предусмотрено защита которая просто перег неет архив Если слишком много слоёв Ну то есть мы делаем Это Ультра эффективно а пример с пины приложением вот добавление Гита для пишного приложения секция git там секция ED которая говорит Добавить папку PHP configs в папку PHP конечного иджа очень удобно секция которая говорит добавить корень репа в папку конечного ИЖа при этом вырезать папку PHP она нам не нужна там где у нас лежит приложение при этом проставить Груп Ну вот кто добавлял исходники в поймёт что это очень удобно и этож зависит от изменения файла composer Log там можно папочки указывать Глобы и всё что угодно Ну я надеюсь что теперь круто но это тоже далеко не всё А давайте посмотрим такой немножко странный пример с дором берём у бунта 1604 добавляем исходники нашего сиш Наго приложение дальше мы ставим компилятор и де библиотеку потом вызываем срочку нашего приложения потом копируем наше приложение туда где оно должно быть потом удаляем компилятор с библиотекой ставим нормальную библиотеку и вы понимаете да Что мы получаем мы получаем при установки компилятора там качается почти гигабайт мы получаем и весом в гигабайт в котором большая часть удалена и она просто в промежуточных но опять та же самая проблема с тем что тогда у нас не будет работать кэш то есть тогда мы будем каждый раз переставлять вот этот гигабайт качать его из интернета это время Окей Вы можете задать вопрос А зачем вообще мы это делаем внутри имиджа Почему нам не собирать в системе Ну мы же можем поставить компилятор в систему собирать бинарник в системе и добавлять только бинарник конечный ид у меня опять ответ А если вам нужно в разных бранча разные версии ну вряд ли си но если вы там пишете на Go уже может быть Ну то есть гораздо удобнее вести сборку Чего угодно в докере потому что именно внутрь Докера Вы можете положить Ну версии софта и не переставлять каждый раз на на C раре А И у нас тут родилась штука которая называется артефакты а в целом паттерн звучит следующим образом значит при сборке проекта нам нужны какие-то инструменты но они не нужны нам для работы конечного результата то есть Нам нужен компилятор чтобы собрать приложение ном оно работало Нам нужен JS для того чтобы собрать ассеты но нам не нужен nos для того чтобы эти ассеты отдавать потому что Аты - это C файл Кай чрт нам имет в системе и ещё по гигабайта каких-то непонятных Бинар мы вообще не хотим их иметь на проде Ну зачем нам они на проде А ну и вот эти инструменты они зачастую весят кучу и зачастую мы их меняем Ред им их перестав Ну и я уже говорил да что это касается отнюдь не языка там си или го или Явы это касается зачастую мы это используем например в основном для сборки асетов Окей Как это работает Дафа командой дабил собирается он генерирует образ с артефактом генерирует конечный образ и копирует артефакт из Ну просто берёт Бинар и гонит его через внешний контекст в конечный ид и получается что у нас докер образ артефактом Да большой гигабайт но конеч и маленький при этом получается что у нас работает ш чуть детальнее Как это работает есть стадии как собираются образ с артефактом они такие же как у обычного только там добавлена ещё одна стадия которая называется последняя арфа тут убраны лишние которые просто не будут использоваться в примере экран маленький ставим компилятор библиотеку дов при первой сборке на стадии добавляем исходники при последующих на стадии то есть даже если у нас много сины исходников или много асетов исходники добавляются не на каждом на каждом добавляется только Дельта вызываем сборку параллельно независи не параллельно на самом деле Независимо Да пока не параллельно Хотя могли бы и параллельно собирается конечный в нём ставится бибб от а ставите который будет эти Аты отдавать который Вам нужен бы для сборки Ну хотя это не так важно и последним шагом артефакт копируется из одного ИЖа в другой при этом самое главное если мы хотим поменять Ну нашу библиотеку Ну или если мы хотим поменять конфиг инса или если мы хотим поменять версию Ну то есть если мы хотим поменять базовый и мы меняем Командо в базовом Иже и у нас перебирается только вот этот кусочек а артефакт у нас остаётся сшиваем и всё собирается очень быстро если мы добавляем исходники в git у нас пересобрать только вот эта цепочка Ну это не так быстро но Ну мы же поменяли наш наше приложение оно должно пересобрать это нормально то есть мы хотя бы не тратим Лишнее Время если мы меняем Командо которую собираем пересобрать Только эта цепочка если мы меняем версию компилятора или де библиотеке понятно что пересорт почти всё но такое происходит очень редко А пример с приложением на си в ДС использу бунту почему-то 144 неважно артефакт внутрь артефакта добавляем из Гита корень проекта добавляем в папочку src Ну для того чтобы не писать много это сокращается вот в такую конструкцию в Ну за счёт того что это руб секция мы говорим что в артефакте на стадии костава такую кома И говорим что артефакт нужно пересолила в гите И говорим что это артефакт экспорт Файлик такой-то в User bin My после стадии Install сборки конечного имиджа и говорим Как собирать конечный имидж просто поставить библиотеку я вижу часы А ну и говорим какой командой Окей Ну что уже можно брать или это ещё не всё пробовали делать модульность на Шеле Ну кто-нибудь пробовал там модули писать на шели Ну или командная разработка на шели Ну наверное это не входит в лучшие практики Ну и помните Да что как бы хочется не повторять себя постоянно потому чтом приходится поно и пони с прочем можно сделать моду в любом случае то есть какие-то какое-то управление зависимостями если мы программировали бы наши имиджи на ru PHP там ещё чём-то у нас был бы у нас мог бы быть штатный на Шеле у меня единственная идея это гивы Саб модули но это очень неудобно мы пробовали если бы мы наши имиджи собирали например шефом ворет коман там был бы так вот мы подумали а бы нет И мы взяли и сделали в сборщики поддержку шефа и мы теперь докер иджи собираем шефом вот прям Почему нет выгляди следующим образом есть Дафа вызываем команду Build она гнет контейнер в котором будет собирать плюс в гите У нас есть папка DF в который принци сделать поддержку абла до чего угодно Командо Build так скажем компилирует этот КБК Ну что такое компилирует стягивает зависимости которые в нём указаны в общем тащит всё что надо и монтирует результат в и монтирует не копирует а монтирует плюс у нас есть и в котором установлен Шеф вместе с Руми со всей историей фдк занимает 800м из этого имиджа Папочка монтируется тоже в конечный имидж и потом там запускается Шеф этот Шеф настраивает настраивает настраивает настраивает контейнер по кбу всё классно и даёт конечный докер образ в котором нет кбу ков Нет 800 м шефа но он настроен классными удобными рецептами которые можно командно разрабатывать у которых можно делать модульность и всё классно А тут есть тонкость заключающаяся в том что мы используем кбу в нестандартном формате вместо Мы в них делаем под папочки по названиям наших стадий и в процессе компиляции мы вырезаем превращая КБК в стандартный для каждой конкретной стадии для чего это делается мы когда вырезаем мы считаем контрольную сумму всех файлов Ну вообще всего содержимого стей и на основани этого принимаем решение перебирать этот ж или несть прини кома или шаблона конфига у нас ж в котором это конфиг используется пере собирается а последний приме пример рельсовое приложение группа образов с эндом и кером и отдельный имидж для фронта А в группу с эндом и кером мы добавляем исходники они там нужны говорим что для всех имиджей конечных использую рецепт кон в этом рецепте кон мы не знаю там ставим Наши Любимые утилиты А чтоб мы хотим чтобы был во всех контейнерах не знаю зачем в группу с эндом и кером мы подтягиваем модуль с рельсами который настраивает ставит Руби бан Вот это всё ну короче делает какой-то какие-то настройки для рельсов в ид с эндом мы подтягиваем модуль для бэнда плюс рецепт который какую-то частность нашего проекта worker тоже самое а во frontend у нас там нет исходников Нам там нужен НК и нужен какой-то рецептик с Фронт эндом в бэнде мы говорим что у нас есть артефакт артефакт собирается модулем с атами экспорт Аты после сетапа и зависит от изменения папки UPS Ну и что всё это работает на 1404 вот Конечный результат как бы того что мы сделали дм фам ча это очень удобно и это работает очень быстро Итого мы добавили стадии чёткие стадии Да сделали какой-то паттерн по которому писать сделали поддержку внешнего контекста сделали классное добавление из Гита сделали поддержку артефактов сделали поддержку сборкой из шефа и мы можем собирать в одном файле кучу столько сколько надо это полностью мы с ней живём полтора года её активно развиваем над ней работает два разраба штатных Я написал первую версию последний год было написано ещё шесть а мы очень будем невероятно будем благодарны не знаю кружки почтой будем слать любить вас писать о вас благодарить если вы будете нам говорить что у нас что-то не работает ну потому что это ваш опыт использования мы гарантируем что мы будем очень быстро отвечать на все ищу пишите по-русски пишите по-английски пишите нам на инфо собака флан В общем мы короче будем всё это поддерживать очень будем рады если вам утилиты понравится и вы нам окажете какую-то помощь Ну или хотя бы поставьте звёздочку актуальная версия 07 она будет завтра но она есть в Мастере если умеете ставить гемы из сейчас текущая версия умеет всё тоже самое там чучуть другой синтаксис Уля Большое спасибо Меня зовут дмитрив над проектом Роме меня работает фейле из нашей компании до проектов о разным Мы очень любим докер много под него разного делаем 52 минуты это слайд номер 400 Спасибо А спасибо за доклад очень интересно работае Слышь нет А у меня вопрос не совсем по вот этому А вот по вашему бэкграунд Как вы думаете почему докер взлетел вот у вас долгий долгий период работы со всем вот этот контейнерами ну универсального Ответа нет но я думаю что взлетел из-за того что они не стали делать ничего своего Ну то есть если вы думаете что докер - это какое-то такое решение там что-то есть да на самом деле это маленькая с девяносто девятого года Ну и дальше Да но а это правильный маркетинг Ну в любом случае маркетинг для чего для того чтобы собрать большое коммьюнити и там 99% работы Докера - это переработка кучу кучу кучу кучу ищю а анализ кучи кучи кучи проблем который дал минимальное количество исходников которые решает проблемы которые есть у каждого поэтому взлетел докер Потому что люди собрали большое коммьюнити и не писали кучу кода а анализировали проблемы и делали максимально простое решение решающее максимум задач Вот мне кажется так у меня такой вопрос вот Я не знаком с предыдущими опытами вот эти вот слои имиджа они появились были в других проектах Solar zones Там и так далее и зо в зонах Нет вообще идея многослойной файловой системы и маунтов одного поверх другого поверх третьего она витала в разных вариациях очень давно я точно сейчас историю не отслеж но давно Ну то есть сейчас у Докера драйверов пять штук уже кажется разных по поддержке вот этой многослойности в целом это ну многослойная файловая система где каждый следующий маут переопределять предыдущий в кстати в соляри совских зонах по-моему это работало из коробки Ну Простите прошло немало лет Спасибо за у меня такой вопрос а поддержка когда-нибудь у вас появится мы какие-то старые и мы пользуемся шефом не понимаем Зачем Но если будет спрос конечно появится потому что сделать по этому же паттерну поддержку То есть у нас в коде есть который использует который использует Шеф Иби и сделать хотел ещ один вопрос задать Вот вы говорите что докер очень делает точное решение когда это распространённое а не боитесь ли что ваше решение оно будет просто перекрыто более изящным решением со стороны Докера Ну это будет классно А чего бояться-то Ну как бы Вы не боитесь то что эволюция существует Ну я не знаю это пустая работа возможно проще ли помочь доке реализовать э все иде секундочку у них есть принцип по которому они уже Достаточно давно не меняют докер файл и есть куча ищу на добавление вот этого функционала в разных вариациях в разных контекстах в разных приложениях которые закрыты со словами что Извините эта фича не будет использоваться каждым и мы не уверены что мы сможем сделать поддержку на пи Ну ещё раз потому что докер - это решение стандартное Да спасибо вот ощущение такое Пока так там выт стандарт дофа Ну как часто добавляют новые возможности в Ну раз в 3 года но там постоянный полный Коли пожизненная поддержка это всё усложняет А мы решаем частный кейс который вот сборка имиджей для быстро эффективно вцелом Да у Докера есть рекомендации как это де собираете в думаете Ну просто это усло как бы мы пытаемся сделать инструмент который делает удобно для разработчиков удобно для десо то есть минимум усилий и в продакшн Ну а что а сталкивались ли вы что если очень много леров то сборка становится медленнее вот здесь решали Ну нам Нам повезло не повезло не знаю мы на Осе Ну так как в основном бунту и так вот впрямую не упирались но у нас кажется были проблемы на девайс мапе были не были не были А вот проблему с внешним контекстом вы вот уже задали вопрос не хотели бы ли Вы её решать с помощью реализации множественного наследования в самом докере форком или Ну это мечты насколько это реалистично допустим это не очень реалистично потому что ну то есть с точки зрения файловой системы сделать множественное наследование Ну просто оно когда-то было а его потом по-моему убрали потому что это противоречит идеологии Докера и всё такое Ну само множественно наследования на файловом уровне сделать просто но на уровне леров на уровне того что у тебя один идж генерирует один конфиг другой и гнет другой конфиг файл один тот же ты его мержить будешь Да и фактически пользы никакой Ну Возможно со временем не знаю было бы классно если бы такое было удовольствием Воль что-нибудь придумали бы там для этого Спасибо конфликты отслеживать когда один и тот же всё ещё один вопрос это последний будет Добрый день а вы думаете про интеграцию с C системами там плагин для дженкинса что-нибудь такое вот чтобы кнопочку нажал и вот сразу по вашей вот системе просто мы считаем что дженкинс дженкинс пора на покой Ну я тоже так считаю и нужно использовать стенд которого есть на этой конференции или Ну то есть удобней в ял файле иметь информацию о сборке чтобы она была разная там для разных браншей утилити будет возможно сейчас там есть метод Build будет метод deploy и в даб файле будет описание для кубернетес как деплоить и фактически у нас будут примерки что вот такой ямк пишете бах-бах у вас рельсовое приложение дется cuber одна Командо поставили bernet вторая Командо сгенерировал кнопочкой Ну только не кнопочкой а ял файли цель такая Да сейчас сделаем Просто кусок со сборкой Спасибо за доклад Давайте поблагодарим Дмитрия было интересно большое спасибо вам"
}