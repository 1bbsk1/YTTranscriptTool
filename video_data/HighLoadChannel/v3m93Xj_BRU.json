{
  "video_id": "v3m93Xj_BRU",
  "channel": "HighLoadChannel",
  "title": "GraphQL: зачем на самом деле он нужен. Apollo Federation — дар бога / Олег Коровин (ecom.tech)",
  "views": 407,
  "duration": 2285,
  "published": "2025-01-17T02:20:24-08:00",
  "text": "друзья Привет Вы знаете я сам раньше не был сторонником Граф ql до тех пор пока не осознал то о чём я вам расскажу сегодня а вообще Обычно когда мы используем какие-то инструменты мы с ним к ним очень хорошо привыкаем Мы считаем что они классные и даже учимся делать какие-то странные вещи с помощью них и считаем что всё новое это вообще от лукавого и не стоит нашего внимания и сегодня попробуем вот с одним из таких кейсов какой у нас на сегодня будет план Мы сформулируем проблематику клиент серверного взаимодействия вспомним привычный для нас с вами подход с Open API его плюсы минусы поговорим о том что такое Граф ql по своей сути сравним Open API Гра ql поймём что у них общего Что у них разного посмотрим какие есть Угра преимущества какие есть проблемы найдём решение этих проблем и попробуем сделать выводы о то когда И зачем можно использовать graphql собственно о себе Меня зовут Олег Я очень давно занимаюсь разработкой но я в основном разрабатываю для Веба я с 2002 года этим занимаюсь видел интернет Explorer 6 Поднимите руки кто тоже встречал такую штуку вот сделал очень много различных сайтов в том числе всё время делал сайт аэропорта Пулкова здесь в Питере сайт Большого Театра знаю как запустить react в Java У меня даже про это есть отдель статья на хаб В общем много всего интересного Вот и сегодня буду вам рассказывать я работаю в компании которая называется самокат тех Вот правда с буквально 2 недели как мы называемся я Комтех и делаем решение для ритейла реального времени то есть Наша задача научиться делать так чтобы товары в пространстве перемещались с максимально быстрой скоростью вы знаете наши продукты такие как самокат МегаМаркет сберлогистика и так далее и для того чтобы вся эта система работала мы используем большое количество микросервисов у нас много микросервисов как на бке так и на клиенте большое количество систем с которыми работают как клиенты так и в наши внутренний пользователь и вот в рамках этого контекста мы сегодня будем говорить о теме Граф куэ А сегодня я хочу поговорить с вами про передачу данных и когда мы хотим что-то куда-то передавать мы можем использовать голубину почту можем использовать например teleg но к сожалению для всех нас с Вами Мы сегодня вынуждены использовать использовать кликер работай пожалуйста так http а Итак у нас есть простая ситуация у нас есть клиент У нас есть сервер и нам нужно как-то сделать контракт взаимодействия между ними нам нужно продумать с вами и все конечно же в такой ситуации говорят рест говоришь рест все такие кивают головами одобрительно но при этом забываю одну простую вещь что ре - Это всего лишь архитектурный стиль взаимодействия компонентов но ни как не контракт того как эти компоненты взаимодействую при этом зачастую мы с вами когда мы организуем взаимодействие клиента и сервисов мы используем комбинацию этих подходов потому что мы зачастую наме отправляем для совершения платежа кото выполняет какие-то функции и так далее Это уже RC при этом история такая что никак здесь не регламентируется контракт взаимодействия но Нам повезло Боженька послал нам с вами такую вещь которая называется openi это спецификация которая позволяет нам описывать клиент-серверное взаимодействие и набор инструментов для того чтобы э этим пользоваться Я думаю вы все это знаете Вы знаете всеми любимый нами любимый нами всеми что-то у меня перестал а свар а openi предоставляет нам возможность описывать схему в которые вы можете описать контракт и потом им пользоваться соответственно есть свар который мы все с вами любим поднимите руку Кто не знает что вот это круто ни одной руки все знают мы можем зайти сделать написать попробовать запрос мы можем Давай дружочек мы можем использовать кодо генерация которая на основе API схемы позволяет нам реализовать практически в любом языке готовые куски кода дальше мы имеем готовые решения например даже Для клиента который на основе схемы могут сформировать вам хранилище данных и в redx to Kit У вас есть Готовое решение для этого дальше у нас есть стандарт Jon API который позволяет вам описывать даже детализированный формат запроса и ответов и смотрите какая классная штука внутри него уже стандартизированы такая штука которая позволяет вам в ответе отфильтровывают что типа в гра можно фильтровать поля указывать поля которые вы хотите в ответе в Jon API это давно всё реализовано и это вообще не фишка Граф дальше всё очень круто то есть если посмотреть на то что происходит то по сути у нас всё есть да как бы кайф пользуйся и получай удовольствие а но а можно меня переключить на ноутбук я дальше с ноутбука буду вещать смотрите допустим ситуация посложнее у нас есть клиент У нас есть несколько серверов и какая получается история Мы хотим обеспечить взаимодействие клиента с несколькими серверами самый простой вариант который может прийти в голову это мы с клиента Просто ходим в каждый сервер который мы хотим Но тогда у нас получается слишком высокая нагрузка на сеть и плюс клиент сам вычисляет необходимые данные то есть производит и далее как мы привыкли эту ситуацию решать мы берм и ставим У нас есть теперь Значит сервер который по запросу клиента ходит во все необходимые сервера получает необходимые данные их как-то объединяет и отдаёт клиенту работает Быстро клиент получает данные мгновенно и все нужные и в принципе наши предки и покон веков ровно так и делали и никаких проблем не знали но Давайте подумаем А какие есть проблемы у openi первое наша схема мы е все любим Но она на самом деле большая и сложная поднимите руку тал вообще глазками когда-нибудь а тем более пытался её писать а писать пытались Да дальше смотрите Какая штука у нас на самом деле формат взаимодействия по-прежнему никак не стандартизированного ничего не сказано по поводу того что нужно использовать формат статуса запроса по факту у нас и то рест и это рест и мы можем на самом деле использовать как угодно Я думаю многие из вас сталкивались что даже две соседние команды абсолютно по-разному описывают этот формат взаимодействия вроде есть openi формат один и тот же ой разный при этом есть когенерация для любого языка Но она оказывается имеет массу проблем во-первых слабоваты Тулы Дальше например если говорить про клиент то генерация данных для жава скрипта такая что она не имеет проверка типов То есть у вас код сгенерирован но вы можете на самом деле отправлять туда что угодно дальше у нас есть даже проблема с генерацией на бке вот есть куча видосов где люди пытаются сгенерировать например для котлина по схеме код и потом его переписывают потому что там по факту у вас генер название функции но реализация никого не устраивает и самое прикольное что Бендеры в принципе ей не пользуются потому что Все предпочитают сначала написать классный код руками на основе него сгенерировать схему отдать на клиента и при этом среди фронтенде с которыми я общался треть в принципе пробовали кодо генерацию на основе Open API схемы и ладно бы это ещё полбеды но Давайте посмотрим вот на Какую вещь долгая разработка О чём речь Представьте что у вас есть уже готовый набор данных с ваших серверов но нам вам нужна новая ручка которая генерирует какой-то другой из них совокупность там какое-то поле добавляет или так далее И вам получается необходимо в этот гей реализовывать эту ручку её нужно деплоить тестировать выкладывать это время дальше представим что у вас на каком-то сервере появилась ещё одна ручка которая предоставляет какие-то данные Так вам нужно мало того что деплоить этот сервер вам нужно в гити её повторять просто для для того чтобы отдать клиенту То есть Вам нужно тоже его писать этот код деплоить тестировать и так далее дальше Если у вас есть появился ещё один сервер в экосистеме и допустим ещё один клиент который использует не тот же набор то вам нужно писать отдельный гей для этого клиента и соответственно кодить много-много Таких вот гетов которые просто предоставляют доступ к вашей внутренней инфраструктуре и так далее но вы скажете А что ты докопался вот мы уже десятилетиями так разрабатываем и всё в порядке не зна я скажу Да Вы абсолютно правы на самом деле много компаний построены на таких решениях и как бы ВС Окей но у меня возникает вопрос А вот можно чтобы было вот так же всё классно только ещё лучше и тут на сцену выходит товарищ Гра QQ - это язык запросов для API и среда выполнения То есть он предоставляет полное понятное описание вашим API даёт клиентов возможность запрашивать то что нужно И вот это Даше и скаже самое что openi по сути Ведь если читать описание то это оно и есть и как бы вы правы это вот очень похоже но Давайте разбираться в деталях и первое Граф ql - это язык и здесь можно провести аналогию с SQL который является тоже языком И он говорит о том как сделать запрос за данными но никак не говорит о том какая будет реализация и здесь очень важное отличие например Граф Q от Open API что он не привязан к транспорту в openi Вы прямо описываете статус в http а в Граф вы просто говорите Какие данные необходимо запрашивать схема схема наше всё это то поверх вокруг чего строится вся вот эта история и Вот я например в песочнице свайера на официальном сайте есть пример мы слева пишем запрос за питомцем а справа у нас модель данных описывается при том что она не помещается то есть здесь есть питомец А там есть ещё в этой схеме под под объекты вложенные объекты с данными И теперь я возьму и перепишу вот эту схему на Граф смотрите что получается вот здесь вот у меня слева все объекты которые будут описаны с помощью Граф который я использую а справа лишь основной объект питомца А вложенные они не помещаются они ниже А вот если посмотреть на запрос то смотрите Какая штука вот это вот слева описанный на openi схеме запрос за одним питомцем а справа тот же самый запрос описа на Гра и теперь Какой вывод у нас на самом деле получается что схема она более лаконичная и понятная и у Граф ещ есть куча фишек например интерфейсы расширения алиасы фрагменты имы юнионы бачин и так далее Потому что это язык и он предоставляет возможность на этом языке реализовывать какие-то синтаксические конструкции и потом их выполнять дальше Ну давайте посмотрим у нас же есть песочница мы все любим на свар прикол Я вот перед тем как делал доклад заходил туда и пытался как бы начать писать просто запрос и он спустя много-много лет зная схему до сих пор не реализует автокомплит то есть здесь я не могу как бы Пиши пожалуйста всё руками То есть я копирую из примера и начинаю что-то править При этом если я захожу в песочницу куэ у меня автоподстановки у меня проверка типов и так далее и так далее вроде всё современно работает дальше когенерация на самом деле очень крутые Тулы которые проверяют в ран тайме всё что не дают вам отправить запрос Если вы отправляете не тот тип данных на бэнда ей по-прежнему никто не пользуется потому что бэнде всё равно любят сначала написать код А вот например фронтенде пользуются постоянно потому что очень хорошая генерация у нас компании фронтенде герт на основе неё большую часть своего кода и дальше Просто используют компоненты Ну ладно мы все обожаем вот этот логотип вообще и прекрасная интеграция с идее потому что вам достаточно лишь настро Вы только начинаете разрабатывать вы настраиваете подключение к серверу и у вас уже вс знает про то какие у вас есть типы данные вы можете отсюда сделать запрос получить ответ и так далее он даже использует автокот вы ничего не делали вы просто указали в конфиге источник с обычным Open я искал плагины которые бы работали также к сожалению не нашёл Может вы знаете Расскажите мне потом пожалуйста и есть готовый набор всех решений для всех систем клиент сервер мобилка пожалуйста можно использовать то есть всё экосистема готовая То есть я хочу например использовать решение для ре погнали вс всё есть у нас и тут смотрите хочется провести такую аналогию сравнение между openi играм для меня лично такое же как между двой и колином то есть это суть одно и тоже но просто то что справа позволяет вам делать решение гораздо быстрее Изе и проще нет того что там одно это вот прям что-то кардинально другое Ну и что теперь то есть я вот это вот всё рассказал что-то такое на хипстерское то есть Нам нужен какой-то такой вот аргумент который позволит прям убедиться что это правда очень клёвая штука Окей поехали Давайте вспомним Зачем нам нужен гейт Он позволяет нам управлять схемой и позволяет нам сливать данных другого но возьмём эти основные штуки и возникает вопрос А вот можно делать Вот то же самое но только автоматически чтобы ничего не делать потому что самое лучшее в мире разработчиков - это ничего не делать Мы самые ленивые люди поэтому мы придумываем решение чтобы ничего не делать и оказывается решение есть вот для Open API есть такая штука называется kaken поднимите руку Кто знает что это такое две руки можно использовать готовый э этот самый вы конфигурируется в нём путь к вашим значит внутренним сервисам и он становится гитом для вашего клиента но прикол в том что видите им никто не пользуется про него никто не знает и его нужно конфигурировать руками а вот у а есть решение которое называется сугра архитектура позволяет вам объединять интерфейс Прим дела Это и отдавать их на клиента давайте объясню Как это работает вот у нас наша с вами схема У нас есть набор данных и объектов которые в ней используются в запросе и вот допустим давайте рассмотрим простую ситуацию У нас есть питомец есть категория И как мы обычно любим мы берём их и разносим по разным серверам мы же любим микросервис ную архитектуру любим разложили и смотрите Какая штука что позволяет вам с помою специальных идентификаторов суно и указать что Смотри Вот у меня здесь будет использоваться значит какой-то другой объект связка по нему будет по специальному ключу А где он находится Я не знаю очень похоже на база данных вы говорите что у меня есть там какой-то там ключ А где и как это будет мне в общем-то всё равно и получается что можно объявить сущности в одном сервисе и сослаться на них с другого можно получать доступ к сущностям по клю как в ба данных в базах данных ирвис Используй не знает Откуда она возьмётся её будет собирать уже клиент и много других фишек какой получается принцип работы смотрите Клиент говорит Дай мне пожалуйста питомца причём дай мне его название имя и категорию и у категории тоже возьми имя запрос приходит на Федерацию Федерация знает что у нас есть два сервера и такая идёт в сервер который отдаёт питомцев и питомец говорит что вот тебе значит информация о питомце и он говорит что у меня есть ссылка на категорию Я знаю айдини этой категории и в общем-то на и делает с ним всё что хочет Федерация понимает этот запрос и идёт в сервис категории она знает где он находится и забирает по этому идентификатору конкретную категорию и автоматически сама внутри себя это жет и получается что отдаёт клиенту ровно то что запрашивали при этом очень важный момент смотрите получается что когда мы запрашиваем только названия Федерация понимает что у питомца Нет сейчас в этом запросе сопутствующих объектов и она не идёт в сервис а что А тут не видно ничего а не идёт в сервис категории и отдаёт только то что необходимо и таким образом идёт высокая экономия на получение тех данных которые не нужны и это опять же происходит автоматически а и что это нам даёт Просто если в ситуации с Open API у нас разработка qa есть на стороне клиентов на стороне серверов и на стороне Гета то в случае с с Ало Федерации получается мы автоматизируем вот эту часть и нам нет необходимости писать гиты под каждый свой клиент при этом мы можем к этой Федерации легко подключать ещё сервера и ещё клиенты потому что у нас автоматически будут схемы добавляться в эту Федерацию и клиенты могут из всей совокупности серверов на бэнде получать Какие данные мы захотим при этом это очень всё легко запускается запускается и настраивается То есть у нас например есть готовый образ Мы в у себя в пайплайн выбираем этот образ мы указываем адреса кн серверов говорим какие необходимо прокинуть заголовки и всё готово и смотрите Какая штука получается что в ситуации когда у нас такая топология похожая например на нашу Когда у нас много-много-много клиентов которым часто бывает необходимо какое-то сочетание внутренних систем то есть мы запускаем там новая админка чего-то ещё и у каждого есть свой набор данных который нужно получать это очень эффективная история получается Мы очень сильно на разработке при этом например любой фронтенд-разработчик Может взять и запустить себе поднять гей потому что ему не нужен Эндер у него есть готовый внутренний сервис Он просто поднимает себе гей и начинает через неё взаимодействовать с экосистемой Вот и например какие-то вот можно стартовать вообще новые проекты не привлекая энд разработчиков круто круто при этом это коне не Панацея Поэтому если у вас много клиентов много будет полезен в остальных случаях по ситуации Ну и мы такие воодушевленный всеми этими полученными данными идём продавать эту концепцию на наш архитектурни самым умным дядьком в нашей компании и тут приходят наши лучшие друзья безопасности и эксплуатации и начинают задавать свои вопросы а как же избыточные данные контроль частоты контроль доступа контроль ложности единая точка отказа всё пропадёт всё точно отвалится если у вас только появляется Граф ль в системе то он точно доберётся до всех внутренних данных это я цитирую слова своих коллег сам возникает вопрос а что же делать Давайте разбираться Итак поехали обработка запроса Мы привыкли что в нашем любимом классическом росте как мы его называем Да вот у нас есть вот такой вот запрос мы пишем какой-нибудь обработчик сверху примерно ноде снизу на котлине и мы считаем что вот здесь проблем никаких не будет потому что вот тут всё хорошо Хотя тут есть SQL инъекции и так далее и так далее много есть мест накося накосячить но мы считаем что тут будут возвращены только те данные которые мы разрешили и смотрите Какая внезапная история в Граф куэ есть такие штуки они просто называются резол веры и мы говорим что вот у нас есть запрос за питомцем и вот у нас есть резольвер который возвращает ровно то что мы напишем То есть если у нас в конкретно для конкретного запроса написано Верни какой-то конкретный объект то ничего другого не будет возвращаться и вся вот эта вот история с тем что граф куда-то чего-то где-то вытащит она на самом деле ровна из-за того что нам там также где-то написана дырка через которую просто это получили Если вы не отдаёте чего-то из ваших внутренних систем оно никак Никаким образом не может попасть наружу поэтому избыточные данные это как и в классической разработке это всё на в стороне разработчика который пишет код дальше Поехали следующие проблемы Вот у нас есть стандартная схема мы делаем ре запрос У нас есть Firewall который проверяет что у нас есть какой-то лист и соотвественно Если вы не делаете запрос которого не доступен в системе то он просто не пройдёт Firewall при этом Вы если у вас идёт дедос атака по какому-то урлу вы просто его отключается например либо ставите лимит никаких проблем нет безопасники очень любят эту схему и клёво но с грам смотрите какой прикол что там все запросы идут на один урол и всё остальное идёт в теле запроса то есть вот у вас внутри тела описано на самом деле уже то где как и что получить и что с этим делать потому вы получается на входе не можете отличить запрос за одними данными от других и так далее но к счастью есть решение называется и получить от него хэши и Теперь смотрите Какая история мы берём приходим на наш urql но мы в заголовке передаём хэш запроса А на фаерволе по этому хешу мы можем проверять Можно ли такой с таким Шом приходить или нет но нам надо как-то научиться понимать где брать список этих хэшей и мы придумали такое решение мы на этапе сборки клиента собираем все запросы которые там А этот клиент использует потому что своим разработчикам мы доверяем Они до этого где в контуре что-то там делали Они вроде протестировали эти запросы нормальные поэтому мы эти запросы собираем и делаем хэши в которых у на мапке в которых у нас с одной стороны хш с другой стороны сами запросы которые наши разработчики сделали первое мы делаем merch request на наш Firewall и добавляем эти хэши в White list таким образом Firewall теперь знает что вот такие хэши можно пропускать А дальше мы на эту мап отправляем на наш Gate просто прямо вызовом из CCD запросов Gate и Gate складывает их себе в хранилище после чего когда приходит запрос клиента он проходит Firewall попадает на Gate Gate по этому хешу из заголовка достаёт у себя из там из базы либо из кша родной Запрос который был и вместе с ним уже уходит дальше и дальше система его выполняет всё отлично работает у нас есть такой плагин для клиента его можно скачать И поучаствовать в развитии и Мы также планируем выпустить плагин для э самого сервера Вот он в разработке Я думаю мы скоро его сделаем и какая получается история что у нас когда мы работаем внутри нашей экосистемы в деф режиме Мы работаем под пином мы не переживаем что у нас будут внешние какие-то запросы которые будут пытаться нам положить систему что-нибудь там такое вложенную рекурсию сделать и поэтому там всё открыто мы а наш сервер работает в режиме без хэшей в заголовках А когда мы уходим наружу вот во внешний мир там мы используем только хэши мы игнорируем тело вообще в запросе То есть злоумышленник может подставлять любое тело нам наплевать мы берём заголовок по заголовку проверяем что можно войти и потом из своих систем по заголовку достаём родной Запрос который был получается что нельзя выполнить Запрос который мы сами не разрешали выполнять при этом смотрите Какая штука оказывается что в экосистеме Apollo у них есть целая группа решений ребята выпустили как раз уже такую штуку Примерно там год назад то есть мы разработали 2 года назад они выпустили год назад то есть там как раз такая же история вся есть но это всё за деньги и нашему православному брату не очень-то доступно поэтому как бы если можете пользоваться Пользуйтесь либо приходите мы расскажем Как сделать то же самое у себя классно вроде поборолись с злоумышленниками теперь как бы мы работаем практически как также как классический рест но единая точка отказа то есть Я показывал схему у нас много клиентов одна Федерация мы такие заходим получаем данные Какие хотим Но если федерация обвалится по каким-то причинам кто-то там криво что-то задеплоить то получается ляжет вся в наша система поэтому мы решили делать Так мы сделали много федераций как я показывал они очень легко запускаются То есть вы берёте просто готовый образ конфигурируется бэнды и всё она запустилась При этом если у каждого продукта будет по своей Федерации то тогда если одна отвалилась то вторая продолжает работать никаких проблем нету при этом как из одного продукта использовать соседние сервера Да очень просто мы приходим говорим ребята мы сейчас тут хотим вас подключить хотим вам дать немножко пса вы такие Окей мы такие Да не вопрос Давайте подключаться смотрите какие истории Первое у нас получается есть здоровая коммуникация команды начинают эксплуатировать друг друга при этом договорившись второе на конкретном сервере видны потребители если например соседняя команда почему-то начинает давать избыточный трафик Можно конкретно только их отключить а свой продукт продолжать использовать то есть эта схема даёт очень много плюсов Ну и каждая команда получается следит за своим блоком Вот и при этом очень легко с ним работать всё вроде бы проблемы основные решены дальше возникает естественно вопрос А как же перформанс оно же там что-то себе считает думает Наверное это всё очень сложно смотрите Какая штука вот зелёный график - это роутер на JS который сейчас как основной и видно что в районе 2000 Он выполняет примерно за 6 миллисекунд при этом Apollo Федерация - это Stat сервер То есть их можно масштабировать вообще сколько угодно штук при этом чуваки взяли и написа на ра и видно что он там 18s он то токо к 5 миллисекунда заползает То есть можно взять его использовать И вообще не испытывать никаких проблем при этом Федерация - это спецификация То есть можно взять реализовать её вообще на любом языке программирования там хотите Напишите её там на го нах на чём угодно если вы считаете что можно ещё быстрее использовать х проблем нет Здорово руто сервисы и мне надо тоже их как-то переписывать мы пошли следующим путём мы сделали Просто набор библиотек который позволяет пере перед вашим существующим сервисом поставить такой прокси то есть сделать маппинг Граф ql на обычный рест это очень легко делается Там просто там один к одному и всё можно перед этой всей системой поставить Федерацию и потихонечку мигрировать потому что миграция - это зачастую один из самых больных вопросов когда мы хотим менять технологию И мы этот вопрос для себя таким образом Решили как бы без проблем На много команд так делают Ну и есть очень важный момент про который нужно не забыть поговорить - Это файлы Дело в том что когда GRA coil работает в формате Application json и он не поддерживает multipart form Data и поэтому для того чтобы передать файл необходимо его конверт нуть в формат Base 64 и э есть проблема в том что во-первых это очень много места занимает во-вторых это не безопасно существующие библиотеки которые для Apollo Gateway они небезопасные наши безопасники просто не разрешают нам использовать их для того чтобы передавать прило Что сделать мы с клиента отправляем запрос на сервер гори чувак там кого нужен файл онко Да не вопрос Вот тебе адрес для S3 Положи пожалуйста сюда мы берём стандартном отправляем данные на3 сервер их оттуда говорим серве всё чувак файл зали готово пользуйся и он спокойненько его скачивает вы такие типа всё попался никакого Граф Дава вспо что Тае этои по сути там система считается если она выполняет следующие правила которые описаны спецификации там клиент-сервер отсутствие состояния кэширование единообразие интерфейса слои и код по требованию мы привыкли считать что openi выполняет этим требованиям но Если задуматься то с помощью граля Можно также писать сервисы и системы которые будут этим требованиям выполнять и значит можно делать ландшафт и гораздо эффективнее быстрее и лучше быстрее класне двигаться к светлому будущему и получается смотрите вот схема которую к которой мы привыкли мы там используем например Kit мы делаем сами гиты либо используем нди который как выяснилось никто не использует Ну и пишем сами сервера А с помощью экосистемы а игра вэ можно на готовых экосистеме библиотек очень сильно экономить если использовать их на всех этапах разработки клиент серверного взаимодействия какие можно сделать выводы о grq на самом деле это не альтернатива rest это альтернатива openi потому что мы можем делать ре архитектуру с помощью языка grq и на самом деле это ни какая-то не серебрянная пуля и не магия С чем-то чего не было раньше потому что как я показывал в начале в Jon API и в других решениях всё Придумано вот сами подходы уже были до этого просто здесь есть конкретный инструмент где он может принести большую пользу дальше это на самом деле как раньше было принято И как я обычно это воспринимал и как Эндера с которыми я говорил Это воспринимали что Это какая-то игрушка для фронтенде что-то такое хипстерское непонятное на самом деле этот инструмент который может быть полезен бэнде и даже зачастую больше поскольку позволяет как я показал упростить работу меньше писать кода и заниматься именно бизнес логикой а не просто кодить гиты и самое это интересное это это уже не хайповая технология ей игра в Куле по-моему лет семь если не больше это уже взрослая вещь Она прошла проверку временим конечно она имеет свои недостатки которые нужно знать и учитывать и некоторые из них я вам показал и показал как мы их обходили вот ну и он будет полезен вам если у вас много клиентов много кэндо а в остальных случаях по ситуации на лоде было много докладов использования грав куэ они все разные мне хотелось сегодня обобщить это всё и показать в целом как какие есть преимущества у этой технологии и может быть вас вовлечь туда это было моё мнение а как думаете вы мне было бы очень интересно с вами пообщаться Спасибо за внимание Спасибо большое за доклад Олег очень интересный и мы прям по таймингу успеваем буквально задать пару-тройку вопросов пожалуйста вот в первом ряду прямо в углу и напомню что эти вопрос куда-то под корку записать Который больше всего нравится да потому что для самого лучшего вопроса у нас будет подарок пое Здраствуйте Спасибо за доклад два коротких вопроса первое Gateway у вас только агрегатор или вы там допускаете какую-то бизнес логику маппинг чего-то или так далее а второй вопрос по поводу секюрити значит понятна идея с Шами Но если мне надо отдавать какую-то ролевую дополнительную логику То есть например Одна часть данных должна быть доступ одной ролью другая например с другой ролью где это реализуется и как это дружит с этими Шами Спасибо за вопрос Да только агрегатор потому что собственно в этом и идея что вся вся вся логика она кроется там в необходимых сервисах которые это реализуют поэтому ничего более А про Security кстати очень классный вопрос Спасибо у меня был слайд на котором я показал милм как запускается AP gway что мы конфигурируется ещё важный момент это заголовки которые мы пробрасывается его авторизацию то есть мы такой плагин сделали для того чтобы уже с конкретным на конкретный эн приходить уже с пользователем для того чтобы экономить на трафике потому что иначе он умножается на И сколько сервисов опрашивает о полу Федерации Спасибо так ещё вот левом ряду Здравствуйте У меня вопрос был просто я не совсем понял вот допустим у нас есть две системы которым вот Федерация коннектится ини на ни допустим есть допустим пользователь пользователь допустим и там и там одни то есть избыточные данные которые могут быть рас согласованы Это небольшой н паттерн но Понятное дело что такое иногда бывает и вот у нас если приходит допустим данные вот Получи мне статус пользователя с таким-то ашнико в одной системе он ещё пока у него статус допустим Один в другой системе статус уже другой прошли изменения вот в таких рас согласованных системах там как примерно будет поведение или вообще лучше таких ситуации не допускать Клиент будет разрулить получается Ну если у нас одно и тоже поле для одного и того же пользователя то у нас Какая история мы вообще в схеме в одной мы не можем объединять одинаковые объекты То есть у нас не может быть пользователь абсолютно одного же типа в двух разных системах соответственно для граля это будут просто объекты разные То есть у нас скорее всего там даже если у нас это как бы вещи дополняющие одного пользователя это два разных объекта поэтому Что делать с этими статусами это будет решать клиент условно у нас там не знаю есть пользователи с точки зрения регистрации есть пользователи с точки зрения там заказа например да иго этом корзина и там у них вроде бы одинаковый статус одинаковое поле если они не объединяются в Граф есть возможность объединения Но тогда там получается надо выяснять кто из них папа кто мама в противном случае это два независимых поля и Клиент будет сам решать что с этим делать то есть это не вопрос технологии это уже конкрет бизнес и решение по поводу того как его реализовывать Так давайте последний вопрос вот из первого ряда и будем выбирать лучший Олег спасибо за доклад Вопрос такой получилось ли сделать автоматические миграции из openi и предполагается ли что-то такое делать или всё ручками кот случае мы вот делаем прокси которые потом ребята на переносят но мы провели очень прикольный эксперимент было интересно вот у нас есть готовый сервис который у которого есть openi контракты и мы захотели понять А может ли фронтенд-разработчик сервис на котлине переписать быстро эти контракты на Гра Q потому что на самом деле синтаксис очень похоже Вы также используете декораторы у вас функциями и нужно просто на самом деле чуть-чуть поменять декораторы при этом внутри Если этот метод просто вынести в библиотеку Даже тот который используется для ре контрактов и его же потом вызвать внутри методов Граф Куля то у вас же входные то Поля те же самые Вот и вы можете на самом деле Граф ql использовать не как язык запросов где будет как бы возможность объединения А вы можете на самом деле как независимые запросы их использовать Чувак короче весь сервис переписал за 3 часа там было что-то около там 20 ручек и никаких проблем то есть на самом деле их можно чуть ли не полу автоматически Отвечая на этот вопрос такое реализовывать Я вот сейчас отвечаю понял что на самом деле можно такое сделать Вот потому что мы просто фронтендер взял на котле не переписал никаких проблем не было так что надо будет такую штуку реализовать Спасибо Спасибо друзья давай выберем лучший вопрос за идею на лету за идею супер Можно пожалуйста подарочки сюда но тебя Мы отпускаем не сразу у нас для тебя тоже есть на самом деле подарок а за то что ты подготовил и выступил С таким очень классным докладом Можно пожалуйста мне подарочек принести А пока его несут я скажу что мы спикера отпустим Но на самом деле у вас есть возможность с ним пообщаться позадавать вопросы копнуть вглубь Да мы переведём в дискуссионную зону обсуждения которая будет находиться справа от выхода из шатра Спасибо тебе большое Олег"
}