{
  "video_id": "ueERqeB1YOM",
  "channel": "HighLoadChannel",
  "title": "nbtree-индексы в PostgreSQL. Полезные новинки / Виктор Егоров (DataEgret)",
  "views": 4709,
  "duration": 2383,
  "published": "2019-07-18T07:46:26-07:00",
  "text": "добрый день рад всех приветствовать второй день конференции меня зовут виктор егоров я работаю в dota игры от компании администратором и сегодня я хотел бы поговорить с вами про индексы в погрузке вере и конкретно про mp3 индекса это самый популярный тип индексов которые наиболее часто используются в базах данных значит о чем мы будем говорить во-первых собственно почему появилась необходимость делать какие-либо изменения в индексах потом мы немножечко поговорим об устройстве индексов далее собственно самих изменениях и в конце еще будет несколько слов других полезных которые появятся в 12-ой версии тоже связаны с индексами начинаем июль 2016 года компания убер пишет блок пост в котором она рассказывает почему она ушла спал русский на майский л есть перевод этого поста на хабре то есть можно почитать понятно что это вызывает резонанс в сообществе начинают обсуждать эту статью обсуждают все претензии которые высказал uber ничего нового они не открыли то есть это старые проблемы которой есть пользовались и обсуждаются методы решения этих проблем существующих версий по выпуске ел и безусловно возникает дискуссия на тему того что же можно исправить чтобы дальше у нас подобных ситуаций не возникало один из членов сообщества маркус винанд сделал достаточно подробный обзор ключевых пунктов блок-посте я убирает а вот последняя ссылка на этом слайде можно почитать основные причины которые претензии которые высказал uber следующие во-первых них было большое количество апдейтов по одной большой центральной таблицы на которой почти все колонки были проиндексированы то есть у них такая схема плохо работала ну и естественно в сообществе сказали что увы и ах к сожалению из-за того как устроена version на я модель подоспела при таком паттерне наличие долгих транзакций в системе приводит к распухание таблиц и индексов это то от чего страдал uber понятно что следующий претензии было отсутствие вторичных индексов вторичным индексом называется такой индекс в котором хранятся не указатели на записи в таблице а указатели на ключи в первичном яндексе в возрасте таких индексов нету и насколько я знаю даже себе текущий момент не планируется их создания следующий претензия была называемая балансировка индексов но я полагаю что в связи с тем паттерном которую они выбрали у них очень пухли индексы и им приходилось их очень часто индексировать то есть это скажем так дополнительная нагрузка на админов им это не нравилось понятно почему не нравилось последняя претензия была бинарная репликация ну им очень не повезло в подписи к сожалению проскочил баг который в уникальных индексов допускал дубликаты они этот баг хлопотали и он по бинарной реплика репликации улетела у них на все реплики то есть как бы понятно им после этого бинарная репликация перестала нравиться они сказали что им больше подходит стоит на слово репликации в майлз келли несмотря на то что собственно проблема была не в самой репликацией а именно то что бак произошел в другой другой части базы данных и к сожалению с реплицировать с реплицироваться какие улучшения были предложены сообществом самое первое что предложили и to write амплификация removal метод в полисе есть такая оптимизация которая называется ход если вы делаете апдейт колонки которая не индексирован и возраст не меняет индексы он меня это только таблицу если у вас достаточно высоко нагруженная система это очень хорошая оптимизация которая позволяет гораздо меньше писать информации на диске данная оптимизация форм она сделала шаг вперед и она предполагала что если вы делаете апдейт по колонке а это колонка участвует ну допустим только в одном яндексе из десяти поменяется только этот один индекс остальные индекса не затрагиваются ну то есть это чуть чуть хуже чем ход но уже хорошо над оптимизацией работали примерно год к сожалению не закончили потому что не было возможности ее реализовать полноценно без изменения физического формата хранения данных от нее отказались но было предложено ряд других решений в частности сообщества приняла концептуальное решение что они слой который работает с сохранением данных в таблицах вынесут за api таким образом что можно будет реализовывать расширение которое будут хранить данные разными способами всем при этом что транзакционный движок блокировки они остаются на прежнем уровне 12 версия которая сейчас уже в бета состоянии вы можете ее качать тестировать в нее уже сделано серьезное количество изменений которые вынесли этот слой за api этот api уже более-менее стабилен сразу же начали писать extension то есть я думаю что там процентов 10 писем в списках рассылки они именно обсуждают вот эти вот расширения которые будут основаны на этом api тую стену в частности за это за хит это расширение которое делает enterprise бы она реализует модель versio нирования такую как вора клей когда таблица это одна часть а ангелок это другая часть они как бы разделены на затор это по-моему ребят которые делают green план это колонна и хранение данных то есть как только api стабилизируется то она сразу же два расширения которая позволит сохранить данные разными способами еще она оптимизация это ритейл индекс делись в данный момент если вы удаляете запись из таблицы из индекса из индекса соответствующий этой записи включение удаляются просто потому что нету прямой ссылке невозможно а это крайне важно для того чтобы поддерживать здоровье индексов и вот собственно dale индекс дели шин это те оптимизация которых я сегодня буду рассказывать но прежде чем мы им перейдем давайте поговорим об устройстве индексов и тут я вас отправляю в исходнике под раз а если вы этого боитесь что категорически не надо этого делать там все очень классно в частности ридми файл крайне информативен там описано все что происходит с индексами как происходит вставка данных как происходит удаление что такое сплит ой как строится дерево как происходит производится вакуумирование и так далее там обычный английский язык понятно что там есть термины но разобраться вы сможете это однозначно кот очень клёво написан его очень хорошо и удобно читать однако если мы говорим об mp3 индексах они поддерживают 2 внутреннюю структуру вот возьмем случае у нас пустая таблица мы начинаем туда писать данные наши данные которые являются ключами с точки зрения индекса пишется в листочек блок листочек индекса в упорядоченном виде то есть все наши ключи они упорядочены пока мы только начали писать у нас блок только один то есть у нас индекс состоит из одного блока в нем нету дерево потому что дерево не нужно как только мы пишем больше данных у нас листочков становится больше как только он остановится два листочка у нас появляется необходимость прыгнуть в любой из этих листочков быстро то есть не заниматься перебором списка а попадать в нужное место для этого у нас появляется еще один уровень слой дерева то есть я не знаю как вас отображать сам я листочки типа примерно зеленые дерево примерно синий а вот то есть у нас начинает формироваться дерево в данном случае в этом дереве единственный элемент является его корнем несмотря на то что он верху это корень чем больше мы пишем данных тем будь тем больше она становится листочков у нас уже не хватает на первом уровне и вот этих вот промежуточных так называемых веточек у нас появляется еще один слой и так вот у нас дерево начинают расти вверх а листочки начинают расти в стороны при этом все листочки это упорядоченный 2 связанный список а дерево это бинарное дерево в котором можно осуществлять бинарный поиск и собственно это те две основные операции которые происходят внутри индексами у нас либо проход по дереву которая называется unix can либо обход списка которая называется range scan для того чтобы попасть в нужную точку списка нам нужно всегда против по дереву в идеальном случае когда у нас уникальное индексу мы работаем только с проходом по дереву то есть мы прошли по дереву попали в нужную точку и мы либо нашли интересующую наш ключ либо и мы его не нашли то есть либо да либо нет все очень просто это самая быстрая операция работать с индексами это то к чему она как бы желательно стремиться не всегда так бывает потому что например если вы хотите выбрать не знаю все покупки за час то вам надо за этот час но уже будет сделать ироническом но тем не менее это две основные операции которые используются с индексами небольшой пример запрос в котором мы ищем заказы конкретного каста мира начиная с 15 января этого года у нас два индекса в первом яндексе у нас в начале идет кастами райден потом дата а втором яндексе наоборот начали дата потом кастом ради давайте смотреть что же получится в первом случае мы сразу же прыгаем на нужного карта мира и делаем небольшой range скан возвращаем все нужные данные как только каждом ради меняется мы понимаем что мы уже вышли за наш диапазон скан заканчивается во втором случае поскольку мы бежим по дате мы прыгаем самое начало списка и начинаем сканировать весь диапазон дат понятно что если это происходит в конце января диапазон будет небольшое будут работать быстро если это будет в конце августа или в декабре диапазон будет гигантский и скорее всего планировщик поступит умным образом вообще не сделает индекс как сделать стекло скан о чем это говорит о том что когда вы создаете индексы для тех запросов которые вы пользуетесь вам выгоднее ставить атрибуты с которыми вы работаете на равенство в начало составного индекса то чтобы в начале шли атрибуты с которыми вы работаете на равенство в конце шли атрибуты с которыми вы работаете по диапазону таким образом вы позволяете механики работы с индексами быстрее прыгнуть в нужное место и сделать минимальный скан по диапазону то есть у вас скажем так получается лучше работающий индекс для ваших запросов часто встречающийся вопрос особенно у наших клиентов и поэтому я хочу заострить на этом ваше внимание в данной картинке у нас более менее скажем так идеальный случай когда все данные очень сильно отличаются ну что происходит если у нас но такой очень выраженный случай в полисе есть расширение пиджин спект она позволяет нам смотреть что физически хранится в таблицах и в индексах если мы его установим создадим такую таблицу в которой будет одна болевая колонка сделаем яндекс по этой колонке и засунем туда 10 тысяч записей как вы видите я в эту колонку всегда вставляю только одно true значение то есть по сути получается у нас ну как бы мы понимаем что этот индекс не очень ну как бы хороший но тем не менее я это дело для того чтобы продемонстрировать ну скажем так совсем критический случай и вот есть функция которая показывает место страничку яндекса эта страничка она присутствует всегда в любом яндексе и поэтому минимальный размер индекса у вас два блока в этой страничке находятся там магическое число служебная информация вершина эта версия индекса у нас рут корень дерева находится в третьем блоке и у нас всего один уровень у этого дерева то есть у нас как бы набор листочков и над ними один корешок этого достаточно для того чтобы писать вот все наши 10 тысяч записей следующий запрос он просто-напросто берет информацию обо всех блоках листиках в этом яндексе и сравнивает общий размер блока со свободным местом которым в этом блоке находится и мы увидим что после такой операции у нас 30 процентов место в яндексе пустует мы создали табличка создали индекс наполнили ее у нас на ход 30 процентов пустого места почему так происходит потому что у нас кругом одни и те же значения они не уникальны и более того у нас дерево наша работает плохо потому что ну как бы поиск по бинарному дереву предполагает что там элементы отличаются а у нас они не отличаются мы всегда при вставке одинаковых значениях идем ну как бы в самое начало нашего списка и потом добавляем вот в это большой-большой хвост туда куда ни будь то есть работает крайне неоптимально и сейчас немножечко в теории принцип построения индекса если вы прочитаете ридми файл на которой я сослался они говорят что по здесь реализуют алгоритм лиман я у это научная публикация очень-очень давно сделано и алгоритм лимон и я у предполагает следующие условия что любые ключи под дерево с удовлетворяет условия к это снизу то есть идет строго неравенства и сверху к и плюс один не строгое неравенство то есть если мы возьмем любой блок и все ключи в этом блоке они должны быть в диапазоне между двумя элементами дерева на верхнем уровне то есть элементы дерева на верхнем уровне должны отличаться как мы только что видели у нас это правило не выполняет второе условие все колючки должны быть уникальны у нас это тоже не выполняется то есть у нас две достаточно основополагающих концепции алгоритм они выполняются в реализации поиск ел до сих пор это было не так вставка осуществлялась в конец этого длинного хвоста почему так потому что мы проходим по дереву падаем в начало списка начинаем искать место куда же вставить наш ключ у нас кругом одинаковые значения по большому счету мы можем вставить в любое место для того чтобы вставить в первую страницу в не должно быть места если вместо есть мы вставляем все хорошо а если вместо нет нам надо эту страницу разделить то есть а операция деления она трудоемко и поэтому мы предпочитаем не заниматься этим а идти дальше по списку искать пустое место но чем длиннее у нас писк список тем дольше мы идём в конец списка и когда-то это было так это квадратичная сложность алгоритма это все ужасно купила сделали такую оптимизацию в одном проценте случаев то есть просто рандомно мы решаем что они мы не пойдем список мы просто все бросаем и вставляем вот прямо сейчас сюда даже если нам надо сделать плит как бы она позволяет избежать вот этой квадратичной сложности но к сожалению у нас крайне неоптимально идет наполнение индекса вот то что мы видели 30 процентов пустого места почему это ну как бы такие недостатки помимо описанных не эффективное наполнение невозможность для запись в таблице найти ключ который ей соответствует это означает что если вы удаляете запись из таблицы из индекса ничего не удаляется все это удаление всегда откладывается до процесса вакуума вакуум поступает следующим образом он сканирует таблицу находит все записи которые нужно удалить складывает их в мейтенс воркман и потом отдельно просканирует все индексы и все указатели которые у него есть вот в этом своем в кэше он их вычищает из индекса если в mit uns форкмэн маленький и не хватает на всю таблицу он будет эту итерацию делать несколько раз поэтому лучше для того чтобы вакуум работал нормально - вор км м делать побольше и вся эта конструкция способствует распухание индексов потому что если вы думаете что вот мой случай который продемонстрировал он такой вырожденной я умышленно вставляю туда одинаковые значения то вот представьте ситуацию которая была убера у него очень высоко нагруженная таблица все колонки проиндексированы идет большой поток апдейтов если сейчас меняется запись в не меняется какой-то как какая-то колоночка и обновить нужно все индексы даже в которых эта колоночка не участвует то соответственно для тех индексов где-то колоночка не поменялось мы тупо будем добавлять дубликате ки вот процесс распухание а вычищает все эти дубликате ки только вакуум а если у вас очень долгая транзакция там отчет 2-часовой the vacuum не может ничего это вы чистите у вас это все начинают копиться копится копится копится копится индексация исправляют ситуация то есть если вы запустите ри индекс для этого индекса он вернет вот процент занятого ой процент пустого места примерно десяти процентам потому что это стандартный фил фактор который ну по умолчанию для миксов используется какие были изменения указатель на запись в таблице и теперь используется как у уникальный ключ у нас формат сохранения данных в яндексе не поменялось а у нас указатели на таблице они были там всегда но почему-то мы их не использовали теперь мы просто-напросто изменили алгоритм таким образом что всегда этот указатель используется как дополнительный той breaker и таким образом у нас любые ключи даже если они с точки зрения логических данных являются дубликатами за счет того что они хранятся в разных записях они все уникальны 2 оптимизация это софикс francais en если на предыдущем слайде я показывал что диапазон ключиков в одной страничке должен находиться между двумя указателями на уровне выше скотт если два указателя на уровне выше там я не знаю длины у вас составной индекс состоящий из пяти полей но если эти два указателя отличаются допустим в первых двух полях то мы можем суффиксы просто отбросить они нам не нужны мы по первым двум полям уже можем ну скажем различить этот диапазон этого достаточно и вот это начинает активно сейчас использоваться в новой версии и очень сильно было переработано эвристики которые используются для того чтобы выбирать точки где мы делим страничке например если алгоритм видим что у нас идет монотонно возрастающее значение там какой-то первичный ключ суррогатный он использует одну эвристику если мы вставляем какие-то бизнес данные и он видит что если сделать вот в этом месте разрыв то мы сможем там не 50 байт указатель записать а 20 байт потому что у нас будет эффективно работать софикс тонкий он будет поступать именно таким образом я привожу ссылки на кометы в этих камерах есть более подробное описание что там происходит и ссылки на обсуждение собственно этих изменений в как в процессе их реализации картинка теперь выглядит так у нас везде используется указатель на запись у нас все ключи являются уникальными как в листиках и так в дереве у нас дерево начинает работать правильно как только мы хотим вставить еще один дубликат мы можем просто за один проход по дереву найти нужное место потому что у нас ну как бы все ключи уникальны это работает быстрее это работает корректней если запустить и тот же код то есть создать эту таблицу также ее наполнить на двенадцатой версии у нас свободного места всего 4 процента то есть плотность наполнения очень классная что изменилось формате все листики уникальны в дереве в данном случае ключи увеличились по сравнению с тем что было потому что туда добавился указатель на строку которые занимают чтобы не соврать вам шесть байт но за счет того что мы плотнее наполняем страничке то есть старый занимал 359 листиков она вы всего 257 листиков то что у нас дерево увеличилась это ни на что не повлияло мы как бы сократили более здоровый кусок объема за счет плотность не наполнения и состоянии индекса оно такое же или возможно даже лучше чем после операции индексации то есть это означает что в двенадцатой версии вы в принципе можете вполне себе создавать таблицы потом создать на ней яндекс и только после этого наполнять ее данными потому что на текущий момент рекомендация вначале наполнить данные потом строить яндекс и потому что индексы ну как бы более оптимальным образом строятся это не относится к тому что если у вас таблицы на ней огромное количество индексов вы пытаетесь загрузить данные то это будет ну занимать большее время чем если вы поступите наоборот я говорю только о качестве наполнения индекса сейчас посмотрим на другой случай другая немножечко табличка в ней 5 колонна чик вот с такими вот дефолтным и значениями мы вешаем на табличку это составной индекс на эти 5 атрибутов и заполняем его миллионам записи в текущей версии у нас получится для листиков 20 процентов свободного места для веточек то есть это intermediate в терминах английского языка 47 процентов свободного места мы делаем ри индексацию она сразу же эти показатели прыгают до девяти процентов для листиков и только до 30 процентов для веточек то есть наглядный пример что вот такие индексы они очень тяжелы для начальной загрузки данных или индексация помогает если мы используем двенадцатую версию то у нас сразу же наполняемость листочков составляет около 4 процентов свободного места всего то есть мы дико плотника туда все нагоняем и свободное место в веточках она примерно соответствует таком тому же что и было после индексации у и общий размер индексом он как бы гораздо меньше чем в 11 версии вот такая вот штука я очень доволен вот этими изменениями просто потому что они работают из коробки ни чего не нужно делать а мы получаем круг дико клатч качественное наполнение индексов какие дал дальнейшие улучшения могут быть на основе того что уже сделано во первых сейчас суффиксы отрезаются по границе атрибутов если вы индексируется какие-то большие строки то дальнейшим логическим шагом будет резать не по границе атрибутов а выделять там ну начала подстроки ну как бы такой самый наверно актуальный пример можно привести это гид у него commit хэши из х 140 символов но когда вы смотрите лог там показываются примерно 7 8 символов которые достаточны для обеспечения уникальности примерно то же самое можно сделать и здесь и это уже ну скажем так заявленной разработчиками и такая оптимизация позволит еще больше уменьшить размер дерева древовидной части индекс ну и соответственно как бы улучшить пропускную способность индекса 2 крайне важная вещь и это теперь возможно удалять ключи во время микро вакуума микро вакуум это процесс когда мы видим что на этой страничке в таблице нету места но мы видим что некоторые записи уже никто не может увидеть и мы можем их ну как бы вы чистите память как пустое место сейчас когда мы удаляем эти записи из индекса ничего не удаляется потому что мы не можем найти ну то есть надо делать большой перебор в яндексе то выжидать этих изменений мы можем вам известны все атрибуты нам известен указатель на строку мы можем за один unix can проход найти нужное место и удалить из индекса то есть здоровье индексов будет гораздо лучше и третья вещь это за счет то инфраструктуры которая была добавлена будет возможность создавать глобальные индексы на partizani rowan их таблицах то есть полноценная глобальный индекс когда индекс покрывает сразу же все партиции с моей точки зрения ну это возможность не самая лучшая для перформанса потому что ну как бы вы делите большую таблицу на партиции потому что у вас там все слишком громоздко и вы хотите чтобы это работало быстрее если вы сразу же сверху вешаете глобальный индекс ну как бы вы идете в обратном направлении с моей точки зрения но тем не менее такая возможность есть доступность новых изменений новый формат индексы 4 то есть в данный момент времени в текущей версии в 11 формат 3 новый формат будет 4 если вы ставите двенадцатую версию создаете там индекс он автоматически строится в новой версии однако если вы используете 50 great to get great также как иван клум он индекса не перестраивает потому что его основная задача как можно быстрее ну проапгрейдить вам базу и вернуть ее в рабочее состояние после пиджак грейда вам потребуется рей индексация и вот тут у нас возникает следующая вкусняшка в 12 виде rsi у нас наконец-то появилась такая вещь как или яндекс конкурент ли это означает что мы можем перестраивать индексы без блокировок на текущий момент времени в связи с тем что в по версии есть вот это вот его проблема связана с распухание им таблиц и индексов перестройка индексов это является но рутинной процедурой которые нужно с достаточной периодичностью выполнять на тех базах которые вы обслуживаете и сейчас в случае если индекс уникальный индекс обеспечивает первичный ключ и на этот первичный ключ не ссылаются другие таблицы своими внешними ключами вы не можете просто взять его и перестроить без длительной блокировки на сразу несколько таблиц вы не можете создать новый индекса рядышком и переделать первичный ключ потому что для того чтобы дропнуть первичный ключ нужно дропнуть все внешние ключи а потом как бы вы создадите новые первичный ключ и нужно пересоздать внешние ключи если вы хотите сделать это в рамках одной транзакции то опять очень долго то есть это очень трудоемкое как бы головная боль сейчас rain expert конкурентный душа на все летит без блокировок это это просто сказка я доволен вторая вещь которая мне очень нравится это если мне не изменяет память по моему уже в 96 начиная с версии 96 мы можем наблюдать за прогрессом вакуума которая происходит в подрасе а сейчас добавили возможность наблюдать за прогрессом построения индексов то есть если вы запустили create index креатин из конкуренты или три индекс конкуренты у нас есть системное представление которое вам показывает что это за индекс сколько записи из таблицы была обработана на данный момент сколько записей ну всего нужно обработать вы увидите прогресс это очень полярность если у вас там табличка занимает 100 гигабайт яндекс занимает 20 гигабайт он строится будет примерно час то есть для оценки времени ну там зависимости от того какие у вас диски в зависимости от того какие у вас параллельные транзакции происходят в системе как бы полезно еще из полезности gist индексы теперь позволяют использовать опцию include то есть вы можете делать покрывающий индексы так называемый для гис то и еще одна оптимизация которая упала это существенно уменьшили объем трансакционного лова которые генерится при создании диск джейн спг индексов то есть все эти изменения они не так значительны и как те которые были сделаны в mp3 индекс но тем не менее они скажем так с моей точки зрения стоило бы сказать ну и в общем и целом сейчас еще раз 12 версия находится в стадии бета-тестирования я очень призываю вас всех ios скачать посмотреть покрутить потому что там очень много всяких вкусняшек и возможно вы найдете что то что нужно именно вам и если вы найдёте какую-нибудь непонятка косячок и зарепортить это это вообще вам респект и уважуха у меня наверное все получилось достаточно быстро если у вас есть какие то вопросы пожалуйста задавайте виктор спасибо за доклад вопрос такой есть три основных преимущества двенадцатой версии возраста с точки зрения работы с данными самое первое то о чем я рассказывал потому что это работает из коробки и но она работает этот давно надо было сделать именно работы с данными были существенные улучшения по тому как работает парте цианирование то есть они продолжают работать в совершенствовании этой под системы под расстрел а то есть можно как бы посмотреть конкретно что там было сделано я сейчас навскидку не вспомню но однозначно по моему у нас появились полноценно внешние ключи то есть если раньше как бы можно было ссылаться только спарте цианирования таблиц на другие то теперь в обратную сторону тоже работает так и что еще такого интересного туда упала с точки зрения как бы с точки зрения из кейсов для чего теперь возраст использовать стало больше каких-то ну скажем так вот это изменение тбм который он начал он не закончен но те изменения которые были сделаны но он не скажем в как впечатляют я понимаю что это задел на будущее и вы не можем им пользоваться непосредственно сейчас в двенадцатой версии вот но скажем так это работает очень серьезно и я считаю что ну-ка банана и самых важных который сейчас производится вам всем будет очень полезно знать что в двенадцатой версии изменилось то как работает репликация возможно это не связано с данными но это очень важно потому что обратная совместимость немножко поломалась теперь конфигурация которая относится к репликации внесена в подгрузки алкан в основной файл конфигурации то есть это нужно учитывать и нужно обязательно почитать про это потому что там действительно изменилось работает иначе конфигурационные файлы поменялись то есть как бы вот обращая на это внимание спасибо большое спасибо за доклад у меня остался вопрос по поводу глобального индекса для порционирования таблиц зачем так вообще делать у меня такой же вопрос зачем так делать то есть я по своему опыту в крупных системах с которыми я работал там одна из первых оптимизацией если есть глобальная индексом просто приходим и их грохот и это может оказаться чревато если на базе просите проходной двор но это идет как бы комплексное решение вместе с такими оптимизация my еще очень ужесточается контроль за доступом к базе чтобы туда ну скажем так обыкновенные пользователь с правами изменения данных вообще не допускались то есть чтобы только через приложение это все работало если возникают косички мы их исправляем на уровне приложения то есть понятно что как только мы играем например глобальный уникальный индекс то у нас внезапно могут появиться дубликаты если что-то где-то пошло не так то есть мы снимаем эту ответственность базы данных вот чтобы это не пошло не так нужно исключать человеческий фактор в первую очередь ok но возможен ли кейс когда глобальный индекс оказывается предпочтительнее построения индексов огненным таблицам или это просто поддержка для того чтобы те кто так уже сделала чтобы не лишать хоть и возможности ну как бы я думаю что это скорее всего второе сейчас вы можете построить по парте тонированные таблицы глобальный индекс но только с одной оговоркой вы его если будете строить вас puzzles обяжет включить в этот индекс колонки портится не то есть за я за этот счет нам как бы обеспечивается уникальность потому что каждая partition уникально в рамках этой колонке профи санирования ну вот таким образом эти индекс устроиться на мой взгляд вот того что есть этого достаточно то есть просто глобальный индекс по всей таблице строить ну нет необходимости спасибо спасибо у меня дополнение вопрос дополнение про 12 по фгос во первых там джейсон расширился поддержка стандарта в общем олег то что олег и завещает и второе это благо был storage engine я не знаю что такое что такое вас новинки по работе с данными вообще свобод это про работу с данными тут все новинки правоту сдано вот это две очень серьезные вещи но мне кажется вещи по которой виктор рассказывал про индексы это вообще на первом месте потому что ну потому что там кучу более улучшены исправлены теплоты индексы и так далее я пропустил начала доклада ты тестировал улучшение того как плод на когда ряда я показывал то есть там реально как и разработчики говорили что во сколько раз и низ первичное наполнение таблицы с построенным индексом она плотность наполнения лучше чем после индекса то есть примерно в районе четырех пяти процентов свободное место при i feel factory default нам 10 процентов свободного места а вот при апдейтах там улучшения петр но как бы при апдейтах там это уже все фактор не учитывается вот ну при апдейтах скажем так эти изменения они не решают к сожалению проблема болото как такового не просто заставляют индексы работать гораздо качественнее и лучше то есть они немножечко сглаживают проблем она совсем от не избавляются улучшение есть именно за счет того что у нас сейчас все записи уникальные индексы работают быстрее и у нас эвристик а вставления данных в нужных местах очень улучшилась как бы я повел фактору это уже определить не смогу наверное потому что фактор влияет только на первичный наполненный таблиц в этом сторону я пока еще не капал глубоко спасибо за доклад вопрос по индексации джейсон б то есть когда мы делаем яндекс не полностью по всей колонки а хотим проиндексировать по отдельным ключам и после этого выполняем апдейт по ключам и джейсон b будет ли изменён индекс случае если мы изменяем ключи который не присутствует в яндексе именно касательно джейсон бета я думаю что такой непростой вопрос то есть раньше они менялись то есть раньше индекс перестраивался я вам с наскоку не скажу потому что это нужно протестировать я вас немножко в другую сторону отправлю если вы храните какие-то данные джейсон b и вы строите поверх джейсон б индексы по отдельным ключам то возможно вы захотите вынести эти колоночки виде отдельных нативных атрибутов на уровне колонок в таблице и проиндексировать их естественным образом это будет работать просто быстрее да сейчас так и сделано вот как бы насчет того будут ли они обновляться или нет если честно я затрудняюсь вам ответить на себя на надо потестировать но вот эти вот оптимизации все будут в принципе работать джесси b также да ну как бы они работают с любыми батареи индексами то есть не важно то есть еще раз это mp3 индекса то есть не то ниже не диск вот ну да будут работать будет хорошо спасибо спасибо на этом видим вопросы закончились спасибо большое за доклад да спасибо назови пожалуйста автора лучшего вопроса самохвалова мы не не очень он не участвует самохвалов не конкуренции я пожалуй дам вопрос который был про новые улучшение в двенадцатой версии при работе с данным мне он понравился спасибо за вопрос"
}