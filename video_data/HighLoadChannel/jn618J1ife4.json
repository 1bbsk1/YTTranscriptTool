{
  "video_id": "jn618J1ife4",
  "channel": "HighLoadChannel",
  "title": "Скрипты в приложениях. Как и зачем пользователям позволять писать код?/ Андрей Привалов (Adscompass)",
  "views": 132,
  "duration": 2507,
  "published": "2024-10-29T03:05:16-07:00",
  "text": "Ну а сейчас я приглашаю на сцену Андрея для того чтобы он нам рассказал о том зачем людям писать код Зачем пользователям писать код У меня тоже такая проблема есть потому что я им дала возможность писать код а они просят ещё и ещё и ещё а они по написали да Ага Всем привет Так Меня зовут Андрей привалов Работаю я в компании а компас в основном я пишу на ГО и если у кого-то Будет желание со мной связаться после доклада в большинстве соцсетей я нахожусь под ником Несс Ну сразу хочу сказать что понимаю что все устали первый день Самый насыщенный постараюсь обещаю что будет не очень долго Итак о докладе условно я разделил свой доклад натри неравнозначные части первым делом мы обсудим некоторые термины чтобы лучше друг друга понимать я Расшифруй название доклада по словам Да чтобы донести ту мысль которую я вкладываю это название Я приведу примеры которые показывают что вот этот подход позволять писать пользователям код он используется на самом деле очень широко далее я Коротко покажу примеры быстрого старта что Ну если мы хотим уже сейчас да как-то какие-то готовые решения или библиотеки использовать в своих приложениях и попробовать исполнение пользовательского ввода и затем заключительной самой большой части мы пройдём по пути когда Готовое решение нам не подходит когда мы хотим написать какой-то свой DSL мы обзорно поговорим про токены про абстрактное синтаксическое дерево и в целом Да какие надо пройти шаги чтобы какой-либо скрипт превратился в какой-то результат Итак скрипты в приложениях как и зачем пользователям позволять писать код что я имею в виду под фразой скрипты в приложениях это речь про встраивание в приложении возможности исполнять какой-то пользовательский ввод довольно часто это называется термином динг Хотя это термин очень широкий Да он и многие другие вещи покрывает что я имею в виду под словом код это как классика какой-то скрипт написанный на лоа на дсе на чём-то ещё на каком-то собственном ле так и в принципе какой-либо текст любой какой-то пользовательский ввод который имеет определённый формат который нашим приложением парси приводится к какому-то внутреннему виду и затем исполняется и наконец Кто такие пользователи Мы привыкли думать Вот слышим фразу пользователя что это какой-то человек с улицы Да который пользуется нашим продуктом мы его любим Но тем не менее это сторонний человек но на самом деле в контексте моего доклада пользователи - это все мы да давайте вот приведу Пример например администратор Да админ какой-то или devop сидит Он является пользователем для продукта прокси сервер он пишет для него там плагины он что-то его конфигурируется использует его как есть и что-то привносит своё э-э например геймдизайнер он является там пользователем для игрового движка он пишет какие-то скрипты для NPC квесты и прочее прочее Ну и в принципе все мы Да мы разработчики которого мы пользуемся сторонними библиотеками сторонними продуктами мы являемся там пользователями этих решений поэтому в моём докладе под словом пользователь я понимаю всех нас и давайте сейчас попробуем ответить на вопрос Зачем позволять пользователям писать код Да что за странная идея приведу вам несколько довольно очевидных примеров например нхо прокси Да эти широко известные продукты позволяют нам писать плагины наа которые они затем исполняют то есть да Ну все понимают нам нет необходимости залезать в исходники и джинсы и так далее мы пишем плагины и уже Н это исполняет ФК тоже широко известный прокси сервер он умеет исполнять плагины написанные на языке Go и что важно Это не та классика которой мы привыкли мы написали какой-то Код Да мы его скомпилировать и запустили бинарник нет фик исполняет плагины написаны ногой именно как интерпретатор графа на К6 если кто-то не знает это есть такой инструмент нагрузочного тестирования от ко графана он умеет исполнять пользовательские сценарии написанные на языке JavaScript Unity в моём слайде Unity - это как некий собирательный образ для всех игровых движков Да о чём я уже упоминал игровые движки Ну каждый уважающий себя игровой движок он обязательно предоставляет возможности скриптинга Да этими скриптами описывается логика NPC описывается квест описывается характеристики каких-то айтемов и прочее прочее прочее значок поса точно также собирательный образ для всех движков баз данных и мне кажется это самый яркий и понятный всем пример ведь на самом деле что такое движок базы данных и SQL Запрос который мы исполняем SQL запрос - это пользовательский ввод Если угодно пользовательский скрипт который имеет определённый формат и движок базы данных его исполняет Ну и промити последней на этом слайде пример тоже широко известный продукт кстати написанный ногой ещё буду его немножко упоминать он умеет исполнять запросы на языке promql для выбора временных рядов тоже как бы очень яркий пример что пользовательский ввод мы как пользователи этого продукта пишем этот ввод Он его исполняет думаю что этими примерами Я наверное уже закрыл широкий Пласт применением динга но я хотел бы привести ещё парочку неочевидных примеров например уточнение поискового запроса Ну вот мы хотим поискать там котиков Да в Гугле каком-то И вдруг нам пришло в голову там поискать на определённом сайте Либо мы хотим поискать документы определённого типа и вот как раз вот эта часть строка уточнения поискового запроса это не какой-то абстрактный текст который движок понимает как есть Это именно что пользовательский ввод который опять же подчиняется определённым правилам поисковый движок его распарсить и как-то применит к выдаче утилита JQ широко известная утилита для получения доступа к Jon элемента внутри документа код не Код да строку кото мы подаём на вход этой утилити когда мы указываем путь до Джейсон элемента Это тот же самый пример динга это какой-то свой определённый язык Да если угодно который опреде определённый формат имеет и последний вопрос мне не вопрос пример мне он нравится своей не очевидностью вот Excel Да что такое Excel все им пользовались пользуются там какие-то Циферки А что такое формулы в Excel Это тот же самый пример какого-то ля То есть это они имеют формат они имеют какую-то законченную грамматику их конечное количество и когда мы пишем туда формулы движок экселя Это не просто как текст воспринимает а вынужден распарсить и применить каким-то результатам Окей полагаю что я вас убедил что исполнение пользовательского ввода - это на самом деле обычное рядовое явление Давайте коротко о быстром старте мы ответили на вопрос Зачем позволять пользователям и Давайте сечас нам отвечать на вопрос А как позволять пользователям писать код для быстрого старта Я выбрал несколько го библиотек Разумеется Ну гораздо больше мы не ставим себе целью все их покрыть и библиотеки выбирал я Ну примерно по такому критерию во-первых мне со всеми с ними приходилось в той или иной мере работать во-вторых Мне кажется эти библиотеки каждый в своей нише такие лидеры наверно можно сказать наме библиотека пот м в вашем приложении исполнять скрипты которые написал пользователь к можно относиться по-разному Да этот язык многими не любим че только стоит того что там массивы начинаются с индекса с единицы а не с нуля но нельзя отрицать что - это наверное один из самых популярных языков для динга он используется уже да как в упомянутых мною там нха Проси там пишутся плагины на нём точно также кто-то наверняка игрался там пишутся прошивки для каких-то микросхем и прочее и прочее то есть очень много ран таймов для него написано Эта библиотека позволяет буквально там в пару строчек кода подключить ваше приложение исполнение лоа далее библиотека Гоя Ну возможно её неправильно называю я не нашёл скажем так её расшифровки Как правильно называть Эта библиотека позволяет исполнять скрипты написанно на жава скрипте чем JavaScript хорош Потому что его очень много пользователей зна если вы вот завтра решите что хотелось бы своё приложение добавить поддержку там пользовательских скриптов каких-то этот выбор Мне кажется будет достаточно хорошим Многие из них скажут Вам спасибо и третий пример - это библиотека Яги от команда ФК тоже об этом я же упоминал прокси сервер тфк исполняет плагины Наго с помощью этой библиотеки именно в качестве интерпретатора То есть у вас как у трафика да Или вы если будете использовать эту библиотеку есть полный контроль над происходящим прямо по строчек все возможные какие-то даже популярные непопулярные решения Поэтому в заключение этого слайда я хотел бы дать вам отправную точку Если вы хотите посмотреть А что ещё есть с чем можно поиграться Какие ещё языки есть широко известные репозитории aw Go имеет отдельную секцию ED scripting languages Где вы эти и другие сможете найти и мне кажется это будет неплохая отправная строчка чтобы понять для себя как бы что можно попробовать Окей своё решение да как я обещал это самая долгая секция но и опять же как обещал второй раз постараюсь вас не задерживать перед тем как погрузиться в своё решение Давайте попробуем разобраться А зачем нам писать своё решение уже есть ку библиотек на самом де этот име с для во-первых безопасность здесь речь даже не о том что сторонние решения могут содержать баги Ну конечно могут и наше приложение может содержать баги речь скорее о том что сторонние библиотеки могут позволять пользователям делать довольно много вещей которые мы не хотели бы Ну приведу пример Не хотели бы давать пользователям приведу пример библиотека гофер луана полностью реализует спецификацию 51 отличная библиотека классная что это значит это означает что если пользователь напишет OS то там GV он получит доступ к переменным окружения если пользователь напишет но я не помню точно синтаксис там открыть файл он откроет вам файл на локальной системе Я верю что наверное кто-то Может это юзера захотеть разрешить но скорее всего Да Вам бы это не хотелось делать конечно же взрослые такие библиотеки большие они имеют возможности конфигурирования часто это такими широкими мазками мы там целый Пласт АО там отключим да Или целый Пласт там общения с сетью отключим кто-то Может там разрешать отключать отдельные функции Но для того чтобы это отключить Вы во-первых должны знать Да что есть такие небезопасные функции что их надо отключить Ну в общем слишком много Если получается Поэтому если вы не можете себе позволить довольно вольно с этим обходиться Или вы не очень хорошо библиотеку знаете своё решение может быть выходом производительность ну здесь на самом деле очень много не сказать довод скажем так Довольно простой да Если ваше приложение очень требовательно к производительности а на самом деле это миф что все приложения прямо очень требуют производительности это не так много их но есть приложения которые очень требуют которые эти скрипты выполняют много раз там в секунду и так далее и вы посмотрев код библиотеки сторонний увидели какие-то не оптимальные алгоритмы либо библиотека как-то очень вольно обращается с локациями памяти и все мы понимаем что внести изменения в стороннюю библиотеку Ну конечно можно её склонить что-то поправить но внести в изменения в upstream очень сложно или невозможно Это тоже может быть доводом специфическая доменная область э это как раз аббревиатура относит нас э к DSL Да domain specific languages Language Ну лучше всего Мне кажется это рассказать на таком примере Давайте представим что вы пишете Soft для лазерного станка вот у вас есть печатающая головка с лазером да У вас есть команды Какие переместить его в координату включить там лазер выключить лазер например и в таком случае применение языка общего назначения типа лу JS Да это будет несколько громоздко это будет избыточно вы вы принесёте туда новые функции но они будут выглядеть чужеродное всего в таком случае вам гораздо проще гораздо Правильнее будет написать свой DSL чтобы ребята которые пишут скрипты для станка просто там mov to mov to там On Off написать на самом деле свои ли имеют множество продуктов прям прям огромное множество там какие-нибудь автокадр Shark Blender Photoshop и прочее прочее прочее То есть можно ряд бесконечно продолжать все продукты имеют свой DSL Ну не все Да это я конечно уже преувеличил но я думаю мы поняли друг друга и наконец любим писать велосипеды но я не случайно велосипеды взял здесь в кавычки по моему мнению когда мы пытаемся что-то написать своими руками Пускай не очень сложное это наверное Ну один из самых лучших способов разобраться в теме мы попробовали написать Сами мы поняли как это происходит И после этого мы можем уже готовые какие-то решения использовать и знаем куда там смотреть Итак о чём мы поговорим Давайте создадим свой DSL и для того чтобы он не был похож Нае языки чтобы вот он прямо был такой самобытный я придумал следующую Легенду представим что вы учитель Информатики и вы ваши ученики будут писать вам какие-то скрипты на языке которые вы придумали И вам надо написать интерпретатор собственно для этого языка назовём этот язык School Language и скажу сразу что здесь вы видите ссылочку я на github уже залил репозиторий который вот этот наш пример полностью реализует эту ссылочку я повторю ещё в конце доклада если кому-то будет интересно Вы в конце доклада сможете её сфотографировать и посмотреть у себя это локально Итак это образец Нашего скрипта Нашего ля что этот язык умеет Да он выглядит необычно как я и обещал что этот язык умеет а умеет он на самом деле не очень много он умеет исполнять арифметическое операции плюс минус и умножение Обратите внимание деление Нет не потому что места на экране не хватило А его сознательно оно сознательно опущено мы об этом ещё поговорим а мы умеем использовать переменное присваивать туда какие-то результаты выражений и у нас есть функция показать которая либо строку либо результат какой-то либо значение какой-то переменной выводит к нам в std out в принципе всё то есть язык Довольно простой э но каким же образом этот текст скрипта мы должны выполнить то есть что происходит Как как происходит эта магия Для этого нам надо пройти несколько шагов первый шаг называется лексический анализ мы должны из нашего текста получить набор токенов Что такое токены Ну это некоторые неделимые объекты нашего текста здесь на экране вы сейчас видите примеры токенов которые могут быть сгенерировано по образцу этого Кода да например какой-то идентификатор B знак равенства то есть видите у нас слово равно Да но это один маленький токен который обозначает собой знак равенства какой-то числовой Литерал и так далее Почему я сказал и подчеркнул что этот набор токенов может быть сгенерирован по этому образцу на самом деле разработчик сам решает что в его коде является значимым А что нет если например вы хотите заканчивать строки точкой запятой то Разумеется для точки запятой у вас должен быть отдельный токен либо другой пример Да если вы хотите сделать значимые отступы как в питоне например то для каждого отступа у вас должен быть отдельный токен чтобы затем мы могли учесть Да сколько отступа у нас там перед строкой находится Окей мы сделали набор токенов И следующий шаг называется синтаксический анализ как это часто называют парсер уже приступает дело поток токенов подаётся на вход парсе который строит абстрактное синтаксическое дерево в нашем случае ну и в целом Да абстрактно синтаксическое дерево - это уже конкретно какой-то код ногой это какой-то набор госструктур которые между собой связаны указателями ссылочка и прочим прочим Ну поскольку у нас реализация на го да поэтому это го структура если бы мы на другом языке писали то это дерево было бы уже на другом языке про построение этого дерева Мы ещё поговорим чуть-чуть подробнее и последний шаг Вот это наше построенное абстрактное синтаксическое дерево подаётся на вход Интер на исполнение и Ну в принципе исполняется Да если можно так сказать но мы этого ещ тоже немножко коснемся Окей лексер Который превращает наш текст в поток токенов на самом деле превратить текст поток токенов это не выглядит очень сложная задача Я думаю что многие из вас сходу могут несколько вариантов придумать то есть да Ну например мы итери просто по символу вот нам на вход попал текст мы находим пробел смотрим Что было большая буква О'кей значит это идентификатор мы видим какую-то цифру Мы ждём следующего пробела и получаем число мы видим слово равно О'кей мы знаем что это токен знака равенства А в своём проекте Здесь вы видите структурою того демо проекта на гитхабе Я использовал подход регулярных выражений ни в коем случае не призываю пользоваться этим подходом на самом деле я его для наглядности использовал не скажу что он самый лучший самый худший это просто один из вариантов построения токенов из нашего текста Вот так дальше пойдём Перед тем как перейти к парсе Да когда у нас уже есть токены Я хотел бы Напомнить пару важных определений это Expression и statement ну своей презентацией я буду ещё пользоваться переводами выражения инструкция то есть что такое это блок кода который возвращает какое-либо значение в свою очередь инструкция - это блок кода который выполняет определённое действия Ну например да поместить в переменную результат выражения операторы условного перехода If там операторы цикла фо там какие-то операторы Switch - это всё инструкции Да это стейтмент то есть по факту наша программа нашего языка которую мы пишем каждая строчка - это отдельная инструкция то есть наша программа - это набор инструкций Почему важно не путать выражение инструкцию Ну я хотел бы привести пример именно для нашего языка го если Мы повесим наше выражение как бы в воздухе Да 10 П 20 это валидно выражение но компилятор не поймёт что с ним делать он этот результат куда-то должен применить куда-то в переменную обозна Да поместить в функцию как аргумент передать и так далее То есть он не понимает что происходит и тоже самое что будет если мы поместим инструкцию туда где ожидаем выражения здесь немножко последняя строчка подчёркнута с подвохом я уверен что практически все знают но может быть и нет что оператор инкремента Go он не возвращает значение То есть когда мы посмотрим на этот код Ну если вот убрать первую ошибочную строку и мы такие М X = 42 Print lnx Ну выведется или 42 или 43 точно не помню как бы человек да мог бы подумать на самом деле эта программа не скомпилировать какое-то выражение то есть то что возвращает результат а оператор инкремента результат не возвращает вернёмся к нашему парсе Итак у нас есть какой-то набор токенов И давайте сейчас мы с вами сыграем роль парсера мы пойдём по порядочную Разумеется важно помнить что вычисление этого дерева всегда начинается с первого узла потому что приоритеты операторов могут вынудить нас перестраивать это дерево мы это сейчас увидим Итак мы парсер мы видим идентификатор B мы видим знак равенства и видим какой-то числовой Литерал Ну О'кей думаем мы это инструкция присваивания мы определяем два первых узла которые нам понадобятся это assignment statement инструкция присваивания и это числовой Литерал инструкция при звание переменно в себе содержит и ссылку на выражение ну в нашем случае это ссылка на числовой Литерал смотрим дальше знак умножения и опять же Литерал троечка Окей мы понимаем что значит не двойку надо в переменную поместить А это результат какой-то арифметической операции в данном случае бинарная операции потому что у нас есть два операнда мы создам третий Узел это бинарное выражение которое имеет ссылку на левый правы опе что с ними надо сделать всё довольно просто да мы перестроили немножечко наше дерево смотрим дальше плюс 4 Ну Казалось бы всё просто и о чём я говорю здесь приоритет операторов Да умножение должно выполниться первее и поскольку мы начинаем от первого узла считать мы опять вынуждены перестроить наше дерево Да мы какие-то стрелочки стёрли новый узел туда вставили и теперь оно уже для Первой нашей строчки вот имеет законченный вид если мы начнём считать от оператора присваивания B равно татата погружаемся глубже и получаем корректный результат смотрим дальше Мы видим что у нас есть слово показать за которым следуют круглые скобочки и внутри этого внутри круглых скобочек Да какое-то название переменной Ну мы с вами же такие умный парсер мы понимаем что окей Это скорее всего вызов функции мы создаём четвёртый в нашем примере вариант узла дерева инструкция вызова функции в которой есть название функции и ссылка на Expression и Казалось бы да Ну мы довольно легко сейчас вот прямо в уме построили это дерево при определённом навыке это будет щёлка просто вот на ура но э мы если подумаем мы поймём что мы на самом деле сделали довольно большую задачу В момент построения то есть мы читаем поток но дерево в зависимости от приоритета операторов и ещё чего-то мы вынуждены это были дерево постоянно перестраивать мы заглядывали вперёд по потоку токенов чтобы понять что показать это именно функция потому что там где-то дальше скобочки есть мы каким-то волшебным образом поняли что вызов функции показать - это уже следующая инструкция а не какая-то продолжение предыдущей инструкции то есть по факту да давайте представим что мы попробуем это всё закодировать когда мы какой-то новый оператор захотим добавить и прочее прочее То есть как же нам решить проблему утомительного написания кода превращения наших токенов в дерево и на самом деле сообщество Решало эту задачу уже неоднократно и как водятся в таких случаях появились специализированные инструменты и об одном из них я вам сейчас расскажу То есть у нас же мы же хотим всё попроще сделать это утилита Як ещё один компилятор компиляторов я - это генератор парсеров для для unix систем для языка си он на самом деле написан ещё в семидесятых годах Ну то есть довольно давно да как это работает вы описываете Як файл Ну обычно он расширение тока Y имеет в котором правила парсера описываются в специальной форме я вам пример этого файла покажу можно погуглить про форму КС и затем утилита Я на основе этого файла с помощью кода генерации на нашем языке программирования то есть нам не надо писать кучу условий руками мы просто я файл такой да как файл спецификации примерно будем править помимо утилиты я есть ещё и другие утилиты там Но почему я выбрал я по очень простой причине что в пакете X Tool уже есть кофа писаны на языке Go то есть мы пишем этот Як файл Да Разумеется мы не полностью убрали сложность написания парсера нам надо будет разобраться с форматом этого Як файла он довольно непростой и мы не будем его очень подробно здесь обсуждать Я всего лишь пару примеров покажу но тем не менее это гораздо проще чем поддерживать самописный парсеры Хотя этот подход Тоже имеет скажем место быть как и говорил Это пример яфа и Ну давайте обратим просто внимание на несколько строчек Да мы видим какие знакомые вещи на первой строке мы видим все варианты токенов которые наш парсер понимает да это идентификатор какой-то название там переменно Это какое-то число это знак равенства на девятой одиннадцатой строках мы видим блоки Да это с девятой строки блок стейтмент то есть инструкции описываются с одиннадцатой строки начинаю описываются выражения Ну и например на десятой строке можно Если приглядеться надеюсь хорошо видно Да можно увидеть такую знакомую конструкцию если идёт идентификатор затем знак равенства затем какое-то выражение то это у нас будет инструкция присваивания повторюсь что я не ну во-первых не имею возможности Да очень скажем так подробно описывать формат этой этих Як файлов во-вторых Я бы даже сказал и не настолько я в них компетентен чтобы вот выйти на всю аудиторию рассказать наверняка Я тоже многого не знаю но в своей демо Проекте в своём я точно также использовал Як файл для нашего языка и то есть парсер который у нас работает он сгенерирован с помощью этой утилиты и вы сможете если скачаете себе этот репозиторий его посмотреть и здесь я напомню вам о том что помните когда мы говорили про синтаксис языка у нас не было оператора деления Но поскольку у нас вот прямо предполагает у нас аудитория такая как в университете давайте это сделаем как домашнее задание кому будет с этим интересно поиграться То есть вам надо будет добавить в проект поддержку операции деления для этого что надо будет наверное надо будет какие-то токены новые создать Да потому что ну знак деления придумать для него там разделить на например для этого надо будет поправить этот Як файл И сгенерировать для него парсер и поправить наш демо скрипт в котором тоже будет деление и не забыть учесть поддержку операторов на самом деле поддержку приоритета арифметической операции то есть на самом деле звучит не очень сло Като подводные камни будут надеюсь вам это будет интересно что ещ про это хотелось бы сказать подход генерации парсеров из Яг файлов на самом деле используется довольно широко уже упомянутая мною библиотека гофер Да которая спецификацию реализует она как раз использует генерацию парсера из Як файла там такой огромнейший Як файл его можно там найти Да в их репозитории который генерирует для Да который promql исполняет запросы на самом деле тоже используют парсер сгенерированный с помощью Як файла для своего парсинга пром языка в свою очередь библиотека Гоя которая исполняет JavaScript они используют собственную написанную реализацию парсера то есть ну как бы подходов очень много Каждый выбирает то что ему удобнее в данном случае ну и последний шаг нашего процесса исполнение нашего дерева то есть мы создали токены из текста каким-то образом Да в нашем случае регулярными выражениями наш парсер сгенерированный утилита сформировал нам массив инструкций стейтмент эти наши инструкции здесь конечно же тоже может быть много подходов я показываю примеры кода из своего демо репозитория с которым вы сможете поиграть его как-то поменять и так далее То есть что мы видим Вот она функция в которую мы массив ментов и мы просто большим ty свим смотрим Что к нам прил statement То есть это функция показать наша Да мы вызываем такую-то функцию присваивание такую-то То есть как может Print statement выглядеть точно также Type Switch Какое выражение нам на вход попало Если это строковый Литерал мы его как есть выводим в std если это выражение мы его как-то вычисляем то есть повторюсь Да это кусочки кода из демо проекта с которым вы ознакомиться Ну тоже самое для инструкции присваивания мы берм Какое название переменной которое у нас есть и вычисляем выражение и туда это присваиваем и в итоге файл запуска нашего проекта выглядит довольно лаконично Да там те шаги которые мы с Вами проговариваем лексер Мы создаём парсер Мы парсим наш Исходный код и запускаем его раннем Да передаём дерево туда построенное перед тем как подвести итоги Я хотел бы Подсказать вам ещё один путь Где можно посмотреть примеры построения абстрактно синтаксического дерева потому что ну часто с этим могут быть Ну какие-то недопонимания до конца да как это правильно дерево может строить как это в живой природе выглядит Окей это у нас демо проект игрушечный А как в живой природе для настоящих программ строится абстрактное синтаксическое дерево и круто то что в стандартно уже есть инструменты для построения абстрактного синтаксического дерева программ написанных на го Ну кстати именно эти инструменты используют линтер для анализа вашего кода То есть как многие может быть может быть кто-то не догадывается то есть линтер не просто там регулярка по тексту ищет они строят по вашим скриптам именно абстрактно синтетическое дерево и затем уже запускают какие-то анализаторы по ним Итак давайте вот эту простую программку возм ЕС Обратите внимание Она полностью повторяет наш пример Ну вот этого нашего Да выдуманного языка когда мы парсера прикидывать то есть мы в переменную помещаем там 2х 3 + 4 Ну и функция показать аналог - это println И вот этот простой код здесь Он наверное всего лишь для иллюстрации что буквально в три строчки кода мы эту программу можем распарсить и получить полностью готовое абстрактно синтетическое дерево для нашей программы то есть мы вызываем функцию пасф из пакета и затем с помощью функции Print в std Out выведется дерево Давайте вам покажу примеры чтото может быть Разумеется Вывод я сократил потому что дерево оно строится Ну не только для внутренности функции Main на самом деле сама функция Main должна быть в дереве название пакетов импорты и прочее прочее это всё попадает в дерево поэтому вывод довольно существенно сокращён но это не мешает нам увидеть знакомые нам здесь конструкции Да мы видим инструкцию прис вы понимаете что то что мы видим это уже какие-то Гош структуры описаны конкретно в коде Да вот знакомы наш синтак звёздочка точка и так далее То есть это уже какие-то госструктуры Мы видим примеры нашего Бинар expr мы видим примеры вызова функции То есть это всё вот у вас такое большое Полотно вылезет и всё это можно наск эк что вот узлы дерева - это конкретны структуры которую можно потрогать и так далее Всё очень просто в стандартной поставке go в папке Go As .go Файлик там все все узлы нашего дерева находятся Ну возможно находятся каких-то соседних ещё файлах может быть и ошибаюсь Но по-моему там максимально всё находится перед тем как при перейти к резюме да на самом деле как обещал довольно быстро постарался сделать я хотел бы сказать такое да такой посыл конечно же мой рассказ о том как написать свой DSL получился довольно поверхностным Ну тяп-ляп мы лексер написали регулярки какой-то ГОК запустили Опа DSL получился Да ну Казалось бы несерьёзно тема то глубокая и да тема на самом деле глубокая Есть множество нюансов Как можно написать лексер эффективно и ещ какими-то путями ещ больше вариантов для написания больше сложностей то есть тема Очень широка но моя цель была показать что она не очень сложная То есть можно какими-то простыми усилиями Да написать свой простенький DSL и дальше в эту тему углубляться Ну либо за использовать готовые библиотеки они очень легко расширяются там гофер агоя добавить туда кастомную функцию Ну буквально там одна или две строчки кода Итак ремы поговорили Том позволять писать пользователям код он используется повсеместно он используется очень широко написание плагинов да для каких-то систем и прочее прочее какие-то скриптинг и так далее мы поговорили о том что у нас уже есть куча готовых хороших решений Когда мы можем прямо завтра в свой проект включить исполнение там скрипто лоа немножко их доработать какие-то кастомные функции нужно нам добавить но в принципе всё будет работать очень быстро JS Go и так далее сказал о том что есть замечательная утилита Go которая для тех ребят которые вот начинают Этой темой интересоваться она убирает огромный Пласт сложности написание парсеров это Это просто очень сложно катастрофически в это можно повязок тов просто отправится куда-то под ковёр и мы сказали о том что у нас уже есть встроенные го инструменты э Где мы можем попрактиковаться посмотреть как серьёзная Да разработчик го написали построение абстрактно синтаксического дерева то есть взять свою программку на го скормить её туда и посмотреть Какое же дерево из этого построилась Всем спасибо голосуйте за доклад если у кого-то ещё остались силы поднять телефон мне будет приятно и будет полезно Спасибо большое за доклад у меня в школе было задание написать язык программирования собственный Я вот сейчас думаю почему где был Где ты был тогда есть ли вопросы в зале Если у вас есть вопрос Пожалуйста поднимите руку к вам подойдут задавайте свой вопрос пожалуйста в микрофон секундочку Кстати хотел напомнить что здесь вот на слайде пока мы общаемся есть ссылочка на то демо репозиторий если кому-то интересно будет сфотографируйте и Поиграйте с ним Да слушаю Андрей Спасибо большое а я хочу разобраться в DSL Я недавно слушал подкаст про DSL и это какая-то Путаница давайте так когда DSL перестаёт быть Лем ведь можно так сказать что это DSL для Си Ну то есть когда-то мы же написали Go используя базируясь Си Ну и так далее и тому подобное и тут были примеры с аргументами для вызова неких а куда мы тоже могли ставить что-то как будто бы свой синтаксис назвали это DSL и в общем какая-то Путаница для меня тут как будто бы две разные штуки проектирования языка и какае-то бизнес решение Да domic спасибо да спасибо смотрите DSL Как расшифровывается domain specific Language То есть это язык специфичный для какой-то прикладной области отсюда вытекает во-первых то что этот язык не обязательно тюринг полный мы не можем любую программу на нём написать как я уже упоминал например софт для лазерного станка там может быть буквально две ко три команды переместить каретку Включить выключить лазер если мы сравниваем DS с языками общего назначения они все конечно же тюринг полные мы можем да какие-то сложные программы на них писать и так далее Я конечно же здесь своё мнение высказываю кто-то с ним может не согласиться кто-то может его дополнить но в моём понимании что DSL - это прикладная вещь какой-то области и она может быть действительно очень Широкая тюринг полная на нём там можно писать там что угодно а может быть очень маленькая но изначально эта вещь была создана для того чтобы в какой-то своей нише работать помогать прочее Спасибо большое за вопрос Следующий вопрос Из зала А вы не рассматривали возможность введения нескольких слоёв DSL грубо говоря для разработчиков для администраторов может быть DSL тюринг пон А над ним ещё один слой который даёт пользователю там вызов уже существенно ограниченной части таким путём шли нам кажется наиболее перспектив Я не спорю нет безусловно он хорош но я думаю что понимаем здесь зат от задачи да Для чего нам создавать DSL Ну я приведу пример Я читал доклад на adops Con в прошлом или позапрошлом году у себя мы используем Вот это исполнение пользовательских сценариев в проекте барте где мы правила алер описываем скриптами потому что ну ну мы не можем декларативное что вот если наступило то событие то событие Нам надо в одну базу вторую третью сходить куда-то по сети сходить и потом понять был алерта или нет Но в нашем случае у нас эти алерты пишут наши же инженеры поэтому у нас нет необходимости как-то их строго ограничить ограничивать но я вполне себе допускаю такие случаи где это можно сделать и на самом деле это ну не выглядит очень сложным да то есть это вполне себе можно реализовать Ну да да очень важно говорить в микрофон Потому что если вы говорите в записи не слышно будет не слышно и получа мы разговариваем сами с собой нет мы любим поговорить очевидно по ели кто будет видео смотреть он подумает что я Да ладно никто ничего не подумает все и так всё знают Поня Есть ли ещё вопросы в зале Ну я думаю что все уже устали просто хотят чтобы скорее всех отпустили первый день как обычно самый насыщенный поэтому Ну не надо не надо себя принижать мне понравился доклад это было круто к слову я в своей компании пользуюсь ровно тем подходом которые описали во втором а вопросе у нас действительно два разных ля по сути для человека который может делать всё и юзера которому мы предпочитаем давать строго ограниченную порцию команд юзера сколько не Да им всё мало юзера они такие не у нас слава Богу два это проще Не пять не 10 но тем не менее это определённый подход и им можно пользоваться Спасибо большое за доклад давайте выберем ва вопрос который вам понравился Это сложный выбор про про уровни да Это хороший вопрос это есть на чем подумать про уровни изоляции D сле отлично Спасибо большое Не уходите пожалуйста мы вручим вам подарок от нашего партнёра по подаркам газпромнефти вас я хочу поблагодарить за доклад это было круто спасибо большое это заключительный доклад Спасибо э вам мы тоже хотим вручить подарок подарок от конференции не убегайте пожалуйста вас сейчас найдёт наш ХЛ и вручат его А ну а я с вами прощаюсь До завтрашнего дня не забывайте что в 7:00 вечера в конгресс холле будет премия лоу Это должно быть интересно Приходите посмотреть Всем пока"
}