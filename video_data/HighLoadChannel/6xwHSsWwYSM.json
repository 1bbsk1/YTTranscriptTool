{
  "video_id": "6xwHSsWwYSM",
  "channel": "HighLoadChannel",
  "title": "Как протестировать код на Go с базой данных? / Василий Василюк (Тинькофф)",
  "views": 177,
  "duration": 2335,
  "published": "2024-10-29T02:48:12-07:00",
  "text": "я приглашаю на сцену Василия рассказать про то как тестировать с базами данных Я вчера много вопросов про тестирование задавала я Я уже готовлюсь уже готовлюсь к новым Всем привет Как вы уже поняли меня зовут Василий коротко о себе в коммерческой разработке Наго я более 5 лет сейчас я работаю НКО в команде образовательной платформы в роли старшего разработчика интеграционные тесты пишу около 3 лет практикую ddd в Go иногда что-то выкладываю в Open Source пример кода к текущему докладу тоже будет на гитхабе ссылка будет в конце презентации А сегодня я расскажу об опыте внедрения интеграционных тестов связки с посо Какие нужно сделать шаги Какие кубики нам понадобятся для этого и под свечу довольно-таки удобный способ очистки базы данных путём её копирования и удаление а начнём Мы в первую очередь с болей в Go К сожалению или к счастью очень популярны тесты на мока и в принципе это хороший инструмент Когда в подходящей ситуации но когда в проекте тесты пишутся только на мока и проект поживёт долго там полгода год полтора и дольше в нём накапливается довольно-таки большое количество тестов Наках которые начинают сковывать кодовую базу и это очень сильно мешает развитию потому что мы приходим делать фичу или Фактори код вносим какое-нибудь изменение в одну строчку и потом идём вносить одно 5 10 изменений в настройке а просто генерирует дополнительную работу и вторая проблема бывает Мы у наследуем проекты от коллег с которыми может быть даже не знакомы и в них часто тестов нет и такие проекты тяжело поддерживать потому что сложно понять как они работают сложно отфрид и сложно внедрить тесты Наках так как петля обратной связи она довольно-таки длинная у нас тестов совсем нетс чтобы м нужно дополнительны абстракции ввести после того как мы факто вели дополнительны абстракции нам нужно отдать в тестирование выкатить на прод подождать что всё работает проверить убедиться только потом начинать уже добавлять тесты на мох и чтоб хотелось или как может быть мы узнаём что код Не сломан секунд 15 Луч быстрее вот минимально меняем случае вообще ничего не меняем в тестах и можем Ну достаточно небольшими усилиями внедрить в проект в котором вообще нет тестов этого бы Вот хотелось и с этим в принципе могут помочь и интеграционные тесты с базой данных и Давайте поговорим а что же нужно чтобы запустить интеграционное тестирования в первую очередь нам нужна база данных нужна нам на машине разработчика для того чтобы не зависеть ни от каких общих стендов не зависеть от Пина интернета и чтобы когда наши разработчики тесты запускали они не мешали друг другу и не ломались изза параллельных прогонов И как же нам поставить её на машину разработчика например из пакетного менеджера из того которым вы пользуетесь Единственное что в командной работе это не очень удобно потому что мы не управляем версией поса кото мы ставим из пакетов разработчик поставил такая там и стоит и нам очень сложно конфигурировать такой постгрес поставленный из пакетов мы должны либо какие-то скрипты общие писать а под разные машины там разные окружения либо заставлять разработчиков вручную что-то настраивать и далеко не все а будут этим заниматься или разбираться это тяжело на внедрении второй вариант - это докер здесь мы уже довольно-таки хорошо управляем окружением нам нужен только сам докер на машине разработчик остальное мы можем определить нужную версию поставить через нужные понро ко откуда-то мы можем и также если мы завер например такую команду в скрипт или в мы можем заметить гиты пошарить на всю нашу команду и она спокойно будет запускать нужное окружение ещё один вариант - это тест Конте проек который на многих языках нероново контейнеры Докера в принципе довольно-таки удобно там можно гибко что-то настраивать конфигурировать слож инфраструктуру но проблема в том что весь код нам нужно написать и поддерживать и ещё одна проблема в том что мы делаем Это из кода То бишь по сути мы запускаем контейнеры из тестов и весь охд на запуск Мы прита в тест в случае с пом стандартный контейнер инициализируется порядка 10 секунд и кажды тест запускаем отдельный контейнер то в каждый тест прилетает Over на 10 секунд это довольно-таки долго ещ один вариант - это do здесь уже сам инструмент за нас написали и поддерживают и есть декларативная в котором мы прописываем необходимые настройки окружения ту же версию по переменное окружение также можем добавить на что база данных пози туда же мы можем добавить миграции это позволит нам Ну во-первых подписаться на Health Check и накатывать миграции на полностью инициализирована базу данных а во-вторых мы а так как используем внешний инструмент всё весь запуск происходит вне тестов весь оверхед на запуск у нас из тестового прогона убирается он остаётся во вне и уже в рамках тестового прогона мы не тратим на это время О'кей мы запустили базу данных например на docker композе и нам нужно откуда-то взять параметры подключения к ней здесь я предлагаю использовать переменное окружение это довольно-таки удобный способ единственное мы их чуть доработан значения по умолчанию например такие же как в docker compose это позволит нам очень удобно запускать тесты Как из commandline Ну из сия из Make файла из эшки в любом месте мы запускаем тесты и они работают со стандартными ресами нам не нужно дополнительно подставлять перемен на окружение и с этим ворочиться Ну и не только нам и всем членам нашей команды и ещё если будете внедрять стоит функцию подключения сразу в каком-то одном месте описать в рамках там вашего репозитория Чтобы в дальнейшем не выковыривать дроп из всего из всего кода тестов вот если мы на копируем функцию подключения рано или поздно какие-то параметры нам придётся менять и здесь это будет дополнительная работа вы корите всех тестов Окей что дальше в принципе на этом моменте у нас уже есть база данных которая довольно-таки удобно запускается локально у нас Мы можем к ней подключиться Ну как драйвером пользоваться Мы скорее всего знаем полу из переменных окружения в принципе можем написать простой тето даже Один раз второй раз он скорее всего не пройдет если мы используем тест контейнер он может пройти так как мы поднимаем контейнер под каждый тест и он очищается потом А вот если мы будем использовать do comp то в базе данных будет оставаться мусор и повторные прогоны тестов не будут проходить То бишь в обычном Юнит тесте мы заполняли не базу А память создавали объекты тестировали их поведение Проверяли его и в принципе тест завершался из памяти всё выгружались ничего чистить не надо тесты проходят много Сколько бы мы их не запускали а в базе данных мы уже при тестировании с базы данных мы заполняем уже базу данных выполняем требуемое действия в связке с базой данных и проверяем его поведение и потом мусор в базе данных за нас никто не почистит его надо чистить самим придумывать какие-то рч коллекторы свои и первый вариант - это очистка после теста То бишь перед нашими тестами мы записываем функцию с какими-то запросами Дели Тами нкей Тами может быть целый сль скрипт а пишем регистрируем в обработчике T cin Up эта функция будет вызвана после прохода теста и также наш тест заполняет баз данных выполняет требуемое действия проверяет поведение его и вызывается это клинап и мусор очищается здесь есть проблема с тем что тест может завершиться фатально мы можем их льну или ещё по какой-то причине может умереть и такле нам не будет вызван мусор останется в базе данных и его никто оттуда не удалит повторный прогон теста такого будет постоянно фейли он сам по себе мусор не вычистить инженеры люди умные они придумали очистку перед тестом зачем удалять мусор потом если можем его вычистить перед собой в данном случае мы туже функцию с клипами с ракетами вызываем перед м и дальше На каком бы шаге наш тест не упал мы мусор ВС равно вычислим перед следующим прого Вот это уже лучше но есть нюансы и в первом методе очистки после тестов и перед тестом есть проблема в том что нам нужно думать что удалять и нужно думать не только нам а всем членам команды которые будут потом эти тесты писать и Давайте посмотрим е альтернативы кото мы можем использовать с ри чистка в данном случае Мы открываем транзакционные подключение к базе данных а перед тестом и в тест уже отдаём транзакционный конек база данных заполняется в рамках транзакции требуемое действие прогоняет в рамках транзакции проверяется поведение и потом транзакция откатывается откатывается она вместе со всем мусором поэтому мы не думаем какой мусор нужно откуда чистить Вот это гораздо удобнее но есть проблема что такая чистка она сложнее во внедрении потому что нам нужно во всех там репозитория и прочих абстракция делать интерфейсы потому что там например sldb Тип и sqlx тип они разные и если у нас напрямую эти типы используются в репозитории нам придётся вводить интерфейсы а также мы не можем тестировать комит если у нас в продакшн коде есть комит Нам нужно его обернуть какой-то Да я не о заработала вроде бы нам нужно обернуть комит какой-то обточка чтобы он не происходил в продакшн коде происходил только в тестах и естественно Вот Но зато такой подход довольно-таки быстро работает на практике и удобен ещё одна альтева про кото СПО это коро данных понадобится instance по с двумя базами данных одна пустая и одна с миграция вот мы подключаемся к пустой базе данных копируем базу данных с миграция А ну какой базу данных с произвольным именем потом подключаемся к этой базе данных и отдаём такое подключение уже в тесты Это позволяет нам полностью изолировать тесты друг от друга не перескочил тест наш проходит в рамках этого изолированного подключения и в конце мы базы данных удаляем Вот и потом уже не думаем какой мусор там накопился тест у нас полностью изолированы они друг другу не мешают а единственное мы платим за это временем там порядка Ну 100 миллисекунд и больше в зависимости от вашей конфигурации может быть overhead на копирование базы данных Вот Но это довольно-таки удобно и чуть-чуть подытожим очистка перед тестом и после теста о них полезно знать на каком-то стеке может быть они вам пригодятся Вот они довольно-таки быстрые но хрупкие из-за слабой изоляции и неудобные в том потому что нам нужно думать что удалять транзакционная очистка Она быстрая простая в использовании но сложная во внедрении и мы не можем тестировать комит и очистка копирование базы она удоб Дат полную изоляцию тестов но медленно ВС ещ быстрее тест контейнер но ВС равно создаёт некоторый охд Окей в принципе мы запустили базу данных локально пишем тесты база данных чистится мы можем захотеть распараллелить Наши тесты например для ускорения чтобы они работали побыстрее в Гош с этим ВС просто мы расставляем в основном тесте в дочерних тестах и тесты запускаются конкурентно параллельно и также сам стандартный Гош ф компилирует наши пакеты отдельно и параллельно запускает пакеты тем самым параллельно запускает тесты это стандартное поведение с лом не совсем связано но здесь всплывают всякие нюансы нашего кода если до этого мы какие-то части кода не тестировали они у нас инициализирован раз при запуске при внедрении интеграционных тестов особенно наиболее сквозных через мы можем обнаружить связаные скими глобальными переменными какими-то объектами которые мы не замечали раньше и ещ с параллельным запуском тестов не дружат некоторые способы очистки например транзакционная очистка и копирование базы данных Они полностью совместимы с параллельным запуском тестов А вот очистка перед тестом и после теста они с параллельным запуском несовместимы они начинают друг друга удалять данные или не успевает очистить данные и естно потом изза неправильного состояния базы данных вот так что по умолчанию они несовместимы есть специфические кейсы Когда у нас данные делится по Тен тамм или по каким-то кнм там пользователей и так далее То бишь они изолированы в рамках какого-то шника в таком случае их можно разделить и использовать очистку после теста и перед тестом но в общем случае с параллельным запуском такие подходы несовместимы е Мы скорее всего захотим разделить интеграционные тете чтобы ка чисте функции которые мы Тестируем тестовые прогоны для них делать побыстрее а интеграционные запускать попозже и один из вариантов организации такого Это переменное окружение в данном случае интег если такая переменная установлена мы её в тесте проверяем обрабатываем если она есть мы прогоняем все тесты если переменно такой нет мы все интеграционные СТ с тоте второй вариант это теги они также в comm onl прописываются в самой горшке чуть повеселее нам нужно вынести отдельный Файлик с интеграционными тестами проставить там теги и если этот флаг есть то эти файлы скомпилированный набор если тега нет то прогони только тест здесь могут быть нюансы со всякими линтер с подсветкой синтаксиса ВД Ешки это такое дополнительная неожиданность потому что чтобы линтер заходили в эти файлы им надо в конфигах обычно прописывать Какие ЛТЕ нужно проверять Вот это такие могут быть дополнительные недост для вас и ещё один вариант - Это стандартный флаг шорт который уже вшит в Гош мы его также указываем в commandline и в тесте проверяем если указан флаг шорт то скипа все интеграционные тесты если флаг не указан мы прогоняем все тесты и юниты интеграционные окей У нас есть тесты локально они проходят база чистится в принципе довольно-таки может удобно мы оформили скрипты команды или файл какой-то остался ещё один последний шажок - это автоматизировать на C если мы на C не будем гонять тесты то скорее всего они довольно-таки быстро станут сломанными кто-то забудет их запустить кто-то намеренно их не починит потому что добо афи горит и различные ситуации могут быть целом поэтому сразу лучше оптимизировать на C довольно-таки популярный стек здесь довольно-таки просто всё подключаем do объявляем до переменную чтобы стандарт имен окружение хост для нашего погоста в данном случае здесь используется чистка копирования баз данных и docker comp соответственно поэтому мы через переменно окружение лям docker Host запускаем наше окружение прогоняем тесты очищаем окружение очистка окружения По большей части тоже нужна чтобы саму команду перепроверить в C именно заботиться очисткой окружения после прогона полного прогона тестов большого смысла нет и вариант actions Здесь всё немного попроще даже попроще мы подключаем Гош запускаем тестовое окружение прогоняем тесты и очищаем наше тестовое окружение опять же для проверки команды вот там доке докер настроен на локал Хосте так жес данных поднимается на лока Хосте и проблем с этим ускорить Наши тесты в какой-то момент когда там будет сотня другая кейсов мы уже будем замечать что они начинают проходить медленно Ну не в C а локально когда мы их используем для рефакторинга и быстрой проверки что код работает и как же нам это сделать давайте рассмотрим варианты Первый из них - это MFS мы можем смонтировать прогрессо каталог с данными в tfs это по сути в оперативную память Что позволит нам ускориться на то ускорится будет немного позднее поэтому ваш вопрос не останется без ответа второй вариант - это отключить принудительно проверку что данные записались постс по умолчанию через проверяет что все данные которые он написал на диск они действительно записались для контроля целостности и это поведение для тестов мы вполне можем выключить потому что нам целостность данных не особо важна мы их каждый раз генерируем тестами но зато мы можем выиграть производительность если такое поведение отключим ещё есть config Здесь также отключается увеличивается в оперативная память для него это чтобы он реже сбрасывал на диск отключаются синхронные коммиты То бишь по сути приложение делает кот данные записываются но пос ещё транзакцию на диск не скидывает а сделает это позже Это тоже для тестов нам некритично перепись оперативной памяти по умолчанию пос страница из памяти оперативной на диск перезаписывать полностью Чтобы на диске не оставались битые страницы в которых полстраницы старых данных полстраницы новых Ну и клиентские варнин которые клиентские сообщения которые прилетают на клиенты поднимаем для рнв Наверное это какую-то роль в производительности играет и что же по цифрам есть пример кода на гитхабе там к сожалению всего де тестов и чтобы цифры более-менее показательные были прогонял я эти тесты с кантом 100 здесь тесты написаны с очисткой копированием базы данных они на доке композе сама база данных запускается Вот и см 100 запустили и в стоке получили что 57 секунд занимает прогон тестов Ну по сути 900 тестов у нас проходит за минуту если мы добавляем tfs мы экономим 24% по времени если чисто fsn отключаем то 31 с конфигом от tpg мы выигрываем 40% по времени если возьмём Temp FS плюс fsn то выиграем 42% времени если смешаем совсем всё в кучу то можем выиграть до 50% времени То бишь с 57 до 28 секунд У нас снизится время прохода прогона а правда эти цифры ничего не не говорят Вам потому что в вашем проекте А с вашим набором тестов вашими Ну способами очистки которые выбрали для себя цифры могут быть совсем другими поэтому эти способы можно просто знать и в нужный момент попробовать у себя и посмотреть какой действительно способ даст вам эффект это вот там делается за 5-10 минут и в принципе можно коммитить и продолжать использовать интеграционные тесты вот и немного повторимся А зачем же мы всё это делали внедряли и так далее В первую очередь это нужно чтобы Фактори код было легче интеграционные тесты гораздо меньше сковывают код его легче Фактори легче чистить от мусора А с чем лучше наш код чем приятнее с ним работать чем быстрее мым на так сказать благополучные а второй момент тесты интеграционные они более надёжные они затрагивают больше абстракций Да это иногда может делать их хрупкими но зато мы получаем когда прогоняем тесты мы более уверены что наш продукт Не сломан Вот и нам легче опять же Фактори и развивать нашу кодовую базу и поддерживать фичи потому что мы знаем что мы ничего не сломали и третий момент мы можем переиспользовать эти тесты при рефакторинг базы данных мы по Фактори таблицы изменили типы что-то проверили и мы можем тестовым набором тем же который у нас накопился для основного кода протестировать изменения в базе данных что мы не сломали наш продукт Вот и ещё пункт который Здесь не указан если например у нас есть сервис в котором тестов не было вообще мы можем взять тест база данных сделать их максимально интеграционными через AP а замокать лишние зависимости Ну прин процес тестировани моми и гораздо быстрее получить тесты которые показывают что продукт не сломался это легче во внедрении Итого для запуска базы данных можно пользоваться докер компом Или тест контейнер с оглядкой на специфику вашего проекта для подключения для получения данных подключения к базе Я бы рекомен рекомендовал использовать переменное окружение и значение по умолчанию это очень удобно и если вы на стке с pog довольно-таки удобно стартовать с очистки копирования базы данных и удалением её и если адаптировать под другие стеки то в принципе делитесь опытом ещ слайди с литературой здесь интересные книги - это принцип Юнит тестирования хорикова там в принципе много подчеркнуть а протесты телефоны можно подготовить чуть позже будет следующий слайд со ссылками на слайды и пример кода как раз а X Unit patterns - это тоже интересная книга в ней как раз есть все способы очистки кроме наверно очистки баз данных и самое интересное там там есть примеры к сожалению на Джаве но читаемые и там есть все минусы которые собрали ребята которые писали книгу Из своего опыта это тоже интересно подчеркнуть для себя и grt там тоже можно подчеркнуть интересные для себя информацию про тестирования в том числе про очистку там делением на тенты и такие всякие интересные способы и в конце как раз слайд со ссылками которые можете себе сохранить лучше сфотографировать QR код Это для голосования А вот ссылочки первоя по нем можно будет найти слайды как раз список литературы и прочее а вторая ссылка тоже интересная предлагаю её сохранить она ведёт Как раз на пример кода к текущему докладу который вы сможете скачать у себя погонять там нужен только докер до и Гошка Вот это позволит м Если вы е не тее интен поть какой-то прое не внедряя в свой или если уже тестирует может быть у вас какие-то предложения или вопросы возникнут или какие-то идеи для себя подчеркнёт а Пока Спасибо за внимание Спасибо большое за доклад Есть ли вопросы в зале Давайте подойдём к моло человеку да Да всё правильно Давай микрофон а добрый день спасибо за доклад Меня зовут Тимофей А у меня есть три вопроса вопрос первый а когда ты рассказывал о разных способах очистки и их совместимостью с параллельным запуском тестов Подскажи пожалуйста как способ очистки копированием базы совмещается с параллельным запуском тестов ведь посередине выполнения второго теста база может очиститься а каждый тест получает свою отдельную копию То бишь мы миграция изначально готовим пустую базу данных в которой есть чисто миграции структуры и данные получаемые из миграции а потом мы в тестах Под каждый тест её копируем саму её мы не меняем не трогаем чисто копируем и уже отдельные копии в каждом тесте используются за счёт этого они полностью друг от друга изолированы никак друг другу не мешают и как тест понимает в какую базу подключаться А мы изначально перед тестом подключаемся к пустой базе данных генерируем какое-то рандомное имя а новой базы данных копируем туда баз данных создаём сразу в неё подключение с нужным именем и в тест отдаём уже подключение к той базе данных в которой мы скопировали вот это просто перед тестом происходит там какой-то общей обёрточную вопросов потому что рук много вас много если это дискуссия е лучше перенести в дискуссионную зону поднимите пожалуйста руки у кого есть вопрос Отлично молодой чело слева Добрый день Василий Спасибо за доклад очень было интересно у меня вопрос интеграционные тесты Вы у себя в тинькове пишете А на каком на каком уровне слоя репозитории или вы сервис рассматриваете как коробку и тестируйте интеграционными тестами весь сервис проходя все слои приложения тут я наверное отвечу не касательно Тиньков А всего опыта разные в зависимости от того если мы унаследовали проект то легче начать с интеграционного насквозь То бишь мы через А через все слои доходим до базы возвращаемся назад и потом уже проверяем изменение там в базе данных через тоже AP или прямыми SQL запросами если у нас приложение более-менее расслоилось если мы прямо хотим только убедиться что мы считываем то же самое что записали в основном Когда у нас именно приложение расло лучше тестировать именно команды сервисы насквозь и проверять их поведение А спасибо Ну вот как Спасибо Подойдите пожалуйста на на на первый ряд дать вопрос Извини пожалуйста что я тебя прервала в принципах Юни тестирования в принципе хорикова там много есть именно про то как тестировать какие слои там можно это подчеркнуть для себя более детально Спасибо за доклад Василий действительно интересно я думаю поэтому вопросов столько у меня вопрос касательно запуска самого приложения инстанса приложения для прогона тестов я поясню хотелось бы чтобы запуск тестов в сие и собственно приложение для тестов си и запуск локально был схож и можно было локально запускать не только все тесты скопом но и отдельно каждый в идеале если ещё и с де багом вот есть какие-то особенности для такого запуска это два вопроса в одном как-то сложно их разделить Я предлагаю в дискуссионной зоне обсудить подетальная тема для дискуссионной зоны из задних Да да здравствуйте Спасибо большое за доклад интересно вот а расскажите пожалуйста подробнее про вот моменты с копирования базы данных если мы в у нас 10 тестов для каждого из них своя копия база данных А как же у нас сервис будет работать с уметь работать с де копиями баз данных одновременно чтобы получить из них данные Или ваши сервис они не работа с этой базой данных вот здесь стоит добавить что мы рассматриваем тест То бишь тесты которые Копится с основным кодом и прогоняю основным кодом мы не компи Бинар нашего приложения мы компи именно тесты и получается что наш тест берёт какой-то Объект который инициализирует полностью сервис подготавливает его нужный коннекшн ему добавляет и в принципе у него получается инстан сервиса как объект для конкретного теста Спасибо ещё вопросы Спасибо Спасибо большое за доклад А у меня вопрос такой вы в начале доклада упомянули тест контейнер и в качестве минусов упомянули насколько я помню то что Достаточно долго запускается догер с базой и то что нужно отдельно поддерживать этот код вот всё-таки Хотелось бы более чётко понимать то есть вот этот вот 10 секунд на подъём - это реально подъём контейнера или это ещё какие-то инициализацией внутри которые поднимаются потому что ну вот из моего опыта действительно есть проблемы с подъёмом тест тест контейнер с Докера если это виртуальная машина какая-то например там в Маке это Lima или докер десктоп вот а нативные как бы я не видел таких задержек Ох тут я прям не отделял то бишь Я смотрел Что погрей контейнер довольно-таки долго стартует Но это на стеке наверное сколи мой Вот потому что в постовом контейнере есть ещё его внутренние инициализации подготовка данных прогон его внутренних миграций которые там монтируются в каталог и всякие такие вещи это не быстро происходит сам инструмент довольно-таки быстро проблема именно в контейнере который вы используете и там есть нюанс что мы не можем использовать всякие ю и прочие опции которые всё это сильно ускоряют потому что мы теряем в параллельности тестов мы Наши тесты когда запускаются параллельно есть опция reuse Test containers всё тоже начинает ломаться вот прямо глубоко глубоко Я не раскапывать всё это в тест контейнер потому что из моего опыта привычнее доке compose который в стороне работает и устраивает Отлично спасибо справа есть вопрос Большое спасибо за доклад ты говорил что при копировании баз данных вы делаете Это порядка 100 миллисекунд достаточно быстро вопрос как конкретно вы копируете в постгрес точно не знаю с какой версии появился SY cre Table template Date То бишь мы указываем данных которы является шаблоном она полностью копируется и получается копия это довольно-таки удобно потом мы можем дропнуть эту базу данных форсо все коннекшн отключить от неё прямо в Клина это всё есть в примере кода Отлично спасибо Есть ли ещё вопросы да сейчас буду долго добираться прямо к центру зала Здравствуйте спасибо за доклад подскажите а как вы обеспечиваете консистентность ddl таблицы которую Вот вы из которой потом создаёте тестовую базу данных Меня интересует не локально А у нас в репозитории сервиса лежит лежат все миграции вот мы их накатывало кальном запущен на локальную базу данных и точно так же это происходит и в C мы запускаем docker comp который прогоняет те же миграции в принципе получается одинаковый результат проблем Не находили вы не держите какой-то контейнер с базой для тестов Да а каждый раз поднимаете новый Да мы храним просто скильные миграции не используется готов готовый контейнер с данными и так далее Спасибо Спасибо ещё один вопрос по цен да давайте сразу же передадим микрофон Здравствуйте случается ли у вас что при быстрой при очистке быстрой миграции остаются данные в в базе э решали ли эту проблему спасибо Я не совсем понял вопрос Что значит быстрая иммиграция которая очистка перед тестом который проходит там на практике много проблем встречали это можно тоже в дискуссионные с спасибо супер спасибо Есть ли ещё вопросы я проверила чат зала в нём нету вопросов не забывайте что можно отсканировать QR код и задавать него вопросы Прямо во время доклада даже не только в конце а если больше вопросов нет Большое спасибо не забывайте что любые темы можно будет дальше обсудить В дискуссионной зоне подробнее провести диалог с докладчиком давайте выберем вопрос насколько я знаю у вас есть подарок от Тинькова давайте выберем вопрос Кому мы подарим подарок я забыл все вопросы пока на них отвечал это проблема как-нибудь помочь может быть да хорошо у нас было много вопросов было два вопроса которые вы отправили в дискуссионную зону один про то как работать с тестами так чтобы их можно было запускать и локально по одному и при этом все вместе и так чтобы это было вообще идентично сию ещё был вопрос про проблемы которую встреча с очисткой до после тестов это два вопроса которые вы отправили в дискуссионную зону А был вопрос про то держите ли вы цельные контейнер со всеми данными или накатывать миграции А так был вопрос с этой стороны у меня тоже заканчивается память Мне кажется у меня очищается по ходу дела с тек тамм А да про архитектуру был вопрос а с право стороны тоже были вопросы это очень сложно кусор дадим сюда подав про архитектуру Хорошо давайте вручим подарок у нас есть ещё один подарок от наших партнёров от газпромнефти кому подарим этот подарок все вопросы выгрузили это сложно это раннее утро Я отлично понимаю а давайте отдадим молодо человеку с про контейнер баз данных держим ли мы целый или это хороший выбор хороший выбор Спасибо большое а вас Мы тоже Хотим поблагодарить и в роче вам тоже подарок от конференции большое спасибо что пришли можно всё дальнейшее обсудить"
}