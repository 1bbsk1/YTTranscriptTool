{
  "video_id": "Sydi9L5m940",
  "channel": "HighLoadChannel",
  "title": "Повышаем производительность файлового I/O для JVM на Linux / Дмитрий Бундин (Grid Dynamics)",
  "views": 1187,
  "duration": 3311,
  "published": "2021-10-04T02:47:02-07:00",
  "text": "так всем привет у меня зовут дима я занимаюсь разработкой приложений и поджимаем на скалы java и также помимо этого я программирую носи под linux x86 ассемблере вот в этом докладе я буду рассказывать про один из проектов которым я принимал участие некоторое время назад это был проект сфере рекламы то есть у нас был ну классическая схема была что deep сервер который принимал запроса пользователя и некоторые сырые данные которые получают в результате этих запросов он их скидывал на внешнее хранилище то есть облака танки то различные gdfs и он прям и так далее вот к этим данным потом накаталась аналитик вот причем отправка данных http server on а вот эти хранилища было реализовано с помощью локального диска то есть данная напрямую никуда не попадали они скидывались на локальный диск и потом спустя некоторое время там это как правило было 10 15 минут они забирались в один baci вот этот матч целиком уже заливался на внешних хранилищ в общем то это все вполне себе неплохо работала только ощущение того что у нас было довольно большой зоопарка из серверов на которых вот эти все проекты были запущены инстанции стоил это довольно больших денег поэтому мы должны как бы лари были решите первое на что мы обратили внимание то что все наши инстанции они так исторически сложились были перманентные вот а перманентно они на порядок дороже прием типов вот например для 3 мин стремных облачных провайдеров это там три доллара и 0,3 доллара за часовое и соответственно очевидное решение это просто взять и выкинуть все permanent и и заменить их на принципу мы это благополучно проделали и почти сразу натолкнулись на проблему которая связана с тем что мы просто ну в общем мы потеряли данные а данный вытирали вот почему потому что когда мы спускаемся на прием тейбл инстансе облачный провайдер может нас от instance по каким-то различным причинам отжать то есть кому понадобились ресурсы он посылает всем уведомляет все процессы которые этой местности запущен на том что сейчас мы его выключим там в течение 30 секунд посылает на ленуська бралась актер и вот это сектор надо обработать случаешь тебе сервера никаких проблем тут нет просто погасили все патроны и выключились а в случае системы доставки проблемы есть и довольно значительны вот что накапливалась довольно большое количество данных и могло накопиться не 100 килобайт могло до 1 терабайта и вот эти данные вот таро байт по сети передать еще загребать по дороге не удавалось и вот тут мы как раз таки данные потеряли соответственно мы задумались о том что нам нужно реализовать какую-то систему которая во первых уменьшить вероятность потери вот этих самых данных во вторых и сделать это максимально эффективным образом потому что аж типе сервер на котором были запущены вот эти самые доставки а он был написан на плюсах было снизила вес на сделал очень много хардкорные бизнес-логике и потреблял все очень много циpкa и памяти отжимать у него эту память был было крайне желательно вот отсюда как бы выросла вторая нога вот это вот проблема которое перед проекта стояла кого ну и начнем разбирать и т.д. провалим по порядку начнем самым и такое основное это как уменьшить вероятность потери ну понятно что если почел и доставка не работает давайте попробуем данные стримить как только что появилась мы сразу будем там в какой-то буфер их собирать например по 8 мегабайт и сливать непосредственно в сети 100 роджер вот такой способ он имеет несколько недостатков спешила первых нужно будет дорабатывать аж и сервер сам поскольку он был написан плюсах этого делать не очень хотелось вообще он был довольно тяжеловесные сложный поэтому мы обратились другому способу это streaming непосредственно новых данных с локальных диск то есть данные изначально падают на локальный диск система уже была реализована мы ее не трогай боба чего доставку мы просто выкидываем и реализовываем непосредственно с нуля вот ну как бы вот такого способа есть очевидное преимущество что нам не нужно мы захотели давать какой-то хранилище нам не нужно переписывать http-сервер мы просто он как скидывает данные на диске так и скидывал вот мы просто докрутим систему доставки и это очень удобно поэтому на таком способе мы все-таки остановились вот streaming через локальные диски теперь самый интересный наверное момент это оптимизация непосредственно все вот этой системы доставки вот мы будем говорить начнем с самого верхнего уровня вот непосредственно с оптимизацией java кода и закончим уровне микро архитектуры x86 и посмотрим немного что-то в ядре linux есть которая какие то момент который на могут быть полезны вот в нашем случае от steam и доставки нужно было три основных функций по факту непрерывный мониторинг локального диска на наличие новых данных после того как мы данные получили мы должны эти данные как-то обработать зашифровать и сжать чтобы отправить их потом сидит после того как мы накатили вот эту обработку у нас происходит непосредственно отправка мы сосредоточимся на рассмотрение вот от этого куска это чтение мониторинг локального диска и его можно получить разбить на три части это определение какие файлы поменялись после того как мы определили файл поменялись мы должны определить где мы сколько мы байт уже из этого изменившегося файл успели отправить на предыдущих то циях и после того как мы это определили мы должны эти новые байты прочитать и потом уже шифровать и скинуть их в сеть начнем с первого это определение смешать файлов вот и тут есть тоже несколько вариантов несколько способов 1 сам простой просто у нас есть файлы и директории мы их непрерывно обходим каждый из этих файлик в каждой из директории смотрим поменялись оттуда там добавить какие-то данные что с ним произошло если что-то произошло то мы просто отмечаем этот файл как изменившейся и его обрабатывать вот у него есть этого способа несмотря на его простоту и удобство в реализацию не есть недостаток то есть мы полем фиксированным интервалом потому что если мы будем как-то интервал подстраивать то потеряется его основное преимущество простота и затраты на изменившиеся файлы 10000 файлов есть поменялось 10 мы вот эти 10 определили и соответственно остальные 9990 мы просто про skip им просто тому что мы должны убедиться что они никак не изменились и вот это довольно затратная операция с точки зрения потребления циpкa поэтому это хотелось бы избежать вот поэтому мы обратились к несколько альтернативному способа определения уведомление это получение непосредственных уведомления от файловой системы то есть файловая система и операционная система они как бы друг друга дружат и операционка знает про все операции которые были сделаны юзер space из файла систему потому что все эти операции делаются через специальные системные вызовы соответственно операционка может с этим знанием с приложениями поделиться то есть в случае java у нас есть набор из интерфейсов этого четыре строчки его член которые умеют с этим знанием работать предоставлять нам их java посредстве на java разработчиков и вот основная суть заключается в том что java приложение опрашивает институт сервиса на наличие изменения который в свою очередь является прокси между jal приложением операционкой и вот как только операционка отвечает а вот сервису что появились какие-то события то ваш сервис отвечает сжал приложений с помощью ручки который уже содержит описание событий удобный для java разработчика и какие файл непосредственно были изменены или там прочитанные так далее несмотря на удобство вот этого способа не тоже есть несколько недостатков свои недостаток пировать то что он представляет довольно маленькое количество event-ов и в случае у сервиса мы можем отслеживать все 4 то есть это три основных кредо ли ты мотив light который отвечает как можно догадаться из названия за создание и удаление модификацию и специальный overflow который обозначает что что-то пошло не так возможно в операционной системе возможно под капотом его сервиса и надо все весь стоит который мы отслеживали с помощью вот этих ивентов надо скидывать и пересоздавать заново вот и второй не менее важный недостаток который является по факту под недостатком 1 это то что мы игнорируем перемещение и вот это недостаток говори никак не лечится потому что если мы посмотрим на такой пример от файл один из файла file1 перминова ли файла то мы получим 2 уведомлений это дэвид и кризис что вообще говоря неотличима от того что мы файл просто прибили создали новый вот это сделано потому что если мы заглянем под капот непосредственных вот-вот в то заметим там специальный тип катар cookies который как раз таки используются в с linux на уровне непосредственно нативного и 5 для свежего не перемещений и вот этот коки он несмотря на присутствие под индексом 2 он сжал код из джиной вызов не попадает они падают он потому что данные 5 должно быть кросс-платформенным перемещение далеко не везде есть в качестве нативными 1 person ных систем вот поэтому вас для кроссплатформенных причин его пропустили сделать с этим ничего не можем его и того если нам нужны все максимально гранулярный подмножество элементов которые мы хотим отслеживать с помощью какой-то системы нотификации и мы хотим в частности старых перемещения мы хотели их трепетному нужно какой-то другой альтернативный способ василису его сервис мы использовать не можем а вот иного из linux этот способ называется антифа это нативная этой которая linux представляет виде хищной структуры они тихо и мент который как раз таки содержит этот идентификатор cookies вот и трех функций которые нужны для инициализации подписки отписки на события и вот основной основе фичи вот это вот подхода стоит он что у нас есть в 12 ивенты в частности вот этим увы фромму в ту которую мы можем с помощью кук с матчей друг на друга и таким образом перемещение треков вот но этот способ к скажем так не без изъянов и основное его скажем так недостатка то что это вообще не кроссплатформенный a stroll совсем и даже не пусть пусть это такой стандарт который представляет нам набор session и фидерных фарси шнайдер на функций утилит соглашение такие что если мы используем только по sex ной функции соглашение то наше приложение будет доступна то есть соберется и запустится на всех пусть x compatible операционках то есть это макось некоторых смысле это linux винда не по секс на я вот а случае антифа и мы должны макоси не запустите ума касия свою это который называется с ивенты нужно будет затрачиваться непосредственно под нее чтобы на макоси запускаться вот ну и второй не менее такой достаточно неприятно недостаток то что все таки для использования и java мы должны будем это написать носящий прокинуть через джина и или ему подобных приблуд которые нам позволят дергать они тихо и с java кода того хочет вообще понять будет ли какой-то профит от данного подхода если мы возьмем померяем аллен простой и они тихой и сравнив потребление спорта до оказывается действительно будет и по 3 они значительно меньше при небольшом количестве заменяющих файлов почти в два раза меньше при изменении всех файлов на секунд однако если у нас модификации довольно часто это тут они tefal понятно дело потребляет большое количество времени процессор нова и он не совсем эффективен потому что полинг узнает об изменении один раз за секунду а энти будет все дети изменений получать и каким-то образом обрабатывать вот но давайте теперь подведем итог по всем трем способам которые мы рассмотрели первый это полинг очень простой и в большинстве случаев он предпочтителен но не гибкие не ресурсоемкие с точки зрения потребления циpкa же так а вот сервис он event bass но представляет не все события поскольку это java кроссплатформенная java и пианино тифа и он максимально гибкий но заточен под linux требует написание джейми портянок вот все таки и мы решили сделать выбор в пользу антифа поскольку мы могли контролировать полностью инфраструктуру мы знали что вы будет запускаться только на линуксе и отложился тоже только на рынок новых машинах поэтому эти война подходила и изменений у вас были 1 секунду или реже вот теперь мы определили изменившиеся файлы когда какой конкретно моменту носки файл меняются нужно понять теперь где мы вообще с этими файлами сколько данных мы успели отправить и вот этот вот это вот определение она требует не к идентификации файла то есть мы получили уведомление мы должны как-то файл идентифицировать для того чтобы вот соответствии с этим индикатором сопоставить state который там будет означать сколько байт мы уже за стримили вот этой vindication на свою очередь отдельно представляет некоторые челлендж вот тут тоже есть несколько способов ряд из них нерабочий ряд рабочие для различных ситуаций 1 самоочевидным это просто путь использовать файл в качестве идентификатора и куда-то в мо потом складывать и там maps to string винтов и по вот этому вот по этой марки уже определять несколько файлов у нас правда на была такой способ он не работает а уж если мы файл смываем мы получим не консистентные представления то что файл 1 у нас наше приложение будет думать что файл один остался на месте файла пропала вот на самом-то деле fm2 никуда не делся он просто переминался file1 а пропало у нас file1 вот такой ситуации тоже хочется избегать другой более продвинутый способ pth первых нескольких записей кстати такое довольно common способ но у нее тоже есть недостатки то что если мы бываем файлы нас есть два файла с одинаковым контентом а у нас такие файлы были по историческим причинам и мы один в другой бываем то вы как раз таки получаем тоже несоответствие стоит одного файла с другим и тут возможен да и в коробку вот поэтому мы обратимся к еще более продвинутому способу это пасек файл сериал нам по sexual сериалом брать такой идентификатор который гарантированно единственны в пределах одной файловой системы вот и пусть x предоставляет набор функций которые можно использовать для его определения то есть это f 100 л 100 300 к счастью и java-приложение нам напрямую вот эти функции использовать не надо у java есть свой утилит ный метод это статический метод get атрибут который по пути к файлу может определить нам вот этот идентификатор то есть мы просто берем указываем стрелковое значение этого атрибута это unix ой ну и потом отзыв то результирующий кастинг лангу его используем вот под капотом там нет ничего интересного простой тот тот же самый обычный вызов стата который документирован в по sexy вот но но у этого способа есть краеугольное еще недостаток который совершенно точно никак не лечится это то что используется путь к файлу а вот такой использовали против файл порождает такое вот про из кондишен представим нас есть два файла запись производится file1 соответственно мы получаем уведомление о том что у нас произведена запись в этот файл мы начинаем обрабатывать читаем его и ноду используем вот этого get атрибут а и ноду мы посчитали дальше мы должны по этой ночью определить стоит сколько байт мы уже за стримили и в этот момент между вот вычисление мои ноты началом непосредственно чтения данных у нас какой то процесс там берет как правило это была лига сирота пар от файл dual какой-то совершенно произвольно берет и бывает file1 соответственно в итоге мы открываем файл 2 и думаем что мы открыли файл 1 потому что надо у нас от файла один а на самом деле мы открыли файл 2 то есть вот такой вот такого труда раис кондишен приводит тоже к да это коробку мы его тоже надо избегать вот поэтому нужен какой-то способ который нам позволит определять ой ну да и читать из файла без вот такого рейса вот для того чтобы понять что это за способ обратить еще раз к стандарту plastics помимо функций стад которая принимает на вход указатель на чар ну то есть личную строку есть еще f100 который работает с файлом дескриптор а это как раз таки то что нам нужно вот сколько своего дескриптора помимо вот накатывание функции встать мы можем из него еще и читать то есть накатывать на него системный вызов рид вот как раз-таки тот самый рабочий способ про который которые мы искали вот другой вопрос откуда вообще от файловый дескриптор рода тентовый костик сны файловый дескриптор достать тут тоже есть несколько вариантов первое воспользоваться публичным классов дескриптор выдрать из него с помощью reflection приватное поле в да и на линуксе она совершенно точно будет соответствовать вот нативного файловый дескриптор у другой более лайтовый способ если например в проекте есть библиотека ванне а то мы можем вот эти трюки с reflection нам не сами не писать мы можем воспользоваться статическим утилит на методом где твд который под капотом уже эти трюки с экшеном содержит ну и третий сам хардкорный способ это написать свой нативный метод который будет просто георга системный вызов лупан и открывать файл только для чтения пробрасывать вот этот файловый дескриптор уже в java приложение и вот таким образом от для использования стата у нас требуется файловый дескриптор который нужно где доставать и опять же нам нужно будет писать нативный код потому что я встать не каким образом дтк по стандартной поставке не представлен то есть тут тоже есть некоторые сложности с ей реализации теперь переходим к самому интересному интересной части это анализ performance вот этих сектантов статов и и так далее чтение первых некоторых байт для идентификации вот для замеров но будем использовать язык программирования си x86 eng принципе то есть первые n 13 к это функция rds c которая читает специальный timestream каутер который локально для каждого типа у ядра он инкрементироваться с постоянной скоростью и вот это ян коммента ция с постоянной скорости еще говоря не зависит от текущей тактовой частоты процессора и в каком powerman состоянии мы находимся то есть например если мы заходим в терм space сделал какой-то syscall мы начинаем висеть на им путал пути и ядра операционной системы помещается по у ядра в стане hold of то есть процессор не какие инструкции не выполняет он висит ждет прерывание когда ядро его из этого состояния в нормальное вернет и при этом утонченным к утру он продолжает инкрементироваться с той же скоростью с которой инкрементироваться в обычном состоянии в use space а вот второй фоны 2 intrinsic это сел flash который нужен для записей для сброса каша во всех во всей каши йерархии по заданному адресу а он нам нужен для того чтобы поменьше маркете уже непосредственно чтение первых некоторых байт потому что highly likely мы будем в таком состоянии что данный скажется пункты шея у нас будут мне представлена в kernal кашах . шаха не лежать будут вот итогам мы получаем такой вот результат для сравнения статусов статам кажется что из 100 тонн эффективнее на 40 процентов но тут есть несколько нюансов во-первых 100 для порядка 40 процентов свое выполнение он использует для того чтобы определить вообще если такой файл protective перми шина если текущего пользователя я говоря право на вычисления атрибутов этого файла и если их нет то мы должны вернуть системный вызов должен вернуть а -1 потому что такая операция не валит на файловый дескриптор уже все эти все эти чеки выполню то есть какой то какой то процесс уже сделал об он получил от файла дистриб 3 как бы проверки и лука по уже были проделан то есть это не совсем честно и сравнение нужно сравнивать стад и опыта статуи тут ситуация уже не такая магическая то есть опытный штат эта пара стенных вызов она проигрывает стату на больше чем два раза ну понятно чем у того что это во первых не один системный вызов а два каждый системный вызов он сопровождается некоторым оверхедов транзакцию и съесть юзер spice girls по iso обратно вот мы теперь сравним вообще что там по чтению первых нескольких байт в частности это 1 страница тут вообще все плохо даже опытный штат пройдя выигрывает у чтение только чтение данных из kerbal space a user's пейс почти в два раза и это даже без вычисления хэша соответствующему танака чем хэш какой-либо то ситуация будет как правило еще хуже вот этого подытожим все способы которые мы рассмотрели вот абсолютный путь он тривиален недоступен войны тихой событий но он файлы инфицирует так же как их аж 1 байт который помимо не идентификации файл он еще и подтормаживал а вот а этот набор который по факту classic style сериал наоборот 1 тоже он как раз таки уникален а файлы системе и вполне себе неплохо пир форм для его определения есть два способа первый это же да каши на который нам не совсем подходит по причине от того самого рейс кондишен и 2 ст от он как раз таки и не подвержен этому раз кондишен у и то что нам нужно но для его использования нужно файловый дескриптор достать и написать ещё одну портянку нативного кода вот поэтому мы все таки на и кстати остановись потому что наиболее гибкий функциональный для идентификации вот этот индикатор мы использовали файл serial number для нашего стоит а количество отправленных байк теперь остается у нас еще один момент это непосредственно чтение данных которые мы которым мы получили которые недавно появились после того как мы отловили уведомлений вот и для этого чтение у нас есть несколько требований во-первых оно должно быть максимально эффективно и мы хотим это вон хи то есть батарей получать потому что визит доджи tk11 он был строго типа уже такая dance появился криповый gzip директ буферов и различные коннектор они тоже к сожалению из коробочных и полу и поэтому мы хотим данные вот именно в батарея не где-то в директ борьбу себе вот в джаве есть вообще три способа как из из файла прочитать это зира купе файл файл чинари ты классический input stream вот зира папе файл это такой способ не совсем для чтения он используется для перекачки данных из файла куда-то еще у побрей то болбой чем то есть это может быть socket какой-то что-либо еще может вы топой быть unix новый вот и вот под капотом у этого метода содержится используется вот такой вот системный вызов send file который как раз таки отвечает за перекачку данных между файловых дескрипторов то есть это очень эффективный способ для непосредственно перекачки если нам нужно вот из файла куда-то там стоки закинуть мы в users поезда на вообще не заносим это все делается на уровне ядра операционной системы поэтому он максимально производительно к сожалению поскольку нам нужно вот пользовательскую обработку делать это шифрование сжатии нам нужно данные именно в визир space соответственно такой способ он для нас несмотря на его эффективность он new забель вот поэтому нас еще фаворит которая представлена метадон рид принимающей на вход байт буфер и позиция откуда мы читаем под капотом он используется классический стены вызов паре для чтения по позиции и вот между вызван джалла метода риты попадания вот эту нативную реализацию еще выполняется ряд проверок такие как является ли instance борьбу сера который мы в которой мы читаем директ байк мусор из является то мы идем в ту нативную реализацию делал этот перед а если не является то мы выделяем временный директ буфер данный вард временный директ буфер читаем и из этого временного директ буфером и в наш типовой борьбу сербка под капотом которого лежит байкеры моих данной уже копируем вот что вообще говоря не очень-то эффективным что копировании больших данных она как бы в учет собой решено с проблемой вот поэтому мы переходим к input stream у кажется что вот он способ который уже умеют в байтах и читать может быть он нам поможет но нам тоже к сожалени не поможет потому что он тоже использует временные буферы это зависимости от размера батарея то стек аллоцирование буфер либо he полосы раваны что еще хуже потому что на каждое чтение у нас делается молока потом этот молок указатель который на молок верну вам еще iv решится то есть все совсем плохо сим пустыре вообще классическими пустым он очень довольна он тормозной довольно таки для чтения из файлов его тоже использовать не очень хорошо соответственно подводя итог по всем трем способам которые мы рассмотрели у каждого есть какие-то недостатки в случае зиру папе файлы это передача данных без users твой с обработки о случае файл чем olympus stream а это дополнительно копирование fit вот и поэтому на хочет найти какой-то способ который читает данные напрямую хип и ничего не аллоцировать ничего никуда не копирует вот такой способ есть называется он критической секции джиной от критическая секция джина представлен двумя функциями из джейн айпи первой функции и to get примите фары critical она непосредственно отвечает за то чтобы вернуть разработчику сырой указатель на какой-то ребенке по которому этот байт array соответствует который мы передаем эту функцию и вот с этим батарей мы можем делать что хотим это сырой указать можно туда данный прочитать и можем его как-то зад ракете так далее вот и вторая функция это релиз critical для того чтобы уведомить гарбич коллектором то что мы больше не используем сыр и указатели на регионы hippo и можно выполнить garbage collector имеет право выполнять все обычные действия которое он skip он выполняет тип compaq шан непосредственный collect горлач collect и так далее и вот уведомление гарбич коллектор о том что мы используем какой-то сырой указателя но выполняется с помощью такой функции logo церкви но джек которая как можно догадаться из названия она проверяет является ли поддержка у garbi имеется ли у garbage collector поддержка так называемого обжиг опенинга то есть если она имеет 100 мы этот объект просто пи ним говорим garbage collector этот объект не трогая все остальные то можешь смывать компактность и так далее прибивать все что угодно есть такой поддержки нет но ничего не остается кроме как полностью гарбич коллектору выключится потому что если он не выключится и будет коллекции данные но вы просто характер типы повезет если мы упадем в корку не повезет если мы получим какую-то магию в runtime вот и в итоге стандартной поставке g d к облик pinin поддерживаться только одного коллектора шенандоа во все остальные при входе в критическую секцию будут благополучно выключаться вот теперь передем к реализация вот этого критика варит метода это обычный нативный метод из java который принимает на вход файловый дескриптор и вот файловый дескриптор который мы уже доставать умеем мы его передаем непосредственно в нативную реализацию и вот эти две функции геты релиз критиков они просто будут внутри содержать себя системный вызов рид поэтому файловый дескриптор который данные будет нам уже вот сырой указатель регион типа закидывать теперь переходит performance у этого тесто то есть нам нужно сравнить насколько он быстро и быстро ли вообще быстрее ли вообще в обычных там энту стримов и каких-то там файл channel of которые читают криповый бай-бай буфер вот опять же будем делать ведь на горячих прыжки шах потому что это как раз таки наш runtime гарантом кейсы в итоге да действительно получается сильно быстрее порядка 20 20 процентов 25 процентов это очень неплохо вот таким образом вот для чтения мы все таки решили остановиться на critical секции для того чтобы данный файл читать потому что вот эти 25 процентов кажется что это нежелательно performance нежелательно терять и он будет болезнь вот теперь кажется что все еще кейса рассмотрели определять файлу изменившиеся файлы умеем данные то есть три трека умеем читать умеем вот кажется что все но тут возникает вопрос а можно что-то еще подтюнить если можно то что ну чтоб понять можно ли что-то еще подтюнить но нужно взять запустить профайлов то есть на линуксе это стандартный перс и посмотреть что там происходит в runtime а происходит того что то есть это такой классический стектрейсы из ядра и 70 процентов которого отжирает специальная функция копию зерна ханства string вот она как раз таки отвечает за копирование данных из пейдж а который там его крутится где-то в ядре и в наш users буфер батарей и ее реализация содержит вот такую вот инструкцию рифму в избе сразу может возникнуть целый ряд вопросов во первых почему не виктора почему не модные молодежные а вы x и для которой кажется что используется для копирования память почти везде второй вопрос будут ли вообще выксы быстрее чем вот эти rip новые если будут то насколько и если все-таки они будут быстрее то как нам эти а выксы для копирования памяти применить ну первый вопрос это почему обычно используется ну потому что в общем случае а вы их ядре я использовать мы не можем это гарантируется это декларируется спецификации системы обед то что каждая инструкция систем кол может менять только два регистра трц xaero dance и соответственно остальные регистры general топаз регистра они все благополучно перед входом свернул с пояса не дам пицца на стек а после выхода esquire на space они из этого стека обратно устанавливаются чтобы пользователи не как и не confusion соответственно если мы хотим использовать виктора мы должны эти же виктора эти векторные регистры которых там порядка несколько то есть в общий размер порядка нескольких килобайт мы должны кто же нас так как скинуть и со стока вернуть что общем-то бедре нужно крайне редко и будут создавать некоторые тормоза вот то есть и стекло на это и инструкции так не быстрая она еще будет там виктора со стока нас так гонять поэтому в общем случае вы их со не используется используется крайне редко каких-то специальных драйверов вот второй вопрос будет ли а вы x вообще говоря эффективнее чем rip ну вот статьи кто-нибудь может сказать будет ли или нет есть у кого идеи ну чтоб понять будет или нет тут надо как бы взять сравнить вот для vx у нас есть классический системой копи который будет копировать пока шли не а для немцев для дипломов у нас есть немцы которые при размере память 4 килобайта и более она будет рипа вы юзать для копирования соответственно чтобы немцы нам жалко декад по использовать нам нужно опять же нативный метод со стандартной критическая реализация и benchmark мы будем это все с помощью джеймса классическая поза для бенчмаркинга живым и кода позже в и в итоге мы получаем такую вот картину что она 828 килобайтах у нас почти различия минимальны это порядка 10 15 процентов а вот на больших размеров она довольно существенное составляет 6 а 90 процентов то есть немцы системой копия обгоняет и вот окажется что большие данные как раз наш кейс и мы хотим их уметь быстро копировать тут хочется понять почему почему немцы пылающая такое быстрая при больших данных есть идеи но оказывается что немцы по и оно не такое она чуточку более умные чем использование простых рипов ваще всегда когда у нас память больше 4 килобайта и если мы то есть когда мы копируем память помощи немцы при она делает сравнение на так называемый x86 шеридан temporal пришел то есть на моей машине тут x86 sheraton там прошел тот 6 мегабайт соответственно если размер копируем и памяти больше ти мегабайт она переключается на специальную технику который называется non temporal записи вот и ключевая особенность вот этих нам тембров записи заключается в том что они анка что было но тратила рейтинг вот чтобы понять что это такое рассмотрим обычную запись который у нас есть например джами мы делаем там запись поле класса вот и основная особенность обычной запись заключается в том что данные всегда попадают в один that cash вот всегда даже случае вала тайлов данный никогда в память напрямую не попадают они всегда падают в data cache но случай латов там дополнительные барьеры просто расставляются для memory консистенции и вот для того чтобы данные из обычной запись в кэш попали нам нужно чтобы вот эта линия когда данные записываются должно находиться специальных состояниях то есть это эксклюзив или modified что это значит то есть в других играх были 1 до тк оше вот не должно быть вот вот это вот памяти где то там за кошелем то есть это стояние шарит когда в нескольких я даг содержится циpкa я др содержится вот это вот область памяти или инвалид когда просто данные в каше вообще не представлен и вот чтобы вот если линейка находится такого не правильном состоянии циpкa стремится состоянии исправить инициируя специальный так называемый ride for о вашей prequest которую суть которой заключается в том чтобы подтянуть данные из верхних уровней иерархии каши или памяти вали один dodge вот и вот в отличие от обычной записи но он temporal записи она очистка что он никак не взаимодействует они просто данные помещаются специальный проект компании баффер сцепу ядре и вот этот баффер при переполнении с память сливается и конечно вообще никак не трогай то есть у нас загрязнение к шее отсутствует и соответственно мы неплохо выигрывает вот то есть есть подвести итог по немцы п и какие темы копирования использовать то есть вот 4 до 6 мегабайт это реп новые и более 6 мегабайт атлант-м парал вот с учетом такой особенности и еще раз performance при копировании которое вы видели он заключает достигается за счёт того что дано у нас большие они в кэше никак не по месяц даже во славу кеш который на мои стремных миг архитектурах это 8 мегабайт на каких то более последних это 6 мегабайт если мне память не изменяет вот и соответственно 300 мегабайт понятно что в каше никакой не влезут они будут просто записываться и иви катится и это очень эффективно анандом парал эту проблему как раз таки решают вот кажется что есть эффективный способ данные из ядра скопировать из kernels пресса users твое скопировать как его ваще применить но тут сразу у нас возникла идея что давайте-ка возьмём файл в память за матчем . с горячей и вот к этому смогли нам у региону накатим он там про копирование должно быть очень быстро и эффективно для получения от масляного файлы и системный вызов и мэтт мы будем использовать для те кого неё которые за нас есть системные вызовы уже помощью джина к нам в код пробрасывать этого в конструкторе мопед файла у нас есть em up в методе клаус у нас есть тема nmap который заставляет но то вот этот регион который мы с эмма пам получили он вам об ливает вот замеряем performance всего этого хозяйства при использовании мапо и но там про копирование получаем вот такую вот ситуацию то есть даже без учета map анапа у нас вон там про копирование сама пам почти также как критику ripper форум хотя казалось что реп ну вы гораздо менее эффективный способ чем на пинта копирование на больших данных а если мы будем мы pm учитывать там овощи проиграем о performance у и почти на там 25-30 процентов вот вопрос а почему проиграли собственно performance at но он там про копирование вроде модные молодежные быстро а performed хуже есть идеи нет там город переходы джейна обратно смотрите у нас переход в жена делается один когда мы вызываем вот это вот немцы при которыми про бросили из в java уход он 1 то есть это он он будет уехать но он не такой значительный но на самом деле там если посмотреть под профайлер mta основную вот этот как раз таки 22 процента но сжирает некоторый печь фолд что копать fold знает кто нибудь вот смотрите чтобы понять что такое подход вообще рассмотрим как происходит обращение памяти любое неважно там из java еси и так далее вот обращение к памяти всегда происходит по специальному логическому адрес то есть мы никогда по физическому адресу из users поясов память не ходим вот и чтобы в итоге в эту область памяти попасть нам нужно понять какого вот этому логическом адрес какой физический соответствует и вот поэтому циpкa при каждом обращении выполняет трансляцию адрес логического на физический вот для трансляции он использовать специальные hotel by cash & the translation лука сайт буфер который по факту тот же конечного аналогия обычно у memory кашу только он кэширует не память а вот эти вот трансляции то есть вот адрес сауна соответствует физический адрес b и вот если нужно трансляцией в каша нет то циpкa обращается уже копаешь таблица которая находится в пространстве ядра операционной системы она you maintain и пытается найти трансляцию там disciple узнают в какой-то какому адресу нас по таблице лежит и это входит и если вот эти таблицы нет этого адреса у нас его там нет то циpкa кидает специально exception который называется почву от exception paypal перехватывается операционной системы и в ответ на этот перехват проставляется вот эта самая trodat это самое соответствие то есть между логическим адресом и физически то есть и вот такое вот представление просто соответствие то есть нам не нужно выделять физическую память у нас она уже выделено . шик прогреты нам нужно просто просто и соответствие она называется майнер пошел когда физическая память выделяется назвать печку и вот вот это соответствие она как раз таки отжирает вот те 20 процентов которые мы потеряли на первом обращении к смотри нам у региону и если мы соответственно попытаемся применить ин-т копирование к региону который уже запрещал think the он и как раз таки увидим этот прирост по performance у который мы раньше видели с ноутом про копирование вот и того для чтения из файла вот такая техника она говоря не подходит потому что каждый раз когда мы будем пытаться обратиться к новым страницам которые вновь появились спичка шах ядра мы будем всегда получать поить фолд и ну и второй момент он более такой не менее важное это то что но он темпорала не афишируется для того чтобы данные обработать они всегда будут в кэш подсаживаться и но все равно этаж промок так или иначе получим то есть данная техника для чтения неэффективным однако поскольку вот он там пора ли не кэшируется то мы можем их применить немного в другом месте в том месте после того как мы данные обработали мы поставляем на стриме то есть мы вскидываю буфер который когда-то на прямо переполнится там четыре мегабайт 8 в защите фигура ци и мы его просто сольем в теч уже обработаны и уже сжаты и вот для постановки данных на streaming вот этот буфер на стримах но он там para la идеальный выбор почему потому что потому что они не кэшируются и они нам в кашах не нужны то есть в кашах нам нужны только данные только этот буфер непосредственно которой мы читаем мы делаем обработку таким образом мы если накатим нам темпорала мы сильно уменьшим каш промах и снизим затраты путаем она вот эти of a request и которые будут связи с этим возникает вот таким образом подводим итог по результирующий схеме с тренинга которые мы в результате получили то для взаимодействия с локальными дисками у нас получился and five статы critical секции джиной непосредственно после обработки постановки на streaming у нас появились нам там para la которые но реализации которая была написана на ассемблере потому что нам нужны конкретные инструкции для того чтобы в обход к шее данные в памяти записать вот ну там такой же джиной был только джиной только социальной реализации по итогу разработки вот этого приложения мы довольно сильно добились экономь инфраструктуре у нас появился авто skinning мы теперь можем машины в любой момент включать потому что она стремится и они данные мы не теряем и и мы данные вот этими теряем и затрат на 3 минут мы тоже сильно уменьшен благодаря вот оптимизации такой джейн и a critical и использованием более эффективного использования спал кашей вот в заключении хочется сказать ошибку performance инжинирингу shit такое и как его делать из скорее всего если вы пишете код хайпе фонд приложения вы вам придется так или иначе под капот платформа на которой вы пишете смотреть то есть случае живым это понятно что скорее всего вы по листам hotspot зависимости от задачи возможность жить компилятор и так далее помимо непосредственно самого хотспота нам надо еще понимать как это все обрабатывается операционкой какие-то msi сколы где возникают и помимо person еще нужно понимать чуть железо у вас есть и как это железо более-менее готовить вот соответственно если мы вот эти все три момента используем то скорее всего мы харпер фон в приложении напишем который будет неплохо решать поставленную задачу всем спасибо доклад окончен итак коллеги у нас секция вопросов прошу сейчас наши помощники спасибо один завод компания tsr-2 вопросы наверное скажите а почему мы вообще не рассматривали вариант там уйти там на несколько трейдов потому что с точки зрения перформанса такого абстрактного в вакууме 8 конкуренции тоже может помочь когда диски конечно нас не вращающийся какие быть и psd да смотрите во первых по поводу дисков мы вот этот овен best подход не случайно как вы применили мы хотели чтобы вот этого дисковый путал тут вообще не было то есть данные появились они вспышка шах крутится мы сразу уведомление выхватываем из . шейх достаем то есть дисковая он он почти отсутствовал вот именно это одна из один из point вообще вот этого ивента запросы вен bass подхода это 1 2 конечно конкор ность у нас там была мы это все данную то есть файлов у нас было много мы это все в параллели обрабатывают то есть если бы это обрабатывали в один поток это все конечно несмотря на оптимизация все довольно медленно бы работала вот понятно хотя странно одесские точно да диски смотрите да диски конечно же мы смотрели это для этого есть и us that который трек от есть тот же первым имеет трогать фолд и дисковое мпу толку то есть диски они отсутствовали почти там иногда возникали диск когда например нужен был файл перезалит случае ошибки то есть от этих дисков никак не получилось ходить ну и эта ситуация была не регулярно большинстве случаев дисковыми put out at отсутствовал благодаря тому что они испечь каша брались ну еще один пойнта что если мы все таки используем первую запись файла то вот это первой записи она вспышка что же попадает это кстати говоря но он тоже как бы может нужные данные которые мы хотим посчитать испачкаешься зависеть то есть в результате тут тоже вот такой момент который довольно важен почему мы все-таки первые записи использование понятно и второе даже просто скорее комментарии у меня было очень забавно то есть очень интересно очень здорово но вы очень много бород бодались и боролись с особенностями по большей части да но все таки такие молвил вещи и все-таки носи проще писать поэтому там был там уже почти сразу было понятно что большая часть на не больше там корчась будет написан на осях потому что ну в живыми это прям совсем трэш получался чтобы что-то под например и чтобы там банальное перемещение достать из живым и нужно было вот понять что у нас там есть вот это 3 индекс размещение по третьему индусу там этот путь лежит вот там через джиной через приватный свет пробросить но это как мне очень взяли это все ручками сделали понять спасибо спасибо за доклад а вот у меня такой вопрос изменение вы это понял трека и средствами операционной системы все так а там не получается ли race conditions у вас работал кал бег на эти изменения и в этот момент приложение уже что-то еще поменяла но ваш call back не вызывался замечательный вопрос весь кондишн и конечно же получается вот поэтому смотрите там то есть например то есть вот у нас есть файл туда пишут пишут пишут event они все равно скими то лагов приложений попадают то есть когда мы получаем эти винты на обработку там уже с файлом может вообще по факту чет другое произойти на 8 можем может уже не быть принципе вот и рейс конечно конечно же есть ему и одно то есть вот эти мол и они отчасти race conditions of которые вот возникают при таких вот при таком лаки попадание ивентов и возникновение их на диске они на спасают это первый момент второй момент такая ситуация вы смотрите у нас есть файл куда пишем уведомление на запись мы получили кто-то где-то там взял файл прибил поставил то новый фф а то что-то записать успел а мы думаем что вот мы получаем уведомление еще старая того файла старого старого вот черта происходит то есть мы его получили начинаем читать читаем уже и снова хотя как бы это вопрос вызывается какого файла мы читаем дальше нас приходит дэвид мы этот стоит вообще очищаем которые у нас есть и читаем уже из нового файл соответственно вот такой раз конечно очень похож на ebay проблему его мы тоже как бы мы с ним тоже столкнулись и его тоже решали на уровне уже конкор нас и java-приложения понятно здесь этим чего вопрос они рассмотрели вы то есть я так понимаю исходное положение тоже ваша которые эти файлы пишет нет исходное приложению за степи сервер он там пишет их как хочет еще был ротатор которых тоже бывает ну вы вы вы не можете доработать http server а мы как раз его не хотели дорабатывать потому что он пишет пусть пишет мы решили все таки жил о просто если какие-то там внести доработать что вот он он пишет и куда-то уведомляет чтобы не средствами операционной системы вопрос как уведомляет то есть у нас все таки то есть там в любом случае получилось бы какой-то интро прусскому никишин или через файл через какой-то файл вот опять же файл уведомление через файла возможно это тоже как бы то есть мы бы столкнулись с теми же проблемами отслеживание вот этих уведомлений как и уже в возникновении уведомлений в этом файле есть уведомление об уведомлений возможность таким проблемам вы столкнулись но мы как-то об этом особого эту сторону сейчас скажу особо не думали то есть вроде есть уже точно есть уже система которая нам ивента трека it now you и кажется что вполне неплохо использовать понятно спасибо так у нас по времени но последние два вопроса спасибо большое за доклад очень много интересного узнал чисто ради интереса есть такой open source ный софт френди называется который вот прямо то же самое делает и насколько порядков он медленнее чем осмотрите да это тоже хороший вопрос то есть про то я вообще про существующее решение мы существующее решение смотрели по той причине что нам нужно было свое максимально кастомайзинг было решение потолще то что мы хотим той мы как бы с ним и делаем то есть флю индии мы не beach park ли нашим кистью точно скажу поэтому цифр нет спасибо сосед здравствуйте и спасибо большое за доклад очень интересно особенно с точки зрения java программиста вот и опять же с точки зрения использования java очень большой вопрос вы ее успешным победили но зачем почему вообще не отказались от gm который вам только шала но вы смотрите логика перемалывания собой самих событий конкор инси обработки вот этих событий она была написана все-таки на java потому что если например писательство на гол но у нас экспертизе вова не было то есть было экспертиза только в java и вся писать конкор на приложение носи это мягко говоря не очень то куча кораблей скорее всего основная часть времени было потрачено на разбирали core dump of из-за обращения по пока раб чон ым указателем что общем то не очень хотелось поэтому логика конкуренции и вообще говоря то есть там логика была не совсем тривиальная по работе с приемники это sour сами вот она была вся написано дживы непосредственно тинейджерам языке вот такие ты low-level вещи они были просто подкручены и протянуть через джиной то есть все все переписывать это довольно затратно а чуть-чуть подкрутить это вполне себе разумное решение и так дмитрий выберите пожалуйста лучший вопрос я думаю что прогресс candychan это прям то с чем мы этот молодой человек да это то с чем мы довольно неплохо бодались наш длительность жизни не поняли кому это к нему да да да да да итак на этом дмитрий переходит в зону дискуссии вы с ним можете пообщаться также зоны дискуссии у нас доступна и в онлайне давайте попрощаемся с нашим докладчиком а также дмитрий подарки от спонсоров все спасибо вам большое до свидания"
}