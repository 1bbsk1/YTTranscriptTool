{
  "video_id": "seF8ovtFySg",
  "channel": "HighLoadChannel",
  "title": "Как мы сделали свой собственный Netfilter с Intel DPDK и префиксными деревьями / Александр Самойлов",
  "views": 1337,
  "duration": 3302,
  "published": "2019-05-14T14:56:14-07:00",
  "text": "зовут алекс самойлов я в коде безопасности разработчикам сегодня я хочу вам рассказать о том как мы сделали свой собственный нет фильтр используя in the hype детей и префикс ным деревьям план выступления у нас следующий сначала поговорим зачем мы вообще решили сделать свой над фильтр чем нас не устроил существующий во вторых как мы смогли добиться фильтрации пакетов зафиксированное время независимо от количества правил в третьих как мы смогли объединить несколько этапов обработки пакетов в одну большую операцию и наконец совсем кратко поговорим о том как мы это интегрировали в уже долго функционирующую и устоявшуюся систему пару слов о нашей компании мы разрабатываем средства защиты уже с 95 года половина нашего бизнеса и the crypto шлюз континента ним чуть подробнее расскажем попозже три центра разработки в москве и питере в пензе и все что мы делаем сертифицируется фсб стек как я сказал так как и сказал половина нашего бизнеса это вот такие комплексы континент по сути это такие metal box и которые позволяют вам делать кучу сетевых задач и такие как фильтровать трафик делать и пьян обнаружат вторжение делают предоставлять защищенный доступ ну по сути стандартный набор таких и тем решений то версия которые вы прямо сейчас можете пойти купить на сайте а нора это третье поколение она работает на free bsd но сейчас мы разрабатываем новые поколения она уже работать на centos и именно рамках работы над новым поколением континенты мы и решили сделать свой собственный нет фильтр к третьему поколению отношения никакого не имеет у нас используются только отечественные алгоритмы криптографии и поэтому принципе можно использовать вот такие комплексы для защиты ваших данных в соответствии со всеми российскими законами давайте перейдем ближе к сути за последние несколько лет мы как и думаю многие из вас столкнулись с теми же проблемами это возникает у многих во-первых изменились требований к производительности если раньше наши комплексы ставили в основном на границе между внешней внутренней сетью там трафик не очень много его характер скажем так не сильно критичен к задержкам и к потерям то сейчас все больше и больше наших шлюзов ставят даже на сегменты во внутренней сети и там трафик он в разы больше и его характер гораздо жестче там очень много люди петров к.п. видеоконференции и там вот задержки и потери это очень критичным во вторых изменились требования к функциональности если раньше заказчики могли себе позволить покупать разные коробки под разные задачи то сейчас они хотят чтоб все было в одном и обнаружение вторжений vpn и фильтрации все-в-одном по-другому такие системы зацените mi3 по списку на не по значимости это изменение размеров политик безопасности для сетей если раньше в худшем случае у нас были сотни правил фильтрации то сейчас легко их набирается несколько тысяч и даже в центре разработка которые нас москве на нашем собственном континенте несколько тысяч правил фильтрации мы подготовили ряд небольших экспериментов чтобы продемонстрировать что вот требования номер один и требование номер три это как бы реально проблема давайте посмотрим немножко графиков для эксперимента мы взяли нашу самую старшую платформу самую мощную на ней стоит довольно хороший мощный процессор там 14 лидер без учета гипер трейдинга довольно много ракетки и 8 10 гигабитных портов и выпустили через нее самый стрессовый трафик который вы только можете придумать это пакеты и дипе 64 байт он хуже чем такой трафик нет ничего в реальных каналах вы никогда не увидите чтобы канал был забит такими пакетами но для эксперимента это означает что если вы обрабатываете такой трафик то все остальное вы тоже легко обработаете и так что мы получили вот что мы получили если для сравнения посмотреть на легкий трафик легкий трафик в нашем случае это http запросы и ответы причем страничке там были большие и средний размер пакетов приближался к максимальным 1514 то там увидим вроде неплохую такую цифру пятьдесят пять с половиной гигабит вроде бы можно чем-то гордиться но мнение это ошибочно если мы пустим реально стрессовый трафик то мы видим всего лишь полтора гигабита и попрошу заметить на очень мощном процессоре с 14 ядрами который все работают под сто процентов и при этом у нас даже никакой реальной работы не происходит мы просто мыши визирует трафик полтора гигабита мы потеряли 98 процентов пропускной способности вот эта проблема которую вы здесь видите общем то проблема известная проблема давно уже освещается давно предлагаются те или иные решения я в своем докладе не буду очень много вот проекта конкретно говорить но вкратце я все-таки расскажу про основные подходы которые вы можете применить чтобы что-то вот с этим сделать первое о чем вы можете подумать в таких ситуациях ну давайте сделаем чуть помощнее добавим побольше я дирк процессор или вообще несколько процессоров поставим несколько узлов прикрутим еще какой-нибудь плясали asik но вариант много все это мы сразу же отмели по одной простой причине что мы не можем просто так увеличивать стоимость наших платформ потому что у нас довольно жесткая конкуренция и мы не можем так себе позволить сделать а во-вторых многие эти решения они временны не понятно на сколько их хватит вы сегодня сделали апдейт процессора завтра он уже устарел трафик возрос вам опять надо делать апгрейт это война вооружение который вы все равно в заведомо проиграете поэтому мы сразу подумали о чем если вы не можете наращивать аппаратами составляющей давайте оптимизировать программную составляющую и вот проекта в принципе можно отдельно говорить 23 часа и все равно даже половину не сказать того что можно сказать поэтому вкратце основные подходы то что вы можете сделать основной подход номер один вы можете что и подтюнить в ядре можете понастраивать каких показателей поиграться размеры размер бойфренд те или иные показатели по выставлять или применить какие-то новые технологии которых благо сейчас очень много вот только сегодня мы много слышали про и бпф прекрасная штука советую послушать те кто еще не в курсе что это такое однако чем это хорошо это хорошо что это минимум трудозатрат с вашей страны вы реально ничего не разрабатываете вы берете какие-то готовые решения и как-то их комбинируйте но минусы тут тоже есть во первых прирост он все-таки обязательно будет обязательно но не то чтобы сверх кардинально по крайне мере по нашим прикидкам в несколько раз да наверное но опять же кардинально с картину вы не улучшить и во-вторых это не совсем универсально то те настройки которые хорошо работают одного заказчика плохо работают у других заказчиков мы не можем подобрать такие настройки чтобы у всех все работало всегда идеально и а подстраивать свою платформу под каждого заказчика мы тоже не можем себе позволить то что но все это сертифицируется и там все фиксирована должно в общем понятно можно много про это говорить переедем дальше во вторых вы можете посмотреть на код в ядре понять что там что-то реализовано не очень хорошо и подумать охрана я же могу лучше вот я могу вот этот кусок написать лучше и можете этим заняться принципе это более выигрышный вариант в плане производительности если у вас руки скажем так растут откуда нужно то вы действительно получите хорошие цифры однако минусов то тоже хватает во-первых интегрировать логику в ядро это всегда боль не понятно как это будет работать с остальным сетевым стеком но и самое главное когда выходят новые ядро обычно ваш код становится немножко неактуальным его надо переделать вот сюда же еще можно было бы отдельно вынести такой отдельный мини строкой новый подход замечательный xd п многие про него наверно слышали когда вы можете навешивать свои обработчики в виде и бпф кода на ранних стадиях прохождениях какие-то в системе замечательная штука но к ней тоже столько вопросов гораздо больше вопросов чем ответов если кому интересно можем подискутировать после доклада как бы почему мы не выбрали в итоге такой подход мы итоге выбрали вот что это еще один подход когда вы делаете корр на байпас то есть всю логику вы вместо того чтобы загонять пакеты в ядро вы носите в юзер space напрямую захватывайте пакеты из адаптера и делать с ними что то там что вам нужно и затем либо дропайте либо пропускаете дальше много существует платформ для таких манипуляция по и frank над mapa de pe дикей dekay дикей здесь наверное наиболее предпочтителен по нашему субъективному ощущению потому что все таки он наиболее развивающейся наиболее поддерживаемый и там очень много различных хороших библиотечных которые помогают жить это очень хороший компромисс между производительностью безопасностью потому что вы получаете хорошие цифры при этом если ваше приложение свалится но это свалится только ваше приложение юзер спейси уж никак не ядро и всякая то чуть чуть получше минус тут один он глобально он очень плохой всем известный то что если вы делаете карту байпас то все ядро вам больше не помощник она не может вам как не предоставить не какую помощь и вам все что все что вы хотите сделать надо делать самому хотите коммутацию делайте сами хотите маршрутизацию делаете сами над сами whelan сами ну список понятно продолжается очень долго поэтому этот подход он скажем так наверное для самых таких слабых духом команд но мы решили рискнуть все время это был риск решили попробовать и оказалось что не все так страшно принципе все это можно сделать самому и получается очень даже неплохо вот на этом я вот про эту проблему с графиком вот юге пи заканчиваю опять же если хотите дальнейших каких-то сведений но огромное количество есть доклада выступлений пожалуйста я бы хотел обратить внимание вот на другую проблему вот на такую это деградация производительности при увеличении количества правил фильтрации смотрите если у нас минимум правил фильтрации мы получаем те же полтора гигабита юге петров 64 байта очень плохого трафика загрузились что правил минус 30 процентов загрузили тысячи правил -75 процентов у нас еще есть замер где мы загрузили 5000 правил но мы даже не стали это сюда выносить потому что там некрасиво бы смотрелось там -70 мегабит на 14 ядрах мощного процессора дисклеймер сразу что правилам мы загружали наиболее неудачным способом самый плохой трафик на самом плохом наборе тот провел который только можно придумать почему происходит такая деградация но на самом деле ответ кроется в самой архитектуре нет фильтра напомню что в netfilter у нас существует набор цепочек в цепочках существует правило пакет проходит по цепочкам в поисках нужно правило дальше он либо переходит в следующую цепочку accept либо дропа еца либо с ним что-то происходит например над изменяет его достанешь иной и или что то в этом духе мы видим что чем больше у вас правил тем дольше в среднем ваши пакеты будут гулять по вашему цепочкам тем дольше вы будете обрабатывать трафик среднем опять же повторюсь в среднем на лицо линейная зависимость производительности вот количество правил больше правилах уже производительность что можно с этим сделать вы можете спросить у меня а зачем же загружать правило фильтрации таким плохим способом наверное в реальности так никто не делает да действительно первое что вы можете сделать это вынести наиболее часто срабатываем и и правила повыше в цепочках чтобы они срабатывали не ближе где-то к концу списка где-то в начале и тогда тогда пакеты не будут так долго гулять по вашему цепочкам будут быстрее фильтроваться чаще всего это выливается вот в такое правило в начале всех цепочек контракт стоит establish так септ это означает что мы доверяем всем пакетом в уже установленных сессии здесь установлена мы доверяем все пакеты зачем дальше фильтровать однако однако такой подход это не панацея не панацея по двум таким глобальным причинам во первых это правило но и в общем то все похожие правила они ускоряют только легальный трафик это значит что если у вас много хорошего трафика и мало плохого вроде все хорошо но если вы вас кто-то например доносит или просто какое-то приложение что-то неправильно генерирует у вас много плохого трафика который на дом дропать тут дропать вы будете не раз в сессию oro на каждый пакет и сколько пакет будет скакать по цепочкам вновь в поисках нужного дроп правило непонятность скорее всего много если перефразировать вас очень легко будет зада досить плохие плохие пакеты и ваша система начинает молотить практически впустую во вторых такие правила не ускоряют работу с новыми сессиями пакеты в новых сисек все равно будут проходить по всем правилам и такой показатель как sip с connection пир секунд у вас не увеличится таких правил в общем проанализировав от все вышесказанное мы поставили себе вот такую задачу 2 2 задачи нам нужно разработать свой собственный firewall который бы первое нет затрачивал сирия ресурсы процессора то есть мы хотим чтобы процессору ещё оставалось время на решение других задач нам обнаружения вторжений или пьян или что-то еще это первое второе чтобы мы работали с фиксированной скоростью не важно сколько у нас правил одно или 5000 и неважно в каких условиях доносят нас или хороший трафик начнем мы вот наверное про первую задачу тут многое говорить не буду большей частью мы этим обязаны платформе hype детей и опять же я вас здесь призываю посмотреть другие доклада на эту тему я вот вам расскажу про вторую задачу потому что она как нам кажется очень интересно какое вообще существует еще подход к фильтрации правил в linux на фильтре есть цепочки есть правила и все и вот эти списки списке линейные существует альтернативный подход когда вы на основе правил стройте префикс ный деревом как она строится допустим есть такой набор правил что вы делаете стройте дерева и причем его его высота будет зависеть только от количества атрибутов по которым вы фильтруете вот у нас смотрите протокол ip и порт это три атрибуты плюс сама действия у нас получилось дерево высотой 4 и не важно сколько вы в него добавляете новых правил не важно 234 10000 его высота от этого не увеличивается она только вширь будет разрастаться разрастаться это значит что вы всегда сможете найти нужный action за какое-то фиксированное время небольшой дисклеймер вот это вот дерево которое здесь нарисована в реальности такие деревья выглядят гораздо сложнее конечно это больше такая схематичная картинка в реальности там много состояния много переходов ну просто зачем это все сюда громоздить такие деревья реально применяются особенно в том случае когда вам нужно сделать просто простую фильтрацию например по five тапом по сетевой пятерки и вам этого достаточно в таком случае такие деревья отлично работают в каких-то простых сетевых железках они применяются почему такие замечательные структуры данных все-таки константное время фильтрации почему они не применяются в линуксе но вопрос дискуссионный мы нашли несколько возможных возможных причин причина номер один во первых префикс на и деревьев все-таки больше работают в том случае когда вас пакет должен попасть ровно под одно правило а затем его фильтрации на этом должна закончиться в linux как мы знаем это не так в линуксе у вас пакет попадаются цепочку при роутинг там попадают под правило потом например форварде он попадает под три правила потом в postrouting еще подобно правилам то есть налицо попадание пакеты под много правил префикс на деревья так не работают но по крайней мере из коробки второе гораздо более важное при вкусные деревья не работают с полями пакет в которые изменяются в процессе обработки в линуксе как мы знаем вы можете например использовать динод и тогда у вас достаточно пили порт поменяется превкусный деревьев таких случаях не строятся нельзя построить но и третье это медленное время реакции то есть мы привыкли что linux добавляют новые правила фильтрации он моментально практически во подхватывает начинает фильтровать трафик с префиксами деревья так не работает если у вас добавляется даже одно правило в и извольте перестроить и дерево целиком и это долго может быть если перефразировать то что я уже сказал можно сказать что префикс на и деревья работают только с терминальными правилами терминальные правило это правило которые прекращают обработка пакет в системе дроп accept в линуксе есть не терминальные правила которые просто что-то делают с пакетом его обработка продолжается что же мы сделали а мы на самом деле все что предлагаем это предлагаем способ трансляции правил нет фильтр в терминальные правила которые затем можно поместить в префикс на и дерево все что мы придумали по сути этот транслятор одних правил в других как он работает проще на примерах показать например вот такой набор правил мы видим что первое правило у нас не терминальное действие лог подразумевает что мы запланировали и переходим к следующему к следующему правильно вот на таких правилах префикс на дерево не построишь что мы делаем мы строим вот такую табличку вот такую табличку как мы устроим по сути все что мы делаем это берем и перебираем все возможные варианты путей прохождения пакетов системе давайте посмотрим первая строчка это вариант когда пакет попал под первое правило ipad 2 вторая строчка пакет попал под первое правило под третье правило еще у нас только два варианта осталось это пакет попал только от 2 пакет попал только под третьим и заметьте теперь у нас все действия стали терминальными в них появились терминальные действия акцепту дроп который прекращают обработку обработку пакета в системе вот такую табличку уже можно пустить на вход префиксом у дерева она построиться еще пример пример с цепочками когда вас несколько цепочек на самом деле для нас нет разницы 1 у вас цепочка много цепочек пользовательские цепочки базовые цепочки никакой разница для нас нету мы точно также перебираем все возможные rihanna здесь у нас пропускаются только пакеты которые попали в правилах природу тенге и в построю тенге все остальное дропа еца самом деле этот пример не был бы таким интересным если бы не одна деталь давайте добавим в табличку postrouting одно правило которое резко сделает ситуацию гораздо сложнее вот такое правило добавим будем фильтровать по номеру выходного интерфейса все так делали я думаю ни один раз в чем же здесь сложность сложность в том что мы заранее не знаем чему равно это поле поле а вот вот интерфейс становится известным только после маршрутизации а мы не то что должны построить наше дерево дом ешьте зации мы устроим вообще до того как пакет и пошли все попали в систему как мы можем построить дерево в котором мы даже не знаем чему равно поле поэтому долгое время мы делали вот так вот долгое время мы делали 2 фильтрации фильтрацию дома 6 зации фильтрации после маршрутизации у нас было два дерева и они работали в связке промежутке мы делали маршрутизацию еще один от ну такая схема в принципе работала ну тут очевидные минусы что надо делать 2 фильтрации место 1 это дольше а во-вторых у нас там падка плевались такие архитектурные маленькие проблемки и в конце концов из стало так многом что мы решили а нельзя ли взять вот эти все четыре квадратиком и объединить их как-нибудь в один очень большой квадратик чтобы наши префикс на и деревья делали за нас вообще всю работу и фильтрацию и маршрутизацию и над и звучит это довольно странно потому что я вам только что сказал что префикс на деревья не работают если у вас а вот тут интерфейс неизвестен но оказалось что если применить один трюк то все сразу работает итак давайте вот такой пример посмотрим сразу disclaimer вот правила которые выйти первое это не настоящие правила в настоящем nf3 бусы не может написать плюс 10 но мы его написали чтобы было попроще воспринимать это всем вас есть правила в котором она тоже не терминальная и в нем поле депорт устанавливается в зависимости от поля и спорт так во втором правиле у нас как раз используется поле д порт который мы в первом правиле поменяли получается что поле депорт становится вычисляем им она его значение становится известным только при прохождении пакета по фильтрации верно-верно как вот эту штуку можно преобразовать в терминальный правил на первый взгляд вроде она не не преобразовывается однако давайте попробуем так же как и в первом примере давайте переберём все пути прохождения пакетов системе первый путь прохождения то что пакет попал под первое правило пакет попал под второе правило давайте поподробней посмотрим что тут можно сделать вот мы обрабатываем первое второе правило мы смотрим первое правило смотрим видим что в нем в качестве action стоит установка поле депорт зависимости от поля и спорт что мы делаем мы берем и записываем эту информацию к себе в маленький такой блокнотик мы прям берем себе и пишем депорт равняется и спорт плюс 10 запомнили запомнили хорошо переходим ко второму правилу во втором правиле мы видим что фигурирует поле д порт и нато гистамина а у нас же до порт вроде бы менялся вроде бы мы что-то с ним делали до мы помним что мы с ним делали и как именно поэтому что мы можем сделать мы можем представить во втором правиле поле депорт как некоторую функцию от спорт и тогда что мы можем сделать мы можем сделать обратные преобразования мы можем из депорт 205 215 во втором правиле отнять 10 тоже там был плюс 10 отняли а потом вспоминаем что депорт поставлялся зависимости от спорт помним помним подставили обратно и теперь смотрите у нас правило в котором было вычисляемое поле депорт который заранее неизвестно превращается в обычное правило в котором фигурирует и спорт спорт заранее известен он не меняется в общем мы преобразовали правило в другой вид и теперь вот это правило мы берем пересекаем с первым потому что мы ищем путь прохождения пакетов 1 плюс 2 правила пересекаем получаем итоговое множество 195 200 спорт и это первая строчка которую мы запишем в нашу табличку это первая строчка все остальные строчки они получаются точно так же как в первом примере то есть 1 плюс 3 только второе только третьем пир вопрос как вот всю эту схему применить к маршрутизации мы же изначально потому что низации говорили вот так маршрутизацию можно переписать вот в таком виде диада подсеть и в качестве экшена сетку iv ethernet один похожи на маршрутизации похоже это оно и есть и теперь мы вот найдите 10 отличий от предыдущего примера нету отличий просто нас место вычисляемое поле депорт вычисляем им полем становится о iv поэтому второе правило мы берем и преобразовываем по точно такой же схеме получаем вот такое правило в котором у их теперь вообще не фигурирует мы зависим только от до дыр которые заранее известен в общем никакой магии не стал не стали мы сюда включать при пример с на там потому что он громоздкий но можно просто поверить на слово что она тоже работает просто там больше манипуляции происходит над тоже в эту схему укладывается и destination и source как и у любой технологии у нас есть определенные недостатки нас потребляется много памяти но это стандартная штуку когда что-то быстро работает обычно она потребляет память мы не можем достраивать дерево на каждое правило мы перестраиваем полностью и тут вот возникает проблема что это может быть очень долго постройка дерево может быть очень долгим процессом поэтому мы много времени уделяем оптимизации применение политики у нас складывается из двух частей нет фильтр прислал нам набор правил нам у во первых надо транслировать в терминальные это первый шаг а второе из терминальных правилам построить дерево второй шаг мы можем работать на два фронта можем во-первых уменьшать время трансляции во вторых уменьшить количество итоговых право чтобы дерево строился им дать пример посмотрим быстренько пример с первой оптимизация да пусть у вас есть такой набор правил вы могли заметить что каждый не терминальные правил у вас порождает две ветки пакет подошел подправила пакет не подошел под правилам две ветки и каждую ветку надо обработать чем больше вас не терминальных правил тем больше вот это дерево ветвится что мы можем сделать мы можем взять и просто удалить заранее невыполнимые ветки здесь что мы видим если пакет попал под первое правило то мы с вами мы люди понимаем что он точно попадет под второе не может быть ситуации что пакет попал по 1 правило но не попал под второе поэтому что мы делаем берём и выкидываем одну ветку из рассмотрения просто не рассматриваем сэкономили себе в половину времени еще оптимизация в процессе трансляции у вас могут появиться самые различные комбинации правил даже самые безумные и вот это одна из таких может получиться такое правило стоит new direction реплей oxette мы с вами понимаем что такого никогда не возникнет потому что если соединение new the direction всегда origin у такие правила мы просто берем и удаляем дерево получается покомпактнее вот казалось бы вроде бы очевидный пример но они очень сильно помогают если так у вас все это может работать минуты или даже часы то так мы чаще всего укладываемся в 2-4 секунды просто благодаря оптимизации да вот 2 4 секунды это вот среднее время применение политики у нас в системе стенд точно такое же железо такой же трафик такой же только мы взяли себе 8 я дерусь 14 6 я беру нас вообще отдыхают они занимаются чем-то другим например той же фильтры той же тем же обнаружение вторжений и получаем вот такой график он может такое довольно неправдоподобный но и надеюсь что после всех объяснений он не будет таким фантастическим мы видим что даже без фильтрации мы выдаем примерно в двадцать раз больше трафика и используем при этом меньше ягер почти в половину чем над фильтр но вот за левый график мы обе всем обязаны по сути dippy детей и тому что мы грамотно использовали его возможности вот в левом вот этом 31 вот 90 нашей заслуги относительно немного это hype детей и в его грамотное использование а вот дальше смотрите нет фильтру деградирует при увеличении количества правил а мы нет мы не деградируем это заслуга нашего подхода с прекрасными деревьями вот такой замечательный график поговорим буквально в пару слов про то как мы управляем нашим над фильтром и и вообще большая проблема потому что вы когда используйте hype детей у вас карно байпаса значит вы не можете использовать стандартные любимые утилиты для того чтобы всем управлять ей пирог не работает и 5 баллов но работает но он бесполезен контракт не работает тисе педант не работает ничего не работает все все плохо поэтому для нас это было проблемой типа как это все интегрировать мы взяли и преследовали утилиты которые уже использовались у нас у нас использовать 1 2 для управления линками и маршрутами nfc и бокс для фильтрации и контракт для управления соединениями они общались с ядром по механизму netlink и для нас это были очень хорошие новости потому что с нет линком очень просто работать давайте один слайд про netlink для тех кто может быть про него не в курсе netlink это способ взаимодействия между процессами чаще всего между утилитами ядром который приходит на смену стандартным системным вызовом если вы посмотрите исходники ай-петри bus вы увидите сплошные системные вызовы и как бы это не очень здорово сейчас все чаще используется найтлинн он в принципе всем по чуть чуть чуть лучше чем системные вызовы например в нетленки у вас обе стороны могут инициировать соединение в системных вызовов только приложений может что-то спрашивать ядро митинг есть широко вещания вызовах нету системных вызовов вы должны постоянно делать опрос о наступлении какого-то события что не произошло нет что не произошло нет ждем дальше окей в netlink соки так вам достаточно поставить recieve и он сработает когда действительно что-то произойдет никакого вопроса наконец асинхронность на клинки есть очереди сообщение поэтому там можно поставить recieve пойти заниматься своими делами в системных вызовов извольте дождаться пока операция закончится в общем что мы сделали мы взяли эти утилиты наложили на них очень небольшие патче прям очень это имеется ввиду 1020 строчек чтобы просто переадресовать все вызовы от ядра к нам это очень просто делается и теперь мы сами берем и обрабатываем все сообщения от этих утилит да мы их обрабатываем что-то отвечаем и для всех остальных компонентов вообще ничего не изменилось они как пользуются своими утилитами так они имею пользуются ничего не для них не изменилось да мы изменили действительно утилиты это теперь их нельзя просто взять скачать из репозитория но все-таки очень удобно очень удобно вот про интеграцию довольно вкратце если есть и дополнительные вопросы могу ответить в секции вопросов выводы картинка пройдемся во первых не бойтесь сами делать сетевую логику когда вы смотрите на сетевой стек linux вы видите там огромное количество кода и вы чаще всего испытываете добыть страха но неужели мне все это придется делать самому ну тут же столько всего столько логике а по факту получается что там очень много кода который либо legacy либо просто перекладывает из пустого в порожнее какая-то такая довольно бестолковая работа ее можно переписать самому и в общем то она будет работать мы это сделать силой одной команды за какой-то приемлемое время пожалуйста просто вот не бойтесь делать свою сетевую логику это можно сделать а главное вы получите быстрый код который только ваш и котором вы можете легко управлять во вторых это то про что я говорил весь доклад то что вы можете над фильтр правило преобразовывать в терминальные и затем их загружать префиксы in деревьям если примените вот ряд преобразований и наконец вы можете интегрировать ваше приложение в существую систему если возьмете утилиты на нет линки это важно и потребовал с не подойдет утилита на нетленки чуть-чуть их про почти и будете захватывать их команды вместо и драм и командный интерфейс получается сохраненным другие компоненты практически ничего не замечает и на этом мой доклад закончен спасибо за внимание могу ответить на вопросы нам спасибо киев собственно вопрос самый главный да вот вы говорили что наибольший ролей оптимизация правило что удаление заведомо невыполнимых правил и так далее и так далее это логика это какая-то семантика вы там используют ипотеку заведомо невыполнимых правилами или вы так как делается спасибо за вопрос вопрос хороший потому что оптимизация это действительно одна из главных это та боль такая серьезность которой мы столкнулись то что когда мы впервые увидели минуты или даже часы когда применяется политик это было абсолютно не применима для нас непозволительная роскошь но мы вот стали задумываться что тут можно сделать и по сути оптимизация нашей трансляции оно не поддается автоматизации нету библиотека для заранее возьму невозможных каких-то правил это действительно рутинная и очень сложная работа когда просто глазами по сути смотрите на набор правил смотрите что тут никогда не выполняется причем поначалу поначалу вас оптимизация хорошо работают и очень быстро вы быстро отсекаете кучу вариантов но затем когда уже все очевидно и отфильтровали начинают какие-то неочевидной комбинации и хохот тяжело находить поэтому даже сейчас даже сейчас мы сталкиваемся с политиками безопасности которую нас минуты компилируются и мы сейчас продолжаем оптимизировать компилятор чтобы он как-то лучше работал но в целом мы относительно боль до очень такая серьезная но много сил умные потратили ещё много потратим это разработчик это вот мы и делаем разработчики не администратор прошу прощения может такой еще вопрос вот по сути вы написали свой сад сетевой стек который осуществляет роутинг над преобразование пакетов и так далее они смотрели в сторону например а как оптимизировать работу сити мушкой с ее очередями как использовать там какой-то байт-код в нее что оптимизировать работу чего простить а ну там например натовские карточки умеют подгружать определенный байт код который потом будет фильтровать и и в принципе не надо будет даже часть пакета поднимать принимать ядром а потом до тоже очень хорошее замечание действительно действительно вы частично упомянул в докладе что есть такой подход и гриппе когда вы часть кода контролируйте в бпф загружаете в ядро она там что то делать какую-то логику и получается вроде и овцы сыты и овцы целы и волки сыты все замечательно вы не теряете сетевой стык но при этом часть логике ускоряется и да если этот подход экстраполировать дальше там еще есть сетевые адаптеры которые тоже позволяют загружать байт-код все верно но мы не ставили себе скажем так задачу отфильтровать какие-то простые правила то что все вот эти все такие механизмы они работают но у них очень пока что пока что довольно ограниченный логика и вы не можете какой то реально у нас нереальные сложные вещи там делать и мы вот сразу не ставили себе такой задачку что наса первых карточки во многих платформ и карточки обычные они там гигабита вы там вообще нет такой логике это первое во вторых даже если бы она там везде было мы бы просто хотели чтобы все наши линуксов ские правило просто чтобы они работали всегда с всегда с одинаковым временем но вообще это очень верное направление мысли до первое что вы думаете это давайте не будем изобретать велосипед а просто возьмем что несуществующие и большую часть пакетов будем фильтровать просто чем раньше тимуш желательно об ще в сетевой карточки кстати да вот если кому интересно просите вы карточки могу рассказать интересную историю vental vental карточках есть flow директор такая фича замечательная которая прекрасно должна прекрасно должна работать и она должна вам балансировать трафик еще в самой карточки причем не только по five the pale а по какой-то сложной логики что мы попытались ее использую и выяснилось что хорошо она смысле нехорошо предсказуемо предсказуемо она работает почему-то только если вы балансируете по five to pull чуть более сложную логику но мы не смогли вот правда мы пытались месяц наверное так и не смогли заставить работать эту фичу хотя она есть она разрекламировано мы месяц потратили так и не смогли нормально пристроить поэтому все эти фичи они хорошие но лягут ли они хорошо ваши приложения до смогут ли они работать прямо достаточно хорошо у нас тут не всегда продолжение либо строим сложную логику виде то мне потребуется где мы можем вернуть пакет еще как-то там ну не в цикле обработать одну какую-то сложную логику с переходами обратно медаль дали тот подход который вы рассказали это достаточно простое деревья да где попадет прошел по дереву и все папа графу фактически но по сути это тоже же очень простая логика то же самое которая который можно рисовать именно напрямую аппарат на сетевой карточки я не уверен что префикс ные деревья можно реализовать в сетевую в карточке просто потому что деревья занимают много много памяти очень хорошо но мы честно говоря вот у меня прям я не знаю как можно огромные деревья там сотни тысяч узлов поместить в память какой карточки чтобы она там работала что заказчики таки интересно узнать и опять же но даже даже если все это принять во внимание у нас просто куча платформ где нету прям крутых карточка они там простые гигабита вы там точно ничего такого нету но в целом интересно если это правда можете сделать добрый вечер спасибо за доклад скажите от не думали в сторону инкрементный достройки все-таки дерево в некоторых случаях это очевидно возможно некоторых чуть посложнее как когда-то это наверное невозможно вообще можно перестраивать иногда что в этом направлении что делалось или нет да спасибо тоже очень хорошее замечание я сказал что при вкусные деревья не поддерживает инкрементальные достройку и не совсем это так существуют такие префикс ные деревья которые позволяют добавлять правило настройками маленькими инкремента me здесь есть следующий нюанс даже если ваше дерево позволяет делать достройку то иногда если вам повезет туда строится одна маленькая веточка если вам повезет а вот если вам не повезет и правило какой-нибудь очень хитрые попал и не туда куда надо может перестроиться почти что все деле почти все ветки могут быть задеты этим влиянием в целом все таки это здорово такие деревья это замечательно однако скажу честно что для реализации своей штуки раз уж мы используем hype дикей да но грех было бы не воспользоваться его возможностями а у него в качестве одной из библиотек есть как раз префикс на деревья называется р т а к л если кому интересно пожалуйста префикс найди рей уже готовы из коробки оптимизированы мы не стали изобретать свое дерево согласен может быть мы смалодушничал и но решили использовать то что есть а dippy детей он не позволяет игра ментально достраивать он перестраивается заново если можно еще вот вернуться к той теме которые подняли это использование сетевых карт первый вопрос по поводу версии ядра на которые вы сидите потому что в прошлом году в мае по моему 31 светки за к мите ли там много интересных и что там по поводу именно обработки сокетов пакетов как бы то есть торгов loading там поддерживается за рукой и там много чего отойди его принесли наконец и второй вопрос как вы работаете с балансировкой прерываний оси вам первый вопрос вернемся к карточкам по поводу того что по поводу версии ядра мы используем для ядра 49 то есть оно свежее относительно ну почти что свежие совсем и действительно в нем есть огромное количество фич фич которые можно перенести на сетевой карточку правда все здорово но мы их тоже используем эти фичи многие дамы hype дикий он же не заставляет вас вообще всю логику визерс бы сделать он вам позволяет задействовать возможности карточек позволяет ту или иную фичу задействовать мы по возможности то что карточка поддерживает мы тоже используем кроме загрузки бпф этого кода в карточку этого мы правда не делаем потому что у нас просто арчик по моему таких реально не используется в платформу я не слышал по крайней мере и в общем мы были сильно лимитированы этим у нас не все платформы схватку с крутыми карточками это вот просто суммирует почему мы не пошли по этому пути второй вопрос по поводу балансировки прерываний нас нет прерываний дело в том что hype дикий он принудительно переводит код в такой вот так называем полинг режим режим постоянно вопроса а дело в том что прерывание сам все штуки очень медленные когда у вас десятки миллионов пакета в секунду представьте обработку 10 десятков миллионов прерываний это плохо очень плохо с точки зрения производительности и и просто их отключает и начиная от wilder у опрашивать чуть пришло очень пришло вот так вот он делает и у вас вот эти ядра которые используются в детей они всегда загружены под сто процентов даже если нагрузки нет вообще это кстати не за баг фичу в принципе наверное не очень здорово но что есть я зато быстро работает прерывание вообще нету это понятно как бы маленького точнее вы используете все таки пул или юбку или там сейчас еще там какой-то третий вариант у него появился вроде ни разу не он как делает он загружает в в ядро свой собственный драйвер называется полно драйвер или pmd это свой собственный rover он вообще заменяет полностью все что может сделать linux и пол это linux of ski опросу наступления того или иного события но с де и по вообще никогда не сработает он не увидит ни одного события то что пакеты просто не попадают в самом linux вот этот драйвер он на очень низком уровне там просто максимально низко забирает все пакеты из карточки и прямо напрямую к ван дер space выплевывает вообще за рукой полнейший и linux вообще не в курсе что там хоть какие-то пакеты пришли все вся ответственность ложится только на вас и это да это вот тоже одна из проблем таких приемов страшно страшно египет никее взять и использовать в какой-то большой системе но может префикс на и деревья сами по себе это понятно просто структура данных известно их огромное количество видов но мы использовали реализацию не то что ну там столько оптимизацию уже сделано там и векторной инструкции уже сделаны и попалить все оптимизирована но грех было не воспользоваться да мы его использовать хотя там есть нюансы как обычно не все там замечательно и еще один вопрос в общем-то известно что вычитанием направьте с деревьев неплохо раз параллели ваются не думали раз параллелей запустить использовать там скажем графику для вычисления и так далее чтобы ускориться еще до мы именно вот про это ускорение мы не думали у нас все ускорение происходит у нас ну естественно нас много пар от потоков да много потоков просто каждый поток он свои пакеты обрабатывает мы масштабируем синие в дереве мы и масштабируемся по данным в принципе по пакетам а дерево они используют одно и то же она шарик и получается выигрыш все равно есть но не в том этапе как вы сказали что это сложнее просто намного гораздо проще запустить н лидер и каждый будет свои пакеты пропускать через одно и то же дерево чем само дерево пытаться распараллелить здравствуйте спасибо за доклад хотел уточнить ада the plain полностью снова описана у вас и или брали какую-то open source реализацию и дописывали соответственно необходимый функционал вот для фильтрации спасибо тоже за вопрос значит do the plain у нас самописный но с использованием возможностей hype детей вообще не больше заточен под си под язык си но мы взяли и сделали 8 + + правда да the plain код у нас почти что хищный почти и дам его написали сами кстати очень маленький вот вы абсолютно сколько do the plain маленький прям несколько федоров все много много логики у нас вынесено в контру playing on the plain это для управления всем этим процессом если вы сделаете большой do the plain много кода много переходов медленно работает до the plain должен быть вот чему меньше тем лучше контра plain у нас вот огромный и там происходит построение дерева там происходит netlink обработка сообщений ее мы тоже писали сами но могу рассказать лайфхак по поводу над ленка если вдруг тот заинтересовался над рынком если вы захотите обрабатывать сообщение nightwing и вам будет лень писать свою библиотеку для этого а сказать вам будет лень но вы не найдете такой вот готовое решение в интернете типа вот пожалуйста легкой обработка все что только есть мы что делать мы взяли nfc и блс утилиту nf3 был выкинул из него функцию main получили либо н.ф. ты был с как мы и обозвали и в ней все функции уже реализованы пожалуйста дергайте будет вам счастье мы вот над ленка очень быстро сделали другие проблему всегда возникает в этом в контру плане чем все наши все наши мы используем возможности не или банов тейлз все остальные наши еще можно то есть вас реализован все стоите словам там и поддержка всех сетевых функций в do to play не ну то есть не знаю поддержкой генов impala ss всего-всего или только какой-то ограниченный и нужный вам функционал тоже спасибо мы вообще не стали это выносить в доклад потому что в горячие по времени было но вопрос интересный получается да получается если вы выкидываете сетевой стык вам в всю работу над делать самостоятельно и тисе пи стек пишите и vpn пишите и вообще пишите все что только хотите да сами но никто так делать не будет это прям слишком сложный вообще зачем на самом деле мы сделали проще у нас у dippy детей ну мы присвоили инструмент использованы уде питкэрн тоже есть это инструмент взаимодействие с ядром это все-таки если вы какие-то пакеты хотите пропустить через ядро вот если все-таки вам вот хочется the hype дикий позволит вам так сделать и это именно то что мы сделали мы трафик который требует дополнительной обработки и пьян на самом деле мы еще не успели скомпилировать свою свой проект чтобы и ле пен работал исав работу все это у нас пока вместе пока не совсем функционирует не успели еще сделать но суть в том что пакеты которые нам нужно пропустить через дополнительную обработку которая у нас еще не реализовано мы за руль его им в ядро и они обрабатываются как обычные пакеты и если сеть выставках видит и можно их обрабатывать пожалуйста как у как обычно мы сделали это через tap интерфейс and tap интерфейс и помещаем в них определенные пакеты глав главное главное главное чтобы таких пакетов было немного если вы начнете много пакетов туда заруливает то вы будете делать двойную работу сами обработали пакеты а потом еще linux их обработку это медленно поэтому нам все хорошо у нас много трафика транзитного мало трафика заворачивается на саму железку много транзитного и у нас медленного трафика и очень немного получается для нас такая схема работает но оно не всегда применимы то есть если много да да действительно в принципе в принципе действительно так потому что если мы начнем много трафик прокидывать в ядро она загнется да да мы сейчас думаем скорее всего мы это решим как мы в самом ядре пропишем определенные правила дополнительными которые будут ограничивать по могут резать просто лишний трафик чтобы ядро у нас не все таки переполняло хотя действительно это проблема то есть мы транзитный трафик реально хорошо обрабатываем а трафик который к нам трафик который к нам не очень хорошо это для дальнейших исследований спасибо за доклад на вот еще один такой вопрос у нас получается 8 едет потребляется на полинг типе диким до 6 а если вы на эти 6 на месте например 3d с которым тоже нужна пакеты да значит если мы навешиваем какую-то логику на оставшись театр во-первых интересный эффект сам по себе следующий что даже если у вас ядро ничего не делает если ядро ничего не делать если она что-то делает это большая разница для других ядер то есть понятно что начинает скита кэш промахи начинают какие-то дополнительно пересылки данных которые вы просто не можете контролировать и вот мы столкнулись с тем что даже если вы просто запускаете хоть что-то практически но вот этих пустующих ядрах дамы проседаем но не сильно да там есть и падение но не сильно другие ядра все-таки воздействует на наши ядра который погиб детей даже несмотря на то что мы их заизолировали мы говорим linux вот и на эти ядра ничего не пихай они только наши несмотря на это все равно происходит влияние по поводу если запустить а и d с dom и пропускать через него много трафика до у нас это сейчас будет работать медленно но у нас есть планы в дальнейшем всю логику постепенно спустить к нам чтобы мы смогли общаться icon не через tap интерфейс и которые медленные а по другим механизм будет работать лучше спасибо , то еще по поводу вот этого замедления если вы средством не укажет соответственно вы укажете вы использовать только эти шесть ядер на одном сокете другой socket оставить простаивающие соответственно все пустые я драму как построить без работы соответственно другой сок это возможно она исчезнет 1 влияние или вы это вы это программе нет по поводу много соки данных систем у нас была платформа с двумя процессорами и оказалось что это очень капризная штука очень очень капризное там ускорение происходит только в каких-то очень определенных кейсах только при определенном packet flow когда вот только нужны через нужные порты все проходит если у вас начинаются но мы пересылки то есть из одного процессора начинается пересылка в другой процессор это плохо очень очень плохо все сразу же рушиться поэтому мы стратегическим решением решили что у нас не будет многопроцессорных систем и если вы говорите про быстро обработку то я всем это рекомендую просто не использовать много процессорами системы слишком много боли там но в общем да поэтому просто не рассматривать такой вариант не исследовали"
}