{
  "video_id": "0vNiooyjrhU",
  "channel": "HighLoadChannel",
  "title": "В поисках идеальной сети, или зачем нужна еще одна SDN / Андрей Королев (Ионика)",
  "views": 439,
  "duration": 2197,
  "published": "2017-04-07T15:21:13-07:00",
  "text": "ну как я и обещал все тысячи доклад про sdn от андрея королёва из компании forbes.ru от предыдущего докладывает отличается тем что это уже работающая технология который можно пробовать использовать вот поприветствуем добрый день а меня слышно хорошо да окей сейчас слышно хорошо соответственно или опять пропал так спасибо за внимание сегодня я хочу поговорить о практической стороне применение sdn полноценный sdn собственно в облаке telekom провайдера сегодня какие плюсы это несет и почему мы не хотели остаться на обычном оборудование ну и собственно о проблемах которые нас привели к переходу на полностью программную сеть ну во-первых любой облачный оператор сталкивается с необходимостью постоянно при конфигурировать switch последней мили будь то виртуальной свечку-то физически свечи тоже проблема касается крупных till i come off всегда необходимо постоянно при конфигурировать последний метр сетевой топологии создавать планы изменять так скоб у какого-то сегмента за на там и так далее в общем то здесь приведены основные проблемы с которыми облачный оператор может столкнуться ну непосредственно кроме при конфигурации мы сталкиваемся с проблемой масштабирование то есть когда мы поставили в 10 раз больше раздельных сетевых сущностей на в рамках одно и то же но ты мы хотим сохранить то же самое легкость перри конфигурация которая у нас была ранее и также мы хотим чтобы большие сегменты can фигурировали большой сегмент стиком фигурировали в максимально легко то есть чтобы мы могли взять стойку и сконфигурировать все виртуальные машины в ней по отдельности определенным образом и это происходило бы также легко как если мы это делали с десятком стоек безусловно люба любая автоматизация в данном случае несет какое-то время разработки в данном случае это может быть на сегодняшний день чуть ли не развертывание конфигурации по пятам виртуальном свечи при определенных условиях или вы можете использовать какой-то вендора специфический механизм для и той же задачи они суть если вы решите выбрать например openstack вам необходимо будет сопрягать бизнес-логику с механизмы меня тоже openstack а потому что как правило она не соотносится однозначным образом с потребностями конечного оператор эксплуатанта ну и в общем-то естественно мы желаем это все максимально удешевить к нам нужны дешевые дешевая программной обвязка ввести где то возможна бесплатная виртуализация бесплатная сеть и бесплатное хранилище безусловно всего этого в современном мире можно достичь взяв open source компоненты и собрав их в единое целое собственно как на поступили если вернуться к проблемы проблеме сетевого оборудования то здесь есть несколько причин по которым эти проблемы превращаются в большую из существенного боль при работе на масштабе то есть когда у вас объемы сетевого оборудования измеряются десятками и сотнями единиц в общем пока вы сохраняете демок гомогенность сети то есть у вас используется один и тот же бендер с одной и той же имплементации протоколу все более-менее хорошо вы можете написать некую скриптовую обвязку которую будет централизовано изменить конфигурацию и можно надеяться что в общем если у вас не будет каких-то серьезных проблем помимо этого вы достигнете своей задачи собственно быстро управлять всеми элементами по логистике ну первая проблема с которой сталкиваются пользователи всех знаменитых и сетевых производителей даже если править 2 топах это не реализованная функция то есть он цене то она будет следующей прошивке если вы хотите получить эту функцию вам придется поставить эту прошивку и собрать все баги которые в ней есть и при этом фидбэк весьма затруднен то есть вы не можете сказать чтобы вам вставили персонально вот эту функцию в текущую прошивку потому что вы так хотите это невозможно это не работает это же относится к исправлению багов ну и опять же заключающий момент если у вас по какой-то причине сетевое оборудование разнородная от разных вендоров то у них помимо разных синтаксиса существует разная логика конфигурации в общем случае пока вы делаете какие-то очень простые вещи она более-менее совпадает то есть вы просто заменяете одно слово на другое и логика скриптах отображается довольно однозначно а когда у вас не происходит усложнение налоги и усложнения конфигурации это превращается особого рода а потому что вам требуется поддерживает множество различных типов логик склеивать или наоборот разводить различные атомарные операции таким образом чтобы у вас конфигурация отвечали тому представлению которое находится над этим оркестровки сети если у вас есть скажем так иди ни одно место из которого она конфигурируется в общем случае но эволюция конфигурация последнего сегмента происходило в последние годы следующим образом все что касается протоколов непосредственного управления трафиком тут как бы ну нареканий наверное нет они существуют давно очень хорошо отложены и в общем-то мало кто может пожаловаться на то что например обиды бей плохо выполняют свою задачу или успев плохо выполняет задачу управление трафиком внутри периметра сети проблема начинается в том случае когда вы хотите сопрячь логику более высокого уровня с логикой топологии сетевых сегментов здесь происходит разделение возможности то есть все что находится на уровне l2 и ниже до последних времён в частности до 2007 года когда появилась стандарта кинслоу хотя на самом деле попытки сделать что-то похожее были но происходили до этого примерно в течение десяти лет вы не имели документ возможности даже теоретически управлять всем сетевом стеком который отвечает за маршрутизацию из но факт фактически можно сказать что open flow является механизмом forwarding и изменения трафика это не очень стандартное определение но на деле он делает действительно две вещи он трафик присылает и изменяет какие-то хитрые ну или в случае дропа понятно что это пересылка в никуда то есть можно сместив это подобного определения попытки свести конфигурацию устройств и их сетевые топологии единое целое происходили ну в несколько этапов первое первом я решил выделить объединение свечей стек то есть когда при конфигурации одного сетевого устройства могла повлиять сразу на два сетевых устройствах это стеки равны и свечи пыли в начале нулевых ну и на самом деле это не несёт никакой практической пользы в текущей беседе следующий шаг это возможность эффективного скальпирования конфигурации через по пятам подобные механизмы появления таких продуктов или возможностей относится к середине нулевых примерно и сейчас этот подход активно развивается используется в общем то никаких проблем с этим нет и джон непер в 2011 году сделал замечательную штуку за вами qfabric когда вы могли централизовано управлять всей топологией группы железок соединенных определенным образом это конечно не очень хорошо не очень удобно но это лучшее что на тот момент сетевые производите могли предложить для продакшена собственно сдм позволяет именно softwear напыляемой сеть позволяет вам делать многие вещи но почему-то никто не хочет вернее не стремится переходить на собственную сеть и тому есть ряд причин первая причина это кажущаяся сложность собственно полной регистрации трафика следует разделять полную оркестрацию трафика и виртуализация трафика случае виртуализация трафика вы используете скажем так обычный vpn он виртуализировать соединение между двумя точками или вы используете что-то более сложное например время nsx который виртуализировать топология но при этом в с транспортный слой остается классическим то есть в транспортном слой используются классические протоколы вы никуда от этого не ушли вопросу могли тому слою который показывается виртуальным машинам выглядеть так как хотят этого конечные пользователи также 2 страшная сказка про про сдм что он не очень производителем потому что вам следует контролировать каждый каждый сидит каждое новое соединение и работать в общем по методу реактивного контроллера когда к вам прилетает какое-то правило на обработку и вы только после того как она прилетела в контроллер можете с ним что то сделать и отдайте ответ свечу в общем случае это не так я скажу об этом чуть позже и эта схема она в общем годится только для лаборатории или для каких-нибудь показав на практике она очень хорошо себя показывает также есть проблема достаточно реально но на самом деле это лечится тестированием тщательным тестированием пинг смерти то есть какой-либо пакет которая одновременно вызывает ошибку обработки чего-то в контроллере контроллер падает трафик переход перестает ходить при этом если контроллер обслуживал достаточно большой сегмент сети у вас исчезла связанность в этом сегменте сети и за единственного пакет на деле этого опять же очень сложно добиться если заниматься тестированием и в общем то это вряд ли когда-либо был и препятствием для внедрения также ну вам скорее всего кажется что переписывать сетевой стык практически самого первого уровня это достаточно сложная задача на самом деле это все оборачивается достаточно простые абстракции вы можете как это упомянуто в предыдущем докладе делать абстракции какого-то уровня там два домен группа маршрутов и что-то иное более высокого уровня более того вы можете использовать какие-то произвольные поля для обработки трафика и это проблема не будет ну как правило про программные сети при их обсуждению выскакивает множество кредита фунтов который не очень имеет отношения к реальности и я хочу просто заострить внимание на том что на самом деле проблема там практически нет собственно как происходит виртуализация трафика первый самый базовый вариант это виртуализация какого-то небольшого кусочка это может быть vpn это может быть виртуальный switch внутри сервера это может быть и by the bliss который просто заменяет один адрес на другой фактически это самые базовые вещи которые не имеют отношения к программно определенным систем тем не менее иногда можно найти работаю в которых подобный подход называется виртуализации сетевых функций второй второй вариант наиболее распространенный и пожалуй единственный существующий в маслом доступен на сегодняшний день это виртуализация топологии для вышестоящего уровня когда вы виртуализировать и отношении конечных точек обычно в в качестве конечных точек уступает виртуале машины друг с другом при этом как я сказал ранее транспорт остается классическим вы не ушли от тех проблем которые приносят собой необходимость перри конфигурации нижнего слоя вы просто сделали перри конфигурацию более удобные для определенного типа клиентов хотя надо признать этот подход достаточно просто в зависимости от выбранного been drawn хорошо не очень хорошо масштабируется и этой да это единственно коммерческие доступное предложение на рынке на данный момент и наконец мы подходим к виртуализации всего и вся то есть это виртуализация транспортного слоя помимо виртуализации непосредственно ваши лежащие топологии да все элементы сети управляются единственным протоколом в данном случае это прям шоу и даже гугл не решил искать чего-то слова использовал open слова в по стране свои сети бифа на протяжении последних нескольких лет ну собственно реальность лепим слову такого что практически кроме google и его действительно никто нигде не применяет по множеству причин это достаточно большой порог входа это достаточно сложная базовая логика ну относительно сложная то есть это несколько человека месяцев разработки при врачом вас начнет нормально работает достаточно не сложная группа действие и вышестоящего уровня то есть логика которая отображается на какие-то правила в виртуальном свече и в общем-то это многих останавливает наиболее распространенной схемы является обычная пар активная схема надеюсь что нижнюю часть вина хорошо когда группа машина участвующих в виртуальный класс при этом может быть openstack это может быть плавать так это может быть практически что угодно в том числе это можно могут быть обычной машинке которые управляются обычным у принц слову контроллером с простейшей логика или орленко свеча в данном случае мы имеем ряд проблем связанных с этим подходом хотя он является наиболее классическим вы его может встретить в практически любой работе про sdn проблема заключается в следующем действительно на каждый новый пакет на каждый новый five the pale вам приходится спрашивать контроллер что с этим five the pole dance вы можете изменить русификацию но по умолчанию это действительно five the pale для opengl плюс и здесь таковы чтобы контролируется действительно все действительно хорошо но на этом они заканчиваются начинаются проблемы с производительностью поскольку в обычном физическом свече о матрице в этом случае может спросить контур plain за какие-то долли микросекунд там есть пища яшина и она очень быстро спросит control plain концов был очень быстро и ответит в данном случае у вас вместо пещере совершенно используется тихи без соединения которые в общем то в тысячи десятки тысяч раз медленней поэтому прежде чем первый пакет пробежать дальше пройдет достаточно большое время для кого-то это может быть критичным и и при большом префикс rate то есть при большом при большой частоте появления новых неизвестных свече five там пол у вас эта схема начнет ну в общем очень сильно мучить контролем и на практике это все ограничивается величины величин порядка трех пяти тысяч для современного железа для современного многопоточного контроллера типа floodlight ты для о пинге свеча если вы захотите построить подобную схему и себе production что можно использовать мы использовали его в течение полугода но в итоге связи с ростом с плотностью виртуальных но ты ее просто перестало хватать следующий вариант собственно если основные проблемы является задержкой и задержка между общением control plain и дата планету почему бы нам ondraw play мне унести в switch то есть не запрограммировать заранее все правила отфильтровав спав отфильтровав трафика из ненужных почти сделав но нужны нужны правила переписываю щи и маршруты и так далее мы берем и уносим всю ту логику которая у нас была в контроллере а до этого проактивное правило виртуального свеча программируемого всем тем что у нас было какие плюсы это дает безусловно это быстро вместо и happy у нас появилась соединение фактически через memory лишь еще что-то в зависимости от используемого виртуального свеча я зависимости от имплементации в общения между hyperspace i do the plain в данном случае do the plain внутри самой самой виртуальный ноды прошу прощения внутри гипервизора на котором располагается switch это ядерная модуль который спрашивает weather ps что мне делать с пакетом это быстрее do the plain или так называемый дтп с как правило это ядерный модуль имеет у себя кэш правил кэш по умолчанию синхронизирован хизер мэйсон то есть нам не надо задумываться о том что там осталось какое-то правило нам следует следить за двумя вещами первое что у нас правило актуализированы и второе что мы не нарушили модель при и ну логическую модель при их добавлении или удалении иными словами если у вас есть какая-то модель построение сети с on this poll сумме с for деньгами с чем-то ещё вот он словами мы вы можете использовать n-слово свищи как роутер он будет прекрасно работать как роутер единственно проблема конечно с состоянием пакетов вы не всегда и не при всех условиях сможете отфильтровать стоит фолз соединения тогда эта схема годится но собственно мы здесь получили их качественному полноценную виртуализацию последнего метра отсутствия виртуализации в остальных кусках сети и в том числе в свече который коммутирует наши не провизор и это большая проблема мы здесь сделали себя хорошо только для вычислительных not что же нам надо сделать нам естественно можно виртуализировать вещи периметра сети как это в нашем случае сделаны я сейчас попробую рассказать достаточно вкратце получится как известно вообще forwarding пакетов внутри периметра сети совершенно необязательно делать на основе l3 как это принято вы можете сделать на основе это определенных меток то есть для вас главное будет то чтобы промежуточное сетевое оборудование эти метки распознавала и имела основание пересылать их в определенный порт например вы можете обернуть пакеты в определенные mac-адреса поставить на свечи статическую таблицу соответствия эти mac-адресом и таким образом сделать себе мак-кей forwarding когда пакеты от любой промежуточные ноты до периметра сети будут добегать не изменяя сволота т.л. не изменяй каких-то иных полей в этом плюс виртуализации вы можете сделать это быстро достаточно легко то есть практически любое legacy сетевое оборудование от поддерживает и при этом если вы эти свечи хоть как-то мониторить и так вы сможете заложить также на катастрофу устойчивость рисуешь горел следовательно используем следовательно нужно использовать иной метку для того чтобы пакет шел иным путем то есть вы переизобретать и внутренний механизм маршрутизации трафика чем это лучше его не перри за британии тем что у вас все сетевой сущности управляются ровно 1 одним элементом логике достаточно небольшим который в общем то может быть завязаны altri может быть завязаны льва в нашем случае завязаны 2 какие плюсы это несет мы берем представьте что у вас есть внутренняя сеть на распев и внешний мир он использует bdb спрашивается если мы все умеем описывать одной и той же логикой зачем на мой спев давайте его заменим как это можно сделать можно написать робот рефлектор который будет создавать правила однозначным образом то есть для определенного age сервера он будет приготавливать пакет на каждой из конечных мног с определенным маршрутам то есть никто больше про маршрут из промежуточных сущностей не знает они просто пересылают его из порта в порт ином случае вы получаете максимальную отказоустойчивость роутинга то есть у вас нет права тир баксов вас нет каких-то централизованных точек обработки трафика каждая вычислительная но до является по сути конечной точкой и дистрибьюции трафика и дживы это сервер которые общаются с внешним миром и стоят на периметре вашей сети аниме и шут критической роли по сути они могут быть обычным мостом вы можете переписывать айпи адреса таким образом что вам не потребуется даже их там маршрутизировать на этих конечных точках это достаточно легко достаточно просто с использованием современных протоколов то есть вы можете и библиотек вы можете взять готовую библиотеку для open слова начиная блайт и заканчивая там счетам масс оно верные десятки просто их не хочу перечислять там что не знаю какие хорошие какие нету туда и однозначно хороший и вы можете взять такую библиотеку и в общем за достаточно короткое время создать рабочую схему для полного программного управления трафиком в своей сети на и я еще раз пройдусь по всем пунктам которые гарантируем место делать как я сказал ранее реактивной управления трафиком возможно но вы упираетесь в префикс рейд вы упираетесь задержку передачи первого пакета в соединении это не очень удобно не очень масштабируема хотя по умолчанию этот момент он вполне себе вполне себе имеет право на жить поскольку вы можете не создавать роутера не создавать роутер боксы этого не стоит делать вы таким образом размазывайте точку отказа централизация обработки трафиком плохая с точки зрения нескольких независимых вещей помимо отказа а вы не можете поймем возможностей и и отказа и и соответственно вылета сегменты необходимость держать замену такого же роутер бокса вы не можете очень эффективно очень быстро на сегодняшний момент на x86 сути жировать пакета то есть при использовании определенных подходов в определенных технологий например когда lookup таблица находится в 2 кэша процессора или ее скажем так наиболее часто используемая префиксы находятся два кэше процессора если все не помещается вы можете добиться скорость пул капов в районе нескольких десятков миллионов секунду но опять же в этом случае вам придется держать отдельный роутер бокс который будет заниматься непосредственно пересылки пакетов в случае когда вы распределяете маршрутизацию по компьютерам на каждой компьютере вы потратите немножко процесса много времени на то чтобы собственно пакет каким-то образом обработать в ядерном дтп с и переслать через сетевую карту это не очень хороший подход потому что там все равно настоящий много копирований одно и того же верила на память и это оптимизируется разными способами можно использовать zero копи фреймворк можно лука производить все одном месте маршрутизацию в другом имеет 2 независимых моделях возможно это будет проще но на самом деле практика показывает что этого подхода хватает не стоит опять же как это упоминается но обычно используется один контроллер для множества свечей лучше использовать контроллер и один к одному и проверять соответствие их логике друг другу то есть при сходных начальных состояниях и исходном сходных изменениях которые были произведены для этих контроллеров они должны выдавать одинаково логику всмысле правил и это тестируется есть замечательный фреймворк найс который рекомендую использовать хотя он на самом деле довольно клинический и 1 выпуск был чуть ли не 4 года назад он проверяет в общем-то соответствие логике провел то и вышестоящий логике который у вас должна быть вы при этом избавитесь от богов виртуальном свечи от баку в своем контроллере и получите формальное соответствие модели маршрутизации тому что у вас должно быть выше ну и вкратце по итогам более чем трех летней эксплуатации всего этого что можно было бы назвать программные сетью и то эволюции которая показала ранее то есть у нас действительно была такая эволюция сначала у нас была классическая схема потом мы перешли на практике правила и потом мы наконец виртуализировать и вообще все мы действительно перри забрели и т.п. мы действительно от отказались от каких-либо механизмов внутренней пересылки трафик помимо собственно но это как можно видеть наверное несет некоторые плюсы мы управляем всем из единой точки за маршрутизации отвечать единым кусок достаточно не больше очень легко искать проблема сравнительно с тем что могло было быть при использовании закрытых январских решений и мы можем произвольным образом это кастомизировать под себя тоже очень хорошо потому что мы можем выкатить фичу новую которую требует крупный пользователь за буквально и не эту в современном мире это достаточно ценно если особенно если вы используете программные сети ну и хотелось бы сказать что в общем-то мы полностью основываемся на open source компонентах сейчас сегодня и два года назад можно собрать программное сеть которая состоит в общем-то целиком из открытых кусков ничего не дописывая просто открыть в боге и вы получите замечательную работающую затворную сеть причем это будет никакой и и подобие но если говорить о каком-нибудь кантрелле где намешано жуткая каша из любящие оборудования и того что пытается протолкнуть производить это полностью программная сеть без каких-либо побочных эффектов и вы виртуализировать и в этом случае действительно все ну в общем то наверное это все что я хотел сказать надеюсь получилось достаточно понятно я бы хотел послушать ваши вопросы если они будут спасибо вопросы а здрасте спасибо за доклад я бы хотел задать два вопроса первые это связано с северным опять контроллера то есть вы так как известно что нету стандартов такого интерфейса не могли лучше чуть подробнее объяснить как вы его реализовывали понимает оба floodlight и второе вы сказали что но это очень плохо когда падает контроллер и поэтому вся сегмент остается без коммутации и маршрутизации так что вы предлагаете своей системе то есть как вы обеспечиваете очень ну вообще говоря сначала у нас я начну со второго вопроса сначала мы использовали просто backup контроллер и когда 1 контролем по причинам падал свечи переключался на backup но то есть встроенный механизм а если говорить об окинаве свеча по умолчанию предполагает что мы его используем сейчас там в течение уже больше более чем года мы не сталкиваемся с этой проблемой что контроллер как-то тихо падает то есть мы всегда это видим и успел вам перезапустить до того момента когда виртуальный switch выбросит все правила из себя и перестанет можете веровать трафик на счет северного моста там сделано действительно имплементация у каждого своя большую часть логике несет сам контроллер мы в него вбиваем практически в силу которая там существует и все сущности которые общаются с ним снаружи они имеют команда вида сделай это сделай это в максимально упрощенной форме то есть вся логика работы с концентрированными на в контроллере и ну то есть мы вынесли наружу минимальный набор действий но на уровне сделай мне такой ты набор провел но он набор правил номер пять для соответствующего бортовом вот сразу делает ну здесь я не могу что-то порекомендовать возможно ли кого-то будут удобном усложнения логики в наш bound to вопрос желаний вопрос конкретных реализаций спасибо добрый день вопрос у меня следующий там был соответственно слайд с распределенным full view и вопрос в том как вы подключается на пленке и как расходятся разливаются уже роботы дальше ну что вы происходит с большим количеством moblin cove и какой логике вообще достаточно простая мы агрегирует в его от всех а блинков вырабатываем опять же некий общий объем и отсылаем его виде какого-то промежуточного на набора через промежуточную набор функций то есть по сути это пара подсеть индекс хлоп как можно понять и рассылаем это честно в bound контроллер мой они формируют набор правил соответственно если что-то падает или что-то ведёт себя не так топология сама перестраиваться предки но я это упомянул видимо недостаточно явно но фактически the road рефлектор только на другой стороне вместо или три маршрутизации мы получаем набор правил спасибо"
}