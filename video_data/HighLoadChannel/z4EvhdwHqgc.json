{
  "video_id": "z4EvhdwHqgc",
  "channel": "HighLoadChannel",
  "title": "Про UUID v.7 / Андрей Бородин (Yandex Cloud)",
  "views": 1075,
  "duration": 2940,
  "published": "2025-01-17T02:22:36-08:00",
  "text": "Всем привет Я Андрей и сегодня мы говорим про ID немножко расскажу про себя я пилю пог для Яндекса Я инженер немножко учёный но скорее всё-таки инженер и доклад У нас тоже будет Инженерный Я в Яндексе пилю и не он вот эти ребята Нам тоже помогает Но вообще вот эти вот ребята вот мы вместе разрабатываем в общем всё что попадётся и по роду своей деятельности мы сталкиваемся с системами которые созданы давно которые довольно сложные изза этого приходится погружаться довольно глубоко из-за этого часто наши доклады становятся научными но к счастью Сегодня у меня не научный доклад Сегодня у меня Инженерный доклад в котором мы рассказываем Почему идентификация работает вот так и почему идентификацией вот так надо пользоваться Давайте начнём с так сказать базы основы вот идентификация - это не что-то изобретённые инженерами информационных систем идентификация присутствует в любой области знания как Краеугольный проблема Ну например у математиков из возможности идентифицировать точку следует так называемый парадо Парадокс банаха Тарского то что Если разделить сферу на э-э части и из этих кусочков сферы можно будет склеить две сферы такой же площади Как видим из возможности в принципе идентификации уже мы получаем парадоксальные результаты э ну если пойти ближе к программной инженерии то у нас есть такое вот выражение филато о том что в computer Science У нас две проблемы инвалидация кэша идентификация собственно наименование вещей и ошибки на единицу то есть инженеры информационных систем с этой проблемой идентификации столкнулись с самого начала и это в целом нормально вся электросвязь вся теория информации она тоже про идентификацию про то как Мы битами представляем знания мысли информацию Ну поехали а я человек про постгрес и когда меня спрашивают какой первичный ключ использовать как идентифицировать сущности в базе данных Я говорю Ну вот там на первой странице к любой книжке написано что Используйте sequence sequence - это что-то что генерирует последовательные идентификаторы которые отлично Работают этол стандарт короче Инженерная практика которую всегда нужно использовать Единственное что когда про это говорят на лоде надо сказать что Используйте сикн для бинта Если вы делаете базу в которой 4 млрд сущностей должно быть достаточно скорее всего не достаточно множество консультантов в мире зарабатывают огромные деньги на том что делают миграции с четырёх интов идентификатора на на во байтов идентификатора Ну ладно у сикса есть другие практичные проблемы например sequence имеет состояние которое нужно логировать sequence отказоустойчивые число то после Крэша вы не выдано это означает что получение новых чисел в сиквенс требует от вас писать на диск внезапно сикн не Если вы не заметили транзакцию сиквенс всё равно был выдан число выданное сикн всегда мотает вперёд из этого сиквенс люди очень хотят заложи на то что в сиквенс Нет гэпов нету промежуток промежутков То есть вы можете Если бы не было промежутков Вы могли бы создавать идентификатор и всегда быстро за константу находить предыдущую версию Нет это не работает Это в принципе не существующая практика существующая некорректная практика нереплицируемый в части логической репликации сикн пог до сих пор не умеют передавать на логические сабскрайберы Но самое главное что сиквенс локальный А раз вы на лоде вы делаете геора спредер системы значит локальный идентификатор для вас уже не подходит в распределённой системе человечество изобрел энтропию человечество изоб Случайность вот тут у меня фрагмент книжки кото называется Million Random digits э книжку до сих пор можно купить К сожалению только на амазоне э там миллион случайных чисел но почему-то в каждом углу страницы присутствует неслучайное Число Вот и вообще были такие отзывы что на Неплохо бы э книжку Ну содержание во-первых к ней во-вторых отсортировать числа по возрастанию Ну вот случайное число - это в целом хорошая штука для идентификации А если это число генерируется распределённые системами у которых достаточно энтропии одинаковые системы информационные системы они потому системы что они работают воспроизводимость - это то что мешает вам создавать разные идентификаторы соответственно при использовании случайных чисел в качестве идентификаторов вам нужно оценить количество энтропии в системе если для сбора энтропии вы используете время то в распределенной системе Это всего лишь несколько битов энтропии значит может быть недостаточно для того чтобы в распределённой системе генерировать случайные числа Ну в общем человечество об этом довольно плотно подумала в начале двухтысячных и создала иф создал request for comments с названием универсальный уникальный идентификатор и главная его версия 4 это версия которая предполагает что у вас есть 16 байт почти полностью набитыми набитые случайными числами полагается что вы используете криптографические стойкие случайные числа а раз вы используете криптографические провайдеры значит вы набрали достаточно энтропии это мешает И отту на самом деле потому что не любое устройство там на ардуина собрать энтропии не так просто у вас Ну недостаточно датчиков реального мира чтобы её собирать тем не менее э в таком виде uad V4 сейчас это стандарт ээ создани случайных идентификаторов Но в нём есть проблемы Он был создан в 2005 году 20 лет прошло Давайте поговорим о том че там появилось нового Ну про ID можно сказать что в нём есть вариант это от одного до ТХ битов которые говорят о том по какой какой спецификации требует следует какой спецификации следует этот идентификатор по факту Для нас это всегда 4 есть раньше было п вот сейчас вот 6 78 появились Но главное для нас Седьмая когда мы начинаем использовать ID в базе у нас мгновенно возникают некоторые проблемы с тем что 16 байт для базы Като крайне неудобная штука под капотом пос постоянно используют дату которые которые имеют размерность указателя в системе ID туда не влазит Поэтому приходится делать локацию в которую указывает датум у которой есть свой заголовок и поэтому для того чтобы положить в массив значений uid нам приходится дополнительно потратить 24 байта на то чтобы 16 байт поддерживать У нас есть тут много деталей но в общем Суть в том что у нас есть н которая сейчас в кор входит uid оссп оссп - это организация которая 10 лет назад делала стандартные реализации uid там есть первый второй третий четвёртый пятый стандарты которые там реализованы но смысл в том что оссп давно уже умерло последние обновление пакета у ССП случалось в 2013 году и по факту Случайный ID V4 - это то что мигрировало в Core и ID оссп больше вам не нужен Вы можете без создания дополнительного ше использовать ID V4 который вызывается стандартной функцией uid есть понятная проблема это случайное число как я говорил раньше поэтому Когда вы вставляете случайное число ВБ дерево Вы каждый раз затрагивается случайные странички по факту uid это главный источник вала потому что вставляемый последовательно данные не оказываются на одной и той же странице использование uid администраторы не любят Именно за то что добавление новой нового индекса по uid всегда огромный источник записи на диск именно со стороны индексов и э запись именно которая разе по репликам и будет нагружать всю распределенную систему в целом вообще мы когда проектируем информационную систему мы её проектируем в так называемой иерархии типов памяти Когда у нас есть ограниченная по объёму быстрая память в регистрах Чуть более Широкая Чуть более медленная память в Шах и далее в сторону дешёвой памяти и в этой иерархии для нас ключевым свойством производительности является локальность она наблюдается на всех уровнях иерархии она наблюдается в том что поля в структуре которым мы чаем доступ одновременно должны быть рядом талы на странице к которым мы Обращаемся одновременно по возможности должны быть рядом или хотя бы на одной странице и не знаю файлы которые Мы скачиваем из S3 по возможности надо их загружать одновременно Ну не любой S3 Конечно будет иметь возможность воспользоваться этой локальность В общем в целом локальность - это то что мы используем для того чтобы предсказать доступ к ещё холодным данным для того чтобы попытаться прогревать данные э вот этой локально концептуально противоречит юристы в первую очередь хотят добиться монотонности сиквенс были монотонным они всегда возрастали это гарантировало логом и Давайте будем делать всё монотонным но монотонность в распределённой системе в принципе не существует как Ино вся в в принципе невозможно и то есть достижение монотонности возможно специальными протоколами но слишком дорого и медленно Не производительно а поэтому строго монотонная штука не нужна с другой стороны локальная штука нужна А было что-то похожее Понятно В начале двухтысячных и оно называлось uid version One Это uid который в качестве энтропии использовал не хаширова время первые там э бай у нас это который в принципе возрастает А значит он в целом локален но если мы возьмём сгенерить и идентификатор се который покажет нам истинную локальность мы обнаружим что даже на де вставка у нас се нарушается что генерирование этих возникало происходило не в соответствии с их логическим порядком Дело в том что у нас байты расположены не так Они расположены в вместо того чтобы быть расположенными удобно так вот нас я сейчас могу нать в общем большинство баз данных что было бы удобно базе данных сообщество посно осознало проблему и например существует такое расширение как V1 Ops которое создаёт оператор класса который позволяет сравнивать ID в соответствии с специальным захард коренным порядком байтов то есть там есть Прямо массив который говорит что сначала Сравни шестой сеь потом чей пятый потом нулевой байты вот этого Окса позволяет уменьшить нагрузку на CPU уменьшить вал но из-за того что вот этот вот цикл плохо разворачивается в плохо понимается компилятором немного вырастает нагрузка на CPU в месте Бин поиска по странице множество различных компаний озна эту прое Twitter там Instagram что есть там Sony в Яндексе тоже свои идентификаторы были в общем все на костыли на велосипеде или много разных альтернатив и поскольку этих альтернатив было достаточно много иф занялся созданием нового rfc rfc 9562 Ключевая ключевой особенностью которого является uid V7 на самом деле когда Рабочая группа занялась этим стандартом они обнаружили что и старый стандарт уже надо утюжить много слов не соответствует реальности интернета требует доработки из-за этого стандарт возвращался назад много много много итераций с редактором было потому что предложено решение существующих проблем а е есть мелкие недостатки в прошлом Стандарт докладывал на на лоде в разных городах как минимум три раза И это были разные стандарты Потому что его начинали снова переписывать и меняли контент uid V7 тоже просто за компанию контент меняли функциональной части Ну давайте пойдём дальше про u7 простой бенчмарк который показывает что при вставке миллиона строк у нас вставка ID занимает Меньше времени интернет сейчас полон Берков бенчмарки д чего года наиболее точные вот последнее существенное техническое изменение в Стандарт было принято в два третьем году там разделили разрешили делить миллисекунды не на 1024 не на 1000 а на 1024 чтобы процессор старым процессором было удобнее но в общем с конца дцать третьего года стандарт почти не изменялся ну здесь мы видим что производительность вставки на приблизительно такая же как просто вставка восьмибитка который последовательный Ну короче просто больше и лучше если вы хотите одну мысль из этого доклада то она такая Используйте V7 типа это за исключением одного маленького нюанса который будет в конце это полная замена uid V4 который Ну сейчас может быть я занимался реализацией гресса К сожалению его не то есть реализация согласована с сообществом но в семнадцатый пос Грес его не приняли потому что фиче Фриз случился в апреле а етф утвердил стандарт Только в мае если бы мы немножко посоревноваться наложены Поэтому в ядре использования uid 7 Скорее всего будет доступно в восемнадцатом посе опять же я говорю скорее всего чтобы случайно не навара вдруг не будет вдруг сейчас все плют на этот uid и будут что-нибудь другое разрабатывать тем не менее Если вы хотите принять участие в разработке Вы можете пойти на comit Fest и обсудить те детали которые я сейчас рассказываю В общем случае мы добавляем простую функцию uid V4 для старой версии вместо длинной функции generate Random uid мы добавили просто V4 и такую же функцию для седьмого седьмого идентификатора Кроме того мы теперь позволяем извлечь из uid его версию Вы можете мы добавили несколько возможностей к интроспекции если вариант uid не соответствует rfc ID то мы возвращаем просто для версии Ну потому что мы не можем гарантировать чтото что ваш uid был сгенерирован каким-то совместимым алгоритмом мы добавили извлечение тапов стандарт не жёстко требует То есть он допускает множество оптимизаций для снижения Ну типа для избежания например операции деления И эти эти допущения говорят о том что не все реализации будут давать один и тот же одну и ту же битовую раскладку времени внутри ID то есть вот эта функция она в се работает для ID V1 Она же будет работать для V6 и V7 V6 - это аналог V7 только с более правильной раскладкой битов Ну то есть короче V6 - это прекурсор V7 Если вы хотите использовать в постгрес генерировать в по ID прямо сейчас Вы можете установить расширение н не произнесу его фамилию на французском скорее всего произнесу неправильно в общем присутствует во всех Рерих ти всякого такого вцелом оно почти правильное в том плане что оно не противоречит стандарту но оно не реализует последнее добавление Вот 23 и чет года стандарт Который пушит наш вероятно соо никогда не встречался с серге дот в Осе и сказал им каким частям стандарта они не соответствуют больше всего Сергей тригери на то что в реализации не используется счётчик обеспечивающий монотонность в определённых условиях Давайте поговорим про этот самый счётчик при генерации идентификатора мы использу мы добавляем время в не шифрованные У нас есть дата и время предыдущего Ну то есть таймстамп предыдущего предыдущей генерации если таста у нас двигается в прошлое или не двигается то мы используем счётчик счётчик занимает дополнительные биты и обеспечивает генерирование uid на одном бэнде всегда монотонно со скоростью до 125 МГц с частой до 12 МГц скорости при превышении скорости генерации у вас они по-прежнему ID на одном сетевом соединении в гресе будут монотонным по крайней мере в той версии которая предложена в сейчас они будут монотонным но вы будете наблюдать эффект того что внутри ID время начинает двигаться вперёд Поэтому если вы закладывается на это время где-нибудь в несколько сотен миллионов в секунду что технически пока сложно В общем время может пойти вперёд внутри есть раскладка биков Ну соответственно вся эта раскладка состоит в том что мы в начало укладываем время так чтобы его при помощи можно было сравнить Но вот эта вот раскладка кантера она попала на версию uid поэтому у нас здесь смещения получились неровные байтовые А между битами версии и варианта мы аккуратненько лобзиком вырезаем наш каунтер из-за этого в моей реализации используется восемнадцати битный счётчик сообщество иногда говорит что может быть стоит его увеличить счётчик при каждом движении времени перее нери случайным числом почему это важно потому что если вы генерирует идентификаторы со скоростью меньше 1 кгц у вас идентификатор содержит много чистой чистых случайных чисел он становится менее предсказуемым стандарт содержит интересный трюк как одно из предложений то есть чтобы счётчик был непредсказуемым Вы генерирует некоторое случайное число на которое вы шае вперёд но по сути это просто то что вы больше битов Выделите под чистую энтропию под чистые случайные числа Поэтому этот трюк мало реализации используют в большинстве случаев у вас внутри одной миллисекунды на одном сетевом соединении пасса используется просто счётчик фиксированной длины инкремент случилась без движения времени впер есть скачком назад либо без изменения счётчика времени Ну вот эта вот Тема с счётчиком времени в стандарте ещё описано Так что вместо счётчика можно использовать честные микросекунды у греса есть проблема с тем что он работает буквально на каждом утюге нам нужно поддерживать множество платформ и гарантировать что микросекунд нае разрешение времени есть везде мы не можем Кроме того в отличие от счётчика микросекунды имеют полное право двигаться назад при переводе стрелок при там даже не високосных каких-то вещах просто приходит НТП говорит А что-то ты тут быстро считал считай назад Вот это нормальная ситуация и монотонности при этом уже у идентификаторов не возникает с другой стороны стандарт говорит что по возможности никогда не закладывать на монотонность счётчика Ну в общем обсуждение нужен нам счётчик вной реализации или нужны микросекунды привели к тому что на обсуждался вопрос А какой время сейчас есть у пос греса Какое время сейчас предоставляет большинство наших серверных платформ и в результате обсуждения мы выяснили что ста наносекунд время присутствует в большинстве поддерживаемых сейчас серверных платформ Ну то есть мы не нашли платформы которая не поддерживает время с разрешением меньше микросекунды это может быть неточно и плавающее тем менее оно постоянно изменяется ЕС вы генерирующая кликхаус потому что в постгрес Мы пытались выбрать одну функцию которая будет работать для всех в Хаусе сначала пошли по другому пу и предложили функцию которая имеет с все треды кликхаус И этот счётчик защищен ксом Ну не знаю можно было на самом деле на атоми Как сделать этот счётчик раз к нему есть доступ с разных с разных процессоров и изначально у них была ещё реализация Non monotonic когда мы говорим что просто у нас всегда случайные числа вместо кантера и monon когда на одном треде мы генерируем монотонные А между тредо это что я лаю для идентификаторы между разными сетевыми соединениями имеют право гоняться в хае этого нету ну общем прил ша сказал-то сложно вы предлагаете людям три функции для решения задачи которая решена 20 лет назад и удалили остался просто вот этот вот защищенный ло если у вас генерация идентификаторов вдруг не Оказывается горячей точкой поговорим про паттерны использование uid в распределённых системах мы в сеты по уже принесли вам функцию для того чтобы доставать таста из ID и основной е кес предполагается что вы используете её для порционирования То есть вы не добавляете колонку со временем а просто добавляете идентификатор и когда вам нужно разложить ваши данные вы будете использовать эту функцию idest она уже есть в системном каталоге в восемнадцатой версии я рассчитываю что также шестые и седьмые ID будут поддержаны код для этого написан осталось чтобы Питер его заметил он в общем сказал что не против просто сейчас ещё рано до конфеста 6 дней так вовсе не обязательно генерировать базе Если вы генерирует её в вашем языке программирования там не знаю в Джаве в си шарпе в плюсах в питон уже есть библиотеки которые делают всё то же самое Единственное что если вы хотите чтобы у вас были вот эти вот маленькие детали с монотонность или локальность Посмотрите вот детали реализации в вашем языке и не все они вот эти возможности поддерживают не все они достаточно точно следуют rfc можете сразу когда находите реквест искать там Сергея Прохоренко если он написал список замечаний из 10 пунктов можно пользоваться А если из 20 то Ну может подождать немножко вот э то есть там есть и другие замечания просто они мне показались не настолько важными чтобы долго про них говорить вот а слишком много чего угодно Это плохо слишком много виски это едва достаточно это кстати фраза которая Марка Твена которые всё время неправильно переводят на русские он сказал much а её переводят как этого просто достаточно тут с инженерной точки зрения Есть разница либо у нас предел такой-то либо стремиться слева к этому пределу Ну неважно В общем локальность не всегда хорошо когда вы быстро записываете данные в персистентность может быть проблемой и изначально в реализации поса была предложена возможность те сказать что у вас в то место куда записываются данные должно быть чере горячих точки вы добавляете смещение стампа на 10 лет к счастью там ещ он без переполнения до деся года и имеете четыре разных точки конна четыре разных горячих точки в которых берутся Локи на странички в которых стандарт явно просит не давать пользователю указывать время для которого генерируется ID поэтому к сожалению в ядре греса этой функции не будет с другой стороны если она вам кажется полезной можно пойти в extension fris и сказать что ну Франсуа Ну ты всё понимаешь мы хотим иметь возможность указать время для которого будет генерироваться ID одна особенность единственный случай когда нельзя использовать V7 вместо всех остальных стандартов это случай когда uid раскрывает время генерирования в медицинских секретных данных uid V7 использовать нельзя потому что из него можно достать информацию которая там что-то скажет секретного короче изначально etf работал над версией 8 которая должна была быть сразу решить проблему id7 Ну вот с этим с конном там с точностью часов выбрать один стандарт Ну комитет Рабочая группа просто сказала что давайте скажем что ID V8 - это любой ID в котором всё кастомное Вот запишите сюда Что хотите Вы отвечаете за его уникальность Вы отвечаете за его локальность Делайте что хотите оно будет стандартом V8 и8 - это стандарт который остался для того чтобы разложить биты так как вам больше всего понравится на этом У меня всё спасибо за внимание Надеюсь что-то из этого будет полезным в ваших системах Большое спасибо за доклад тебе Давайте переходить к вопросам очень тема интересная Вот давайте начнём с первого ряда сразу Фёдор вижу именно раз Привет меня зовут оче интересный слушать вот я на самом деле недостатков почти не услышал хотелось бы чуть побольше про недостатки и такой второй под Вопрос вот та таймов не можем при входе Да а какой-нибудь соль туда передать можем каким-то образом Ну то есть какое-то число которое Вот например у нас есть лёд ная система там в США в России и где-то ещё в Китае Мы хотим гарантировать что вот в сиквенс в США Росси Китай были разные то есть какой-то вот это такая штука была в этом стандарте называлась к сожалению в 2023 году её удалили оттуда я дискуссию не зане не следовал А нуно предполагалось да что по этим э шард ID будет разделение систем в результирующей стандарте её нету почему именно удалили яче сказать не могу можем найти обсуждение на гитхабе велось оно открытое можно ещё ворваться тут нет уже нельзя Это уже RC чуть-чуть поздно что-то менять а реализации позволяют управление битами реализация Франсуа позволяет оставить энтропийный биты нулевыми и самому там записать что хочется Это же просто 16 байт можно сказать что последний байтик ваш Используйте его Для чего хотите Он правда будет не совсем стандартным но стандарт - это типа как это вы же знаете что делаете Наверное А про недостатки а про недостатки а Если у вас есть поток событий там допустим миллиард событий в секунду они падают в одну точку Если вы пишете это в систему которая там блокирует странички на запись и записывает их последовательно у вас образуется contention Point cont Point - это типа Бат блин извините я английскими словами говорю короче это тормоза А нам же нельзя чтобы что-то тормозило вот нам нужно распиливать несколько точек вставки данных вот раскрытие данных о времени генерации вроде всё с минусами А если вы используете версию которая глобально монотонна Ну монотонно глобально для вашей инсталляции то её нужно защищать либо Амика либо ксом соответственно каждая генерация Это означает что вы из кша соседнего процессора выкидывает счётчик то есть у вас генерация этих идентификаторов работает не в норме она ограничена генерацией криптографических случайных чисел Но вот как только вы начинаете выкидывать из разных Шей этот счётчик у вас ограничение шино данных и скоростью инвалидация кша И на самом деле Она оказывается медленнее чем генерация псевдо случай Крипто других минусов не вспоминается Спасибо ещё вопрос так давайте вот из центра зала хотел Антон разработчик из Зена Хотел бы уточнить всё-таки Вот хотелось бы понять Какие преимущества ID по сравнению с последней генерацией именно в случае постгрес потому что например я понимаю ЕС мы рассматриваем базы с честным мультимастер параллели всё хорошо а если мы говорим про пог нам всё равно выделенный Мастер и в итоге мы всё рано упирается в эту точку генерации и но при этом последовательность у нас о локальность из коробки обеспечивает А с uid нужно заморачиваться как-то Вот хотелось бы понять во-первых е ID Мы принесём в вашу коробку Мы работаем над этим чтобы не надо было заморачиваться просто будет функция из шести букв которые надо вызвать и она будет во-вторых sequence генерирует вал он пишет Если вы закладывается с на sequence вам нужно переносить sequence при например логической репликации вы делаете апгрейды И ещё вам нужно перенести Нева секн вот а в случае с uid если он у вас работает он stateless у него всё состояние оно как бы обнуляется с рестартов так Ну наверное я услышал ответ Спасибо зала Ну короче главное все недостатки мы починим главный недостаток что его ещё нету в базе Ну и Кстати вы можете генерировать его не только в базе Там просто вызовите его в императивно языке и всё вот вот ваши 16 байт идентификатора но главный недостаток в сравнении сксом в два раза длиннее и он не влазит в датум То есть он всегда это проблема тоже немножко ну это чисто сная проблема Давай Дмитрий Привет Андрей Спасибо большое за доклад очень познавательно вот я хотел спросить а там с есть пла во спросить таймер системы Сколько время то есть не будет ли это Батл неком при регенерации а ээ Короче так я с конца потому что у меня это стек спросить время сейчас около 20 наверно секунд Несмотря на то что это вроде как сиско это не cis там короче линуксоида вам расскажут про vds и другие трюки которые я стараюсь Ну типа знать но не могу про них уверенно короче говорить вот то есть ну 20 на секунд вот стоимость посмотреть текущее время там под капотом много хаков которые используют не только настоящее время они используют счётчик тактов для которого они приблизительно знают его стоимость который они как-то делают чтобы это работало с ум того что у нас так вобще горя плавающие вы любитель поса как и я Вы можете открыть бинарки поса и найти там утилиту PG тест тайминг которая на вашей системе даст вам гистограмму распределения получения времени там вы заметите что там довольно тяжёлый хвост Вы можете в очень высоких кванти увидеть что там два-три раза из миллиона у вас получение времени почему-то стоило секунду скорее всего у Вас просто прерывание отработала и операционная система вам сказа мо сейчас есть дела поважнее А вот короче Воспользуйтесь ЛЗ и посмотрите на вашем сервере или на вашем ноутбуке или на ваших часах сколько оно времени занимает А первый вопрос я уже забыл Есть ли планы про то что про про датум нет датум такая железная штука в прогрессе когда компьютеры станут 12 восьмибитные у нас будут побольше датум э вообще датум вот тут Миша наверное что-то хочет сказать нет хочешь давайте вопрос Следующий так если время генерации аж секунда может быть насколько можно использовать вообще е если нам надо генерить врем время генерации времени в секунду это следствие не чтения информации о времени а следствие того что просто исполнение нашей програмы было но операционной сист системы многозадачные операционные системы не являются операционными системами реального времени в принципе операционная система имеет право прерывать наш процесс настолько насколько считает нужным мы должны на это рассчитывать для решения задач Когда нам недопустимы секундные задержки наверное в принципе недопустимы там не знаю двигатель уедет куда-нибудь нам нужны другие другой софт другое железо всё другое сист дают вменяемое время обычно в большинстве случаев и оптимизированы на пропускную способность Спасибо ещё вот много у нас вопросов Давайте из вот рядом здесь а потом из Конца зала пожалуйста Здравствуйте спасибо за доклад и вопросик такой мы можем про версии для генерации там потели на V4 потом переключились на V7 никаких там подводных камней нету Бинар это абсолютно одно и тоже база про эти 16 байт не знает что у них внутри она знает что их надо сравнивать вызывая mcpi но внутре них не смотрит эти биты внутри себя никак не использует для организации доступа Единственное что она хочет чтобы для разных строчек они были раз ое базы не требуется Ну и такой вопрос по сравнению То есть если мы хотим сравнить нам Ну либо как текст мы сравниваем либо экстра тайм делаем и тогда мы можем сравнить только эти уид по каким-то признакам я правильно понимаю То есть мы просто сравниваем как массив из 16 байт не никакого экстрагирования информации оттуда не происходит Мы по байтов сравниваем Если первые байты одинаковые то сравниваем вторые байты если вторые байты одинаковые то сравниваем третье байты если они разные то возвращаем какой из них больше Понял спасибо Андрей я пока напомню что тебе нужно будет выбрать лучший вопрос Да можно пожалуйста в конце зала поэтому запоминай я запомнил Ладно я пока не буду спойлерить Добрый день Кирил возможно пропусти могут быть проблемы если на Скат время есть соединился с ntp понял что отстаёт взял подмотать и я же правильно понимаю что состояние счётчиков Видимо для каждого тайм смпа должно где-то храниться и Это довольно может быть большой объём если у нас гранулярность микросекунда да то есть секунда - это уже миллион значений счётчиков А нам наверное не за одну секунду надо хранить Видимо это два вопроса это Спектр вопросов который короткий ответ на них то что мы храним счи оперативной памяти соответственно у нас могут быть проблемы если у нас дрифт времени назад сопровождается одновременным рестартов мы нарушим монотонность идентификаторов если у нас поедут часы и нас перезагрузкой системе они возможны с другой стороны стандарт явно про монотонность есть мы потеряем монотонность мы не потеряем локальность данные сгенерирован одновременно по-прежнему будут рядом в базы данных и мы самое главное ни при каких условиях мы не потеряла ни при каких условиях слишком жёстко сказал в большинстве случаев мы не потеряем уникальность даже в случае этого события надо сказать что когда нам требуется уникальность это важная часть про которую я не сказал уникальность требуется нам тогда когда мы генерируем много данных в одном наборе Когда нам когда против нас работает Парадокс дня рождений э соответственно чтобы запустить Парадокс дней рождений нам недостаточно одного скачка одновременно с рестарта там нам нужна большая серия Скачков назад Вот если уж доводить до экстрима то приблизительно 10 в пятнадцатой где-то в 10 в шестнадцатой Скачков назад одновременно с рестартов там не нулевому то есть больше чем 1% вероятность коллизии идентификатора и нарушения уникальности Это довольно жёсткая гарантия на самом деле то есть не любая система выдержит там 10п рестартов ну некоторые системы один рестарт плохо переносят там Второй второй уже не случается не могли бы всё-таки уточнить вот я не очень понимаю у нас шлось время мы старли он при старте понял что время разошлось отмотал себя назад состояние счётчиков отсутствует как в этом случае гарантируется уникальность я вот не очень понимаю кроме 48 бит времени там ещё 63 бита энтропии а именно энтропия гарантирую Да я понял вот а если рестарта не случилось и случился скачок назад без рестарта то мы считаем что часы не продвинулись вперёд мы используем предыдущее значения когда счётчик на предыдущем значении перепони Только тогда мы кун шагаем ВД а собственный счётчик да то есть фиксируется время на старт системы Видимо да и дальше идёт собственный сч фиксируется время предыдущего генерации предыдущей генерации и в этой генерации мы не даём времени идти назад У меня тут там код был короче который это демонстрировал я Поня Хорошо и вы упомянули Пию А вот нет ли проблемы нехватки тропи бом количестве генераций А ну в данном случае мы полагаемся на Open ssl как провайдер трапи в целом она может быть и как я сказал генерирование uid на большинстве реальных систем ограничена скоростью генерации случайных чисел а Но типа генерация миллиона идентификаторов не составля миллиона идентификатора в секунду обычно не составляет труда Ну то есть н копии хватает у скажем так стандартного сервера да это уже начинает перестать в дискуссию Да у нас есть другие коллеги которые тоже хотят задать вопрос Давайте вот с левой части зала Добрый день меня зовут Вадим Я тут услышал что вы сказали Ну можно сказать не по теме Ну по теме Короче вы сказали что взять время - это 20 наносекунд да около того Вот это глобальное заблуждение вот всего программер ского сообщества Лоба заблуждение происходит потому что вы мее что-то в функции где миллион циклов Да измеряется это время общее Да миллионы потом делите на миллион Да вот а вы Возьмите измеряйте Ну есть ТСП такие штучки Да там которые могут нано секундочку мерить Вот вы измеря каждое измерение Да и делаете паузу между ними не в десятки раз разни это на всякий случай Если честно я не понял добавление паузы на что повлияет Вот вы делаете цикл в этом цикле пауза вы мертенс потом делаете Это собираете статистику отбрасывается хвосты это получаете среднее и посмотрите сколько там получается просто сделайте пример Ну Сделайте так у себя сечас вот прямо сейчас в pgs hackers идёт дискуссия о доработке PG Test таймин Я думаю что ваше участие существенно помогло бы сообществу Приходите у нас действительно там цикл который вызывает Get time of Day или или Clock Time что-то короче из этих Силов Прим они очень мы вот сейчас смещая гистограмму с микросекунд на наносекунды Угу Если вы говорите что наносекунд не существует что в целом Ну зная железо оно как бы не не звучит неправдой просто типа знаят числа которые мне выводит туза Я говорю 20 наносекунд потому что я их Вчера у себя на ноутбуке видел Ну да я понимаю Не я просто много занимался измерением времени разных штук Да там в реале так не происходит да у вас нет миллиона транзакций прямо вот так вот так обычно транзакция приходит и она делается да потом засыпает на какой-то ваше утверждение не про транзакции Давайте сложности добавлять не будем у нас уже время заканчивается вижу очень бурная дискуссия развернулась её можно будет продолжить как в дискуссионной зоне после доклада и также после тех толка здесь будет пре комит фст где наверное тоже это можно будет обсудить Нет там там очень много других вопросов но мы обсудим сейчас понятно а Выбирай пожалуйста лучший вопрос который тебе больше всего запомнил или про время Блин я не знаю сылка на голова А ссылка да пролили да она на последнем слайде но он сейчас вот а можно да нам вернуть Спасибо бо Если да вот голосуйте Если вдруг хотите больше юдов то голосование по этому QR коду даст вам ещё больше ещё два уда в секунду лучший вопрос был про вот дату Я считаю что 12 восьмибитные компьютеры когда-нибудь у человечества будут про дату Да мы помимо нашим зрителям подарок Помимо того как подарить подарок нашим зрителям дарим подарок нашим спикером А спасибо большое тебе за доклад сейчас пока его выносят Я немножко об этом подарке расскажу это матрёшка матрёшка коллекционная а она будет на каждой конференции отличаться и ходя по конференциям различным онтика Вы на самом деле можете собрать какой-то очень интересный уникальный набор Спасибо Спасибо большое L"
}