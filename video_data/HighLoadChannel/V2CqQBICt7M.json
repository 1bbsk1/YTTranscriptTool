{
  "video_id": "V2CqQBICt7M",
  "channel": "HighLoadChannel",
  "title": "Ускоряем разжатие LZ4 / Алексей Миловидов (Яндекс)",
  "views": 4169,
  "duration": 2763,
  "published": "2019-01-14T00:11:39-08:00",
  "text": "давайте рассмотрим к простой запрос в кайф хаоса конечно задерживаешь его выполнять просто человеко читаемое фильтруем условно под строку этом как от сортировка лимит но это уже совершенно не важно и посмотрим какая у нас получается скорость рот во все отлично то есть здесь данная яндекс метрики просмотр страниц таблица 100 миллионов строк мы делаем files can читаем все обрабатывается меньше чем за секунду скорость работы 11 гигабайт в секунду и 125 почти 126 миллионов строк секунду все замечательно все довольны что еще надо делать непонятно ну можно ничего не делать но я очень часто захожу на сервер и вижу вот такую картинку кто меня подскажут что это такое громче абсолютно верно это трв top evod на первом месте я вижу за 4 для компрессов от во первых это меня расстраивает само название функции расстраивают там написано fast это как бы намекает на то что активизировать и и не получится все уже активизировали все наши усилия будут тщетными не зря ведь его так назвали но все таки она на первом месте целых 32 процента занимает то есть тормозит может щетки надо что то сделать а почему вообще такой функции у нас присутствуют и что вообще такое эльза 4 на всякий случай спрошу поднимите руку кто не знает что такое лиза 4 значит таки придется пояснить библиотека дождаться данных ну ясно рассматривать все возможные такие библиотеки скажем за отлив газет и все такое и сравнивать как по отношению к ним относятся за 4 можно отметить что это такая библиотека которая старается все таки как то сжимать данные но при этом работать с максимальной скорости есть и другие варианты которые определенным образом торгуют скорость работы на силу нажатия данных то есть можно данной сильнее она будет медленнее есть принципе много альтернатив примерно такого же класса выбрать какие-то снаппы крэка раза елизово может быть кто им становится за этого использовал но мы используем из-за 4 а почему именно из-за 4 дело в том что этого библиотека почти оптимально говорят она почти лучшая но когда мы говорим что какая-то библиотека дождаться данных лучшая это не совсем корректно потому что есть по крайней мере три параметра это причем все эти параметры можно изменить на совершенно разных дата сетах и надо еще подобрать всякие репрезентативной дата сайта чтобы понять что будет лучше значит сила сжатия у нас есть есть скорость и отдельно ее можно мерить скорость сжатия и скорость рожать и и алгоритм можно назвать пара то оптимальным если невозможно улучшить какую-то одну характеристику не ухудшив другие и в этом смысле за 4 почти пород и оптимален да почему называется на пары то оптимальным потому что ясно нарисовать на графике зависимости коэффициента сжатия score сажать а для разных алгоритмов то получится какая-то такая кривая которая некоторым людям что-то напоминает ну ладно пойдем дальше я с некоторые варианты которые в отдельных редких случаях могут быть лучше чем 24 скажем счас я есть библиотека она использует со своей инструкции почти полностью branches очень интересно доступного open source дело что потом почитайте или например есть эльза turbo разрабатываться каким-то человеком из ирана встали и она не open source и человек не дает никому не исходники не бинарники только отдельным людям дал они протестировали и этим людям вас надо играть и не говорю сейчас супер и все работает очень стран библиотека и за что почитать а почему вообще при выполнении запроса наш сервер упирается в разжатия данных ведь валь за 4 это эффективная достаточно библиотека и скорость сражаются там достигает одного или нескольких гигабайт секунду на одном процессор нам внедрять мы естественно в каком ся для обработки запроса используем больше процессных лидер и так мы получаем скорость рожать десятки 10 гигабайт секунду или даже десятки и это уж точно больше скорость работы жесткого диска это больше скорости работая с д это больше скорости работа raid-массива из ssd как же тогда рожать и все-таки является узким местом во первых стоит заметить что скорость это самые 10 гигабайт в секунду это скорость именно раз сжатых данных с диска читается сжатые данные дела у нас кажется нажать и скажем 20 то получается что там будет не 10 секунд сочетаться с диска всего лишь 500 мегабайт в секунду это уже меньше например скорость работы достаточно хорошего raid-массива из hdd во-вторых часто данные вообще не нужно читать с диска у нас нету ввода-вывода потому что до начинается с каша и это весьма распространённый сценарий когда мы читаем горячие данные итак мы точно вопрошания ввод-вывод av процессор значит все-таки оптимизировать имеет смысл но если у нас рожать а тормозит то возникает вопрос а нужно ли вообще сжимать данные и тут есть очень простой ответ да всегда сжимаете данные при записи на диск сжимается данный пример дачу данных по сети тоже сжимаете данные даже если у вас быстрые диски даже если у вас быстро и сядь там 10 гигабит ну если у вас сайт 100 гигабит то может быть сжимать не обязательно почему она нужна скажем вот ко мне в чат поддержки англоязычный обратился один человек и говорит вот у меня очень быстро и создает тоже заметил разжать ее узкое место можно ли в ховался сделать так чтобы он не отжимал данные я говорю такой возможности нет кликал всегда сжимает данные он просто использовать по умолчанию очень легкий алгоритм так что не беспокойтесь пусть работает человек говорит может я запилю такую фичу и уже через пару дней пришел powerquest там добавился мята сжатия ничего не делать и человек говорит все отлично работает протестировал я об этом говорила какие результаты стали лучше а он говорит извините но на реальных данных получить расстаться не удалось потому что данных стало слишком много так что мораль всегда сжимаете данные теперь рассматривало как устроена за 4 или все алгоритм из того же семейства того же класса алгоритмов который называется lz77 за это два человека a77 это наверное год вот сжатый файл он представляет собой как бы команда который нужно выполнять чтобы его рожать эта команда двух видов первая команда говорит что в сжатом файле идут идет какое-то количество байт который нужно просто копирует как есть то есть они не азат и называется литерал или литералы неважно а вторая команда это матч или совпадение она говорит о том что где-то недавно были ража ты какие-то данные и по какому-то смещению назад нужно взять сколько тобой и повторить их то есть скопировать то что уже было недавно раза то вот рассмотрим пример сжимаем страку хеллоу ворлд а потом снова хэллоу и вот она записана в сжатом виде сначала литералы 12 байт хэллоу пробел world пробел а потом матч по смещению 12 байт назад взять и скопировать 5 байт как мы видим на таком простом примере в нашем псевдо как бы всех да не знаю файле дано его содержались но это неважно рассмотрим что нужно сделать чтобы получить такой сжатый файл это тоже очень просто идем по данным просто по поэтому один за другим берём следующие четыре байта каждый раз пишу руинах и ищем их хэш-таблицы то есть кладем в хэш-таблице из там ничего не было а если там что-то было проверяем а там находится именно эти четыре байта я сам их нашли то мы идем дальше смотрим сколько максимум совпало то есть с помощью хэш-таблицы находимся в патче 3 байта а потом сразу смотрим что может быть совпало там 50 байт в этом случае просто кодируем матч совпадением а если они нашли кодируем литерал все очень просто но вам-то клади а не буду рассматривать я буду рассматривать только 1 сжатия толстая интересует скорость select insert и они так нормально работать теперь рассмотрим все в дакоте как развивается данные именно валь z4 эльза 4 кодируют обе команды начали трал вместе и они всегда чередуются то есть там написано сколько то скопировать как есть потом сколько-то повторить сколько было может быть 0 и у нас есть цикл и в этом цикле 2 копирования скопировать литералы потом прочитать там сколько надо копировать совпадение и скопировать совпадение очень простой цикл всего два копирования и на них тратиться время теперь вопрос как скопировать кусок памяти вы пишете например носили на себе подоспел вся наша спрашивать не буду совершенно неважно пожалуйста как скопировать кусок памяти в программе на оси отдела ответный цыпой другой ответ отдельная инструкция на прогноз армянах она всегда была там инструкция для строк и она тоже иногда использоваться но это неважно вот но основном есть и другая дачная функциям себя она использоваться библиотеке находится в библиотеке lipsy так что ответ saraceno правильный можно использовать нём себя и можно надеяться что уж эту функцию это точно все оптимизировали за столько-то лет но я стою использовать то возникает проблем считает тормозит на самом деле не тормозит на наша сцена работа она все-таки тормозит потому что у нас особенностью работы и другое что в данном алгоритмы не всегда корректно использовать именам себя и но мы это посмотрим потом значит есть нас к пунктов почему не тормозит зря я вам показал этот слайд ну вас кто-то уже успел прочитать так что меня будет вопрос вам почему меня всегда и тормозит над что есть внутри да так процессора то есть получается что косвенный вызов и мы вызываем какую-то одну из многих функций хорошо что не будет складывает нас так то есть это значит то что функция у нас меня завела не надо и надо ее вызывать еще что-нибудь да когда в области пересекаться вообще нельзя использовать еще гипотезы да тоже бывает что под достаточно широкий диапазон процессоров но не под конкретное давайте теперь просмотра что думаю я значит первое потому что косвенный вызов ходил это за того что обычно добьется куриленко динамически и там есть таблица для casanova вызова как будто это там виртуальный вызов но почти зато это дает возможно делать достать оказаться по процессорам вот второе потому что если аргумент says размер который нам нужно копировать не константной на этапе компиляции то функциям себя не будет наклоняться я обычно это не нужно копируем там например десятки килобайт и совершенно неважно будем моим lines эту функцию ринит но когда мы развиваем данные мы копируем там 10 байт 5 байтом 20 байт то есть каждый раз с разной но маленький и в этом случае именно на вызов тоже будет тратится много времени а третий пункт его почему-то никто не назвал но я его сам считаю очень важным что функциям себя и она старается делать копирования всякими широкими кусками развернуть цикла в несколько раз но чтобы это сделать нужно корректно провод хвостики данных скажем передали в нём считаю что надо скопировать 17 байт и она что нужно сделать нужно скопирует 16 байт оптимально а потом еще не оптимально скопирует один байт и вот для обработки этих хвостиков там сложная логика стоите под дафа девайс а в нашем случае это не нужно просто мы когда ружьем энданы мы можем писать каждый раз при копируем лишние байты и читать тоже лишнее байт и потому что на следующей операции мы эти лишние байты просто перезапишем заново и вот например у нас хеллоу ворлд и надо холов скопировать всего лишь 5 бат а мы будем копировать нет от бы это восемь байт из которую михайлов хэллоу про долго и ничего все прекрасно будет работать над еще 20 пробел в перепишется следующими данными единственное надо все-таки проверять что мы копируем лишние байты не выйдем за границу буфера иначе у нас будет проезд по памяти и вот как говорит этот человек кровь и кишки 1 триллион к ну я это не очень нравится итак реализуется все это очень просто вот смотрите есть функция скопирует восемь байт она еланец а внутри немцы 5 но этот мир себя вызываться реально не будет и the built-in в компиляторе так что компилятор прямо по место поставить нужной инструкции и есть другая функция то цикл который копирует всегда минимум восемь байт и количество которым копиров кратно 8 байт все очень просто идем дальше теперь по поводу этой дополнительной проверки за границу выхода за границы буфера значит у нас два копирования в цикле и валь за 4 уже присутствует оптимизация что нужно можно копировать по восемь байт всегда минимум по восемь байт а кратно 8 поэтому там есть проверка выхода за границы массива функция за 43 компресс обычное этих проверок 2 перед первым копирование перед вторым 4 компресс fast только одна значит вторую которую не может выйти за границу буфера но специально в сжатом формате за 4 поставили условие что данные должны быть такими что вы при копировании матча мы никогда не вышли за границу буфера должна описано последний для нас байт должны быть только лета роуминг довольно сложные условия но суть в том что если вы используете функцию за 4 компресс fast злоумышленник может отправить вам такие данные что они вызовут проезд по памяти будем просто иметь это в виду и первый вопрос вот у нас был пример когда мы копируем по восемь байт и польза 4 именно так сделано а почему по восемь байт почему не по 16 а почему бы не по 16 я еще четыре раза развернуть цикл можно использовать assassin когда вы их с инструкции и вот пример который это делает вот функция которая копируется раз 16 байт такой код все писали все знают даже спрашивать не буду здесь in трусики это сослан принципе чтобы прочитать назвать регистр по него румяным адресу и записать ничего лишнего нет итак почему же в оригинальный реализация 4 копирования все-таки не по 16 а по восемь байт во первых не очевидно как же лучше вы можете сказать типа я все знаю так точно будет лучше но это ничего не стоит вот и конечно из-за этих условий нажатый формат чтобы при копировании по восемь байт не было проезда по памяти а я сам и будем по 16 байт копирует 100 условия должны быть другими и в оригинальном формате так и сделать не получится и теперь еще 2 часть рассмотрим копирование совпадение в наших данных есть простой случай когда вот например которого хэллоу я этот пример уже показывал диапазон данных не пересекаются все просто copper скопировали все нормально а вот теперь сложный случай дело в том что в сжатом формате мог быть такие совпадения что их длина пересекает наш курсор где мы сейчас находимся и как бы это совпадение содержат еще одни инициализирован и и байты которых как бы нет вот здесь вот пример у нас то что мой рожали это всего лишь три байта и би си аналоговый рот и вот мы находимся сейчас на байке паслись и и нам говорят что по смещению три байта назад нужно скопировать 10 байт а как скопирует 10 байт из у нас есть только три a7 еще нет ни инициализирована и ответ такой что надо копировать так как будто мы один за другим байты копируем и тогда у нас получится что после копирования строка вот это вот будет повторяться и by сервисе и так далее то есть примерно так цикл по байтам и копируем и вот как это выглядит было только и би си мы скопировали одну букву другую третью и на там 5 итерации например мы будем копировать то что мы создали уже в процессе копирования кстати я со смещение будет равно единице то у нас просто один байт будет повторяться сколько-то там раз это значит из этого можно сделать вывод что эльза 4 в качестве частного случая содержат себя реализацию rl я то есть рангов encoding кодируя повторяющихся байт теперь вопрос как же сделать оптимально потому что каждый раз когда я вижу цикл по байтам в программе становится грустно потому что сделать что-то по одному байту это всегда тормоза и конечно его можно оптимизировать будем копировать 1 4 байта прямо как есть папа этого то есть четыре там вызова как бы стоит на там а после этого у нас есть уже готовый четыре байта и мы можем теперь делать копируя сразу 4 байта а когда мы это сделали теперь можно скатывать восемь байт и восемь байт можно скопировать как обычно потому что теперь диапазоны уже не пересекаются и это оптимизация есть вы за 4 вот как она выглядит и честно говоря мне потребовалось очень много времени чтобы понять что тут написано какие-то таблицы причем одна once on the другой ain't какие-то смещения в принципе вам будет проще потому что я только что объяснил что тут делается копируем четыре байта паба этого вот 4 этих оставить лентами потом сдвигаем место с которую надо копирует куда-то согласно какой-то таблицы и к первым сразу 4 white а потом снова сдвигаем и дальше можно делать цикл как обычно уже по восемь байт я очень долго разбирался с этим кодом а вы знаете что когда какой-то код непонятный да еще и без комментариев самый простой способ разобраться это все переписать вот я переписал туда же комментарии появились я не у и роста этот год стал более понятен для вас но мне он нравится больше и когда его писал сразу же его можно было вообще на 16 байт вот тут супер целых три каких смещения копируем 1 4 байт как есть потом четыре байта потом 8 ватт а потом уже можно дальше копирует по 16 байт а теперь вопрос вот мы писали такой хитрый кот а вдруг в процессор и есть магическая инструкция которая делает то что нам нужно то что нам нужно это не сколько байт размножить по другим бойцам то есть присвоить каждому там байту результата значение из байта исходного пока кого-то номеру вопрос можно кто не знает есть такая магическая инструкция спасибо им тогда я даже не буду спрашивать стоит за инструкция в том что я сам про это да абсолютно верно это инструкция shuffle она входит в ссср 3 это старый набор инструкций можно не беспокоиться на всех сферах и то есть а если у вас более старайся error это вы можете сдать их в утилизацию значит принимает 216 находи страх первое это данные которые нужно как бы shuffle shuffle значит переставить вот а второй это селектор в нем и там бойца написано из какого байта какого номера взять результат посмотрим как это работает допустим у нас было два 16-битных регистра одна была написана и бесси а потом какая-то не инициализированная память а в другом был написано просто 012 это и сайт повторяется мы делаем одну инструкцию выполняем и на выходе получаем ту же самую строку разложенную в точности так как нам нужно вот почему вырезать четыре нет такой оптимизации они не знаю глупые ставинне они не глупы за 4 автор я на khaled и я его очень уважаю замечательный человек должны смотря на то что он забыл написать комментарии в коде а вот тот самый код который делает то что нужно боюсь что здесь ничего не видно но здесь значит есть какая-то таблица для каждого смещения написано какой выбрать коллектор и мы его выбираем и делаем shuffle а потом еще сдвигаем матч на какое-то другое смещение ну не надо этот слайд особо внимательно разглядывать на это времени нет и так значит эту инструкцию можно использовать до 16 байт на регистрах можно использовать его ей до восьми байт них регистров mmx регистров но я это не стал делать по очень серьезной причине я сейчас не буду спрашивать нас кто-то после доклада скажет по какой серьезной причине то у меня есть подарки на этот случай потому что вопрос сложный вот а еще можно до восьми байт его пример так что мы будем просто читать 16 байт а там будет какой-то мусор мы будем как-то переставлять мусор не важно как но 85 раз дата потом возьмем и там все будет нормально и ест аналогичную инструкцию более современная и в оу x2 и а вы x 512 правда процессоров с этим набор инструкции сейчас почти не существует только-только появились хотя есть там все сделано фай но это немножко другое есть и для arma если вы хотите портировать на arm то тоже старшая инструкция теперь вернёмся к изначальному вопросу как же избежать этой проверки за выхода загорается массива если мы хотим расширить наши копирование до 16 байт отвел такой надо просто сделать интерфейс наши функция неудобной и переложить от забот она пользоваться мы скажем пользоваться ты когда вызываешь эта функция пожалуйста выделенном буфер на допустим сколько-то 32 например байтов больше чем надо а мы будем использовать от 32 байта для того чтобы читать оттуда какой-то мусор писать туда какой-то мусор ну короче дай нам такой буфер но могут быть проблемой скажем мы сжимали данные очень хорошего кусочком 64 килобайта 5503 шесть байт вот и мы теперь говорим что для вызова этой функции дай нам теперь размер буфера 5551 байт и возникает вопрос как же будет работать на локатор может быть в этом случае локатор вызывает нам кусок память он проделал с 6 килобайт а может быть и 128 килобайт а может быть локатор увидят что надо выделять такой большой кусок памяти и перестанет его кэширует второй блок алкаши а может быть он начнёт использовать a map для каждой это операции и вместо нашего наши чипы надежды хоть чего-то чуть-чуть оптимизировать мы получим катастрофическое падение производительности может быть получим может быть не получим итак мы рассматриваем три оптимизации 1 к 1 по 16 байт более широкая второе инструкция shuffle вместо непонятного кода и третье убрана одна лишняя проверка выхода за границы массива и я стал это тестировать и что же получилось я значит взял первый попавшийся данные первой попавшейся данные были о производительности яндекс браузера яндекс браузер использует коли house ну не на вашей машине конечно на наших серверах и там какой-то столбец версией я посмотрел референсная реализации который был один из оценки габбард секунду я все ускорил стало почти 3 гигабайт в секунду 76 процентов быстрее очень круто я сразу же решил что сейчас я это за к вечеру померзла сделаю релиз и все это пойдет в продакшн но передать им я отвлекся а в когда вернулся решил протестировать еще на одном пример данных теперь данные были байера крутилки яндекса и какой то еще столбец кстати название с торцов могли быть изменены в этой презентации и так референсная реализация две целых три десятых гигабайта в секунду а когда я сделал всю свою оптимизации то я получил результат на 20 процентов медленнее и теперь перспективу внедрения то в продакшен под вопросом сначала я решил протестировать на каких файлах лучшей оптимизации на каких хуже яблоки пальцы за что чем больше как сажать а тем лучше использовать широкие копированием действительно потому что я со данные сильно сжали старика мы будем повторять копировать более длинные куски памяти а более длинные куски памяти лучше копирует более широкими инструкциями но чтобы все проверьте я решил сделать четыре варианта кода естественная их никакой постил а использовал для этого шаблона сикрест и стал всё тестировать вот кстати тут написано новый онлайн не надо отвечать почему я со кто скажет после доклада тоже будут предусмотрены подарки вот я стала то тестировать и сначала довольно опрометчиво тестировать там на своем ноутбуке но у меня хороший ноутбук яндексе выдают вот но чтобы тестировать первое отключите хотя бы энергосбережения процессора 2 остановить и всякие дурацкие программы типа firefox храним да вот если тестируется на сервера то примерно так остановите все программы которые мы называем условно трэш скрипты на языках программирования букву п это всякие мониторинге агенты они изредка просыпаются начинают использовать процессор пару секунд и засыпают снова а мы хотим чтобы наши результаты были стабильны но последние два это какая-то индексов специфика просто случайно попал на слайд итак допустим я смог все это протестировать но когда я это начал тестировать я еще выяснил удивительную особенность я пошел на наши серверы обнаружил что там раза дата абсолютно другие вплоть до того что они меняются местами и у меня был один сервер со старым процессором intel я пошла другая там тоже результата другие то есть производительность сильно зависит от модели secu и возникает вопрос как же выбрать лучший вариант и так скажем выбрать какую-то репрезентативную нагрузку репрезентативный datasette и все это протестировать этот который лучше в среднем то ты в продакшен но проблема тут в том что treehouse использовать по всему миру это многие сотни компаний и я вовсе не гарантирую что я смогу самостоятельно выбрать ригондо рпд нативные datasette и так что может я выберу какой то лучше алгоритм у наших замечательных клиентов на другом конце света он будет тормозить я с другой вариант что 1 скорость зависит от модели считаю и как сажать надо просто в код писать пороге если данные за ты больше чем в 10 раз используем 16 байт на инструкции или например ется из пост старый процессор intel отключит инструкцию shuffle но как же я смогу вписать это огромное количество условий и как я могу протестировать все на всех доступных моделей процессоров может быть надо взять справочнике типа intel что-то типа мануал в 10 томах и прочитать где там написано что в этом все там shuffle один такт отрав под четыре операции да можно пользоваться яндекс браузера протестирует но у нас есть еще и яндекс метрика яндекс директ яндекс почта очень много вариантов так вот какая-то картинка и что на ней расположено кто скажет какая-то симуляция к смеси нет значит написано бандит какой бандит вы сказали однорукий нет короче сразу после моего доклада если я не ошибаюсь в другой аудитории будет доклад под названием но нога руки и бандиты и так многорукий бандит это способ выбрать как анти оптимальный вариант случайным образом как он работает у нас значит есть 4 варианта алгоритма мы можем каждый раз когда какой-то запускаем измерять его время причем на измерение времени много времени мы не потратим потому что золотые блоки например это минимум 64 килобайта и мы можем начать совершенно случайно даже равномерно случайно дергать любые методы и собирать статистику а какой из них за какое время работал а когда у нас будет накапливаться статистика мы можем рассматривать в реально работы каждого алгоритмы как случайную величину не известно имя еще неизвестно и распределение которым мы можем согласно нашей статистике оценивать и в начале у нас будет полная неизвестность а потом у нас будет это распределение сворачиваться к настоящему значению который у нас есть и что с этим делать мы хотим дальше чаще вызвать те варианты которые в среднем чаще оказывались лучше этого есть метод называется томпсон сэмплирования суть его в том что мы оцениваем распределения для каждого варианта я пожалуй верну эту картинку оцениваем распределение и для того чтобы выбрать какой следующий вариант вызвать мы как бы в уме разыграем случайную величину каждого из них на вернется вот 4 случайных варианта и какой из них оказался меньшим то есть лучшим меньше времени тот раз и вызываем мы продолжаем вызывать эти варианты случайно но чаще вызываем те которые оказались лучше и остается еще вопрос как же оценивать вероятностное распределение тут я низко вариантов есть байесовский метод и иногда алгоритм называется бойцовскими бандитами но я стою использовать то у вас в коде на секунду с будут какие-то сложные формулы а я не люблю сложные формулы копировать со страницы википедии вдруг на этой странице ошибка можно оценивать параметрически предположить что наши распределение они принадлежат каком-то семейства случайных величин например гамма распределения но там тоже формула получится сложная да а есть вариант он как бы для тех кому лениво это оценивать нормальное распределение но это полностью невежественно абсолютно неверно потому что мы же у нас случайно величина это время выполнение кода время выполняя кода по крайней мере не может быть отрицательным а нормально распределенного у нас я сама его пасу мб леру им может вернуть отрицательное значение значит этот вариант для тех кому лениво но именно его мы используем потому что как ни странно он работает работает потому что ну когда достаточно статистике то все равно будет плотность этого распределение там сходиться ну и как вы знаете я с агама распределение взять и там параметр увеличивать и все это нормализовываться тоже должен будет нормально и распределим в общем нормально работает вот и после того как я выяснил что значит зависит от модели процессора я решил посмотреть каким процессора у меня есть условно говоря под столом и вот тут 13 разных вариантов есть куча пинту love и более-менее современной и какой-то раритет и процессора м да вот epic это такой свежайший процессор недавно выпустили замечательно всё работает есть парочка старых оптронов и вот последнее это какой-то кевин тендер x2 что это такое да это арма и это довольно интересно потому что как вы наверно уже догадались на арме все мои оптимизации надо переписывать ну я переписал вот итак у меня есть 13 серверов на каждого из них и я значит собрал datasat и в нем почему-то получилось 10 6 файлов но это совпадение я специально не подбирал самых разных из данных браузера метрики директор данные полета в сша и 6 вариантов алгоритма смотрите есть референсный алгоритм потом есть 4 варианта между котором я выбираю и есть еще один супер вариант который запускает любой из этих четырех согласно методу многорукий бандитов и на всяк случай каждый тест запускаю прилично хотя бы 10 раз и получается 200 тысяч вариантов и все это можно сравнивать между собой и результаты такие что адаптивный алгоритм на современных процессорах intel ускоряет где-то на 13 17 процентов а если взять современный процессор то там даже почти 20 процентов и адаптивную алгоритм всегда выигрывает а нашелся только один какой-то очень старый сервер на нем было замедление на 1 процент даже на армия есть выигрыш хотя там что-то так быстрый капа активизировал ставил инструкции вектор тайбл lookup и даже не уверен что я сделал всё что можно тем не менее получил плюс 3 4 процента и интересный вывод еще то что я значит померил все варианты и адаптивный алгоритм на всех процессорах в среднем на нашем dota сети лучше чем я собой наперёд заранее выбрали какой-то один вариант например я сам я просто поставив продакшен варанс а счас я инструкциями shuffle и 16 мой хуй оба в среднем получилось хуже то есть много руке бандиты позволяют нам выиграть не не сразу тропе намаз конкретным например конкретно там первый алгоритм конкретно там второй алгоритм и естественно с референсным который оригинальная реализация за 4 вот тут наверно стоит сделать отступление большой вот я яндексе работаю в отделе который называется отдел инфраструктуры хранения обработки данных что мы делаем мы переставляем байт из одного места в другое собственно как я на слайдах показывал но вот мы сидим своей комнате никого не трогаем на до нас доходят слухи что в соседях отделах люди делают самое здесь и автомобили умные говорящие колонки занимаются машинным обучением да это сайнс искусственным интеллектом между прочим мы тоже хотим и вот я услышал в коридоре этим на груди бандиты сразу оставил это свой код помогло так ну на этом все спасибо теперь вопросы а давай да лучшим микрофон 1 раз о работает даже голос как бы как у робота ну ну ладно принципе как она кажется на слайде смерти 5 бак а может быть нет недавно последний раз не считаем себя там написано что иначе гипотеза такая что он обрабатывает хвосты если я правильно помню в какой-то светлый момент времени у него половина тормозов была не из за того что он обрабатывает хвосты а из за того что он обрабатывает бошки потому что он выравнивал ся на границу 4 8 16 байт сначала после этого долбил move up some они в move up some как здесь а после этого еще хвостик доживал до начала он эту машинку долбанную разворачивал чтобы вы равняться на 16 только потом начинал долбить по 16 байт мама псами и после этого еще хвостик зажимал но последний раз мем себя я читал несколько лет назад собственно вопрос неужели сегодня они начали пользоваться move купцами и поэтому бошки не читают тут конечно стоит сразу спросить о какой именно me ames опять только рецепшн и когда ест если псину из какой версии lipsy там ведь еще есть ужасная лишь эта version ность символов ну не будем рассматривать вот а какой мир себя использоваться в к хаусе как ни странно не такой специальный китайский нам считай это это я не шучу все действительно так же китайская подделка да и там могут сада почему это потому что значит есть такая легенда который имеет под собой основание то что читать и писать панируем адресом это плохо и сейчас это легенда частичного старела в общем неплохо и как ни странно даже на армию архитектура or часа 4 не тормозит все нормально хотя может быть я не проверял так что именно обрабатывать как вы говорите бошки они хвастики уже в общем это можно не делать это в курсе вот коллекции несколько лет назад был нет соответственно интересно научился или нет или в греции вообще не смотрел я смотрел конечно но я сейчас не помню по моему все таки он обрабатывает начала все-таки но я не уверен что смотрел самую новую версию но это на самом деле неправильно самый новый смотреть все равно ее в продавший через пять лет раз катишь и вторая половина вопроса про mmx именно про mmx и shuffle и наймом exe да значит насколько я помню из годов древних и там pentium 200 mmx там и потом немного там основная проблема с этим было что после фарша самого с инструкциями ты вынужден делать ей мм с для того он долбит все флот регистры и в общем нехорошо получается но и опять полтора вопрос как бы основные тормоза ему микс вариантом в этом или нет и если в этом-то а почему так то блокер вроде достаточно большие ей мы можем амортизировать ваш ответ абсолютно верной и лучше того чего я даже долл вообще все идеально сказано да почему я вам их снизу использовать я начал использовать и после этого потратил полдня потому что у меня в другом месте абсолютно никак не связанным был бедолаг а почему был бедолаг потому что там она рвет map для ног драться тонн лицензируется двумя операторами мы вычисляли множество ними розницу еще там был фактор фил фактор максимальный long дабл донк добыл использует как раз этот x 87 у которого составим надо сбрасывать и я сначала палка потратил чтобы сделать минимальный пример потому что вот я человек менее опытные чем вы я про это просто не знал действительно надо после работы с ними вызывать инструкция сбросить mmx состоит и конечно ее можно сделать один раз после целого блока это не будет тормозить но я сама посмотрим просто на наши данные как работает эта инструкция shuffle то она работает одинаково что такие регистра что такие и я совершу я действительно попросил пользователь выделить больше памяти мне не нужны лишние проявки то у меня будет бесплатно обрабатывать сразу 16 байт пусть должны 2 плен к это мусор ну то есть смысла нет и нет понятное дело что сегодня смысла нет последние 10 лет начиная с них алимов когда я счас едут 4 по-моему . 2 появился другое дело что если очень хочется сделать фолд для каких-то древних процессоров то был вопрос не неужели там есть перформанс проблемы с индексом вроде ее можно избежать а я вот даже не знаю честно говоря им тоже не стал тестировать если еще просто любопытно вдруг я на эту задачу потратил очень много времени я надеюсь что сейчас я ее закрою спасибо"
}