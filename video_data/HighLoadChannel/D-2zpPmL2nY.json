{
  "video_id": "D-2zpPmL2nY",
  "channel": "HighLoadChannel",
  "title": "Множественное наследование в Lua / Сергей Леляков (IPONWEB)",
  "views": 420,
  "duration": 2246,
  "published": "2019-05-14T14:41:40-07:00",
  "text": "всем добрый день меня зовут сергей я работаю ведущему разработчиками архитектором в компания apple в мы в компании разрабатываем платформы для рынка онлайн-рекламы разрабатываемых более 10 лет и делаем это в том числе с использованием в сегодня я хотела бы рассказать о том как мы в нашу платформу в мире внедряли компонентный подход вместе с объектно-ориентированным подходом поддерживаем множественные наследования и зачем на вообще все это понадобилось но сначала я хотел бы рассказать небольшую историю когда то давным давно когда деревья были большие а рынок онлайн-рекламы был очень маленький было достаточно маленькое количество пользователей владельцев веб-сайтов рекламодателей и рекламодателя напрямую общались с владельцами веб-сайтов чтобы вставить баннер на их странички все было замечательно рынок рос количество сайтов количество рекламодателей росло взаимоотношения между ними усложнялись приходилось договариваться с новыми и новыми партнерами в конце концов такая схема просто перестала работать и тогда пришли баннер объемные сети на смену всему этому эти бани раненые сети взяли на себя функции по связыванию множество владельцев сайтов с рекламодателями при этом они еще и стали выбирать какой трафик для каких рекламодатель лучше всего показывать для этого они использовали множество разных фильтров с разными настройками и какое-то время эта схема тоже хорошо работала но рынок продолжал расти рекламодателей и сайтов становилась всё больше и больше оба не разминки и за ростом рынках не успевали и не могли предложить рекламодателям достаточно обширный трафик ну как известно спрос рождает предложение и поэтому на смену банер нам сетям пришли 2 programmatic платформы одна платформа работала с рекламодателями другой платформы работала с владельцами сайтов при этом они также предоставляли возможность фильтровать трафик расширение аудитории происходило за счет того что эти со эти платформы сами между собой начинали интегрироваться немного о том как вообще мы все это называем и счас пили satelite сапой сайт форм эта платформа которая представляет владельцев веб-сайтов и продает и пытается продать от их имени трафик то есть пытается продать их рекламные слоты на сайтах с другой стороны есть 10 pir она же диман сайт plate вам это такие же агенты только для рекламодателей от имени рекламодатели они попытаются у из sp выкупить эти самые рекламные slade и чтобы показать там рекламу своих рекламодателей то gettin или как мы его называем таргетинг это фильтры либо группы фильтров которые по каким то параметрам отсеивают ненужный трафика как они вообще между собой взаимодействуют когда пользователь заходит на сайт сайт от его имени посылает запросов и со спид на то чтобы пользователь показалось реклама и со спин пропускает такой запрос через свой фильтр трафика понимает какие действия лучше всего купит этот трафик и отправляет запрос и именно этим действия с другой стороны когда где и приходит запросы от ссп а действий точно также пропускает этот трафик через свои фильтры и решает стоит ли вообще покупать у этого из аспирин рекламные места или проще вообще ничего не отвечать резонный вопрос а где вообще во всей этой схеме находится lua на самом деле лот находится и томатом потому что мы пишем бизнес-решения исключительно на lua и для сайт платформу и для demand давайте чуть поподробнее про логику таргетингов эти самые таргет и выполняются по очереди то есть когда к нам пришел запрос от пользователя по цепочка начинает выполняться там геотаргетинга таргетинга по типу устройства с которых зашел пользователя по демографии еще по каким-то признакам и они в принципе практически идентичные что на одной платформе что на другой именно по на основе этих таргетингов я их буду строить свой дальнейший рассказ как эти таргетинга устроен внутри но в принципе там ничего сложного за каждый фильтр отвечает своя функция эта функция принимает на вход параметры для фильтрации и какой то какие то данные о пользователе дальше идет проверка пришли ли данные по котором нужно проверить пользователи если такие данные не пришли то значит в нам в принципе от проверка не интересно все хорошо мы можем сказать что даму например хотим купить этого пользователя а если данные пришли если параметры фильтрации пришли но у нас нету данных это значит что мы такого пользователя просто определить не можем и нам проще ему вообще ничего не показывать чем пытаться еще что цинк сделать и в этом случае фильтр возвращает значение ложь если у нас все хорошо есть параметры есть данные мы пытаемся определить а собственно говоря сходится одно с другим то есть походит проходит ли проверка если проверка прошла мы возвращаем истинное значение и дальше пытаемся купить это рекламы если ну и в противном случае им просто фильтра завершает свою работу со знач на со значением ложь как эти фильтры вызываются есть папки для каждого фильтр есть своя собственная функция в эту функцию передается кусочек общих настроек для фильтров передается кусочек данных а пользователя и дальше эти фильтра что-то делает таких фильтров в проектах как правило не один и не два для каждого фильтра приходится передавать параметры которые характерны именно для этого фильтра и для каждого из этих фильтров есть своя собственная проверка выхода из за обработки входящего запроса если все фильтры вернулись тянут а в конце концов мы начинаем нормально обрабатывать запросы делаем там какие-то ставки либо начинают либо показываем рекламу не знаю как вот вы относится к этому коду у меня он вызывает тихий ужас я совершенно не знаю как поддерживать такой код как его развивать и не представляю что может произойти если взять кусок этого кода и скопипастил в другой проект взорвется там не взорвется как бы сказать очень сложно ну ужаса же сама делать с этим что-то надо при этом надо делать с учетом того что у нас множество много разработчиков множество проектов и этих проектов гораздо больше чем разработчиков получается причем регулярно в эти проекты прилетают новые бизнес кейсы и зачастую они либо одинаковые либо очень похожи в каждом из проектов ответом для нас стало компонентные программирование которое позволило бы разделить код на независимые компоненты содержащие какой-то функционал и это нам дало бы за счет того что эти компоненты работают независимо единую базу решений при этом каждый раз когда какое-то решение возникало бы мы добавляли бы его в единую базу и она бы решал это делалось ровно один раз а если задача прихват приходила бы какая-то крупная ее можно было разделить на несколько маленьких компоненты каждый компонент разработать в отдельности то есть несколько разработчиков могли бы работать на такой задачи параллельно а как в этом случае стали бы выглядеть наши таргетинга ну тогда это уже был бы нет такой список как примере каждый таргетинг можно было бы представить семена отдельным блоком при этом о том принт или решение или нет как бы из каждого из одного блока в другой переходила бы просто проверка для того чтобы к этому прийти нам перво-наперво нужно как-то развязать код первые что мы для этого сделаем это вместо того чтобы в каждом фильтре принимать на вход свой собственный кусочек данных мы будем принимать параметры для фильтрации и параметры пользователя целиком дальше мы из общего списка параметров выберем им то что относится именно к данному фильтру проверим точно также есть эти данные или нет если их нет вернем значение истины если есть попытаемся из в данном случае request of достать интересующую нас информацию точно также проверим доступны ли она и если не достанут оттого вернем ложь и потом проверим а соответствует ли эта дата параметрам таргетинга и вернём результат да или нет для того чтобы все эти функции каким-то образом вынести и использовать более просто мы их просто добавим в lua табличку сделаем обертку в виде функции пастор getting который на вход принимает те же самые параметры внутри себя она в цикле прогонит каждое из этих фильтров проверит что он возвращает если какой-то из фильтров вернула что она про завершится сам код проекта при этом становится гораздо лучше то есть уходит сейф и вместо этого ровно одна проверка и ровно один вызов функции но все равно остаются вопросы вот над рефакторинга код а каким образом его можно расшарить между проектами и между разработчиками как избежать copy paste off как упростить работу с этим кодом как в принципе упростить поддержку вот из добавления новых таргетингов тут мы посмотрели в сторону объектного объектно-ориентированного программирования с поддержкой множественного наследования что это нам дает поскольку мы можем создать некоторые классы унаследованные вместо одного родителя от 2 3 5 мы можем одному классу присвоить кучу независимых функционалов из разных компонентов при этом получается что основная как был и который в соединить все соединяет она остается в проекте но все компоненты уезжают опять же в куда-то в общее решение помимо этого если мы говорим о опыту мы сразу получаем избавление от сильно связанного кода поскольку есть такое понятие как инкапсуляция еще мы можем создать создать доменную модель нашего проектов попробовать использовать объектно-ориентированной паттерна разработки и у нас появляется такая штука как unit тестирование полноценная и за всем этом нестись на стоят огромные наработки огромная база данных ну для того чтобы выбрать собственную библиотеку которая будет работать в режиме множественное наследование мы должны сначала определить какие в принципе книг требования нашей платформы работают как http сервера при этом у них есть два этапа и так загрузки и так выполнить многопоточное выполнения когда приходит запросам этапе загрузки мы сразу подгружаем все доступные нам модули ло и дальше мы их на копа . во время выполнения просто их используем кроме того у нас есть много статичных данных которые мы также загружаем в память на этапе загрузки и внешние данные который к нам приходит из request of либо моих тянем сети и баз данных кроме того у нас есть еще наша внутренняя среда разработки про который наверное многие наслышаны который каким-то образом изолирует ла кот в ней к сожалению запрещенные некоторые функции ровно поэтому мы первоначально когда хотели использовать металл класс не смогли этого сделать потому что внедрение толкался используется две запрещено у нас функции руки гитару set мы пытались искать другие какие-то решения но ничего более менее нормальную вменяемую не нашли немножко взгрустнула но делать нечего как написано в книжке господина иерусалимского если в лаву чего-то нет сделайте это сами и мы реализовали свое собственное объектно-ориентированное программирование с поддержку для того чтобы объяснить как оно работает я взял из той же книжки два примера чуть-чуть их модифицировал свел их к одной задачи когда требуется может и наследование это когда у нас есть задача сделать специальный аккаунт который работает с одновременной из и со счетом из именем клиента при этом у нас получается что спешил аккаунт унаследован наследуется от класса name яко от и от класса аккаунт но внутри нашего представления на самом деле эта цепочка на следа это множественное наследование превращается вот в такую цепочку то есть спешил аккаунт наследуется от на им не наследуется аккаунт и аккаунт наследуется от внутреннего базового класса давайте посмотрим как это в принципе выглядит у нас в lua коде посмотрим как устроен классный как видно из кода на самом деле наймит это не класс амиксин мы его определяем с помощью конструктора миксин предварительно его бы загрузив и хочу в этом месяце сразу сказать что первая строчка где у нас погружается миксин больше нигде в коде использоваться не будет мы будем считать что этот конструктор у нас уже определен дальше есть какой-то конструктор объектов и внутри у него есть вот такая вот несколько странной структурка может возникнуть резонный вопрос а зачем вот так вот сложно обращаться классу родителю для того чтобы это продемонстрировать я введу в пример еще 1 класс реп от который должен работать и строить допустим отчеты по всем именным счетам при этом у него функционала который отвечает за работу с именами ровно такой же как у класса спешиал аккаунт согласитесь что писать два одинаковых класса для этого смысла нет проще у наследуется от того же классный по идее в этом случае у нас должны получиться 2 вот такие независимые цепочки наследования но на самом деле все немножко не так эти две цепочки наследования сводится вот к такому виду то есть они обе эти цепочки проходят через элемент name 1 при этом уходят в аккаунт другая сразу наследуется от базового класса и тут встает вопрос а вот когда мы находимся внутри класса name и вызываемая родительский метод new какой нам из методов нужно дернуть new на аккаунте или new или сразу не на базовом классе вот ровно для этого и введена в вызове супер переменной которая содержит себе либо класс наследник либо объект этого класса то есть таким образом мы понимаем по какой цепочке наследование мы сейчас именно идем и понимаем . он в этой цепочке наследования за которые должны какие-то стоять родительские методы теперь мы знаем как работает супер дальше мы уже спокойно обращаемся к методу нее нашего родительского класса при нами при этом нам совершенно все равно что это за родительский класс и там стоит определяем какой то внутренний метод который работает там с именами счета и возвращаем наш класс в этой строчке я тоже написал летим дальше этого таких стручками не встреть но имейте ввиду что когда я бы дать дальше буду говорить о классах эти строчки подразумеваются эти строчки позволяют нам однозначно привязать наши классы к модулям в которых они лежат то есть когда мы делаем рекламе какому-то модулем автоматически получаем доступ класс внутрь и посмотрим как устроен квас аккаунт ну в принципе он не сильно отличается от класса номер единственно что у него вместо конструктора класса и конструкторами миксина используются конструктор класса внутри точно такая же получается обертка вокруг родительского мета данью возвращающего объект есть какой-то метод который работает со счетом и собственно сам спешил аккаунт который нас интересовал тут чуть-чуть отличается в данном случае мы этот класс наследуем сразу от двух классов от name этот аккаунт при этом в отличие от middle class а здесь мы вместо того чтобы передавать заранее загружу загруженные подготовленные ссылки на какие-то классы мы просто передаём именно модули в которых эти класса лежат на самом деле у нас поддерживается оба варианта то есть можно туда и класса передавать дальше мы видим ровно такой же такую же обертку вокруг конструктор объекта метод который работает как-то специализируется работу с со счетом при этом в этом методе вызывается еще один метод s-class родителей в принципе все сводится к достаточно простой в работе с родительскими классами и здесь даже не надо особо задуматься множественного наследования или обычная мы вернемся к нашим таргетингом для того чтобы унифицировать работу с ними мы для каждого фильтра в вернo добавим метод пас который возвращает значение истина или ложь добавим введём новый метод пастор getting который работает примерно так так же как и функции постарается не в предыдущем примере и создадим еще один репозиторий который будет доступен во всех проектах которые здесь называется common помимо этого мы еще применим два таких паттерна как цепочка обязанностей и фасад как работает цепочка обязанностей на самом деле это некоторая последовательность обработчиков на вход которым входит какой-то запрос и дальше он но от обработчика carbo veg обработчика передается до самого конца либо если какой-то за обработчик при обработчиков принял решение что дальше обрабатывать нельзя цепочка обработки прерывается фасад же предоставляет унифицированный интерфейс к какой-то внутренней системе вместо того чтобы использовать ее сложный интерфейс а этот интерфейс достать делается простым давайте посмотрим как у нас изменился наш проект мы его распилили на 6 классов при этом практически весь функционал уехал в общей репозитории а в проекте остались только вот чисто специфики этого этого проекта как это устроено изнутри начнем с конца у нас есть абстрактный класс фильтр который внутри содержит ровно один метод возвращающий всегда значение true от этого абстрактного фильтра дальше наследуется все остальные фильтры у каждого из этих фильтров свой собственный метод пас внутри они выглядят следующим образом сначала мы наследуем ся от абстрактного фильтра дальше в конструкторе мы из параметров конструктора объекта входящего в конструктор объекта определяем выбираем нужные для конкретного фильтра данные сохраняем их во внутреннем состоянии объекта внутри функции пас мы принимаем на вход все тот же request делаем всю ту же проверку на то что у нас в рекой если есть данные на то что у нас есть данные фильтрации если эта проверка не проходит мы возвращаем значение fools но если эта проверка проходит за счет вот этой самой цепочки обязанностей мы передаем направления другому обработчику то есть другому фильтру с таким же методом паз для того чтобы все эти фильтра каким-то образом в проекте объединить был сделан агрегатор фильтров внутри он устроен ну совсем просто то есть мы просто берем и перечисляем все фильтры от которые должны быть проекте то есть мы просто следуем ся от всех фильтров при этом получается что на классе very fair у нас собираются все методы пас всех этих фильтров и соответственно все метода new дальше нам каким-то образом этот агрегатор нужно подключить к нашей системе вот здесь как раз мы используем фасад у нас есть класс таргетинг который подгружает very fair в конструкторе он призывает в конструкторе объекта он создает внутренний объект объект verify и дальше на функции поставки тем он просто запускает эту самую цепочку обработчиков внутри фильтров и поскольку мы перешли от функционального к объектам у стилю саму платформа нам тоже чуть-чуть пришлось подправить она стала выглядеть следующим образом у нас есть какой-то классном из а спереди испеку наследований от таргетингов есть метод процесс request который был в прошлом примере и в данном случае мы просто вызываем метод пастор getting которые мы унаследовали от фасада таргетинг то есть здесь код почти не изменился по сравнению с кодом после рефакторинга в этом месте поскольку мы уже добились своих целей хотелось бы оценить а что мы приобрели что мы проиграли в плане производительности к сожалению мы не делали замеров на проекте до и после рефакторинга но оценить насколько удачной стала наша реализация аоп и масть мы смогли для этого мы взяли тесты самых библиотеки middle class с которой мы изначально пытались работать чуть чуть их допилили под нас и запустили наложите первый раз результат нас несколько обескуражил и огорчил создание классов в наш реализации оказалась практически в три раза медленнее чем это делает middle class но с другой стороны если учесть что все классы которые мы используем у нас подгружаются и создаются на этапе загрузки это кажется не так страшно потому что плюс минус 10 миллисекунд ко времени запуска сервера это практически ничего а дальше картинка существенно поменялась время создания на объектов на классах первого уровня то есть от классов которые ни от кого не наследуются у нас оказалась на 15 процентов меньше чем в металл классе тоже самое но при унаследованных классах там разница больше чем два раза оказалось то есть наша как раз более сложные классы создавали объекты получается вот в два раза быстрее чем это делает me туркласс и тест на вызов методов которые были унаследован от класса родителя тоже дал вот такие странные результаты то есть у нас вызов тайна методов которые унаследовали от класса родители оказались на 40 процентов быстрее чем в не только металл классе другие тесты при этом показали примерно одинаковое время ну давайте подведем итоги нам удалось таких пилить компонент на компонентное программировании мы сделали это на основе нашей собственной реализации ооп с множественным наследованием при этом у нас ничего не взорвалось с точки зрения разработчиков мы получили слабо связанный код в проектах то есть избавились от макарон нам все еще остался доступен поэтапный рефакторинг проектов то есть мы могли вот эти самые компоненты внедрять в наши проекты постепенно вместо того чтобы переписывать проекта целиком на тех проектах которые у нас были переписаны у нас перри использование кода выросла более чем до 80 процентов то есть осталось примерно 20 процентов логике внутри проектов объем проектов при этом уменьшился с двух с половиной тысяч строк всего до 330 с точки зрения менеджмента тоже все оказалось очень хорошо если раньше у нас в среднем два разработчика поддерживали три проекта то на новой системе у нас три разработчик тянут 12 проектов при этом запуска новых проектов у нас ускорился там 40 45 дней до 15 сложность самих проектов у нас за счет опять же за счет того что все сложные улыбка мы вынесли куда-то в общее решение сильно снизилась то есть порог вхождения разработчиков достаточно небольшим стажем стал или вишни и сильно ниже плюс мы получили стандартизацию что я под этим имею ввиду проекта у нас стали похожи один на другой то есть в случае необходимости всегда можно взять разработчик с одного проекта и перевести на другой при этом он не затратить много усилий на то чтобы вникнуть в то что там происходит на этом все буду рад ответить на ваши вопросы так вопросы спасибо за доклад у меня такой такого плана ближе микрофон пожара да вы можете описать вкратце в чем отличие миксина от класса потому что ну самые такой значимое отличие nexen не может открыть наследоваться от класса и у него нет собственного конструктора объекта то есть nexen он цель миксина это расширить функционал без создания сам самого гена без возможности создать перед сам объект при этом то есть такой не до класс получается хорошо а если меня класс наследуется от двух трех четырех классов как это было позади я так понял он вызывает методы последовательно один за другим да то есть я не могу новость метод 3 наследника напрямую можно очень постараться это сделать на самом деле там где я приводил пример с тем как устроено внутри обращение к классу родителей нам для того чтобы взять конкретный метод нужно всего лишь две переменные это класс который есть в цепочке наследования и это конечный класс который конечно и дать дочерний класс либо объект где вот этого цепочки присутствует вот этот самый класс взяв вот эти две точки мы получаем точное место в цепочке наследования соответствие получаем точный метод этого класса либо класс родителей и последний вопрос про тесты вы сказали что вы тестировали middle class на лоджии 2012 свой путь и тестировали свой реализации каких-то там же наложит то есть просто написали два одинаковых теста рядышком в одном файле кир запустили получили два времени спасибо для коротеньким вопросом у что-то упустила ваша реализации библиотеки на в open source или она закрыта я не услышал вообще нет нет нет ну пока она несколько старовата для того чтобы и выкладывать сообщество поможет то есть у него релиза или релиза аллфин в общем пока лет пока нет но ожидать стоит да ну там внутри пытаем сейчас решить проблемы с тем как и лицензии использовать как поддерживать все остальное но имейте хоть с леди где следить можно канал информация какие то есть пока не вот там вот телеграм-чате клон маску антон солдатов туда напишет новости да надо добавится ясность спасибо еще вопросы спасибо потому что такого правительства с разумовским стандартным конструктором классов и и ваш самописный а то просто показать из того что было что стало с тем что было раньше то есть объект на ну куда пошла чудес не бывает по понятное дело что деградации по производительности было я об этом сказал мы к сожалению не проверяли на конкретном проекте до и после но если сравнивать по проектам которые работают на старой системе и на новый там деградации где-то составляет порядка 50 процентов большая деградат но до 7 секунд против четырёх это очень серьезным для нас но с другой стороны время затраченное на поиски разработчиков временно падет затраченные разработчиками на поддержку она с лихвой окупается просто 2 двумя тремя дополнительными серверами а вы рассматривали другие подходы к организации код они у пышные ну у нас на самом деле в компании есть еще одно подразделение которое релиза реализовала нечто похожее на питоне мы посмотрели как это сделано у них и передрали иди и то есть нас нам было с кого копировать поэтому особым это вот на функциональные не смотрели еще сама спасибо за доклад фундаментальный вопрос пропустить их а это наш чем написано в это начисто мало чисто его чистый ванильный говорит player было непонятно я буквально в эту же сторону просто добавлю помощью вопрос связан у вас на lua полностью все приложения или это внутренняя часть вот жить там работает а вас там допустим как-то обвязка принимает request и конкретно вашей провожу не что нет у нас есть http сервер написаны на сяк в этом что-то по сервере запускается юджин о котором все раньше дальше понял все это есть на всех обвязка обмена принимает connect еще раз такой маленький вопрос у вас когда происходит сантор denchik вы друг за другом вызываете фильтра это прямо так почему бы не вызываете и параллельно и кто первый сказал нет так и все или есть еще кое-то более сложного к агрегации ну здесь естественно все сильно упрощенном в примерах у нас такие цепочки периодически прерываются на какие-то другие проверки плюс мы обрабатываем request то есть каждый request обрабатывается у нас в об одной в одном потоке собственно ш обвязка вот как раз и упрощает задачу разработчиков этой семени нации какать между к рутинами считается что они как будто пишут как на обычном языке без крутим коллегия просто еще и фильм не интегрировали еще вопросы ну хорошо так лучший вопрос сложно сложно ну да спасибо"
}