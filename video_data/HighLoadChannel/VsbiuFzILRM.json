{
  "video_id": "VsbiuFzILRM",
  "channel": "HighLoadChannel",
  "title": "Переход от Rest API к GraphQL на примере трех реальных проектов / Антон Морев (Wormsoft)",
  "views": 3983,
  "duration": 2431,
  "published": "2020-07-17T06:46:25-07:00",
  "text": "меня зовут мари фонтан я являюсь основателем компании warmth of the мы занимаемся процессами автоматизации бизнес-процессов сайт в мобильных приложениях и в основном в приложения и прежде чем я начну рассказывать про сам граф келья хотел бы виснут вернуться немного к основам как в принципе происходит взаимодействие в клиент-серверном приложение у нас есть клиентское приложение это не важно будь то мобильное приложение или веб-приложение в браузере есть api и уже api и обращается в базу данных кэш в очередь и так далее вот о чем appy appy является главным посредником и самые первые способ решения данных построения api которая приходит голову и the rest простые get под вопрос spot patch запросы получили запрос получили ответ способа рабочий но в нем есть некоторые недостатки первое о чем стоит думать при разработке api это документации документации это то что по сути дела этапе возможным к использованию документированию есть несколько основных подходов способов первый способ это отсутствие документации при этом подходе мы абсолютно легко сталкиваться с проблемами поддержки это документации и но при этом позволяет очень быстро и просто строить какие-то прототипы следующий способ так называемые мудрец это когда в какой-то компании есть один человек который разработал эту api и при необходимости получить какую-то информацию поэтому api все люди идут к нему следующий способ это уже большой прогресс это хранение документации в виде каких-либо файлов word excel угол док почему-то до сих пор некоторые даже крупная эти компании используются и пиксель как способ крайней документации и следующий способ которым мы в итоге пришли на котором мы остановились при разработке растопи это использование инструментов документации swagger удобное интерактивное позволяет делать автоматическую генерацию документации к пии на основании кода но хорошо первый вопрос документации закрыт следующий вопрос который приходится так или иначе решать при разработке api это разграничение данных и вот тут мы приходим к первому моему примеру где мы перешли от растопи графики ель это интернет магазин в интернет магазине есть много разных сущностей но основная самая важная сущность это товар товар участвует в большом количестве бизнес-процессов и по сути на название товара держится весь бизнес интернет магазинов в сегодняшнем примере рассмотрю плюсы переходы не во всех бизнес-процессах даже не 5 а только в трех это в каталоге товаров в корзине и в карточке товара какие же могут быть способы реализации данных которые будут давать сервер со стороны api первое это сделать один одну модель 1 класс нам назвать его допустим all our own product и в нем будет информация допустим мы сделаем простой интернет магазин в которого есть у товаров есть только название цена проходит время интернет-магазин разрастается появляется еще поля описание и бренд проходит еще во время появляются связанные продукты фотографии допустим еще так же товар участвовать в корзине после этого появляется отзывы вариации товаров модели разрастается класс разрастается и что самое главное появляется очень много свойств которые для получения которых может ходить в другие источники дополнительные запросы к базе данных и так далее получается у нас при получении модели мы делаем много лишних запросов которые не несут никакого смысла решить эту проблему можно также несколькими способами например делать свою модель под каждую ситуацию это вот например у нас случается класс под карточку товара со всеми полями которые нужны в карточке classpath связаны под отображение товаров связанных продуктах и классные отображение в списке и настена с тем этом строится строится один героический класс эротическая модель который содержит себе вот каждые воплощение данной сущности под каждый бизнес-процесс вот но как быть с количеством запросов у нас получается если у нас 1 1 на 1 странице несколько вариаций разных несколько вариаций модели товаров нам получается над делать для для одной странице сколько запросов первый способ который мы для начала у себя интегрировали и успешно использует язык запросов то есть это при запросе copia мы указываем какие поля у какого слышались нам нужно получить вот и в ответ и афинами дает только эти поля которые нам нужны и в целом это способа работал отлично до тех пор пока они не случилось переполнение запросов какое количество полей сначала мы получали как эти поля которым нужны название описание цены затем добавляются связанные товары а затем появляется забыл опросы подобные этому приказу в котором разобраться не является принцип является возможным но не является удобным то есть вот принципе видно вот а общая информация информация по отзывам фотографии а потом еще сверху на в карточке появляются связанные товары и еще появляется информация о скидках и таким образом у нас запрос получается очень-очень длинная и работать не становится крайне неудобно вот и постоянно при разработке норрис приходится балансировать между тем что вы делать все в один запрос и неудобно как я показал в примере раньше либо делать много запросов но при этом году удобно поддерживаем на работу на много запросов что тоже несет с собой свои недостатки в поиске решения которое закрывает сразу несколько вопросов а именно чтобы было невозможно писать api невыполнение не пополняя документацию чтобы можно было выбирать информацию которую нужно нам получить и не и и не забирает у информация которая нам не нужна и чтобы например можно было сразу несколько разных слушать в одном запросе получить видимо фэйсбук с такой проблемой тоже столкнуться и они разработали граф келли как данный вопрос мы бы решали бы мы решаем на php используя графики ель у нас есть описание схемы товара вот в данном случае мы видим аргументы это иди входящий параметр по которым мы получаем товар и поля товар это иди название описания описываю строгой со строгой типизации типа идеи строка строка и в ней внизу функцию резал в которые выполняют в реализует мойку получение данных из базы ярус сделал простой пример без каких-либо контейнеров и так далее чтобы было понятно о чем идет речь вот следующий этап это построение запроса запрос нас выглядит примерно следующим образом тут у нас все тот же иди который мы принимаем на запросы и поля который нам нужно получить тайтла дискрипшн и в ответ мы получаем те самые тайтлы диск refin которые нам нужны допустим проект разрастается и в каких-то местах нужно отобразить вариации данного товара ну допустим разные размеры товара разные там названы наше случает интернет магазин парфюмерии там разные банк баночки вот этот для этого товара мы добавляем новую под сущность называем это вариант в список его как поле рядом с полем тайтла description и описываем его тип и с функцию для ее получения в данном случае у нас есть свой новый тип необычно скалярная пути product вариант type о котором я скажу чуть позже и так и таким образом запросто трансформируется в нечто подобное у нас появляется поле вариант вот и в ответе мы получим примерно следует следующую картину у нас приходит массив в рим варианты вариантов данного товара а сам продукт вариант type выглядит примерно следующим образом вот в данном примере есть тут еще добавились поля которых не было в запросе это цена скидки и модель картинки которые мы используем дальше в карточке данства предыдущем запросим его не запрашивали он просто тихо-мирно остается в памяти сервера и не перегружает hdpi и не приближает клиенты лишними данными которые не используется на основании этого небольшого кода у нас получается удобно интерактивной документации вот выглядит на примерно следующим образом нас и сущность товара с полями которые мы описали можно нажать на интересующие нас поля данном случае вариант а у поля в поле вариант это массив из продукт вариант и у него есть те поля которые мы описали и мы так можем до бесконечности идти в глубь и и выяснять информацию по поводу всех полей которые используются на пи и как результат у нас процесс расширения api сильно сузился если раньше backend разработчику было пройти с целые процесс надо было встретиться с фронта интером обсудить что и где добавить какой запрос мы расширяем какой вопрос мы добавляем описать этот виде виде документации уже потом это реализовать то сейчас нам мы просто добавляем нужные поле в нужную сущности и описываю к его получения для начала можно даже сразу сделать мог данные чтобы frontend разработчики уже начинает с этим с этим интегрироваться на стороне фронтэнда процесс тоже сильно упростился вот если надо было раньше также общаться с бэк-энд разработчикам изучать документ изучать документацию описывать логику подключения к другому and point это в принципе не является проблемой но так или иначе удобнее держать все в одном месте при разработке хотя тоже спорно про судов или нет вот и вас этого используется поле после внедрения графики ели мы просто расширяем граф келли запрос который был уже построен до этого для для данной странице и вы используем поле которые нам нужно следующий проект который я хотел прийти к чисто пример это проект с микро сервисами у нас один из клиентов это криптовалютный банк вот детали газа не буду это не конференции не против на валюту но суть в сортире не разработки она следующая есть интерфейс есть ядро системы это так сказать api и есть два внешних сервис от которых мы зависим от крита валютной бирже и api самого кошелька криптовалют и на стороне боккен это выглядит примерно следующим образом у нас есть you и два приложения вот в нем есть модуль api и начиналось все с того что клиент подошел и сказал что это лишь маленький стартап нам нужно проверить идею разумеется мы особо об архитектуре не задумывались мы сделали минимум но не расширяли ipad микро сервис и прочим и сделали просто одинокий модуль который обращается уже напрямую в кэшировать и кошелька и и папе бирже но после этого у клиентов или повелели запросы на расширения функционала появился модуль по интеграции с почтовыми серверами модуль платежей модуль вывода вводов вывода денег там и пришлось сделать отдельный модуль авторизации которые используют другие сервисы другие приложения но и и наш и наш этот backend стал как публичная api и примерно следующим образом выглядел наш код у нас есть контроллер есть экшена и в нем мы реализуем свою логику вот и к к к к к к я говорил ранее мы использовали швагер и автоматически наса монеты формируется документация вот но в возникла следующая проблема некоторые сервисы пришлось переписывать php и на другие технологии у нас были как взвешенное решение перехода на другой язык как и не особо взвешены но суть остается следующий миф сервис бородки по работы с почтой переписали нога сервис платежей мы решили ну экспериментируйте изучить мы написали на react php отдельным сервисом вот после этого мы написали один сервис и под взаимодействие с биржами поскольку количество биржа осталось бы под каждый герой писали свой сервис без сервис для ввода выводов платежей и вы клиент клиент захотел реализовать чат которым конечно никто не пользовался потому что есть телеграм но клиент захотел мы реализовали отдельным микро сервисом взаимодействие с чатом и тут мы уже столкнулись прям очень сильно остр с проблемой документ документации у каждого вникай сервиса должна была быть документация для сервера сервера ядра и мы едва и где-то это решалось через про табов можно строили контракты и само действие 4 записи а где то подобным образом образом отрешить не получалось но и главная проблема была это строить документации для разработчиков интерфейсов вот поскольку я являлся главным ответственным за этот проект вот в итоге все кончилось тем что тем самым мудрецом стал я и взаимодействовал с интерфейс с разработчиками интерфейсов с разработчиком микро сервисов пытался как-то поддерживать актуальной документацию что в со временем перестало быть возможным вот но тут в пришел выход в виде слоя граф келли внутри самого сервера ядра приложения который в котором разработчики уже принудительно сами описывая описывая схему формировали документацию и из предыдущих контроллеров которые привел в примере мы перешли к ресиверам то есть резон жиры по сути реализовывали тут то же самое слой контроллеров только уже внутри схемы граф келли и как результат помимо автоматически формирует формируемой документации мы еще получили такую возможность как делать а и получения одним запросов информации с разных некой сервисов данном примере мы делаем запрос за транзакциями последними последними платежами это два разных сервиса не работать физически на разных машинах но в итоге получаем мы их все в одном запросе fontaine разработчиков перестала в принципе волновать что происходит за пределами гравировки ель слоя следующий проект который я хотел бы привести в качестве примера эта разработка обычного сайта и казалось бы зачем при разработке обычного сайта использовать графики ель ответ такой график ель он я бы не сказал что он является революционной технологией но он открывает очень большие возможности при для оптимизации процессов поскольку наше направление оптимизация бизнес-процессов и их автоматизация граф тилли позволил наши процесс разработки также автоматизировать как обычно мы зарабатываем сайтом и сайт кажется делается из трех кусков из трех положений есть сайт это надо садовской приложение с таким не фреймворком например view вот который собирает нужной информации пока его клеенку клиенту есть api сервер который хранить всю информацию о сущностях бизнес-логику обработку заявок и система оповещений и есть админ-панели это тоже джей с приложения на фары ну обычно без серверного рендеринга view приложения разрабатывая там сайт за сайтом приложение за приложением мы заметили то что очень много времени уходит на очень примитивные задачи а именно на процессы обработки примитивных простых сущностей вот который хотелось бы очень сильно автоматизировать вот но поскольку у нас стек не позволял сходу подключить какой-то готовый движок который это проблема бы решил нам пришлось так или иначе писать его помимо и первая версия нас было без графе ель и формат был примерно следующее в одном месте в коде описывается jason jason описание сущности какие у них поля как они друг с другом связаны и на основании этого фармер формируется автоматически схема графики ель резольвер для получения информации и интерфейс админ-панели хранится это все в manga тебе поскольку она схема лес и позволяет хранить и любовь любой формат данных любом был похож на джейсон вот выглядит примерно следующим образом есть джейсон описании поле это формирую приводит качестве зад слева отображается в поле в админ-панели а справа запрос как получать информацию по станциям метро вот один из клиентов находится не далеко от нас но недалеко от этого места и он он сдает рушится и вот например в качестве примера вот есть сущность который отображается на сайте это определенный офис вот и справа приведён пример запроса который нужно сделать для получения информации для этого офиса но сущность офисов она очень большая она используется много других бизнес-процессах мобильных приложениях системах интеграция с crm-системами и и везде работает графики ель и в каждом месте мы запрашиваем запрашиваем ровно то что нам нужно и процесс разработки каких-то простых примитивных приложений виде обычных сайтов и информационных очень сильно сузился если на бэг-энде это было те же самые там несколько этапов как случится интернет-магазином продумать что и как куда расположить то сейчас бэкон разработчику нас при разработке этих вещей просто обновляет джейсон файл конфигурации и на автомате формируется удобно и к используя схемы городке для фронтэнда автоматически он может запрашивать когда ему нужен то что ему нужно афронт enter и вместо того чтобы разбираться в документация граф кель начали разбираться в схемах не раз документация swagger а начали разбираться в документациях графин то есть у них процесс сильно не упростился но ускорился процесс получения новой информации или разработки но граф киеве он дает с приносит собой очень много плюсов и возможностей но это не серебряные пули у него есть ряд сложности ограничения с которыми приходится сталкиваться сегодня я вкратце расскажу про некоторые из них и первое что я хотел бы привести прям к чести пример это проблема n + 1 вот мы когда переходили на график ели в первом при внедрении любой технологии в компании мы сначала обкатываем это на своих внутренних проектов которые гуру гора песочница чтобы понять насколько много проблем технологии решает насколько много прольем технологии приносят вот и вот реальный пример у нас есть внутренний простой task manager который мы как раз для тестов используем и front-end разработчик сделал примерно вот такой запрос то есть мы запрашиваем задачу видите список задач и и в каждый элемент задача мы хотим получить под задачу вот и вот этот вот кусок с получение по задаче он оказался большой проблемой в том месте где у нас допустим 100 задач приходит запрос у нас еще будет обязательно дополнительных 100 запросов к базе для получения под задач что является недопустимым при разработке даже или даже не сотни высоконагруженных система просто любых систем у нас непредвиденное поведение сервер api на стороне php эта задача решается примерно следующим образом это у нас в резон very описывается такой класс как и где феррит он откладывает выполнение им еда и вода передачи его в ответ мы сохраняем иди по которому нам нужно получить информацию в будущем и при уже получением и один раз подгружаем для всех необходимых иди информацию и получаем информацию по этому иди вот это в принципе решение хорошие она решает данную проблему но она приносит с собой кучу других проблем как минимум тем что надо об этом постоянно задумываться если при разработке rest api мы не заморачиваться по поводу таких вещей то есть мы делали отдельный запрос за конкретными под задачами для на задача и front-end и не могли сломать наш букет дешёвым запросам то случае с графики ель об этом приходится думать постоянно следующее что можете на фронт enter он может сделать очень тяжелый запрос вот тут вроде бы проблему n + 1 решили но получить под задачи у нее под задачи по задаче под задачу это может быть фатально для системы особенно если сделать ещё несколько таких уровней и самый простой способ защиты от таких вещей то ограничения глубины запроса мы делаем глубину запросы меньше чем 4 и соответственно если глубина запросы больше чем 3 у нас сервер выдает в фонтане дыру ошибку и фронтэнда не может делать такие запросы вот но запрос может быть настолько сложным на первом уровне что это не будет сталкиваться с ограничением глубины но сервер все равно при этом ляжет или будет очень медленно вать ответ таким образом появилась следующие проблемы которые надо решать это ограничение сложности запрос а у нас на каждом уровне для каждого поля приходится описывать насколько тяжело это поле получаете описывать gedit и в своих единицах своих попугаях это просто но число и потом при формировании при отправке запрос на сервер сервер проводит анализ этого запроса вычисляет его сложность если сложность превышает максимальный порог запрос тоже остановлю останавливается и front in der не получаете чего то же решение хорошие работает но требует постоянной поддержке новых вещей которых раньше поддерживать мне приходилось вот и бывает стоит ограничение сложности 40 запросы фронт эндеры услышан tender делает запрос со сложностью 39 и это вроде бы не выходит за пределы ограничения но все равно это грузить сервер и таких о таких вещах приходится думаю постоянно но и следующая проблема которую на данный момент актуальны неизвестно сколько она будет актуальным через какое-то время это сложность адаптации разработчики в целом привыкли делать rest api некоторые разработчики привыкли просто рендерит на пешке готовый сайт и выпускать продакшном что тоже хорошо но при приучать к новой технологии в надо нам постоянно приходят новые разработчики расширение проектов и объяснять им как работать граф кейн это отнимает у нас частности у меня много времени то есть эта проблема пока еще актуальная и что с ней сделать я не знаю ну разве что только ждать когда граф киев будет более активно использоваться в качестве инструментов при разработке в лавке ель вот я для себя сформировал следующий список инструментов есть график и сервиса он хорош только тем что он сейчас от создателей самого граф келлер а в целом продукт он уже довольно устаревшие не у него нет большинство вещей которые необходимо при разработке если используя какой-то внешней клиенту с нет нет не пешки шторма внешней программы это альтаира вот альтаир это современный интерфейс он может работать функционалом подписок то есть получается график роял тайм в real time обновление есть бесконечно полезная штука для нас это экспорт виде curve чтобы можно было на консоли тестировать запросы но у него есть и минус то что он не понятно почему регулярно поджигает процессор что с этим делать я не знаю но это все таки реджис приложение вот конференции по пешки можно про них плохо и сказать вот это в общем это скорее всего дело в ноги делаю в этих в джинсах и так далее из следующий пример который вершине которую мы используем прям постоянно это разреши расширение для пешки шторма и в 0 в шторм и джеймс городки или я не знаю почему я не разместила здесь название оно должно было быть примерно вот здесь вот сейчас я понимаю что его здесь нет называется же с граф келье давно вышла новая версия и вот это реально и удобное и классно мы прям рядом с тем местом где мы используем запрос мы мы его описанном виде граф келлер файлика и автоматически работает автодополнение кода можно прямо в коде уже смотреть какие какие поля есть какие на них есть ограничения вот и это действительно ускоряет процесс разработки принципе нас фонд эндер с браконьерами практически не общаются они общаются только со схемами граф киеве вот и поскольку речь идет про php и на php мы нашли 4 библиотеки которые так или иначе занимается предоставлением сервера графе 1 этого боник сон про под копирку переписан сдс того самого из-за которого 20 процентов загрузки процессора и со своими плюсами и минусами то есть там все нас построены на call back ах и прошлых пешкеш ников это расстраивают он считается как бы но не красиво но мы используем именно его и мы в целом довольны тем как он работает поскольку у нас еще постоянно ведется разработка на джесс у нас нет в проблемы бы киндеров пока нигером свести с бака недаром который работает на ноде и он объяснит ему как работает выбор никс потому что он с ним работает следующие расширением это риэлт разработал один из членов программного комитета на данной конференции в целом хорошее но она еще не закончена там нет ни документации но это по сути не библиотека который позволяет строить граф крейсеры это самое сам по себе сервер сам по себе вроде вроде фреймворка но пока он не сказал это не framework я до конца не понял как это официально представить но в целом это очень удобное решение которое позволяет быстро и легко красиво писать граф келлер гора и с расширением самого графский эль языка и есть еще две библиотеки 1 появилась после того как я уже подал доклад на это выступление и в 3 4 этой уши да я собственно становилась на первой строчке то что она не поддерживается и дальше я ничего про него сказать не могу и как как итог у нас граф киеве приносят свои плюсы и свои минусы главный минус то что является продолжением его плюс это что приходится поддерживать строгую типизацию и это бывает избыточный для маленьких проектов то есть когда мы делаем к этой г.п. хочется вы быстрее что-то там наклепать и выпустить уже в продакшн чтобы проверить как оно работает случае с городки ей приходится первым делом описывать документацию данного правда да данного wi-fi но это же является плюсом то что у нас всегда api хоть худо-бедно но документирована и после внедрения в процесс и в процессе этого граф киеве мы получаем просто какой-то в некоторых местах колоссальная скорость расширения то есть добавление нового поля не занимает принципе никакого времени не для фронта не либо к нигера и конечно же очень здорово то что можно в принципе если заморачиваться для построения очень дежурно большой странице можно сделать все будет получение всех данных в один запросы на стороне сервера это за кэшировать и это тоже будет работать быстро и не будет перегружать лишний раз сеть ну на этом у меня все спасибо вам за внимание и если есть вопросы я сразу за них отвечу спасибо антон за доход вот тут мы скука рук сразу спасибо за доклад меня на самом деле много вопросов я думаю еще мы с вами пообщаемся где-нибудь в дискуссионной зоне но из таких самых важных вопросов вот мы тоже в компании у себя перешли на граф quelle мы на нем написали нашу внутреннюю админку чтобы обкатать как раз эту технологию и у нас возник очень большой вопрос взаимодействие бэг-энде фронтэнда в том плане что у нас были определенные скажем так специфические запросы можно сказать костыли на старые админке которые мы делали и когда возник вопрос переноса текущего функционала в новую админку мы все сказали нет мы не хотим писать костыли frontend тоже сказал нет мы не хотим писать костыли как как у вас этот вопрос решался некоторых местах мы писали костыли вот она нас такого запрета жесткого не было но вообще старались придумывать схему такую то есть лишние уровне запросто можно получить список сущности то мы сначала пишем случится потом уже элемент допустим и добавление лишнего уровня она позволяет потом в будущем как-то его расширять у нас бла главно проблема то что мы сделали очень неглубокий запросто 23 глубина и канала было чего-то добавить системные допустим припади нации количество страниц в общем общее количество элементов от пришлось переписывать все очень мучительно делать 2 ли добавлять лишний уровень и переписывать все приложения под этот лишний уровень поскольку это очень глобальное расширение было выход как я вижу это вот лишнее уровне создавать и в крайнем случае если особенно если речь идет про админ-панель который для внутреннего пользования мы в некоторых вещах с остаемся привержены мир изд-во то есть нас в админ-панели жест используется для авторизации для проверки права права доступа для получения списка ролей и так далее но получение ими именно обработка данных сухих у нас происходит через графике то есть комбайн такой и мы на этом уживаемся в принципе понятно спасибо и еще вот один вопрос как раз про pagination то есть достаточно очевидно как сделать pagination именно верхнего уровня а как быть например с тем если вот допустим загрузилась загрузился какой-нибудь товар да и у него там ну например сотни модификаций как-нибудь делали баги нацию именно связанного поля конечно каждое поле у нас есть такой тип но вы можно звать к стильным там по janity type это обертка над уже потом типом вариант но в данном случае я просто показывался простые примеры там просто продукт вариантов на самом деле он api обернут в поджимаешь погиб приняты type даже есть для ее два расширения готова я уверен что для любого там php фреймворк а серьезно из расширения который позволяет делать эту pagination то есть каждое поле у нас позволяет дает возможность быть разбиться по страницам даже случае с вариантом нам как аргумент передается пейдж и сколько страниц и сколько линтонов на эту страницу и там тоже приходится делать новый уровень мы сначала опять же сделали сразу получение данных а потом надо получают информацию и мы столкнулись с проблемой везде везде где pagination в общем обязательно еще один уровень точно должен быть понятно спасибо пожалуйста спасибо за доклад у меня вот такой вопрос касательно поиска сложных сущностей вот вы приводили пример с интернет-магазином где поля добавляются добавлять углубляются и как бы в каком-то готовом продукте который вот ну вот у нас такая ситуация мы переписываем существующий продукт полностью то есть мы знаем как у нас что должно быть и вот у нас тоже есть заказ к нему огромное количество полей и есть задача сделать фильтрацию то есть так чтобы можно было найти и заказы по любым вообще параметрам естественно как это делать то есть input type и пишутся свои для каждого этого то есть создается такая сложная там для например сущности заказ и вообще очень сложная структура там кавардак фильтр type мы вот используем как раз свой бой ix вот и здесь возникает вопрос то есть у нас есть отдельный слой репозиториев которые находят заказы какая проблема то есть у нас основная база мой стиль но при этом для того чтобы иск мы могли искать заказы вообще по любым полям быстро мы используем ластик то есть мы в него все синхронно переливаем как бы с этим все хорошо но вот какая возникает проблема у нас input type этот фильтр в graph келли он такой большой и из-за некоторых ограничений которые есть гров келли есть появляется дополнительная иерархия там где не надо и как бы вот в резул дыры в аргументах этот фильтр так приходит как обычный массив вот и вот здесь возникает ряд проблем то есть использовать например нам надо вот этот массив поэтому массиву как не структурирована moony как просто обычный массив найти заказы писать прямо в резул very преобразовывать его например войск ель прямо напрямую обращаться к базе это ну плохая практика потому что это мимо репозитория идет сейчас у нас там запрос идет на мой съели завтра мы в этом переделали на elastic а то есть прокидывать опять же эти самые этот массив которые мы получили от граф кель в репозиторий чтобы он с ним работал тоже неправильно потому что получается что репозитории начинает знать что-то про слой api и то есть приходится делать такие проверки дурацких какие-то из-за того что с опять же из-за требование граф киль какой-то структуре вложенной придется в репозиторий делать проверки что если этот ключ есть то внутри там посмотри то сделать такой запрос и так далее в итоге как бы единственное более-менее решение которое получается это писать для каждой сущности какой-то свой а как бы как сквере builder то есть вот как умным я сделал or dark вере builder у которого добавил там если это тип поля дата то у него есть нам created там допустим ну минимум минимум максимум дата и вот получается такая штука что в резул very весит массив обрабатывается создается объект куэрри builder вручную проставляются все его аргументы потом он пробрасывать в репозиторий репозитории я по нему снова прохожу и уже как бы получается все изолирован от я создаю нужный запрос на эластики ли на мой съели уже неважно но такая практика превращается к тому что есть опять же взять грубо говоря интернет магазин в котором помимо заказов есть там товары есть клиенты есть пользователи есть роли и все-все-все если такую штуку такой клэри builder писать для каждой сущности чтобы везде в api можно было нормально осуществлять поиск даже например просто по названию товара делать там какой нибудь там ayting вере builder и так далее можно ну просто сдохнуть честно сказать я не знаю это огромное количество года не говоря о тому же как это все потом покрывать тестами то есть это мало того что как вот да вы привели пример с ним что на каждую паги нацию приходится списать свой слой к этому еще если фильтр для каждой сущности свой и все это тестировать вот пока что не могу найти ни одного красивого решения и у меня такое чувство что это выльется в том что будут огромные где-то баги которыми просто нет тестируем который передут продакшн и постоянно будут там появляться вот решали ли вы такую проблему и если да то как ну вот кори builder собственно это было наше решение вот я не совсем понял в чем постановка проблемы в случае графики отличается такой же проблема в бресте на совести есть запросы мы также то что приходит мы превращаем что-то удобоваримое для репозитория чтобы это можно было тестировать проверять и передаем уже дальше чем отличается тем что бресте вы сами вы ограничены только одним какую документацию вы пишете то есть если вы написали что нужно там передать документы в таком формате вы их сразу таком обработайте например вполне можно случае средством сделать так чтобы запрос который пришел там ну грубо массив аргументов который к вам пришел с api вы можете напрямую протянут в репозиторий потому что вы объявили что вот тут нужен такой формат данных а в случае с грядки ель возникает сложных фильтрах возникает лишние иерархия которые надо как-то преобразовывать вот я понимаю суть проблемы я понял я пока не понял чем отличается от роста вот проблема можно обсудить потом я будучи еще есть вопросы да добрый день спасибо за доклад но я с граф коли меня сам не работал поэтому такие вопросы я понимаю что mapping происходит в ресивере как раз надо и соответственно там нужно писать если нужно свои специфические поля там нужно дописать от каждом поле потом мы дописываем свой резон я щас и но чтобы напрямую с ну имеется ввиду что это не ровно как базе данных что пользователь как бы не мог это увидеть что у вас какие-то поля называется ров базе да сейчас как просто пример скажу вот и тип вариации товара и у него есть поле имидж и мы конкретно имидж отдельно описан в sauber где я рут это то что пришло в этот продукт варианта им по то есть данном случае ты будешь сущность товара самого и мы описываем уже получение картинки как хотим то есть если она в принципе в руки ей вроде есть там прайсом и тогда и тогда мы уже он сам выведет если нам уже свою свою тройку получения информант данных тогда приходится писать свой револьвер и до получения в ней внешних источников спасибо второй вопрос можно ли как то сделать но он когда нужно при низкой сущности получить то есть в те в одном запросе нужно получить но там мне не знаю ну составной какой-то запрос я тебе нужно получить низкой сущности как это проходит собственно одна из одно из преимуществ граф келлер строится вот один запрос сразу несколько вещей транзакции и платежи мы получаем одним разом сразу несколько полей понял спасибо я и просто не в курсе спасибо а еще вопрос мы можем какую-то спецификацию тут использовать ну например какой-то сон api например намин вывод от отображение какой-то преобразовать да это все в джейсон ну в случае там воскобойник салат из коробки переводится джейсон граф келлер носом обелять библиотека случае с php она отдает уже готовые джейсон вам а вы его уже к хотите хотите выводить и сразу хотите его как преобразовывать и какой-то другу же если вам нравится xml спасибо большое пожалуйста еще есть есть у просто подскажите пожалуйста вы все время говорили что вы отказываетесь типы от общения front эндеров ибо киндеров как мы вообще схема изменяете кто первый вносит нее изменение чтобы дальнейшем кто смотрит и делает изменением соответственно в ходе front-end и back-end основном это зависит от проекта если проект просто обычный сайт где в основном рулят frontiers где много логики на фронте но не надо метров контейнер говорит хочу сюда вот это поле и мы уже обсуждаем ну это первый импульс это фонтейн дыра есть сложный процент приложения как мы для банка там куча бизнес-логике и есть некоторые сложности передать то или иное поле в другой местом пока нет он говорит удобно сделать здесь здесь можно сделать еще вот здесь фронт эндер уже говорит что ему будет удобней запрос модифицировать мы их не то чтобы отказываемся от общением в принципе общительные люди вот но мы стремимся минимизировать так еще есть и что-то здравствуйте подскажите как выданные обновляете в каком плане надо запись какую-то в базам удаляя про обновление данных я предполагал что времени хватит рассказать вот это график или отдельный механизм мутации там таким же образом описывается схема и выглядит это примерно так же как аргументы при получения данных сейчас и пристаю вот строится запросто к вместо к вере здесь описывается mutation и в аргументу передается что именно мы хотим поменять и также на стороне макиндера боккен записываются результаты для обновления сущности то есть мутация тоже позволяют в горах теперь можно также обновлять данные также с гибкой схемой еще есть вопросов нет то есть ну раз уж заговорили про мутации интересно как у вас сделано загрузка файлов через раз через так ну давай на и завершение антон вот ты тут рассказываешь про как что вы перешли к это плюс и расскажи когда не надо применять граф quelle чтобы понимать что не всегда 8 и утром нужно ведь я же не про планируется непредвиденное развитие проекта и никто не может по заранее понять насколько наша слышно сколько не адекватный клиент попадется вот если если мы видим то что да да на если мы видим что клиенты у клещева если клиент со своим дизайнерам и дизайнеры я дизайнер я так вижу вот вот такого плана таком случае мы не рискуем здравко хорошо еще один вопрос вот такой ты тут много говорю там про оптимизацию что вот значит провести там много запросов надо делать да тут мы одним но тоже немножко это затронул тему про вложенный этом n + 1 да вот это но вопрос на какой например в базе данных ты когда листаешь какой там join да можешь сам грамотным сайт запрос который будет использовать и притом не знаю фаренгейта на которой построен яндекс или приоритетом запрос где vr по двум полям но тут фильтровать да но в базе соответственно если они в какой пою в каком порядке они вид их поставишь либо будет используется индекс либо не будет ну например когда ты сам пишет запрос ты очень легко it контролируешь в данном случае тут по профессии я ошибаюсь надо либо описать свой там builder для запросов и свой резон который четко вот эту особенности база данных будет использовать либо ты можешь написать и сделать неоптимальный запрос на вопросы join и решается отложенными запросами как вот в примере прямо + 1 вот а вопрос индексов и так далее да то есть тут ну либо бить по рукам front эндеров если они поля стоит не в том порядке либо делать свой builder зависит того насколько платежеспособных клиентов сколько он не торопиться получить свой продукт вот если мы это вот опять майк вопрос о том что лада что иногда вот этот выход на доработке он может перевешивать на самом деле в том числе чем плюс в общем думайте прежде чем что-то выбирать даму спасибо большое за доклад"
}