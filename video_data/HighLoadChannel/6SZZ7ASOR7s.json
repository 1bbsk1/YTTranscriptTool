{
  "video_id": "6SZZ7ASOR7s",
  "channel": "HighLoadChannel",
  "title": "Архитектура процессора Эльбрус 2000 / Дмитрий Завалишин (Digital Zone)",
  "views": 22270,
  "duration": 3291,
  "published": "2021-10-04T02:47:02-07:00",
  "text": "если кто-то из вас уже работала с эльбрусом то вы к сожалению от меня ничего нового не узнаете это будет такая обзорная обзорный рассказ ну наверное может быть я парочку слов скажу про то что там мало кто рассказывает тем не менее общая идея бы хотел что вы просто знали что это такое потому что про него ходит много разных слухов толков человеку эльбрус во первых он не является ничем клоном это абсолютно российская разработка на самом деле еще советская разработка он уходит корнями в далекое прошлое помощью с проективным россии есть версия которая в россии и изготавливается на наших заводах но конечно самые болевые мощные версии делаются в тайване над см7 эльбрус и про это тоже есть много разговоров умеет исполнять код x86 но делает это не совсем аппаратно даже на самом деле совсем не аппаратно а путем бинарен трансляции я про это отдельно расскажу современные версии эльбруса нас кошелька с 14 года уже выпускается да это довольно мощный процессор 16 ядер 2 гигагерца и надо понимать что это 2 гигагерца не тех же самых что у интела потому что эльбрус умеет запускать на один такт до 50 инструкций правда это надо кое-что же суметь ему выкатит такой код чтобы реально заполнить все возможности но технически это возможно серийное производство 14 года и уже на сегодня поддержан довольно широко операционными системами в основном конечно линуксом ну вот я сам внезапно только вчера готовят этот рассказ узнал что оказывается даже есть версия unix ну и еще есть российские у совы которые сделаны для эльбруса в принципе на самом деле кстати вот под после 1 который здесь вот да меня два раза выступал давно на нее перенесён и вообще-то довольно много кода на него перенесена краткая история что примерно понимать чит 1 эльбрус появился в восемьдесят седьмом году 15 миллионов грации 64 мегабайта для то время это была бешенная совершенно объем оперативной памяти и сам он тоже родился не на пустом месте к этому моменту момент уже была бэсм-6 которая была самый производительный советское время и в общем даже среди мировых она в некоторый момент занимала первые места девяностый год эльбрус 80 из нитей год выброс 2 до 8 процессоров в параллели 125 миллионов операций эльбрус 3 ему не повезло он пришелся на деградацию советского союза и хотя он был сделан на общем собрали один экземпляр дальше он не пошел после этого там были смутные времена и разработчики которые проектировали придумали их бруса не в на самом деле работы на компании intel и там даже есть патенты наших вот людей которые до этого работали на эльбрус а потом помогали делать в частности счас е инструкции для компании для процессоров intel и вот только в четырнадцатом году выходит первый процессор эльбрус в виде микропроцессора уже он во многом наследует идеи вот этих первых трех эльбрусов хотя и довольно сильно не одних отличается ну и в общем про это поговорим вообще и я сейчас вот буквально еще одно слово скажу про предыдущий слайд надо понимать что эльбрус и это действительно довольно специфичный вид процессоров они изрядно не похоже на то к чему вы привыкли есть базовая инструкция все те же самые вот там и чувакова буде удивительного нему не увидите сложение вычитание умножение jump и переходы все это в общем там есть но тем ни менее архитектурно процессоры очень сильно специфичные чтобы понимали насколько они специфичны и вот в процессорах эльбрус и 1 и эльбрус 2 вообще эльбрус и отличается от всех остальных процессоров так называемый тяговая архитектурой процессор пикирует данные в памяти таким образом что он знает тип объекта памяти когда обращается в памяти какому-то значению обычный процессор просто считывает бытовую строку и дальше трактуют как float или int или pointer или что то еще эльбрус точно знает что там прилежит с той стороны так вот современный эльбрус отличает только pointer и и данные вообще а предыдущие эльбруса знали настолько много про объект на этой стороне что например поддерживали такую вот вдумайтесь перечную операцию в эльбрусе 2 можно было положить память такой указатель такой объект что при попытке считывания значение этого объекта то есть обращение памяти на считывания данных из нее прозрачно для для вызывающего обращающегося куда вызывалась функция адрес который находился в этом объекте она отрабатывала ее результат подставлялся как итог команды считывания из памяти с этим масштаб того что там была реализована в современном отбросив все попроще существенно много таких вещей в общем из него убрана но тем не менее это довольно интересный в общем очень не банальный процессор пойдем дальше 21 год вот на сегодня он уже существует правда это все-таки еще пока звука знаю тестовый экземпляр и они еще не пошли прямо в серию серии в серию он уже делаются на них платы это вот эльбрус 16 из 16 ядерные 2 гигагерца еще раз напомню до 50 команд на один такт поэтому это прям существенно другие 2 гигагерца технически он позволяет ну вернее технически архитектурно позволяет дождь из четырех процессоров неправильно написан у меня ядер собирать в сампе систему по 16 ядер в каждом да и опять же я не знаю сколько реально возможно потому что понимаем что одно дело это в архитектурная возможность другое дело нагрузка на шину и реализации но вот известно что про предыдущие модели известно что 4 processor ные модули на них производились реально поэтому можем уверенно предположить что сок там опустишься 4 ядра вполне себе возможно вы сампе варианте запустить я здесь ним стал все что про него известно можете почитать это все всей этой информации есть в интернете про то что у него на борту по периферии там общем все довольно серьезно на самом деле я больше сегодня буду про архитектура говорить это картинка про небезызвестный вам закон мура вы его знаете да значит каждые два года количество транзисторов на одном кристалле в среднем удваивается почему я про это говорю потому что сильно влияет на ток вообще откуда взялся эльбрус с его идеей как надо делать процессор и вот на этом графике если вы посмотрите какие там именно процессоры дата до где-то 95 года происходит вообще абсолютные синекура для программистов процессоры реально количество транзисторов удваивается процессора становятся более быстрыми и те же программы без всякого приложения усилий со стороны программиста просто работают на процессорах быстрее заменили 8086 на 208 6 все полетело быстрее 300 еще быстрее 406 еще быстрее пентиум просто программа летают программисты ничего не делает процессор просто тупо ускоряются дальше начинаются тонкости ну начнем с того что во первых на закончим тем что сейчас мы знаем что к сожалению уже невозможно просто тупо ускорять одно отдельное ядро и ускорение процессора делается за счет увеличения числа ядер что уже не позволяет программистам просто в тупую запуска те же программы их нужно раз параллели вода но вот между сегодняшней ситуации и совсем простой ситуации там типа pentium ii и 408 6 была еще одна фаза это появление процессоров со встроенным распараллеливание им исполнение кода что происходило значит обычный intel овский код это крупные сложные инструкции в которых закодирован довольно много rub а ты вот здесь примерно показано как устроено вот слева инструкция типа интеловской а справа как это сделано в рисковых процессорах которые такую инструкцию исполняет в intel и инструкция сама может сходить память читать кучу значения сделать несколько вычислений сохранить данные в память да еще может много чего сделать процесс исполнения одной инструкции в рисковых процессорах так не принято в них принято инструкции иметь фиксированного размера и очень простые либо инструкции читает из памяти либо она выполняет регистрирую операцию поэтому одна инструкция интела на рисках машинах разбивается на целую серию простых инструкций которая делает то же самое как ни странно могут делать быстрее значит что произошло вот в этом самом девяносто пятом году у интела возникла проблема связанная с тем что программы завязаны на январский набор команд в intel и очень мало регистров поэтому оказалось что писать программы эффективно невозможно почему всего 8 регистров вы написали кусочек кода который использует эти регистры следующий кусочек кода используют их же даже если да эти два кусочка кода можно было бы исполнить параллельно за счет того что процесс или для этого достаточно мощности из за того что они упираются в одни и те же регистры это невозможно сделать что сделал intel значит внутри процессора intel и это сейчас так происходит сложные инструкции бьются на кучу простых и мало того этим простым инструкциям излучается в на самом деле внутри intel а больше регистров чем видно с точки зрения программиста их там не 8 а нам 32 или больше и вот такие наборы инструкции им даже если они обращаются у два набора к одной тоже к одному и тому же регистру использовать его загрузили посчитали и записали в память да и следующий набор инструкции такой же загрузили в x посчитали записали в память они раз параллели ваются и им выдаются две отдельные копии виртуального регистра x я не мог бы запущены параллельно это позволяет опять же без того чтобы нагружать программиста сильно ускорять программа за счет того что процессор выявляет в коде скрытый неявный параллелизм и реализует его в виде реально параллельного запуска участков кода которая в общем можно исполнять параллельно как вы понимаете это очень не бесплатная затея то есть это очень сильно усложняет процессор процессор вынужден много анализировать много чего делать в нет внутреннего возникает в общем целая куча дополнительные войны связанные с тем что мы разбираем инструкции исполняем вот эти микро инструкции потом еще выясняем а где же они на самом деле закончились там возникает целая куча сложных эффектов которые действительно очень серьёзно усложняют аппаратуру процессора с другой стороны возникает в общем довольно приятная картина мы можем внутри одного ядра делать много что параллельным ну опять же опять же мы понимаем что несмотря на все это все равно не получилось облегчить жизнь настолько чтобы процессор полностью снимал с программиста необходимость распараллеливание рядные процессоры все равно тем не менее вынуждают нас писать мал тетрадные программы искать какие-то способы про грузить вот все те аппаратные средства которые в современном процессоры есть все равно не смотря на все эти вот и хищение внутри процессора компиляторы довольно сложные сам код программы прикладной сложный и с этим приходится много возиться что сделала ли брус на самом деле надо понимать что это было сделано в изрядной степени из ну некоторые невозможности реализовать вот эти вот сложные устройства внутри процессора было сделано предположение что не надо все это всю эту сложность запихивать процессор можно сделать сильно проще можно сказать что все распараллеливание должен делать компилятор мы возьмем и сделаем процессор таким чтобы можно было через сложная большую инструкцию очень детально и подробно объяснить ему какие исполняющие устройство процессора должны что в данной инструкции сделать то есть процессор вообще не пытается за вас разбираться где там восходе можно что параллельный спринт что нельзя компилятор должен реально хорошо разобраться в программе и ему это сильно проще сделать поскольку он в отличии от процессор который видит маленький кусок кода он видит много вплоть до всей программы он может очень детально разобраться что происходит и детально процессор объяснить вот эти вещи можно делать параллельно эти люди нельзя значит мало того в этом месте еще снижается существенно неопределенность потому что интеловском компилятор все равно надо довольно хорошо знать что-то в процессоре происходит и подавать его код так что процессор было легче его распараллеливание возникает такая сложная командная игра компилятора и процессора в процессорах с очень длинным командным словом это собственно эльбрус ну и кстати intel itanium да это происходит полностью на стороне компилятора и процессор упрощается и за счет этого на самом деле можно существенное количество аппаратуры процессора которая ну вот выпуском подходе занималась этим разбором и раз параллели ним потратить собственное исполнение на на еще исполняющие устройства на кэш и еще некоторое количество ценностей из этого вытанцовывается значит что де-факто происходит у эльбруса в каждом ведре ingrosso есть шесть аллу логических устройств которые могут исполнять 6 довольно полноценных параллельных инструкций то есть это там инструкция типа вычислений типа доступа к памяти этот мы собственно то что мы вообще обычно считаем инструкцией и в очень широкой команде эльбруса для каждого из этих аллу прям явно сказано ты складываешь ты вы читаешь ты делишь ты записываешь память например в этой же команде можно положить одну суку инструкцию которая управляет переходами ну это условно jump но я даже скажу там чуть похитрее сделано и еще можно положить 4 литер альных значения то есть значение которые прямо пойдут в исполнении как бы как константы и еще очень интересная вещь которая там заложено это то что здесь вот описано как предикаты это тоже очень веселая вещь значит у процессора эльбрус есть отдельный регистр который называется регистр предикатов если совсем просто то один бит в этом регистре носовых там два бита это булево значение которое можно использовать для условного исполнения инструкций когда вот вы запускаете на исполнение эту огромную инструкцию то 6 суп инструкций для каждого аллу можно еще завязать на предикаты сказать что вот эта суп инструкция будет исполняться если такой the predicate единичка а это если нолик это приводит к очень простые вещи можно сильно экономить на jump ах потому что можно некоторые простые условные операции а иногда и довольно непростые условные операции закодировать в одной инструкции таким образом что у нас по первая половина iv исполняется если предлагать предикат единица автора если он 0 то есть мы сразу запихиваем в команду и тот и другой вариант кода для iv и для else ну просто проверяем по определенному видику какую из них исполнять это позволяет как вы понимаете сэкономить довольно большое количество jump off a jump а для современного процессора это огромная головная боль тут на самом деле много усилий сделано для того чтобы их по возможности избежать мало того вот эти предикаты для них для самих существуют зубы инструкции которые позволяют перед исполнением команды их посчитать то есть мы можем на самом деле внутри одной инструкции взять посчитать несколько пулевых операций то есть у нас в регистре предикатов есть много разных там педиков сидит мы можем там парочку из них по или потом какой-то из них с другим по и связать потом получить ответ и по этому ответу условно использовать не команду и можем оставить его регистре предикатов он останется это как бы такой большой флага вый регистр в котором можно сохранять большое количество булевых значений то есть еще и большое количество булевых и вычислений которые относятся как правильно как правило control flow управление того как поют исполнение команды куда в программе исполнять полностью параллельно вместе с основным кодом программ и почему jump и очень неприятная вещь для современного процессора все современные процессоры являются так называемой платиновым процессорами они исполняют каждая команда исполняется в процессоре много такт auto 5 7 до 19 по моему но за счет того что в каждом такте мы исполняем от первой инструкции вот первый шаг от 2 2 и 3 3 и так далее то есть они как бы вот вот видите такой вот ступенькой расположены самая первая инструкция мы делаем не только одно считываем инструкцию из памяти на втором такте мы для следующей инструкции считываем и из памяти а для предыдущие декодируем и так дальше движемся по цепочке таким образом процессор каждую инструкцию исполняет там скажем 10 тактов но за счет того что они все наложены фактически в один такт исполняется 1 инструкция так который к этому моменту доехала до конца времени свое исполнение так все с вами процессор устроены из-за вот этой проблемы команда jump очень неприятно для процессора потому что она вызов вынуждает процессор доработать все висящие в плане инструкции полностью закончить исполнении сделать переход и потом снова начать наполнять pipeline снова с нуля в новом месте таким образом потеряв огромное количество процессор на во времени один джампа стоимости может достичь там 10 20 инструкций это реально огромная проблема для компиляторов поэтому прям огромное количество усилий с точки зрения оптимизации и в компиляторах процессорах тратится на то чтобы такой ситуации избежать вот я уже сказал как и сбегается такая ситуация с помощью предикатов вы люси но есть еще одна вещь которая в нем реализована для того чтобы по возможности такой вещи избежать это сильно по-другому устроены и команды переходов в обычном процессоре есть ну там 2 традиционной команды jump по которой процессор переходит на новый адрес инструкции начинает код исполнять с нового места и условный jump который позволяет проверить условия кстати валь груси это как правило предикат и сделать переход если условие исполнилось или не исполнилось значит что сделано в или брусе в отбрось и переход любой условный безусловный и даже вызов подпрограммы и даже возврат из-под программы можно разделить на две части в первой части мы готовим переход мы говорим процессору знаешь я планирую перейти скоро перейти по такому-то адресу у меня будет там jump по такому-то адресу в этой части инструкции мы сообщаем ему как вычислить адрес перехода аппаратура эльбруса параллельно с исполнением других инструкций выполняет это вычисления то есть она где-то там может сходить память откуда это дело прочитать и внутри себя подготовиться полностью к тому что переход был исполнен в момент исполнение самой инструкции перехода если между вот подготовкой и исполнением инструкцией мы дали ему чем-то другим позаниматься то переход оказывается полностью бесплатным за счет того что параллельно он полностью подготовился выяснил адрес перехода и всю свою аппаратуру к этому подготовил сам jump оказывается для него абсолютно бесплатным и вот такого вот сбоя pipeline а не происходит при чем процессор позволяет знать подготавливать до трех переходов него есть три таких специальных регистра которые используются для подготовки jump off и все три можно использовать если мы скажем точно не знаем еще по какому будем переходить ну скажем там у нас есть типичный код где у нас окончив срабатывает ему может быть перейдем по и поможет не перейдем к этому знаем позже но куда мы перейдем мы знаем заранее потому что это как правило константный адрес вот три регистра обычно 2 используется для подготовки именно переходов внутри кода функции а третий специальный он умеет вызывать функции возвращаться из них он обычно используется специально для этой вещи кстати над сказать что вызовы функции возврата из них валь брусе это тоже общем отдельное довольно не детское занятии я про него отдельно расскажу следующая вещь которая в или брось все сделано не как у людей абсолютно восхитительно сделано это регистровые окно значит в обычном процессоре у нас есть с вами там там 10 20-40 факта регистров которыми код пользуется он пишет в регистры промежуточное значение читает из них при вызове функции обычно с в регистрах сохраняются какие-то аргументы возвратные значения в них хранятся при этом как обычно устроена обычная функция на обычном процесса этом на intel она are my feet происходят одинаковы перед вызовом функциям и командами push сохраняем в памяти регистры значение которых нам почему-то важны мы хотели их после возврата из вызванной функции иметь вызываем функцию она там то что то всеми делает с этими регистрами возможно какие-то затирает возвращаемся командами поп поднимаем из стека важные нам регистры продолжаем работу что происходит в или брусе вообще не надо никаких пуша и попав происходит абсолютно фантастическая вещь иначе во первых у него есть огромный пул регистров и двести пятьдесят шесть штук каждая функция в начале своей работы прямо явно говорит процессору мне нужно вот столько то регистров из этого пула и процессора ей из этого огромного множества выделяет кусочек в котором она будет жить при этом видимые функции группы регистров вот это окно вот в этот вот регистровый файл она делится на три части первая часть это те регистры который мы получили от вас функции которая вызвала нас то есть этот блок и они и она видела и мы видим он для нас общий там находится параметр который нам переданный следующий блок это наша регистр который мы никому не хотим показывать они видны только вот нашей функции больше никому и третий блок готовится перед вызовом и в нем мы помещаем параметры следующей функции когда мы ее вызываем то это окно сдвигается вверх таким образом что вот эти параметры функций для следующей функции становится нижней частью окна регистров дальше там образуется опять же следующая ее личная часть и дальше следующая часть это регистра которые то функция будет использовать для вызова своих уже функции здесь это примерно изображена я надеюсь что я это вменяем объяснил но вот для иллюстрации то есть грубо говоря при вызове функции мы едем вверх по этому регистра вам у файлу выхватывая для него блоки регистров которые используют текущие функции и они частично пересекаются в вызовах таким образом что мы через них передаем параметры какие-то кусочки этого фрагмента вот то что есть серединке нарисовано как это можно вот здесь вот в этом месте от нарисован да это вот собственно параметр который передается из функции из функцию в функцию тут кусок регистра файла который виден обоим что же происходит если все это кончается как бы каков бы ни был велик регистровый файл когда нет он кончится конечно так вот прозрачно для прикладного кода да и для системы у нас м где то же процессор просто сохраняет встык куски этого регистра файла когда ему не хватает регистров если очевидная функция попросила сколько-то регистров и у нас столько свободных файле нет то все это окно сдвигается влево хвостик одной большой быстрой операцией пробрасывать свои оперативную память и высвобождается еще какое-то количество регистров которые снова можно использовать если у вас очень большая вложенность на самом деле для огромного количества кода все это происходит вообще без обращение к памяти 206 довольно много на самом деле и в существенный там на на глубину там в 1020 вызовов этого может просто хватать полностью без обращение к памяти но если не хватает то процессор абсолютно прозрачна для прикладного кода сохраняет регистры ну естественно когда начинаем возвращаться и все это окно сдвигается влево когда он доходит до места где мы упираемся в левый край регистровый файл это он процессор начинает подгружать регистры обратно из памяти я чуть-чуть забегу вперед на сказать что одно из ценнейших свой столь bros и заключается в том что это очень сильно защищенный процессор он прямо сильно сложнее устроен чем традиционные процессора и всего этого на нем очень многие вещи которые можно находить в традиционных процессорах такие хоть и в нем не проходит и из-за этого многие вирусы в нем не работают в частности эльбруса несколько разных стыков и поэтому например опять же вот вы видите да сохранение регистров происходит вообще аппаратно недоступна для прикладного кода поэтому очень трудно сделать в нем всякие вот фокусы которые на традиционных процессах основанным на процессорах основаны на затирание данных в стеке на возможности подсунуть туда какие-то свои данные добиться того чтобы процессор прочитал из стыка неправильный адрес перехода и перешел куда-нибудь куда мы хотим его загнать в эльбрус такие вещи не проходят час я проверю что я ничего не забыл из предыдущего да вроде ничего не забыл к этому надо добавить вот еще вот это самое регистровые окно она содержит в конце концов в конце еще один кусок который вообще не передвигает свою речь просто глобальным он виден вообще всем функциям и может использоваться для самых разных вещей но просто как обычный регистра в мощном процессоре либо как временная регистр который мы понимаем что под момент вызова функции будут затираться вызванные функции поэтому не храним в них длительно ничего либо наоборот как глобальные регистры но там типа регистров в которых хранятся там ссылки на глобальные данные или там позиция independent ход регистра который используется компиляторами для хранения некоторых глобальных таблицы которых лежат нужные компилятору вещи опять же их в общем довольно много вообще над сказать что по аппаратуре эльбрус довольно богатый процессор подкачкой данных для цикла вот смотрите назначить на самом деле если говорить про современные процессоры то есть несколько вещей из-за которых все очень тяжело проблема для современной процессора заключается не в том чтобы сделать процессор который может быстро считать это на самом деле не трудно проблема заключается в том чтобы погрузить процессор то есть во первых сделать такой код который позволяет действительно задействовать все возможные мощности процессора а во-вторых и это то во что процессоры реально упираются это вот вы обмена с памятью обмена с памятью раз в сто медленнее чем операции внутри самого процессора поэтому каждое обращение к оперативной памяти особенно если оно случилось в таком виде что процессор начал ожидать его результатов это просто кошмар и трэш поэтому все современные процессоры пытаются сделать так чтобы обращение к памяти главным образом на считывание с записью не проблема запись выполняется отдельными записывающими юнитами которым выдают значение говорят на пойди запиши его памяти и бегут дальше потому что ну запишут когда-нибудь не страшным нас это уже не останавливает а вот считывание нас останавливает поэтому и аппарат на процессоры пытаются это делать и программа для этого очень много делается в процессорах разработчики архитектур стараются делать так чтобы мы узнали о потребности считывания из памяти как можно раньше желательно до того как это считывание стало для нас критичным когда эти данные нам реально потребовались ну к примеру например в современных процессорах практически во всех существует инструкция которая говорит я скоро собираюсь использовать данные которые находятся по такому-то адресу памяти на просто говорит процессора поди попробую эти данные в кэш дотащить чтобы мы потом когда будем их реальность и ты во тьму их получили мгновенно эльбрус идет дальше начнет он volvo сообще есть совершенно фантастическая поддержка для циклов щель босс как вы понимаете создавался для вычислений для будто вычисления вычислений поэтому всякие вот именно цикловые операции в нем поддержаны очень хорошо значит что умеет эльбрус как как правило встроен цикл в программе как правило цикл обрабатывает какой-то массив в памяти то есть у вас есть какой-то индекс этого самого массива вы бежите по индексу массива считываете из массива каких значений например в этом не знаю там видел картинку обсчитывать или звук у вас есть буфер вы из него считываете значение там по сэмпла вы их обрабатываете куда-то записываете сашан типовая банальная операция совершенно очевидно что если вы за кодируете эту операцию обычным циклом то есть кусочек кода jump но начала снова тот же кусочек кода который исполняется цикле то на каждой итерации у вас будет обращение к памяти на котором процессор зависнет пока данные из памяти не приедут это настолько фантастически медленно что создателей rus из бруса сделали специальное решение которое эту ситуацию закрывает или броса есть специальный отдельно параллельно работающий юнит аппаратной подкачки данных он устроен следующим образом внутри цикла вы не пишете инструкцию считывание из памяти опишите специальную инструкцию выборки данных из фифа до начала цикла вы запускаете аппаратную подкачку которая начинает делать следующим образом вы и сообщаете куда памяти идти и как считывать значения она бежит с опережением цикла и выдергивает из памяти значения которые этому циклу нужны и записывает их сифон цикл бежит параллельно и вытаскивает с считанные значения из этого фифа и с некоторой вероятностью с довольно существенный на самом деле вероятность особенно если правильно сделано можно получить ситуации в которые считывания из памяти идет со скоростью которая практически не будет тормозить исполнение самого цикла данные самих вот разработчиков игру со показывают что в десятки раз возможно увеличение быстродействия вот за счет этой реализацией мало того эльбрус поддерживает схему исполнения циклов которая позволяет запускать следующей итерации цикла на исполнение в процессоре до того как закончились предыдущие традиционный процессор у вас цикл кусок кода вы дошли до конца куска этого кода jump на начало jump гарантирует вам что вы точно совершенно не начать исполнять код который вот следующую итерацию до окончания этой поэтому они будут исполняться строго до исполнения последний инструкции что делает в эльбрусе в эльбрусе внутри регистра во окна выделяется еще одно маленькое под окно некоторого размера и куду цикла дается не конкретный регистр указывается а ему говорится вот будешь брать данные из этого под окна использоваться использовать регистры в этом под окне и аппарат на процессор будет для каждой следующей итерации цикла из этого падок на выдавать следующий регистр это позволит там скажем 10 подряд идущим операциям цикла в коде будет написано обращение к одному и тому же регистру а физически каждая следующая операция будет получать следующие отдельные регистры и это позволит этим операциям работать с той степени параллельности с которой вообще хватает аппаратура процессора это тоже позволяет вот в совместно две эти вот две эти штуки позволяют ну прям катастрофически у сказать исполнении циклов и очень сильно снижает зависимость от обращений к оперативной памяти несколько стеков я про это уже начал говорить значит что самое важное значит процессора эльбрус есть стек вызовов который полностью аппаратно поддерживается у него инструкция вызова функции она сохраняет очень большое количество информации о текущем состоянии на спицы альный стек и суда сохраняет адрес возврата в общем все что нужно для возврата в предыдущие функции но при этом на этом стыке отсутствуют данные то есть на него не сохраняются данные из регистра во файла на него не сохраняются никакие пользовательские данные и в силу этого поскольку он может быть организован вообще в отдельной части памяти совершенно невозможно пересечение между памятью адресами возвраты и тем местом стыке где они хранятся и данными пользователя потому что они находится просто в двух разных стеках на самом деле там больше стыков но вот настолько я уже не разбирался что это означает совершенно типичные для интела метод атаки на код носи выглядит следующим образом мы пытаемся построить код таким образом чтобы в какую-то переменную обычно строковую переменную который лежит на стыке записалась больше чем эта переменная в размере то есть вот такие старые функции тип str копии это очень легко позволяли если строка длиннее чем буфер в которой мы копируем да и буфер находится на стыке то мы перезаписываем буфер и дальше затирая данные доходит до места где на стыке находится уже не данные а адреса возврата в это место мы пишем к он специальный адрес и при выполнении возрастные функции функция возвращается не туда куда должна была а туда куда мы направили а там обычно находится уже код который мы тоже в это место подсунули и это перехват управления через переполнение буфера довольно такая типовая банальная проблема которая до сих пор на сказать в общем еще встречается в эльбрусе это абсолютно и полностью невозможно в силу просто всего того что стеки находится в разных местах я там дальше еще одну интересную вещь скажу которая еще сильнее может защитить код но даже даже вот это на самом деле уже ощутимо помогает вот защищенный режим этот то свойство или броса который очень сильно недооценена и очень мало используется в основном потому что с ним очень тяжело потому что на самом деле чтобы засечь затащить код защищенный режим с ним очень много работу надо править проделать скажем гидру linux вот на сегодня в защищённый режим перетащить не удалось что он из себя представляет основное свойство защищенного режима заключается вот в чем как я вам уже говорил данные которые лежат в памяти для процессоров эльбрус тэги роются то есть рядом с каждым значением памяти лежат бить и киты гав которые говорят это число а вот это указатель это позволяет процессору твердо знать что он считывает из памяти это позволяет процессору вот в защищенном режиме полностью запретить преобразование целых чисел в указателе вообще чего бы-то ни было в указателе защищенном режиме есть только один способ получить указатель и это получить его из другого указателя внимание вопрос откуда берется самый первый указатель да там есть специальный режим в котором он порождается мало того защищенном режиме указатель это не просто адрес памяти это огромное 256 бит там получается число которое содержит себя три поля это базовый адрес собрался 28 конечно 4 бита базовый адрес еще четыре бита все остальное это базовый адрес это размер окна в которой мы смотрим это текущее положение в этом окне все это может быть хлопну то да там окна не знаю там в 4 лишь восемь байт и тогда мы имеем просто обычный указатель которые смотрят на одно число в памяти а можем иметь его раздвинутые он может смотреть на массив или на структуру и ночью на кой то большой объект памяти в этом случае когда указатель имеет какой-то большой размер внутри себя вот это вот предел у него побольше чем там восемь байт мы можем применять к нему адресную репите q но только внутри вот это вот поле если нам передали скажем pointer на массив то он указывает на начало массива в размере указан размер массива и сам он смотрит какую-то точку массива которую нам почему-то педали как опорные мы от нее можем двигаться адресной арифметики вверх и вниз можем вот внутри этого массива делать все что хотим но выскочить за пределы не можем никак вообще совсем и грубо говоря когда функция защищенном режиме получает какие-то параметры то она абсолютно никаким образом не может обратиться к данным который не адресуется явно передан ими ей указателями то есть грубо говоря мы вот на уровне session авокода получаем защищенности уровня там я вы или сишарпа то есть среды с менеджер указателями проблема кстати на самой очень большая во первых на самом деле существует довольно много кода просто тупо с ошибками которые вот таком режиме начинает взрываться во вторых кто видел там код ядра видел что часто очень в коде ядра в одно и то же поле которая описана как указатель когда целые числа например да это режим который не применим для защищенного режима и еще есть некоторое количество тонкостей например такие вещи как сет jump & long jump были брусе защищенном режиме это не то чтобы вообще невозможно но это прям война я немцы довольно трудно реализовать для прикладного куда они могут быть реализованы ядром а для ядра все совсем сложным вот тем не менее на самом деле ящики вот лично я считаю мне кажется даже самим создать альбуса не так уж сильно верят защищенный режим как я я считаю что это в этом огромная ценность на самом деле в этом есть огромная ценность даже уже на уровне какого-то фрагментарного использования потому что защищенный режим можно использовать например как инструмент тестирования кода если вы свой код прогнали защищенном режиме и все тесты прошли то считайте что получили в общем защищенный режим это такой аппаратный valgrind скорость исполнения абсолютный скорость исполнена уровне скорости процессора который проверяет все ваши указатели всегда можно не использовать его в продакшин коде но в во время тестирования здорово время кончается поэтому нас ради мне довольно мало осталось и под конец вернусь к вопросу о в исполнении 800 кода x86 wakodo значит процессора эльбрус штатно вот на уровне поставки имеют возможности для исполнения этого кода вплоть до того что на них можно windows загрузить и в общем весь код работает и происходит это дело через технологии бинарной трансляции то есть конечно же эльбрус не исполняет код процессора 8086 каких-то более поздних вместо этого в нем запускается бинарный транслятор который буквально читает инструкции 88 6 процессора транслирует их выставлен струкции из бруса и их уже исполняет но надо сказать что в чистом виде бинарная трансляция стоит очень дорого особенно для интела в основном потому что у интела есть так называемые сегментные регистры и операционной системы их активно используют в своей работе и сегментные регистры это означает что мы учим на каждый обращение к памяти должны выполнять некоторое количество математики с этими сегментами регистрами если бы это стимулировало с инструкциями эльбруса то нам пришлось бы почти на каждую инструкцию интела делать там по две-три инструкции эльбруса это было бы ужасно поэтому разработчики или груз а сделали такую очень интересно гибридная модель некоторые вещи которые очень дорого эмулировать они реально захочет загнали в аппаратуру процессора в частности процессор поддерживает эту самую сегментные адресации в режиме вот эмуляции x8 шестого года как раз адресные вычисление он проделывает сегментами аппаратно почти все остальное делается программно есть еще некоторые тонкости которые будут были сделаны в аппаратуре для очень чистой совместимости с 86 м кодом но не буду вдаваться в детали сам по себе нарын транслятор это же вообще то прям peace of art потому что он сделан как набор из трех трансляторов на самом деле еще интерпретатор который может прямо в без трансляции бежать по коду и прямо интерпретировать его транслятор состоит из трех уровней кода генерации самый банальный бинарный транслятор делает по инструкционная трансляцию берет тупо одну инструкцию intel а то подлиннее синтезирует соответствующий набор инструкций эльбруса которые исполняют это конечно очень неэффективно вот но для кода который один раз исполняется это с учетом стоимости трансляции которые тоже общем занимает процессор на и время это оказывается достаточно хорошим трейдером 2 транслятор это быстро регионы я транслятор он уже берет ни одну инструкцию я фрагмент ну как правило линейный фрагмент ну может быть на самом деле сложнее и компилирует его уже учитывая взаимосвязи между инструкциями где то он делает это более эффективно и если при этом при этом по все эти вот скомпилированный код вставляются естественном точки замера которые показывают что код исполняется там где-то редко или часто если кот исполняется очень часто то поднимается насчет тяжелой артиллерии в виде последнего этапа это тяжелый оптимизирующий компилятор который работает медленно но зато он выжимает из бинарной трансляции все что возможно и синтезирует действительно довольно эффективный код который в общем да безусловно все равно он конечно быстродействие уступает прямому исполнению на родном intel и но тем ни менее показывает очень вменяемо и быстродействие с которым в общем можно жить я честно сказать в общем нас на сегодня это уже не очень актуально там лет 10 назад когда он только появился это была осмысленна потому что родного кода под эльбрус было мало сейчас это в общем то уже я скорее этим восхищаюсь как фантастически хорошим инженерным решением потому что общем сделать бинарную трансляцию для полноценного с 64 бита современного интеловской процессора это в общем дорогого стоит вот тем не менее на сегодня а да вот еще вещь про который чуть не забыл сказать еще одна вещь и это на сегодня уже более актуально в штатный скомпилированный под или брус операционной системе linux возможен запуск бинарной трансляции для прикладного кода то есть если почему-то у вас нету прикладного кода в исходниках вы не можете wacom пернуть под груз то эльбаз позволяет внутри запущенного приложения сделать бинарной трансляцию и ваш экзешник извините пожалуйста ваш аут этом или файл с транслировать и запустить его на эльбрусе прозрачно как если бы он прям вот этот альбуса был скомпилирован в этом наверное еще в некотором смысле есть резон на сегодня потому что в общем даже под open source не весь source upon и не весь к сожалению доступен время совсем уж кончилось быстро там подведу итог с моей личной точки зрения я в общем знаю довольно много процессоров только они устроены очень много существующих современных очень много старых довольно много разных странных солнечных процессоров вот с мы точки зрения или груз это в общем инженерное чудо я восхищаюсь людьми которые его спроектировали этот процессор при всем том что я говорил сейчас про то что он в некотором смысле проще чем в омске и процессоры это не простой процессор с ним надо уметь в общем жить и в общем практика показывает что если у вас реально вычислительный код то надо приложить определенные усилия по оптимизации чтобы выкачать из эльбруса в силу производительность но во первых надо сказать что по этому поводу уже есть довольно много инструкции есть отличное руководство от собственно от разработчиков для программиста на сие есть библиотеки готовые которые уже оптимизированный под эльбрус есть уже довольно большой опыт перенесение кода на него и в общем на сегодня это уже довольно стабильная развитая среда в которой перенесена много кодов который работает много людей ну и мне кажется правильно будет сказать присоединяйтесь потому что это здорово спасибо спасибо большое дмитрий друзья давайте зададим пару вопросов и сразу 9 ну погнали здравствуйте и спасибо за доклад же скажите пожалуйста что но если такое есть вообще что нужно сделать простому человеку чтобы попробовать процессор можно не зрительно настоящий там ему лет значит доставлен пройти надо спросить инцеста конечно не меняя них не работаю но кроме очевидного ответа купить себе или bros его может купить уже на самом деле не существует программа дистанционного доступа вот прям свяжитесь с инцест и у них есть возможность дистанционно зайти на эльбрус и на нем скомпилировать запустить поработать там они довольно договора способна так что обращайтесь можно 1 раз я здесь слева вот дмитрий спасибо за доклад я не сильно разбираюсь процессорах но вопрос такой насчет предикатов очень интересная тема заменяет ли она собой писатель переходов смотрите спасибо большое на самом деле реально невозможно даже в час втиснуть все что хотел услышать и предсказание переходов есть и спекулятивное исполнении ли вы пусть тоже есть есть специальная поддержка для спекулятивного исполнения которая откладывает эксепшен и и вот на самом деле там в частности почему еще предикаты имеют два бита на предикат потому что у него еще есть значение типа но то нам верна который недопустимо и соответственно да это тоже присутствует не могу сказать в какой степени заменяет это вот опять же надо уже говорить с людьми которые на нем реально гоняли но спекулятивно тоже есть но раз есть прекратив кота начать безопасности получается всякие уязвимости типа спектр имела вот вы знаете опять же разработал разработчики процессоров отвечают что нет не происходит них не готов на и вот на сегодня ответить как именно не происходит но утверждается что вот я сейчас вам не совру прям чтобы твердо сказать надо надо посмотреть что-то из этих последних вот атак на эльбрусе вообще не проходит с какими то есть тонкости надо не готов вам сейчас подробно ответить помню что с частью по барр ну даже не поборолись об сходу не прошло спасибо вот следующего здравствуйте меня зовут андрей у меня вопрос по поводу тех случаев когда у нас нет компилятора совсем то есть процессор зависимо от компилятора а что если у нас программа написана на интерпретируемым языке или на языке который скомпилирован промежуточный байт-код типа джеем или код сишарп или например получается что код x86 проходящий через двоичный транслятор оказывается в точно такой же ситуации то есть для него не применялся компилятор эльбрус и получается в коде который прошел через двоичный транслятор нет вот этой вот рекомендации по параллельному исполнению и мне кажется в таких ситуациях по очевидно какой-то performance будет смотрите на счет на самом деле почему нет рекомендации от последняя фаза бинарного транслятора она довольно серьезная и в общем она довольно серьезный кот на иначе на в нативном альбусе но вообще в целом для языков типа я вода у которых jit компиляция происходит это все записывается в jit компилятор то есть в принципе это вопрос качества jet компилятора этого сами хороший вопрос потому что действительно вы правы backend стандартного си компилятора эльбруса и довольно сильный серьезный bekannt который реально хорошо оптимизирует насколько это реализовано с g том насколько я на сегодня знаю ситуацию до java для него есть jack сделан существует я не могу вам сказать что качество этого jetta ну запредельная да мне по сложилось ощущение что там пока еще есть место для подвига вот в по оптимизации именно йоркского jetta под эльбрус но по сути дела это вопрос именно написание правильного качество jetta опять же это это все та же вопрос времени конечно времени и усилий я знаю что есть усилие по написанию или льва м бэг-энда для эльбруса и это было бы конечно очень ценно потому что через или backend можно довольно много того что уже как бы вот в том большом мире происходит эльбрус перегнать и получить качественную куда генерацию но не могу вам сказать на каком она сейчас состоянии но пока я знаю хотя что интересно я знаю что в онлайне существует сайт на который можно зайти в лево кошечка пишете код на эльбрусе а справа прям показывают сгенерированный ассемблера эльбруса для вот этого хищного кода и что-то у меня есть позволяешь нам их 1 или 2 м используется внутри но не буду вам брать вот по моему львам для него еще не готов и джедда есть качество обсуждали не готов в общем сказать что очень высокая друзья наше время истекло но финальный вопрос и потом пойдем в цифровую дискуссионную зону да пожалуйста спасибо большое за доклад в продолжение вопроса про компиляторы хотелось бы понять насколько существующие компиляторы под эльбрус умеют генерить достаточно эффективный код для этой архитектуры и если можно как-то сравнить его с существующими решениями там для x86 на в клаенг и g7 спасибо значит смотрите по поводу эффективности но как более эффективную компилятор или гуса чем родной все равно не существует поэтому разработчики полагают компилятор очень эффективным тем не менее что интересно что каждый год вот у самой компании st есть такой теперь добиться на повышение качества компилятора еще 10 процентов увеличение скорости кода и пока общего я понимаю у них это удается там в общем есть еще определенный запас по глубине оптимизации хотя если вы почитаете их статьи по оптимизации то они очень впечатляют опять же вот на мой взгляд вот что касается gcc вообще надо сказать что или вот родной компилятор по фронту sgc очень хорошо совместим то есть как бы ну просто его можно подсунуть место в целом по опциям по всему что вообще релевантно прямо втыкается и генерится с linux собирают понять что делается просто вот эти вот компилятором которые вставлены место gcc по качеству оптимизации я я полагаю что в общем он довольно серьезно на уровне потому что опять же если почитайте статьи по качеству оптимизации то там люди занимаются выжиманием таких вещей что видно что это довольно глубоко при этом тем не менее есть очень много вещей которые на эльбрусе будут хорошо скомпилирован а если правильно написан и там на самом деле вещь это нехитрые ну грубо говоря если вы будете там например оптимизировать циклы которые считывают значение из массива с шагом там в 256 байт то конечно у вас будет постоянная война sky шонда и cycles он будет работать медленно если вы получите значение вплотную эту вот этот самый prefetch механизм для циклов будет тащить это линейками каша и правительств будет очень большая там на самом деле эти вещи не так уж сильно завязаны на специфике своей бруса но с учётом вот этого prefetch механизма да тем не менее там в общем есть вещи которые можно еще сильно выжимать понимая как он работает и на эту тему кстати довольно много статей даже на том же хабре которые показывают как люди достигали на нем хорошие поверхности понимая как устроен процесса"
}