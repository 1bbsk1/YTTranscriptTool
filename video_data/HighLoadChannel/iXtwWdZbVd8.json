{
  "video_id": "iXtwWdZbVd8",
  "channel": "HighLoadChannel",
  "title": "Как мы учились чинить самолеты в воздухе / Евгений Коломеец (Virtuozzo)",
  "views": 513,
  "duration": 1986,
  "published": "2018-08-16T04:50:03-07:00",
  "text": "а графстве он доклад иметь такое шуточное название как мы учили chinese самолеты воздухе на и как вы догадались самолетом и все-таки ничего с ними не делали а занимались мы починкой программ в тот момент когда они исполняются ну или как вы это назвали юзер space life починка здесь краткий план сегодняшний доклада я расскажу что такое лопатин зачем это нужно расскажу немножко состояние процесса какие момент времени мы патч можем приложить потом о том как патчу строен расскажу несколько динамических библиотеках и символах и потом как почти собственно говорят процессу прикладывается и как почти создавать и так что же такой life починка но и делает починка на похоже на идею обычного пачанга при обычно починки что происходит мы берем исходный код потом накатываем патч с необходимо нам изменению собираем восполняемые бинарный код и этот код запускаем случае слав паркингом мы делаем мы тоже применяем некие изменения но делаем это сразу двоичному коду и делаем это в тот момент когда он исполняется поэтому мы тут во первых должен это делать безопасно чтобы спасается ничего не случилось чтобы он там не покрасился или частным кит неприятность не произошли и должны при этом суметь сохранить создания процесс что когда процесс исполнялся он уже какой-то сцене накопил мы должны дальше продолжится то же самое состояние для чего это нужно вообще самый на такое частою space это когда у вас есть некий сервис в нем есть критическая проблема это может быть security уязвимость или это может быть какой-то там страшное падение производительности в эту проблему очень хотите хотите пофиксить но вы не можете этот или очень не хотите сервер стартовать примеру restart сервиса может занимать длительное время или вы не хотите что вас разрывали сетевые соединения при этом и таком случае вот можно исправить проблему с помощью live починка хочу сказать что такие подобные утилиты продукты уже есть это это это копать red hat его сделал как ровд с производства sussex place at оракла это все для ядра функциональность также есть подобные вещи для use space это коснулось опять-таки lip care недавно в клауд линуксе он появился есть как комьюнити всякие концертные проекты например понос но и наверное есть какие-то еще другие проект уже состояние процесса вообще что такое состояние процесса но для начала хочу сказать что состояние процесс это видит вас очень сложно она стоит из многих частей которые сильно связаны между собой поэтому ее можно уподобить карточный домик в неком смысле если что-то там случится с одной частью мы испортим то у нас развалится все и так же она состоянии постоянно меняется мое исполнение и что же входит в это состояние это во первых а статические переменные перемена которое уделяется этапе компиляции и адреса известных сразу динамические переменные на их адреса уделяется фронтами да например с помощью функций молок и исток-сток он содержит информацию двух видов когда это локальной переменной функцией и адреса возвратов но для нас наибольший интерес представляет алиса возвратов потому что для того чтобы патч корректно приложить нам нужно анализировать порядок узо функции и об этом чуть позже расскажу об измене мы можем носить с помощью механизма как других нас тема подобного рода тут есть достаточно существенное ограничение дело в том что когда мы патч прикладываем мы получаем новый код и этот новый код должен работать с уже осознанно станем процесса то есть он должен использовать переменный который уже есть которую уже имеют какие-то значения поэтому в общем случае в таких патчах тип переменных меняться не должен то есть мы не можем сделать патч который например понять куда перемену сантана лун если размеру гонка больше или сделать патч который меняет порядок полей структуре так далее что же мы тогда можем применять мы можем применять такие изменения которые меняются музыку процесс например мы можем добавить пропущенный проверку нулевой указатель или там по-другому корректно вычислять размер буфера чтобы не было overflow ну и так далее также из этого следует что здесь требуется ручной review кода то есть нет полностью автоматического способа чтобы мы там как патч скормили система сказал что да этот патч безопасно применять июня то есть тут с требуется некий ручной труд теперь когда патч вообще может быть приложим в какие моменты времени процесс описан исполняется о состоянии меняется поэтому логично что процесс начала надо остановить но недостаточно знаете в любой точке потому что для того чтоб патч может быть приложен должно выполняться очень два условия но 1 на очевидно тот код который мы заменяем в этот момент спать не должен если мы пытаемся сделать мы получим сразу же крышей в общем все на этом закончится второе условие но несколько менее очевидная а именно на тот код который мы почтим не должно быть ссылок на стыке сейчас я немножко объясню откуда это вообще берется ну предположим ситуацию у нас функция f позвала функцию же и мы делаем бинарный падь при прикладываем патч который меняет функцию мы поймали стрит в функции же где-то он там остановился приложили патч дальше мы этот тренд запускаем он бежит дальше вызывает функцию f идет на вызов функции f но здесь уже нападать на новую на новую версию функция f на новый код потом эта функция f отрабатывает все завершается хорошо и затем thread возвращается по адресу сохраненного на стыке но адрес крайне на стыке он указывает внутри старого кода внутри старые версии то есть у нас получается что патч приложили но при этом после это у нас работают и новую версию и новая и старая версия функции что в общем то может быть нежелательно например внутри функции там мог поменяться например хокинга и это все может привести плохим последствиям поэтому мы таких ситуациях хотим избегать для этого мы должны анализировать стеке вызовов сестре дав т.е. для того чтобы патч мог быть безопасно приложен call стыке всех thread'ов не должны содержать ссылки на те функции а тот код который мы по чем что если вообще бинарный патч представляет как я же варил есть много подобных систем и в общем большинстве из них код он меняется на уровне функции то есть если там функции там поменяла супер даже если поняла скота тенниса инструкция мы заменяем функций целиком ну почему это делается но это просто на первых и вторых это достаточно надежно что самое главное поэтому для того чтобы создать патч мы берем все те функции которые мы хотим поменять и запихаем в динамическую библиотеку vr-формате и затем эту белеть динамической библиотеку мы погружаем в адресное пространство процесса которым хотим пропатчить начатых библиотеки это в общем библиотек совершенно стандартная в общем заключением того что мы в эту библиотеку добавляем отдельную секцию и в них хранится метаданные которая позволяет сопоставить символы в этой библиотеке или какая буду называть патч и с процессом который мы хотим про патч таргет процессы называть вот эти метаданные это представляет собой собственно адреса символов и такое поле как билл дойди зачем нам билде нужен вот когда мы собираем патч когда мы делаем пачку дела ни для какой конкретно для текке вообще то есть мы не можем например создать там почти для окон и ссср мы делаем этот пакет конкретно сборка библиотека библиотек потому что в разных сборках будут разные адреса символов и невозможно сделать универсальный патч на все поэтому чтобы у нас чтобы быть уверены в том что наши адреса символ сохраненные метаданных корректны мы также требуем совпадений бил дойди что такое бил зайди туда дед стандартное поле в аль формате в общем сейчас часто где есть ну прям сразу присутствует и она собой представляет фактически хэш от частей эль файла от исполняемого файла то есть там хэшируется там сегмент кода там еще что то так в общем все эти часть которые необходимы для исполнения опциональной части вроде там таблицы символов и те часть которым мог быть по стрип она не в этот хэш не входит теперь немножечко динамический библиотеках как они устроены мы предположим что есть у нас такой простенький код какая-то функция использует некой внешнюю переменную вот такой совсем тривиальный пример и мы собираем виде динамической библиотеки в формате что будет внутри этой библиотеке очевидно будет у нас код будет у нас код сам вот эта функция f но вопрос как этот кот может получить доступ переменной адрес которого не знает то что на этапе компиляции вообще говоря про адрес этой переменной ничего не известно для того чтобы решить эту проблему в компилятор создает такую структуру данных называемый глобула в сад apple это фактически просто таблица адресов и когда кот хочет получить адрес переменной var он из этой таблицы например там из слота номер три там берет адрес этой переменной и потом с этим адресам работают откуда берется адрес переменной т таблица это уже работа динамического линкера и динамической linker заполняет таблицу когда у нас библиотека погружается уже когда он уже используется для этого используется там пару структур данных который опять-таки selfie 1 это таблицы релокации и 2 таблицы символов таблица аллокаций она содержит в себе записи них есть поля первое поле это офсет 1 полях сатана указывать то место которое нам библиотеки нужно поменять linger то есть куда нужно прописать изменения 2 поле индекс она связь она связывает данную локацию с данным символу и третье поля dent это слагаемое которая прибавляется кадры всему то есть данной ситуации у нас есть локация она ссылается на символ с именем war динамический linker находит а где у нас определенного в процессе находит его адрес прибавляет к нему ident слагаемое и прописываю про всю эту по все это указанному таким образом массу он заполняет таблицу смещение углов 100 был после того как динамический linker прошелся по всей таблице аллокации у нас динамической библиотека становится готова к использованию после этого все уже можно и запускать передавать мне управления я тут говорил о символах эльфа какие собственно говоря символы бывают бывают они нескольких видов первый это так давай им статические символы в чем их особенность особенность в том что область видимости такого символа она ограничена одним файлом но если быть точнее одной единицы трансляции в языке си определяются не с помощью ключевое слово static это как у нас такие символы в видны только внутри 1го файл то средства внутри одной динамической библиотеки или внутри одного исполняем файла таких симонов может быть могут например может быть файл символ с именем war там поля . себя . си эти силы между собой совершенно не как независимый код в кадр в каждом из эту файла ms использовать свой символ если мы там загрузим щетки этой библиотеке то это на этот код никак не повлияет соответственно если такой символ определен в исполняемом файле то его адрес он известен просто этой компиляции да и поэтому кот не может обращаться по абсолютному адресу например адрес у него будь то 0x 1234 если же такой символ определен внутри разделяемой библиотеки то вообще говоря адрес символ заранее неизвестен то что сама библиотека может быть загружен быть по произвольным адресу но при этом известен и постоянен в сад то есть смещения этого всем относительно чай библиотеки то есть например тот всему может быть отстоять от адрес загрузки библиотеки на 100 со смещением 100 например и код который использует такие символы статически он для этого но на x 864 использую три против адресанта есть адресации относительно указателя команд примеру чтобы там использовать такой символ команда может его адресовать как европе плюс 300 то есть текущий указатель команд плюс смещения 300 следующий следующий вид символ фотосинтез дефолтный видимостью с объявляется не проще всего языке си просто без всяких ключевых слов такие символ а не в отличие от статических они видны в пределах всего модуль то есть предел все библиотеки или в пределах всего исполняемому файлу и не может быть двух сел с незнакомыми им также такие символ они видны за пределами модуля например если определитесь ему варуха default невидимостью то он может в библиотеке x то он может быть использован быть и из какой-то другой библиотеке y ну собственно говоря такие символы они как бы и составляют api любого библиотеки то есть например если мы используем там молока из глеб седан то и молоко тон иметь такую дефолтную видим вот тогда интересно вопросу некое то что будет если у меня в процесс загружено 1 пара библиотек и в каждой из них определены символ знака мы виним ну из дефолтной видимостью что-то будет тогда оказывается что весь код будет использовать только один такой символ вот называется ты явление символ der позиция замещение символов вот и реализуется достаточно просто дело в том что у динамического linker и есть список эльф модулей в котором осуществляет поиск символов когда например хочет призван символ war он идёт по этому списку и находит первое с первой совпадение если такой сел он найден то он возвращает адрес и первым в этом списке первым в этом списке идет сам исполняемый файл и потом библиотеки в порядке загрузка пускай какой бин и лес там то сначала в этом списке будет тебе на лес потом липси и потом еще библиотеки который там ему и тогда у нас получается тут возможны две ситуации сотрясаться таких символов в коде первой ситуации если такой силу определенную внутри исполняемого файла таком случае этот сему не может быть замещены другим символ точно принесли определил переменную war внутрь экзешника внутри исполняемого файла то этот символ не может быть замещена неким другим силам из какой библиотеки и поэтому опять таки для тех символов адреса они известны момент компиляции абсолютно адреса а в случае есть такой символ определён библиотеки то в общем получается что-то адрес этого символа неизвестен того момента как библиотека будет загружено в адресное пространство процесса вот и поэтому для библиотек там используется механизм адресов через globalsat ты был про которые до этого рассказывал и потом идет следующий класс символов he don't символа зачем они нужны мне нужно для того чтобы подавить этот механизм в замещении символов то есть на про если хочу иметь какой-то символ который виден в пределах всего лишь модуля но я не хочу чтобы у меня отрабатывал отрабатывал такое вот замещение символов я могу объявить всему например как hidden простого синтаксиса языке стены продали его нет клипсе можно использовать такой вот синтез атрибутов и что какие особенности этих символов но это нечто среднее между симмонс дефолтные видимостью и символами статическими как символы с дефолтные видимся недоступна предел всему модулю то есть любой код из библиотеки может использовать но как статические символы эти символы не могут быть замещены и они не видны за пределами библиотеки которые не определены то есть точки зрения генерации кода с точки зрения обращение к не всем они в общем то эквивалента статическим символом так но будут говорил что мы сохраняем некоторые метаданные в патчи для того чтобы связать символы в процессе с символами в нашем паче из того что я рассказал в принципе становится понятно что символы все символы можно как бы разбить на две категории 1 категория это символ и адреса которых известны заранее то есть это статические символы hidden символы и символ с дефолтной видимостью для исполняемых файлов для таких символов мы сразу можно сказать какой ни будь то адрес или абсолютно адрес или адрес на стекле модуль которого определен поэтому в момент генерации патча мы такие силы просто резон находим их адрес и мы вот эту информацию помещаем в табличку что и чтобы таблички слева индекс это индекс символа индекс символа в таблице символов патча а справа это адрес соответствующего символа в том модули которым хочу вот и вторая часть метаданных наших это адреса следующих функций в таргете и в патче они нам нужны будет для того чтобы для того чтобы перенаправить управление потом собственного а как процесс приложения патча выглядит вот у нас есть на пряники процесс вот и адресное пространство есть функция f использованию переменной var мы хотим его про падь что он должен для этого сделать первое непосредственно что мы должны сделать это загрузить нашу библиотеку наш patch в адресное пространство казалось бы достаточно простая задача но на самом деле это не так какие здесь сложности дело в том что в вину xenith стандартного способа как-то модифицировать адресное пространство произвольного процесса системный вызов им map но он на модифицирует адрес написан от текущего вызывающего процесса вот и нету какого-то системный вызов который позволил бы понять адрес на просторную произвольно процессу как раньше проблема решалась вот например в проекте понос они просто сделали своему литра который реализовал системный вызов и map 3 это стандартный map плюс еще один аргумент пит процесса алекса про сон с которого мы хотим поменять мы эту проблему решили стандартными средствами на именно с помощью систем на вызову по trace как мы это делаем мы в процессе находим подходящий mapping тот который поддерживает там тот у которой есть разрешение на исполнение кода мы туда енджэ актив свой код небольшой и опять с помощью потряс передаем на нее управление этот кот уже потом в контексте нужного нам таргет процесса вызывает системный вызов нужный нам imap мы получаем там адресное пространство но и затем мы восстановлена переписанные данные после того как у нас есть адресные пространства туда можем загрузить по чем она опять например с помощью механизма по tracing затем наш patcher процессе таблице аллокации он идет по всем локациям так он идет по всем локациям смотрит на индекс символа если из отличий индекс символа сохраненных наших метаданных он использует адреса с метаданных если если же метаданных ко всему нет то этот символ или золоте стандартным образом по именем точно ж поделать стандартные динамический linker после того как patcher прошелся по там по таблице локации у нас получается настроенной все ссылки на данные прописали тонн при адрес переменной и после этого нам остается только перенаправить управление со старого кода на новый но это делаем просто как все другие системы ты делаем просто в начало функция вставляем команду джон новый год после этого в общем процесс починка завершён можно продолжать процесс резюме 3d она теперь расскажу как собственно рыбачили тот создавать вот например есть у меня какой-то код какой то прибавлять эти поля . сие есть функция f я хочу про патч фунтов на привод минус минус я хочу поменять на плюс плюс как я это делаю я беру тот кот я беру новую версию кода которую я хочу получить складывание киев складывать какой-то files произвольный номер apache . 7 ту совершенно может произвольно и подключаю набор вопросов который позволяет мне сделать связь символов патча и символов в то библиотек которые хочу пропатчить здесь используется два таких макросом первый из них называется музыку файл он сдает область поиска символов как я же говорил имя символа но необязательно уникальный случай этических силах при их может быть много и поэтому для того чтобы можно было назначить ему найти я сдаю область поиска в данном случае что этом окраска этом говорить что весь код который находится ниже статически символ в нём они должны из конца файла . си а второй макрос он собственно и делает ссылку на переменную когда этот макрос и граница во-первых мы получим саму ссылку на переменную виде там экстерн and war и этот макрос тоже откладывает метаданные метаданные про эту перемену в данном случае метаданных будет сказано что это переменная типа static но эти метаданные опять-таки кладут в отдельную секцию и эта секция потом читается генератор при генератора скажи новичкам уже вот что мы потом с этим почти делом мы его сначала компилируем как стандартную разделяем периотек уже все минусы в пик минус шарит так далее получаем ли патч . затем этот липочка сумму из карлин генератору генератору который упоминал это генератору берет два аргумента первый аргумент это имя вот посту bine repo man там по авто баннере это никто библиотеки которую я хочу патчить и мой патч что делать генератор во-первых он из этой библиотеки который хочу пропатчить сохранит билде внутри патча чтобы потом можно было патч сопоставить с нужный библиотекой в процессе и затем идет процесс рисового символ для этих стимулов адреса которых мы можем заранее поризованный как рассказывал мы генератор это делает используя де важную информацию для для этой библиотеки и вся эта информация она сохраняется секцию метаданных это секрет который будет потом используется patcher у и наконец патч можно приложить процессу делают команды вот называется нанес бы у нас она берет два аргумента 1 the patch и 2 the pitt получив от процесса она идет по адресу пространство процесса смотрят все эль файлы которые туда зама плен и если есть файл совпадающим бил дойди то тогда этот почти до прикладывается ну так же есть ещё и другая функция сна при этот файл пачка то можно 3 вердикта вот ну теперь небольшое заключение плюсы-минусы нашего подхода ну самый очевидный минус который есть от то что требуется некая ручная работа вот остальное это скорее плюс а во первых сам большой плюс точным использовать стандартное ядро мы не используем никакие нестандартные сколы поэтому механизма толпа чего не может применяться на широком круге стен второе мы используем стандартную сборку бинарник of то есть для того чтобы пропатчить бинарник нам не нужно собирать вот специальным компиляторы тем более нужно специальный компилятор единственное что требуется только наличие де важной информации но это как правило является проблемой также для всяких низкого уровня к задач мы используем ряд библиотеку вот для таких задач как остановка то рода продолжение тренда вот это вот inject кода мы используем для тех липком pearl этот проект проекта криво проект или он занимается миграции контейнеров можешь врозь как чекпоинт ресторан user space поэтому общем там ему требуется такая же функциональность как и для почитания и ну и наконец для анализа стыков мы использовали buy online для тех это тоже нам помогает меньше возиться всякий низкоуровневая архитектурно зависимым кодом вот не с самим проектом если кто заинтересуется можно ознакомиться на гитхабе поэтому oris лежит у меня все спасибо спасибо за доклад вопросы пожалуйста задавать по микрофону и за самые интересные и лучшие вопросы и за сам интересные лучше вопрос евгений выберет некоторых которые можно раздать наклеечки за которые можно получить призы евгений у вас там было еще один параметр минусу 0 собственно говоря без него то можно атос без оптимизации котов очень хреново обычной работой да вот это очень интересный вопрос ну он у лимона на самом тут потом причину ну во-первых безумно ли мы можем сразу как решит стать функций тоже компиляторах сразу выгонят это одна проблема вторая проблема она как бы более тяжелое это в том что если какие-то функции не предоставляют не является свой публичный api ну представьте к функциям the compiler он может там принять всякий оптимизации вот и в общем есть такая сейчас достаточно сложная проблема что с этими активизациями делать в общем эти оптимизациях можно как бы на три класса поделить первое это онлайн функцией второе это изменение там всякие входных параметров и 3 это когда меняется раньше выходных параметров первая проблема на простая то есть то что функция поняла ним эта информация с debug info то есть если функция поняла не но мы можем просто там сказать а вот еще надо почет эту функцию включить потому что в нее появилась функция да вторая проблема тем когда идет оптимизация аргумента функции тоже можно решить потому что принципе если мы находимся некой точке то с помощью дебага нтв мы можем выше значений грумер например у нас было к это функция tom 2 аргумента х x y до компилятор y выкинул потому что он все время был равно 5 до используя баф инфо можем понять мы можем понять как вычислить x и как вычислить y отвар сливают foo будет и третья проблема вот то что 3 проблем в чем заключается насчет рэнди параметров например есть некая функция int она возвращает перемену перемену до компилятор понял что значение переменной а от одного до десяти всегда исходя из этого сделал оптимизации каких других функциях и вот после того как мы прикладываем патч принципе это предположение о том что результат функции он находится там в промежутке от он 10 он может быть больше не верно это вот сложной проблемой у непонятно как решить мы как бы об этом всем знали у нас в принципе сейчас в разработке находится несколько другая версия она меняет библиотеку целиком то есть например если я хочу пропатчить ли все я просто загружу полностью липси дождусь пока процесс из не выйдет и и поменяю код но минусы очевидно до больше надо кода там будет больше надо мест по чуть больше будет печь болтов там памяти будет больше заниматься но зато как понять что оптимизации они не могут вылезти за границу библиотеки спасибо за доклад у нас система на сишарпе ну все на винде шар из из планет и так далее ваша как его система она применима к таки у меня настолько для только для linux да а вообще вопрос сколько длится самого life пачек по времени сразу мгновенно и без простоя дополучает тут дело в чем это зависит потому что нам нужно понимать процесс нужно в нужный момент времени да то есть он может какую-то функцию ти и там находиться все говорят долго тут сложно дать какую-то гарантию что вот там останавливается сердце эта функция да какой который почитаемые ну как делается мы сейчас делаем достаточно просто мы берем процесс останавливаем анализируем все стыки если состояние подходящим и подчинись нет моего резюме через какое-то время опять восстанавливать то есть простой и все запросы к этой функции не все не прохода нет простой там очень быстрый то то есть мы как бы мы взяли остановили процесс с помощью там либо инвайн там проанализировали все стыки то есть это быстро достаточно происходит потом если сцене подходящему почему не подходящим и просто резюме процесс и через некоторыми 5 ретро им счет идет на минуты секунды ощутила ну вот простой счет на на что идет минуты и секунды часто день ну зависимость того какую функцию хотим пропатчить например мы хотим к какой-то функция условно говоря такой экстремальный вариант вы хотите про почти функцию main из функции main процесс ну если выходит то все да то есть если вы хотите про почти функцию main вы никогда не пропатчить поэтому это в общем зависит от того какую конкретно функцию пальчики насколько долго в ней процесс времени проводят спасибо за доклад я так понял все это касается библиотека написанных на си си плюс плюс си плюс плюс ну в принципе можно было бы принести плюс плюс там мне кажется основная сложность он как связать вот функции там в патчера с функциями процессе фото 6 плюс плюс там есть такие вещи как over low данным space так далее выдает вот это все да да да то есть в случае с сетом с помощью этих магов с которым и сделал там достаточно просто описать да какую конкретно символ мы хотим как массивах не подступиться случае с плюсами это не очевидно да в принципе с плюсами можно использовать это вот уже имя которое получается после managing вот этот кривое до но это такое нет да да но это не элегантно получается на виндоусе хотя бы теоретической есть возможность что-то подобное прогород на виндоусе но и за ним невозможно даже теоретически ну наверно наверно можно до если на"
}