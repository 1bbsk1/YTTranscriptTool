{
  "video_id": "SkDHl_g23q4",
  "channel": "HighLoadChannel",
  "title": "Особенности разработки Open Source-приложения для real-time-стриминга IP-камер / Алексей Хить",
  "views": 124,
  "duration": 2591,
  "published": "2024-10-29T03:00:09-07:00",
  "text": "я приглашаю на сцену Алексея мы услышим доклад про Ну библиотеку это же мош назвать библиотеку это приложение оно самостоя приложение хош про приложение Угу Всем привет Меня зовут Алексей последние 4 года Я активно разрабатываю разные о Source проекты в основном они посвящены тематике умного дома а-а мой github на сегодняшний день набрал уже там более 10.000 звёзд суммарно А если вы пользовались платформой умного дома Home Assistant Возможно вы пользовались каким-нибудь из моих проектов а среди русскоязычной аудитории наиболее популярен проект Яндекс станция для управления колонками с Алисой м в умном доме также встречаются такие устройства как IP камеры а а в результате чего и появился проект Go To rtc Go to rtc - это приложение для стриминга камер в режиме реального времени а оно поддерживает огромное количество протоколов на вход поддерживает все основные стриминговые протоколы на выход поддерживает двухсторонние аудио и много чего ещё а некоторые протоколы Go ttc поддерживает эксклюзивно допустим по мое По моим данным А это единственный в мире Open Source проект который поддерживает стриминг с камер по протоколу ekit Это довольно такие хорошие камеры потому что производителям этих камер приходится соответствовать стандартным качеству фирмы Apple также из такого экстравагантно поддерживается стриминг с пылесосов рок в последних моделях старших моделях пылесосов ставят камеры для того чтобы они там обнаруживали носки всякие провода не наезжай на них не засасывает поддерживается двустороннее аудио То есть вы можете практически с любого браузера позвонить на свой пылесос и пообщаться с домашними можете использовать пылесос в качестве информатора какого-то там какие-нибудь уведомления с помощью него выводить там допустим что у вас протечка случилась а также можете стримить музыку на ваш пылесос Это тоже поддерживается а проект молодой а ему чуть больше года но он уже набрал более 2.000 звёзд на гитхабе а более 370.000 скачиваний на гитхабе ой на докер хабе и более х 260 скачиваний на гитхабе здесь цифры устаревшие уже там количество скачиваний растёт по десяткам тысяч в неделю м проект активно встраивается другими Open Source разработчиками в свои А проекты и разные энтузиасты собирают дистрибутивы под разные платформы из наиболее интересных интеграций можно выделить egate это nvr платформа Network Вио Recorder куда вы можете подключить все свои камеры там будет вестись локальная запись с этих камер egate поддерживает очень большое количество детекторов людей животных автомобилей причём поддерживаются детекторы под разные аппаратное ускорение То есть это процессоры Intel видеокарты NVIDIA Google Corel Этот проект очень популярен среди пользователей Home Assistant и также небольшой Инсайт со мной связывался разработчик расширения под Home Bridge камера ai есть такое расширение и он тоже переделывает стриминговые ядро своего проекта под go to rtc Так что Надеюсь вскоре и фанаты Home brid тоже будут пользоваться А у них появится свой nvr сердцем которого будет Go rtc А вот ещё один интересный проект - это альтернативные прошивки к камерам Wi это такие дешёвые китайские камеры от того они популярный и разработчик этого проекта встраивается Go ttc непосредственно в прошивку камер то есть приложение запускается на слабенько и довольно дохлебывай использовались в этих прошивках ранее а это к тому что goc настолько хорошо оптимизирован что может отлично работать на железе А таких камер и в том числе а этому способствует язык Go который может скомпилировать э ваше приложение вот на такую редкую архитектуру допустим На этих камерах используется архитектура mips м как я уже ранее замечал Go rtc поддерживает большое количество протоколов и форматов И подавляющее большинство этих протоколов и форматов написал я сам с нуля с полного нуля А за исключением webrtc для GTC используется популярная в Go библиотека от команды pion все остальные разработал я сам а если в ваших проектах понадобится использование каких-нибудь из этих протоколов можете посмотреть как это реализовано в Go ttc или подключить А эту штуку в качестве внешней зависимости некоторые разработчики так уже и делают а вообще в стриминге видео нет ничего сложного по сути это просто перекладывание байт из одного места в другое и от вас как от разработчиков требуется просто это делать очень аккуратно и очень оптимально А и как раз со слайсов байт и я бы хотел начать свой доклад м на мой взгляд слайсы байт - это просто гениальное изобретение от авторов Go снимаю перед ними шляпу и гениальное оно тем потому что если вы умеете И хотите лоцирование и не хотите аллоцировать память Вы можете этого не делать и ваше приложение всё равно будет работать как в первом так и во втором случае только вот в первом случае оно будет работать более оптимально А и более производительно когда вы смотрите в коде на отдельно стоящую строчку upend без какого-то там дополнительного контекста вы не знаете произойдёт там под капотом локация памяти или не произойдёт в этом и есть вся магия Go Вот например возьмём функцию по упаковке rtp пакета в некоторый сй Bite это функция из библиотеки как раз rtp - это самый популярный формат для передачи а видео в реальном режиме времени здесь авторы библиотеки сами лоцируются необходимый фрагмент памяти и записывают туда rtp пакет и также они предоставляют другую функцию которая позволяет вам самостоятельно лоцирование данная функция вызывается сотни и тысячи раз в секунду и как бы это очень большое количество локаций памяти и большая нагрузка в последствии на сборщик мусора то есть от вас как от разработчиков требуется всегда помнить там стоит ли или не стоит иной раз аллоцировать память к слову в первых версиях Go TC использовалась первая версия функции в впоследствии Я уже оптимизировать этот код то есть не обязательно оптимизировать код там А с самых первых версий вашего приложения вы всегда можете там улучшить производительность вашего приложения а в следующих версиях в обновлениях ещё интересный факт про слайсы не все его знают Это проверка на выход за границы слайса в стандартной библиотеке Go можно найти вот такую вот конструкцию это упаковка двухбайтовым странная запись где разработчики берут некоторый элемент слайса и приравнивают его к пустоте зачем это делается А если кто не знал Каждый раз когда вы обращаетесь к элементу слайса компилятор Go вставляет в это место проверку на выход за границы слайса и если а выход за границы происходит компилятор вызывает панику То есть когда ваши приложения падают по причине выхода за границы слайса это не непредвиденная ситуация это вполне предвидела её предвидели и сделали проверку и упали и каждый раз когда вы обращаетесь к любому элементу слайса вызывается эта проверка А вот такой вот конструкцией когда вы в начале функции обращаетесь к максимально возможному элементу слайса которому хотите дальше обращаться это подсказывает компиляторы что проверку на выход за границы стоит поставить именно тут и больше чтобы он эти проверки не вставлял опять же если такая операция вызывается очень часто это сотни тысячи раз в секунду имеет смысл произвести такую вот оптимизацию кода и Существует такой вот очень удобный инструмент для проверки разных оптимизаций кода от Go это компилятор из кучи разных языков некоторый байт-код и вы можете даже не понимать какой байт-код получается на выходе из этого компилятора вы просто Можете написать две разные функции и сравнить два результирующих байко и скорее всего этого вам хватит Чтобы понять какая из функций выполняется более оптимально вот в данном случае а можно найти что проверка вставляется в одном случае один раз на выход за границы и вызов паники тут тоже можно найти и во втором случае проверка вставляется два раза это очень интересный инструмент чтобы проверять какие-нибудь каверзные вопросы на собеседованиях когда там любят задавать а Как ведёт себя компилятор в том ином случае вот вы можете отладить на этом инструменте только Аккуратнее А в этом случае Вы можете быть даже умнее интервьюеров они это не любят а следующая тема которая Я хотел бы обсудить это ридеры и райтеры на мой взгляд это ещё одна гениальная штука от авторов Go они её используют повсюду А моя среда IDE подсказывает что ридеры райтеры используются в исходном коде Go более 400 раз каждый и это как бы намекает нам что нам нужно вовсю использовать как встроенные интерфейсы ридеров и райте так и писать свои А например у нас есть некоторая функция продюсер которая получает на вход видеопоток по первым байтам этого потока понимает что за формат к нам пришёл вызывает определённые функции для распаковки этого потока и на вход это функция принимает именно р зачем Затем что сам поток может прийти к нам совершенно разным транспортом это может быть tcp соединение http соединение это может быть входящее исходящее tcp http соединение вот в случае tcp соединения А сам Connection исполняет роль ридера в случае http соединения respons Body исполняет интерфейс ридера и также допустим ST Если вы вызываете какую-нибудь внешнюю утилиту она тоже отдаёт вам этот поток тоже std Out выполняет интерфейс ридера таким образом написав лишь один раз код продюсера Вы можете его подключить куче разных дополнительных транспортов если завтра появится какая-нибудь камера от какого-нибудь производителя которая допустим передаёт данные по протоколу websocket довольно несложно будет написать соответствующего ридера и подключить уже имеющемуся продюсеру вам не надо будет переписывать код продюсера А вы сможете поддерживать ещё один протокол а или вот ещё пример написания собственного ридера с буферизацией этот ридер умеет включаться в определённый момент умеет выключаться в определённый момент и поддерживает функцию перемотки в видео стриминге существует такая проблема что иногда нужно прочитать первые кадры потока что чтобы понять что там за кодек к нам пришёл параметры этого кодека ширину высоту картинки А вот вы прочитали эти первые несколько кадров И после этого надо эти кадры отдать дальше клиенту Чтобы это сделать конечно Вам надо куда-то эти кадры сохранить это вот этот буфер исполняет именно эту роль в тот момент когда вы готовы читать кадры включается этот буфер то есть до этого момента Он был выключен все данные через него проходили насквозь включается некоторый буфер с ограниченным размером чтобы мы случайно там не ушли в переполнение какое-нибудь и по окончанию а функции когда мы там узнаём что за коды к нам пришёл мы этот буфер перематывают готовы отдавать поток клиенту А этот буфер сначала прочитает все данные которые в нём лежат отдаст их клиенту А после чего там самоуничтожиться очистит память и переключится в режи режим прозрачного прокси будет просто передавать данные насквозь через себя а также есть стандартный буфер от авторов Go и тоже очень такая очень мощный инструмент для оптимизации ваших приложений Как и где вы можете его использовать как и где его нужно использовать чтобы оптимизировать ваше приложение допустим рассмотрим код а чтения из веб сокета - это низкоуровневый код который читает данные из Веб сокета на уровне tcp чтобы прочитать сообщение из веб сокета вам нужно сначала прочитать заголовок сообщения из заголовка сообщения вы понимаете насколько оно большое а сообщение в сокета бывает трёх разных размеров маленькое среднее и большое и после того как вы прочитаете А размер сообщения Вы можете собственно просчитать его пайлот в итоге а для того чтобы прочитать одно сообщение из веб сокета вы делаете три чтения из сети чтение сети это очень дорогая операция когда я проводил профилирование go to rtc основное время приложения тратилова стек на общение приложени с операционной системой на вызов си сколов А И эту функцию вы оптимизировать не можете она уже работает там на своём максимуме что вы можете сделать как разработчик - это уменьшить количество этих вызовов и для этого как раз существует буфер в случае с веб сокетом допустим если мы здесь бы вместо коннекшн использовали буфер как бы он поступил при чтении заголовка сообщения буфер бы просчитал из сети абсолютно всё что сеть способна ему отдать в этот момент это могло быть и 2 байта и сотня байт и несколько там а тысяч байт мы не знаем а tcp соединений - это потоковое соединение и все данные а ложатся в tcp соединени по очереди вот а первое чтение заголовка сообщения было бы действительно бы из сети второе чтение размера сообщения скорее всего бы попало в буфер чтение лода если он небольшой тоже попал бы в буфер и более того чтение следующего заголовка следующего сообщения и лода следующего сообщения тоже мог бы попасть в буфер мы этого не знаем то есть за время как мы читали сокета туда могло накопиться очень много сообщений тем самым используя буфер в правильном месте мы очень можем оптимизировать наш код после того как я добавил буфер в ТСП протокол а нагрузка на CPU уменьшилась на 30% это огромное ускорение и многие пользователи это подтвердили что вот в их показаниях нагрузка на CPU уменьшилась на 30% А это как бы нагрузка 24x 7 через Go ttc проходит огромные гигабайты данных 24x 7 у многих пользователей с большим количеством камер Так что 30% - это очень большой прирост Не забывайте пользоваться буферами но не стоит вставлять их вообще куда попало потому что допустим стандартная библиотека Go уже содержит эти буферы там авторы языка позаботились о нас А эти буферы есть и в входящем соединении Когда вы реализуете веб-сервер эти буферы есть и в исходящем соединении Когда вы реализуете клиента но стоит помнить что стандартный размер буфер это 4 КБ если в ваших приложениях там нужна другая цифра Вы можете её поправить для этого есть config Аа ещё такой момент а стоит помнить что некоторые операционные системы в частности Linux поддерживает очень быстрое э копирование данных из одного сокета в другой соке и также поддерживает очень быстрое копирование данных из файла в сот А от вас как от разработчика главно только правильно этим инструментов воспользоваться допустим Если вы вызовете операцию ко где с одной стороны будет файла с другой стороны сетевое подключение А язык Go сам поймёт что вы это делаете допустим на операционной системе линуса сам поймёт что один из дескрипторов является файлом другой дескриптор является сетевым подключением и вызовет для этой операции системные AP системные линуса при этом данные не попадут даже в ваше приложение а переложи из одного дескриптора в другой это будет очень быстро на именно на таких подходах и построен Очень популярный сервер engin То есть он завоевал свою популярность тем что он использовал вот такие вот оптимальные IP операционные системы Везде где это возможно и у вас тоже есть возможность пользоваться этими Вот они тоже встроены в Go Главное правильно их использовать ни в коем случае там не копировать эти данные самостоятельно там альтернативной версии может быть просто чтение из файла в какой-нибудь буфер и потом перекладывание этого буфера в сот при этом оптимизации никакой не будет далее Я хотел бы поговорить про http и особенностей связанных с ним нам мее это Котен Type Если вы не в курсе то если вы не укажете своему респонс Котен Type то язык Go полезет и попытается его автоматически узнать И если заглянуть внутрь этой функции Она довольно большая там очень много операций Так что А если вы знаете контент тайп своего респонс лучше его предварительно Установите Не заставляйте Go выполнять какие-то дополнительные операци там где это не надо ещ одна особенность райте допустим когда вам нужно передавать потоковые данные в данном случае у нас есть пример протокола mgp там кадры передаются один за другим и важно помнить что когда вы вызываете операцию в это ещё не означает то что данные попали в сеть данные попали только в буфер помним что между нашим кодом и сетевым подключением GH вставляет буфер А и как раз операция Flash а служит для того чтобы подсказать нашему приложению что Мы закончили допустим А ложить данные в сеть и их а надо закончили ложить данные в буфер и их надо отправить клиенту без этой операции тоже всё будет работать но к сожалению Клиент будет получать кадры с отставанием на один кадр то есть к нему прилетит очередной кадр только когда вы вы запишите в этот буфер следующий кадр если буфер переполниться допустим А ещё одна интересная штука это захват соединений используется не очень часто но тоже доступно А я её использовал в протоколе Home Kit ekit протокол он изначально делает обычное обычный пост запрос и после того как он сделал этот пост запрос наворачиваются шифрование придуман инженерами Apple и в данном случае как раз эта возможность райте сильно помогла то есть получаем сырое соединение и работаем с ним как как хотим стоит помнить что в этом случае уже закрывать это соединение А это ваша обязанность это в ваших руках оно автоматически не закроется также эта функция используется при реализации сервера веб сокета там в известной библиотеке Gorilla то есть захват сетевого соединения А и реализация какого-нибудь дополнительного не http протокола далее Я хотел бы поговорить про маршалинг и ан маршалинг и на мой взгляд это ещё одна гениальная штука разработанная авторами языка снова снимая перед ними шляпу и про особенности маршелин стоит помнить что авторы разных библиотек э добавляют авторы разных библиотек маршалинг добавляют туда некоторые специальные типы которые меняют поведение библиотеки при А распаковке И запаковка если вы не знаете как распаковывается тот или иной ключ Джейсона допустим Вы можете распаковать те ключи которые вы знаете Как распаковываю указать те ключи которые вы не знаете как распаковать именно на этом шаге и распаковать их уже на следующем шаге А в зависимости от значений известных вам ключей ну эту штуку Возможно там большинство из зала знает но такой же интересный ход есть и в библиотеке Ямал и даже более интересный он там поко в библиотеке ял Я заметил что если вы ан маршали ваш yel файл в переменную типа yel Note то вы получите очень подробное дерево тегов там останутся все комментарии исходного ял файла останутся позиции всех ключей и всех их значений и с помощью этого подхода мне удалось реализовать функцию правки yel файла с полным сохранением форматирования то есть допустим Если вы читаете яфа вносите в него программ на какие-нибудь изменения потом сохраняете его Ну тоже самое с ном то вы полностью теряете то форматирование которое было в этом файле и все комментарии все отступы становятся стандартными А вот и если пользователь там имеет доступ к этому я файлу он очень огорчиться Если вы нарушите этот файл и вот такой подход как раз позволил реализовать функцию сохранения полного форматирования и файла я не знаю как такую же штуку сделать на любом другом языке не не встречал таких вот позитивных инструментов э также мне довелось реализовывать собственный маршале собственного типа это tlv формат его пришлось реализовывать для протокола Home Kit Type L value и я видел как этот формат реализуют разработчики других языков Я видел код на c+ Plus видел код на питоне видел код на nots люди там очень сильно страдают как-то придумывают подходы Как можно реализовать ан маршалинг такого сложного формата но в языке Go удалось его реализовать очень лаконично и очень просто потом с ним работать а ну здесь на слайде видно что поддерживаются некоторые вложенные ключи и структуры поддерживаются лас этих вложенных структур формат тлв такой забавный что у него сами по себе слайсы значений ключа не поддерживаются не слайсы а массивы там в других языках программирования но у него поддерживается несколько ключей с одинаковым именем на одном и том же уровне Ну то есть в Жене в ям запрещено иметь несколько ключей с одним и тем же им на одном и том же уровне вложенности в этом формате это разрешено и А с помощью слайсов как раз и сохраняются значения этого формата Ну удалось реализовать эту функцию а также пришлось решать задачу Когда нужно разделить Когда у вас есть слайс бай как некая единая сущность допустим это вот Session ID это там некоторая переменная на 16 рандомных байт и когда у вас есть слай байт именно одиночных байт это вот на примере как у нас есть статус там Одиночный байт используются значение нули и единицы и надо было как-то объяснить нашей структуре чем они отличаются для этого вот я воспользовался типом string а то есть если кто не знает string и SL by ра очень похожи единственное там отличается нет и в любой момент вы можете провести преобразование одного типа в другой это работает очень быстро очень оптимальный и рин может хранить Там абсолютно любые значения в том числе непечатаемые символы никакой проблемы в этом нету поэтому здесь вот это приго про каналы и каналы в гортис тоже используются вот наиболее яркая яркий код который это демонстрирует Это передача данных от поставщика потребителям то есть goc поддерживает допустим стриминг с одной камеры на несколько клиентов и здесь как раз используется а буферизированный канал для того чтобы сгладить скорость чтения из поставщика допустим нашей камеры и а а скорость записи в наших потребителей то есть эти скорости могут отличаться и здесь используется не блокирующая запись в канал для того чтобы медленные потребители не тормозили всю нашу цепочку Ну допустим у нас есть какой-нибудь клиент а-а мобильный телефон сидит на 3G там очень плохая связь и он не успевает читать данные из канала канал забивается И если бы здесь была блокирующая запись то это просто бы тормозило чтение из с камеры и это бы тормозило других клиентов у которых нет проблем с соединением и немного информации про сам goc про его архитектуру весь goc построен на модулях То есть каждый протокол вынесен свой отдельный модуль и в любой момент вы можете брать своё собственное приложение и столько нужных вам протоколов Это рабочий код Ну то есть Я показывал ранее слайд где Go TC поддерживает огромное количество протоколов но вы можете допустим сделать а приложение с поддержкой только rtsp формата оно будет весить очень мало оно будет поддерживать ТСП сервер и ТСП клиент вот минимально необходимый код чтобы собрать такое приложение и также я старался делать все остальные модули чтобы они были максимально независимы друг от друга чтобы в любой момент можно было из любых модулей слепить себе приложение Какое хочется И вот пример инициализации модуля А в начале объявляется структура конфигурации задаются этой структуре некоторые значения по умолчанию и сама конфигурация хранится в общем файле yamla Где на Первом уровне у нас сами модули А на остальных уровнях конфигурации этих модулей и происходит чтение из этого ял файла вот в эту вот структуру и получается когда пользователь укажет допустим порт list для ТСП А это значение перепишет наше значение по умолчанию если пользователь не укажет а что-то там в ял файле то будет оставлено в данной структуре наше значение по умолчанию такой подход позволил реализовать многих конфигов одновременно то есть на вход goc можно подать хоть десяток конфигов они будут считаны один за другим и получается каждый следующий конфиг может переписать значение там предыдущего конфига это всё вполне работает очень хорошо и дальше инициализируется лоер для каждого из модулей это тоже очень удобно позволило реализовать функцию что у каждого модуля может быть свой уровень логирования То есть вы можете целому приложению указать какой-нибудь н допустим уровень логирования а какому-нибудь одному модуля указать там ТСП модуля уровень логирования баг И для него создастся отдельный логгер с этим уровнем наследуемый от главного логе А если в конфиге не окажется какого-нибудь специфического уровня логирования то для модуля будет использован лоер по умолчанию пример билдинг нашего результирующего приложения здесь используется флаги для уменьшения размера самого приложения для линкса используется утилита upx Чтобы ещё больше сжать наше приложение Ну то есть при запуске результирующего бинарник он распакуем наше приложение в память оттуда оно уже запустится утилиты upx поддерживает в том числе и Windows но антивирусом очень не нравится когда вы пакует своё Go приложение в А через upx они там в 50% случаев считают что это вирус поэтому я принял решение использую для этого обычный ZIP архив для виндоу и для Маков а для линуксом справляется и отлично работает для примера без дополнительных флагов которы удаляют разную баг информацию но обычный Go Build создаёт бинарник на 20 Мб практически под все платформы плюс-минус после этих флагов после применения этих флагов бинарник получается 14 МБА то есть с 20 до 14 мы уже упали и после применения упаковки и upx и Zip ахв даёт примерно одинаковые результаты получается 5 Мб то есть м под все платформы получается довольно маленький самодостаточный бинарник Как вы знаете а бинарник Go самодостаточные они не нуждаются в каких-то сторонних зависимостей Если Вы не написали код соответствующим образом И я очень старался не использовать внешние зависимости А в go to rtc именно по этой причине чтобы код во-первых собирался очень легко его можно собирать на Виндовса линуса в Мак без проблем и чтобы код запускался очень легко на любых платформах Возможно это и стала причиной Почему куча Open Source разработчиков стала использовать его в качестве ядра своих проектов У меня всё спасибо большое за доклад У меня есть вопрос Ты в начале говорил что тво приложение работает на камере у которой достаточно слабое железо правильно и работает эффективно Каким образом ты профилирующий Я использую стандартные возможности языка Go и в том числе мне помогают и мои пользователи допустим был случае когда у одного из пользователей очень сильно текла память буквально гигабайтами на забивалась вот и он сам а разобрался как запустить профиль Я не знаю уж был он разработчиком на голову или нет собрал нужную информацию прислал мне и там было понятно что аа на битом потоке с камер go to TC просто не мог найти окончание кадра и а сохранял сохранял эти данные в буфер Всё ждал окончания кадра А вот круто Спасибо круто что это делается коллективным усилием к тому же я извиняюсь за то что я назвала это библиотекой потому что это действительно большое и комплексное приложение очень круто Есть ли вопросы в зале поднимите пожалуйста руки к вам подойдут для того чтобы Вы могли его задать в микрофон вот в первом ряду есть вопрос Привет Спасибо за доклад Довольно интересно было многие штуки Да понятные У меня вопрос наверное не совсем по структуре Именно этого сервиса Да мне понравились цифры в конце которые ты сказал что упаковка практически в три раза пакует Бинар четыре В четыре Да нет Ну смотри Сначала ты получается лагами отрезаешь до 14 а с 14 до пти пакуются анализировал за счёт чего то есть Казалось бы бинари это неоднородные данные за счёт чего в три раза можно упаковать это вот просто мне интересно никогда наверно не обращал на это ну вот 14 он там вырезает дебаг информации это да да вот дальше интересно Вот именно upx И 7zip то есть вот за счёт чего они в три раза могут упаковать бинари вот или не может быть ты не интересовался этим глубоко поэтому не именно почему у сем зпа так хорошо получается не знаю Просто ну в три раза упаковать Бинар не какие-то текстовые данные а Бинар в три раза упаковать Я думаю что это отличная будет реально отличная тема для обсуждения коллективного в дискуссионной зоне о том что там такое может быть а может быть даже и да тема для доклада в будущем А сейчас давайте сосредоточимся на вопросах я вижу что в последнем ряду молодой человек хотел задать вопрос Да здравствуйте Спасибо специально на этот доклад на самом деле пришёл очень было интересно есть ещё личный вопрос насчёт УП сам хотел спросить могу частично ответить идёт за счёт того что сжатие идёт разархивирование потом идёт в оперативной памяти и поэтому антивирусы ругаются но из-за этого Здесь был вопрос докладчику Я неоднократно читал сам использовал в своих проектах что в ран тайме могут быть необъяснимые Баги и поэтому многие разработчики боятся для продакшн каких-то проектов свою работу тащить я вот не побоялся у меня в своих проектах есть upx но вот прямо есть Прямо ищу по поводу того что необъяснимые баги происходят то есть паники или ещё что-то то есть Ну странно вот я говорил цифры скачивания у меня огромное количество пользователей ни один не жаловался на что-то такое не встречал таких ещё хорошо Спасибо молодой человек в зелёном хотел задать вопрос Вопрос такой я какое-то время назад получил ну пару камер от Линка и никак с ними не получилось нормально построить считывание стрима не встречались ли вы с такой проблемой и может каких-то других вендоров посоветуете если так а с Линка встречался можно вот в в ларах расскажу всё про них всё про них знаю И ещё можно вопрос А как вы тестирует вот подобные э Ну разные вендоры вот даже вы говорили с пылесосом получалось Как вы типа покупаете эти девайсы и пробуете с ними Угу а по пылесосу вот повторюсь есть или я не помню говорила про это или нет есть татья на хабре А можно там подробнее почитать Как там всё было пылесос был не у меня У отдалённо пользователя а он предоставил мне доступ приложения от роборок и этого хватило в принципе приложение позволяет сделать удалённое подключение А и В том числе благодаря этому удалось очень хорошо отладить протокол потому что это было именно удалённое подключение и в том числе удалось найти проблемы Этого протокола в нашей стране К сожалению Вот наши эти системы защиты они а немного портят этот протокол и я даже поучаствовал в этом а в комита библиотеки а для исправления этой ситуации больше не портят пришлось чуть чуть уменьшить там проверку безопасности brtc авторы библиотеки не захотели принимать это по умолчанию этот флаг но сделали его флагом Вот пришло Ну мне приходится его выставлять чтобы оно работало Но если этот флаг не выставить иногда при подключении в разных регионах нашей страны выбор си не подключится Понятно спасибо Есть ли ещё вопросы Из зала У меня есть последний вопрос я не знаю Правильно ли я его сформулирую А ты рассказывал В некоторых случаях про специфичные применени например про сеть у тебя необычные решения дало ли это прирост производительности и какой я называл да эту цифру Это 30% дало ускорения применения буфера 30% нагрузки на CPU дало применение буфера в протоколе ТСП Круто Спасибо я видимо прослушала Извини пожалуйста Хорошо я вижу вопрос в предпоследнем ряду Подойдите пожалуйста к молодому человеку я с видео только начинаю работать вопрос может быть глупый Тай Вопрос вот как РТИ развернуть в корпоративной среде если посмотреть он полезет у тебя на Google Ну то есть у него Google сервера нужно для рукопожатия Существуют ли какие-то классные сервера допустим доке развернул и будет свой корпоративный сервер это он лезит на Google за Стан сервером как бы такой сервер поднять у себя вообще никакой проблемы не составляет есть Open Source решение там Stan Turn серверы Stan Да это вот он лезет на Google скорее всего за станом Ну он stun А ну это легко всё прогуливается и можно да ну хотите вот в кулуарах можете задать вопрос или всегда можете мне писать Я всегда открыт Спасибо большое Да если что любое обсуждение можно перенести в дискуссионную зону это как раз место которое Создано для того чтобы услышать опыт докладчика поделиться своими мыслями разобрать какие-то конкретные кейсы а не просто задать вопрос Там можно построить диалог с докладчиком Есть ли ещё вопросы в зале Хорошо спасибо большое за доклад давайте выберем вопрос который вам понравился больше всего так сес Я даже не знаю хорошо Ну наверное я не могу сказать что мне мой вопрос понравился больше всего так нехорошо Да но мне вот понравился вопрос молодого человека здесь Потому что он действительно говорит всяких нюансах и ещё мне понравился вопрос про камера Потому что его можно обсудить и про венро просто люблю конкретику в обсуждении давайте выберем Вот это молодого человека Да у не действительно был интересный во отлично Спасибо Не уходите пожалуйста мы подарим вам подарок от нашего спонсора Газпром нефти вас Мы тоже Хотим поблагодарить за доклад Это было очень круто и Подарить вам подарок не не Сбегай с площадки приходите сразу в дискуссионную зону чтобы с вами могли поболтать я благодар всех Приходите к нам ещё чуть попозже у нас будет доклад про Каденс и его использование"
}