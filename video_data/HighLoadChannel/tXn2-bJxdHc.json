{
  "video_id": "tXn2-bJxdHc",
  "channel": "HighLoadChannel",
  "title": "Peeking into the Black Hole Called PL/PGSQL - the New PL Profiler / Jan Wieck (OpenSCG)",
  "views": 658,
  "duration": 2800,
  "published": "2017-04-22T14:48:25-07:00",
  "text": "надеюсь все меня слышит меня зовут я навек сейчас я работаю на о пенсии с сиджи это компания которая находится в нью-джерси в сша из и оказывает услуги консалтинга я один из самых старых членов сообщества погреться брус марджан меня привел по-моему в девяносто пятом году если я не ошибаюсь в это сообщество где то тогда но я еще до этого работал с посредством но уже как пользователей начал я примерно с 94 года когда вышла версия 4 и 2 я занимался рядом разработок tool система занимался пел пиджи сиквелом в xii веке бэкграунд райдер и другие вещи которые сейчас добавляют вам говорят головной боли сегодня я хочу поговорить о профайлер и в частности о функциях профайлинга в рамках язык opel пиджи сиквел профайлинг это метод поиска по поиска этих самых бутылочных горлышек чтобы вы могли понять где программа использует ресурсов таких как по память вот вывод и и время больше чем положено потому что именно это нас интересует когда мы говорим о базах данных но я не хочу просто рассказывать я хочу чтобы у нас был диалог с вами под мысли вас появляются вопросы задавайте их что касается postgres а воскрес может собирать очень много статистических данных что очень помогает в профайлинга приложение баз данных из моего кода коллектор статистике это тоже один из моих детищ этот инструмент позволяет собрать собирать статистику по ресурсам ввода-вывода по с к нам по блокам сколько индексов была выполнена сколько кортежей вернулась и так далее есть и другие расширения например перестать statements который может собирать данные о нормализованных запросах сколько диска использовалась сколько времени было потрачено на запрос ну и так далее кто знаком с эти с этими инструментами хорошо итак заработала есть и сторонние продукты которые можно использовать которые могут использовать данные отпуск gresso для анализа и предоставлении вам данных о профилях например пиджи беджера этот инструмент можно использовать для анализа логов прогресса если вы включаете журналирование каждого запроса ну и по крайне мере дорогостоящих запросов вы можете использовать пиджи пейджер для составления профилей ваших приложений что собственно они делают кто использует пить пиджи беджера я смотрю здесь не так уж много специалистов по профайлинга но к сожалению для пиджи беджера требуется очень много ресурсов журналирования если вы хотите знать что происходит с вашим приложением вы должны задать лог state of mind юрий шин до 0 но иногда это приводит к полной потере производительности поэтому дважды подумайте прежде чем пробовать подобные операции в производственной среде но если вы этого не будете делать вы можете кое-что упустить потому что иногда не только длинные запросы могут приводить к падению производительности есть и менее значимые детали и об этих вещах вам также необходимо знать я очень много видел ситуации когда когда отдельные запросы которые выполняются всего в течение нескольких миллисекунд но если вы выполняете их в большом количестве конечно же это призыв приведет к потере производительности это вот те самые маленькие вещи которые могут иметь большое влияние поэтому и если вы зададите 0 для этого выражения то вы увидите те маленькие вещи которых я говорю немного личного опыта я очень часто видел пользователи которые профилируют свои приложение база данных до того как они вообще собственно сталкиваются с проблемами производительности они горят все хорошо все все зеленое мы работаем в рамках и солей и то черным что-то делать и как только они сталкиваются с проблемами падения производительности то им даже не с чем сравнить эти данные они даже не могут понять почему это произошло они просто видят список параметров и запросов и не знают что с этим делать потому что мы даже не знали какая те приложений как эти запросы работали например вчера для меня это хорошо потому что это собственно мой хлеб это то что меня кормит за что я получаю деньги но вы можете сами сэкономить эти деньги и не платить их мне выполняя профилирование все что я описывал опыте by jerry и о других инструментах работы достаточно хорошо если вы хотите найти проблематичные запросы ваших приложениях если конечно же мы не говорим о тех самых маленьких вещах но количество и объем из журналов конечно может привести к очень сильному снижению производительности поэтому для того чтобы понять почему так происходит и для того чтобы понять все остальные вещи нужно знать как работает язык pl50 изнутри этот язык представляет собой продукт который я написал не из необходимости не могу сказать что у меня был нужен произошло следующее в паз греции 42 я добавил переводчик текстов я перешел на пост скилл естественном я хотел этот инструмент забрать вместе с собой тогда мне нельзя был этого сделать нельзя было просто взять и переместить его на серверную часть поэтому я задумался о разработке специального обработчика языка который сможет переводить все эти данные и таким образом появился каталог пиджи языка и соответствующие команды все это до сих пор существует просто они спрятаны под расширениями ну а там они по-прежнему находятся и после этого все начали жаловаться и ныть что нам не нужны процедурный язык который находится в паз гресь и мы не хотим ими сторонние библиотеки и так далее и чтобы эти люди заткнулись я взял и syntax аракава и разработал нечто похожее на этот язык который до сих пор существует что сейчас происходит вы можете создавать функции в этих процедурных языках белке скаут и другие языки потому что очень часто мы сталкиваемся с тем что некоторым пользователям нужен свой белый язык был руби и пел питон или какой-либо другой итак когда вы определяете язык и функции в рамках этого языка вас gres видит что о это язык которые обрабатываются специальным обработчиком он видит что модуль загружен и что все все выполнение перекладываются на плечи имя именно этого обработчиком для этого используется специальный модуль пиджи прок который как раз может переводить языки и типы или как мы называем эта подпись функции для поиска функций и их тела и преобразование и в этой в этом плане был пересекал абсолютно ничем не отличается всех других языков при первом вызове функции в сеансе обработчик будет выступать скорее как компилятор то есть это не будет непосредственно компиляции бинарного кода это скорее будет вложенная структура которая будет выполняться и на этом этапе парсинг склеили запросов не будет выполняться они скорее будут представлять собой строки поэтому внутри они не будут переводиться это будет обычный оператор pl пересекал выражение или результат выражения и соответствующая переменная и внутри все это превратится в оператор select с каким то параметрам и временем стол это мы сделали осознанно пел сиквел просто понять и не имеет по поводу оценки выражений он не знает как рассчитывать вычитывать какие-либо параметры умножить на 100 все это остается как запрос sql и передает просто бэг-энда под gresso таким образом раз позарез настолько расширяем и масштабируем вы можете создать свои типы данных можете создавать свои и настраиваемые функции можете разрабатывать и создавать свои агрегат с совокупные подходы свои операторы вы все это можете создать без проблем и и оставляя это все на усмотрение движка под gresso пётр сиквел автоматически узнаёт о новых типах данных новых выражений форматах все это автоматически наследоваться никому ничего не требуется сделать bios кискиным если когда мы получаем новые типы данных новых операторов вы закрыли желаете джейсон бер это расширение все уже загрузилась все автоматически подхватывается и все системой уже знают а именно специально мы это делали мы заложили then на этапе разработки есть безусловно определенные проблемы и сложности частности пел одессе сиквел как раз оплатит достаточно большую цену за оценку что такое comply язык компилирование данном случае это множитель операции машины всего ли это мастера вана я функция имею или и вещи и пять или шесть под уровней по-настоящему это достаточно дорогостоящее и очень серьезно сказывается на производительности данная древо в утверждении мы просто видим определенную структуру и фактически мы можем использовать одну или более выражение или перечень других выражений поэтому уйдем 1 уровень и список упражнений возможно какой-либо петля с sql запросом главное чтобы этот запрос искала возвращает true то таким образом данная петля будет исполняться и в дальнейшем у нас перечень различных утверждений которые определяют исполнении данные абстрактные данного страшного выражения первый раз когда выражение содержащие запросы скиллы при первом запуске исполнения данного запроса то пел стиль используется монитор испей так называемая серверной программе программируемый интерфейс и который определяет каким образные функции вложенные fast прогресс и backend получает доступ к данным таким образом компилируется либо подготавливается атомный план и используется на протяжении всего срока службы или исполнения данного процесса если какие-либо вопросы работе пела пиджей сиквел а теперь давайте посмотрим на простой пример я буду пользоваться данным примером на протяжении всей моей презентации данный пример основан на типи типи силен бенчмарки кто-нибудь знаком с данным быть марком никто до а а кто вообще знаком с быть марком тепихе by кто-либо использовал пиджи bench тогда вы знаете что такое тебе себе потому что это практически тоже самое но фактически знаете не столь важно те пи си си имеет также таблицу истории и эта таблица история доступно только на в нос данных из этой таблицы ничего не вычитывается там индексы тоже нет известная разница различия данном примере данной таблице 3 колонки с ключами для потребителя и таким образом потребитель в типе сиси также имеет поле баланса типе сиси это система симуляции когда того потребитель заказывает какой-то товар получает этот товар и время от времени потребитель платье за товар и каждый заказ которая помещается он вычитает сумму определенную сумму с баланса клиента а каждая выплата также пополняют счет или баланс клиента дельта который добавляется или вычитается также записывается в таблице истории и если мы суммируем все водные данные из истории по клиенту то мы должны получить то же самое значение как и записано в поле баланс клиентам таким образом мы можем проверить нас согласованность и соответствие показателей потому что данные цифры должны совпадать и мы создаем функцию которая получает а в качестве параметра основной ключ идентификатором клиента после этого мы используем выборочную данные выборочной данные из истории и ключи соответствует сертификатор у клиента пел печи sql слегка изменяет данное утверждение потому что в принципе вы можете назначать такие же значения и запрос который фактически исполняется psp выбрать select определенное количество опресс определенный период времени и впоследствии из этого в результате запроса мы получаем ответные данные мы таким образом фактически ожидаем получить один единственный ряд результатов с одной колонкой который затем назначается данной переменной вот запрос который выбирает определенные значит определенное значение за определенный период времени теперь мы можем создать просмотр и представления данных функций которые отображают всех клиентов показывает их баланс из колонки баланс и после этого баланс тоже рассчитывается на основании таблицы историй действий раз таблицы истории не задержит индекса то конечно это негативно сказывается на производительности потому что исполнение данного запроса реализуется следующим образом когда проверяется вообще все потребители все клиенты из этой таблицы которые удовлетворяют определенным требованиям и после этого извлекается их данные по балансу из таблицы истории и через несколько лет то конечно вы заметите явно и замедление в водитель насти но для целей демонстрации мне конечно необходимо использовать простой пример которых может наглядно показать вам работоспособность данной системы но смотрите нам нужно понимать каким образом мы найдем данный запрос который создает для нас проблему проблема в том что когда мы выбираем определенный параметр из таблицы истории мы снижаем потребитель ность в данном случае под gres не сможет выполнить как джоем если вы используете чистый sql то возможности записать все это в качестве операции join до и после этого вы получаете какой-то значимый план запроса но раз мы используем в нашем случае функцией то пузырь с должен проводить отдельно и сканирование таблицы по каждому клиенту при увеличении числа записи а влоги и когда мы например вносим записываем журнал абсолютно все данные чтобы найти необходимый параметр то запрос который протоколируются лакируется из нашего представления то мы выбираем любое параметры из проблем из ql то есть представление которые только что сейчас создал данный запрос который исходит из клиентского приложения также планируется но во время исполнения данного запроса исполняющий модуль находит данную функцию которая была нами создала и передает обработчику sql и впоследствии происходит исполнение данной функции данного запроса и это уже журнал не вносится данная функция select определенный объем определенную сумму не отобразится журнале конечно их можно где-то записать и просмотреть и я думаю что неплохо это можно сделать используя расширение 5 statements по умолчанию данный функционал не включен и вам необходимо из установить пиджея is that state man's . трек равно он таким образом вы обеспечите блокирование всех действий всех функции ваших запросах и как и запросы приложения вы также увидите нормализованная версию то есть будет присутствовать все запросы все функции все операции которые исполняются там буду символические placeholder и которые вам покажу так что все запросы будут выглядеть одинаково и там не будет выделяться когда вы используете select при обращении к первому ко второму спросу не будет никакого разделения различных ваших запросов различных утверждение но тем ни менее переступ statements и этот предпросмотр результат которого выйти вы просто не поймете откуда пришел пришло это утверждение вы не сможете понять в какой функции pl содержалось данный параметр и в какой строке просто этих данных там нет и поверьте очень уж не весело разгребать все эти запросы для того чтобы найти нужную строку и теперь посмотрите еще на один момент это вы сможете указать различные периметр и различные параметры например аута explay ног не стоит state нас я вас у нас то я вам настоятельно рекомендую не используйте данную функцию если вдруг вы запустите его это старый сервер 88 ягера 8 гигабайт памяти и вдруг запускаем данный параметр то 10 минут система собирает где-то 150 гигабайт логов случае если я запуска активируя данный параметр просто забудьте никогда не пробуйте 150 гигабайт данных за 10 минут до может быть и неплохо если вы куда не там где вновь 0 используете но в противном случае 70 процентов случаях мы наблюдаем серьёзное снижение производительности так как сеть диски просто забивается но проблема определенно возникнет после этого вам потребуется проанализировать все собранной логе вам непросто над собрать эти данные вы фактически собрались себе самый большой массив данные как вы могли так найти и будете просто искать эту иголку в стоге сена поэтому вы никогда не увидите этот запрос а теперь посмотрите на этот пример он конечно достаточно тривиален можно посмотреть на исходный код но в реальном мире все не так просто первое для чего используя новый profile профиль эта база данных пользователей которые содержат 1800 table с 13 тысяч индексов 600 функции пел опять же sql и совместно составляет где-то 100 тысяч строк кода вы знаете его реальном мире достаточно проблематично найти нужную строку нужные параметры потому что спел пиджей sql записано абсолютно вся бизнес-логика данная логика содержит определенная функция определена операторы значения которые опрашиваются может быть в течение несколько раз несколько часов а какие то каждые несколько миллисекунд и поэтому вы можете просто отменить поход и просто можете принять решение не получать данные результаты конечно не очень много обещающе в данном случае в отличие от каких-либо искусственных примеров которые я приводил самом начале вы знаете здесь ничем не может помочь спел вот тогда что вы ищете и наши базы данных и удаленные базы данных как раз сталкивались с такими проблемами и наши специалисты изучали эту проблему на протяжении скольких день но так и ничего не нашли пел профайлер состоит из двух элементов которые работают совместно первое это расширение профайлер который загружается backend и фактически собирает статистические данные данные которая собирается хранится на бэг-энде в расширении и иллюзии и пользователи которые используются системы для конфигурация профилей они очень часто используют различные командные консоли которые написаны на питоне и мы разрабатывали код питон которые я обычно я обычно создаю классы питона потом я использую командную строку и конечно мы уже преобразовали данные консоль графический интерфейс позже я вам покажу но если вдруг вы захотите импортировать данное средство и данный инструмент со своей мэйнфрейм то тогда пожалуйста можете попробовать вы найдете такой способ итак расширение использует так называемые инструмент по дебаггинга и который добавляет был добавлен postgres аскел где-то в 2006 году я здесь абсолютно точно не уверен но мне кажется версия была где-то 8.2 и с того самого времени данное расширение используется для ты багира и также была написана дымит 1-я версия профайлер opel и с тех пор никто ничего не менял в нем во всем целым сообществе это не очень хорошо нам необходимо оптимизировать данное расширение нам необходимо активно использовать данный инструмент пожалуйста сделайте себе заметку и так дальше эти хуки вызывают обратную функцию в расширении каждый раз когда мы запускаем либо завершаем функцию или каждый раз когда исполняется какое-либо утверждение и обратный вызов просто собирает эти данные во внутренних кассовых таблицах расширение собирает три различных вида статистических данных первое это стек по каждому вызову или до график вызовов количество вызовов обращение кумулятивное время которое было потрачено на данном уровне стыка так же время которое было потрачено на их делю на всех детях данном случае мы когда говорим с вами по поводу например кадров за секунду другие два вида данных понять гораздо проще прежде всего это количество вызова определенные функции сколько время исполнялись используясь данная функция и то же самое относится к утверждениям инструмент командная строка используется для взаимодействия с расширением и для того чтобы мы могли создать так называемая удобочитаемым отчеты по производительности а теперь поговорим о графике вызовы так называемое текущие стек и каждый раз когда вы постоянно вызываете различные другие функции то вы выстраиваете определенные стеки ли планы вызова например если вдруг у нас три функции и нас мы запуск начинаем исполнять эту функцию с функцией а функция вызывая функция b функция b вызывает функцию в таким образом нас три и стыковые вызова прежде всего это стык а второе это абэ и а третье а б в в каждом статье вызова мы проводим определенное время таким образом мы тратим определенного время когда активно только функция часть времени задействуется при использовании функции b и таким образом когда мы рассчитываем время когда мы запустили функция и завершили функцию а мы ведь также видим часть времени которое было потрачено функция b но фактически это время не было потрачено на функцию а и нам интересно узнать сама время которое было потрачено только на функцию а либо только на функцию б поэтому нам необходимо выделить исключительное время запуска и функционирования каждой функции и если например функция а также вызывает функцию в напрямую таким образом мы получаем 4 уникальные стык вызова которые все представляют собой альтернативный способ вызова функции в с и графиками вызовов и этой информацией мы можем создавать нечто потрясающее и что потрясающие например flame граф кто видел кто их видел до этого spain граф по цепи да да это наш ответ потому что они выглядят именно так так как я бесстыдно интегрировал flame groves шпиль профайлер в этом прекрасно проект открытых проектов итак в этих flame графах которых очень сложно читать не только потому что они маленькие не пришлось там размыть некоторые данные потому что это данные реального заказчика дело в том что они иногда приводят к снижению производительности но если вы посмотрите на вершину этого графика этот оранжевый блок слева и желтый блок справа которые самые большие это одна и та же функция абсолютно та же функция если бы мы посмотрели на числа то увидели бы что эта функция использует более 90 процентов времени которого все времени которое тратится во всем этом стеке внизу мы видим входную функцию это это собственно так функция которую вызвала приложение для бизнес транзакции и затем мы видим какую функцию вызвало эта функция и так далее и тому подобное пока мы не добрались до верхнего уровня где у нас образовалась новая последовательность и там около нескольких мы там есть c свой ай ди очень длинный но мы сейчас не будем говорить рыбам в случае мы видим что в действительности эти flame графы а интерактивный инструмент и мы можем получить достаточно сложные комплексные flame графы где функции будут уменьшаться по мере по мере приближения к верхнему уровню и тогда вы сможете просматривать всю подробную информацию о каждой функции дочерние элементы и что конкретно эта функция делает я не могу к сожалению показать вам исходный код flame графа или пел который использовался для этого flame графа поскольку это кот него заказчика но давайте лучше покажем несколько примеров мы создаем еще одну функцию которые используют предыдущую функцию для того чтобы предоставить нам сводную информацию по клиентам если вы не являетесь но уже с программистом вы скорее всего будет игнорировать тот факт что это база данных но если у вас есть api-интерфейсы вы его используете пример мы хотим получить баланс наших клиентов таким образом я получаю баланс ни одного клиента а всех поэтому никогда не упал не упускайте такой момент как программисты но уже с поскольку они могут привести к краху вашей таблице но здесь очень просто здесь у нас есть лук и получаем результаты теперь давайте запустим командную строку и здесь мы укажем пиль профайлер ран выбираем баланс всех наших клиентов затем подключаемся к базе данных бен стр 1 активируем расширение пели про fire и запускаем запрос и получаем данные и вот что мы получаем внизу вы видите жёлтую полоску это в это выполнение нашего первого запроса и в этом случае мы видим что проблема как раз заключается в непосредственно выполнение этой функции так как время на ее выполнение очень длинная и выполнение этой функции заняло так много времени именно из-за внутренней под функции которой она пыталась вызвать обычно по умолчанию переправ aero выбирает 10 основных функций которые берут больше всего времени на выполнение если мы посмотрим еще ниже на нижнюю строку из мы перейдем по ссылке которую мы видим мы поведём в другой раздел который будут выглядеть мин а вот так здесь мы видим номер строки счетчик выполнение саму функцию и ниже каждая из каждый из операторов дальше общее время и самое длинное время на выполнение общее время как вы видите помечены желтым и эти желтые строчки это процент от всего времени которая потратилась на выполнение этого оператора с помощью этих желтых строго очень легко сказать что вот этот select плохо работает например и сейчас мы видим сейчас мы видим что плохо работает эта задача именно администратор баз данных анализировать подобную информацию и выяснять какие операторы слишком долгие но какие-то из них естественно изначально будут долгими но с помощью этого инструмента вы не сможете вы не сможете избавиться от администратора база данных но значительно упростить его работу и если вы кому-либо скажите что вы используете профайлер вы можете запустить его с утра весь остальной день заниматься всем чем угодно потому что ваша задача на сегодня закончен и профайлер конечно же не может выполнять 1 одну-единственную функцию вы можете конечно создать файл и запихнуть туда всю информацию о тех проблемах с которыми вы столкнулись создать отчет но перед профайлер может создавать отчеты по всему runtime у приложения как он это делает теперь профайлер может собирать данные статистику не только из локальной памяти в рамках сессии если вы загрузили расширение с помощью дополнительной библиотеки он может также подключаться и к общей памяти их другим полом и таким образом все эти данные которые он собирает может отправлять в общую память после этого можете использовать команду монитор для включения профайлинга или отключение его после выполнения задачи и для этого используются самые разные инструменты конфигурации которые ставят доступны начиная с версии погреться 92 и по-прежнему хорошо себя проявляют затем вы используете отдельные переправ а и рассчёт для того чтобы получить уже какую-то осмысленную информацию и после этого вы можете анализировать свое приложение и если вы знаете пи идентификатор какой-то конкретной функции или оператора вы можете развернуть этот отчет и найти именно этот компонент но в действительности вы можете профилировать свои свои приложение которое находится в производственной среде и при этом ничего не менять а сами приложения даже не будут знать что они стали объектом профилирования это же здорово и я могу сказать что достаточно доступно потому что на это тратится обычно 57 процентов от всех ресурсов но если вы не будете использовать эти средства вы можете столкнулся с гораздо большими проблемами производительности чем 5-7 процентов поэтому поэтому не загадывайте если вы хотите поиграться с этой средой то могу сказать что есть специальный сайт где находится бег сиквел и также есть специальный графический интерфейс уже интегрированы в мексику я думаю что совсем скоро это средство появится и в других утилитах управления том числе тех которые основаны на питоне и моей специалистом по трапу потребовался вот два часа для того чтобы реализовать эту ничего сложного из мы посмотрим на графический интерфейс то он выглядит именно таким образом здесь вы видите поля куда вводятся данные сейчас вы кстати работаем еще над одной реализации где можно выполнять мониторинг ничего особенного вы эти данные нажимаете выполнить и получайте точно такой же отчет после обеда я буду находиться на стенде postgres а у меня будет ноутбук и я готов продемонстрировать вам как это все работает как мы занимаемся профайлинга и на этом я завершаю свою презентацию как раз уложился время и хочу задать вопрос кому что непонятно если вопросы здравствуйте спасибо за презентацию вначале вы сказали что есть проблемы с маленькими запросами и когда проект развивается с этими с этими маленькими запросами проблем становится больше особенно когда они выполняются в параллельном режиме если способ профилировать именно эту ситуацию и предсказать во что это все может вылиться как когда окажется в продакшене прогнозирование это очень сложный вопрос из тем более когда они работают в параллельном режиме очень часто когда мы говорим о маленьких запросах прогноз это очень сложная вещь прогноз это далеко не самая сильная сторона профайлинга и когда вы используете параллельный режим линейного развитие ситуации обычно вас не будет вы можете конечно задать границы но обычно она очень быстро будет пробита и ситуация выйдет из-под контроля вы можете собирать данные из общей памяти запустить приложение в параллельном режиме я отдел бенчмаркинг спиче бэйн из benchmark сиквел у меня есть реализация которая может все делать в рамках хранимых процедур и там я вижу именно то что вы описываете проблема с параллелизмом одну выполнение 1 1 из транзакции и чего не показывает как правило это все происходит сначала в состоянии при п р но когда вы начинаете запускать 15 одновременных подключений и используйте высокую частоту подключение то тогда уже конечно же начинаются конфликты в журналах то есть вы конечно можете это увидеть можете проанализировать но что касается прогнозы то тут скорее ничего не получится спасибо спасибо большое за ваше внимание"
}