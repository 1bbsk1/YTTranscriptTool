{
  "video_id": "Pt9TGFzLVzc",
  "channel": "HighLoadChannel",
  "title": "ApplicationCoordinator для навигации между экранами / Павел Гуров (Avito)",
  "views": 11136,
  "duration": 2824,
  "published": "2018-01-16T11:22:43-08:00",
  "text": "Гуров Я занимаюсь разработкой I приложений в компании Авито сайте объявления номер оди России года три назад Я выступал на одной конференции с докладом о построении сетевого стека в приложении с использованием конкретных технологий библиотек и с тех пор вышло уже несколько версий iOS нас полностью поме внешний вид приложений пла каждый год выходит множество сторонних библиотек по работе с сетью каширою данных и так далее отрисовки чере Ja Вот почему в этом докладе я решил рассказать об архитектурном решении которое будет актуально независимо от того какими технологиями вы пользуетесь сейчас или будете пользоваться Через пару лет я расскажу как мы используем Application кодир для построении эе скажу небольшой демо проект и наконец расскажу как можно максимально быстро внедрить этот подход в ваше приложение а в конце Буду рад ответить на ваш вопрос Итак навигация навигация между экранами - Это задача с которой 100% все из вас сталкивались то есть Неважно Что вы делаете Делаете вы социальную сеть там вызов такси или онлайн банк навигация - это то с чего вообще начинается приложение ещё на этапе создания прототипа То есть когда вы даже не знаете ещё как у вас будут до конца выглядеть экраны там вы не знаете какие у вас будут анимации будете ли вы кэшировать данные или нет но наш экраны вообще могут быть в принципе пустыми там да Или сделаны на картинках но задача навигации появляется в приложении как только этих экранов становится больше чем один То есть фактически сразу если мы возьмём наиболее распространённые методы построения архитектуры iOS приложений это mvc mvvm и mvp то все они описывают то как построить один экран модуль вот е там говори о том что модули могут друг о друге общаться с другом и так далее но совсем мало внимания уделяется вопросу того как совершаются переходы между этими модулями Кто принимает решение об этих переходах и Как передаются между модулями данные iOS из коробки предоставляет Нам несколько способов показать следующий по сценарию экран первый - это UI storyboard и всем нам известно Я думаю это когда мы обозначаем все наши переходы между экранами в одном удобном файле потом вызываем всё очень удобно и здорово следующий способ показать Next Screen - это контейнеры контейнеры такие как UI Navigation Controller UI tar Controller UI P Controller или возможно какие-то самописный контейнеры которые можно использовать как программно так и вместе со storyboards И следующий способ - это метод Present VI Controller Animated это просто метод класса uw Controller значит в самих этих инструментах проблем нет проблема в том как именно они обычно используются это ВС про методы класса и предлагает пользоваться этими инструментами внутри самого котле доказательством этому служит сле создаёте новый сабкласс uiw Controller по стандартному шаблону в нём написано прямо если вы используете Segway И вам нужно передать данные в следующий по сценарию экран вы должны достать этот VI контроллер из Segway Вы должны знать какого он будет типа Вы должны сковать его к этому типу и пробросить туда свои данные Давайте посмотрим к каким проблемам приводит такой подход к построению навигации значит первая проблема Я думаю достаточно очевидная это стя связанность экранов это знат что экран О у нас знает о существовании экрана 2 мало того что он знает его существование он е его Ида потенциально ирт из зная какого он типа идват ему Като данны Вот так это прот ЕС нам пона вдг при каких-то обстоятельствах показать вместо экрана Като э то нам при знание о новом экране 3 точно так зашивать как и это было зашито с экраном 2 вот всё становится ещё сложнее если наши контроллеры 2 ИТ могут вызываться ещё из нескольких мест не только из экрана один получается что знани об экране 2 и 3 придётся зашивать в каждой из этих мест если сделать это ещё половино беды то основные проблемы начнутся у вас когда потребуется внести в эти переходы изменения или всё это поддерживать следующая задача - это изменение порядка контроллеров сценарии это сдела тоже будет не так просто по причине связанности так как чтобы поменять местами два вю контроллера нам недостаточно будет просто зайти в сториборд и поменять местами две картинки нам придётся залезать в код каждого из этих экранов вытаскивать этот код настройки следующего менять его местами что как бы тоже не очень удобно и ещё одна задача - Это передача данных по сценарию здесь например при выборе чего-то на экране 3 нам нужно обновить О так как у нас нет ничего кроме в контроллеров нам придётся каким-то образом связать эти то есть изначально нет ничего кроме в контролеров нам придётся каким-то образом связать эти два вю контроллера Неважно как через делегирование там или ещё как-то проблема может быть здесь осложнена тем что по действию на экране 3 Нам нужно будет обновить не один экран а сразу несколько Например сразу и первый и второй В таком случае делегирование може обойтись не можем потому что делегирование связь один к одному нам прид сделать по-другому там кто-то может сказать Давайте Чере тоже неважно Вот это может затруднить отслеживание потоков данных в нашем приложении Давайте посмотрим лучше Как говорится один раз увидеть Чем 100 раз услышать Давайте посмотрим на конкретный пример из настоящего приложения Авито Авито услуги Pro это приложение для профессионалов исполнителей услуг в котором они могут очень удобно отслеживать заказы обща с заказчиками новые Зака и так далее СБО города в в редактировании пользователя вот перед вами есть экран редактирования пользователя Я думаю что он есть много в таких приложениях нас конкретно интересует выбор города значит что здесь происходит пользователь нажимает на ячейку с городом и первый экран принимает решение что пора в Navigation Stack запушить следующий экран это экран со списком федеральных городов Москва и санкт-петербург и список регионов если пользователь на втором экране выбирает федеральный город то второй экран понимает что сценарий завершён прокиды первому выбранный город и там каким-то образом на откатывается до первого экрана ВС срий считается завершенным Если же пользователь на втором экране выбирает область то второй экран принимает решение о том что нужно запушить третий экран в котором мы видим список городов этой области Ну и там уже соответственно если пользователь выбирает какой-то город то этот город прокиды опять же также на первый экран откатывается на и сценарий считается завершённым на данно с проб связано которых я Говори изображе в видере контроллеров и от этих проблем Мы будем с вами сейчас избавляться чит как мы это делаем первое мы запрещаем себе внутри U cont обращаться к нашим контейнерам То есть к про Navigation котле контроле или ещё какие-то контейнеры кастомные которые вы вот сделали там как Да там как проти то есть мы теперь не можем из кода экрана взять Свой контейнер и попросить его что-то сделать там возьми запу следующий экран отка там сценарий назад всё Мы про это забываем второе мы запрещаем себе внутри U controll вызывать метод и писать код в методе prepare for который бы брал следующий по сценарию экран и занимался его настройкой то есть мы больше не работаем с перехода между экранами внутри U котлера И третье Мы точно также себе запрещаем любые упоминания о других контроллерах внутри нашего конкретного контроллера никаких их инициализации это всего это забываем и так как все эти обязанности мы убираем контролеров нам нуж новая сущность Куда эти обязанности попадут и мы создаём новый класс объектов Куда эти обязанности мы помещаем и называем его координатор значит координатор - это просто обычный объект которым мы передаём на старте на и вызываем у него метод Старт сейчас не думайте о том он реализован просто посмотрите как в таком случае у нас изменится сценарий наш сценарий выбора города теперь сценарий начинается не с того что мы пушим какой-то конкретный экран Navigation Королле А мы у координатора вызываем Т Старт передав ему перед этим в Илай зере Navigation Controller и координатор понимает что в Navigation Controller пора запушить первый экран что он собственно и делает Вот он вам показывает а дальше когда пользователь выбирает у нас ячейку с городом это событие репортить Как говорится хоть пожар То есть ему вообще не важно он это сообщение сообщает координат Даше координатор реагирует на тем так у него нале что он пушит в него следующий шаг это выбор городов выбор точнее регионов дальше пользователь нажимает регион такая же точно картина экран сам ничего не решает координатору об этом сообщает координатор пушит следующий экран и когда на третьем экране пользователь выбирает уже конкретный город этот город прокиды у нас через координатор на первый экран есть ко сообщается сообщение том что Выра город до первой до первого экрана значит здесь главное на что нужно обратить внимание это то что контроллеры теперь не общаются друг с другом решая кто будет следующий и не передают друг другу никакие данные более того они вообще ничего не знают о своём окружении Если же смотреть приложение в рамках трёхслойное архитектуры то я думаю понятно что в контроллеры в идеале должны стремится полностью поместиться в слой и нести в себе как можно меньше логики приложения в данном случае мы используем координатор чтобы вытащить логику переходов на слой выше и убрать это Знание из VI контроллеров Так теперь бы я хотел показать вам небольшое демо А к счастью мне удалось здесь запустить X код так о зацепил так да Сначала я покажу вам то что получилось в итоге чтобы не перегружать вас я сейчас сделаю чтобы был чтобы я тоже видел что я делаю чтобы вас не перегружать я решил сделать абсолютно тот же сценарий о котором рассказывал только что это редактирование профиля и выбор в НМ города значит первый экран Как видите это экран редактирования юзера он показывает информацию о текущем пользователе а именно его имя и выбранный город и Здесь есть кнопка выбрать город см Токио да то у нас на первый экран прокиды этот город Дайте ещ раз выбрать город выберем обратно Москву Давайте посмотрим теперь как это устроено в коде видно хорошо просто больше наверно нет смысла делать Вот значит начнём мы с моделей модели здесь достаточно простые Первая - это структура город у которой есть поле имя строка и вторая моде это польва у которого тоже есть им дальше посмотрим на сториборд который здесь есть начинается на контролера и у нас в принципе те же самые экраны которые Вы только Что видели в симуляторе это экран редактирования пользователя с лейблом и кнопкой и экран со списком городов на котором показана табличка с городами Давайте остановимся на экране редактирования пользователя что у нас здесь это кото переда сда с это тот пользователь которого мы будем редактировать вот сет юзера сюда приводит к тому что вызывается здесь блок Что приводит к вызова локального метода Up всё что делает этот метод он просто помещает информацию о пользователе в То есть он показывает его имя и показывает название города в котором пользователь живёт тоже самое происходит в методе самое интересное место здесь это вот этот вот обработк нажати на ноп выбо горо ви контроллеры не вызывает кие се ВС что он делает это вызывает ко А - это вторая про нашего контролера Вот это без параметров соно что происходит Поль нажимает кнопку тому что вызывается этот ко Всё достаточно просто перейдём теперь к экрану выбора города значит этот экран это СДО из другого места приходить и здесь достаточно тривиальный табличный код который показывает этот список городов в ячейках здесь опять же самое интересное место - это вот этот вот обработчик Select R Index Pass нам всем хорошо известный метод здесь Как видите опять экран сам ничего не решает что происходит Дальше после того как был выбран город он просто вызывает колб Как видим здесь это наш параметр это колб с единственным параметром город То есть он вызывает колк и передаёт туда город Вот на этом как бы код самих экранов заканчивается Вот как мы видим Они ничего о своём окружении не знают и теперь перейдём к связующем звену этих между этими экранами это наш координатор Так что он из себя представляет координатор имеет две проперти Первое этор это тот пользователь которого мы будем редактировать с помощью этого координатора и второе - это на кот который му нужно передать при старте у него есть метод который приводит к тому что вызывается Давайте на НМ с подробнее остановимся Что делает этот метод он достаёт контроллер из ри борда ему нашего локального юзера Дальше он проставляет ему и пушит это вызывается вот этот ко это приводит к тому что вызывается следующий приватный метод C SC Давайте посмотрим на него теперь на следующий метод он на самом деле очень похож он делает практически тоже самое поднимает немножко другой контроллер избор ставляет ему Call on и пушит его в вот всё что происходит и дальше когда пользователь выбирает конкретный город на срабатывает это коор обновляет у локального ра нашего поля город и откаты до первого экрана Так как - это структура то обновление поля город у него приводит к тому что вызывается бло и это приводит к тому что вызывается приватный мед всё что делает этот метод он просто проходится по всему и пытается развернуть каждый кон это он прокиды обнон юзера и посредством этого получается что наш выбранный р на втором экране автоматически прокиды на первый экран единственное что осталось здесь показать то есть координатор с ним всё понятно это точка входа наше приложение это то где всё это начинается вот в данном случае это мето на что здесь происходит тогда он из Window Root Controller достаётся здесь создаётся юзер который мы будем редактировать с именем и конкретным городом дальше сдаётся наш координатор с юром и Navigation Короле у него вызывается метод ста координатор кладётся локальную проперти вот в принципе и всё вот схема достаточно простая если кто-то что-то не успел посмотреть ничего страшного там в конце на последнем слайде будет ссылочка на эту презентацию и на это демо то есть впе достаточно просто Ну потом можете его ещ раз посмотреть Значит тут есть Теперь несколько моментов на которых я бы хотел поподробнее остановиться чит момент первый в демонстрации вы Наверняка обратили внимание что про влере помечен комментарием как и а колбеки этих контроллеров помечены как АТ Давайте Вот на этом моменте поподробнее остановимся значит и и вход это любые данные которые могут Измени во времени также воз может Измени са или его параметр поэтому это является входом на который контроллер реагирует выход это любые события о которых контроллер хочет сообщить внешнему миру например Это нажатие на кнопку А на экране контроллер ничего не знает и ничего не делает по этим событиям он делегирует решение о том что сделать дальше кому-то ещё obc я не очень люблю писать сохранение колков из-за их ужасного синтаксиса Вот Но по сравнению с obc с этим всё гораздо проще а использование колков в данном случае это альтернатива хорошо Всем известному паттерну делегирования в iOS только тут вместо того чтобы обозначать методы в неком протоколе и говорить что координатор соответствует этому протоколу и потом где-то отдельно писать эти методы мы сразу можем очень удобно в одном месте сущность проставить и вс это сделать вот Единственное что можно заметить что При таком подходе в отличие от делегирования появляется жёсткая связанность между сущностью координатора и экрана потому что координатор знает что существует конкретная сущность экрана от этого можем избавиться таким же образом Как делегирование с помощью протоколов значит чтобы этой связанности избежать Мы можем закрыть и нашего контроллера протокол прого рение далее наш как бы слева вы видите сфто аналог вот этой вот схемы далее наш контроллер конфор этому протоколу определяя у себя необходимый колк Всё достаточно просто делаем Это для того чтобы координатор не знал о существовании класса C но в какой-то момент ему понадобится этот сконфигурировать у этого контроллера для этоа фабрике есть метод C output Вот то есть получается что наш координатор получает не не создаёт контроллер и не получает отку он берёт создаёт то есть точнее ему прокиды фабрика которая возвращает в методе закрытый протоколом объект и он ничего не знает о том какого класса этот объект Вот теперь самое главное зачем вообще всё это делать зачем вот нам встраивать это уровень ещё один дополнительный когда вроде как у нас так не было никаких проблем вот здесь можно представить такую ситуацию что наме при просит сделать а тестирование того что вот например вместо списка городов У нас появился выбор города на карте давай-ка вот мы сделаем выбор города на карте Вот если бы в нашем приложении выбор города был не в одном месте там в разных координатора в разных сценариях нам пришлось бы в каждое то место зашивать вот этот флажок там Да его прокиды снаружи поэтому флажку поднимать либо один либо другой в контроллер это всё не очень удобно Мы хотим из координатора это знание убрать вот поэтому можно было бы сделать это в одном месте в самой фабрике мы бы сделали параметр по которой фабрика бы возвращала закрытый протоколом либо тот либо другой контроллеру Вот и у них у обоих был бы callback on c селек это координатор был бы в принципе неважно да С каким из этих экранов работает там на карте или на списке его как бы это не сильно бы волновало так следующий момент на котором бы хотел остановиться - это композиция против наследования такой большой левар значит первый метод Как можно сделать наш координатор - это сделать композицию Когда у нас Navigation Controller передаётся ему снаружи Вот и хранится локально как проти это как бы композиция мы добавили Navigation controll как проти второй вариант существует мнение что в uik и так уже всё есть и нам не нужно изобретать велосипед и что вот можно просто взять и от наследоваться от UI Navigation Controller значит за каждый можно перечислять свои плюсы и минусы Вот но Лично мне кажется что композиция в данном случае подходит больше чем наследование саклан вообще в принципе это менее гибкая схема И если нам потребуется изменить например Navigation на скажем там то мы сможем в первом случае просто закрыть их общим протоколом типа там Покажи следующий экран и удобно подставлять нужный нам контейнер Ну и как бы с моей точки зрения самый главный аргумент заключается в том что вы скрываете от конечного пользователя в композиции все ненужные ему методы То есть получается что у него меньше шансов оступиться вы ему оставляете только То которое ему необходимо например метод стар и всё Вот и у него нету возможности вызвать то есть-то вме дете вашего координатора вы от него скрываете все эти десятки методов родительского класса следующий момент я считаю что Они заслуживают отдельного внимания вместе с Лично я поддерживаю так как они позволяют визуально быстро ознакомиться со сценарием когда приходит новый разработчик вам не нужно лазить по коду если как бы вы уже давно сидите в проекте это денят чтот приходит тяжело поэтому как бы Story boards в этом плане помогает даже если вы делаете код интерфейс кодом Вы можете оставить там пустые вю контроллеры там в верстать интерфейс кодом но оставить как бы хотя бы переходы и всю суть вся суть стори бордов на самом деле именно в самих переходах а не в вёрстке ЮА А к счастью подход с координатора нас не ограничит в выборе инструментов и мы можем спокойно точно так же использовать координаторы вместе с SE Но нам нужно помнить что мы не можем работать с seg теперь внутри uiw контроллер поэтому мы должны в нашем классе переопределить метод prepare for Segway и вместо того чтобы делать что-то внутри контроллера мы будем делегировать эти задачи опять же кому-то там например координатору через callback Вот то есть здесь вот вызывается ме forway вы сами ничего не делаете вы не знаете что это за SE какой там Destination Controller вам это всё неважно вы просто прокиды это всё в Коб координатор там разберётся в координатора есть это знание вам это знание ни к чему для того чтобы всё было попроще можно сделать это в неком классе Да чтобы не переопределять его в отдельно каждом взятом контроллере в таком случае координатор будет как бы удобнее работать с вашими значит ещё одну вещь которую нахожу удобно со ри борда это придерживается правила того что один сториборд равен одному координатору тогда можно сильно всё упростив упростить сделав вообще один в принципе класс координатор и у него сделать паме root typ видите здесь рда делать и заво него внутри весь срий види тут У нашего координатора есть И нашего паме и дальше при инициализации передаём не конкретны передам из которого достаётся наш корневой и его первый контроллер вот таким образом О даже показать модально либо взять и запушить существующую сво какую-то навигацию Да там и уже дальше работать соответственно наш координатор в таком случае стал бы простом поставляющий в genic паме Тиле такой вот такая вот схема так и теперь давайте о решении последней проблемы кото обозначал в начале Это передача данных обратно по сценарию давайте рассмотрим тот же самый сценарий выбор города но теперь в нашем сценарии можно выбирать будет не один город А их можно будет выбирать несколько чтобы показать пользователю что он выбрал несколько городов внутри одной области Мы будем на экране со списком областей а показывать циферка маленькую рядом с названием области отображающую количество городов выбранное в этой области да то есть получается что действия на одном контроллере на третьем должно приводить к изменению внешнего вида сразу нескольких других то есть и в первом мы должны с городом показать и во втором мы должны все Циферки Обновить да соответственно у выбранных городов у выбранных регионов значит координаторы упрощают задачу тем что прокиды данных назад по сценарию Это теперь такая же простая задача как и прокиды данных вперёд по сценарию Что здесь происходит пользователь выбирает какой-то город опять же это сообщение проки координатору координатор как я уже показывал в демке проходится по и занте мн и соотвественно они могут котле могут обновить сво с этими данными так последний момент на котором бы я хотел остановиться это то как нам Фактори существующий код То есть если у вас есть желание не с нуля начать писать проект использу этот подход А уже внедрить существующее приложение где у вас есть mcm там или mvp первое что нужно сделать это вот такт контролни ва есть контролеров Что нужно сделать нужно взять и разделить их на сценарии в которых они участвуют то есть в данном случае у нас есть три сценария первые это сценарий авторизации дальше это сценарий редактирования профиля и сценарий показа какой-то ленты там вот и получается так что каждый сценарий мы теперь заворачиваем внутрь своего координатора мы должны возможность эти сценарии на самом деле стартовать из любого места в нашем приложении То есть это в этом должна быть гибкость конар должен быть полностью саста такой подход В разработке даёт дополнительное удобство оно заключается в том что если вы в данный момент работаете над каким-то конкретным сценарием вам не нужно каждый раз при запуске до него доливать Вы можете его где-то там при старте быстренько стартануть в НМ там что-то править править править а потом как бы этот Старт временно убрать вот значит после того как мы определились с нашими координатора нам нужно определить Какой сценарий стартует какой то есть Какой может привести к старту другого из этих сценарий составит дерево в нашем случае дерево достаточно простое у нас логин координатор может стартовать координатор редактирования профиля у нас почти всё встаёт здесь на свои места но остаётся очень важная деталь у нашей схемы не хватает точки входа А этой точкой входа будет особый координатор называемый Application координатор а его создаёт и стартует App delegate и дальше он уже управляет логикой на уровне приложения то есть с тем какой координатор мы стартуем прямо сейчас например при старте показываем мы логин если пользователь не авторизован или мы сразу можем перейти к Клин там например только что мы с вами рассматривали очень похожую схему только на ней вместо координаторов были в контроллеры и делали мы с вами что там мы делали так чтобы в контроллеры ничего друг о друге не знали и не передавали друг другу данные с координатора в принципе можно сделать тоже самое мы можем обозначить у них некий инпут метод старт и какой-то output Call онш и координаторы становятся точно также независимыми пере используемыми и легко тестируемые то есть они перестают зна друг о друге общается только например с каким-то алике координатором тут опять же нужно быть осторожным Потому что если в вашем приложении будет достаточно много этих сценариев то Application координатор может превратиться в такой огромный гадо объект там да будет знать о всех существующих сценариях Это тоже не очень здорово тут надо уже смотреть то есть есть возможность в принципе попробовать попили там эти на координаторы на ещё какие-то под координаторы То есть тут уже как-то раскидать архитектуру так чтобы не разра эти объекты до невероятных размеров хотя в принципе размер - это как бы не всегда повод то есть для рефакторинга так и теперь о том как с какого вообще начинать То есть откуда вообще начинать начинать нужно с того что как бы я советую начинать с низу вверх то есть сначала какие-то отдельные сценарии реализовать и как временное решение их можно стартовать внутри uw контролера то есть Пока У вас нету ни Рута ни других там координаторов вы можете делать один координатор и как временно решение стартануть его из UI viw Короле сохранив его локально в Property Как вы здесь видите есть какой-то Next Коди Когда происходит какой-то вы как я и показывал уже в демо только там это был здесь вы создаёте локальную про кладёте сюда координатор Называйте в не метод Стар всё очень просто и потом когда Вы уже сделали все эти координаторы Старт одного внутри другого выглядит абсолютно точно так же То есть у вас есть какая-то локальная проти или у вас есть какой-то массив зависимостей типа там координатор Да вы туда всё это складывал и вызываете там в принципе всё так что же мы получаем ВТО независимые экраны как экраны так и сами сценарии которые ничего друг о друге не знают друг с другом не общаются вот мы этого пытались добиться далее нам становится легче менять порядок экранов в приложении без изменения кодов экранов То есть другими словами вообще по-хорошему Единственное что должно измениться в приложении Когда у вас меняется сценарий это э данных между экранами и другие задачи которые подразумевают под собой связь между вашими экранами и лично мой самый любимый момент это то что чтобы начать его применять вам не нужно добавлять в проект сторонней зависимости или разбираться в чужом коде Спасибо за внимание Вот мои контакты здесь и здесь моя почта есть и ссылка на хабе Где вы можете зайти скачать демку и также взять эту презентацию Спасибо зани может какие-то вопросы будут у вас Да пожалуйста Может микрофон там передать чтобы было на запись попала Да да да он там молодой человек Здравствуйте а как вы решаете проблему Когда например вам нужно перейти на одну и ту же страницу скажем так с двух разных мест причём там с особенностями страница это обернута в какой-нибудь л не очень понимаю что обёрнутый меню так соответственно у вас есть Shell и внутри этого шела вставлена страница Вот и вам нужно перейти на эту страницу с двух разных мест одно место это та же страница другая страница которая обернута в тот же самый л а другая страница - это просто страница без этого шела и как вам как бы вы решили эту задачу чтобы максимально мягко перейти чтобы допустим если на шили есть анимация то она бы продолжила бы проигрывать а страница в это время поменялась бы так значит я правильно понимаю что вы хотите вернуться на первый экран то есть во-первых Shell - это какой-то контейнер правильно то есть допустим это может быть там какой-то там ВК там или ещё что-то то есть какой-то контейнер Да с этим самым в принципе в таком случае получается что мы можем завернуть в координатор как раз вот с этим контейнером то есть будет там какой-то vde координатор Да который будет это всё координировать вот а что значит имеется что вы спросили про возврат на первый экран В смысле вы имеете в виду что мы с какого-то экрана внутри этого шела возвращаемся на первый или как Нет нет нет э-э Есть страница без шела Угу Есть страница с шелом Угу соответственно когда я перехожу на страницу которую И перехожу из страницы которая без шела соответственно у меня должно перерисовать Shell и всё остальное Угу А когда я перехожу на страницу из из страницы с тем же шелом у меня Shell должен остаться а новая страница рисоваться назад Да да так Ну в таком случае смотрите здесь нужно будет внутри этого координатора в любом случае у вас все контроллеры будут появляться в контексте какого-то координатора То есть даже если это одна и та же страница вы говорит что в одном случае она внутри шела а в другом случае она вне шела внутри шела она будет иметь свой контекст это как бы координатор этого шела а в другом месте какой-то другой координатор то есть сценарий в котором она там участвует правильно получается что по действию на этой странице мы это сообщение прокиды координатору а координатор уже дальше Всё это делает если это координатор который координирует л то Он поймёт что нужно в этом случае откатываться назад до первой страницы а если это то есть координатор который представляется какой-то другой сценарий то он просто возьмёт и каким-то образом Старт тот координатор который шел То есть он покажет м модально там или то есть Это уже зависит от того как у вас устроен ваш этот шел и второй Маленький вопрос почему координатор а не Navigation сес например Почему такой название Ну да Такая организация Вы знаете я не знаю То есть название просто вот оно есть есть координатор То есть это можно в принципе как угодно назвать Вот мне кажется что нейминг - это такая вещь нет Вот это Это у вас объект Или это у вас сервис такой это это объект объект Да а почему не сервис потому что вот это объект так решили так решили да спасибо за вопрос Давайте да отсюда начнём вот молодой человек поднимите руку пожалуйста ещё раз чтобы вас видно было Да здравствуйте такой вот такая есть проблема а при изменении системных настроек приложение запускается заново Угу А как можно это решить проблему чтобы оставаться на том же экране когда пользователь вышел из приложения угу так хороший вопрос а в таком случае я думаю что а становится понятно что у нас с координатора приложение превращается как бы в иерархию не вю контроллеров А в иерархию координаторов то есть одни координаторы держат другие и так далее В принципе каким образом это можно просто сериализовать То есть это можно куда-то сериализовать какой-то там Файлик записать и так далее и потом просто при старте смотреть нет ли у нас сериализовать выключены настройки А можно делать там как какой-нибудь Спарк делает да Когда вы там почту просто закрыли приложение потом заново его открываете он просто его опять же также восстанавливает неважно там вы настройки поменяли или нет вот просто можно каким-то образом сериализовать это дерево координаторов и потом его восстановить стоит этот спасибо спасибо там ещё был вопрос Да там есть уже микрофон даже супер есть да Павел Спасибо большое за доклад Скажите пожалуйста приходилось сталкиваться с проблемой бесконечной навигации и есть ли какое-то решение в рамках координатора для решения этой задачи Так вы наверное имеете в виду то что у нас может быть циклические переходы друг на друга и могут экраны бесконечно добавляться в стек такое часто Да но тут как бы опять же в данном случае мы можем эту логику засунуть в сам координатор то есть смотрите когда у нас происходит вот э вот цикличность то есть мы хотим из вот этого экрана попасть на вот этот да координатор Может вместо того чтобы просто В тупую запушить следующий экран negation Stack он может просто пробежаться по текущему стеку и понять что уже этот контроллер там есть взять этот контроллер сделать поп к нему и обновить его с теми данными которые нужно показать всё То есть в принципе просто эту логику придётся зашить в координатор Ну тогда придётся писать кастомные переходы правильно Ну то есть видимо придётся транзишн ка сделать так чтобы анимация при этом была такая как будто перешло вперёд то да то есть если вас если вас не парит то что у вас будет как бы откат назад и пользователь это может смутить тогда конечно То есть вы можете просто сделать попыт в контролер конкретный Если вам нужен переход как будто это было вперёд то вам придётся поиграться конечно транзишены да Спасибо А ещё один вопрос часто приходится менять порядок экранов на практике вот на практики если честно да то есть это довольно редкий кейс но просто это как бы одна из вещей с который можно то есть Может помогать это вот это как больше про Sity то что мы всё-таки выносим знания о сценарии наружу и координаторы не меняются То есть это как бы просто демонстрация одних одной из вещ которые теоретически с которой бы помогло это вот Спасибо Да пожалуйста ещё может какие-то вопросы да там столько рук сразу можете ещё раз руку поднять просто чтобы Да было видно кому микрофон там передавать скажите пожалуйста кто отвечает за презентацию модальных экранов И в частности также алертов Угу Так кто отвечает за презентацию модальных экранов смотрите в данном случае получается что модальный как бы модальная презентация - это Почти то же самое что и Push Navigation Stack только вот если вы помните я там показывал слайд где мы создавали сториборд координатор у которого был как бы и Navigation и как бы его Root VI кот да то есть у этого Найна вот так делать Даже удобнее вместо метода Старт Потому что таким образом мы не привязаны именно к навиг мы можем просто получить конкретный координатор и взять у него если нам нужно презентовать модально Мы можем взять у него а его Navigation коллер и презентовать модально Если же нам нужно его запушить в свой существующий Navigation СТК то можем просто взять и как бы взять этот контроллер рутовые и положить его в свой Navigation СТК как-то так то есть вы прокиды всё это до координатора Да все алерты То есть у вас на экране есть например четыре алерты туже смотри тут тут всё зависит от того что у вас на самом деле является экраном если у вас mvc - это просто контроллер да то есть у вас это может быть контроллер это может быть как бы в модель То есть это может быть что-то другое это не обязательно я просто сделал здесь отображение с mvc чтобы было как как можно проще Вот Но уже решение о том где показывать Арт опять же Это вы сами принимаете То есть это не накладывает вам ограничений Вы можете передать это сообщение в координаторы в координаторы показать Арт если например нужен там какой-то результат который пройдёт там какому-то дополнительному действию Если же это инкапсулировать именно внутри экрана и это не ну как бы не кого снаружи не волнует то в принципе можно Вы можете это и в экране показать свой алёрт а уже результат действия который должен привести к какому-то изменению навигационного стека прокинуть наверх координатор Спасибо Да там ещё молодой человек да а тестируется ли вы координаторы и если тестирует то что именно попадает под Unit тест Угу Ну вот с тестированием конечно да интересный вопрос Мы Тестируем координаторы таким образом что у нас в контролеры как бы они закрыты протоколом понимаете то есть мы в принципе можем любые моки туда подставить у нас координатор не знает Короле Поэтому просто создаём определённые моки которые генерируют какие-то события дёргают эти ручки и мы уже смотрим в какой стейт перешёл координатор то есть мы смотрим Что он там у фабрики запросил следующий мы смотрим Что он там должен был запушить и так далее То есть в принципе да это тестируется достаточно Легко вот теру данных ходит от от конкретных контроллеров к координатору и обратно конечно да это тоже можно протестировать опять же То есть если вы делаете моки Вы можете просто тут у этого мока дёрнуть ручку а у этого соответственно в проперти сделать там deet и посмотреть там поставить булевый флажок что вызвался соответственно прокиды не данных сюда и просто в этом убедиться да то есть это тоже можно сделать Да спасибо спасибо Можно я задам вопрос конечно я здесь справа можете ручку поднять Да а вот здесь да Да спасибо за доклад а такой вопрос а есть базовый класс для координатора какой-то А ну тоже опять же всё зависит от того как вы делаете Но вообще вот я показывал со стори бордом Да удобнее сделать так чтобы был какой-то даже не базовый класс А класс с генерик параметром Где вы можете подставить просто любой тип VI контроллера как Root и всё и он автоматически как бы показывает вам Navigation и вот свой тип этот самый То есть в принципе да можно сделать базовые классы чтобы было удобнее работать это уже тоже как бы зависит всё э детали уже имплементации А вот в вашем случае Вы делаете Я вот услышал вопрос про алерты Ну скорее всего на каждом экране есть какая-то работа с сетью Ну и например когда-то она обрывается либо сервер падает мы показываем алерты Ну и чтобы не дублировать этот код Ну наверное легче куда-то в базовый выделить Ну хотя это неправильно Конечно можно опять же это можно вместо тут опять же вопрос наследования композиции Да можно просто какой-то обработчик там х там то есть запилить Просто этот координатор засунуть он будет как бы обрабатывать там ошибки алёрты показываться и так далее тоде просто уже наследование композиции это как уже вы там реши делать да спасибо А спасибо большое за доклад у меня похожий вопрос так это про базовые классы в случае многих э координаторов там когда координатор координаторов существует Есть ли у вас какой-то единый интерфейс либо вот координатор он всегда какой-то уникальный для для сценария а смотрите у нас есть протокол котором закрыты координаторы а у которого есть метод старт и всё и какой-то callback on Finish Вот вот каким протоколом мы то есть закрываем протоколом все координаторы кроме Application координатора который самый рутовые Потому что его события уже никого не интересует то есть да как бы он всем рулит вот а дальше у всех координаторов которые находятся внизу мы просто делаем метод старт и он финиш который закрыт тоже протоколом и уже просто они все как бы являются одним и тем же протокол называется координатор вот так просто Да Спасибо всё больше и больше вопросов Так давайте да давайте вы Привет Спасибо за доклад интересный вопрос есть ли какие-то методы у вас чтобы за закрывать в контроллера например презентован модально или если нужна кастомная кнопка как-то обрабатывать закрытие наза как ноп гораздо всё проще потому что это просто нажатие это как бы ивент вы в контроллере это ловите определяете как бы либо кидаете в координатор Либо вы там что-то показываете если нельзя перейти вот если же у вас не кастомная кнопка а просто это обычная кнопка то в таком случае вам придётся уже как-то там поиз вращаться немножко вам придётся стать делегат на gation контроллера обрабатывать там все эти вещи то есть там тоже чу-чуть посложнее но сделать тоже можно в принципе то есть тоже можно все эти события Они все в принципе отлавливает там вот поэтому это всё тоже можно отловить они отлавливает начинает знать о том где он презентован в най контроллере в в контроллере не нет Смотрите смотрите а контроллер как раз наоборот не знает о событии того что мы сделали там Нажали на эту кнопку об этом знает координатор то есть мы координатора делаем делегатом Navigation Короле который в нём лежит и всё то есть и получается что экран как бы по сути Понятно спасибо спасибо большое за доклад у меня уточнение и вопрос правильно я понял что на каждый контейнер у нас создаётся свой координатор наж контейнер Да ну то есть там у нас есть какой-то Navigation и у него есть какая-то цепочка плюс у нас есть какой-то допустим табар и у него тоже есть какая-то логика Угу ну смотрите здесь получается что здесь как бы сопоставление не один к одному то есть один контейнер у нас в принципе может быть один длинный длинный Navigation Да но он быть побит на какие-то короче поменьше сценарии эти сценарии будут старта будут стартануть в одном и том же навигейшн вот вот так может быть а может быть так что как бы у нас наоборот в одном координатор типа табар там и най какой-то то есть вот так здесь нет разниц Один к одному Так а в чём вопрос А вопрос в том что если у нас допустим есть плин какой-то либо у нас пришёл пуш мы на него тыкнул у нас где-то глубоко Очень нужно уйти в экран вот за вот эту логику Кто отвечает тут опять же можно сделать так что так как у вас есть всё это дерево координаторов Вы можете просто в протокол а добавить какой-то там метод типа handle deeplink или can handle deeplink да и просто с самого верха прокиды вниз вниз Вниз пока кто-то его там не обработает типа как respond chin только в обратную сторону сделать то есть ну точнее в эту же сторону и всё то есть точно так же потому что у вас есть способ Достучаться до всех координаторов так они все друг друга держат как дерево поэтому вы можете просто вниз прокиды Да спасибо большое Здравствуйте спасибо за доклад вот хотел спросить такой вопрос что всё-таки координаторы рассчитаны на то что в каждый момент времени на экране один вю контроллер А что делать в случае если у нас есть Child View контроллеры то есть на одном вю контроллере прекрасный вопрос Да значит смотрите здесь хорошим примером можно может послужить например iPad с его согласитесь то есть там как бы у нас одновременно это как бы тоже контейнер там одновременно есть на экране Маер и детей Да вот да да то есть в тако в таком случае например да если Ну я говорю как пример просто у вас есть какой-то контроллер у которого есть два вю контроллера в принципе там происходит абсолютно Такая же история у вас есть какой-то контейнер и как бы этот контейнер он содержится в координатор и дальше координатор ловит события от чил дов этого контейнера и обновляет другие чалды вот так ну а там вот два свойства у координатора то есть сам контейнер Да вот и текущий вю контроллер вот что в данном случае будет текущий vie контроллер то есть parent View Controller да для кото Ну родительский View контроллер для Это для этих чилдо да то есть если что координатор будет в него стучать Да как бы нет вот текущего как раз контроллера там Нет смотрите Вы можете сделать тут опять же вот такая схема что она достаточно гибко Вы можете делать как вам удобно вы можете сохранять эти вю контроллеры чилд каждый как Property We Да вы можете ще виде яле из То есть я знал что они лежат Короле Мне нужно дополнительно их хранить даже как то есть это просто усложни визуально всё Поэтому просто пробегал Поня свойства да да То есть можно как бы есть варианты разные как Как Вам удобно так и делайте Вот ладно спасибо посмотрю ещё ваш пример Конечно если Бут какие-то вопросы ещ можете потом ко мне подойти как бы лично я там могу ещ что-то показать рассказать если интересно Всё спасибо"
}