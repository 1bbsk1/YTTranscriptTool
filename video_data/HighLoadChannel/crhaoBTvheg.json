{
  "video_id": "crhaoBTvheg",
  "channel": "HighLoadChannel",
  "title": "!sync: асинхронное взаимодействие / Вячеслав Турчанинов (Ratengoods.com)",
  "views": 480,
  "duration": 2568,
  "published": "2017-04-10T05:57:59-07:00",
  "text": "я буду сегодня много ндо рассказывать вам про синхронные взаимодействия Но это на самом деле интересная тема Если говорить о синхронном взаимодействий вообще вы с ним бессознательно сталкиваетесь постоянно ваша постоянная работа с операционной системой подразумевает постоянное создание куч разных событий которые планировка операционные системы выполняет асинхронно То есть он их принимает является по факту мешалкой всех этих асинхронных событий основной основным интерфейсом для того чтобы всё это крутилось в операционной системе является системный вызов который выполняет одну простую вещь Он забирает управление из программы фризит её на какое-то время отдаёт управление операционной системе которая выполняет свои действия давая возможность выполниться другим программам которые тоже могут сделать системный вызов и вернуть управление Таким образом получается коллаборативная работа все операционные системы ваши окошки все работают всё рисуется всё хорошо Но есть один момент если вы пишете программу какую-то операционную систему и пишете цикл в котором нет ни одного вызова системного вы получаете некий затуп вашей программы причём ваша программа которая начинает висеть Она за собой тянет всю остальную систему допустим если вспомните какой-нибудь Windows и вы возьмёте какую-то программу Напишите которая будет работать и в цикле Ну какие-то считать считать что-то постоянно ничего не дела Не выводя никуда не сбрасывая то ваша в принципе винда Она висит Это первый фейл который Вы должны запомнить и понимать что вы его будете ловить практически всегда Окей бессознательно мы более-менее понимаем давайте веся к со что же такое синхронно взаимодействие ста что у на есть каких-то и неважно что это ласс ли это функция либо это сервис реально существующий какой-то в архитектуре в любом случае это какой-то для нас синхронном взаимодействии это выглядело после начался закончился начался закончился и так до тех пор пока у вас ВС неработа то есть гипотетически если не взирая на то что внутри этого взаимодействия которое вы делаете с инстам будет происходить блокирование на выводе то есть допустим Если это было сетевое взаимодействие то вы посылаете запрос на сервер он будет отрабатывать в это время ваша программа будет просто ждать ничего не делаю ничего не отрабатываю если посмотреть на асинхронное взаимодействие то в этом слу пон синхронность которая существует в рамках ваших ваших задач это EV по факту это та вещь которая работает всегда которая на себя как раз как операционная система её планировщик забирает все задачи и каким-то образом прокручивается тем самым Вы можете одновременно создать кучу запросов каким-то сервисам передать управление сво СПО пока вам опять же придут без гарантии последовательности в любое время но факт в том что вы их будете принимать постоянно То есть если вы три задачи отправили в какое-то время эти три задачи Вам будут приходить как только первая задача придёт она начнёт сразу обрабатываться но в то время пока она обрабатывается операционная система или за вас подг бает остальные задачи тем самым вы не ждёте эти чудесные 200 ми секунд а вы ждёте 250 допустим миллисекунд самого длинного взаимодействия и в эти 250 кунд укладываются все Ваши действия С обработкой ответа Профит у вас будет сразу хороший стоит отметить что в случае с асинхронным взаимодействием вы от него получаете Профи только в том случае если время сетевого или там взаимодействие жёсткой системой системой жёсткого диска занимает больше времени чем обработка Отта и формирование за этом случае вы получаете Профит Если ваше время соме и это какие-то доли процентов или наоборот обработка у вас дольше то вы не увидите это особого почи Окей дальше Если говорить о том как вы это будете строить непосредственно в вашем коде то у вас есть два варианта это старые добрые колбеки и новые современные рурам Если вы возм и начте делать колк то самая главная задача в том что вы должны сохранить контекст того момента когда вы создаёте функцию обратной вызова Когда вам функцию обратного вызова должны будет прийти те данные которые связаны с вашей задачей то есть гипотетически вам У вас есть пользователь и вы делаете там какое-то взаимодействие на серс котором говорит что ему там надо отправить пло и потом после того как это будет выполнено вы захотите эти данные разгрести и скажет там успешно неуспешно Ну какую-то посто обработку сделать в этом случае оп У вас появляется юзер который вы должны будете каким-то образом захватить глобальную переменную или какой-то объект создать Ну в общем Вам нужен ранд который это сделает а в какой-то момент вы потом поймёте что юзера вам маловат Вам бы ещё бы хорошо иметь там Ну допустим какую-то сессионные данные Ну сессию его там у вас там лежит локаль вы там как-то на основани локали формируете сообщение которое прилетает ему в нужном языке и у вас появляется ещё одно значение но всё было бы хорошо если было бы это одной функции Но на самом деле у вас Call будет не один а у вас их будет какая-то цепочка и получается как только вы в од в одно начало цепочки запихивать ещё одну переменную вы автоматически начинаете сыпаться по основным колкам и Вам приходится значительно больше времени тратить на то чтобы нарастить функциональность если гипотетически в вашем коде ГТО ВМ из кол бэков что-то падает Exception Допустим или какая-то ошибка сегментации неважно любой вариант м Найти потом причина этого практически невозможна контекст а внутри того места где вы вызываете настолько мало насколько вы его определили а определять вы будете минимально вам не хочется лишний раз что-то делать э и всё упав вы будете долго искать Почему падает это сразу системные ошибки вы будете постоянно получать пошепки от работодателя Это плохой вариант дальше если вы обрабатывал большинство так и делат они говорят что Ой если что-то падает вот я буду регистрируйте мне функцию я буду её там когда-то вызывать когда что-то упадет она эта функция вызывается всё хорошо но опять же контекста нет Что произошло тоже в принципе Непонятно И с этим жиже эффек это то что ваш код превращается в некой спагетти он абсолютно запутанный появляется куча это личный опыт ребята как бы без теории код запутанный и в принципе поддерживать его потом становится адски тяжело То есть вы его раз написали потом вы смотрите он как бы хорош вы в него функци запихнули он уже как-то похуже а потом он всё хуже хуже в какойто момент вы просто собираете выкидывает пишете поно Следуй вариан это это Като кот реализация это иде иде в том чтобы иметь некую конструкцию иметь некий код реализацию ВС что угодно в вашем личном языке в котором вы сейчас Пите чтобы ваша вот эта конструкция имела две важных особенности перво ваша Тина который её вызывает Ну то есть допустим я хочу вст систе Ну с сетью и получить какие-то данные из удалённого сервиса моя задача в том чтобы вызвать там или и как бы ждать Давай остальным функциям там возможность выполнить вот этот вот вызов должен привести к тому что ваша функция заф она захватила контекст и она передала управление обратно наружу всё остальное забирает на себя если этот вариант У вас есть у вас есть рутина с которой удобно работать вы имеете в итоге линейный код который всегда имеет контекст падение в любом месте этого кода оно Понятно Так как у вас есть контекст Вы можете произвести нормальную обработку если попадают ошибки сокеты всё что угодно оно может быть внутрь пробро в эку рутину вы всё понимаете вас ваши последователи вас не захотят убивать и будет у вас хорошо дальше что касается э архитектуры и вообще синхронного взаимодействия тут опять работают те же самые правила вы должны понимать что если вы используете асинхронное взаимодействие в рамках архитектуры то в принципе Вы должны все ваши узлы которые когда-либо вы делаете рассчитывать на то что это будет асинхронно вот грубо говоря в своей постоянной работе и как бы проектируя что-то я придерживаюсь микросервисной архитектуры То есть у меня есть кучу кучу кучу маленьких каких-то инстан сов которые в основном воздей взаимодействовать по сети необязательно это ТП всё что угодно любая вещь получается что При таком взаимодействии у вас огромное количество сетевых взаимодействий это вот Первый факт того что вы ВС можете дество делать асинхронно все ваши взаимодействия могут быть асинхронными для того чтобы этого достичь вам нужно нужна одна простая вещь Это некий TAS - это очередь который имеет один вход Ну то есть один вход и одного получателя вы посылаете сообщение на другой стороне регистрируется некий сервис который говорит что О я готов принима Круг задач а он принимает на себя эти задачи и отсылаю внутрь в тоск задачу эта задача падает автоматически в один из инстан сов которые готовы обслуживать Тем самым у вас м ваша задача может быть перенесена куда-то наружу и вы можете э ну во внешнюю во внутреннюю инфраструктуру и вы можете делать несколько задач одновременно А ещё один важный момент в том что TAS Q который вы выберете должен не терять задачи а не терять задачи он может только одним способом пришедшая задача в него должна быть обязательно выполнена если ваш инстанс который подписался на эту очередь и готов обслуживать какие-то задачи упал не сообщив о том что это падение легально Да ну это ошибка какая-то которую вы потом получите обратно как ответ то эта задача должна быть возвращена обратно в очередь и должна быть повторена попытка передачи обратно этой задачи какой-то инс который возможно попробует это сделать как-то лучше или сможет вообще это сделать если не брать в расчёт который набира забирает на себя взаимодействие как шины то есть ещё одна важная задам образом вст с шере или каким образом вы взаимодействует для этого вы должны иметь известный формат сообщений то есть в вашей очереди или в вашем взаимодействии см лучше всего для всей архитектуры вашей выбрать какой-то один формат который вы вам будет известен вы сможете сказать что это и зачем это Откуда это И куда это в этом случае вы сможете взять эти сообщения прологи их записать в какой-то файл и в итоге у вас получится некая история которую вы сможете проигрывать на вашем архитектуре то есть гипотетически представим себе ситуацию что у нас есть этот Лог и в какой-то момент мы получаем какие-то непонятные системные ошибки что-то происходит в системе вообще непонятно самый простой вариант взять слайс базы ну какой-то у нас есть слай базы поднять это всё поднять какой-то тестовый стенд м и взять средст этих логов в которые наблюдались ошибки и начать просто транслировать их в tq В итоге вы получаете полное повторение тех событий которые происходили внутри системы Вы можете достоверно понять По какой причине у вас падает ваш сервис в рамках микросервисной архитектуры у которой кучу кучу кучу маленьких маленьких маленьких сервисов которые делают свои маленькие задачи Бывает так что поймать конкретную ошибку бывает очень трудно потому что она может проскользнуть практически по всей системе сообща что у нас зде ошибка а найти тот хвост в котором у вас реально произошло падение первичное бывает практически невозможно поэтому повторять повторять и повторять это событие - Это очень хороший вариант для того чтобы отлаживать вашу архитектуру в целом вашу систему есть наши библиотеки которыми мы постоянно непрерывно пользуемся что у нас всякие Мон ку разного другого то не всегда для того кода с которым мы работаем и для тех технологий с кото тех фреймворков с которыми Мы работаем есть драйверы к системам хранилищем ре то в случае TAS вы Элементарно берте этот код вы его выносите и у вас получается асинхронный взаимодействие на уровне баз данных Чего угодно понятно что этот код не стал асинхронным но в рамках вашей архитектуры он стал асинхронным в какой-то момент если вы возьмёте какого-то человека который будет готов переписать действительно синхронный вариант Окей у вас будет полный асинхронность даже на уровне ваших малех звен момент это не только обслужить текущий запрос да то есть м пришёл клиент мы ему отдали всё а важно ещё иметь какую-то систему которая ну грубо говоря продаётся обычно это какие-то кабинеты какая-то статистика это может быть даже там какие-то ну не знаю награды там что-то сообщения какие-то пользователя Ну всё что угодно что должно реагировать агрегировать какую-то посто обработку для того чтобы это сделать самый простой вариант не меняя общую архитектуру это ввести так понимаю так называемые события в системе вы берёте э описываете некие события которые могут произойти в рамках всей вашей системы и вы с помощью tq можете их транслировать на сервис который будет их обрабатывать В итоге кабинет Ну гипотетически в нашем проекте который О сейчас н у нас есть некая система кабинета который мы предлагаем коммерцию вот для того чтобы эта система работала мы используем простую генерацию событий у нас события постоянно поступают в нашу наш отдельный сервис который в реальном времени пересчитывает строит там графики и вс тем самым не нагружая никаких узлов он является совершенно отдельным блоком который мы отдельно Сампе позволял бы делать допустим анализ трафика а анализ активности пользователей кстати говоря анализ активно Поль очень полезно с точки зрения если вы боитесь там парсинга или че-то такого Вы можете проанализировать каким-то образом их там отсекать там что-то давать там какие-то вот так вот если вы всё это делаете У вас могут быть проблемы с тем Как вы разрабатываете всю эту микросервис архитектуру ВС это синхронное взаимодействие первый фейл который чаще всего встречается для тех кто только начал писать какой-то асинхронный код это они берут какую-то библиотеку впиваются е в текущий рабочий код и ожидают что всё будет отлично и она будет асинхронной на самом деле они взяли то Сарат У меня такого предположить как бы не может но оно вот вот есть и вы должны понимать что если вы строите асинхронные взаимодействие то у вас асинхронно должно быть практически всё как максимально Всё если что-то асинхронно не может быть суть его зата Пускай там живёт когда-нибудь вы оттуда вытащить дальше асинхронное взаимодействие опять же не избавляет вас от необходимости иметь вычислительный ресурс синхронное взаимодействие избавляет вас всего лишь только от сетевого взаимодействия то есть даёт вам возможность делать только то что нужно с теми данными которые вы получаете не Задумайтесь о том что у вас есть сеть поэтому Вы всегда должны учитывать то что всё количество запросов которые вы будете делать оно будет отражать ресурс Поэтому чем больше у вас задач пролетает по асинхрон тем больше у вас нагрузка Вы можете там открыть сервер посмотреть его нагрузку увидеть что ваши сервисы едят вообще крои какие-то а камень вас вообще нагружать Да нельзя это всё вот решает операционная система и эти лупы поэтому самый простой вариант это как все рекомендуют берёте и имеете запас стараетесь держать 70-80 там про Аля нагрузки на камни тогда у вас не будет проблем но если вдруг у вас появляется перегрузка и эффект будет очень странным будет ощущение что сайт не работает и причём чем дальше тем хуже тем хуже тем хуже практически вся ваша система станет колом за какие-то там короткое время Окей если вернуться к низкому уровню то там есть определённый набор библиотек он набо технологий которые позволяют производить Это асинхронно взаимодействи наверно все слышали и ерунду есть библиотеки которые позволяют поверх всего это жить ли Ну куча разных других я допустим пишу на питоне у меня вот есть торка которая в принципе меня устраивает я с ней работаю так вот если вы пишете какое-то ядро системы то вы как разработчики должны помнить о том что асинхронное взаимодействие оно потому асинхронное что вы получаете когда-то что-то в каком-то виде в непонятным Вот вы можете в любой момент получить что угодно Поэтому если мы возьмём соке и скажем что О'кей мы будем на этом сокете э работать асинхронно и первая мысль О Круто а я же ведь могу взять и в этот сокете послать две задачки а потом две задачки принять Нет так не получится Вы пошлёт две задачки они уйдут А пока вы будете посылать вполне возможность к Вам уже вернётся ответ вполне возможно вы эти после две задачки будете сидеть ждать и вам одновременно две задачки придут абсолютно не гарантируется никакая последованность Когда кто придёт В итоге вы получаете можете получить либо сложную логику обработки всех ваших ответов либо просто ваши ответы все заме будет мешаться в одну кучу будут ошибки будет всё непонятно и всё будет падать поэтому самый простой вариант - это поднять соединение отдать задачу сидеть ждать вы си те Вам пришло вы делаете дальше свои движения если что-то не так обрыва всё это не нужно вам и поднимаете Работайте дальше дальше если продолжить то само взаимодействие не несёт Никакой пользы без того чтобы там летали какие-то полезные данные поэтому данные должны иметь протокол Об этом я чуть раньше уже говорил они и оны протокол уже сетевого уровня то есть да не какой-то логический формат Да а вот именно протокол который вы либо Бинар либо каким-то образом можете понять и разобрать этот протокол должен обязательно иметь шапку и должен обязательно в этой шапке указывать свой лот То есть вы должны всегда понимать что послав данные вы первым делом доны сказать сколько вы полёте получив данные вы должны всегда знать что Вы получили какой-то обм данных иначе у вас получается накладывание данных друг на друга невоз читать какие-то данные Либо вы в какой-то момент можете прочитать лишнее и как программист вы там прочитаете лишнее потеряете это забудете про это и опять всё падает падать будет постоянно также не стоит при работе асинхронно забивать в чтение какой-то гипотетически для вас кажущейся подходя бай Я хочу получать каждый раз буду получать не вы должны именно работать по вашему протоколу с вашими фиксированными протокола шапку приняли засчитывать дальше тогда у вас будет всё более-менее нормально По крайней мере на уровня логики у вас будет работать и ошибки сетевые они останутся ошибками Семи а не ошибками программирования емы говорим архитектуре и поговорим о том что всё это должно как-то масштабироваться всё это должно быть работать быстро и как бы это всё надо раскладывать на разные Тачки у вас сразу возникнет желание поднять кучу исов это нормально И это правильно так и должно быть вы берёте поднимаете эту кучу исов проходит асинхрон кото этих исов попадает и обрабатывается поэтому вы должны делать эти инстансы как можно более однотипный То есть если вы сделали какой-то сервис Он должен не менять своих свойств Если вы его планируете Если вы в каком-то из ваших сервисов возьмёте и скажете Окей мне здесь нужно ло и вдруг вы возм и скажете Это хорошо я сейчас быстро запи фалик всё отлично вы этот Файлик запили на этом сервисе и всё работает всё лочи всё бегает но стоит взять этот сервис положить на другую тачку всё не работает Локи прилетают как бы задача прилетает задача может дубли нагрузка откуда-то непонятная всё куда-то бегает прыгает Ну ничего не понятно Поэтому если вам нужны какие-то примитивы какая-то синхронизация Окей там можете взять кш можете вть какие-то другие вещи которые позволяют примитиво какими-то управлять но ни в коем случае не Старайтесь сделать так чтобы ваши инстансы были какими-то уникальными всего лиш того что вы его подняли Ну и собственно самый главный Профит от асинхрон это в том что у вас есть Клиенты клиент может быть любой клиентом может быть ннд который отдаёт сайт клиентам Может быть там мобильное приложение всё что угодно любой клиент считается для нас одинаковым факт в том что любое клиентское приложение имеет алгоритм своей работы чаще всего этот алгоритм выглядит следующим образом есть какие-то внешние данные на основе этих внешних данных нам нужно получить какую-то Блокирую задачу логически Блокирую Да допустим получить там сессию пользователя Ну что-то какой-то минимум А после этого мы берм и можем получить Нам нужно будет получить огромную пачку задачек огромную пачку данных допустим там Лента последние новости фотографии Ну всё что угодно любую пачку мы можем е поть асинхронно если мы что-то не получим это не страшно мы покажем что мы там грузим или что-то но факт в том что вы получаете асинхрон вы берёте это всё TAS закидывается все задачки пошли и по факту у вас как раз та ситуация когда сетевое взаимодействие значительно больше времени занимает нежели получение данных их обработка и отображения то есть сам рендер там грубо говоря того же шаблона занимает какие-то вобще миллисекунд вхождение в базы там выборки занимает там десятки сотни миллисекунд ваш ваши клиенты которых вы буде которые вы будете писать потребует значительно меньше к себе внимания и меньше ресурсов для того чтобы работать м вы э больше времени и больше усилий будете тратить на то чтобы разрешать реально ваши задачи которые будут касаться именно данных именно взаимодействия а именно каких-то какой-то бизнес логики Здравствуйте я хотел бы вот такой вопрос задать Если задачи являются зависимыми то в этом случае асинхронность как бы получается теряет свой своё преимущество А как тогда поступать как решать такую проблему Ну например если у меня выполнение третья задачи зависит от полученного результата первой задачи то есть они получатся а вторую задачу я могу выполнить параллельно Ну первая вторая и третья А как они должны взаимодействовать То есть как То есть я получается отсылаю все три задачи но третья ждёт пока не выполнена первая если нет тут тут уже Вопрос просто в логике того как вы реализовывает в коде гипотетически вы берёте первые две задачи вы их отправляете вы их отработали вы их приняли обратно ну окей вот третья задача вы е просто отдельно выполняете Если вы можете вместе задаче выполнить ещё пачку выполняйте это уже просто блокирующая логикам Если у вас есть возможность сказать что у меня будет зада синхрон Да и вы можете работать ну как бы выстраивать свою личную логику так чтобы она была асинхронной то есть вы просто в голове простра ивайтенки задач вы его получили оптимизируйте ровно Вот это место на стороне сервиса сервера А дальше вы делаете пачку асинхронных и всё в вашей архитектуре мы фактически получаем единую такую точку отказа это очередь неправильно Нет вот смотрите хорошо у нас упа оче у нас упало всё нет Если вы одну сделаете у вас Да ну вы Вы просто неправильно тогда сделаете на самом деле вы Ну так как вы работаете с сетью Да и вы работаете асинхронно И у вас на создание нового коннекшн крайне мало ресурсов уходит это же нер там да не тред это сот то Вам никто не ограничивает TAS Q увеличить вдвое втрое в три четыре инстанса сделать Как вы хотите сколько вам нужно сколько вы считаете разумным и каждый сервис у вас цепляется каждый Ну каждый микросервис цепляется к каждой очереди Они же равноправны в все очередь равноправны Значит на стороне клиента вы также имеете информацию о том что у вас есть три инстан гипотетического та Серви и внутри Вы можете решать Робином как угодно ве сами выбор того какой В какой таск вы поште задачу вы в неё послали задачу она ушла тем самым вы разгружает это ну всё дальше понятной день за а очереди нет очередь - это примитив который реализуют одну вещь доставку ВС Они между собой логически ничем не связаны если вам вобще ничем вам интересно Чтобы у вас было одна тас Q на одно а другая тас Q на другого причём это обосновано тем что у вас на одном та одни задачи у вас лёгенький мало а другие задачи у вас большие и их огромное количество просто они пролетают огромными пачками Да есть смысл отдельно отделить там э Task сервис сервер для одного Task и там пачку сервисов серверов для других Task это логично А так они всё одинаковые никакой разниц как-то можно Нет Кого instance с та TAS а зачем резервировать Нет а зачем а вы сразу делаете поднимите рири и это ошибка это косяк Это жёсткий упал Ну это конечно зона ответственности Но это крайний случай то есть с тем же самым способом может упасть что-то Окей У вас есть логирование сообщений которое вы можете либо проиграть либо потом его просто обработать Ну провести какую-то может быть ретроспективу взять достать как то сообщение которое было дослать его и так далее это всё можно но факт в том что Вы не должны пытаться решить всё То есть если у вас может что упасть Окей Пускай падает У нас есть резервы если клиент Может там облома ну облома о один раз но второй раз вы ему доставите у вас у вас при асинхронном и Том Том подходе Когда вы имеете не по одному инстанс на какую-то задачу Да T это сервис Неважно а по нескольку че Окей на одном упало система автоматически через tq отключилась этот микросервис и он начинает течь в другие места один раз отвалился дальше будет всё хорошо Ну хорошо и ещ вопросик какой алгоритм работы обработчиков то есть как они регистрируются и как они берут задачи Вот это это я не стал Конечно говорить есть куча сервисов куча даже решений которые уже tq реализовывает если взять тот же самый rit MQ он это Умеет zq умеет факт в том что это очередь обычная это обычная очередь с допка один к одному пришёл получил пришёл получил не брод Кан один к одно мы на самом деле у себя долго искали Отта отказались ВС что связано см почему-то как-то очень странно себя вет абсолютно непонятно Мы перешли на так называемый Да он старенький Он давно не поддерживается Я не знаю там когда последний раз фик приходили но на тот момент когда написали Он идеально вообще решает свою задачу задача у него простая как раз вот отослал зарегистрировался получил Либо выполнил пор потом кони еста него фич никаких функций он весь in Memory он упал всё потерял Ну как бы ничего страшного м доставка и нагрузку мы на нём тести он выдерживал там тысячи этих псов никаких проблем у него вообще не возникает память он практически не жрёт А да да где там жрать там нечему вот так что вот если нач с чего-то начать вот Возьмите german Попробуйте очень просто куча библиотек практически под все языки э какая-то там админка даже есть что-то какие-то морды ну можете попробовать Е А спасибо за доклад Ну вот я так понимаю что микросервисная архитектура она всё равно сложнее В разработке сложнее В поддержке Это я хотел попросить можете критерий озвучить когда на него пора переходить проекту тоу сразу любой начинайте сразу легче будет Спасибо сейчас я просто можно сейчас проком этот вопрос он буквально 2 минуты на самом деле микросервисная архитектура - это не ново в программировании и в архитектура всё не новое Всё старое всё слиза с реальной жизнью вот если вы возьмёте реальную жизнь и попробуете представить е без микросервисной хитори Ну то есть без там департаментов образования Без маленьких групп людей без там друзей без там школ институтов которые делятся микросервис какими-то инстанса Да какой-то кон задаче то ваш мир вот схлопывается непонятно что с ним делать Ну вот тоже самое И там оно же живёт по тем же самым признакам правилам что и обычная жизнь вам просто рано или поздно Если вы хотите нагрузку получить Ну вам придётся перейти лучше сразу переходить не морочить голову можно следующий вопрос вот смотрите немножко Автопик он больше про микросервис чем про асинхронное взаимодействие А есть такая проблема что в том случае когда изменения в системе ког на условно говоря все интерфейсы статичные Да ВС у нас прекрасно мы Независимо делом запускаем истан и так далее тот момент когда у нас меняются интерфейсы меняются схема работы сервисов между собой не дай Бог продуктовые требования накрывает несколько сервисов которые должны разом поменяться у нас деплоймент становится очень сложным у нас в продакшене на самом деле микросервисная архитектура как бы поэтому мы этого наелись нормально Вот и собственно Есть ли какие-то рекомендации потому как плой организовывать потому ча это бывает очень сложная хореография реально У меня более правильное решение для вас есть сменить генерального директора и маркетинговый отдел Да что сменить генерального директора и маркетинговый отдел ладно это нереально на самом деле реально но если это реально делайте Так найдите нормальных людей на самом деле нельзя вот рабочую систему взять и сказать Что окей 50% мы переделаем и пускай оно прям сразу всё взлетит такого не бывает нет подождите подождите подождите есть конкретное небольшое продуктовое превращение Да которое в целом на системе должно Измени оно для того чтобы его реализовать он может затронуть интерфейсы нескольких сервисов Это как так Ну вот так это бывает я могу как бы ну сейчас чтобы время не рази мы можем потом это подробнее обсудить но такое бывает и соответственно возникает вопрос есть ли какие-то Бест практис на эту тему на самом деле прям СТ практис У меня нет сходу то что я могу сказать А вот вот вот это вот новый новая функциональность которая делается она как-то клиентам что-нибудь увидит Да конечно пря сильно а с Деп у вас какие проблемы это вы просто не можете разложить их или что он превращается в многофазной возникает риск того что не потребуется иметь Две версии одного сервиса в продакшене если сервис опираются на источники данных не копеечного размера вы изменили IP для клиентских приложений а клиентские приложения вы не можете сами потрогать поменять в данном случае это даже неважно потому что в качестве клиента конечно может выступать другой сервис Наго в конце системы Да ну там серии За ним ещё два-три дру То есть вы всех клиентов не контролируете естественно есть часть клиентов которых мы не можем непосредственно контро у вас двух вазе у вас нет вариантов это главная боль Окей это как смене смена схемы пожалуйста О'кей спасибо А ещё один вопрос по поводу внешних ресурсов при асинхронном взаимодействии У нас есть БД У нас есть микросервисы которые асинхронно взаимодействует что-то меняют в этом БД и в итоге логическое с точки зрения клиента операция разбивается микросервисами которые исполняются в разных потоках на разных тачках но мы хотим сохранить консистентность Вот есть ли какие-то в базе данных чтобы это была ну грубо говоря одна распределённая транзакция например есть ли какие-то паттерны как это легче всего организовать потому что всё накрытие распределённой транзакции - это блокирующих ресурс Просто так это прям прям жёстко размазано А как как как-то конкретнее ну смотрите У меня есть э данные по пользователю и микросервис который меняет эти данные по пользователю там прописывает ему там новое новое фото одновременно с этим совершенно другой микросервис подсчитывает количество там фото и регистрирует активность у подписчиков и если хочется иметь когда выполнило с одно однозначно во внешнем ресурсе в базе данных чтобы другое слате сделайте событие и всё будет хорошо да событийная модель понимаю но тем не менее мои клиенты у меня спрашивают А как вы нам гарантируете то что в базе данных не будет половина функционала зафиксирована А половина потеряна это же база данных это проблема того как вы проектируется микросервисная архитектура на той приноси чтобы вы брали задачу вы делали IP а всю тонкость вы туда вот у и никто не видит это такой большой сервис не микро получается А как это микро вы фотками управляете Ну управляйте фотками В чём проблема-то Ну это Я на пример привёл на самом деле мы пишем финансовую систему для банков и там когда идут документы там что-то огромное происходит по куче продуктов по куче серверов это ну очень много данных Ну опять же вы вы меня сейчас взяли Вот вы Я просто спрашиваю есть ли у вас какой-то Ну может быть паттерн когда сервисы взаимосвязаны меняют по сути обращаются к единому ресурсу это какое-то у вас У вас есть вот место инициализации Да место где долж где первично возникает какая-то какое-то взаимодействие Да что фронт какой-то что-то и потом у вас начинается асинхрон он такой бу потёк куда-то да да Лок алок можно начало Если всё хорошо ивент всё вот чётко разделяйте Я понимаю что э Вы ждёте чтобы вот оно залился вам тут же событие скорее всего это не нужно вам нужно вот если нужно транзакция что-то типа вот у вас есть блок вот по нему и Работайте ловите всегда тот момент где у вас что-то начинается то есть это микро такое состояние вот на уровне ну Вот мы вот тут по сути это есть состояние вот мы Лок начало конец Да да это состояние оно ведётся да Ну понятно спасибо у меня такой вопрос а вот у нас есть система в которой разгрузкой очереди занимается отдельное приложение и соответственно Ну там никаких ни коллбэк ни каротин Ну появилось требование возвращать контекст после отгрузки из очереди сообщений А первоисточнику есть ли какие-то решения для этого или отказаться от этого требования стоит совсем отгрузки контекста источнику это как ну у нас первоисточник отправил сообщение в очередь его очередь когда его разгрузила она Ну в это разгрузила она отдала что ли кому-то на выполнение или что нет Она отдала какому-то конечному сервису куда она должна его отгрузить вот после этого она должна вернуться в тот контекст который был на момент отправки Ну то есть по сути колк но из другого приложения я честно говоря не совсем понимаю давайте сейчас дадим комуни шанс ещ потом Подойдите Просто чувствую сечас надолго это затянется возможно человек говорил про возврат результата Я тоже хотел спросить как результаты возвращаются от сервисов Ну точно также обрат результат ул одна сессия сессия вот есть сот поставили задачу эта задача присвоила какой-то идентификатор что-то Ну вам потом этот сервис скажет что вот у тебя такая штука была дальше там что-то произошло там где сервис ваш что-то сделал он послал ответ обратно в очередь но он уже как бы воркер да он хендлер По факту он ответил задача вашего tq понять что вот идентификатор вот он идентификатор вот он клиент всё ещё вцепится зацеп Ну мы ему и отошёл вот он получает потом асинхронный этот ответ"
}