{
  "video_id": "65EBw1aEaX0",
  "channel": "HighLoadChannel",
  "title": "PHP generics / Антон Сухачёв (cdnnow!)",
  "views": 165,
  "duration": 2169,
  "published": "2023-10-06T07:24:21-07:00",
  "text": "Привет меня зовут Антон я разрабатываю на PHP уже 8 лет примерно год назад я задумался ну серьезно Почему в PHP до сих пор нет дженериков я полез смотрите России Я палец смотреть там Исходный код какие-то читать статьи какие-то читать Вот все это в принципе вылилось в то что у меня получилось написать собственное решение дженериков для PHP на самом PHP вот об этом опыте Я бы хотел сегодня рассказать свой доклад Я поделил на три части Что такое дженерики И зачем они вообще нужны какие есть подходы к реализации дженериков и как сделать а ценерики это очень много про типизацию Поэтому вот в принципе хотел бы начать Сначала с типизации какая она бывает Сильная слабая типизация языки сильные типизации характерны тем что не позволяет смешивать в одном выражении разные типы языки особо зации позволяют смешивать такие типы Ну и могут выполнять неявные преобразования Вот например как в PHP статическая и динамическая типизация языки со статической типизацией обычно выполняет проверки типов на этапе компиляции динамических типизации проверяют типы на этапе рантайма то есть мы сначала написали код вот на PHP или его скомпилировали и только потом уже в рантами узнали что у нас там где-то что-то неправильно но большинство языков в принципе не облагают не обладает какой-то строгой строгой типизации или строгой слабой типизации Они обладают какой-то смешанной типизацией которую где-то что-то больше выражено вот даже в том числе в PHP есть это ошибки компиляции на этапе компиляции для типов то есть такие небольшие случаи в принципе валидный код можно зайти проверить и того HP динамический соботизированный позволяет смешивать типы в одном выражении делать не явные преобразование проверяет типы на этапе рантайма в принципе PHP проектировался как язык вот такой вот без типов чтобы в принципе можно было быстрее проектировать быстрее писать Ну проще писать А зачем тогда в принципе добавлять Зачем типы печки могут понадобиться Ну вот например с типами читать и писать код проще предположим что разработчик пишет какой-то библиотеку для оплаты Ну есть функция Pay без типов есть хороший разработчик Он должен будет в теле функции проверить что аргументы передались определенные типы То есть он будет для каждого аргумента он обязан будет проверить проверить что все хорошо при этом пользователь который будет пользоваться этой функцией как минимум должен будет проверить что такая функция вернула и если вдруг он захочет посмотреть А какой же в принципе тип ему нужно передавать в эту функцию ему нужно будет посмотреть не на сам интерфейс функции а залезть в само тело функции и там уже посмотреть как эти типы обрабатываются Какие типы можно передавать смотреть довольно сложно получается при этом если мы добавим типы то во-первых разработчик который пишет эту функцию Ему больше не нужно делать проверок на типы за него это будет делать язык разработчик который использует эту функцию ему тоже не нужно будет делать проверку на Тип который эта функция возвращает плюс если он захочет посмотреть интерфейс функции он открывает интерфейс видно очень удобно проверки типа происходит на уровне языка разработчику не нужно за это думать и писать и читать код с этой стороны проще становится почему еще проще если мы добавим типов в код то стационализ станет работать намного мощнее ошибки которые мы можем выявить не в runtime как в PHP А в на стадии написания кода это здорово намного намного раньше чем вот когда код упал там где-нибудь на сервере Да Пару слов про аннотации аннотации мощная штука можно указывать типы но аннотации это все-таки документация это комментарий коду от одного разработчика другому Сам PHP эти аннотации не учитывает а аннотации Как и любая другая документация Может встревать может быть Не валидно а при этом даже если мы написали что мы ожидаем какой-то тип там вот в функцию совсем не обязательно что туда этот тип передадут это просто договоренность на уровне языка такие типа не проверяются Ну и того Зачем нужна типизация в PHP проверки типов выполняется на уровне языка разработчику за этим следить не нужно писать код становится проще опять-таки разработчику не нужно писать какие-то дополнительные проверки читать код становится проще потому что мы сразу же видим интерфейс функции интерфейс класса Здорово более мощно работает стационализ Ну и аннотации могут устаревать поэтому могут устаревать могут быть принципе не валидные поэтому вот железно положиться на них на уровне языка мы не можем Где сейчас можно использовать типов печки Ну Практически везде мы вот можем и в аргументах функций Используйте возвращаемых значениях много где где нельзя ну в коллекциях нельзя то есть мы не можем сейчас PHP взять и указать что массив будет конкретно из Вот таких вот типов мы можем указать конечно через аннотации но как я уже говорил они на уровне языка ничего не дают язык сам не проверяет что внутри массива жестко будут какие-то типы как это сейчас решается сейчас для каждого такого типа создается своя коллекция в котором добавляется тип по одному в котором как раз таки можно указать и вот этот тип как раз таки будет проверяться на уровне языка Но получается что для каждого такого типа нужно будет сделать свою коллекцию то есть нужно будет написать свой отдельный класс со своим конкретным типом это больше кода в общем неудобно вот тут нам могут помочь дженерики можно написать один дженерик вас шаблонным типом и использовать его много раз но очень здорово получается пишем всего один раз кода немного проверка происходит самим языком проверка получается очень удобно Здорово то есть и читать и писать будет удобно какие есть подходы к реализации дженериков Ну вот я знаю три это typera effication И мономарфизащищен вот сейчас я немножечко про них расскажущие или стирание типов заключается в том что мы будем стереотипы на этапе компиляции то есть разработчик пишет код с дженериками с шаблонами типами все очень здорово на этапе компиляции должны выполняться проверки и после этого эти типы стираются такого подхода есть ограничения Ну кроме того что проверки должны выполняться только на этапе компиляции еще во время рантайм есть ограничения по использованию шаблонных значений то есть Вот например если мы захотим вызвать статическую функцию от шаблона переменной какой-то то время рантайма этой переменной не будет И поэтому виртуальная машина не будет знать откуда в принципе вызывать эту статическую функцию стирание типов довольно простая реализация проверки типов можно выполнять только на стадии анализа или компиляции но при этом есть ограничения использования в коде Ну и нет типов дженериков фронтальных заключается в том что для каждого конкретного набора аргументов дженерика мы сгенерируем свой конкретный класс и подставим его вместе использования То есть если мы захотим контейнер дженерик контейнер для типа int то во время компиляции компилятор найдет такой дженерик сгенерировать для него конкретный квас для int и подставить вместо использования а реализация опять-таки довольно простая можно использовать полностью дженерики в коде то есть нет ограничений как при стирании типов проверки типов происходит и на стационализе можно и в компиляции и в runtime но при этом требуется дополнительная память и опять-таки нет дженериков в runtime в самом то есть вот там уже будут конкретные типы и последний это refication отличается на предыдущих двух тем что сами дженерики сохраняются и врантайме тоже то есть реализация будет такая что в рандайме у нас можно будет сделать reflection можно будет посмотреть Какие аргументы Какие дженерики были у такого подхода при использовании дженериков нет ограничений также как при стирании типов при этом проверка тоже можно использовать и на уровне на стадии стад анализа и на стадии компиляции eurone тайме есть одно но Это вот сложная реализация три подхода в одну табличку Чтобы проще смотреть получается что стирание типов довольно просто делать но они не подходят в PHP потому что PHP такая вот он динамический все проверки нужно делать в рантами а при стирании типов проверки по-хорошему нужно делать на этой компиляции Ну или стационализа хорошим конечно на этапе компиляции поэтому не подходит вроде бы хорошо но кушает много памяти в зависимости от проекта к проекту в принципе сейчас карты новая версия PHP Вот они держат такой баланс между тем чтобы Добавить каких-то новых фич и при этом не замедлить язык так вот тут вот тоже будет очень сложно с тем чтобы добавить дженерики Да и не сделать так чтобы памяти кушалась вдруг сильно-сильно больше refication в принципе подходит по всем пунктам Кроме того что сделать его довольно сложно Почему сложно Ну вот сейчас как раз я об этом немножечко Расскажу какие есть проблемы в том чтобы в принципе тащить динарики PHP как я уже говорил при каждой при каждой новой версии у нас добавляется какие-то фичи при этом есть баланс между тем что печки работал быстрее я взял сделал немного синтетических тестов который замеряют время проверки типов которые которые ожидает функция какая-то то есть вот есть функция без типа аргументов с типом Рэй микс и класс и на этих тестах получилось так что если мы не указываем тип то есть принципе проверка типов в принципе не происходит конкретно когда аргумент продается функцию то такой вариант самый быстрый если мы указываем имя класса какое-то то видимо там еще класс реализовывается еще какие-то дополнительные проверки происходит то есть вот он практически на 20 процентов на этих тестах конкретных медленнее работает То есть в принципе в таких динамических языках чем больше типов тем больше проверок тайме тем он чуть медленнее работает с этим вот нужно как-то будет баланс находить Какие еще есть Проблемы есть проблемы с синтаксисом вот Вполне себе валидный код PHP который сейчас поддерживается если так присмотреться кажется что то внутри есть дженерик на самом деле дженерика нету PHP сделать не явное преобразование там будет 2 болевых типа вот Но вот такие вот коллизии они должны решаться нужно их как-то обходить и про синтаксис принципе я хочу немножечко побольше рассказать вам дальше нам потребуется чтобы немножечко рассказать вот где он в принципе используется в PHP Мы сначала пишем код потом используется лексика парсер для Что для того чтобы построить абстрактное синтетическое дерево это дерево компилируется в обход его коды сохраняется исполняется виртуальной машине Так вот самого первый шаг это вот Лектер вот там как раз таки синтаксисы нужен какой как в принципе PHP сейчас парсит код он использует для этого байса это генератор парсеров с помощью него мы можем описать синтаксис какого-то языка из генерировать парсер для этого языка который сможет построить абстрактное синтаксическое дерево вот здесь на примере такой маленький пример простого калькулятора синтаксиса простого калькулятора если мы добавим еще немножечко кода сгенерируем парсер то он сможет распарсить синтаксис такой калькулятора и вывести значение его с помощью вот этого байсана из кода на PHP получается как раз таки абстрактность синтетическое дерево Какие с этим есть Небольшие проблемы Вот исходный код PHP использует bysson bison поддерживает два алгоритма один из них который он сейчас использует он как раз таки плохо обрабатывать такие исключения такие вот коллизии о которых я недавно рассказывал он может переключиться на другой алгоритм там с этим можно как-то работать есть такой пакеты Попович припарсер который используется везде он используется во всех большинстве линдеров он используется при кодогенерации очень много где при этом он использует для парсера который именно вот синтаксис аналог байсона Но использовать он может только один алгоритм который как раз таки плохо обрабатывает эти вот ошибки синтаксиса по хорошему нужно перевести его на байсон но пока что это вот довольно сложно потому что я который использует PHP парсер написан на PHP байсом в общем-то написан на си и вот нужно как-то вот перевести так чтобы можно было Использовать байса можно обойти это ограничение с другой стороны у Никита Попова Есть еще одна библиотека которая строит абстрактно синтаксическое дерево и при этом оно использует парсер который уже встроен в PHP то есть партер который сгенерирован байсаном который есть PHP используется вот в этом экстеншине проблема какие есть во-первых его нужно дополнительно ставить не очень удобно во-вторых вот таким методом можно распарсить только версии либо текущего версии PHP либо предыдущей версии PHP то есть не получится распарсить например на версии 7.4 версию 8.0 с какими-то новыми фичами с новыми синтаксисом добавить какие-то фичи туда новые синтаксис тоже не получится вот я попробовал сделать такую же библиотеку но с помощью одной проблемы по крайней мере для меня меньше мне не нужно ставить дополнительный экстеншн потому что фай ставится по умолчанию но при этом такие же ограничения вот на версии на какие-то фичи если мы вдруг захотим добавить чтобы на будущее их нету Какие еще есть проблемы с реализацией но rfc еще не готов то есть нет документа конкретного по которому можно было бы уже начать делать дженерики вот для примера один кусочек кода У нас есть класс дженерик и квас а и квас б который наследуется от класса А если мы будем сравнивать дженерик в которой передали класс который передали класс B то есть таким типом кто для стирания типов такие классные будут равны потому что класса А и B они в рантами сотрутся и получится сравнение одного класса с другого одного и того же они будут равны если мы использовать будем мономорфизейшем подход то для каждого такого класса А и без генерируется конкретные классы и они будут уже не равны если мы будем использовать то в зависимости от подхода который там будет реализован можно сделать и так и так это одна из самых тоже больших проблем Это очень много кода для изменений то есть придется очень много кладоизменить очень много тестов написать Ну хорошо PHP втянуть как-то не очень получается Давайте попробуем тогда ну сделать дженерики PHP на самом PHP Какие сейчас есть принципе решение Ну вот есть аннотации самая сейчас распространенная мощное решение используя мастера не типов потому что вронтаймине аннотации этих нету комментариев этих нету синтаксис языка не меняется дженерики пишется через аннотации проверки типов только при стационализе при этом как я уже говорил если вот у нас не использует кто-то не использует ES подсветкой аннотации кто-то не использует в проекте линтер на постоянной основе Вот то такие аннотации могут встревать за ними нужно следить Вот и их поддерживать не всегда удобно опять-таки проверки типа происходит только при стад анализе фронтальной проверок никаких не будет каких-то таких железных вот проверок что обещают типы программиста их нет в фронтайме у спати есть библиотека которая может например делать коллекции с каким-то типом вроде все хорошо но при этом этот тип мы не сможем указать в качестве типа аргумента какой-то функции то есть вот он синтаксис языка опять-таки не меняет можно сделать определенный список с каким-то типом но передать его уже в качестве типа аргумента не получится то есть вот наглядности вот этой при написании при проверке нету но при этом до проверки все вратарь происходит у Time To Go есть библиотека такая более поинтересней вот на последней строчке использования дженерика вроде бы как Ну не совсем понятно что в принципе дженерия но используется встроенный автолодер свой он понимает что там есть у класса Maybe есть дженерик для класса std класс он найдет квас дженерик мэйби и вместо типа Type подставит это класс его он сохранит твороговую систему и уже подгрузит вместо использования мы без вас здесь используется когда генерируется конкретные классы он не меняется языка он абсолютно валидный все эти конкретные класса сохраняется на файловую систему но при этом нужно использовать встроенный автолодер и синтаксис он конечно не изменен но читать его сложно вот такой вот с таким такой подход он сложный для чтения для написания при этом проверке типов происходит время что собственно очень круто и самое такое интересное это у RC Max есть тоже библиотека для дженериков она уже меняется синтаксис языка и работает примерно так же как и предыдущий вариант для каждого вхождения дженерика генерировать свой конкретный класс и поставляет его опять-таки используется свой автозагрузчик используется как предыдущем предыдущий разрешен уже добавлен новый синтаксис То есть просто так на PHP такие классы не получится исполнить сгенерированные классы подгружается через его необходимо встроенный автонодер использовать но при этом Да все опять-таки очень круто во время рантань все происходит все проверки Ну да как и как же сделать-то печь пить дженерики на PHP ну для начала нужно добавить новый синтаксис в парсер потом нужно найти места использования дженериков в коде Не сами дженерик А места использования знаков для каждого такого вхождения использования дженерика для каждого конкретного набора аргументов для дженерика нужно сгенерировать конкретный класс и уже этот квас вместо использования подставить Ну хорошо я взял вот партия Попова взял синтаксис который там был и туда дописал дженерики с помощью яко сгенерировал новый парсер добавил немножко кодов саму библиотеку и собственно теперь с помощью этого парсера можно парсить новый синтаксис дженериками получать абстрактно синтетическое дерево вот прямо с дженериками круто Теперь написал библиотеку которая ходит по всем файлам и Source и ищет вхождение дженериков вот для каждого такого вхождения дженериков для каждого набора аргументов она генерирует конкретный класс и сохраняет его в директорию кэш паровую систему Затем в composerson нужно будет указать что при загрузке файлов нужно будет ходить сначала директорию кэш только потом в директорию Source Но для такого решения нужно чтобы у нас было как минимум три файла первый файл это в котором будет автозагрузчик подгружаться от композера и в котором будет использоваться квас в котором используется дженерик Второй файл это класс в котором используется дженерик и третий класс то сам дженерик То есть первый класс в нем первый файл в нем синтаксис не нарушен его может обрабатывать Вот сам PHP а второй третий класс в нем синтаксис же нарушен Поэтому при его подгрузке используется вот эти вот наши закошированные файлы в которых уже есть а вот здесь для примера Да у нас есть файл индекс.php в нем вот на первой строке подгружается авто лоб на следующий используется квас юзечь и юзать он уже достается из директории кэш в кш уже используется конкретный конкретный курс дженерика для этого я написал команду для композитора который проходится и все это генерирует плюс он может проходиться генерировать не только для директории Source но и также для вендоров То есть вы написали библиотеку с дженериками подключили в свой проект там есть вот как вот она сможет сгенерировать дженерики конкретные дженериков не только для вашей библиотеки Ну вот и для не только для основного для вашей библиотеки Насколько быстро все это работает конкретные классы генерируются заранее поэтому их можно кэшировать Но чем больше конкретных классов тем больше тратится времени на их подключение на проверку типов на хранение в памяти то есть вот эти все основные минусы при мономортизации нельзя использовать без композеров telloat Ну вроде не такой большой минус reflection reflection нет как я уже говорил для монетизации reflection Ну не может быть и самое больное это поддержка синтаксиса выде его пока нету например нет поддержки дженериков Ну потому что даже до сих пор Россия ещё не определён всего до конца а работающего плагина для протокола lsp тоже нет это такой протокол который позволяет написать свой сервер и с помощью этого протокола с сервером Да я общается и может подсвечивать синтаксис новый какой-то который вот она до этого не умела подсвечивает там распознавать как-то какие-то подсказки делать как язык который основан на PHP в котором сейчас есть дженерики Раньше вроде как поддерживался в PHP но сейчас нет поэтому вот синтаксиса с дженериками шторме нету вскоре в принципе есть поддержка его спи Но для PHP с дженериками синтаксиса сервер такого нету Есть плагин для Хак там есть поддержка синтаксис вот этого хаксликами но не так удобно как PHP Шторм использоваться всякими подсказками В общем на этом все ссылку на как раз библиотеку с дженериками там есть еще ссылочка на эту презентацию в общем я готов сейчас буду отвечать на ваши вопросы Все спасибо Спасибо Антону Ну как вам дженерики Давайте уточним У кого есть вопросы сейчас мы еще в чате посмотрим вопросы спасибо да спасибо за доклад хороший интересный два вопроса Наверное если можно Да не об у меня назрели входит доклады вопрос первый ну как вы правильно сказали typeration сейчас рассматривается как основной наверное да способ большинством сообщества есть вообще мнение что дженерики не нужны Почему они нужны потому что единственная их по сути реальное применение типизированная коллекция очень типизированную структуру данных Да и тот же сам писал он прекрасно с этим справляется вот как вы относитесь к такому утверждению Что может быть дженерики вообще не нужны языки потому что есть стад анализ и это уже работает Это первый вопрос второй вопрос я видел очень интересную реализацию когда используются не аннотации атрибуты то есть базовый класс некой абстрактной коллекции атрибутом задается типизация этой коллекции Ну и дальше внутри уже понимаете как Всё достаточно легко и просто и вратаме есть опять же да информация об этом типа как к такому пути относитесь вот два вопроса Спасибо Спасибо за вопрос про аннотации как я уже сказал это просто документация То есть если вы конечно поддерживаете все это хорошо да на должном уровне у вас постоянно линтеры запускаются у вас выдает поддержка есть дата Здорово в принципе ну сейчас все этим пользуются в общем-то про атрибуты атрибуты Да это здорово Они как раз таки да могут проверяться в ран тайме Единственное что нужно будет доделать поддержку синтаксиса то есть чтобы е понимал что вот когда мы указали какой-то атрибут что это вот именно шаблон вот так вот ну хороший вариант задам свой вопрос А вот реальных проектах продакшене Используйте Вот это решение насколько оно пошло удобно неудобно Нет сейчас она нигде не используется я его делал именно для того чтобы попробовать А можно ли в принципе сделать попробовать какие-то посмотреть лимиты на синтаксис Какие ограничения есть да то есть сейчас принципе вот когда всплывает какой-то да то хотелось бы иметь что-то уже какой-то готовый хотя бы демо Да чтобы можно было пощупать это и может быть какие-то фичи добавить то есть например вот вот в этой библиотеке которую Дай написал например есть значение по умолчанию значение по умолчанию указывать Но какие-то фичи которые можно делать только в самом PHP там естественно нельзя будет сделать Ну вот как такой вот демо для rfc вот Вполне себе можно использовать да так А если окунуться в историю rfc их же наверное было несколько штук я Припоминаю в разные годы какие-то инициативы А почему они все запоролись из-за сложности реализации именно а там много всего rfc Сначала был на своем сайте сейчас он на гитхабе вот да там много Например упирается самой диалоги PHP То есть почему до сих пор не тащили стирания типов Ну потому что PHP должен пить именно динамически он должен проверять все типы вот в runtime Да все-таки в компиляции проверять Ну вот ребята которые как раз таки из России компиляции нельзя Нужно только втаскивать только так Да в рантами сложно но понятно то есть мы будем ориентироваться на твой библиотеку в надежде что она покажет Core разработчикам путь к светлым будущему и они напрягутся и запилят это все вронтами наконец Я надеюсь Да а вот еще вопрос 1 ряда Большое спасибо за доклад А подскажи все-таки вот в будущем Где ты видишь практически применение это будет какие-то проекты которые вот молятся на примерно в каких проектах ты видишь использование подобного вот решения потому что он есть например как вот уже коллега сказал что там понимаете и прочие вещи которые помогают это дело закрыть и потом банальные геттеры классов сам ПХП проверяет что тебе вернулся не тот тип и там пофиг будет что аннотация где-то стоит когда у тебя Ну просто сам ПК работает и ну как бы Спасибо так вот почему сейчас вот эти вот коллекции Ну не использовать неудобно потому что такие коллекции нужно будет писать для каждого класса мне бы хотелось использовать это легко то есть вот даже для маленьких кисток каких-то структур Да сейчас нужно будет писать свою коллекцию где вот этот вот гетер сеттер использовать чтобы именно конкретно phprint ввёл проверки вот а где можно использовать а именно дженерики Ну по сравнению например с аннотациями Да это смысле везде в том плане что опять таки это будет проверять сам язык То есть даже если вы вдруг не включили линтер вдруг или что-то такое проверку какой-то Да глазами не сделали то PHP все равно за вас проверку это сделает Вот а если именно про использование библиотеки то конкретного применения куда-то ее использовать я пока что не предполагал хотя там тесты есть все работает все хорошо самая большая проблема как я уже говорил это поддержка синтаксиса vde её сейчас просто нету по этим поэтому этим просто пользоваться очень больно Спасибо Так ну у нас было два вопроса в зале время выбрать лучшие вопросы из двух Так у нас подарок один да двух подарков не найдется просто вопросы были примерно про одно и то же то есть вот почему использовать именно вот дженерики они нотации например никто очень похоже Я думаю тогда первый вопрос был такой более объемный больше понравился Спасибо за вопрос Так у нас сейчас будет полчаса перерыв и последняя тема модульный laravel что на самом деле очень интересно лично для меня я модульный laravelle давно использую послушаю с удовольствием автора и до встречи через полчаса"
}