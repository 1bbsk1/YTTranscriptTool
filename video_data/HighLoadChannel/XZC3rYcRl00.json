{
  "video_id": "XZC3rYcRl00",
  "channel": "HighLoadChannel",
  "title": "Как работает MVCC в In-Memory-СУБД / Александр Ляпунов (Tarantool, VK)",
  "views": 475,
  "duration": 3141,
  "published": "2023-10-06T07:23:37-07:00",
  "text": "Привет Меня зовут Александр Я работаю в ВК вот в Тарантул делают намеренные базы данных сегодня расскажу про то как устроены mcc базах данных так план примерно такой сначала буду рассказывать что такое nvc это будет такая очень Экспериментальная штука Я постараюсь это сделать максимально на пальцах там для детей младшего возраста потом постепенно там доклад будет усложняться усложняться я буду говорить про дисковая база данных под конец данных Поэтому если самого начала будет скучно то Подождите если в конце будет сложно то извините Вот и так что такое миссиси расшифровывается как multiversion concaracy Control из это название ничего не понятно поэтому начну с анекдота Жена просит мужа сходить в магазин говорит купи батон хлеба А если будут яйца восьми десяток Вот но возвращается с десятком батона хлебов Вот они мой вопрос жены отвечает яйца были вот на самом деле вот это вот штука там купи батон хлеба если то это такая Элементарная программа составителем которой является жена а муж программист исполнителя в принципе можем таких программ придумать достаточно много мне вот нравится вот если будет молоко яйца ему Карту купи всего Понемногу если чего-то не будет там с этого всего ты не покупая ничего такая вполне Понятно жизненная штука вот этот мы понимаем что человек это очень разумный Исполнитель то есть он может там как-то разруливать по ходу конфликты то есть там два программиста там тянутся к одному пакету молока последнему но они как-то разберутся кто из них там идет ни с чем А кто с чем-то Вот и всякое подобное в мире it или в компьютерном мире там в компьютерном технологиях я по-разному называть происходит примерно то же самое только исполнитель там максимально тупой то есть вообще никакой самодеятельности вот только что написано в программе Он выполняет собственно примерно как вот отсылка программистов с самого начала анекдоте Вот Но при этом все происходит очень быстро то есть вот характерные времена ну то есть там база данных может выполнить запрос там за одну миллисекунду микросекунду микросекунду За микро секунду Если не ошибаюсь свет пролетает 300 м то есть до магазина допросов такой свет можно долететь вот при этом база данных работает с такими эфирными объектами вообще в принципе компьютер не сильно связан с реальным то есть там у нас может в базе данных лежать там сто пятьсот квадриллионов батонов или минус Один батон там не проблема вот при этом программа на ходу записывать Ну как бы так обычно не происходит то есть в реальном мире там можно сказать что типа там А ты не купил колбасу сходи ещё раз за сосисками то в компьютерном мире так не получится Вот Но есть общее то есть и база данных О Господи Компьютерный мир и собственно реальный живёт в некотором изменчивом мире и с этим изменчивым миром как-то там стараются ужиться А ещё и в компьютерном мире в реальном хочется писать простые программы то есть мы как программисты лениво наверное да хочется не хочется описывать Весь детальный процесс хочется написать как-то коротко емко там типа сходи купить не описывать там вот эти вот если вот там у тебя вырвут из рук там пакет молока этого всего не хочется хочется писать короткую программу иметь там максимум два результата либо всё получилось либо всё не получилось вот и Пользуясь этой параллелью чтобы мы могли придумать в реальном мире такого чтобы максимально простить жизнь покупателю таким образом чтобы позволить ему быть максимально тупым Вот и первое что приходит в голову это ну понятно Если покупатели друг друга мешает Давайте как-то изолируем то есть Пускай магазин по одному ставим охранника на входе вот значит не впускает следующего пока не идёт предыдущий вот можно так сделать Ну в тяжелые ковидные времена вроде делали вот понятно недостатки этого подхода потенциально большие очередь на вход вот причем в этой очереди стоят люди которые там один за молоком второй за хлебом Казалось бы как они должны помешать друг другу поэтому мысль идет дальше Давайте охранник оставить у каждой полки вот тут стоит один Второй они там подпускают по очереди там вылезают следующие уже проблемы То есть там программа У каждого свои один захватил полку с хлебом второй с молоком потом они пошли там перекрестно к этим полкам и зависели бесконечно потому что каждый ждет второго вот тем не менее Можно так сделать наверное можно а Можно в компьютерном мире так сделать Да тоже можно вот собственно так многие делают и называется эта блокировками вот там детали Вот примерно такие же можно блокировать всю базу целиком можно таблицу можно часть рядов можно там один в общем как угодно но тем не менее многие базы используют этот подход блокирование чего-нибудь пока кто-то там не закончим с этим работу вот недостатки те же потенциальные большие очереди взаимные блокировки вот можно ли что-то еще придумать так вот в реальном мире это звучит уже вообще дико А вот в компьютерном в принципе можно сделать следующее представляете покупатель заходит в магазин и вот моменты захода ему берут и копируют магазин целиком такой персональную копию Опа И он в ней ходит один вообще вот приходит второй ему тоже бац копия магазина и он ходит тоже не один не мешать друг абсолютно А вот на выходе там какой-то кассир значит внимательный придирчиво значит изучает что каждый делал и говорит там и уже повторяет эти действия настоящие реальности так вот это туда туда Вот хорошо Вот те чек на выход а второй приходит такой кассир смотрит а у тебя молоко Слушай когда ходил тут молоко всё разобрали то есть они настоящее молоко Верни всё на место Если хочешь попробуй еще раз но не факт вот фактически это если мы сиси вот мы в одном слайде это описали на всякий случай повторю подробно MSC это подход в котором каждый покупатель транзакция видит свою реальность все изменения которые вряд реальности происходят делаются самим вот этим актером то есть никаких других изменений не происходит при этом нет никакого ожидания то есть мы считаем что магазин как бы копируется моментально сразу и все работают параллельно асинхронно во всех кажется в магазине экосир на выходе собственно проверяет сверяет и повторяет настоящее реальности всё вот это вот то что делал каждый покупатель Вот чем покупателям которых от футболил кассир мы считаем вообще вот их никогда не было мы их забываем и нигде не фиксируем А вот те которые собственно выходят успешно у нас получается так по ходу кассовая книга то есть последовательность действий которая происходило с магазином с точки зрения вот самого главного человека кассира Вот только пересеку перестали дальше Вот при этом еще одна интересная особенность покупатели которые ничего не делают а только смотрят вот для них вообще не существует такой проблемы Как там их от футболили они фактически получили уже на входе в свою корректную на какой-то момент времени реальность все что они видели мы просто говорим что ты во сколько зашел в 14:00 вот Будем считать что ты был ровно в 14:00 вот короткий промежуток времени вот поэтому этот режим частенько используется BD Вот потому что вот с правильным менеджером конфликтом к тем же кассиром мы можем получить уровень изоляции то есть изоляцию любого уровня при этом нет блокировок И можно там бесконечно делать какие-нибудь операции там типа получить свои там получить свою реальность копаться там до вечера изучать что-то никому не мешает при этом Вот но недостатки тоже есть во-первых Самый главный бич такого подхода это то что могут повторить могу попросить повторить Вот то есть может не получиться это тоже неизвестно сколько разводить тайм-аута нужно в общем есть такая проблема вот вторая проблема то что в принципе этот подход достаточно сложен Как с точки зрения реализации так и с точки поддерживания то есть он требует каких-то ресурсов там памяти как минимум и тоже Поехали дальше как может быть устроены в СССР дисков база данных начало это вообще такая обзорная штука вот для начала Что такое дисковая база данных Мне кажется они появились лет 40 назад Вот когда памяти счислялась килобайтами носители мегабайтами тогда собственно закладывались основные Базис для создания баз данных на дисковых характерные особенности диска собственно такая штука вращающаяся там самое главное особенность то что начинать читать очень долго то есть там нужно диск прокрутиться должен там головка переехать это все долго но потом Зато когда она уже начинает читать в принципе все вот потоковое чтение получается достаточно быстро а еще диски дешевые по моим оценкам раз в 100 дешевле чем память вот Итого если мы делаем базу данных на дисково носителе нам нужно мириться с вот этими вышеперечисленными вещами вот в частности почти сразу следует что база данных должна работать синхронно То есть она не может себе позволить ждать такая вот пока там закончится чтение там или запись на диск она должна как бы это в этот момент чем-то другим заниматься другими транзакциями значит работать с транзакциями параллельно значит синхронно вот потом из того что прочитать диска грубо говоря один байт там 100 килобайт это примерно по времени одинаково особенностей поэтому дисковая база данных как правило имеет тенденцию к некоторому порядку упорядочен упорядочиванию данных и разбиение на блоке вот при этом также характерно что как бы мы там ни старались нагрузка на дисковые базу данных будет небольшой то есть Все упирается в диск и поэтому в частности например не требуется особо там как-то стараться с алгоритмами то есть грубо говоря если мы прочитали блок дисков Память то что мы там делаем в памяти уже не так важно потому что по сравнению со скоростью чтения вот этого вот процесса Вот это всё мелочи никто не заметит разницы мы можем представить базу данных вот таким образом кстати кто-то говорит что база данных это в первую очередь индекс или даже просто индекс в общем суть то что как правило Мы берем данные пользовательский упорядоченным по какому-то принципу например по фамилии там кого-нибудь вот разбиваем там ножом разрезаем на куски блоки данных и храним эти данные значит либо файлах либо в одном файле в разных местах вот главное что мы подсовываем это дело индекс который позволяет обрабатывая транзакцию понять В какой блок нам нужно пойти чтобы получить или изменить какие-то данные вот сравнивай это дело с магазином очень интересно мы можем сравнить блоки данных с полками в магазине Вот они там стоят а индекс мы можем сравнить вот этими указателями которые под потолком висят там типа хлеб там молоко там мясо там вот использовать приходит покупатель он сначала обращается к индексу каким табличкам говорит Ага мне туда Потом приходит там полка с хлебом и он уже такой целиком оценивает Там просто зарастает А вот мой хлеб и берёт и уходит вот если мы тут я упоминал как бы индекс как такая отдельная штука на самом индекс тоже может быть достаточно большим он как правило меньше чем данные вот но все равно есть он достаточно большой он может помещаться в памяти Ну и вообще мы хотим оперсии поэтому как правило его тоже разбивают на блоке делает там индекс индекса В общем индекс этих блоков данных индекса Вот и как бы повторяет этот процесс рекурсивно мы приходим к такой конструкции как бы дерево то есть дерево это дерево в котором все разбито на блоке в листовых узлах хранятся данные пользователя в промежуточных узлах и в корне происходит там ну некто маршрутизация то есть имея определенный запрос мы от корня понимаем В какой узел А тузла в какой лист и находим свои данные с которыми работаем а как можно рисовать MSC Мне кажется я не сильно совру если существует всего два подхода два пути это либо хранить копию данных либо хранить историю изменений что имею ввиду под сохранением копи данных если мы так изобразим базу данных допустим появляется два пользователя один из которых что-то хочет поменять что мы можем сделать мы можем взять целиком блок данных скопировать для того пользователя которых хочется изменить скопировать и пусть он меняет этот благодарность свой как бы личный вот а тот останется у нас как ни в чем не бывало и другой пользователь должен ссылаться на старый блок данных у него будет как бы старая версия данных как бы получается новое при этом остальные блоки как бы шарятся между ними и в такой ситуации понятно что сам индекс нужно будет поменять потому что у одного пользователя будет ссылаться на один второго на второй это разные вещи поэтому индекс тоже надо скопировать Вот Но если да потом соответственно возникает проблема сбора мусора когда пользователь исчезает Но это небольшая проблема не буду акцентировать внимание если у нас есть индекс достаточно большой его нельзя просто так скопировать Вот одна из не наклеечная мы тоже можем бить на блоке который кстати можно и не сохранять на диске просто для удобства разбивать на блоке но подход тот же блок который мы изменяем мы копируем и изменяем уже с копию своей персональную вот в пределе если у нас есть бы дерево вот мы в общем случае должны нам нужно изменить что-то в листе мы должны скопировать лист чтобы мы ссылались на новый лист мы должны изменить узел Вот соответственно тоже его скопировать и так вплоть до корня Вот то есть копировать нужно будет целый путь так сказать от корня к листу чтобы обеспечить себе такую копию Вот кстати дерево может быть и не только высотой 3 Это так просто нарисовал Вот соответственно сохранение копии данных это подход который очень понятный очень простой он как бы вот практически не требуется пу Вот то есть что-то нужно скопировать блок это вообще нагрузка не на СПУ вот в этом его как бы плюс Ну и минусы соответственно на каждое изменение нам нужно один байт поменять нам приходится скопировать блок понятно что изменения в этом же блоке нам уже второй раз не нужно будет Копировать Вот Но у нас могут быть там изменения там в разных местах база данных и нам придётся скопировать много блоков вот ну и да это что в общем случае приходится целую высоту как бы дерево менять для того чтобы получить такой независимую структуру данных значит вот это вот возможно ошибка недостаточное место при удалении Но на самом деле это вот как и следующее это больше это характерно вообще в целом для инвестиций подхода Но в данном случае может быть как нам нужно удалить что-нибудь Казалось бы место должно освободиться но у старых данных есть пользователь это значит мы должны скопировать блок для этого требуется место может не хватить вот у нас и получается что не получилось ударить потому что нет места и понятно что если транзакция или кто-то там заблокировал какие-то данные мы эти блоки Ну то есть вообще все данные не должны менять должны копировать если база данных живет активно всё изменяется нам приходится копировать вплоть до Ну как бы всей базы данных То есть фактически нам нужно сделать рано или поздно Мы сделаем копию всей базы данных целиком ради одного пользователя но зато эту копию можно будет считать из трудов поскольку она абсолютно не меняется она и не требуется никакой синхронизации только всякие инициализации уничтожения разве что нужно делать из одного треда и Но поскольку место на диске как правило дешево Это не такие большие проблемы следующий подход это сохранение истории изменений тут немножко по-другому то есть вместо того чтобы менять реальные какими данные мы дописываем там туда куда-нибудь дописываем информацию о том как мы изменили или на что изменили или там случае удаления просто говорим там надгробие ставим вот здесь вот мы удалили вот это вот оно тебе как бы не должно быть вот при чтении мы можем эту историю читать и дочитывать до нужного нам места если мы там живем В каком-то прошлом хотим видеть прошлое мы получаем это отсекаем часть изменений Вот для этого история обычного упорядочивается либо по времени либо по какому-то sequence Number у либо редкой потому и другому вот чтобы мы могли понять вот где мы находимся что нам нужно считать что нет в дисковых базах данных поскольку особенности диска таковы что случайное чтение плохо очень важно эту историю хранить рядом чтобы в одном блоке чтобы высчитывать как бы за раз вот фактически получается мы до этого упорядочивали как бы по какому-то алфавиту по главному ключу теперь нам нужно просто в этот ключ добавить еще и вот этот фитнес намбер чтобы разгребать историю вот Ну и понятно что нельзя бесконечно эту историю копить рано или поздно Нужно как-то сжимать условно там идти там говорит что там прошлое история за прошлый месяц нас уже не интересует надо как-то схлопывать там сжать и получить какой-то итог за это время проводя опять же аналогию с магазином можно представить себе такой магазин в котором Вот точно также есть индекс есть какие-то полки блоки Вот и человек нам приходит к полке с хлебом и там видят вот вроде бы 100 батонов но там бумажки такие стикеры квадратные висят там типа тут два батона там забрал Глаша как они забрала тут еще вот один Серёжа и человек понимает что там на самом деле 97 батонов и он как бы забирает один Ну как Просто бумажку оставляйте типа этот бой мой этот батон мой не трогать такой подход очень хорошо сочетается со структурой данных который называется лсм дерево потому что оно само по себе устроено таким образом что хранит историю изменений то есть там Эта история изменений накапливается как-то образует уровни эти уровни как-то там потом где-то в бэкграунде как-то мертжатся схлопывается и получается что вся вот эта вот наша необходимость хранить история историю и вообще необходимость организовать сводится просто к тому что нам нужно как-то объяснить вот этому бэкграунд процессу который там мержет чтобы там не особо прийти вымержил чтобы он не схлопал ту историю которая еще кому-то нужна вот Итого сохранение истории измерения подход который ощутимо Более сложный чем сравнение копии данных вот удорожается чтение поскольку там нужно как-то анализировать историю иногда это достаточно длинные цепочки это долго Вот зато нет ни зато это хуже сочетается с многопоточным доступом но опять же там зависит структуры данных То есть лсм например Вполне себе нормально так работает Ну и характерная ошибка для всего nvc тоже недостаточное место при удалении там тоже присутствует но есть и плюсы это подход В общем скорее сложно говорить Точно Вот но он как правило или даже иногда более экономит для диска Вот то есть может показаться что как бы добавление небольшого информации об изменении это лучше чем копировать большой блок Вот и этот подход идеально подходит для деревьев которые сами по себе очень такая крутая структура данных и они так очень хорошо дополняется собственно поэтому в тарантуле в качестве дискового движка мы используем именно lsm дерево для организации мсиси мы делаем подход сохраняем историю изменений дальше переходим к последней части как может быть устроена vccing ВМР базы данных вот для начала Что такое namera база данных Мне кажется они появились лет 20 назад то есть так в два раза раньше ну как два раза позже чем дисковые Вот это относительно новая штука в общем-то они в основном она следовали и алгоритмы и подходы какие-то там стратегии с дисковые базы данных адаптируя их под память понятно что память работает значительно быстрее там есть всякие указатели которые позволяют там прыгать в разные места почти бесплатно конечно потоковое чтение с памятью тоже быстрее но из случайного доступа тоже можно мириться вот при этом очень память дорогая опять же в сто раз дороже чем диск и пользователь когда он платит за дорогой память он ожидает что у него как бы перформанс будет соответствующий поэтому возникают также более высокие требования к алгоритму То есть то что для дисковых базовых данных прокатывало как бы можно там как-то развлекаться Ну и притом тоже очень важная штука надежность никто не отменял То есть если мы называемся базой данных то мы должны все данные все равно так или иначе оставлять на диске то есть одной памятью обойтись наверное нельзя в качестве примерно как мы адаптировали бы дерево для Memory вообще когда речь придёт база данных там когда нужно сделать индекс что там возьмем наверное дерево поиска и будем использовать выясняется что это не так здорово потому что скажем так на 1 миллиард записи в базе данных каждый байт который мы тратим в памяти это как бы 1 гигабайт за который кому-то нужно платить вот а бинарное дерево поиска как правило это там в районе там 32 байта что типа например на вскидку вот поэтому это большие суммы вот до дерева в этом смысле гораздо более компактно поэтому база данных используют его по крайней мере мы так точно Вот мы используем специальные локаторы как для данных так и для блоков дерева очень хорошо зашла трансляция адресов то есть мы опять же экономим место на списках значит вместо 8 указателя мы используем более короткие айтишники поскольку блоков в дереве не так много мы можем использовать короткое чиселко соответственно есть какой-то транслятор адресов вот еще мы используем модификацию звезда дерево там дефис должен стоять звезда дерева это модификация в котором блоки должны быть заполнены не менее чем 2/3 то есть по сравнению с обычным дерево где не менее чем наполовину почему но опять же потому что не используемое место это место которое фактически за которое заплатили но она не приносит результат соответственно если мы захотим сделать MSC для вас задано в памяти то у нас есть несколько путей мы можем адаптировать как обычно воровать алгоритмы с дисковых баз данных база данных вот объекте там дорабатывает под себя с учетом этих алгоритмов и механизмов которые нам дает оперативная память вот А можем запретить асинхронность Вот что я сразу перейду к третьему моменту к последнему Что такое запретите синхронность вот то что мы говорили то что звучит дико для магазина и в общем-то неприятно для дисковой базы данных это вот не позволить не позволять одновременно необходимость одновременно обработки запросов в базу данной памяти Вполне себе работает то есть поскольку при выполнении какой-то транзакции нам как правило не нужно чего-то ждать должны сделать определенный набор действия там нет каких-то таких долгах операций в течение которых мы могли бы чем-то заняться ещё фактически мы можем выполнять не как бы Атаман а просто выполнять атамарно сначала транзакцию потом другую третью и так далее таким образом они друг друга менять мешать не будут по определению Вот это накладывает определённое ограничение то есть мы например там много чего не можем этих транзакциях делать Вот И там возникают проблемы уже на комете то есть рано или поздно транзакцию Нужно записать на диск А это долгий процесс Это значит что в этот момент начинают другие транзакции что-то делать а на диск можно там не удастся записаться там место кончилось транзакция нужно откатить её могли кто-то видеть это как бы не очень хорошо вот и это на самом деле всё-таки не mcc то есть это просто такой подход способ реализации менеджера транзакций вроде как вот этот подход используется в тарантуре по умолчанию если не включать mcci движок Вот так все работает и это реально круто то есть получается все очень быстро очень компактно очень просто очень эффективно но это не миссиси вот если же мы хотим сделать честный mcc то мы начинаем воровать алгоритмы с баз данных например что касается сохранения копии данных что мы можем сделать Мы же фактически тоже получается используем дерево для наших вычислений для индекса но она нас как я там рассказывала Но если слегка адаптирована в частности оно уже использует трансляцию адресов то есть блоки именуются Ну то есть идентифицируются некоторые мадишником вот так вот когда мы когда мы делаем вот этот вот сохранение копи данных То есть когда мы реализуем в сессии при помощи сохранения кофе данных вот мы можем не менять весь всю высоту дерева чтобы там всё изменить достаточно изменить только листовой блок Ну как обычно скопировать изменить положить рядом но оставить её под те же самые айтишникам просто сообщить транслятору что для данного конкретного пользователя этот номер блока Это нечто другое это другой лист вот фактически мы сделали специальный локатор забавным названием матрас и если фактически он подходит для любых структур данных если его правильно использовать то можно в любой структуре данных сделать MSC мы так делаем для дерева мы так Делаем дальше таблицы вот подробно вот пожалуйста ссылка можно посмотреть Вот то есть Таким образом мы сделаем сделаем mvc для индексов Вот Но поскольку я опять же говорил мы Ну то есть когда мы адаптировали дерево для движка Получается что все данные не только поэтому по нескольким причинам данные лежат отдельно то есть в дисковых базах данных мы можем в листах бы дерево хранить сами данные то тут нам нужно хранить указатели ссылки на данные которые уже в другом месте лежат и они уже не работают то есть вот этот наш подход для индекса для данных уже не работает мы там делаем другой подход другой механизм именно для данных мы снабжаем там каждый запись данных айтишником это грубо говоря примерно так Эпоха создание этого области данных этой записи Вот и вообще диаграмме пытался это изобразить у каждого записи базе данных есть какое-то время создания время удаления жизни вот а какой-то читатель какой-то на версии это такая вертикальная черта на этом графике вот он хочет видеть вот такой вот срез базы данных Понятное дело что то что было удалено до его не волнует то что было создано позже тоже не волнует а вот именно то что было создано до на удалено позже ему нам нужно как-то обеспечить этому читателю видеть вот эти вот данные которые были фактически удалены понятно что эта история может быть гораздо более сложная читатели бы может быть много линия жизни некоторых записей может пересекать несколько линий читателей Вот Но тут в общем-то алгоритм напрашивается достаточно простой который мы используем Вот это при удалении объекта на самом деле не удалять отдавать владение читателю если их несколько то само мы не позднему из них для определённости вот мы засовываем как бы в список этого читателя Вот это теперь твой объект самоудаление соответственно когда читатель совершается Когда уничтожается нужно с этими списками записи разобраться некоторые удалить сразу если они влияют только на этого читателя А некоторые Там те которые с длинной вот этой длинной линии жизни нужно пересунуть как бы в соседнее review Вот это звучит как сложно на самом-то деле мы там делаем в каждом review делаем много списков то есть есть Список объектов которые принадлежит только этому Список объектов которые этому предыдущему там этому предыдущему и предыдущему и так далее вот поэтому мы быстро кладем список а при уничтожении быстро весь список перекладываем завод единицы в соседнее Вот либо удаляем если это в зависимости от Вот это в этот подход мы используем для определенных значит вещей я чуть позже покажу основные принципы повторяются повторяюсь тут значит при удалении объект может быть отдан во владение в review review много списков для оптимизации при уничтожения ревью мы как-то эти списки обрабатываем что-то перекладываем что-то уничтожаем сразу списки у нас инклюзивные то есть в первые 8 байт записи используется как указатель на следующую туда попадает вот эти 32 бита версия которая уже к этому моменту не нужна еще там порой очень не очень нужны полей как бы нас так перезатирается Вот и таким образом в общем то все ограничено все алгоритмы ограничены вот этим количеством review вот которые Это количество небольшое можем сказать Константа поэтому у нас константная сложность вот используется эта штука для на самом деле разных вещей то есть она используется для например того чтобы сбросить все данные на диск на определённый момент времени мы создаём readview и соответственно там копируем всё на диск вот или там приняли социализации реплики точно так же водоём ей определённый слепок данных ну и мы выберем это дело пользователю вот я очень хотел похвастаться именно этим и соответственно как это происходит то есть у нас там есть Space это типа таблицы в нем есть какие-то данные мы создаем review вот из этого review что-то там удаляем добавляем под конец у нас в базе данных другие данные о вреде остается те же то есть эта штука используется для Вот таких для пользователей работы пользователя соответственно этот подход именно сохранение копий мы делаем Значит мы используем разные подходы для индексов для данных там все очень хорошо Как по памяти по алгоритмов и review мы можем ради чего это делается мы можем делать работать с ним из средов без синхронизации Вот и соответственно этот подход работает только для второй подход сохранение истории изменений Мы также используем для в общем-то для менеджера транзакций вот Понятно Мы тоже адаптируем этот подход из диска но мы можем хранить историю как бы не вместе Вот и очень хотелось это сделать как-то органично чтобы не заставлять пользователя платить там за то что не использует чтобы там было достаточно Все просто и для разных работала для разных типов индексов и делаем мы примерно следующее То есть как у нас есть индекс который ссылается указателем на какие-то данные при изменении этих данных мы заменяем данные как будто бы никакой ncci нет но мы эти данные помещаем одним битом один бит нам пришлось потратить который означает что этот эти данные этот это запись имеет некоторую историю которую уже отдельно там по специальной Хеш таблички можно быстро получить там в другом месте там уже будет объект истории который уже как-то связаны с песком хранится очень много всякой ценной информации Вот и потом сейчас в частности вот по вот этим вот объектикам справа уже можно ходить как бы копаться в этой истории получают собственно mcc при помощи истории Вот соответственно получается достаточно дешево там тратится всего один бит история Ну история там реально очень сложная там очень много сохраняется там есть там сохранение например чтений неподалеку вот нужно там для того чтобы избежать фантомных чтений вот и получается что если данные чистые то мы читаем очень быстро и как бы как будто никакой нет А если они грязные то мы их тоже достаточно быстро читаем разгребая история вот очень важный момент К сожалению очень мало времени осталось даже совсем это на самом деле самый по-моему важный слайд который у меня есть это то что Тарантул использует уровень изоляции сиролайза был но на самом-то деле это не снапшот изоляция и nvc у него с плавающим review то есть мы гарантируем что транзакция получает review который актуален на какой-то момент времени но не говорим с самого начала на какой то есть фактически можно представить себе там человек вышел за молоком начал что-то выбирать вот кто-то Прибежал там быстренько взял там батон хлеба утащил и убежал как бы и получил чек вот и когда эта транзакция доходит В итоге до полки с хлебом мы говорим так ведь на самом-то деле она же как бы может быть после вот той которую там хлеб трогала он уже до этого на хлеб не смотрел никаких противоречий он будет позже делаем Это по-разным причинам потому что Чем старше Вот это review для MMC для для менеджера транзакций тем больше во-первых оно стоит а во-вторых тем больше вероятность конфликта то есть конфликт транзакций возникает из-за того что вот это вот nvc версия пользователя уже сильно отличается от настоящего она не сходится уже вот еще у нас есть там теперь возможность создавать вот этой redview из неподтвержденных данных Вот на это лучше уже на отдельном стайде Как видите не успеваю Вот вы того этот подход сохраним история изменения мы используем в качестве основного движка для транзакций мы получаем уровень изоляции был вот мы в общем-то там по алгоритмам более-менее нормально но смысле там все Примерно вот единицы или От количества изменений мы говорим что это немного вот на по ссылке можно посмотреть подробно на статью про это дело Вот такие дела вот еще по рассылок это собственно репа Тарантула это документашка всем спасибо оставляйте отзывы 35 минут Александр Спасибо отличный доклад вчера коллега Владимир Перепелица сделал такой водный обзор А сегодня нырнули чуть глубже и отлично друг друга по моему Дополните два доклада а ну что пора переходить к вопросам как обычно вопросы Из зала и из онлайна Катя рули процессом давайте начнем с зала вот слева вопрос молодого человека Остальные поднимайте руки к вам подойдут помощники в красной футболках Привет Спасибо за доклад по моему вопрос блокировок как-то остался немножко не раскрыт потому что для проверки конфликтов они видимо должны быть и как-то осталось за кадром и с этим я про сериал тоже не до конца понял Потому что если нету никакого а там по началу транзакции которые как бы с тобой до конца непонятно как проверять что никто не записал то что прочитал Например если вы хотите честные сериалы Да к сожалению но просто не влезала в доклад я поставлю всем поговорил бы на эту тему еще пару часиков Но вот тайма таймин такой вот я там По ссылкам что-то можно найти в том числе и про Ну то есть я обычно как разделяю меньше транзакций на две части это тот который обеспечивает некоторую историю то есть что-то типа nvc и менеджер конфликтов Вот мне кажется что менеджер конфликтов у база данных с блокировками и с вот этим CC она не не должно сильно различаться поскольку ну нужно трека чтение и нужно трекать запись искать собственно их пересечений вот собственно это вот работа меньше транзакции ну там плюс-минус ещё всякие там диапазоны там всякие детали Понятно дьявол в них Вот но я в этом докладе действительно за скобками говорю можно пойти По ссылкам вот в двух словах сказал что мог если у нас еще вопросы не вижу рук можем раскрыть тему которую Павел поднял и да если нет у нас в онлайне может быть чего-то Илья не онлайн Пока молчит Здравствуйте Это трубку тянуло вопрос не видно тебя ничего страшного вопрос по поводу последнего момента когда происходит обновление вы храните вы храните бит про то что она изменилась А как он ну как потом происходит удаление когда все транзакции завершились сейчас там рисовано реализовано через больших мусора То есть все вот эти истории все вот эти вот ну там в любом случае если есть грязные данные то существуют вот этот специальный объект истории который отвечает именно за эту как бы изменение они уже прошиты там всякими разными списками один из которых собственно это вот список для вот кандидатов на удаление граунде какой-то проходит процесс и когда видишь что вот этот объект уже точно никому не нужен он значит схлопывает вплоть до того что даже в общем-то Может там из индекса то есть понятно что если данные как Вы удалили целиком они продолжают висеть в индексе как нечто хранители истории потом рано или поздно они Прямо даже из индекса могут удалить 101 Original потом появляются какие-то добродельные транзакции что-то изменяем вы это храните эту историю вечно или ну оно имеет смысл уже например на стартовал это какая-то транзакция она увидела Вот это Original Data в это время работает ещё допустим пять транзакций которые её изменили а потом они все закрылись допустим никто туда не трогает то в этой истории тоже смысла нет может быть есть А может и нет это достаточно сложно вопрос то есть теоретически в этот момент мог быть какой-то там review там транзакция который вот читать это она не должна видеть не туда она должна видеть ориджинал дата Вот это в общем-то Тоже легко отличить главное что единый момент это как бы не всегда получается тоже хотим так сделать но фактически ещё раз то есть для каждой вот этого компонента истории мы можем увеличить Я говорю ещё раз то есть у нас есть бэкграунд сборщик мусора то есть некоторые процесс который подходит по очереди говорит так вот это возможно Вроде нет И вот тогда в топку и удаляет и она исчезает вместе собственно с самими данными они оба как бы схлопываются и остается Только остается которая рано или поздно помещается как чистое не имеющая истории нужно как бы если история как бы состоит из ничего интересного то мы говорим что это просто чистые данные все они очищаются постепенно спасибо Вот но сразу скажу на самом деле это как бы решение Мне она не нравится то есть наверное не самая лучшая часть этого движка Возможно когда ты переделаем но тем не менее мы так сделали нет тут как бы я не виноват спасибо спасибо за вопрос вижу вопрос вроде бы даст слева сзади Если я правильно понимаю Здравствуйте спасибо за доклад А если я правильно понял то история хранится в лсм дереве Только я не понял Это я сам дерево оно целиком в памяти работает или на диске сам вроде как обычно используют чтобы на диске хранить оптимизирована Значит мы используем лсм дерево в специальном нашем Чтобы понимать то у нас есть дисковый движок вот он использует лсм дерево вот на самом деле выстроена таким образом что самый верхний его уровень вот самый маленький и самый такой незначительный он лежит как бы в памяти все остальное сбрасывается на диск и Поэтому собственно там это мои движку и менеджером транзакция всем нужно иметь ввиду что бывает данные которые лежат на диске бывает которые ещё в памяти Они через некоторое время окажутся на диске но некоторое время они существуют именно как вот такой вот но главное что он в этот момент уже там ну очень быстро становится тоже недвижимом то есть его никто не меняет то есть весь смысл вот этого см дерева в том что накапливает данные и сбрасывает их на диском а потом Спасибо за вопрос есть ли еще вопросы в зале Давайте вот сюда передадим микрофончик я Напоминаю что мы еще подарочки дарим Так что не стесняемся у нас есть время поговорить Спасибо большое совсем короткий вопрос Вот mvc это одно он относится к классу пессимистик или оптимистик конкоранцы Control не знаю что ответить мне кажется там все семья Вполне себе оптимистично Наверное это я вот без понял спасибо Так не смогу Если были детали какие-нибудь я обрисовал Спасибо решился ли кто-нибудь еще задать вопрос А да пожалуйста Илья чек не нет ли чего-то еще раз в онлайне нету да послушаем из зала Да спасибо Добрый день спасибо за доклад Насколько я понял вот в истории хранятся именно копии блоков данных Z Ну то есть Дельта не рассматривали хранить с дырками это как не с дырками Какие изменения нужно сделать в оригинальном блоке чтобы получить Ну как в некоторых потому что там даже слоновья база рассматривает это как Почему изменения почему-то исторически у нас так не получилось то есть у нас ну то есть вот этот подход к тому что мы даже там Элементарные изменения Ну то есть там например там пользователь хочет там там нас есть там база данных там есть колонка Я человек хочет пользу одно поле увеличить на единичку Мы в этот момент этот все это запись целиком как бы копируем и это самое это самое в ней уже как бы оставляем измененные точки это делается по нескольким причинам то есть во-первых потому что очень часто такое такие Элементарные изменения нельзя применить обратно А это приходится делать когда нужно откатить транзакцию потому что там что-то случилось плохое там не удалось записать на диск нам нужно откатить вот во-вторых там наверное в каких-то в каких-то местах это можно было бы сделать вот там возникнет какая-то более сложная архитектура каких-нибудь ссылок Потому что сейчас данные у нас доступны как бы из seapi и с вашего питом это как-то все живет под капотом каким-то в одном вареве поэтому там существует какие-то счётчики ссылок в этих данных Вот и Наверное если бы это была какая-то более сложная структура это было бы сложнее Наверное это было бы можно но в общем там самом деле наверное можно было но как-то вот мы пошли заводишь уже в трекере как будто бы эта задача сейчас трекеры уже заводишь на самом деле вопрос стоял можно пытаюсь подумать в будущем Я думаю что это стоит иметь ввиду Но почему-то если я уверен что если подумаю полчасика наверное наверное обрисую насколько это будет сложно делать и вряд ли Спасибо класс еще кто-нибудь и у нас подоспели вопросы а так значит Кирилл иванкин спрашивает Есть ли какое-то время после которого слепок считается устаревшим даже если данные не затронуты никем другим так сейчас попробую осознать слепок устаревшим даже если данные не затронуты другим значит единственное место в котором мы считаем что становится устаревшим это мы ограничиваем просто физически то есть понятно что вот этот миссиси в любом случае это расходный как бы для памяти механизм когда базу данных памяти Это очень важный ресурс вот поэтому у нас есть жесткая ручка ограничения времени жизни транзакций после которого мы его как бы уничтожаем это касается менеджера транзакций вот а вот этим механизмом который работает на сохранение копии данных для доступа из разных трудов мы там тоже наверное не сможем сделать обратно То есть он доступен и он валиден пока ты сам не грохнешь потому что вплоть до того что он же доступен из других трудов без синхронизации как мы там будем идентифицировать о том что он как бы протух Нет он остается как бы пока его пользователь сам не грохнет Вот надеюсь что я ответил на этот вопрос хорошо и есть еще один вопрос я все ждал Но кто когда кто-нибудь спросит что-нибудь про магазин и так значит зачитываю все-таки про блокировки кассир работает тоже без блокировок вот Не совсем понятно что спрашивают интересно вопрос кассир работает действительно без блокировок в этой конструкции он является таким товарищам которые имеют он должен быть один он должен работать последовательно и он должен работать последовательно с каждым покупателем Вот то есть он фактически вот это вот стерилизатор То есть он говорит что он работает сначала одним потом с другим и с третьим и каким-то образом каждый раз валидирует это дело то есть он является вот этим вот схлопыванием все в последовательность то есть внеси это такой подход в котором все работает параллельно но потом как бы оказывается как будто бы последовательно поэтому кассир работает вот таким вот последовательным образом вот и он там не могут быть блокировки потому что он один он работает один поэтому Ну как бы да фактически он можно сказать что он блокирует всю базу данных целиком Вот такая блокировка самая серьезная но он работает Быстро особенно базы данных мы можем все это позволить Это не проблема как в реальной жизни есть ли еще вопросы и зала ребят У нас есть время пожалуйста на первом ряду помоги Ага давайте начнем с конца и сюда пожалуйста микрофончик На первый ряд Принесите Спасибо Вы только что упомянули что review может быть уничтожена только пользователем который начал процесс но ведь тогда мы можем как бы если у нас очень долго транзакция несколько суток мы просто все ресурсы сожрем и все да все верно рано или поздно пользователю уже наверное другого начнутся с ошибками что памяти как бы не хватает Это не единственное завершить эту транзакцию которая зависла принудительно потому что ресурсы заканчиваются мы не можем Ну как бы да это не совсем хорошо Ну наверное так тоже опять же можно сделать но на самом деле как бы сам за себя может сделать Зачем запрещать пользователю выстроить в ногу если у него такая Увлекательная жизнь Вот то есть мне кажется что в база с памятью Ну как бы память заканчивается это не единственная причина по которой заканчивается память иногда память просто заканчивается и пользователю тоже к этому надо Быть готовым Вот то есть там есть какие-то мониторинги там какие-то наверное админы сидят смотрят на графике что там приближается кверху в этот момент Они там приходят там начинают трубить тревогу какую-то увеличивать квоту памяти в общем Ну это такой стандартный процессор в процесс с памяти приходится как-то с этим всё равно считаться Вот и review это такой всего лишь один один пользователь этого всего Ну да потенциальный можно удвоить количество памяти спасибо спасибо за вопрос Давайте крайние вопросы будем выбирать лучший пожалуйста у меня вот такой вопрос вот здесь рассказывалось по сути про модификации Да а вот что будет со вставкой например процесс чтения считает Ну сколько там подходит под какой-то критерий Да и потом он делает запись только если это количество подходит и второй точно также Да процесс то же самое делает очевидно что они оба прочитают какое-то количество у них все подходит но оказывается одному из них нельзя вставлять вообще вот как тут ну в этой ситуации вот этот менеджер конфликтов он же кассир вот он должен понять что вот эти транзакции пересекались друг другом по чтению Вот и по записи Вот наверное наверное там нас как-то можно подловить Но вообще раньше никому не удавалось вот так вот Я просто за минуту просто уже не успеваю но вроде как Смысл в том что достаточно хорошо обученный Вооруженные менеджер конфликтов должен разруливать эти моменты То есть получается Он должен будет часть бизнес-логики проверить дополнительный нет утверждается что не может быть такой бизнес логики которая не сможет полагаться на вот какой-то ну то есть смотрите если получается нечто завязывается на какое-то например значение а и мы говорим что это типа значение изменяется правильно если она не изменяется то Нет конфликта А если оно изменяется то происходит вот этот ридрайт конфликт который меньше транзакций отличает Но вот в этом и вопрос то есть если есть какие-то данные но они не предполагают их само изменение Да но предполагают новую ставку данных на основе тех и то есть получится что возможно две ну две ставки на основе тех данных а если бизнес объект предполагает отсутствие данных то он должен прочитать эти этот как бы этот ключ Ну то есть что-нибудь прочитать убедиться что как бы их нету правильно дополнительно получается А ну Каждый каждый процесс Каждый акктор должен это делать и меньше транзакция это фиксирует он учитывает что было чтение и это чтение привело к пустому результату вот мы это храним очень хитром месте Ну то есть там в зависимости по-разному в номере в другом с другим способом но мы сохраним информацию о чтении вот этого пустого множества Мы храним в соседнем в соседней записи Они же там упорядочены лежат рядом и мы там приписываем что вот тут приходил то-то смотрел Ничего не было Вот если кто-то туда вставляет фактически это сразу же приводит к потенциальному конфликту вот мы видим это пересечение мы сразу видим что из этих двух транзакций одна из них уже как бы не выживет Спасибо Давай стал самое сложное это даже не выступить выбрать лучший вопрос я вижу что есть отлично тема остальные можно будет раскрыть в зоне со спикером рядышком залом напомню для тебе что было или осталось в оперативной еще 10 минут Для этого мне больше всего понравился первый вопрос и последний то есть первое про собственно блокировки и вообще в механизм который наверное всё-таки Спасибо обоим наверно последний вопрос про фантомных фантомное чтение вот собственно фантомные проблемы Спасибо вот да наверное это вот это было лучше самый самый интересный такой хороший вопрос и Александр Спасибо большое за доклад от программного Комитета и от Яндекса как организатора трека дарим тебе тоже небольшой Презент спасибо ждём новостей"
}