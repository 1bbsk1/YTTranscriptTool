{
  "video_id": "4kEktgEQi8c",
  "channel": "HighLoadChannel",
  "title": "Как (не) выстрелить себе в ногу на Lua / Ярослав Дынников (Tarantool)",
  "views": 4480,
  "duration": 1724,
  "published": "2021-10-04T02:47:27-07:00",
  "text": "всем привет да я работаю в тарантула и у нас слой это основной язык расширение на котором можно писать скрипты мы на немного пишем поэтому я сегодня хочу поделиться ошибками некоторые очевидные некоторые очевидными становятся только после того как их совершишь но начну издалека вдруг нам кто-то первый раз зашел the law жизни не видим очень простой язык он мне за это нравится почему он простые что в нем такого полезного он очень краткий но при том же очень емкий его легко интерпретировать в голове он относится к языкам динамической типизацией и это хорошо это упрощает жизнь и очень ускоряет разработку кто пробовал на плюсах распарсить жетончик тут примерно понимает о чем я говорю и чтобы далеко не ходить приведу недавний пример пару недель назад нам нужно было улучшить логирование вообще я занимаюсь разработкой в тарантула картриджи это фреймворк который позволяет строить plaster а и для диагностики инцидентов у нас было плохое местечко которая вообще никак не было покрытыми лагами коллега написал такой кусок кода который перебирает все события которые там недавно и произошли и все их распечатывают вот еще функция диск райп оно обогащает скучные и виды полезной информации типа url алис ну что то чтобы проще было логе читать я посмотрел на этот код и решил что мы можем еще немножко это его улучшить если про сервером и url дописали та реплика сет остается скучным видом и я дописала такие маленькие три строчки и угадайте что все сломалось потому что вот в этом месте индексирование по таблице стала всегда показывать нил когда у нас сошлись звезды мы попали на свой реплика set это я все к чему конечно в моем случае не надо было экономить на переменах писать по человечески пусть и чуть чуть больше строк но зато понятно и если даже несмотря на то что у нас простой язык динамическая типизации это не совершенно не означает что мы можем завести три переменные abcd гонять их типы по кругу и это я ещё тип переменной не поменял а представьте что было бы если там вместо строки начал фигурировать young ну и так далее второй аспект типизации это языки бывают сильный степи зация бывают со слабой и слабой типизации отнести лу у меня язык не поворачивается потому что все таки не смотря не на что там нельзя творить такую дичь как можно творить в питоне в железе особо показательный пример и лоу нам не позволяет смешивать типы в выражениях но сильно тоже не относится потому что есть два исключения лу по стандарту разрешает в математических выражениях использовать строки и использовать числа при операциях со строками это прям допустимо но мне это не нравится я считаю что аргументы все-таки надо проверять чтобы было проще интерпритировать код в голове чтобы проще было его читать и анализировать разберем вот такой пример у нас есть функция которая просто я там проектирует запросик и все работает хорошо до поры до времени пока туда не попадает какой-то аргумент внезапно оказывается нилам мне в этом случае не нравятся ошибка да здесь есть имя файла номер строки какие-то непонятные слова непонятные внешнему пользователю про то что мы пытались конкатенировать мил ну это плохо в лоу в таких случаях принято все-таки чуть-чуть защищаться a sure to me с таким acer там и ошибка уже становится чуть лучше нам явно язык подсказывает что url должен быть строкой но все равно не идеально есть ряд ошибок которые мы все еще поймать не можем пример следующий очередной запрос прилетает с аргументом тайм-аут в котором кто-то допустил опечатку а сердце не ругаются ошибок никаких нету ну и поведение кода не соответствуют тому что мы ожидали возможно там кто-то во дефолтный тайм-аут бесконечность заложил ну в общем потенциальная проблема если мы попробуем такого характера ошибки ловить в а сердцах то у нас очень быстро код превратиться в простыню из этих а cert of и на саму бизнес-логику места не останется она потонет поэтому мы у себя написали маленькую библиотечку checks которая все это делает просто компактней и раз уж об этом зашла речь то не могу не упомянуть что в мире существуют такие инструменты как линкоры и в принципе правильно настроенные даёшь к уже ловят половину проблем еще не доходя до авто тестов автотесты же все пишут я надеюсь до с библиотекой checks библиотека текстом говорит генерируют ошибки уже еще и еще лучше в данном случае она скажет явно что плохой аргумент номер один что же до лечо получили либо плохой аргумент тайм-аут ну здесь уже выцепить ошибку глазами будет куда проще чем просто искать почему нас запросы повисли еще один повод почему лу такой простой это его система типов она примитивная вот здесь перечислено абсолютно все что в есть серым я выделил сидят у это не совсем лу это тип который дарят нам logic он позволяет маппить session и и типы влажное пространство и там пользоваться ну а в голову типизация максимально простая есть всего один числовой тип и по дефолту это дабл да конечно мы можем скомпилировать лотом с другими флагами и использовать флота леланд w или даже целочисленное что-нибудь но мне проще предполагать что это просто дабл это избавляет меня как разработчика от головной боли не приходится задумываться что там происходит с неявными type кастами silence ain't переполнение сайты турбину и так далее но все прелести doblo они конечно на месте все же сдают шутку что когда мы работаем с баблом 0 1 + 0 2 0 3 не равно шутка известная поэтому в принципе на нее вроде никто не наступал а вот с переполнением на больших числах люди иногда приходят в чатике потому что он добыл может хранить целочисленные только до 250 3 нас низшие юле 64 как можно было бы там привыкнуть всего лишь до в 53 после этого наступает гранулярный с точностью до двойки какие проблемы возникают например у нас tarantul и есть такая фишка как там 64 возвращает наносекунды с начала эпохи сейчас эти числа примерно 2 в 60-е то есть за два 53 недавно перевалили пользователя берут это число использует его в качестве таймс темпов кладут базу и какое-то время не знают бед но потом в результате неаккуратного обновления или чего-то такого случая эта ситуация когда у нас есть в базе запись мы видим в ней таймс темп у нас есть х ттп запрос мы видим в нем таймс темп эти числа абсолютно равны но backend говорит что такой записи просто нет потому что где-то в середине произошло неаккуратно и округление и мы уже запрашиваем не то что пользователь ожидает получить механик этого всего в принципе понятно у нас есть мантисса у нас есть экспоненты есть одна математическая формула и есть да бля еще одна интересная особенность специальное значение экспоненты из всех единичек оно означает если мантисса при этом нолик то это два специальных значения плюс минус бесконечность настоящая математическая бесконечность а если хотя бы один бит не 0 то это волшебное число nan nan это буквально не число нам обладая тем интересным свойством что оно не равно абсолютно ничему даже самому себе получается она из математических операций с не определенным результатом как-то корень из минус единички взять 0 на 0 поделить если 1 на 0 то там еще бесконечность 0 на 0 это уже не число и сравнивать ее ничем нельзя понятное дело любые математические операции с на нами также дают нам но из этого правила тоже есть исключение потому что единица в степени нан и нам в нулевой степени равны единице это полностью противоречит здравому смыслу но так написано в мануале какой из этого можно сделать вывод на самом деле не тот который вы можете предполагать просто не пользуйтесь на нам не допускайте его в лол это не тот язык в котором надо настолько опускаться лучше в бизнес логики обойтись без знаков а вот фишки на здоровья и в лоджике есть интересное использование на nov я хочу с ними с вами им поделиться вопрос идет о том как лоджик хранит у себя в patro хах типы на самом деле лоджик использует восемь байт для хранения вообще любого значения будь то нил boolean будет звездочка на строку ну или сами нам числа даблы чтобы все это у пихать восемь байт лоджик говорит что а у нас в ногах первые by текке все должны быть единичками поэтому он в качестве типа 0 используют все единички фол соответственно тильда один это все единички без 1 ну и так далее у нас получается 8 байт который с точки зрения дабл интернете интерпретируется как нами а с точки зрения low jetta мы спокойно можем хранить там свои воин звездочки 32-битный и с пространством обычных чисел не пересекаться отсюда же собственно вытекает интересное ограничение лоджик про то что лучше те можно пользоваться всего двумя гигабайтами оперативки это как раз два в 31 адресация есть манипуляции которые позволяют использовать все 32 бита и есть новый лоджик режим га c64 который позволяет сорок семь бит откусить вот от этого на на а все остальное уже используют подтипы но вернемся к простоте и поговорим про следующий тип это таблицы таблицы это вообще единственный композитный тепло которые используются абсолютно для всего таблицами можно пользоваться как обычными массивами можно пользоваться как лапами можно изобретать что-нибудь свое типа ordered map и ну а куда деваться другого композитного типа у нас в принципе нету в коде лу jetta таблица выглядит не очень хитро здесь есть массив и его длина есть вторая половина в которой лежит как раз ключи значениях и шмапы для наглядности покажу вот берем пустую таблицу лезем в потрахал его jetta смотрим что же там лежит адрес понятно первая часть массивом 0 элементов во втором флешмоб один элемент ключик нил значения нил все логично пробуем положить туда какие-нибудь значения a b c видим что они кладутся в части с хаш папой и уже здесь можно догадаться что вот это внутреннее представление она не всегда одинаковы и для двух таблиц которые с точки зрения лу выглядят одинаково внутри могут отличаться но мне как программист аналу это и неважно мне важно чтобы мой кот работал правильно и я не хочу делать никаких предположений демонстрация следующее я немножко изменяю синтаксис инициализации таблицы вижу различные внутреннее содержимое и если я пробегусь по этим двум таблицам pairs of the pairs мне распечатает ключи в разном порядке завязываем узелок прирост порядок не гарантирует едем дальше если я при этом удалю какой-то элемент из таблицы сюрприз в patro хохлу джотто он остается лежать сам ключ остается лежать на месте нужно это для того чтобы не ломать поиск по таблице поиск по таблице нам нужен ради того чтобы можно было во время интернирования модифицировать удалять элементы это то что разрешает нам делать стандарту а вот удалять и изменять можно а добавлять новые нельзя потому что если мы добавим ключик и для него не найдется в шляпе место но вот этот кусок памяти перри аллоцировать все там перехешировать и порядок поедет этом диффенбахии виа ладно со строковыми ключами спросу нет перейдем к тому что мы называем массивами на самом деле это конечно сленг и правильнее говорить про таблицы а вообще стандарт лу вводят такое определение как sequence секунд это таблица определенного вида у которой пространство целочисленных ключей непрерывно от единички до некоторого н это м называется его длиной до этого мы сейчас дойдём а пока что в чем особенность что даже для seconds of для же для обычных массивов внутреннее представление может отличаться здесь тоже используется хитроумный синтаксис и один элемент попадает в часть с массивом а второй ложится в хэш maple если еще чуть-чуть по по шамане синтаксисом то мы можем получить таблицу на которой даже iterator pays печатает нам элементы 1 2 3 4 7 856 поэтому prs порядок не гарантирует даже если эта таблица хотя бороной лучше конечно выключить вот порядок итерации еще ни разу на моей памяти к проблемам не приводил а вот длина таблица которой я уже упомянул очень даже часто подстреливает и так лу вводит определение sequence а не любая таблица является sequence и мы не у той любой таблице есть длина сюрприз зло в стандарте есть он define беседе с ним придётся жить у таблиц с пропусками с дырками такого свойства просто нету свойства нет а оператор все еще есть и в зависимости от ситуации он нам может выдавать разные результаты эти разные результаты нам могут нас могут за ноги кусать вот тот же самый пример с двумя синтаксис изменил 2 которая говорит что длина двоечка и если мы через киева илью синтаксис присвоен в чем здесь отличия лоджик когда еще длину он пытается найти так называемую границу это такой элемент левее которого значения есть а правее нету если у нас массив с дыркой то таких значений может быть несколько а значит лоджик вправе найти любой из них и будет фактически прав но он прав а нам что делать нам не допускать таких ситуаций надо постараться откуда они вообще берутся ну во-первых классически кто-то забывает про существование такого оператора коктейль был remove который все сдвигает и пользуется панельным присвоением такой код я тоже видел данил можно присваивать но делать это надо созданным короче там где у вас целочисленные ключи ими кати бездумно включайте голову проверяете нет ли там потом каких-нибудь проблем второй способ это завернуть переменное количество аргументов или результатов функции в табличку с таким примером функций в арк который оборачивает примерное количество аргументов таблицу если его вызвать нил с аргументами не layer of the fare ирги окажется таблица с дыркой в зависимости от того как мы потом с ней работаем это может быть on диффенбахию и могут быть сюрпризы сюрпризом относится например функция тейбл сорт которая всегда работает в диапазоне от единички до вот этого самого оператора решетка который по определению выводится соответственно если оператор решетка вдруг вы числился не так как вы ожидали то половину таблицу вас не отсортировано и из предыдущего примера после того как мы табличку завернули мои и чаще всего разворачиваем on паком он по дефолту тоже разворачивает аргументы от единицы до решеточки если нам не повезло хвост может отвалиться а может и отвалится от все-таки б чтобы хвост не отваливался one пока все таки есть способ явно указать что мы хотим какие аргумента распаковывать поэтому logic в лоб а мой муж 52 есть встроенная функция от эйбл пока а мы можем ее имитировать буквально одной строкой с таким кодом уже становится жить полегче явное лучше неявного итерации которые делаются по решеточки ты они достаточно очевидны в глаза бросаются а вот оператора и был сон не нравится на самом деле у него нет в принципе не определенного поведения он всегда работает детерминировано даже на массивах с дырками литератора и был эквивалентен следующему файлу он идет ровно до тех пор пока не встретит нил неважно как там вычислялось длина не важна какое-то внутреннее представление вот просто как только не встретили все конец но что делать с этими массивами с дырками в принципе потому что есть монолога ситуации когда они нам в принципе нужны ну например таблы в tarantul и у нас в данных и могут быть пропуске могут быть ну лабильные колонки и так далее нам их надо как-то хранить вот здесь используется такой интересный вариант type от значений не равен нил почему не просто почему само значение не сравнить snell потому что в tarantul и мы для заполнения дырок частенько используем такой волшебный объект из это та самая cidade а вот звездочка null pointer он обладает странным свойством он равен нилу что в принципе как бы делает логичным его использование для заполнения дырок и в то же время с точки зрения лоу дырка не является и никакому on диффенбахии веру не приводит тем не менее это знаменитая грабля в таранто ли под названием бокс null стреляет она когда мы пытаемся сделать какую-то проверку с помощью ифа так вот так как это сидят а то по определению в ла она расценивается ифом как положительное условия поэтому поэтому с одной стороны оно равно нил а с другой стороны if not не проходит так что решение для этой проблемы до сих пор неизвестны не изобретено мы продолжаем страдать и писать везде равно равно нил чтобы хоть чуть-чуть было однообразно я готов перейти к выводам такие здесь можно сделать выводы но во первых старайтесь писать код без багов как бы это смешно не звучало и не пишете код бездумно проверяйте аргументы пользуйтесь линкорами настраиваете еда ешки избегайте нам всегда и везде ну если вы конечно не хищный программист не делайте лишних предположений про содержимое таблицы всегда проверяйте оберегайте себя и sure to me и бойтесь древних массивов а у меня на этом все задавайте ваши вопросы задавайте вопросы вот я вижу же микрофон можно передать и также в онлайне тоже ждем вопросов давайте россии выросло я правильно понял то что любой сида то но даст true если этом дачу и вынуть и то есть лучше сида то вообще не используют для каких-либо логических проверок нет ни лучше у них ну ко всему надо подходить с умом то есть здесь частные случаи я могу привести и когда да и когда нет по определению в ла вот под if not подходит только нил и только falls поэтому да вся дата она относится к true но логические выражения но как там сравнение писать я понимаю катя мы сравнению вот как раз таки и if not лучше не запихнуть сюда то это always true окей спасибо большое напоминаю что за вопросы будет вручаться книжка так что запоминаю какие-то вопросы типа нравится здравствуйте меня зовут георгий и у меня вопрос такой в целом вообще по использованию а вот я в своей практике сталкивался вот с применение лу только в геймдеве я сейчас работаю гендо в компании тут бочком совершенно колода ну обычно используется либо как скриптовый язык вот в парочке движков потому что он простой либо вот у нас например лу используется потому что он опять же простой то есть у нас интерфейсы на нем программируется и тех дизайнеры могут что-то там немножко разобраться и самое что нужны для нас так как мы мобилки делаем мы можем с помощью патча без пересборки самого кода высовывала основного быстренько пальчиком что то какие то исправления подгрузить вот как такие есть причины использования лугов highload проектах это живут но все-таки язык интерпретируемый неужели он быстро как это работает во первых причина первая то же самое что он простой и удобный вторая причина ну а нам хватает в хайло де то есть у нас самые критичные места все-таки на осях написаны все что касается бизнес-логики на алла описать как вы сказали да она то есть ядро вас тоже там носил у нас много сей и много на лоу и частенько мы залезаем на лот туда куда по хайло аду за не лизать не надо но это все к вопросам преждевременной оптимизации чаще всего относится спока хватает жить можно понял спасибо спасибо большое за доклад у меня такой вопрос про timestream стана секундами до которая не влезает в дабл-д выговорю тоже при каких-то определенных операциях он густой можно у вас попросить маску снять возможно то нормально да то есть если мы говорим про timestream сна на секундами и выговори тоже при определенных операциях может отрезать просто от него кусочек да и будет неправильно это отчисления у меня такой вопрос такой вопрос на не на таким чувством вообще нельзя делать никаких операций или есть это какой-то список ограниченной которую можно приплыть в котором можно проводить я бы сказал что осознанно можно делать что угодно но тут главное помнить где именно включите свою осознанность вот как я говорил про я больше то мол какой правил по умолчанию лучше взять что в например для большой группы разработчику сказать водки по идее сути так и у вас проблем не будет с этим вот какой лучше то есть вообще ничего не делаете с таким числом или что то все таки есть уже или вы можете не на этом типа какие-то пиратка производить я бы сказал что откладываться sure to me вот теми же чек сами если у вас везде сидят 164 и вы и коммент рядом стоит что там внутри лежит cidade 164 то его анализировать этот код будет достаточно просто хорошо спасибо большое пока кот кто-то понимает все хорошо блог становится когда вы перестают понимать даже сами разработчики"
}