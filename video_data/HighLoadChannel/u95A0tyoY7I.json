{
  "video_id": "u95A0tyoY7I",
  "channel": "HighLoadChannel",
  "title": "Устройство PHP-фреймворков / Фрол Крючков (Авито)",
  "views": 7732,
  "duration": 1676,
  "published": "2020-07-17T06:50:36-07:00",
  "text": "всем привет меня зовут фрол я тим линд в компании авито и занимаюсь разработкой микро сервисов в город в одной из картин перед тем как и перейду к своему докладу хотел бы немного рассказать про авито авито это один самый большой сайт а сам большой сайт в европе у нас на данный момент больше 50 миллионов активных объявлений в нашем о тех департаменте больше 300 100 сотрудников и практики сотни micro series of кубер найтись и наша база под gres выдерживает со всеми викингами выдержит больше 35 тысяч рпс и при этом мы держим 20 тысячи транзакций в секунду как немного рекламы перед тем как я перейду непосредственно к теме сау доклады хотел бы сказать что этот доклад начального уровня и он предназначен для разработчиков которые только начинают свой путь в разработке печь при разработке и уже как минимум ознакомились с одним из фреймворков и не было времени или у них есть какие-то барьеры для того чтобы начать изучать именно внутренности free маркой как они устроены когда я делал прогон свою дату своего доклада я думал о том что а зачем собственно знать кто как устроены фреймворке сначала я подумал что это будет очень хороший навык для того чтобы не строить свои велосипеды когда вы знаете как какая-то система работает из каких компонентов она состоит это хороший навык для того чтобы начать проектировать свои системы опираясь на какой-то дизайн уже существующих но я думаю что это наверное не самок сильная мотивация чтобы сидеть и изучать именно как устроены фреймворке затем я подумал что это достаточно не будет неплохой скилл то как искать или либо жить ошибки в ваших приложениях потому что когда вы знаете как работает система вы знаете какие ошибки в каких ее частях могут возникнуть и это достаточно сильно повышает вашу эффективность как с рабочего вы начинаете искать сразу же проблемы в нужных в нужных местах куда было блоков кода а что позволяет вам быть более эффективным и более продуктом продуктивным разработчикам но опять же это не совсем цели зачем нужно это делать потом я подумал о нескольких случаев когда нам приходилось мигрировать наше решение самописных компонентов или даже сам описанного фреймворка на какое-то более стандартное решение которое достаточно сильно распространено на рынке но как правило такие миграции невозможно произвести за один присест не невозможно сесть за ночь все переписать и запустить продакшен как правило такого процесс растягивается на очень продолжительный срок и для того чтобы это сделать как можно более безопасно для бизнеса чтобы не было много ошибок в коде при переезде необходимо знать то как матрица ваши самописные компоненты какие какой функционал можно будет перенести на функционал какого-то конкретного from our кое какой компонент за это отвечает это тоже один из науках который вам позволит делать более более мягкие переходы с одной системы на другую но я думаю что самый главный мотиватор в этой истории является то что каждый за рабочих я думаю стремиться к тому чтобы копнуть чуточку глубже и узнать выйти за пределы своего понимания именно своего кода и начинать разобрать разбираться в том как устроен слой который находится глубже для того чтобы быть более более образованным инженером чтобы иметь возможность влиять на систему не только которой ты разрабатываешь но возможно и кантри beauty в какие-то общие компоненты компании или компоненты которые использует компания или в целом open source я думаю что я думал что это очень хороший навык и это достаточно сильно позволяет инженерам повышать свою квалификацию и но как правило первый барьер когда вам необходимо перейти из своих зона комфорта в слой ниже это достаточно сильный барьер иногда у нас не хватает времени чтобы это сделать иногда знаний я думаю что этот доклад поможет вам будет маленьким трамплином для того чтобы легче нырнуть в внутренности фреймворков и так перед тем как расскажу о том как к устроенной фреймворке я бы хотел сказать хотел бы задать такой тем когда мы начнём с очень базовой простого скрипта который в каком-то смысле играет роль такого очень простого фреймворка и постепенно мы будем делать рефакторинг этого файла выводя какие то делать рифат и делать какие выводить какие-то компоненты тем самым будут добавляться новые системы новые компоненты которые мы будем в будущем опять на фреймворк какой в какой компонент взрослых ремарках этот этот момент использует а что ж приступим как вы видите скрипт достаточно примитивный скрипт он отображает две страницы если мы сделаем брал вызов в браузер и странице яндекса отобразится индекс если отобразим страница фу отобразится страница фу ну какую проблему вы видите такую самую первые очевидную которую можно исправить здесь кто-нибудь все правильно все правильно глобальные переменные думаю что все не понаслышке это уже заезженная тема что они нельзя используя глобальной переменной потому что это утяжеляет тестирования разработку кода они мутабельные и таким образом достаточно сильно усложняется заработка фреймворка извиняюсь продукта как мы все знаем как мы все знаем веб-разработка строится на в основном базовым принципе когда у нас имеется обмен сообщений от клиента в нашем случае браузера до нашего бэг-энда это взаимодействие описывается пересылкой сообщений от одного от клиента к бренду и от бэг-энда клиенту спички мы не привык как разработчики мы привыкли работать с понятными структурами данных то есть для того чтобы писать сообщения мы как правило используем объекта рис request и который мы получаем от клиента и получаем и формируем ответ response для того чтобы отдать структурированную структур структуру нашим клиентам чтобы нам удобно было с этим работать первую итерацию рефакторинга я решил использовать компонент htp извиняюсь а штефан дальше на symfony потому что просто наиболее знаком был с ней на тот момент и вел заменил rev a tree факториал использовать глобальных перемен и использование тех компонентов я использую фабричную функцию h теперь foundation для того чтобы сформировать из глобальных переменных структуру request а затем использую поля этой структуры для того чтобы выяснить на какой странице мы находимся и формирую модели ответа которые мы понятным образом формируем и нам уже более удобно как-то отдавать это пользователем и так с первой проблемы мы рассчитались какая следующая как вы думаете хороший хороший догадками но еще рано до этого с подсказкой не совсем сейчас наш индекс файл по большому счету содержит с он ответственен за то как формируется структура ответа из каждого каждой странице по сути дела это бизнес логика и такая логика как правило относится в класс и сервисов контроллеров и давайте попробуем это сделать я завел два новых класса контроллер и и заменил вызов формирования нашего response а из файла и так впечатлит в контроллер и наша структура проекта выглядит примерно таким образом то есть у нас появилась папочка сердце и в нем находится классы контроллеров в контроллер и у нас очень примитивный контроллер который получает на вход a request получает и я даю это response и от формируется в нем модели model a response а но как правило контроллеры должны быть тонкими это конечно холивар на я тема но на самом деле контроллер инфраструктурный слой который сам по себе не ответственность за то как бизнес-логика формируется вон отвественность за то чтобы сопоставить request от клиента к классам это могут быть репозитории или сервисы которые уже знают как формировать бизнес-логику и прокси рует ответ обратно уже в яндекс файл для для вывода для лаконичности кода я нарушил правила и сформировала сутки response в контроллер и наш сайт все еще продолжает работать ровно таким же образом как и было после наших нив небольших рефакторинга фф но как я сказал мы хотим все таки построить какое-то наш в мини фреймворк для того чтобы объяснить как работает разные формочки и для того чтобы как-то абстрагироваться от каких-то имплементации конкретных библиотека например как sinfonie мы используем на помощь приходит пср и кто-нибудь знать что это такое хорошо ну тогда вы подскажите какие стандарты высеры помогут нам а уже абстрагируется от от наших контроллеры от symfony компонентов здесь кричать 7 правильно но не так много кстати как я сказал что мы использовать стефаник factory close метод а для того чтобы сформировать request и мы используем сами модельки мы используем для того чтобы абстрагироваться конкретно ответить реализация request a и response а есть стандарт пср 7 который по сути дела и описывает интерфейсе этих этих моделей в нашем случае мы будем использовать его лишь два интерфейса это сервер request интерфейс или спонсор из request интерфейс они помогут нам абстрагировать наши контроллеры от конкретной примет ации symfony что насчет фабрики кто знает за что ответственны пср 17 все верно давайте посмотрим что произойдет с нашим печки скриптом после таких взаимодействий как вы можете видеть здесь наверное слишком мелко но тем не менее мы перевели формирование наших request of на пср 17 и начинаем использовать уже интерфейс фабрики и также 17 для того чтобы формировать request и и переключается экран пср 17 и и пср 7 для того чтобы формировать сами модели наш экран упростить и наша free мог продолжать все ищет работу таким же образом но как минимум сейчас у нас уже есть возможность использовать разные имплементации этих компонентов и нашего бизнес-логика никак не зависимо зависит от нашего индекс файла следующий момент как вы говорили что здесь нарушена следующая концепция это роутинг какой компонент как правило участвуют для того чтобы избавиться от этого ифа хорошо мы добавили роутинг скотт примерно выглядит стал таким образом у нас появился роутер в данном случае опять использовать симфоний road на данный момент мы используем яму configure описываем road и в я в файле также указан директорию для каширования этого файла и наш iv заменился на request mature что по сути он делает request mature берет и все данные из ямал файла там где мы декларативно описали все наши рига request и и возвращается какие-то метод данный который получил о классе который необходим которые ответственны за реализацию этого конкретного робота и полученные метаданным по сути дела мы делаем вызов контроллера на какой-то экшен давайте посмотрим что лежит в работах рот выглядит следующим образом то есть у нас есть и road яндекс и и фу то есть мы по большому счету писали об описали как на какие классы какие роботы мочиться что насчет кэш зачем роботам необходим папка с кешем что он там сохраняет зачем отчасти да то есть по сути дела вы правильно говорите мы делаем кэширование для того чтобы не парсить ямал мы превращаем наш декоративный ганаш конфигурационный файл в печке файл который впоследствии загружается печки попадает в appcache и как правило делает достаточно сильное кэширование сам файл выглядит таким образом то есть нас есть какая-то простая ассоциативный массив который может завод единицы замочить какой входящий request попадает кадр обрабатывается каким конкретно контроллером но что будет если мы добавим динамические road и когда нам необходимо использовать ajax для того чтобы для того чтобы мачте роботы то есть в данном случае я добавил до в uri новый новый параметр name который по сути дела удалит regex по любому слову как вы видите у нас появилась еще одно свойство динамический динамический road ну вот вопрос такой зачем почему имея два робота с динамическими конфигурации мы все еще имеем один regexp в в этом к скомпилирован файле смысл в том что помимо того помимо об оптимизации что вы сказали как вы сказали мы нам необходимо каждый раз спарсить ямал файл мы также еще и оптимизируем все риггс по их с мертвым в один большой regexp и результаты выполнения твари кекс по на входящий uri мы получаем как какой-то индекс который по впоследствии мы можем замочить на какой-то рот потому что вызов 1 риггс по гораздо быстрее чем матч несколько несколько несколько объект маленьких regexp of такая небольшая конфигурация что насчет выбрасывание параметров полученных из uri в контроллер по сути дела если мы сделаем dump дамп результата что мы получаем мы увидели все то что у нас имеется в ямал файле плюс еще параметры которые пришли из-за из нашего жюри и как правило мы можем их просто напросто пробросить вторым аргументом в наш контроллер хендлер контроллера и сделать вывод этих данных то есть теперь у нас имеет вас есть возможность посмотреть как работает mature например в symfony или в laravel а используются различные резал веры которые для которых вы для каждого конкретного типа вы можете сделать вы можете сделать рефлексию на то какие аргументы принимают и контроллер конкретный если поставить если конкретный там int сопоставляется какой-то там сущность user или там другой моделью в этом моменте вы можете сделать это соответствие и вашу контроль уже придет конкретная модель если мы посмотрим на то что у нас сейчас есть в нашем индекс файле то есть он достаточно сильный под разбух и как правило в больших ремарках используется такой заводится сущность как как карл или об давайте попробуем зари factory те ту историю на наш индекс файл и выведем основной бизнес-логику из бизнес-логику нашего фреймворка из-за печки индекс файла в наш класс то есть все осталось по-прежнему мы всего лишь ниц или зиру им наш конструктор необходимые внешними зависимостями вся вся логика помочь ингу роутинга у нас попадает в наш оп оп класс функцию findall в котором мы передаем request который делает processing всего и получает в обратную сторону response который уже в яндекс по ли мы выводим пользователю наш индекс файл сократился теперь у нас вся бизнес-логику кладутся в три строки мы всего лишь инициализируем request глобальных переменных проект пробрасываем его в наш наше приложение и обрабатываем туч и печатаем ответ как правило фильм вока заключается в том что он также берет на себя ути реализацию достаточно большого количества функций таких как security кеширование и допустим там контент книга шишин когда вы договариваетесь о какой формат отдаете и как правило эту роль играет и то эти функции выполняется в миду в для мы д-р есть специальные также стандарт псф 15 который выполняет эту функцию много ли знала о вас что они этого пср а ну не так могу ли ну достаточно недавно появился в этом стандарте реализуется всего лишь два интерфейса и the request сэндлер интерфейс и мидл в хендлер интерфейс а в чем смысл их для того чтобы мне объяснить от то как как его необходимо использовать я нашёл первую попавшуюся библиотеку который имитирует этот этот стандарт и мы рассмотрим устройство middle вверх на ее на ее основе начнем с класса рулей relay как вы видите достаточно простая простая функция которая называется хендл принимает на вход сервер request интерфейсе дает свой лишь response интерфейс поступил это очень сильно напоминает нам историю про то что у нас есть в контроллерах мы инициализируем класс a runner и прокидываем туда пью и как правило запускаем хендлер раннера для того чтобы прогнать наши request через очередь из наших медовых давайте посмотрим что находится в раньери runnier по сути дела принимает на вход request отдают response такая же очень похоже он также лизу и тп с интерфейс request сервер интерфейс и здесь немного немножечко посложнее хотя нас код все еще очень примитивный простой мы берем первый элемент из нашего мида вера и и вызываем его пробрасываем первым аргументом наш request а вторым аргументом всю очередь которая у нас осталась в наших yummy долларов после перехода на библиотеку relay наше приложение apple стала сократилось и гораздо сильнее то есть у нас на данный момент всего лишь мы вызываем инициализируем наш relay и вызываем хендлер на него как видите вся вся обработка ошибок а нахождение роутинга абстрагировался различными дал веры это позволяет по сути дела уже на данном этапе нам использовать наш комп наш фреймворк и заменять все компоненты роутинг используют различные campo роутинга другого фреймворка и то есть мы все компоненты имеют легкую связанностью за ней не зависеть друг от друга давайте посмотрим что находится в конкретном виду vr допустим роутинг то есть здесь роль хендлер то есть все наши trying печи ушли в 1 в 1 стек вызовов middleware и получается что все последующие middle веры будут обернуты вызовом вот этого нашего error handler а когда мы делаем findall findall request по большому счету в нашем следующем элементом был это обработка обработка роутинга и робот metal gear s обработка роутинга выглядит следующим образом то есть мы получаем request визовый контроллер и делаем следующую обработку как у нас было раньше ее результатам будет результат выполнения контроллера и если последним это именно мы используем в интерфейс пср 15 для фабрики формирования response а таким образом по большому счету нас абстрагируется весь абстрагируется весь pipeline то как работается базы фреймворк наш индекс файл сократился еще чуть больше ну на самом деле для того чтобы делать вывод я использую symfony компонент поэтому необходимо использовать bridge и для того чтобы сконвертировать из-за h&h теперь испанцев и стефани response of disease пср response of sympathy способы штамм ип лимитируется вывод испанцам что насчет фреймворков то есть по большому счету на данный момент мы уже достигли той точки когда когда у нас есть все базовые необходимые компоненты для того чтобы реализовать чтобы сопоставить то как то как работает наш мир маркс с взрослыми решениями начнем слово стало ровере как вы видите на экране 2 индекс файл нашего и приборка laravel и как вы можете видеть мы инициализируем первым делом что мы делаем фрезеруем модель request a мы используем свою фабрично мест было обворовала использует свою затем мы передаем этот request в finder приложи инициализирована во приложения и печатаем response что находится в киндерах в тендерах спи картина очень похожа то есть мы делаем хендл laravel тоже делает хендл request но вместо того чтобы использовать ps r15 он использует свой компонент pipeline который по сути дела выполняет абсолютно ту же самую функцию то есть он берет прогоняет прогоняет request через pipeline метал гиров только формат описания меняется от саровского на на свой очередь массе очередь из-за медоваров что насчет symfony 10 картина абсолютно тоже такая же это мы инициализируем request из глобальных переменных мы инициализируем на шикарном приложения которые соответствуют нашему нашему приложению и вызываем handle печатаем response за исключением того что за исключением того что в symfony вместо того чтобы использовать свои мидеров используется паттерн обзор который symfony регистрирует события триггеры вен когда триггерит even когда у нас приходит какой-то request и все подписчики на gps вызывается в порядке очередь то есть эта очередь зависит от приоритетов этого подписчика и таким образом по сути дела у нас выполняется тот же самый pipeline как и у нас выполняется в нашем фреймворке за исключением того что сильфы не может прокси ровать request самого себя и получать что необходимо делать несколько слоев при request эвентри gelid и посты в интриги и в n 39 сию и в принципе картины тоже самое как вы можете догадаться то есть у нас есть наши об керну у нас есть applications точки зрения ей таким же образом работает и система событий и похожие на symfony которые по сути дела и выполняются все всеми dvr обработки request а на самом деле это все но я надеюсь что у вас появилось небольшое представление о том как если кто-то не знал то как работает htpc джинка ты как связаны с этим стандарты псс псс 7 и 17 как работает роутинг и зачем нужна медовые который по факту реализован по своему в каждом своем в приборке также мы сопоставили все эти компоненты с тем как они работают в других фреймворков думаю это кому-то поможет начинать чуть лучше разбираться в других ремарках спасибо"
}