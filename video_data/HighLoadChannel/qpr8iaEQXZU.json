{
  "video_id": "qpr8iaEQXZU",
  "channel": "HighLoadChannel",
  "title": "Поддерживаем разработку нескольких версий продукта в Git / Станислав Лукьянов (GridGain)",
  "views": 2146,
  "duration": 3008,
  "published": "2020-04-27T12:22:59-07:00",
  "text": "всем привет меня зовут станислав лук и они great game и сегодня я хотел бы с вами поговорить как мы поддерживаем старой версии в гите сначала пару слов о том что будет за доклад кому будет полезен и кто я вообще такой кто вообще такие будем говорить про то как мы поддерживаем большое количество относительно большое количество старых версий для наших пользователей полезна эта тема будет тем кто либо уже занимается каким-то продуктом с большим количеством старых версий и вы уже поняли какой то от пытаться протащить fix и в свой мастер и куда-то на несколько лет назад либо тем кому интересно через что проходят вендоры пользоваться продуктами которых вы пользуетесь ну и в конце концов даже если вы сегодня такой продукт не разрабатывается то может быть это пригодится вам в будущем на каком другом проекте и дальше пару слов про то что это за компания green day тут будет пару слайдов который я стащил наших маркетологов но поверьте я веду к чисто технической теме продукт breed гейн это распределенная субботы и платформа для обработки данных она основана на продукты который называется apache игнайт upon source нам все что есть вы знаете на слайде выделена выделена красным и grid день добавляет вокруг какое-то количество enterprise них фич которые тут по бокам и плюс к этому занимается платной поддержкой и выпуском платных патчей для игнайта чем зарабатывается кто этим пользуется пользуются этим вот эти ребята тут много всяких компаний в основном это финн всех банки и те кто их обслуживает все то что их объединяет это то что это все жесткий кровавый enterprise проблема с энтерпрайза вот в чем любой апгрейт это прайдов между новыми фичами и стабильностью хотите апгрейде ца немножко жертвовать и стабильностью потому что затягиваете себе какой-то новый код enterprise всегда делает выбор вот так он хочет обновляться как можно реже и затягивать как можно меньший патч и из-за этого нам приходиться поддерживать много старых версий и посмотрим на то много это сколько вот такая вот у нас релиз модель можете сейчас секундочку взглянуть тут я вывел версии которые мы выпустили в наших активных ветках за последний год мы выпускаем майнер версии примерно 1 квартал поддерживаемых два года что означает что мы поддерживаем порядка восьми майнер веток одновременно в них мы пускаем патчи в среднем они выпускаются по одному в месяц на каждого майнер версию и ну если посмотреть на слайд то получится что у нас 5 10 версии выходят ежемесячно это довольно много если вам кажется что это немного то попробуйте выпуститься в чем же проблема в чем именно сложность того чтобы поддерживать все вот эти старые ветки давайте пойдем наивно и попробуем сделать все вот нормально делай нормально будет есть у нас мастер мы в него комете в какой-то момент за хотели выпустить версию повесили так на commit отдали в киеве прошел ничего не нашел никаких проблем версию выпустили выпустили так еще одну сталь готовить следующие пока версии булавку и произошло следующее сначала мы запилили еще что-то какой-то fix или хочу которая попала на мастер но которую мы не хотим в этой версии 13 а потом юрий нашел в 13 какой-то баг который мы тоже пофиксили вопрос как теперь протащить б в 13 1 казалось бы очевидное решение представить так 13 кто видят в этом проблему поднимите руку естественно все понимают что такое скуоп крип мы переставили так и у нас в 13 попал еще commit a очевидное решение фиговая что мы еще можем сделать можем зари вертать а переставить после этого 13 и после выпуска 13 а закомитить обратно в мастер но очень уж много это телу движение можно было вообще сказать что надо было мастер за фризить пока мы 13 не выпустим но слишком много помех для текущей разработки естественно все знают в 2019 году что на самом деле мы хотим сделать branch под 13 и в отдельном branch и проводить стабилизацию туда за фиг там за фиксить вот в такой картине в том как она выглядит сейчас кто-то видит еще проблему вот а на самом деле оно есть потому что в том как мы сделали это сейчас мы забыли дотащить бэда мастера и как это сделать просто и как дотащить b и туда и туда ну как бы не может быть неочевидно немножко усложним пример скажем что мы стали делать branch и для каждой ветке но вспомним что у нас на самом деле релизы живут независимо выпустили первую версию 130 прогнали через тестирования выпустили выпустили следующие оборачивались от 0 потом приготовились запускать вторую и опять та же ситуация есть commit a который мы не хотим 132 но скажем мы хотим его когда-нибудь протащить в ветку 13 просто не прямо сейчас не в 132 очевидное решение а давайте сразу сделаем ветку 133 и туда все протащим и все будет хорошо после этого опять мы находим какой-то проблему в 132 которое нам там нужно и теперь нам нужно ее протащить и в 132 и в 133 и проблема здесь в том что разработчик теперь принимает очень много решений на основе того что он знает о версиях которые выпускаются он должен знать что есть 132 она в киви в нее надо тащить не все подряд есть 133 в нее надо тащить все подряд что то что должно оказаться в ветке 13 это довольно много информации и если кажется что это вполне по силам и можно это вот так как то вручную без особых заморочек с процессами сделать то это к сожалению не масштабируются и когда у вас веток становится больше и одновременно выпускающихся релизов становится больше разработчики начинают путаться я гарантирую вам что без правильно построенного процесса вы начнете видеть пропущенные комменты в каких-то ветках начали пользователи начнут видеть регрессии снова натыкаться на баги которые уже были пофикшены и вот вами очень довольна сформулирован проблемы на которой мы посмотрели у нас есть релиза в разных состояниях какие то мы еще не начали какие то мы уже давно выпустили а какие то мы наполовину за фризе ли они сейчас в стадии стабилизации и все подряд мы туда тащить не хотим у нас есть риск того что если мы что-то пофиксили в одной ветке мы это не пофиксим другой и нужно как-то этот риск минимизировать и эти проблемы множатся тем сильнее чем больше версий вы поддерживаете чем больше веток у вас одновременно живет из этого формулируем свои требования одновременные релизы не должны мешать друг другу и не должны мешать текущие разработки если нам надо закомитить мы должны иметь возможность что-то закомитить если нам надо выпускать релиз вне зависимости того что там еще мы впускаем мы имеем возможность забросит релиз в киеве на стабилизацию мы не должны терять консистентной между релизами если в старом релизе мы штат пофиксили этого всех новых релизах это тоже должно быть пофикшен а потому что пользователь не должен видеть багов которые он один для него один раз уже пофиксили и все это должно масштабироваться во-первых скажем так в ширину на большое количество версий которые мы хотим поддерживать можем хотеть поддержит последние два три четыре года и в глубину часто мы хотим выпускать патчи патчи для патчей выпускаем версии с тремя цифрами с четырьмя с пятью вот серьезно у нас есть ветки которые живут даже какое-то время какое-то время в которых у нас по пять цифр и прям бывает нужно посмотрим дальше как у нас посмотрим на то как построим разговор дальше начнем с существующих подходов к работе с битом парочка полярных и посмотрим как они вообще работают с версиями потом посмотрим на то как мы строили собственный подход какие есть развилки трейдов и и скажу о паре проблем которые мы все еще решаем сегодня существующие подходы начнем с git хоп flow кто знает что такое гид х плов вот кто не знает вы на самом деле знаете просто вы может не понимали что или что пользуетесь gif гиф hat with high flow этот самый простой подход к работе с git который может быть у вас есть мастер когда вы хотите что-то пофиксить вы делаете фичер branch или bug fix брайан дж когда закончили через пол request print a great and testing review вмешиваете все в мастер требования которое выделяет гидрофлоу это мастер должен быть постоянно абсолютно стабилен и готов где пло и фактически это значит что вы можете если у вас современный себя и сидит а скорее всего на каждый камень в мастер на каждый мертвым либо делаете deploy в продакшен либо принципиально можете сделать заплыв production то есть никакой стабилизации нет и каждый раз когда вы что-то вмешиваете можно сказать что вы выпускаете следующую версию потому что мастер опять же постоянно стабилен как git хоп flows справляется с требованиями про которые мы говорили релизы у нас не мешают изменения просто потому что процесс выпуска релиза это всего лишь процесс мер ja нет никакой стабилизации и нельзя сказать что у нас одновременно с релизом что-то происходит потому что выпуск релиза это всего лишь мертв мастер этом мгновенный процесс консистентной сохраняется потому что у нас есть всего одна веткой мы не можем забыть что-то куда-то про мер жить но очевидно что это не масштабируется потому что у нас всего лишь одна ветка it have low pro версии нам вообще ничего не говорит каких-то инструментов для того чтобы поддерживать старые версии нам не дает но понятно что это хороший базис ну это основной способ так мы все работаем с китом фиксы в фичер branch их и merge мастер с этого будем дальше начинать сверху снаружи будем накручивать все что связано с выпуском версии гид flow еще один очень популярный процесс он поддерживает две главных ветки помимо мастера есть еще и ветка давал об мастер это также постоянно абсолютно стабильная штука которую можно с любого места деплоить develop это нестабильные ветка в которые аккумулируются изменения фичи фича раньше создаются из девала по потом в мер живо ются в него обратно в когда мы готовимся сделал три лист мы делаем релизы брешь в нем проводим стабилизацию когда стабилизация релиза закончилась мы смешиваем его в мастер и обратно в давала то есть делаем сразу два мейджора когда мы держим его в мастер это считается моментом выпуска релиза кроме обычных релизов есть еще и понятия ход фиг ты hotfix релизов отличие от обычного в том что branch делается не отдавала по а от головы мастера делаем вот такой hotfix также делаем там стабилизацию и после этого также вмешиваем в мастер и выдавала вот и весь процесс как он справляется с нашими требованиями релизы не мешают изменениям потому что мы используем лесб раньше мы этому же научились самом начале сохраняется консистентной между ветками которые мы поддерживаем и да и нет с одной стороны мы в мир живо им релизные branch и и hotfix branch и обратно в давала по в мастер и это хорошо это знает что их изменения мы не потеряем по крайней мере в дтп но если у вас есть несколько одновременно живущих релизных врачей или скажем вы одновременно готовить и hotfix и релиз то нет процесс не дает какого-то инструмента как вам их синхронизировать скажем у вас есть hotfix который вы готовите с каким-то критическим патчем и какой-то релиз hotfix по этому процессу в релиз в мерзну не будет вам нужно что-то уже накручивать повергнет flow для того чтобы этот камень не потерять а уж как нам поддерживать большое количество версий netflow в принципе нам ничего не говорит он как-то предполагает что мы поддерживаем один hotfix один релиз желательно вообще не одновременно ну раз каких-то публично описанных процессов популярных процессов которые решают наши проблемы у нас нет давайте попробуем решить проблемы сами я дальше буду использовать вот такой вот сквозной пример у нас есть мастер и пять версий которые мы поддерживаем к нам пришел кантемир и сказал что у него есть проблема в версии 1.3 в нее нам нужно что-то закомитить разберемся как мы это будем делать какие у нас есть развилки трейдов и во-первых мы договорились что мы хотим избегать регрессией в нашем примере это значит что если мы хотим сделать вот так и закомитить что-то в 13 то мы на самом деле хотим это закомитить вот так сразу в мастер в 15 14 13 следующий вопрос в каком порядке будем делать эти коммиты здравый смысл подсказывает что просто закомитить их в случайном порядке это плохая идея а опыт подсказывает что закомитить все одновременно это в общем случае невозможно у вас могут быть конфликты вам может потребоваться что-то переделать для старых и для ли или для новых версий поэтому мы не можем сказать что мы просто возьмем и сразу сделаем все везде тогда у нас остается 2 логичных подхода мастер first и top gear force master шерсти ляп стрим first начинаем с мастера и потом по очереди промерзшего им во все предыдущие ветки веток не пропускаем если хотим прожить в 13 то обязаны сначала сделать это в 14 чтобы сделать в 1415 и так далее какие плюсы у нас нет никакого момента когда мы нарушаем консистентной между релизами если у нас fix есть в более старые ветки то значит мы до этого его уже сделали в более новой ветки то есть такой ситуации когда мы выпустили релиз просто миру отдали ему bug fix а потом отдали ему какой-то релиз из более новой ветки более новый и он увидел и он этого бог фиксатор не увидел такой ситуации у нас с этим с этим подходом не будет изменение идут только в одну сторону и это такой небольшой плюс потому что это помогает чисто логически разработчикам понимать процесс проблемы здесь в том что мы очень долго идем до версии 13 нам нужно сделать несколько фиксов предыдущих версиях и если в большинстве случаев это будет не очень долгий процесс вам максимум придется решить какие-то конфликты то иногда это может затянуться если фикс для как для какой то из старших версий занимает какое то дополнительное время по сравнению с фиксом в 13 другой противоположный подход таргет first начинаем с фиксов в 13 и потом поднимаемся в верх и если нам вдруг надо спускаемся вниз + fix целевой версии максимально быстрой можем там пофиксить сразу реле сразу зарелизить потом уже разбираться со всеми остальными но при этом мы рискуем нарушить эту самую консистентной очень частая ситуация когда вы сделали фикс для карта мира выпустили ему версию и расслабились протащить этот фикс более старшей версии это больше не критическая срочная задача поэтому разработчик прикидывается на более срочные штуки и промерзать fix мастер можно вообще забыть эта проблема и опять небольшой такой минус сравнении с предыдущим подходом это то что мир джемма теперь и вверх и вниз и это логически чуть более сложно вот небольшое сравнение понятно что то в чем хорош один там блок другое они такие антиподы друг друга эти два подхода мы для себя для себя выбрали мастер first ну потому что консистентной превыше всего и мы готовы за нее заплатить иногда более долгим фиксом в той версии где где этот фикс нам нужен прямо сейчас дальше внесение изменений в следующую версию о чём я здесь говорю тот пример который у нас уже был ранее когда у нас есть какая-то версия 132 которое уже в киеве и нам нужно было протащить fix a ветку 13 но 132 уже был в киеве поэтому мы создали df ветку 133 для того чтобы аккумулировать изменению там и после этого у нас как бы две активные два активных релиза в одной и той же ветки 132 и 133 вопрос как разработчик принимает решение что ему надо тащить если он знает что комет нужен в какой-то версий в рамках ветки 13 как он принимает решение с какие именно релизы коммент протащить достаточно сложно решение которое мы себя придумали это релиз мастер бранча первым для ветки 13 создается branch который называется 13 мастер это он играет для 13 такую же функцию как мастер играют для всего проекта то есть аккумулирует вообще все все все изменения в тот момент когда нам нужно зарелизить что-то мы делаем мы делаем ветку от этого branch от от 13 мастера поэтому разработчик может видеть только мастер протаскивать фиксы только туда в нужный момент релиз инженеры сделают ветку от этого 13 мастера 133 нам в эту и вообще ветки релизов в состоянии девелопмент когда они еще не переданы в киеве нам в этом случае вообще не нужны потому что изменение могут накапливаться прямо в 13 мастере а если нам нужно принести какой-то fix в во время клей как здесь нам нужно было перенести fix б в 132 это делает релиз инженер они разработчик релиз инженер знает осколки релиза за который он отвечает у него есть доступ к этой ветке и он может сделать этот черри пик следующий такая минорная но все же развилка как нам отмечать версии что имею в виду есть вариант когда мы на каждую версию создаем по branch и нужны нам там стабилизационные кометы находят и проблем не находится равно создаем пап раньше часто предлагают вместо branch и стараться использовать теги как это делает например netflow тот же самый для версии legit хопфа когда мы просто на мастере ставим теги и только если нам потребовалось стабилизация какой-то стабилизация для какой-то версии тогда мы уже делаем для нее branch ну тут все понятно теги более легковесные они нам не засоряю список branch и он действительно потихоньку распухает branch и более универсальна и потому что если заранее вы не знаете потребуется вам стабилизацию или нет если потребуется то вам придется так заменить на branch или как-то использовать их вместе это довольно запарно поэтому мы просто стали использовать бранча теги мы практически не используем в нашем процессе последний момент у развилках как мы в мастер то кометы доносим уже поговорили обо всем чем мы делаем со старыми ветками но как нам пофиксить мастер в чем тут сложность в мастер мы наверное хотим использовать стандартный процесс но практически did have low за и затем исключением что мы не требуем полной стабильности мастера сделали bug fix ветку сделали там несколько коментов в мир жили в мастер как нам после этого дотянуть вот эти несколько коментов до предыдущих версий первый вариант прямой черри пик если кто не знает чепик эта команда которая затаскивает перетаскивает камеры с одной ветки где-то на другую напрямую перетаскиваем все кометы из bug fix релиза в старые ветки какие здесь проблемы первое у нас могут быть какие-то изменения непосредственно в мерч к мите которые были частью мертв мастер во вторых у на мы таскаем целую кучу коммитов между ветками многие из них это всевозможные work in progress которые часто могут быть достаточно мусорными штуками в третьих у нас получается некоторая разница между тем как fix выглядит в мастере в старых клетках потому что в мастере это опять же отдельная ветка имидж комет в старых ветках это просто несколько фиксов прямо на релизных мастерах и это тоже некоторая проблема их потом сложные сложнее сопоставлять друг с другом другой вариант черри пик минус m что делает черепеть минусом в отличие от обычного черепе к он все комменты схлопываются вместе вы натравливаете его на мертв комет в мастере говорите что хотите взять коммиты из ветки bug fix он их все вместе с хлоп его id вместе с изменениями которые возможно происходили primergy и после этого вы таким образом перетаскиваете камина и перетаскиваете изменение в старые ветки в чем здесь проблема у нас все еще есть некоторая разница между тем что у нас лежит мастере и тем что у нас лежит в старых версиях достаточно большая в старых версиях нас один какой-то атомарный комет в мастере у нас их целая куча еще и с мертвым все еще достаточно сложно всем этим управлять и состава и сопоставлять изменения в мастере и в предыдущих релизах тот путь который мы выбрали для себя это мертв сквош что делает мертв сквош он вместо того чтобы создавать мерч комет в мастере он создает сквош камер который примерно как в черепе к минус m схлопывается все комменты a b c из bug fixes вместе и кладет их прямо в мастер в мастере при этом мерзком это вообще никакого нет то есть мастере у нас лежит один комент соответствующий всему изменения и мы его легко простым черепе com1 комета перетаскиваем на предыдущие ветки это максимально удобная штука если вам нужно часто делать черри пике между черри пике каких-то бог фиксов и фичей между ветками даже если это относится не к поддержки старых версий от каким-то другим вашим процессом мир сквозь прям спасает поговорили обо всех частях процесса по отдельности теперь посмотрим на то как весь процесс выглядят вместе сначала то как процесс видит разработчик и как мы вносим изменения в продукт надевает шапку разработчика мы можем не думать о релизных branch ах вообще о конкретных релизах мы можем думать только о мастер branch of остальные вообще не видим и строго говоря мы по процессу вообще запрещаем как для всех кроме релиз инженера комменты в железные ветки вот такую картину видят для себя разработчик когда нужно сделать какой-то bug fix он готовит себе bug fix ветку после интеграционного тестирования review всего остального в мир оживает это все мастер потом делает филиппики по очереди в 15 14 13 вот и все это все что нужно сделать разработчику процесс прямолинеен не так ни за какими предыдущими релизами следить не нужно откуда разработчик получает информацию о том в какие из этих веток комитете в кабину в какой версии нам этот нам этот нужен нам нужно fix в какой минорной версии это у нас обозначается прямо в жире в fix вершин либо это делает тот кто заводил тикет либо это делает разработчик сам исходя из своих знаний о том какие фичи в каких реле в каких минорных релизах были добавлены если фиксит фичу которая добавлено в 13 значит нужно промерзать fix вплоть до 13 как процесс видят те кто занимаются выпуском релизов как процент как вы ведь релиз инженеры есть мастер есть релизный мастер 13 мастер от которого мы собираемся сделать релиз когда мы готовимся релиз выпустить сначала весе вас клуб собирается в ветке 13 мастер после этого когда мы когда весь клуб готов мы делаем релизную ветку 132 так как мы ее только что сделали мы знаем что все что лежит в мать в 13 мастере в этот релиз у нас попала если нужно пока релиз тестируется мастер и 13 мастер продолжают развиваться независимо если нам нужна какая-то стабилизация в 132 мы нашли какой-то бог б то мы проводим его по обычному процессу разработчики по фиксировал мастере потом в 13 мастер и потом релиз инженер протащит кива в 132 еще раз посмотрим на те требования которые мы выдвигали к подходу ранее мы говорили про то что релиза не должны мешать друг другу и разработки что между релизами должна сохраняться консистентной steam и не хотим не рисковать и подход должен масштабироваться в ширину на большое количество версий и в глубину на разные уровни патчей кажется что наш подход этому всему удовлетворяет одновременно и релиза друг другу не мешают за счет того что мы используем релиз branch и и релиз мастер branch и разработка всегда может вестись в релиз мастер мастер branch ах и поэтому никакие работы с релизами не мешают разработчикам вносить новые изменения консистентной между релизами сохраняется за счет интеграции сверху вниз мастер фреш степ стрим фарш когда мы точно знаем что промерзли commit во все более новые версии если он есть в более старый масштабирование в ширину мы достигаем за счет того что мы можем добавлять больше мастер броней а масштабирование в глубину мы можем достигать за счет того что будем создавать такие branch и как 111 мастер и и так далее они будут с своим реализмом мастером относиться так же как релизный мастер относится к обычного мастера что дальше какие проблемы у нас все еще остаются ну первая проблема это проблема с тем как мы боремся с нарушениями процессов кроме того чтобы землю людей палками мы не будем людьми палками естественно ни один процесс не будет работать если ему не следовать но нужно сказать что вот этот принцип up stream first который мы придерживаемся он несколько более хрупкий за счет того что мы не вмешиваем старый например старые релизные бренчи вверх если мы в какой-то момент что-то за куда-то забыли про мер жить так как непосредственно мер джей между ветками мы не делаем to fix может так куда-то и не попасть и эта проблема поэтому если процесс он нарушается то начинается хаос и решаем мы это через то что пишем дополнительные инструменты сейчас у нас в разработке ну уже есть первые версии инструменты которые делают там валидацию with logo и jira здесь нам очень помогает то что мы делаем мертв сквош это что у нас ровно один камень под каждую gera еше скрипт может посмотреть на список комментов на фиг с версии указанные в жире и точно идти между ними соответствие один к одному за счет этого можно легко поймать все проблемы с тем что мы что-то куда-то не промерзли еще одна проблема которая не напрямую связана с китом но эта проблема поддержки старых версий и промерз промер жевание коммитов и соотношениях по комментам это то как версии соотносится представьте что клиент использует 11 10 и захотел прийти на какую-то версию в ветке 12 какую версию он может на какую версию может прийти может ли он прийти на 121 на самом деле мы этого не знаю проблема в том что один 110 мог выйти позавчера 121 мог выйти три месяца назад в 11 10 будет просто больше фиксов и то что клиент уже видел пофикшены в своей текущей версии окажется сломанным в той версии на которой он прийдет если он придет на 121 это означает что при приходит клиента с версии на на версию на другую майнер версию нужно учитывать время выпуска версий это такие комменты туда попали решение над которым мы работаем сейчас это составление матрицы совместимости это в общем просто таблица в которой есть по обеим осям мы перечисляем все версии которые которые мы выпускали и отмечаем на пересечениях можем мы сделать такой переход или не можем это плюс такого подхода в том что он позволяет учесть не только дату выхода не только то какие комменты нам туда попали но также и баги которые могут быть в совместимости потому что это достаточно гибкий подход но проблема этого в том что такую таблицу сложно поддерживать но представьте у нас сотни одновременно находящихся указ номер версий одновременно живущих и это будет ну такая гигантская таблиц астана стоит конечно не очень классно и и пользователь такое давать сложно но сейчас мы работаем над тем как бы это привести в какой-то божеский вид возможно исполь возможно тоже используя гид каким-то образом эту штуку строить для того чтобы пользователь мог понять как он может осуществлять апгрейт ну и наконец какие-то выводы о чем сегодня поговорили посмотрели на то что поддержка продукта и поддержка нескольких старых версий продукта это не тоже самое что разработка в одном мастере и у такой разработки есть специальные требования к тому как мы работаем с ветками гита нам нужно не забывать о сохранении консистентной sti и о том что мы должны промерзать ками ты сразу в несколько мест и мы должны убедиться что выпуск релизов не мешает нам производить какие-то изменения в продукции или выпускать другие релизы kitkat flow гид flow какие-то подходы которые описания которых вы могли найти публично этим требованием не удовлетворяют хотя я уверен что у большим ну наверное у всех продуктовых кампаний которые занимаются такой поддержкой есть какие-то собственные велосипеды на этот счет поэтому мы тоже построили свой собственный велосипед но решили еще и поделиться наш подход это основан на интеграции мастер first или обстрел шерсть сверху вниз и использование релиз мастер броней которые аккумулируют изменение соответствующие соответствующие поддерживаемые майнер веткам easy мы продолжаем его улучшать и дорабатывать мы работаем над дополнительными инструментами такими как валидация гита и кросс валидация гитаэ jira и над какими-то инструментами которые помогут нам понимать соотношения между нашими версиями спасибо за внимание здравствуйте я тут спасибо не могли бы чуть более подробнее рассказать про выбор мастерхост потому что получается что бак приходит на конкретную версию допустим 13 и очевидно если бак непонятен take on hear my teeth будут тоже на версии 13 соответственно в 13 в таргет его можно легко починить и дальше следуя логическому процессу разработки эволюции решения перенести его во все последующие ветки камень починка начиная с мастера помогает вам убедиться в том что этот фикс гарантированно попадет в последнюю версию но контроль за тем что fix попадет в каждую из версий у вас уже есть поэтому не совсем понятно зачем усложнять жизнь разработчикам и менять вот этот порядок с логического на обратный с учетом того что вот может уже видоизмениться до полной неузнаваемости спасибо спасибо за вопрос хороший вопрос можно было бы сказать что тут есть какой-то компонент того что так исторически сложилось потому что понятно мы сначала пришли к тому что у нас было обстрел first это достаточно давно произошло кросс валидация гитара и жиры то есть как контроль за миражами у нас появился не так давно но на самом деле он тоже зависит от вот этого обстрел часть потому что если мы только что промерзли что-то в 13 и еще не промерзли выше то вот этот бот который нам ходят и присылает нотификации он сразу начну начнет нам сыпаться ли ртами что мы что то еще не промерзла мы хотим чтобы у нас были не alert и на которой мы реагируем а мы хотим чтобы у нас alert of не было потому что если вот постоянно будет сыпать тем что у нас все баги которые мы фиксе они еще должны быть тот помёрзнуть просто при stand на это отреагировать добрый день и спасибо за доклад сказать пожалуйста какая политика при случае отката ну если commit который пошел не взлетел либо версии конкретно либо от по всей ветке спасибо у нас в общем редко делаются откаты ну прямо очень редко то есть они хендрикса прямо в супе ручном режиме и связано это с тем что вот предыдущий коллег кто сдавал вопрос говорил про то что нам нужно проанализировать commit праве лидировать fix например у пользователя это так но если мы скажем сделали какой-то fix мастере и он не взлетел он на самом деле нам проблемы не пофиксил мыши вонь но не просто так сделали мы написали на него какие-то то есть мы нашли и воспроизвели какую-то проблему мы что-то пофиксили возможно иногда бывает так что мы пофиксили проблему но это не была проблема с которой приходил пользователь но это знает что мы чет пофиксили а теперь нам надо пофиксить что то еще то есть откатывать нам ничего не нужен знаю performance если если у нас была какая-то регрессия по performance у почему то еще мы скорее всего тоже не будем делать отката мы просто заведём но отдельные регресса нашли и будем хандрить его таким образом а если релиз инженера но у него есть план по стиму разработчик что-то замешивал ветку это как завязывается мы вообще запрещаем ну просто на уровне правил там проекта на гитхабе мыло чем ветки соответствующие отдельным релизом так что и назад жил мастер правильно то есть он у мастера этого релиза да ну то есть да то есть это означает что у нас регрессия появилась во все там в куче релизных мастеров и это значит что мы заведем regression мышью какой-то блокер который будет блокировать там нам возможно релиза во всех этих ну во всех мастерах и стараемся быстро его пофиксить здесь данного с регрессиями это хороший вопрос у нас наверное просто не так часто случаются такие проблемы просто всем фримаркет они идут по пути когда все хорошо всегда штаг доедай не задает да я всегда я согласен я согласен я согласен но здесь мы когда решаем проблему девяносто девяти процентов случаев и вот этот один процент когда мы дрогнули performance как к каким-то bug fixes в два раза и нашли это там где-то во время тестирования a bug fix уже везде промерзшем но мы в ручном режиме значит предпримем какое-то решение может быть мы сделаем откат но скорее всего мы просто очень быстро будет фиксить это во всех клетках добрый день внутреннюю систему колец у него просто бы вы говорите что вы используете подход обстрел first dunno при этом допустим вам пришел тикет на исправление версия 13 соответственно разработчик он сначала должен найти локализовать и справиться 13 фиксе и затем пойти сверху 1514 возможно 12 или же начинают самой последней версии с 15 смотрит если сейчас самый свежий обычно у нас это происходит таким образом то есть у нас есть две инженерные команды на самом деле 1 и я как раз не работаю работают с каста мирами и воспроизводит их проблемы и занимается частью бак фиксов и есть там команды который работает преимущественно с мастером ну нос с такой направленный в перед разработкой и обычно у нас происходит так что команда которая работает сказкам раме получает отказ камера запрос потому что 100 мир вообще не заводят как бы баг репорт он он говорит что у меня чет не работает как когда вас программы анализируем проблемой когда мы ее воспроизводим мы удостоверяемся что она воспроизводится скажем только на его версии или она воспроизводится еще и на мастер если она воспроизводится на мастер это мы просто фиксируем в мастере потом пропускаем назад если только ну на каком-то диапазоне версий то скорее всего мы начнем фиксить самой последней версии где она воспроизводится и потом начнем промер жевать вниз но поиск начинается с версией пользователь поиск начинается с версией пользовать войск начинается с версией пользователя потому что в самом начале пользователь приходит с проблемой которая просто не очень но мы заранее не знаем если у нас бака где у нас где у нас проблема то есть нам нужно максимально воспроизвести для того чтобы произвести бак мы сначала максимально воспроизводим дивайн в элемент а потом уже пытаемся как бы подменить версию например на самую последнюю посмотреть воспроизводится все еще или нет хорошо еще такой вопрос мастер в вашем понимании ну то есть в том примере который приведет что это это получается на самом деле мастер 16 ну он не будь он он не станет мастером 16 когда-нибудь мастер 16 от него от бронхита но фактически да фактически мастер это как бы релизная ветка для вот следующего релиза который мы будем готовить конечно такой маленький вопрос вот это студент видите всем в пример у него 50 вопросов он выбрал из них 4 сейчас давай последний versio не рование там больше 3 на 4 больше положенности скорее и спецификой конкретной ваши до разработки то есть по факту вы ну как бы выходит какие находятся какие-то бани в фиксики ну вряд ли же получается так что исправление к каким-то к стенах нужно каким-то стримером нужно да если это какой-то баг то есть почему не выпускать там 13 14 1 131 132 я но то есть почему костюмер просто не возьмет и не за придется до самого конца и мур им уже все равно нужны все эти фиксы но в каком смысле да и это еще решить ту проблему что раньше погреть и типа копятся по факту мы же сможем тогда удалять условно предпоследнюю ветку всегда ну в рамках минорных в рамках минорных версии вот выпустили 13 мы можем удалить 180 выпусти 133 можно удалить 131 по сути ветки удалять мы просто не хотим потому что но нам нужна история мы на них периодически но когда к нам придет к саммерс 131 нам нужно какую-то ветку за чика учите собрать для того чтобы на ней и продюсер какую-то проблему почему нам нужно поддерживать старые ветки почему-то красными они переходят это всегда какая-то договоренность к стримерам потому насколько большой прыжок они готовы сделать если они сидели полтора года в продакшене у них все было хорошо потом они нашли какой-то в один бак и мы им говорим что ну отлично в эти при затяните все наши изменение фичи за полтора года для того чтобы его пофиксить они скорее всего будут него не не очень сильно рады и даже если это захотят сделать сама команда разработки в каком-нибудь банке то их скорее всего развернется как как но он какие-нибудь их опираешься к развернут они попросят не знаю че czech лист для так для такого перехода он там будут тысячи изменений и не скажут мужчинам пачек не проблема гарсиа нирования то есть получается что у вас минорной версии о самом деле не менее не минорной почему не нет нет нет почему минорные ну минорные мажорные версии не отличаются мы как бы выбираем мы пускаем минорную или мажорную просто по изменениям менеджер ломает compatibility а майнер не ломает формально скажем так и не ломает по крайней мере вот но в рамках минорной или мажорную версии мы потом продолжаем их просто не независимо выпускать о них почти чтобы костюмером было проще один раз выйдя в прод на минорной версии проще было в рамках неё градец я предлагаю этот мастер-класс по сольфеджио прекратить подарить парню за 150 вопрос в книжку"
}