{
  "video_id": "1e4JwZX4OfU",
  "channel": "HighLoadChannel",
  "title": "С++ и msgpack: проектирование кастомных протоколов / Александр Ляпунов (VK)",
  "views": 797,
  "duration": 2050,
  "published": "2023-01-19T07:01:38-08:00",
  "text": "так меня зовут алекс панов я работаю в компании в к конкретном подразделении тарантул в небо я лидер небольшой группы называется картин для маленькой группы очень горды название мы делаем тарантул вот сегодня хочу рассказать про то как мы используем если чпок в качестве протокола общения тарантула со всем миром и про то как мы используем си плюс плюс чтобы работать с этим самым месяц пока так коротко о плане наступления сначала расскажу примерно треть про то как мы выбирали message так как он вообще чем хорош чем плох именно в контексте протокола общения какие шин сервера и клиента вот затем я расскажу как мы проектировали и разрабатывали hibiskus коннектор к тарантулы при помощи то же самое место чпок а вот и в общем-то последняя часть последняя треть наверное это примерно навязчивый погоню за производительностью как мы пытались придумать так чтобы это было работала максимально быстро вот прямо вот без без тормазов q поймут не ради скорости для начала пару слов про сам тарантул и про месяц по как может быть сказать что было понятно вообще чем речь о крошечном два экрана так тарантул это может долго привык отвечать одинаковый что это иной мере но и скурили persistent особо д с языком хранимых процедур на lua но это на самом деле не совсем так давно вот и языковым храним процедур там разные варианты есть с диском в общем-то engine есть и самое главное что на этом самом языке ханин процедур написан уже так много что тарантул давно считается таких шин сервером то есть есть очень много применений тарантулы когда мы берем на нем налог или может быть на еще каком языке пишем приложение но то есть она прописываем набор функций и потом соответственно эти функции прекрасно используются встроенную базу данных вот и все с этим делом работаю в целом как с некоторым механизмом для какой иначе не какой-то бизнес задач вот что касается message пока то сразу скажу что это протокол который разработали ним и который разработал я не помню вот по сути это протокол стерилизация произвольных данных то есть мы можем взять все что угодно там чистые стройке массивы массива массивов map и там короче люблю глюк любую конструкцию мы можем упаковать месяц пак вот он без схемы прям сразу написано что он очень сильно на мой взгляд похож на for the buff arthas баф вот только без схемы то есть достаточно только запаковано данных чтобы распаковать значит он бинарный глазки ну читать очень неудобно он вариативный это значит что каждый например число может быть упакована зависимости от значения этого числа может быть распакована там в один байт в 3 там в 5 в 9 вот это означает частности что при распаковке мы не знаем где заканчивается ну то есть пока мы не распакуем как бы один объект мы не знаем где он заканчивается вот вышеперечисленные by надо вариативный фактически приводит том что он компактный но некоторые там сделаны действие для того чтоб можно было на любой точке его паковать раз попутно любой другой вот маленький пара коротких примеров как выглядит носач паки например вот массив из двух элементов число и строка бац и число 1 ставка bc вот это чем-то показанный экран это во первых вот нолик 92 этот ток который означает что дальше идет массив из двух элементов вот и собственно все на этом информация массиве заканчивается нет никакого суффикса который показывает что там где-то закончится все вот пошел массив и 01 это первое число это собственно единичка она упаковывается в один байт далее идет строка этот тег 0 x3 который показывает что дальше идет строка из трех символов и собственно сами символы строки и еще один очень важный пример это как у упаковывать сама по ну собственно очень близко к этому да что такое мапо но это ключ-значение то есть ключ ночей на вот точно также короткий t0 s 82 который показывает что это мапо из двух пар ключ-значение но и дальше там в общем то почти точно так же число тоже самое строка и вот true тоже упаковываться один банк байтом это 8 символов то есть вращается очень компактным вот но при этом надо понимать что вот вот такой пример показывает что для того чтобы правильно ну то есть мы распаковывай объект мы должны его распаковывать как бы от начала то есть униан он префикс ный формат то есть нету никаких данных о том что там закончился массив закончилась моффат map а вот и в итоге мы в tarantul и стали использовать мясо чпок буквально для всего мы храним там данные поскольку мы ускорили мы должны делать иерархическую внутрь хранить эротическую структуру там любых данных то есть это не обязательно там роу в котором фиксированное количество колонна как может быть все что угодно мы используем для сети мы храним это дело на диске вот для разных ну и вообще как бы используем во всех случаях когда мы точно не знаем какие какие типы должны умножить нужно хранить мы используем если чпок и в частности мы используем их в качестве протоколов и вот тут сна верно ну то есть ключевой момент такая залог успешности нашей стратегии это то что мы в сети используем при общении по сети используем симметричный этот месяц пак который использует мэппер то есть и запрос и ответ выглядят одинаково это три объекта число от количества размер дух следующих структур в байтах вот мама с заголовком и мапо собственно с телом запросу вот это позволяет делать очень многие важные вещи в частности мы можем изменять протокол постепенно то есть в торонто ли возникают новые фичи появляются новые поля мы добавляем старые коннекторы прекрасно с этим типом работа это не просто пропускают лишнее вот игнорирует при парсинге вроде работают всем с чем есть и ровно наоборот можно в принципе новым коннектором пытаться обращаться к старому тарантулу это же все будет работать торонто будет выпускать лишние ключи то есть таким образом мы достигаем а абсолютной гибкости запросы вот ну и плюс конечно же мы там можем показать все что угодно то есть если мы говорим про блики чем сервер то мы можем написать функции который принимает какие-то произвольные аргументы произвольное количество и у прекрасно где то там вот в недрах вот этих вот map of упаковывать вот соответственно ну плюсы да я уже начал рассказывать расширяемость мы можем сколько угодно расширять вот этим об и не ломая все имеющиеся там концы коннекторы конструкции и так далее компактность да во всех матчах мы используем в качестве ключей числа причем числа маленькие про не всегда упаковываются одним байтом это здорово органичность да но поскольку у нас все вместе с из пакета у нас и как бы очень хорошо входит в этот протокол тысяч пар есть забавные вещи то есть tarantul и например когда делается ставка данных пользователь присылать место чп от эти четыре теоретически можно приписать чуть-чуть биты мисочках но чуть-чуть некорректный вот но тарантул никогда не перепаковать те данные которые пришел пользователя потом когда он их за selected он получит тоже чуть-чуть бит бит ем ап в месяц пока то есть мы вот байт в байт как будет все что он прислали мы это хранима с этим работаем это отдаем когда страшно так мы произвольность да я сказал то есть можно можно использовать если используется как applications сервер то понятное дело расширяемости там ее результаты можно как угодно передавать вот я синхронность тоже важный момент такая конструкция протокола позволяет socket торонто высыпать эти запросы просто пачками один за другим там есть специальный идентификатор который позволит потом отличить ответы на какой из запросов то есть тарантул даже ответы может выдавать в произвольном порядке но вот можно их там запихать тысячу и потом ждать тысячу ответ это очень удобно ну там сравнить с http 10 вот ну все бы хорошо закончилось ибо если бы не было минусов вот минусы у месси чпок но по сути сводятся к примерно следующему что он не всегда работает быстро и не всегда очень удобно писать код вот как например вот этот пример кода который упаковывают higer higer вот тут один из этих трех объектов которые шляются по сети данных как он упаковывается в это как такая простая кода я забыл сказать что торонто в основном написан на языке си вот и поэтому там вот вот такого от кода там достаточно много вот то есть под каждый объект под каждый тип объекта у нас есть особая функция там и пин-код ruins and in code in не перепутать если случайно вызвать эту функцию для работам своего чисел как-то сделает вот на и всячески теоретически можно не то чтобы он постоянно ошибаемся но вообще плацдарм для ошибок нам огромные то есть в таком примере например если мы захотим вот ума по добавить еще одну пару ключ-значение то нам надо не забыть маме не принять тройку на четверку если мы это забудем а просто добавим в конце еще парочку vin-кодов да вот еще добавить там ключ-значение но то мы получим корректный мыса чп окно неправильный то есть эти два элемента попадут как бы не в map of попадут какое-то в другое место там в либо вышестоящую структуру либо вообще сбоку как-то валяться будут вот протокол испортятся но общем это будет не очень то есть такой один запрос с работы этого следующие уже нет вот это не очень здорово помимо то помимо этого такая простая работать не очень здорово поэтому мы делаем вот такие конструкции то есть иногда мы упакованы упакованную структуру хищную то есть прям конструируем ручки добавить за бантиком для того чтобы потом записать место чпок в сеть как бы одним ним себя им вот выглядит это вообще отвратительно самом деле ну и поди кода там тоже это как бы не очень здорово то есть только то распаковываешь maple ты распаковывать ключ а потом тебе нужно switch хейзом понять это вообще ключ к чему относятся вот и понять вот этого значит такой-то такой-то поле это по 1 вот ну и да и branch branch branch инга там достаточно то есть условно в целое число знаковые в мисочке парке может храниться 10-ю разными вариантами нам нужно при распаковке эту честь ну и соответственно потом а это еще помещаем свечки с на общем там сплошной сплошной и фрэнк пирс что мы решили сделать мы хотели с этим что то что что то придумать что то хорошее но так вот с места в карьер и бросаться не хотели и возникла идея поскольку протокол симметричен мы решили попробовать реализовать что-то другое на клиенте но собственно на си плюс плюс клиенте секрет узко никто докторантуру если ты дело хорошо зайдет то потом постепенно закатить и в сервер вот и так началась история с тарантул си плюс плюс коннектором и так история си плюс плюс коннектором вот собственно мы там разбили его на три части это сетевой блочный буфер вот это какие-то специальные шаблоны параметры для вынесения всех этих платформ специфик тех нюансов общение сетью и выяснилось что по большей части сибирской нектар это всего лишь месяц пока он коде радикович поскольку требование коннектора у нас было очень много и все они были очень амбициозная соответственно все эти пледа требования выпали на месяц пока он должен быть очень удобно на место чп от коллег вот он должен быть относительно коротким ну то есть чтобы было легко использовать вот он должен быть быстрым ну в частности до была поставлена такая задача сделать так чтобы это все работало без промежуточных объектов и без динамического ценных объектов такое часто бывает если там куда-то хочешь сходить данным написанному в какой-нибудь там в базу или в какой-нибудь там сервис то тебе нужно собрать данные в том виде в котором она они хотят то есть там какой-нибудь определенные серые вот положите в него и тогда мы значит его обработать вот хотела сделать так чтобы панировка т.к. работал стиме данные которые есть у пользователя вот то есть как как именно ну то есть понятно да есть вот вот мы сделали функцию который кодирует не слишком определенный буфер кладет а мать это единичку фолз и тогда с числами и фол сами понятно то есть мы просто определяем тип значение понимаем как его запаковать а если у нас есть что-то более сложное но например строка или вот томаты вектора покой не будь то есть понятно ну то есть мы то понимаем как люди что вектор нужно упаковывать как массив но как научить encoder это делать и делаем и следующим образом мы написали огромное количество всяких trade of самописных которые определяют что-то по тому объекту который 1 din en кадиру на упаковку это малый список там нас андрей гораздо больше в качестве примера вот как выглядит один завод этих trade of до который определяет что по этому объекту можно активироваться при помощи беги на н да ну тебе геноцида соответственно вот все делается это все это нас финна и если кто-то понимать что здесь написано это очень здорово ну то есть это примут лайк вот и такого бара барахла там очень много и потом это позволяет нам в конструкции найти в этом и в контекст экспресс шиндо и в куст и в контекст kunst экспорт перебирать возможные варианты и находить что именно пользователи передал нам ведь почему все это делается потому что мы не хотим завязываться на какой-то конкретный std вектор или какой-нибудь стб мэк мы хотим сделать так что пользователь использовал свои то есть он может быть там использует boost или он может быть использовать какие-то свои собственные структуры да она совместима и тем не менее сам пописчики вряд ли кто-то будет делать а но что такое из ряда вон выходящее то есть мы работаем по принципу если что-то похоже науку на утку до или крякает как утка это наверное вот тут к ее нужно паковать как утку вот дальше мысль пошла глубже вот ну вот например тип lada vesta дать упал вот понятно что нужно паковать как массив на фишка то в чем что это не просто массив это массив в компании тайн и смесь известного размера поэтому вот это действие которое предназначено для упаковки массива мы можем сделать комп комп а витамин правильно вот то есть мы можем 4 понять что это как бы вот нужно писать там 0x 94 до в поток можем можем извините это я сейчас подругой сейчас вернусь до я хотел сказать что в тех случаях когда автоматический механизм определению типов работает не совсем так а хочется-то существует спецификаторы который позволяет явно указать что вот это вот пожалуйста пакуйте как мапу вот в качестве примера вот по умолчанию тепла она пакуют как массив вот но если указать кодификатор из map то он начинает атаковать как мы то есть ключ ну то есть папа по очереди да там это там ключ-значение ключ-значение вот этаких лицевых петель в котором там достаточно много ну в общем то на все слухи да таким же лук ну да если у нас есть определенная структура мы упаковываем вот ему именно таким образом то есть самый такой гибкий варианты упаковывания структур это их паковать как map и назначая им надо на каждой назначая каждому полю определенный идиш ник небольшого размера вот таким образом теплый оставлять упал попал как правильно говорит спецификации из мы вот упаковывают вот такой вот как мы - со значением этого поля так распаковывать можно вот и тут я ошибся слайдам теперь вернулся наконец тибетского compal тайму если у нас есть то поставит apple мы этот стенд от apple передается в encoder ну нас упаковку мы можем понять что он строго compal танки все равно размера и сделать некоторые шаги по упаковке этого массива в комп алтай мы дальше а как то есть это же очень обычно это известная проблема то есть вечно вечная проблема си плюс плюс мы не можем определить что аргумент функции он как бы const экспорт как а константа выражение мы можем делать канз текста вершин функцию но вот баргу вот в обычные функции мы не можем понять что это было просто единичка или это было там какой-то там выражение там ссылка на новость память вот на этого не знаем но существует способ--и передать именно константное выражение функцию например есть пистолет не так долл констанс это тип который внутри себе содержит значение и если мы передадим эту штуку в наш encoder инкокер поймет что это не просто так это в комп алтай константа определенного типа и определенного значения вот то есть мы немножко модифицировать этот код и теперь encoder знает что это не только массив фиксированного размера а ключи этого то tapplock вот это ключ и вот этой map и это же массив у нас да ну каждое второе значение короче мы знаем что это compal time известное выражение что делать со строками вот тут мысль как бы пошла еще дальше теоретически можно сделать тип который содержит в себе строку то есть если мы то есть только определяется набором своих символов мы можем сделать шаблонный класс в котором все символы строки собственно находятся в лунных аргументах вот нас омлета конструкция скорее всего там много где используется я это же как бы не сам придумал вот где-то там стащил следующего проекта в общем смысл в том что к этому всему он прилагается некоторым окрас которой по нотам или вот например как ли литерал домов есть мы можем в любом месте написать там в кавычках строку и подчёркивание cs и это будет не необычный литерал строковый который как известно чертам массив чаров а это будет именно compal time известная строка то есть по типу вот этого значения мы понимаем как из каких символов она состоит вот и таким образом мы продолжаем то же самый пример можем сделать вот с упаковку такого массива из двух чисел 2 100 строк полностью известную campral times и соответственно encoder это будет использовать и будет упаковывать эти все вещи в кампале time мало того да у нас есть очень удобным окрасим чтобы эти строки и числа там не писать эти длиннющие студенты groupon ством потому что это унизительно вот у нас есть короткие макросы для этого всего таким образом конструируется и самое главное что дело умеет делать энкодер он умеет это дело объединять то есть фактически когда он видит что-то по константной там потом константные значения еще одна константное значение он их агрегирует то есть он использует can файл time буфер в которой предварительно складывает все вот этих compal тайны известные объекты и таким образом вот такой я тут убрал одну буковка i чтобы она вмещалось в восемь байт вот такой and hot в итоге будет вариться исключительно в complete time авран тайме он всего лишь скопирует одно готовое число в буфер вот такая вот магия ну и про декор у нас пять минут есть вот по сути дико dirt ну в общем то по большей части он использует идеи которые уже описал то есть там должны быть нас они сейчас он в таком состоянии что мы на нем еще работаем то есть в нем вот все что я скажу есть но у него не очень удобная фишка вот мы сейчас придуман более классную фишку к этому декору вот очень в процессе очень интересным но главное чтобы принцип тот же мы обмазываем со всякими trade a mi другими на то чтобы определить что вот в этот как как этот объект читать из из буфера до из месяц пока вот и там много еще похоже то есть по сути это точно так же только нинка to decode нужно нужно будет писать вот самое главное с чем мы решили бороться процессе де конинк а это с тем самым браунингом то что это я уже говорил то что int может упакован гуру разными способами и это нужно когда перебирать а потом это дело использовать в switch кейсах в общем нам мы решили сделать следующее мы делаем стоит машину которая читает ну по сути как первый байт месяц пока и по нему дальше выбирает направление 1 из 2 2 156 и направлений как им и читать это не спать дальше при этом все эти 10 6 функций компилируются автоматически то есть ты всего лишь указывает что ты хочешь успокаивать она сама строит вот этот самый вектор и таким образом получается из всего branching а это тот самый прыжок неизвестном направлении то есть по первому buy the message пока ясно что в нем лежит дальше то есть если это как бы этому то есть 1 байт определяет защитить зачастую и само значение которое там запаковано но в любом случае он определяет формат обозначения то есть это там в 9 байт на представление числа или там эти байты вот все это есть и у нас вот этот прыжок вот этой вот самой функции он читает конкретно это представление о дальше он переключается на следующий вектор и таким образом шагает полностью распаковывая вместо чпок до но это приводит к тому что сейчас даже в общем-то тестовые примеры у нас компилируется ужаса еще долго вот серьезный отбор сборка тестов делается чудом пару минут что ли хотя там там как бы еще особо нечего это нет вот но в целом мне кажется что это так это в некотором роде магическое преобразование пользовательского там числа в какую-то огромная машинерию которую она потом колбасит там какой-то буфер что мы еще будем делать на саму много еще там будем делать вот из тех вещей которые мы хотим доделать это например runtime сборка стоит машину то есть complete м это прекрасно но у некоторых случаев пользователь например пользователю нас дальше уже применение как будто ранду например пользователь задал какой-то формат кортежей то есть он не просто по умолчанию при произвольный формат но пользователь может задать ограничение что хочу вот здесь у меня число вот здесь у меня строка вы здесь у меня то то то то тут нам это нужно проверять вот сейчас таран туре мы делаем это как бы в несколько проходов то есть мы сначала когда нам приходит запросам его полностью читаем парсим понимаем впрочем когда доходит до проверки для проверки формата мы еще раз читаем тоже самый кортеж но уже с другой цели мы проверяем его на соответствие форматов и я все время считал фактически там один тоже кортеж проходит с учета до пяти раз ну под разными предлогами то есть мы проверяем сначала так вот там всех под android и третьим образом и каждый раз это branching вот эти все прочие вещи скачки в неизвестны хочется это сделать за один раз сделать это может только одним образом когда пользователь задает определенный формат нужно создать стоит машину для парсинга конкретно этих самых кортежах которые хочет увидеть пользователь чтобы это стоит машина выкидывал ошибки судоку дома читаем в случае если это что то нет а вот и таким образом до реализовать в действительно дентон проход вот как мы это сделаем еще не пока непонятно но я верю что будет очень крут вот немножко ссылок зачем я писал буквами не знаю но вот подходом можно по этим ссылкам перейти вот у меня все спасибо а по вкусу же вопросом знаешь очень лаконично получилось а ты так говорю что там низложенным сложно сложно ничего не понятненько а вроде даже понятненько не очень сложно к тут немножко тут стандартный хоп тут стандартных к ковчегу раз кубизмом и не магические работает вроде наоборот приятно там подойди базы ты начинаешь предоставится ужасно но так нет нет нет еще хуже чем де божиться не собираюсь normalno маги вот так это же проблема не наша дворе как известная проблема разработчиков библиотека это проблемы разработчика библиотек во все блоги пользователя это сожалению все еще твоя проблема поэтому не переживаю все исправится когда сам и дело что не знаю слышно исполнители либо нет не отваливается дело в том что в конечном итоге пользователь в которые будет пользоваться вот этим коннектором он в случае когда он там неправильный объекту до передал буду сейчас есть вот коннектор а задачи что-нибудь там будет какой-то там статика сердцем вот где-то там после третьего вызова да это кстати та вещь которая стоила тоже бы нам взять на будущее на как бы в планы было бы здорово как-то более в качестве на сообщать об ошибках я уж не знаю это концепта должны быть или что то еще совсем совсем не слышно да сказали не слышно поэтому давай ты окей вот я никак не мог вот так что может быть мы будем работать еще над с более адекватными сообщениями об ошибках в процессе компиляции но это наверное не ближайших планах ну зато вы были очень быстрыми это прекрасно да и тарантула это часто такой ограничитель выбора технологии то есть поскольку мы ориентируемся всегда примерно ну то есть у нас есть грубая оценка что мы должны выдавать там на миллионе данных миллиона ps хорошую цену а хороший облагается хорошие что хорошая благая цель да и при выборе методов технологии нам всегда нужно учитывать вот этот вот ограничитель да то есть мы должны укладываться в какой-то там в микросекунду вот на все про все просили чишма так одна нужно дать ничего страшно пока все думают над тем как это все с иностранным я пока на брошу расскажу страшную тайну вот ты там буферы буферы показал а что за буфера о это достаточно интересная конструкция вот надо сказать что в tarantul и используется исключительно для парсинга message пока из используется исключительно последовательный нас еще чар звезда для того чтобы тарантул смог раз поразить места чпок необходимо чтобы он лежал в едином как бы в куске блоки памяти непрерывно а это не всегда удобно потому что когда мы читаем там из сети нам нужно как-то там по кусочкам поэтому приходится как-то двигать в общем там целая магия с этим происходит мне очень приятно и поэтому было принято решение сделать блочный буфер блочный буфер как бы словно состоит и 16 килобайт не блоков но рис как скажешь вот и чтение из сети происходит в него по кускам дочитать из сети происходят как бы автоматически ну то есть нам не нужно перетаскивать эти данные никогда нам не нужно там при если нам не хватает места мы просто выделяем блоков и дописываем туда нам не нужно перетаскивать откуда там старые прочитанные данные а я правильно понимаю что в останусь поди есть какой-нибудь это делать локаторы лекарствами локатор чтобы это все работало потому что кажется что это все собирается не сходу легко что там же есть некоторая штука вам надо типа пообещать что вот в этом кусочке блочного бодро у вас будет записано какие-то данные на эти данные зависят от других да ну вас гопак у топосе милиции какую магию обещание о том чтобы когда этим он дадим байтики он любит кого последовательную спорк у вас примерно также реализована история ну я может быть не совсем понял вопрос но я скажу что следующее что в этом блочном буфере используются итераторы которые именно держат блоки этого буфера от дальнейшего удаления то есть условно говоря если мы парсим какой-нибудь объект или мы по нему понимаем что вы сейчас вот здесь вот у нас находится ну какой то прочитанный request или response там неважно вот пока мы держим указатель это и таратар на этот блок он не будет удаляться из буфера потом постепенно по мере как бы уничтожение как бы блоков с глаз охлаждение вот этих операторов данные будут удаляться из бог не понял посему не есть предложение последняя попытка с вопросами у меня пара вопросов вот первые готовы к красота что спрашивали вот блоки в этом остается в конце месту получается если мистер спок не умещается где вы уже при упаковке или разного ковки ну при упаковке очевидно что если он уходит вот такими блоками это в конце должны сдаваться по денги нет там получается что блоки всегда фиксирована размера и заполняются они всегда до конца то есть фактически может получить такая ситуация что мы упаковывали какой иметь request у нас заняло мы заняли пол блока вот мы записали этот request и вот этот вот граница является то местом где сетевой механизм уже может писать а если возник новый request вам с этого же места продолжим то есть всегда в буфере есть такой borderline ну как в области владения да то есть вот до какого-то момента мы занимаемся тем что пишем куда место шпак а с какого-то момента уже сетевой механизм эти данные сбрасывает в сеть вот и мы не имени и мы всегда эти блоки заполняем до конца если блок не заполнен сейчас до конца это значит что следующий request или какой-нибудь там который дойдет его заполнить до конца и уже тогда перепрыгнет на следующий блок таким образом все время происходит такая бесконечная цепочка без пропусков понятно а второй вопрос вот вот этот массив на все функции вот на 256 вот вы не показывали шаблон к которым вы его генерируете или может вы что-то стандартные типы 100 до визита используйте вместо этого массе я бы с удовольствием показал бы на этот код выглядит очень громоздкое даже не переживай у нас есть дискуссионную зона можно показать все самые интимные на интересные дискуссионную зоне я даже даже не уверен что там выживают после просмотра этого кода в ноги и потому что на самой выглядит он очень громоздкой и там достаточно хитрая конструкция каких-то ридеров там вот эти интеджер секунд со время подставляются подписывается чтоб понимать что вот там у нас есть ни один как бы и предмета их 200 фолд экспресс шанс полна ростом разные технологии используя там макрос это ж какие то сбоку гибели нормально это вот это такая но то есть все это происходит автоматом и все это вот такая сложная машинери вот я могу открыть но она там правда то есть дома не зона мы там смотрите включенную зону нас спасет нас по нам поможет и 321 вопросы закончились красиво"
}