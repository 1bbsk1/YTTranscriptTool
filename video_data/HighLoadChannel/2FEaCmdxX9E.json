{
  "video_id": "2FEaCmdxX9E",
  "channel": "HighLoadChannel",
  "title": "Подробно о том, как Causal Consistency реализовано в MongoDB / Михаил Тюленев (MongoDB)",
  "views": 1957,
  "duration": 2546,
  "published": "2018-08-16T05:00:10-07:00",
  "text": "только вот начиная наверное с появлением реальных распределенных систем которые используются в продакшене мы стали уже и и реализовывать именно как продакшен great фича вот ну и собственно как закончится это все как это в конце концов выглядит для пользователей вот то есть для начала вот рассмотрим простой пример который проиллюстрирует что происходит когда кожу конце снасти в системе нет вот допустим что я там решил положить какие-то деньги в банк вот это производит апдейт в коллекция которая держит скажем аккаунты и в результате все окей после чего я решаю проверить о лежат ли там деньги то есть но поскольку манга это распределенная система там есть мастера и slaves и допустим что вот этот вот файл пошел к именно славу который в этот момент еще не успела реплицировать данные из про мире знакомая ситуация вот результате ну ничего не будет естественно это будет ошибка в приложения или еще хуже если это будет лишь которую приложение не заметит и будет с этим работать дальше вот достаточно распределенная вещь конечно что распространенная вещь конечно она решается как-то вот но для начала вообще что является свойствами кузову к ответственности на стороне клиента то есть данном случае мы рассматривали именно свойства ридли rights то есть была запись и та же самая сессия то же самое connection должна иметь возможность прочитать вот эти значения во втором свойством является райт follow риц это как бы in вершина того что есть а значит и на следующий если у нас вот есть некоторый клиент который прочитал данные то следующая запись этого клиента должна работать уже с этими данными ну то есть он прочитал значение какого-то аккаунт инкремент должен иметь уже этот каунта не какой-то там предыдущее значение тоже важные свойства ну просто придирается на такой популярный про него много говорят а вот rightful рис уже меньше как вот нам она тони корицы это значит что есть у нас есть серия чтения то они все они не могут убивать по времени то есть каждая знать каждый новые чтения она уже видит то что было возвращено предыдущими чтением то есть мы предположим ситуацию когда у нас есть там несколько secondary зато это свойство будет нарушена вот вы меньше ли consistent системе которые сейчас в версии 3 4 является манга деби потому что 1 сек андрей может уже там почти что с кича вс праймари другой еще где-то далеко если один пошел к первым 2 к втором то данные будут не монотонны вот ну и маната не кроется а это с этим все хорошо потому что у нас сингл мастер и соответственно стирается вот надя но ты там она все уже упорядочена как бы сама по себе вот и за за запись мы не сильно переживаемого за чтения поскольку система позволяет считать отсек andreas то есть вот это вот собственно над этим нужно поработать ну вот как сейчас этот вопрос решается но самый простой способ но не нужно использовать ис-3 распределенную систему можно просто взять большой сервера там и начать на него писать и читать почему собственные то вопросы возникли только сейчас потому что последний там какой-то там десять лет может быть потому что появились распределенных систем в которых проблема актуальна на больших монолитных серверах этого просто нету вот примерно такая же ситуация если читать и писать снова ну вот этот пример то самое что вот сейчас люди делают в основном если требуется к залу consistent данные . скажем чтение своей запись просто запись на мастер и последующие чтения возвращает consistent данный ну за исключением случай mongo db а в случае скажем если запись была без редко без маджоре theory тсм отжарить это он может вернуть старые данные потому что данные не успели реплицироваться вот ну или просто можно самому что-то на ваять вопли кишинев тогда но она как-то будет что-то делать это уже зависит от разработчика приложения в общем есть проблема и вот собственно мы и и собираемся и как раз я расскажу как мы и решили манга тебе вот все началось вообще вот первая вещь которая как-то вот можно связать сказал к естественности было написано в 1578 году это на самом деле самая широко цитируемый статья предопределенным системам это лести lan порты 978 год там клаксон доволен африканцы не с ребята чистым вот она вот вкратце я сейчас она рассказывает о том как организовать упорядочить доступ к разделяем ему ресурсу среди некоторых процессов вот тут вводится понятие процесс вот это некоторая вещь которая посылает ивенты и может регистрировать его это все что процессами имеют вот и вот понятия одновременности и один ивент раньше другого vento то есть для того чтобы ввести это понятие нужно как это нельзя пользоваться скажем понятиями раньше пользу связанными с обычными часами потому что обычные часы но они могут просто быть идти по разному и соответственно при этом значением их нельзя доверять даже он теперь там понятно что будут даст достаточно сильно может быть это дельта поэтому лэмпард предложил водить вот эти кадры на каждом из этих процессов вот эти kontra они увеличиваются каждый раз когда происходит вот пример в данном случае процесс и у него event you wan он отправляет сообщение на процессор процессор иван что она получает соответственно мы видим что значение count и причем вот каждый вот этот вот event отправлением с чем он переносит значение аккаунт вместе с собой который был на том процесс которого отравлял ну вот мы видим что процессор получил значение аккаунта 10 увеличила на один получил 11 вот ну дальнейшей пример скажем процесс иван процесс отправляет ивент на процесс и у него получается то же значение kontra 11 эти процессы они как бы одновременно у них одно и то же значение к утру мы видим они между собой вообще никак не взаимодействовали не могут после один результат и мне как то есть вот это вот как бы как специальной относительности вообще так мне кажется может быть как то была навеяна аналогия вот ну и вот третий пример мы видим события q3 которая произошло позже события q2 события q1 потому что они упорядоченные внутри процессы по умолчанию потому что они внутри процесс происходит получили вот но при этом q3 произошло после процесса пиво один потому что он но оно произошло после и два вопроса после 51 потому что один послал сообщение но и таким образом мы говорим что r2 например зависит от пи-1 вот то есть один козырь вызывает r2 ну и для того чтобы полностью упорядочить лампы предложил также упорядочить сами по себе процесс и таким образом у каждого event-а есть пара процесс и значение аккаунта и поскольку даже если kontra одинако поскольку процесс упорядочен получается полный порядок и он там дальше рассказывает как это можно использовать и того чтобы организовать доступ к ресурсу вот это вот сам первая статья после этого было очень много сделано различных это вот вот эти канту называется нам подклассу может слышали про них вот после этого была целая серия работ там были вектор clogs там были очень много всего пытались придумать люди для того чтобы вот решить эту проблему синхронизация вот мы соответственно расскажу как мы к этому подошли вот для начала просто формальное определение что же такое кожу концы снасть потому что что мы говорили до этого она касалась исключительных line сайта то есть у нас был клиент который что-то делает вот с системой который является черным ящиком и вот он что-то наблюдает у себя и вот на основе этого мы говорим что черный ящик ведется кокоса конкретной системы или не казал касается системы но это именно стороны клиента а если посмотреть вот как бы внутри сервера как вот разработчик сервера это видит скажем это ножка другой то есть мы говорим что если у нас два события взаимосвязаны то это взаимосвязь она наблюдаемость любого процесса в этой системе это на самом деле вот утверждение даже посильнее чем вот эти четыре свойств которым ну просто формально являются прямым следствием этого значит скажу несколько слов о братьях цвету ремон к тебе я так полагаю что ну-ка стараюсь не говорить вещи которые вы все очень хорошо знаете на всякий случай я все-таки пройдусь по основу манга тибет распределенная система она шарди равана то есть это означает что данные collection который к вариант таблицы до в реляционных базах данных они разбиваются некоторые кусочки чанки эти чайки распределяются между сортами это сделано для того чтобы можно было проанализировать нагрузку когда особенно происходит доступа основа на основании вот этого ключа в котором было шарди раване сортировать можно похож или парень живу вот и существует система которая балансирует вот эти вот чанки чанки они как бы могут расти в размерах когда они достигают максимального размера они там разделяются на две части и баланс в общем распределяет их между свободными шар даме для того чтобы сделать систему равномерно нагруженный вот она вот что еще важно поскольку шарды они расположения данных для рафтинга это в общем то метаданных и довольно много там могут быть сотни тысяч от этих чанков в таблицах и нужно знать ваши где они находятся вот эти данные хранятся в отдельном shortie который называется конфликт конфиг сервер и доступ к этому конфиг сервер он вот это вот информация она вот кэшируются на разных уровнях то есть частности у нас есть раутер которые позволяют направить запрос на правильный шар то есть вот если приходит запрос там найди мне что-то где x равняется 1 и x это sharding это он найдет тот шаг на котором этот x 1 находится в chunk у с этим значений находится да пошлёт запросу он вернет - ответственная ситуация когда это не шутки и тогда происходит с катер гавр то есть на все шарда посылается запрос потом возвращается собирается вот поэтому достаточно важно правильно выбрать картинки но на эту тему всего вы можете услышать других лекциях вот вот собственно что касается роутеров они дают ls то есть это просто чисто кэш метаданных и монитор который находит вот процесса и понимает когда они живы и когда они неживые ну и собственно каждый shard он может быть replicas этом то есть репрессированные то что достаточно важно для дальнейшего то что репликация происходит с помощью капт collection которая у которой прайма реки это но на основе на таймс темпе + a term потому что привлекаться реплики шин протокол в данном случае равно ровд этой винчи или consistent система то и данном случае мы получаем праймари 2 венчали кассе стасик андрей меньшими концерты значит они догонят праймари но когда неизвестно на самом деле и никто этого сказать не может но чем переходим к интересным моментом как собственно это сделан да то есть вот на закрыли теорию все вот собственно вот начинается все с того как примерно и вот в этой горе кластер там статье мы сначала вводим понятие кластер time вот вестер time это ну просто восемь байт каких-то данных они по счастливому случайному стечению обстоятельств можно конвертировать их в 2 4 байт них значения которые в общем-то и описывают the mist and вот то есть фактически мы приходим к тому что вот этот кластер темп может использоваться как ключ в о plague которые используются для репликации вот то есть таким образом мы какую-то абстрактная time spent который находится в блоге можем превратить кластер там но понятно что для того чтобы она была именно кластер там его нужно каким-то образом распределять до между нодами вот и для этого ну для каждого мода включает драйвера включая раутера включая праймериз с ндс каждый из участников кластера они все у них на них всех работает некоторые синглтон который просто вот у него задача простая он содержит всего лишь одно значение текущей кластер time и он это значит это значение используется при передаче при общении с любыми другими нодами то есть каждая вообще команда каждое сообщение монк тебе она переносит с обозначение кластер теперь 36 без исключения практически вот таким образом когда not получает вот этот массаж с этим кластер там он просто синхронизирует часы одно довольно важное отличие вот скажем со статьей lan-портов заключается в том что часы просто синхронизируются не увеличивается значение вот этого к утра если мы возьмем систему только с 85 до то не будет происходить никаких изменений часов то есть он все время будет 0 на самом деле 0 какой-то вот одно значение которое было изначально максимально но в конечном счете установится там среди них все они тикать не будут сами по себе вот нужно их заставить тикай ну как мы будем тыкать поскольку это вообще up log кита естественным образом тикать будет когда у нас увеличивается значение когда происходит запись waplog мы собственно увеличиваем значение вот этого timestamp и таким образом автоматический лечим значение кластер то вот пример да происходит и сорт какой то я не стал писать полный форм потому что это в общем то неважно допустим это какой-то вот абстрактное значение 4 вот у нас уже значение 5 и 6 там есть вот ну и обратить внимание вот волк лог наверху да там на крышке вот этой вот цилиндр который собой как бы символизирует базу данных вот там волколака dance это сделано что просто показать что а вот это не просто такое вот прямолинейного увеличение значение аккаунта он еще синхронизируется с часами то есть если часы они впереди то он использует значение именно вот там с ним под что это эпоха да и бог и какой-то инкремент вот и пока просто секунды там 1080 года он возьмет это значение туда запишет и соответственно пример вот примерно вот так это будет выглядеть вот ну и вот теперь после того как мы знаем что часы ходят на всех нотах и они распределены распределяются по всем ногам ну соответственно ходит она также означает что когда стартует шар дали реплика сета инициализируется вот эти вот встроенные часы с тем значением которые сейчас находятся в блоге вот теперь его нужно еще и сообщать да вот опять мы пока что идем вот один в один собственно та статья и вот как это сделано man где пока ничего нового нет мы к нему придем можно пока этого не происходит ну соответственно нужно sap отсылать назад когда каждое сообщение это не кластер там это именно перешейками то есть operations in time это значение вот ключа в блоге в тот момент когда эта операция выполнилась и она может быть на самом деле меньше чем кластер то где кстати говоря у меня явный баг потому что мастер там не может быть один себя нужным 11 сейчас это только заметил вот есть кластер тайма но всегда больше либо равно чем operations to me по определению потому что першин тайма но значение а плуга таймс темпа apple оптом стенку он вырастает уже из кластер там кластер там он является вот этим именно тем к утром который использует для инициализации облагает вообще был очень удобно для реализации потому что вся вот эта механика работала то есть там было просто использована некоторые независимо какой то kontra мы его заменили вот именно на на класс тортами и все остальное осталось таким же это кстати говоря очень помогает вот всяким существующем уже утилитам которые скажем делать backup recovery да не делал backup интайм или recovery он там если бы вдруг поменяли вообще ключ во флаге на виртуальные какое-то время 8 байт на который был просто бы абстрактный какое-то число то все бы то сломалось и ну наверное был бы можно понять само вас не очень хорошо когда backup нельзя делать ну вот соответствие вот эта операция там она возвращается значение его плохо в тот момент когда было произведено это операция чтение или запись есть некоторые тонкости в частности если чтение скажем всю но вернет именно маджоры confirm and tried а если она просто local то она вернет лао колорит вот тут есть нюансы но в суть этого заключается в том что это при этом соответствует моменту выполнения команд причем это включает в себя ошибки это включает я все что угодно exception-ы так что если вы будете играться или использовать мангу тебе 36 и увидеть что перешли ко мне вернулась в результате команды то можете смело файлик бак вот этот баг все на должна возвращаться всегда вот ну и осталось последний момент то есть у нас уже есть система распределения у нас есть система тика и осталась вот мы возвращаемся значения которые происходят момент команд теперь нам осталось сделать так чтобы когда произошла какое-то событие пришел запрос скажем на secondary до чтобы он дождался вот собственно того времени которое необходимо вот это поскольку это блок сделать достаточно просто вот передается такое значение автор кластер time эта часть реткон серна вот то есть при в некоторых команд можно передавать элит контер вот в этом рядом консоль не добавили дополнительный аргумент авто кластер так и не стал писать эти детали то есть это не столь важно вот этот автор кластер там он передаёт то значение окрашен танк который был в предыдущей команд они таким образом получается взаимосвязаны вот и когда вот она уже приходит собственно вот на ну предположим данном случае the secondary вот он начинает ждать пока жена о блоге не появятся вы собственно это вот значение как только она приходит в команду она блокирует потому что все ingresso перешли на ней блоки когда игоря с не было меня синтез то есть она в любом случае там чего-то ждёт и вот она дожидается вот этого значения и возвращает уже его назад в данном случае скажем пришло 11 то есть там больше либо равно вот это вот в принципе как бы все да вот вот мы сделали оно должно по идее работать вот но не совсем все так просто сейчас мы переходим уже к интересным вещам а именно что произойдет если у нас есть пользователь который посылает вас скажем вот такое значение его можно послать правильно это ну 24 обаятельных каких-то значения причем ну понятно да последний из них на единицу меньше максимально возможного вот это jeans and все вот если предположить что вот та система которая писал от работает как она написана происходит что у нас происходит присвоение вот лучше кукла вот этого значения которое пришло кластер time потому что она больше чем все что было до этого вот а дальше ну вот что у нас просто происходит запись инкремент этого аккаунта до максимально возможного запись его waplog потом это возможно еще все реплицируется вот ну и вы понимаете да у плох он не может никуда назад и те и вот происходит вот такая вещь то есть это в принципе довольно серьезный такой end of the game сценарию то есть реально вот game ower то есть после этого тут все что можно сделать это вот как-то выкл и выгрузить все эти данные там как-то там починить свернуть и так далее вот но соответственно поэтому один из таких важных вопросов о том как же сделать так чтобы собственно вот этих сценариев не происходил потому что никто не хочет чтобы я не знаю был пользователь который имеет привилегию послать pink который тоже переносе собой какие-то данные вот он посылает этот pink после этого базы данных не работает причем он может точно рассчитать время когда нас ломается на то есть все вот что мы стали делать для этого мы решили что решение которые мы используем это подписывать значение кластер time вот это ведь маг и сочи иван подпись вот если него требуется хэш генерация хаш по ключу да пребудет с хэштег для кота или который позволит этот signature генерить вот вот это вот решение позволяет полностью избавиться от этой проблемы это подпись можно сделано быть только в тот момент когда собственно время это ну увеличивается вот после этого на просто переносится вместе с со значением естественно когда она приходит в манга откуда там он где или мангой останова лидирует то есть поскольку мы предполагаем что все-таки но ты сами находятся внутри защищенного периоду там будут внутри бинарный код у них никто ломать не будет тому что если он может он может и так сломаю вот то соответственно манга ест лимон где они могут получить эти ключи и могут собственно пересчитать вот эту сильную и сравните ее с тем который приходит запросе если они совпадают то позволит увеличить аккаунтор вот этот вот эти лоджик кукла вот это вот собственно как это работает то есть кажется достаточно просто на самом деле тут существует ну кучу просто тонкости это вообще чуть ли не 25 процентов от всего код который написан он связан во-первых с тем что нужно как-то добавлять вот эти ключи да то есть они не могут просто из воздуха появится они не могут быть везде одни и те же то есть они генерации у них там есть способ здание там чистое место они перегоняется потом не манга я с ним он ga-de не могут запуститься если это реплика след пока у них нету ключей то есть там кучу всего вот этого есть вот управление вот этими событий но в результате все это ну как то так срослось и работает вот ну понятно что тут были такие моменты скажем если у нас кластер до шарлиз кластер то один запрос как минимум до не будет авторизированы кокаину получить ключ как нам он gs получить ключи ключи генерится на либо на конфиг сервер лина направили реплика сайт если это ни шага кластер вот то есть получить этот ключ требуется уже запрос который не подписан вот мы тоже обходим потому что если мы можем понять когда запрос приходит изнутри система когда вовне если он изнутри мы не обязательно требует мы можем отправить tommy kid ну вот это вот один из таких важных моментов тоже долго кластер там он везде передается он кешируется драйвера он сохраняется на драйверах ну вот дальше еще может быть такая ошибка как скажем оператор ирак то есть пришел админ и написал скрипт который скажем там adjusted time на всех машинах и допустим он вот он поставил на год вперед просто ошибся и в этом случае мы можем получить вот совершенно легально можем получить вот такую вещь поскольку это все-таки внутри периметра да то есть но все сады может все что угодно может произойти вот такая вещь вот это тоже в принципе позволяет как-то приблизиться вот к этому вот а сценарию когда game over вот и мы тоже от этого защищаемся тем что просто сравниваем значение wall clock и значение кластер там если кластер там слишком сильно впереди мы ограничиваем просто рейд и возвращаем ошибка настраиваемые функции то есть если вдруг там что-то пошло совсем сильно не так то это все можно как-то вот починить подстроить вот ну и соответственно данном случае будет ошибка теперь мы говорим про то ну понятно что подписывать каждую из этих значений на всех запросах это вообще чудовищный просто overheat потому что вы представляете себе что будет если все запросы которые происходят происходит валидации этой подписи и по и подпись когда insert вот соответственно мы пошли по пути подписывать именно range времен вот сделано это следующим образом то есть допустим и кэшировать это значение именно на основании ключа time раньше во что такое там лишь ну допустим нас пришел некоторых fight в котором есть кластер time какое-то значение да и сильнее чем то есть мы просто вот там не гейтс так так берем и делаем пор и забиваемся последние все последние то там два байта в данном случае забиваемых просто единичками соответственно они все будут равны друг другу вот ну и вот таким образом мы там увеличиваем вот эту производительность на потенциальном 10 раз ну точнее больше мы этим можно это можно как-то двигать туда-сюда в целом вот это основная идея вот вторая вещь который использует а использовать даме сильно часть то есть мы можем предположить что у нас есть пользователи которые живут закрыта перед рей у них доверие есть своей системе безопасности которые ограничивают всех каких-то непонятных запросов снаружи поэтому для них мы тоже можем сделать что-то чтобы они могли жить нормальной и не не испытывать этого вверх основная идея состоит в том чтобы использовать там висит на час который не требует компьютер на верх это не просто генерят что-то из то есть они уже даже не killed ничего не просто до записывает какое-то вот дефолта вы и значение то есть и второй стоит это использовать во первых когда они не включен authentication то есть мы предполагаем использую не пользуясь индикации он не пользуется в двух случаях первом вообще все равно индикации можно сделать очень много чего базы данных и даже не нужен так изощряться и ломать кластер из один случай с учетом рычаг его не так просто и сломать это потому что он будет два ограничивать приходится несколько раз вот такие вот делать прыжки вперед 2 случай когда вокруг уже существует периметр и внутри уже все хорошо и не нужно об этом беспокоиться . дим подход а второе это вот специальные есть привилась которая 20 стр там ее можно дать пользователь может создать роль сытой приведешь потом эту роль гарантий каком-то пользователю соответственно и пользователь будет иметь возможность не подписывать все свои данные ну и вот мы уже на самом деле так вот заканчиваем как конечные пользователи вообще все это виде то есть видит довольно большая механика у нас есть часы и они между собой как взаимодействовать там теку это так далее вот а все для пользователя это все завернуто в сессии мацесте это новая штука которая появилась в 36 вот оно появилось а в драйверах вот в данном случае это пример и сшил если возьмете там россии давай our secret то есть принципе можете вот даже с этим попробовать что-то поделать вот и вот просто старт он создает уже позвать позволяет делать именно казуал consist он сказал конце здесь стать необязательно он по умолчанию труп успешно позволяет и другие какие-то вещи включать но в данном случае просто привел пример именно для кузова конце снасти вот то есть получается вот объект беби бон где бельдиби позволяет посылать команды то есть дебет и ты без данном случае ноге да вот и вот все вещи которые вы с этим дтп с могут происходить они уже козы ли consist in по умолчание чего не надо делать вообще старца шины все вот как бы заканчиваю уже да вот пример вот возвращаемся саму ферму в эту примеру когда пользователь кладет деньги банка да то есть если applications на 36 там и начинается с командой star цешин а дальше все тоже самое то что произойдет то есть вот этот файл который туда придет он вместо того чтобы немедленно вернуть данные до секунды он будет ждать пока вот центре догонит хотя бы вот тот вот три кают time as primary да вот и вот после этого он уже вернет и все будет хорошо вот ну вот этого то что хотел вам рассказать а теперь я готов если есть вопросы на них ответить спасибо большое за доклад очень интересный вопрос следующий у нас есть собственно шарнирный кластер в нем несколько реплик ассетов несколько waist and woman г с а кто из них является источником собственно времени кластера и если запрос например с мангой с уходит только в один рипли кассет по ключу как получается что время всего шарда синхронизировать отличный вопрос спасибо значит первый вопрос источником тиков является прайма рис на реплика сетах всегда вот ниоткуда прийти это не может извне но может быть за одним исключением там можно через сессию установить но вообще внутри систем когда она уже запущена тикают именно праймериз на реплика сетах второй вопрос просто вот отличный как шарды между собой договариваются о том какое у них время да потому что можете представить ситуацию когда у нас скажем есть 10 г с разговаривать с одним шар дом там даже другой мангой с разговаривать с другим шара дом в штате session они позволяют передать общее значение вот этого кластер таймс одной сети в другую это возможно это работает мы хотим чтобы казал конце ственности работала не только в 1 сессия сразу вот во многих сессиях да и вот он предположим даже для примера что были данные какие-то на первом шарди которые мигрировали куда-нибудь да и вот вообще они не касаются вот этой сессии этого драйвера да вот кажется что не будет работать на самом деле будет и главным синхронизационные в данном случае механизму вот таких сценариев является то что то есть там возможно 2 ситуация первое события между собой связаны или они не связаны то есть если они конкурента вообще все равно вот если они не конкурент то у нас произойдет если вы узнаете да есть такой стрел shard вершин exception ну она может не для пользователя но внутри когда происходит какой-то запрос для синхронизация метаданных каждый запрос присылает собой шар вершин то есть это вот значение некоторые значения которые присваиваются там чан кули collection в тот момент когда происходит этот запрос и recipe and out at у получателя то должен ответить на таком он сравнивает вот эти значения lip сам себя обновляет ли присылает вот этот exception вот на основании этого то есть на самом деле у нас получается такая ситуация что даже если данным такое от мигрировали и так далее у нас будет вот это вот стрел shard вершин и соответственно sharp ну будет вынужден синхронизируется через конфиг сервер и на самом деле таким образом он дождется вот пока эти данные туда придут которые либо ушли ливни пришли вот это я думал эту схему сделки потом понял что я вот 15 вопрос потрачу рассказывая как это все работает но вот она работает и ключом является именно то что помимо вот синхронизации часов на самом деле еще работает синхронизация метаданных и вот этот синхронизация метаданных а но вот именно догоняет время вот в этих сортах когда они между собой разные независимую вот этот стать и делает вот это время глобальным так что вот хороший вопрос спасибо сил мог не рассказать можно вот я уточню базовую идею то есть я скажем записал допустим на каком-то шов где один набор данных потом той же сессии находясь читаю какой-то другой набор данных то используя вот эту концепцию получается я буду ждать до тех пор пока дата реплики в которой читаю второй набор данных не доедут изменения от 1 до хотя они словно логически с моей точки зрения как разработчика приложения не тому что не ferrum ну да и нет не совсем так то сиди и заключается в том что если у вас есть реплика сайт но и сортированный там кластер и она представляет собой как некая единая система нет его мне нужно знать топологию вам не нужно что является провели что является secondary то есть вы поставить что-то записали и потом вы можете это прочитать не важно куда это запрос будет перенаправлен вот и вот основная идея заключается в том что построить сделать такую возможность что когда у нас чтобы запись и чтение скажем были между собой взаимосвязи чтобы чтение скажем но это как пример потому что может быть им она тоник рецепт абсолютно все тоже самое но мы говорим сейчас review раз примерно чтение который происходит после записи после указать данные обновились если оно не пришло скажем на пара фрай моря пришло на secondary она будет там ждать ввиду этого всего механизма пока эти данные туда не дойдут причем на не будет ждать все данные там могло произойти еще миллион каких-то обновлениях да вот после первого запись они не нужно сдать всего то есть это не там пятна джарите то есть и так далее она экономичным по максимуму там нету лишнего какого-то понятно что одним из простых способов будет просто вот ждать вообще-то бесконечный а потом делать систему ты меньше или consistent и она туда придет в какой-то момент данном случае ты просто гарантии что она будет ждать ровно столько сколько нужно когда вот эти результаты туда дойдут вот почему ждем на о блоге потому что флакон просто держите все операции до которые произошли с манга тебе они просто меняют состоянии собственно этой базы данных да то есть обретать этот стыд и если вы меняли какую-то collection там где то до то эти данные будут в этом блоге они соответственно будут уже применены нас и гондри в этой коллекции нины поэтому вы ваш запрос сработает так как мой вопрос скорее был про то что не будет ли какого-то дополнительного overheat а связано с тем что я поработал с одной коллекции логически выполнил культа одну задачу по то находясь той же сессии делаю какую-то логическому не связанную задачу будет конечно вот и получается в один там будет оральный вопрос хороший будет это будет верх от нас по поводу оверхедов тоже я хотел добавить а мы измерим то есть пока что нет просто вот таких вот совсем красивых результатов что можно был график нарисовать ну там принципе все внутри 10 процентов пока что так что хорошо ну ты увидишь большое спасибо за доклад от меня такого просто не продолжение вопроса выполняли процессе и вот на одном из слайдов а что будет если у нас есть несколько клиентов один клиент пишет другой допустим читает ну сессии они тоже значит как драйвера к этому подошли а вот вообще потому что я рассказал сервер еще есть драйвера в них вообще другие приоритеты другая точка зрения на мир и так далее у них там ну не просто свои задачи которые они решают и эти задачи они дополняют серверные но не обязательно такие же соответствия драйвера делают они внутри сессии они смотрят за этим trace into mine который приходит и обновляют его вот внутри на самом деле на уровне манга клиента они держат вот именно кластер то есть кластер тайн долларов мастер там это глобальное кластер на и время она как бы общие для всех то есть ну может так себе представить вот эта операция там это кластер то в прошлом на какую-то операцию до а вот кластер там это значение часов appear in the mind вот когда последний поезд ушел вот соответственно сессия если у вас две сессии которая одна пишет другая читает вот есть метод у сессий advance кластер там но вот скажем цели и вы можете этой реализовать таким образом то есть будет но можно получить вот эта пережитой можно сделать advance кластер timely 1 ст операцию tempus сессии могут между собой разговаривать и передавать вот эту вот информацию про позолоте между собой решить можно вашу задачу но может быть будет небольшой вверх от но он не должен быть очень большой потому что то принципе синхронизация данных внутри вот между месяц сессии то есть после того как вы сделали райт когда вы хотите сделать рид вам нужно убедиться что райт помимо райтон еще и отдайте другую сессию и говорит итак следующий ряд должен произойти только после того как времени которое я сделал после райта я должна знать другую сессию ну если они совсем независимые да надо знать то есть они должны как-то между собой разговаривать но она не будет казались сзади pendant аму что она не будет знать operations time который пришел с первый вопрос такой зачем нужно было использовать этики то есть какой-то привязка как он все-таки времени когда вы решили использовать логической векторные часы можно использовать зачем нужны эти векторные часы они учитывая что он уж ардак может быть очень много это очень большой вверх от но мы думали про векторные час это вполне нормальное решение если в там два или три шарда если их 1000 то вы представляете себе что каждый раз тащить вот эту тысячу значений с каждым сообщением это просто не будет работать чисто по этой причине скалярное скалярное часы нормально работают вот то есть это было сделано за этим текке они мне кажется хорошее решение потому что она просто используя топ лук как и реализатор вот этого вот парализаторов ивентов нам не нужно ничего делать для этого вот ну и соответственно позволяет вообще использовать вот этот кластер time для очень многих других вещей там она принцип потом поставку снова добавили она стала используя других проектов так у довольно активно для именно синхронизации вещей которые происходят внутри кластера спасибо за доклад два вопроса первый вопрос какой версии это все в 36 правильно только до 36 вот это уже есть риска на второй вопрос по поводу сессии так далее возможны две блоки в этом случае возможны ли мне кажется что возможно нет предлоги какие если мы открываемся одну сессию ретро it апдейт то есть классический случай вот если мы открываем сессию то одна из них будет ждать на какой-то один кластер time другая будет ждать ее же она тот же кластер times то есть в это даже возможно d блок блок значит то есть в зависание сессии потому что вот этого кластер тайма нет и не будет опять же вот прям спасибо за вопрос вот иначе я чувствовал что что-то забыл сказать а mongo db в той ситуации когда она получает запрос скажем и видит что там есть автор кластер там этого кластера той монету в блоге вот нету манга тебе она не знает придет он не придет может быть как раз такая ситуация когда у нас была одна сессия который разговаривал с одним шар дам шарах понятно что там есть не синхронность там можно в 11 писать миллион записей у него часы идут вперед все вот и вот допустим исписали до 1000000 записи он получил этого перешли томи потом с этим операциям adsense делает запрос другому кластеру группу другому шар допрос другой ключ например ну что в этом случае произойдет вот он сделает но проекта есть он придет он поймет что нету такого времени в блоге и просто сделает уже часы тоже будут обновлены и он просто сделать запись и таким образом эти часы догонит он не обязательно должен скопировать все данные потому что у него нет указал relations relations но он сейчас и таким образом догонят и они его папа блоге установятся в нужные значения у сможет ответить ну просто он вернет эти значения которые там были и которые там должны были бы быть если бы это был козырь и life поскольку они не козыри light но просто переставить часы куда надо и ответит иннуся что будет работать но хорошего просто раз спасибо да ждать он лежать он не будет он просто делает но про это не там все ну как бы синхронизируется то есть если предположить что там миллион запрос пришел будет только один но про это не там все разблокируются когда он совершиться тогда если не послушаться вроде поменялся вроде бы пытался раз на картинке с обзором архитектуры и если он там и зачем что остров был его упомянул ровд я его плюнул только из соображений что это и меньше или consistent это на самом деле абсолютно не принципиально то есть его раб не является принципиально в данном случае просто но есть некоторые способ репликации которые используют up log вот я как бы упомянул что ну манга тебе использование которую модификацию рафта для репликации вот по крайней мере вот один из вариантов нас есть и другой вариант который более старый ну раз вопросов не давайте поаплодируем спикеров зима спасибо всем что пришли хорошо вечера вот"
}