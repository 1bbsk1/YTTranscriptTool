{
  "video_id": "h8UIX94XJGc",
  "channel": "HighLoadChannel",
  "title": "Поиск проблем в базе данных, если ты разработчик / Алексей Лесовский (Coins.ph)",
  "views": 1304,
  "duration": 2963,
  "published": "2023-01-19T06:56:45-08:00",
  "text": "всем привет меня зовут алексей лисовский как меня уже представили и в ближайшие 30 40 минут я буду рассказывать про то как искать проблемы и устранять на стыке приложений и баз данных пару слов о себе кто и такой я в индустрия идти с 2005 года многое долгое время работал администраторам баз данных и начинал системным администратором веб-разработки последние семь лет я работал с крестовым дуба и каждый день сталкивался с адресом и все мои предыдущие доклады они как раз таки и относились как подгрести рассказывал для подгрести став сейчас я работаю уже разработчикам занимаюсь автоматизацией опишу нога но по привычке занимаюсь и пожгли сами и мониторинга me работаю я в компании coins эта компания осуществляют финансовые услуги странах юго-восточной азии о чем будет доклад как я уже сказал все мои предыдущие доклады были связаны способе сам как пользователь пожгли со администратор для администраторов учитывая что сейчас я занимаюсь разработкой то я могу взглянуть на эту сторону со стороны разработчика и доклад будет как раз таки про то как искать проблемы в приложении на стороне разработки и разработчика говорить буду много быстро доклад будет много слайдов поэтому запаситесь заранее какими-то ручками блокнотами чтобы записывать чтобы потом можно было задать вопросы поехали когда мы работаем с базой данных со стороны приложения у нас возникают разные классы проблем и наиболее часто возникающие проблемы это какие-то ошибки я думаю что многие здесь и из вас сталкивались с этими ошибками они как правило встречаются в логах приложения мы видим какую-то ошибку и наши приложения просто не работает не делает то что должно и разработчик должен это исправить если у нас есть какая-то система мониторинга мы можем мониторинги надо же бордах увидите ошибки но если самом худшем случае когда нет ни логов не мониторинга у нас могут быть какие-то клиенты которые ходят и жалуются либо может быть коллега какой-то по отделу либо руководитель тимлид который будет стучаться нам в личку в телегу там uslug куда угодно и говорить что у нас что то не работает что делать в таком случае сам простой способ это ставить гипотезы подтверждать их либо опровергать то есть нам нужно выяснить действительно ли проблема в базе данных нам нужно идентифицировать то место в программе где возникает ошибка и убедиться действительно что запрос отправлены в базу данных возвращает ошибку то есть нам нужно найти функцию либо это обработчик какой-то хендлер где возникает взаимодействие с базой данных и убедиться что проблема именно на стыке базы данных если вы как разработчик хорошо знаете свое приложение и вам не досталось какой-то старая legacy то вы в принципе этот шаг довольно быстро пропускаете уже заранее примерно представляете что да это действительно база данных проблема где-то в ней и вот этот шаг довольно опускается ну пропускается довольно быстро и когда мы ищем ошибку вот именно на стороне кода где она возникла хорошим инструментом являются графики которые показывают статус и обработки вот этих запросов которые вызвал пользователь при обращении в наших приложения и вот этот вот график он является хорошим инструментом если привести в пример и какой-нибудь и сетевые приложения то хорошим примером такого графика будет обработка запросов и статус и ответов эти типы ответов по каждому and point у то есть это довольно таки хороший график который хорошо показывает в каком хен двери возникла ошибка и сколько их и насколько это серьезно другим хорошим источником данных являются логе и особенно хорошо если у нас есть какое-то централизованное хранилище сбора и хранения логов типа там ел кфк может быть еще какие то вещи там treehouse и какие-то инструменты которые позволяют обращаться в это хранилище с помощью структурированного языка запросто извлекать оттуда данные по ну пологом это может быть кем она может быть тире дэш может быть еще что то соответственно в это централизованное хранилище у нас стекаются влоги со всех наших приложений и мы можем одним запросом вытащить влоги со всех инстансов приложений и нас в конкретном случае интересует ошибки интересуют текст ошибок какие то возможны и детали относящиеся к этой ошибки самом худшем случае если у нас нет ни мониторинга не системы сбора хранения логов то нужно быть готовым к тому что придется подключиться к тому серверу где выполняется приложение и база данных и воспользоваться консольными инструментами для обработки и поиска там данных в текстовых логах это могут быть всякие разные консольные утилиты типа греев с и тафты вот все те утилиты командной строки ok допустим мы идентифицировали место в приложении мы поняли что даст запрос выходящих плела в базу данных возвращается с ошибкой или что нужно делать дальше во первых когда мы работаем с базой данных нам нужно эту же ошибку найти ну ошибка которая возникла в приложении нам желательно найти ее в пол игры сью то есть установить однозначную связь приложение и базы данных и в этом случае при разработке приложения стоит уделять внимание тому как мы обрабатываем входящие ошибки от наших зависимых сервисов то есть желательно ошибки прокидывать в том же виде и сохранять их в лоб в том же неизменном виде нежелательно как-то маскировать изменять добавлять какие-то отдельные поля чтобы ошибка у нас как-то изменилась совсем и была не такой как она возникает например в базе данных соответственно если у нас централизованное хранение логов нам нужно поискать в этом интро и зова нам хранилище логе базы данных если такого хранилища нету то придётся искать логе базы данных на сервере где работает базы данных и дополнительно мог возможности придется еще подключиться к базе данных для выполнения там каких-то дополнительных действий может что-то нужно посмотреть перепроверить какую-то статистику для этого можно воспользоваться консольным клиентам ps клей который идет в стандартной поставке после со либо можно воспользоваться плагином для работы с базами данных из нашей любимой и даем и выполнять все действия там когда мы ищем где находится логе под криса мы можем воспользоваться встроенной в паз grease функцией pg car and log file она покажет где находится log но эта функция она существует в новых версиях полисов более старых версиях под колеса придется посмотреть расположение logo с помощью параметров конфигурации пожгли со вот но к счастью к счастью все логе лежат в более-менее стандартном месте и the warlock по загривку эль практически в девяноста процентах случаях логе будут лежать именно там имя файла может быть отличаться но каталог примерно будет так есть небольшое исключение возможно администраторы системы или любые какие-то другие люди которые администрирует сервера баз данных они могут изменить расположение каталога где хранятся логе но это довольно таки редкий случай что нам нужно искать в этих влогах в лаках у нас как правило есть много записей и все эти записи имеют какую-то какой-то уровень важности и нас в данном случае интересует все сообщения с уровнем важности выше орден га это ошибки сообщения по не как фатальные сообща фатальные события какие-то взаимо блокировки если postgres настроен дополнительно логирование настроена там и в этих же логов ищем информацию об ожиданиях какие то долгие запросы и временные файлы которые сказываются на производительности но опять же отмечу что вот эта дополнительная информация была влоги postgres нужно отдельно до настроить и во время поиска нам нужно понять и вообще общую картину происходящего мы должны построить некий топ ошибок за какой-то интервал времени например за сегодня за последний час если ошибка возникла вот более-менее сейчас нам эту картину происходящего нужно сравнить с тем что было с такими же предыдущими периодами времени то есть нам нужно посмотреть как долго существует это ошибка и как долго мы с ней живем может быть такая ситуация что ошибки копились какое-то долгое время и вот сегодня они просто перевалили за какой-то критический порог и стали уже вытянул совсем откровенно заметными и мешать работе вот такой простой относительно командой консольной можно сделать ну топ ошибок и злоба то есть мы берем ошибки сортируем их и берём уникальное значение считаем количество вхождений опять сортируем у нас получается топ ошибок у нас есть текст ошибки и есть количество вхождений то есть у нас есть какая-то суммарная сходная картина о том какие ошибки у нас в сервере су где происходит мы можем такую информацию получить из централизованного хранения логов либо из консоли либо из другого места где у нас собираются логе и когда мы столкнулись с конкретной ошибкой в приложении и в базе данных мы нашли взаимосвязь между этими ошибками нам нужно найти время возникновения первые ошибки и желательно представлять контекст происходящего в окружении которым работает наше приложение то есть желательно ну это не обязательно но желательно то есть знать о том что происходило может быть были какие-то тепло и приложения может быть менялась конфигурация может быть еще что-то происходило то есть знание таких деталей нам позволит лучше проводить анализ и разрешение проблемы кроме того если говорить про позарез нужно отметить что пост брyса есть хорошая привычка каждое сообщение об ошибке сопровождать деталями и подсказкой как устранять эту ошибку это справедливо не для всех типов ошибок но для многих из h бог это действительно и когда мы ищем ошибки в подгрести нужно помнить об этой особенности и всегда смотреть следующую пару строчек чтобы увидеть что там под гриф нам подсказывает что с этим делать и на практике получается так что ошибок в подгрести может возникать самое большое количество и каждая такая ошибка она имеет свое отдельное решение нет возможности у универсальным способом решить большой класс каких-то там не связанных между собой проблем и как правило мы находим ошибку начинаем искать ее решение в интернетах на stackoverflow где-либо еще там у коллег спрашивать и как правило находим какое-то индивидуальное решение на практике часто бывают ошибки связанные с неправильно написанными запросами ошибки синтаксиса часто бывают ошибки связанные с нарушением уникальности когда приложение пытаются вставить какие-то строки в таблицу при этом нарушается первичный ли уникальный ключ и база возвращает ошибку бывают ошибки связанные с отсутствием схемы то есть мы со стороны запроса пытаемся обратиться какому-то объекту бы тут таблица функция представления но не указали схему ip-адрес просто не знает дескать этот объект возвращает ошибку бывают ошибки класса подключения к базе данных обычно это неправильно указанные реквизиты либо неправильно взятые реквизиты там из места где они хранятся например какой нибудь волки что-то подобное с em am a зоновский то есть проблема и здесь обнаруживается довольно быстро на старте приложения потому что приложение не может установить соединяет базе данных и она сразу бросает исключение проблемой справляются простым способом просто меняются реквизиты подставляются нужно не проблема исчезает ошибки доступа тоже довольно частая проблема особенно когда в компании появляется какой-нибудь рьяный администратор баз данных и начинают переводить все в порядок он начинает приводить права доступа в базе данных и неаккуратно может снести какие-нибудь права и у приложения исчезают права доступа к таблицам к выполнению этих то функции схемам и так далее я обычно эта проблема решается на уровне взаимодействия разработчика ip-адрес нового дыба одна из самых частых ошибок который возникает именно в контексте эксплуатации пожгли со это проблема отмены запросов на реплики очень часто у нас есть мастер и есть желание разгрузить мастер и вынести часть нагрузки на реплики для этого создаются отдельные реплики и запросы на чтения отправляются на реплику запросы выполняются нормально но в какой-то момент они начинают выполняться слишком долго ip-адрес начинает их отменять вот с такой ошибкой здесь возникает конфликт выполнение запросов и репликации запрос может работать долго он может прочитать какой-то блок данных но в это время по репликации приехали точно такие же ну такие же данные которые хотят изменить этот блок возникает конфликт пузырь из начинает отсчитывать тайм-аут по умолчанию 30 секунд если запрос не успел выполнится за 30 секунд то postgres его принудительно отменяет приложению отправляется ошибка разработчик видит ошибку в таком случае у нас есть некоторый диапазон действий которые можем применить бывает что запрос выполняется долго потому что нет какого-то индекса в этом случае но это самый простой случае мы просто достраиваем индекс на мастере он реплицируется на реплику запрос начинает быстро выполняться проблема исчезает но часто бывает так что реплики используются для какой-то аналитики мы хотим выполнять на реплики какие-то четные запросы которые читают большие объемы данных и выполняются ну просто не быстро в таком случае мы можем захотеть увеличить этот тайм аут и дать пас grease у возможность дольше ждать когда выполнится запрос но при этом у нас получается риск появления логарифм акации и здесь мы должны выбирать у нас либо лака репликации и выполнение запросов либо у нас маленький лак репликации но при этом ошибки при выполнении запросов здесь нужно выбирать зависимости от требований к рабочей нагрузки со стороны этом бизнеса либо продукта есть еще отдельный вариант мы можем сделать отдельную реплику увеличить тайма оптом на максимум и гонять там наши аналитические запросы но при этом как бы там будет большой лак репликации и это можно как бы считать допустимым домашнее задание для вас как для разработчиков в ваших в приложениях должно быть логирование ваше приложение не должны молча игнорировать какие-то исключительные ситуации какие-то ошибки обязательно должно быть логирование многоуровневая и если какая-то ситуация на уровне базы данных возникает вы должны об этом знать желательно чтобы логирование было динамически изменяемое чтобы у вас была какая-то крутилка которую вы можете в ран тайме извинить и извинить уровень логирования это встречается довольно редко я видел такое всего один или два раза когда уровень логирования в приложении менялся через отправку post запроса на ешьте happy end point это очень удобно для каких то целей отладки чтобы не перезапускать приложения где то в каком окружении с измененными флагами планирования плюс желательно проверять логе базы данных на предмет ошибок если у вас нету штатного дыба и задача по обслуживанию база данных ложится на разработчиков там то лучше сделать это самостоятельно потому что бывает очень большой объем ошибок накапливается в базе данных и когда мы сталкиваемся с какой-то реальной проблемой эти ошибки они мешают поиску реальные проблемы плюс нашем приложении должны быть метрики метрики помогают нам отслеживать то как выполняются запросы с ошибками или без ошибок следующая проблема это тайм-аут и симптомы таймаутов обычно но одинаковые в любой эксплуатации будь то база данных либо какое-то любая другая система какая-то операция раньше выполнялась быстро потом начинает выполняться медленно какой-то момент она приводит к ошибке ошибка падает флаг с текстом что-то там той mount либо если у нас тут olicity питу нам может вернуться 504 код ответа что делать в этом случае подход примерно такой же как и в прошлый раз нужно определить and point нужно определить функцию хендлер которая выполняет работу и убедиться что проблема действительно проявляется на при взаимодействии с базы данных окей допустим мы нашли эту функцию выяснили что проблема именно с базой данных и не связано с какими-то другими проблемами которые могут приводить в тайм-аутом и что делать в этом случае нам нужно посмотреть что происходит в базе данных и когда мы говорим про отслеживание активности в базе данных то самым главным инструментом который должен знать разработчик и уметь пользоваться это представление пгс that activity это системная вьеха с которой можно работать с помощью песка или языка это вот самый главный инструмент который вот разработчик когда он работает с под гриль сам он должен про него помните иметь ввиду что есть в этой видюхи у нас есть данные о клиенте откуда он подключился с каким именем пользователя какой базе данных у нас есть информация о времени жизни соединения как долго это соединение установлено так долго выполняется транзакция или текущий запрос нас есть информация о блокировках и ожиданиях мы можем находить информацию когда клиенты мешают работе друг друга есть идентификатор и текст запроса это самая главная информация которая понадобится дальше плюс есть идентификатор процесса в операционной системе и с помощью него мы можем присоеденять другие представления и получать дополнительную информацию это нам не понадобится дальше но вообще такая возможность очень полезная при траблу шопинге в паз gresso и когда мы говорим про наблюдение за тем что происходит в подгрести важно понимать что пгс о тактике предоставляет сырые данные которые не очень удобно смотреть вот как они есть и для более лучшего понимания что там находится лучше использовать какие-то как минимум скрипты либо более продвинутые инструменты примером таких скриптов может быть скрим baby activity от компании datagrid либо инструменты pg центры побег 9 которая интерактивно показывает что происходит в прогресс that activity и более в понятном интерфейсе вы можете понимать что происходит в базе данных давайте разберём пример скрипта db activity что он выводит мы запустили этот скрипт это обычная вскоре скрипт он выводит нам какие-то строки в этой строке нам важно увидеть что у нас есть какой-то запрос его текст находится внизу подсвечены зеленым и он выполняется 55 секунд то есть у нас есть какой-то пользователь который нажала где-то сайт на сайте кнопку либо в мобильном приложении запросу шел на backend бэкон сформировал запросов правило в базу данных и запрос выполняется 55 секунд то есть это ну довольно долго возможно что клиент уже давно ушел и запрос выполнять даже не надо не нужно выполнять эти ресурсы но он выполняется то есть здесь самое главное что у нас есть текст запроса и мы можем дальше уже пытаться понять почему он работает долго для этого мы используем второй инструмент который важен знать всегда важно знать разработчику и уметь им пользоваться и to explain это инструмент для отображения планов выполнения запросов в базе данных но пользоваться эксплей нам тоже нужен некоторый опыт и некоторые навыки там выводятся довольно длинная портянка текста с которую нужно проанализировать и при первом знакомстве с эксплей нам это может быть как бы довольно сложно но к счастью сообщество предлагает несколько инструментов для работы с explay нам и я всем рекомендую с ними ознакомиться тем более что тут есть инструмент от российской компании компания тензор у них даже интерфейс полностью на русском языке и многие пользователи как бы предлагают почему не сделайте английский интерфейс чтобы охватить большую аудиторию другим источникам ожидании этой маунтов могут быть так называемая idol транзакции эта ситуация когда приложение открывает транзакцию командой бегим что-то делает этой транзакции и не закрыв транзакцию уходят по каким-то своим делам дела могут у приложением быть самые разные зависимости от реализованной логике это может быть попытка сходить в какой-то соседние api в соседнюю базу данных чтоб получить дополнительное данное это может быть попытка отправить какое-то событие в шину или получить или обработать это событие может быть попытка там что-то обновить в к шее и так далее в самом худшем случае приложение может упасть с ошибкой и по стыку вызова функции откатиться назад и оставить транзакцию вообще брошенный эту ситуацию можно назвать утечкой транзакции когда приложение теряет контроль над ними то есть случаев может быть довольно много и решение здесь как правило несколько одним из таких решений является использование таймаутов если мы в приложении используем транспортные тайм-аут и на установку соединений на обработку учтите пересоединение то мы можем использовать такие же тайм-аут и на стороне базы данных и самым подходящим тайм-аутом здесь таймаут на простой транзакцией то есть мы можем ласты но и глобально если нас транзакция выпал он простаивает дольше положенного времени под глисты и отменит вернет ошибку в приложении разработчику видит ошибку в лучшем случае и попытается исправить проблему если мы 1 обнаружили а и дал транзакцию в процессе от trouble суть инга то хорошим вариантом считается просто завершить ее выполнения и чтобы сервер мог продолжить работу дальше но оптимальным вариантом является устранение таких ситуаций на уровня приложения чтобы само приложение не допускала таких ситуаций при работе с базой данных домашние задания при эксплуатации ваших приложений которые работают с базами данных ваших базах должны быть настроены прямо у ты по умолчанию таймаутов но практически нет есть один той малом только над и блоки у вас должен быть тайм-аут и на простой транзакции на выполнение запросов помимо того в приложении должны быть метрики по которым мы можем оценивать как долго наша активность выполняется ну соседних зависимых сервисах включая даже те операции которые в итоге завершаются ошибкой а плюс у нас под рукой всегда должны быть диагностические инструменты мы должны иметь какой-то минимальный инструментарий под рукой быстрого им воспользоваться оценить то что он показывает и уже как-то действовать по ситуации ожидания это другой класс проблем и по сути ожидания это более запущенный случай таймаутов если тайм-аут у нас о рубит активность по какому-то таймауту то есть базы видит что активность выполняются долго обрубает возвращает ошибку то ожидание это отсутствие таймаутов то есть активность выполняется долго непредсказуемо долго выглядит это так как будто приложения зависла и не отвечает ни чего не показывает в логах если мы запускаем приложение то ситуация может повториться сейчас может повториться через какое-то время зависимости от того что вызывает источник ожиданий что делать в этом случае здесь мы к сожалению не можем выдвигать гипотез о том где возникает ожидания и нам нужно проверять все зависимые сервисы которые используются в нашем приложении мы можем превентивно посмотреть в базу данных либо в даже борды и посмотреть что там происходит нам нужно смотреть на наличие ожиданий и на наличие блокировок мы пользуемся опять теми же самыми инструментами по которой я говорил в предыдущей части это скрипты поверх прогресс that activity и blogs плюс мы можем использовать какие-то свои скрипты которые но мы посчитали интересными в нашей эксплуатации либо можно использовать утилиту типа pg центры пабе activity также мы можем посмотреть наши логе на предмет строчки аквой рад логе именно с угоди мы можем видеть там примерно следующее что есть какие-то процессы которые захватывают какую-то блокировку на какой-то таблицы в какой-то базе данных спустя какое то время если вот верхних случаях там время ожидания составила 3 секунды где то может быть это приемлемо но все равно долго то в более худших случаях там время ожидания составила три минуты то есть опять же у нас где то есть там пользователь нашей системы он что-то там нажал сформировал запрос в приложение приложение отправила запрос в базу данных в базе данных этот запрос висит три минуты и чего-то ждет другим инструментом для обнаружения блокировок является также скрипт поверх пгс тот activity и по velox logs три дерева блокировок с помощью него можно строить зависимость процессов и запросов друг от друга и видеть их иерархию в структуре зависимые починю и блокировщик кто облака заблокировал и ожидающие те кто ждут завершения блокировщика соответственно когда мы видим такую информацию мы видим источник зла мы можем воспользоваться функцией pg термины backend и принудительно завершить работу этих процессов и дать возможность остальным продолжить работу но оптимальным вариантом является рефакторинг приложения и устранение этих ситуаций со стороны приложения потому что приложение генерирует нагрузку как правило такая-то конкурентная работа над одними и теми же данными возникает ситуация гонки и возникают блокировки другой источник ожидание это использование полов соединений полость соединение это специальная прослойка между приложением и базой данных которая позволяет экономить на установленных соединениях пулы бывают внешние виде отдельных программ типов bouncer одиссей либо менее известный п.г. а grow с таким сложным названием вот и приложение при работе с базой устанавливается единение именно к полу было к пулу соединений и работает именно с ним а пол соединение уже устанавливает соединение ровно столько сколько необходимо в базу данных и выдает их приложению и позволяет их переиспользовать есть виню внутренние пулы когда абстракция пула предоставляется какой-то библиотекой для работы с базой данных и такие пулы они встроены в приложении так в чем здесь проблема бывает так что пула недостаточно но мы должны об этом как-то узнать и понять и вот этот недостаток пула он выливается в ожидании в ожидании соединения при попытке отправить запрос в базу данных для оценки утилизации плов нам нужны какие-то метрики например внешним пулы как правило предоставляют какую-то статистику по которым ему мы можем это определить например pg балансире есть команда show us которая показывает статистику утилизации пулов например в этом примере мы видим что у нас есть 250 клиентов которые пытаются отправить какой то запрос но находятся в очереди ожидания и максимально ожидания составляет 117 секунд на графике это выглядит примерно так у нас есть какая-то полка то есть наши клиенты максимум ждут до двух минут в очереди пока пулом выдаст соединения если мы увеличиваем пул то мы как бы уменьшаем вот эту очередь ожидания и позволяем клиентам быстрее получить соединение чтобы отправить свой запрос но здесь нужно быть очень аккуратным и увеличивать пул нельзя бездумно потому что мы должны увеличивать plu согласно тем ресурсом которые у нас есть на сервере чтобы при большом потоке запросов мы не перегрузили сервер нагрузкой случае внутренних пулов ситуация чуть сложнее и такую статистику бывает получить не просто но мы можем сходить в базу данных подключиться к полюсу и посчитать количество соединений по каждому адресу наших приложений если мы видим какую-то ровную палочку одинакового количества установленных соединений то скорее всего у нас превышены пулы соединений в приложений и нужно уже менять конфигурацию драйвера bt на стороне приложения плюс дополнительно можно сходить в документацию по этой библиотеки и посмотреть возможно есть какие-то методы которые показывают статистику утилизации пулов из приложения и соответственно эти вещи желательно бы вывести виде метрик на практике причинами ожиданий чаще всего становится какой-то конкурентная работа и неожиданно возникшая а эта транзакция idol транзакция удерживает блокировки и мешает работе других соседних транзакций другие транзакции ждут когда закончится это idol транзакция чтобы продолжить свою работу и если не вмешаться туда самому ну не отменить эту idol транзакцию либо не завершите автоматически через тайм-аут то эта ситуация может продолжаться сколь угодно долго и приложение может также висеть в этой ситуации довольно долго другой причиной и часто возникающие бывают блокирующая ли заблокированная миграция когда есть необходимость поменять что-то в схеме данных и такие операции довольно тяжелые они берут тяжелые блокировки и все кто работают с этим объектом которые меняются в миграции все пользователи этого объекта также встают в блокировку и ждут когда завершится миграция бывают истории с неаккуратно выполненным операцией вакуум full на каком-то горящем объекте на какой-то таблицы когда вакуум full запускается он берёт тоже эксклюзивную блокировку и все клиенты которые работают с объектом тоже встают в ожидании и ждут когда вакуума закончится домашнее задание ваших приложениях всегда должны быть тайм-аут и транспортные типа на установку соединений на ожидание там ищете пике drop отправку тела и так далее вот но вместе с тайм-аута my вы в приложении вы должны использовать тайм-аут и на стороне база данных на простой транзакцией на выполнение запросов на взятие блокировок то есть все тайм-аута желательно использовать потому что они по молчанию не настраиваются плюс нас должны быть и метрики со стороны базы данных о ожиданиях и блокировках то есть мы должны иметь метрики иметь даже борды которые показывают то что у нас в базе данных возникают ожидания что время тратится не рационально и вместо того чтобы делать полезную работу база проводит время в ожидании на этом пожалуй все 4 раздел я постараюсь все что я сказал про улучшение в приложениях объединить в одной части логирование в нашем приложении должно быть логирование это очевидная вещь мы всегда должны быть в курсе что происходит нашем приложении и любые ошибки не должны игнорироваться не должны пропускаться или замалчиваться желательно чтобы логированием было динамическое чтобы мы могли на youtube поменять уровень лагерные посмотреть более детально что происходит в приложении как вариант можно еще хранить стектрейсы но здесь нужно быть очень аккуратным потому что stag 300 занимают много времени и если возникнет какая-то горячая ситуация когда генерируется много стектрейсы за единицу времени мы можем переполнить хранилище логов и ну логе будут весить много занимать много места метрики обязательно должны быть метрики на технические на выполнение тех операций которые происходят в нашем приложении статуса их выполнения длительность их выполнения состояние в процессе выполнения то есть у нас должны учиться не только успешной операции но и те которые в итоге закончились ошибкой и хорошим инструментом для выдачи метрик являются решение типа prometheus либо open телеметрии последний является индустриальным стандартом который как бы имеет амбиции стать главным в индустрии но про митоз пока больше как встречается для того чтобы посмотреть prometheus тут вот я вам экономлю ну 20 в минут времени есть 2 статьи про то как инструмен тировать приложение какие практики инструменте рования вообще есть эти две ссылки желательно их прочитать ознакомиться свободное время даже борды дашборд это настройки над метриками потому что метрики это сыр и данная и работать с ними как бы напрямую не очень удобно для этого мы берем мы организуем даже борт и хорошей отправной точкой является методологии ред и golden signals они позволяют делать удобные поверхностные даже борды для приложений но и для базы данных тоже можно построить такие даже борды и как бы использовать их дальше по желанию можно расширять эти даже борды добавлять них дополнительную информацию о том как работает наше приложение трейси опыт показывает что можно обойтись и без стрессов использована когда мы говорим про эксплуатацию баз данных потому что в микро сервисной архитектуре запрос может передаваться по сервисам много раз и нам желательно видеть вот это вот движение в каком микро сервисе выполнение заняло дольше времени иногда запрос приходит в базу данных он как правило как правило дальше никуда не передается и ответ возвращается обратно в приложению то есть у нас будет какой-то один такой вот спам последнего уровня и вот он будет нам показывать сколько времени операция заняла в базе данных но tracing в данном случае является дополнительным источником инженерных пробов мы можем с цифрами подойти к администратору базы данных и сказать что вот у нас приложение утыкается в базу данных работает в базе данных медленно и либо как бы вам вынужден будет как бы идти чините смотреть почему работает медленно хорошим инструментами являются общепризнанная егерь цыпкин и опять же окон телеметрии в которой претендует на стандарт в индустрии какие здесь могут быть выводы у нас приложение и в базе данных должно быть инструменти рование у нас должны быть логе метрики желательные trace и наши инструменты должны быть всегда под рукой не должно возникнуть у вас ситуации когда вы столкнулись с проблемой и так где-то полгода назад я видел презентацию на той презентации были какой-то слайд в этом слайде было название какое-то инструментов надо найти посмотреть не помню инструменты должны быть под рукой вы должны уметь ими минимально пользоваться это залог того что вы сможете быстро найти источник проблемы даже борды должны быть подготовлены даже горды если вы работаете над каким-то приложением у вас должен быть минимальный какой-то дашборд который показывает здоровье вашего приложения не нужно полагаться на инфраструктурную команду которая делает какой-то общий шаблон для всех приложений то есть вас если вы отвечаете за приложение вас должна быть информация о том что с ним происходит не полагаясь на другого человека и работать с метриками из браузера в виде дашбордов гораздо приятнее удобнее чем подключаться консоли там и какие-то статистике смотреть портянки текста и вот это вот все сложная но тем не менее у вас должно быть должен быть навык уметь подключиться к приложению к серверу где работает приложение к поту и так далее чтобы произвести какую-то ручную диагностику никогда не пренебрегайте логированием и дополнительными настройками на стороне базы данных вас должно быть настроена и логирование потому что в поскрести она в довольно минимальном виде настроена у вас должны быть тайм-аут и потому что использование таймаутов и вообще хорошая практика при разработке приложений но при эксплуатации баз данных такую практику тоже следует применять поиск проблем здесь ничего необычного все очевидно у нас есть какая-то общая картина мы выставляем гипотезы подтверждаем их опровергаем отсекаем лишнее используем логи для уточнения деталей используя метрики для наблюдения за поведением системой плюс используем инструменты которые нам помогают выявлять какие-то проблемы в базах данных на этом все с вами был алексей капитан очевидность лисовский если у вас были какие-то вопросы или есть можно задавать красота и памятный признан баренцева друзья давайте вопросы зададим и ребята кто смотрит онлайн тоже выходите задавайте вопросы мы вас на экране покажем большом поднимите ручки у кого есть вопрос а вот можно задавать эти вопросы не только по теме доклада можно вообще про пузыревский выпустить здравствуйте спасибо за полезный практически применимый доклад вижу-вижу получается мне два вопроса первый вопрос это вот со стороны разработки приложения если из возможность при выполнении запроса к пузыри указать ему тайм-аут то есть не чтобы на все запросы был одинаковый а чтобы сам пожгли взял и отек да дам можно по каждому настройки в подгрести они довольно гибкие и мы можем переопределять настройки для отдельных базы данных для отдельного пользователя мы можем менять настройки при подключении мы можем менять настройки в рамках сессии и даже некоторые настройки мы можем менять внутри транзакции то есть postgresql том плане довольно гибко конфигурируется и прямо в ран тайме можно менять параметры сервера то как сервер будет работать внутри вашей сессии и второй вопрос по поводу оптимизации запросов например как вот разработчик это он пишет запрос может оптимизировать его со стороны какие индексы нужно построить посмотреть где он там сканы делает где секи и так далее смотрите тут вопрос довольно таки непростой но есть некоторые общепринятые практике поведение запроса его план может меняться в зависимости от объема данных на поезд и и джемала данных план будет один на продакшене много данных план будет другой нам важно смотреть всегда на план запроса если какой-то запрос простой и вымещает там не знаю в 5-6 10 строк мы можем по предикатом но условия после строчки у р а мы можем посмотреть какие используются предикату условия и по ним примерно представить по каким полям быть поиск и посмотреть если у нас соответствующие индексы если индексов нету то мы можем достроить в надежде что они помогут но всегда лучше не надеется полагаться на какой-то конкретный инструмент в данном случае это explain то есть нам нужно посмотреть план запроса через explain посмотреть как он выполняется если необходимость в яндексе есть то этот индекс добавить вторая часть вопроса когда мы говорим про статистику использование запросов приложением в подгрести то всегда лучше смотреть на статистику не ввода-вывода не тех кто таблиц которые используются а с точки зрения прикладной разработки нужно смотреть на статистику по запросам в подгрести есть представление пгс that statement она хранит статистику по выполняющимся запросам в базе данных и разработчикам прикладным всегда нужно обращаться именно к ней вы можете найти запросы которые отправляет ваше приложение в базу данных и можете увидеть то сколько ресурсов базы данных используют эти запросы и это гораздо полезнее и продуктивнее будет для разработки и улучшения вашего приложения но кроме того есть да и статистика по вводу выводу таблицам индексом но пока редко используется она больше нужно инфраструктур щекам надеюсь ответил на вопрос спасибо спасибо алексей ты смелый человек давай интернет-пользователи мы поговорим легко и но колесо колесо делать не нему не будут мнения все нормально смотри вот даже вопрос начинается с улыбки добрый день добрый дима привет давай спросить уколу порекомендовали удобного использования представлен помогут вперёд как ты была права будет воровать табличные представления еще раз можно повторить вопрос удобный инструмент для распаривания чего удобный инструмент для раз партию нилова пузырь sqweel ставления табличном виде все понял а для раз прощения логов под гриф коль можно использовать такой инструмент как pg banger это довольно старый и заслуженный инструмент который позволяет анализировать данные в пузырьки и строить такие веб отчете cqi и можно в них всю информацию которой есть блогах в более человека понятном виде увидеть и как бы это будет более информативно чем смотреть текстовые портянки на черном экране но если что но спасибо я добавлю ясно что парсинг логов он тоже занимает какое-то ресурсы какие то время если логов много то и парс не займет тоже много времени бери спасибо за вопрос спасибо хорошо что пришел вот бомбические а бы которые можно раскрашивать когда нервничаешь классно будешь пожалуйста спасибо за доклад никита зовут можешь пожалуйста чуть чуть подробнее про кейс отменный запросу на реплики из-за того что прилетели вот точно такие же данные споймали то есть это репликация синхронная запрос на праймари ждет в этот момент чуть-чуть подробности про это за опера механика как бы проблемы выглядит примерно таким образом запрос когда выполняется он берет обращается каким-то данным шарит батерс шарит батерс это ну страничке по 8 килобайт и пока запрос не выполнился эти странички заблокированы то есть они не могут быть там условно говоря как-то кардинально быть изменены соответственно когда репликация в подгрести передает данные политиканы устроена физическим образом она передает изменение в блоках данных то есть это не логическая эта физическая репликация то по протоколу репликации приезжают изменение которое которое должно изменить этот блок который удерживается выполняющимся запросам соответственно возникает конфликт выполнении запроса и репликация репликация когда видит такой конфликт она останавливается потому что она не может изменить этот блок потому что он заблокирован запросам соответственно on база данных вынуждена ждать пока запрос выполнится но если ждать бесконечно долго то ну очень долго времени то может возникнуть риск лака репликации будет копиться и реплика может оторваться от мастера идет потребуется перри наливать это проблема как бы решается другими инструментальными средствами на уровне самого полиса настройками использованием там дополнительных конфигураций но решается но когда у реплики большой лак репликации мы не можем эту реплику использовать для переключения случае если мастер отвалился то есть у нас могут возникнуть риск потери информации соответственно всегда кандидат на переключение должен иметь маленькие лака репликации а желательно вообще быть синхронной репликой чтобы влага репликации не было и соответственно вот эта проблема отмены запросов она и порождает тут такую ну выбор либо мы ставим маленький таймаут на отмену запросов но позволяем как бы держать маленький лак и запросы будут отстреливаться либо мы увеличиваем этот тайм аут и позволяем запросам все-таки выполнится но тогда реплика будет с большим благом ее нельзя будет использовать случае файла вера или свеча вера спасибо из правильно понимаю что м10 в данном кейсе не работает потому что это право физическую репликацию и следующий вопрос проиграна в этот момент ждет или нет то есть если это синхронная репликация если эта синхронная репликация то процесс который выполняет запрос он должен сделать commit подтвердить подтвердить свою транзакцию даже обычные запросы состоящие ну не обернутые в транзакционный блок бегин энд они все равно использую транзакционный движок и по сути это транзакция из одного запроса и он в конце тоже должен подтвердится и пока вот не произошла операция по рождения не пришло подтверждение с реплики что данная гарантированно записались на надёжное хранилище то процесс клиент будет ждать этого подтверждения и не сможет управлять другие запросы и это вызывает задержки при выполнении запросов случае если у нас медленно и сеть или ненадежность ну там медленные диски на реплики на мастере тогда это может быть проблемами производительности круто спасибо и все это время мы говорим про читающий запрос на реплики типа select к он как на примере да да великолепно остальные вопросы друзья в кулуарах лично алексей сейчас выходят в цифровые кулуары общаться с интернет фанатами аплодисменты его хорошего продолжение дня"
}