{
  "video_id": "Ybz6P-l9YHc",
  "channel": "HighLoadChannel",
  "title": "Оптимизация производительности фронтенда / Игорь Алексеенко (HTML Academy)",
  "views": 9821,
  "duration": 3386,
  "published": "2018-01-16T13:30:40-08:00",
  "text": "Меня зовут Игорь Алексеенко Я работаю в HTML академии преподавателем я веду два курса по jasp первый и второй базовый продвинутый и конечно же я работаю разработчиком потому что ну нельзя преподавать не зная что ты делаешь И сегодня я хотел поговорить О как раз таки о проблеме разработчиков Мне кажется я пось своей собственной босье бо Прим Я ненавижу когда интерфейс тормозят не только как пользователь сайтов но и как разработчик Почему Потому что мы как разработчики отвечаем за те эмоции которые люди испытывают на сайтах за тот экспириенс то есть если человек придёт на сайт и получит какой-то негативный опыт это наша вина Напрямую это не дизайнер не сложная технология это мы и Ну ладно бы интерфейс тормозит мы сечас подумаем что ничего страшного Пома тормозит интерфейс придёт пользователь в нашу онлайн игру и не сможет прицелиться и там хедшотов больше сайты решают более сложные задачи и если вы разрабатываете какое-нибудь банковское приложение и у вас случилась какая-нибудь там повторная отправка данных пользователь потерял деньги или у вас какой-нибудь интернет-магазины пользователь там не смог купить товар который ему нужен то вы этого пользователя потеряете просто из Т тормозит а потерянный пользователь это потеря денег потеря денег это экономия с точки зрения компании и может быть ваш уход В общем Всё достаточно плохо с тормозами это действительно серьёзная проблема поэтому нужно её решать Давайте разберёмся как решать проблему тормозящих сайтов Но для того чтобы решать проблему нужно знать врага в лицо тормоза на сайтах возникают когда взаимодействие с пользователем перестаёт быть ровным что это значит Дело в том что са пользователи когда видят страницы когда видят наши сайты они не видят какую-то статическую картинку потому что сайт - Это не просто картинка сайт - это процесс взаимодействия пользователя с интерфейсом который мы ему предлагаем потому что пользователь может увидеть те же самые анимации о которых я говорил он может банально скролить этот сат динамическое какое-то взаимодействие он тыкает на кнопки Он вводит текст он перетаскивает элементы это всё работает динамически почему это работает динамически Почему сайты могут жить в каком-то какое-то продолжительное время это происходит из-за того что во все движки браузеров встроена такая конструкция как Event loop на самом деле EV loop - это такой простой программистский Прим который заключается в том что мы просто запускаем бесконечный к определённой частотой такой чтобы у нас там не забился стек и была какая-то производительность и на каждом шаге своего выполнения бесконечный цикл проверяет внешние условия и запускает какие-то определённые действия например он понимает что пользователь прокрутил мышку и нужно нам немножечко сместить страницу вот с этим самым ивент лум который встроен в движок браузера синхронизированы все взаимодействие с пользователем То есть все прокрутки все все прочие штуки и код который Мы выполняем В долгосрочной перспективе он тоже с ним синхронизирован то есть ВС ВС Это зависит от этого самого Илу как попадать в кадры ин лупа на самом деле вот у нас же есть цикл он крутится с какой-то определённой частотой А с какой частотой он крутится мы как фронтенде не можем контролировать эту частоту во-первых А во-вторых мы не можем знать эту частоту Мы очень такие ограниченные ребята нас зажимают в правах и у нас есть возможность только пользоваться уже готовыми предназначенными нам кадрами то есть мы чистоту не контролируем но вписаться в неё можем для этого есть такая конструкция как ре Animation Frame если мы передаём код в Call requ Animation фрейма то мы попадаем в начало очередного кадра обновления и кадры обновления бывают разные на Маке например эти кадры стараются вписаться в 60 FPS Но не все происходит это так мы увидим позже приме не всегда бывает равно 60 FS смотрите мы разобрались что в жава скрипте в основе жава скрипта лежит такой бесконечный цикл который обновляется со временем и теперь мы можем предположить откуда у нас могут возникать тормоза вот у нас есть кадры которые обновляются с течением времени и мы запускаем какие-то определённые вычисления на нашем сайте любые вычисления всё что мым врите это факс выле эния занима обновление пользователь видит лаги Ну то есть у нас идт череда последовательных кадров а потом фига и происходит какое-то долгое вычисление которое занимает больше кадра пользователь видит небольшую задержку у него ну скажем анимация дёргается или вычисления могут стать Вот такими вот тогда у нас страница зависнет и мы ничего не сможем с ней делать хорошо здесь понятно что такое Почему Дава програм какие-то инструменты э на которых наш код запускается и Главная задача программиста - это правильно распределить баланс нагрузки между процессором и памятью процессор - это Мы все знаем что такое процессор это устройство в компьютере которое отвечает за мгновенные вычисления то есть любая команда которую вы пишете она преобразуется в инструкцию для процессора и процессор будет эту команду выполнять Но если у нас есть последовательность команд которые приводят к какому-то большому результату допустим там мы посчитали какое-то сложное значение мы не хотим повторять эту последовательность команд поэтому мы можем записать результат работы этой команды в память и пользоваться другой инструкцией процессора которая называется чтение из памяти и вот Об этом я как раз таки хотел поговорить то есть первая оптимизация которая видится логичной - это использовать память для того чтобы не использовать вычисления в принципе в принципе такая стратегия звучит выигрышной представляете Ну на самом деле она даже не только звучит выигрышной это хорошая стратегия которая уже используется например Все вы знаете что в жава скрипте есть встроенный Объект который называется он предназначен для работы с какой-то математикой там вычисления какие-то и этот объект содержит не только методы но и сразу потому что например чтобы посчитать число Пи которое там сохранено до определённого знака ну нужно какие-то сложные действия выполнить во-вторых есть такой хороший пример про старые времена Я очень люблю программистов восьмидесятых годов потому что они писали эффективные решения железо было слабое им приходилось придумывать какие-то хорошие штуки и в первых 3D шутерах они ну в 3D шутерах всегда используется тригонометрия для того чтобы считать там всякие расстояния и всё прочее и в тригонометрии очень часто используются синусы косинусы и все эти прочие штуки с точки зрения компьютера Это тоже достаточно дорогостоящая операция и раньше программисты на этапе компиляции засовывали таблицы синусов и косинусов прямо в программный код то есть они пользовались уже посчитано значениями синусов и косинусов и вместо того чтобы их рассчитывать для отрисовки сцены они брали их как константы вообще звучит Круто А и таким образом можно оптимизировать вообще всё на свете можно там посчитать заранее анимацию как она у нас будет выглядеть и сделать всё что угодно В принципе это звучит очень круто смотрите вот у нас есть кадры и вместо того чтобы запускать вычисления которые занимают несколько кадров мы запускаем вычисления которые занимаются только чтением Ну то есть раз прочитали готовое значение всё подставили использовали и получается что интерфейс работает очень быстро в принципе теоретически это звучит очень круто но Давайте подумаем о том именно нде работа когда Мы открываем вкладку браузера нам выделяется какое-то определенное количество памяти его объём Мы кстати тоже не знаем В этом мы тоже ограничены то есть мы не знаем Сколько памяти у нас есть там и мало того что мы не знаем объём памяти мы не можем управлять этой памятью есть ещё такая особенность что в этой памяти уже что-то хранится во-первых в этой памяти нита языка Есть конструкторы все фун ни ВМ во-вторых Вы тоже пользуетесь какими-то данными вы скачиваете что-то с Акса вы там что-то генерирует какие-то структуры в-третьих У вас есть дом дерево и оно тоже попадает в память потому что JavaScript не умеет читать HTML и поэтому браузер для жава скрипта преобразовывает разметку в набор объектов в дерево и в память браузера во вкладку попадает ВС что у вас есть в разметке все теги попадают в виде каждого отдельного объекта попадают тексты то есть для каждого переноса который выставите между тегами создаётся объект в памяти браузера как текстовая нода и он висит и вот здесь мы смотрим Что у нас и так уже есть куча всего в памяти и мы хотим записать что-то наше и это достаточно опасно потому пам может този эти при противоречат друг другу Как ни странно потому что первая причина называется сборка мусора а вторая называется отсутствие сборки мусора Давайте разберём Каждую из них Что такое сборка мусора перед тем как я расскажу что такое сборка мусора я расскажу вам как мы будем смотреть работу с точки зрения производительности памяти и вообще всего на свете Дело в том что все эти производительно можно вж показывать на примере Хрома но в других браузерах это тоже есть а и мы будем смотреть на вкладку которая называется профилирование по-английски она называется performance Давайте разберём Из чего состоит эта вкладка я могу открыть эту вкладку в любой момент времени и замерить так называемый snapshot производительности браузера То есть я нажимаю кнопку Record записать у меня производится запись этой самой производительности и через какое-то время я могу посмотреть на то что у меня происходило на странице и как это влияло на память и на процессор смотрите Из чего состоит эта вкладка во-первых у нас сверху есть такой таймлайне вкладки и этот таймлапс частоту кадров которая была в тот момент времени А дальше он показывает загруженность процессора на таком совместном графике он показывает разные роды вычислений Дальше он показывает скриншоты можно их кстати не показывать я советую Вам их отключать Потому что если вы вате профиль производительности со включенными скриншотами у вас проседает FS это гарантировано То есть если вам нужно именно FS посчитать то Выключите скриншоты на всякий случай Ну и дальше идёт спш памяти вот Самый Нижний график Ну вот под тем оранжевым а потом идт детальная статистика той же самой информации которую мы видим сверху то есть мы можем увеличить любой момент профайлера и посмотреть именно по кадрам что у происходило есть Можем увели даже до кадра и Поре выполнялись даже ну ссылками на код мы это всё увидим Итак и вот это вот производительность мы будем мерить на Инстаграме с котиками Все любят котиков Все любят instr Поэтому я решил сделать вот так котиков не бывает мало поэтому мы будем смотреть большие страницы по 5.000 котиков у нас будет пять страниц с 5000 котиков и мы их будем уметь переключать между собой Итак давайте сделаем следующее смотрите здесь я показываю Вот как я генерируют из какого-то стандартного шаблона на основе We components но заполняю уникальными данными То есть даже там где у меня там картинки повторяются я использую та чтобы не было кэширования чтобы вот тест по памяти был чистым и когда я когда Я создаю все элементы Я добавляю их в один фрагмент тоже оптимизация которую вы все знаете и чтобы почистить страниц я буду просто шашки на голо чистить контейнер вот Конте hml равно ничему это работает быстрее Итак давайте смотреть Что такое сборка мусора сборка мусора это такой процесс который предназначен для оптимизации нашей с вами работы с памятью сборка мусора это неконтролируемый нами процесс который запускается тогда когда именно браузер сам понимает чтом память под эту вкладку зано чтобы удалить старые неиспользуемые объекты старые неиспользуемые обекты - это объекты на которых больше нет ссылок то есть это объекты не записанные в переменные не записанные в объекты не записанные в массивы в общем никуда и вот Казалось бы это крутой процесс да Нам нужна сборка мусора потому что действительно память ограничена и нужно её освобождать почему это может быть проблемой потому что мы не знаем сколько времени будет занимать сборка мусора имы не знаем ко Давайте посмотрим на примере здесь я записал тайла Ну вот этот профиль это талай переключение страниц Вот вы на Верхнем графике видите такие всплески производительности процессора Ну загруженности процессора это как раз-таки переключение пятитысячных страниц с котиками и на Нижнем графике мы здесь видим такую что сначала память идёт вверх это график использования памяти а потом мы видим ступень вниз это как раз таки и есть процесс сборки мусора на первые две страницы мне памяти хватило То есть я отрисовка что памяти хватало А чтобы отрисовать ещё 5000 котиков мне памяти не хватило Я удалил старых потому что они больше у меня не используется в принципе это круто да действительно браузер обо мне позаботился и удалил то что я не использую В чём пробле зани процесс сборки мусора если мы сложим чере записи колен то мы увидим что процесс сборки мусора занял 134 миллисекунды 134 миллисекунды это 10 кадров при 6 FPS То есть если вы бы хотели про анимировать за какое-то определённое время перемещение скажем какого-нибудь блока на 600 пикселе 100 пикселе просто за счёт того что браузер решил почистить память и вы не контролируете ни наступление этого процесса не длительность Это плохо вторая проблема абсолютно противоположна первой это проблема называется утечка памяти Казалось бы браузер такой непоследовательный вот ему нужно и почистить память это долго и не почистить память это Давайте посмотрим Почему утечка памяти - это такой процесс когда а та самая сборка мусора не происходит то есть даже она может быть происходит но она не чистит то что нам нужно иногда мы можем накидать в память чего-то а чего-то такого Глядя на что движок браузера поймёт что он не может это почистить Давайте посмотрим на примере кода А вот здесь у меня есть то же самое переключение страниц Но каждый раз когда я Вставляю новые элементы на страницу Я добавляю обработчик на каждый из на каждую из фоточек допустим Мне нужно поймать нажать там скажем на пробел и я повешал на всякий случай на документ обработчик чтобы у меня никуда не исчез Что произойдёт в этом случае смотрите когда я чищу контейнер с помощью удаления у меня удалятся дом ноды из дом дерева обработки на домен на страни Ну то есть ничего с ним не произойдёт и когда будет происходить сборка мусора сборщик мусора эти обработчики не удалит А теперь давайте посмотрим что написано внутри этих обработчиков внутри этих обработчиков у меня используется нода получается что у меня не удалятся И ноды из памяти потому что на них есть ссылка это и называется утечка памяти когда я не контролируем то есть с точки зрения логики мне эти ноды не нужны не нужны ни обработчики ни ноды но сборщик об этом не знает Потому что сво точки зрения не используется Что произойдёт в этом случае давайте смотреть на график и Из волн таких которые поднимаются опускаются У меня график превратился в такую лестницу которая растёт наверх и с каждым переключением страницы У меня память используется всё больше больше больше больше больше и не чистится потому что у меня остаются обработчики в памяти ноды тоже остаются в памяти и память не освобождается это тоже плохо компьютер тоже начнёт тормозить почему он Нант тормозить потому что ну большая память - это слишком плохо Ну процессор будет забиваться когда будет выполнять операции на большом доме что мы в итоге получаем Мы в итоге получаем что когда мы работаем с памятью то есть мы пытаемся оптимизировать что-то с помощью памяти мы получаем большой риск сам БН который создал JavaScript в недавнем интервью это было интервью он сказал Jap хороший язык он быстрый он по производительности иногда может тягаться но проблема начинается Когда возникает сборка мусора потому что мы не знаем когда к нам придёт сборщик И сколько времени он проработает получается что оптимизации по памяти они не надёжны то есть они может быть хороши но не надёжны потому что другую сторону вот той картины которую я показывал Давайте посмотрим как можно оптимизировать скорость нашего приложения с точки зрения процессора основного вычислительного устройства смотрите есть три основных способа ускорить работу процессора первый - это уменьшить объём вычислений второй способ - это затролить чуть попозже я расскажу что такое затролить Аа да и третий способ - это не пользоваться процессором это тоже достаточно такой странный способ оптимизировать процессор Но это хороший способ Итак смотрите уменьшение объёма вычислений Давайте посмотрим на нашу картину с котиками я говорил что у меня отрисовывать страниц по 5.000 котиков в принципе Кстати это реальные объёмы То есть вы можете покро там в течение полу минуты этих котиков и у вас уже получится дом на 5.000 элементов но Если так подумать то для первой загрузки нам этого не нужно мы вот сейчас видим четыре ряда пять колонок Коти 20 котиков и получается что пользователь когда первый раз открывает страницу он видит 20 котиков Он не видит 5000 котиков а браузер отрисовывать 5000 получается что нам Мы отрисовывать задел у нас пользователь склит сайт ему тоже нужно что-то показывать Но если рисуем 100 котиков это будет уже Сколько экранов пять экранов поэтому первое что мы можем сделать мы можем уменьшить объём дома Это самый простой способ нам нужно использовать не больше памяти а меньше вы уменьшается дома у вас всё работает быстрее Давайте я вам докажу с точки зрения профайлера вот я отрисовывать вот зде Тая в про будет записывать скорость загрузки именно страницы он её Перезагрузи и когда страница полностью отсе вот вс всё будет готово он прекратит запись этого снапшота и 5000 котиков отрисовывать в конце э секун пото в кон а этого ви на тре секунде появляются обёртки картинок То есть он показывает что вот здесь будет картинка но её Пока нет и котики видны только через 4 секунды если я уменьш страницу на 100 до 100 элементов до п экранов то Загрузка у меня получится всего полсекунды причём пользователь когда что-то увидит он сразу увидит готовый результат он не увидит сначала обещание что вот здесь будет фоточка он сразу увидит готовых котиков всё хороо поэтому вопервых уменьшать объёмы вычислений а не увеличивать то есть память нужно уменьшать второй момент - это тролинг что такое троттлинг Представьте что у вас есть задача Да у нас есть определённая частота кадров и эта задача не вписывается в ту частоту кадров которую мы выбрали Да мы об этом уже поговорили но тролинг - это такой способ мышления когда мы делаем следующее мы делаем шаг назад и пытаемся понять Действительно ли нам нужна та частота обновления которая у нас есть вот у нас есть Ну допустим это 60 FPS и у нас операция выполняется с этой частотой но вычисления у нас занимают там больше 16,5 миллисекунд и тут нам нужно подумать А действительно ли нам нужно вписывать эти вычисления в 16,5 миллисекунд и если нет то мы можем проредить частоту до нужной нам Давайте Я приведу пример мы с вами сделали же только что ну оптимизировали котиков мы показываем не 5000 страниц а 100 котиков и Давайте изменим способ взаимодействия пользователя с этими котиками мы не будем показывать сразу большие страницы мы будем показывать котиков по мере необходимости для этого нужен динамический скролл мы СКМ доходим до низа показываем Следующую страницу это код дописал немножечко статистики Я записал Дельту в пикселях Как часто у меня срабатывает событие скролла и счётчик общих собти скролла И когда я проро страницу сверху вниз уня высота страни пикселе ие скролла у меня срабатывало каждые четыре И сверху донизу у меня произошло 500 проверок Почему так много потому что сл как раз происходит с частотой 60 FS той самой причём вчера же показали этот самый IP у которого частота экрана 120 гц значит они теперь будут стараться делать 120 FS а не 60 и об этом нам стоит е ещё более серьёзно думать получается что помните осла из мультика про Шрека который спрашивал Мы уже приехали Мы уже приехали Мы уже приехали вот Ровно в том чтобы проредить количество кадров мне не нужно проверять каждые четыре пикселя до скро ли я до низа страницы я могу это сделать допустим раз в 100 миллисекунд вот здесь я добавил небольшую проверку основанную на датах я смотрю Сколько времени прошло с прошлой проверки и запускаю следующую В чём суть у меня событие скролла продолжает происходить но я использую не все кадры скролла я использую Некоторые из кадров скролла которые попадают под моё условие и в этом случае у меня вот когда Я использовал 100 миллисекунд у меня проверка выполнялась каждые 20-30 пикселей И сверху до низа у меня произошло всего лишь 100 проверок Ну в принципе это нормально раз в 100 пикселей спросить не находимся ли мы внизу по-моему нормально А это второй способ вычисления то есть проверьте частоту кадров может быть 60 FPS вам не нужно для какой-то определённой задачи и нужно его снизить третий способ отдать вычисление Как можно отдать вычисления с процессора тут тоже есть несколько вариантов во-первых мы можем некоторые вычисления отдать на видеокарту во-вторых мы можем некоторые вычисления отдать на сервер и в-третьих мы можем отдать вычисление в другой поток это не то чтобы разгрузить процессор пользователя Но это разгрузить процесс процесс который открыт во вкладке давайте рассмотрим каждый из этих примеров Для начала я расскажу вам Почему браузерные игры делаются не на канвасе не на свг а на канвасе вот браузерные игры - это такая вообще штука где у вас есть очень много элементов Ну таких элементов которые вы выкидывает В таких случаях Когда у вас есть какое-то сложное взаимодействие большое количество маленьких элементов которые причём не живут Достаточно долго вам есть смыс использовать ка Дава ние под свг Когда вы что-то отрисовывать формат в виде разметки А как мы уже раньше выяснили вся разметка попадает в JavaScript в виде дом дерева в виде объекта Ну например с класс листом или со всеми остальными свойствами А когда вы пишете на канвасе Вы просто оперирует взаимодействие с касом э бо ничего поэтому на канвасе вам приходи придумывать какие-то свои структуры данных потому что у вас нет дом дерева которое за вас было кем-то придумано но зато они могут быть чуть-чуть получше чем Ну для решения задачи чем те структуры которые предлагает свг раз у свг есть какое-то вот какая-то стандартная структура обновлять по одиночке там анимировать их на канвасе вы всего этого делать не можете То есть вам придется ВС это писать руками вот как на ассемблере но зато Вы можете получить прирост производительности потому что поскольку с это дом дом будет считаться на процессоре а отрисовка пикселей будет считаться на видеокарте Давайте посмотрим я написал такую амку у неё разрешение Ну смешное по нынешним временам 800 на 600 Ну вообще ни о чём И вот та Земля которую вы видите это всё векторная графика и все страны описаны через один сложный ПС Это не я не отрисовывать каждую страну отдельно в виде отдельного объекта это просто они все смр ну в одну какую-то линию такую вот такой формы я буду обновлять кадры через request Animation Frame то есть браузер сам мне скажет какой у меня FPS для отрисовки вот этой штуки То есть он сам поймёт за сколько он сможет отрисовать один кадр и в качестве анимации я буду проворачивать землю на 360 от Лондона до Лондона Ну так было проще написать там в массиве Мне нужно было передать ноль потому что это координата Лондона Ну и от нуля до 360 Ну понятно И вот здесь я записал таймстамп Ну в смысле этот самый профиль работы канваса во-первых смотрите на нижний график здесь у меня используется только пу То есть у меня используется только видеокарта для этой анимации чуть выше у меня ничего нет у меня есть у меня задействована вкладка Main - это работа непосредственно процессора Но это работа непосредственно процессора по изменению в массиве числа ноль на число 360 Ну и там просчёт вот этого пса в зависимости от угла он там умножает известные ему координаты стран на ну на формулу проекции их на окружность А дальше используется только только видеокарта и ничего больше И в итоге у меня вот я запустил несколько тестов и у меня получалось в среднем что анимация длится 6 секунд если мы проведём нехитрые вычисления там 360° за 6 секунд получается 60 FPS всё хорошо 60 FPS всё нормально а вот свг справился чуть-чуть похуже Почему Потому что вот если Вы посмотрите на две последние линии у нас заполнилась вкладка которая называется ра Что такое Р Это значит что у меня свг создавал Под каждый кадр дом объект просчитывает полностью с помощью процессора не с помощью ГПУ и рендел его с помощью видеокарты уже в виде Ну в виде пикселей то есть сначала дом элемент который долго и сложно просчитывается а потом пиксели на экране и это просалон уходило в среднем 8 секунд и Это около 45 FPS и вот здесь я обвожу 45 FPS красной рамочки знаете почему Потому что 45 FPS это за гранью позора так называемого вот вы сейчас скажете ты что говоришь есть же даже фильмы которые идут с частотой 24 FPS неправда даже фильмы которые ещё на заре кинематографа записывались частотой 24 FPS показывали с частотой 48 FPS и вот эту концепцию нам объясняет Томас Эдисон он объясняет её так да человек будет видеть как движение 24 FPS но он будет видеть мерцание от обновления картинки то есть ОНТ ви движущуюся картинку но мерцание он тоже будет замечать и чтобы он не замечал мерцание нам нужно как минимум 48 видите разницу 48 и 24 Дело в том что старые фильмы показывались Так что каждый кадр показывался два раза То есть даже старые фильмы на заре кинематограф показывались 48 FPS А кавас у нас не справился То есть он провалил тест производительности а и стало всё плохо получается что в определённых случаях кавас лучше свг когда у вас много вот таких вот disposable элементов которые вам нужно выкидывать вам нужно использовать кавас это лучше смотрите Ещё один тест Я когда писал Я когда писал презентацию Ну то есть когда я готовился там прогонял все примеры кода Я случайно забыл одну строчку очистку предыдущего кадра и у меня получилась Вот такая вот странная картинка и я решил не не просто избавиться от этого Бага А я решил посмотреть куда меня приведёт моя ошибка и решил замерить производительность вот этой вот штуки когда я замерил производительность оборота земли на канвасе без очистки канваса У меня получилось 60 FPS я когда готовил эту презентацию я шесть раз перепроверил туже не ту же ли я картинку вставил вот здесь вот в качестве иллюстрации 60 FPS кавас наплевать а вот есть у вас предположение как справился свг с каждым разом всё хуже и хуже Ну Назовите время анимации вот хотя бы 200 24 минуты у него ничего не чистилось и это произошла классическая утечка Ну то есть у меня память росла росла росла я хотел показать здесь профайлер Но мне Я первый раз видел Окно смерти на профайлер это вообще очень странно но Чтобы объяснить что произошло я покажу профайлер на обычном свг вы видите снизу используется память и каждые 2 секунды она забивается потом чистится каждые 2 секунды забивается теперь поставьте Вот эту вот лесенку друг на друга и Представьте что произошло на конце че минуты Когда я успел попить чай сходить куда-то в общем если у вас есть очень много disable элементов Если у вас есть сложная графика в которой есть какое-то нетривиальное взаимодействие то лучше использовать кавас вряд ли кто-то будет описывать пылинки которые разлетаются от дерева в которое попал фаербол в качестве доно у каждой из которых есть класс лист но нет лучше кавас и Трей ещ один способ вычисления - это отдать вычисление на сервер вот мы се только что говорили про кавас что графика хорошая быстрая на канвасе у нас получается Но однажды у меня была Вот такая вот задача отрисовать тепка Ну то есть теплоту поверх города Как часто встречаются рестораны в этом городе и я подумал Ну графика графика свг не подойдёт не подойдёт потому что шаг обновления один пиксель То есть каждый пиель у меня что-то знат Поэтому нужен быть кавас я решил эту задачу на канвасе да то есть у меня приходила структура данных я проходил По всей этой структуре данных ставил точку на карте которая соответствует всему этому определённой насыщенности цвета и что получилось на самом деле мне не сильно получилось понравилось решение потому что во-первых мне пришлось писать очень много костылей кавас - это фактический графический ассемблер приходить с кажым пикселем вручную негов во-вторых Проблема была в том что мне приходилось запускать очень много вычислений а пользователь видел одно и тоже То есть он сдвинул карту А я заново всё пересчитывал Ну такое ограничение и тогда я подумал Хорошо я умный разработчик я решил офигенную сложную задачу я нарисовал теплокабель у которого есть красивая библиотека для работы с графикой которая на генерирует мне статических картинок которые лежат не у меня и которые ещё и закрут то есть вместо того чтобы нагружать процессор пользователя своим тщеславием Я подошёл к Бендеру и попросил наге нери картинок то есть нагрузить процессор компьютера Эндера который предназначен для этого а процессор что чити из ша потому что как вы знаете у Картино есть е одно преимущество их не надо пересчитывать каждый раз они запоминаются ирисовый способ - это отдать параллельный поток на самом деле это достаточно новый способ для Фронда потому что обычно об этом говорили Ну ребята которые пишут на других языках новот давайте рассмотрим таку клиент сайт най редактор то клиент Сай отвечает за такие базовые вещи как мигание курсора скролл перемещение курсора и все прочие штуки а помимо этого нам нужно подсветить код или сказать Чувак ты написал неправильный оператор в неправильном месте и всё это сломать А чтобы сказать что пользователь написал неправильный оператор в неправильном месте Мне нужно построить СТ дерево пробежаться по нему проанализировать и сделать все прочие штуки что сделали разработчики они сделали так они сказали в основном потоке мы оставляем основное Пусть курсор мигает Пусть он ходит Пусть экран скро это будет происходить без задержек то есть пользователь будет доволен А все остальные штуки дополнительные мы отдадим это такой инструмен вы запускаете JavaScript фа не в вашей вкладке и не расходу производительность не расходу ваши loop например на постройку дерева То есть вы делаете здесь основные важные вещи есть одно ограничение в сево нельзя отдавать работу с домом То есть если вы хотите работать с домом то вы работаете в своём потоке А в Если у вас есть сложные вычисления вы их отдаёте в параллель Это хорошо и это повысит производительность вашего фронтенда так смотрите давайте подытожим как можно отдать вычисление С практической точки зрения если вы делаете визуализацию на3 и она у вас сложная у вас там есть какая там есть такая штука например Гравитация вы построили дерево и чем больше у него нода тем сильнее оно притягивает ноды И это всё ещё анимирует и там происходит за к то если вы делаете Это обдуманно это не всегда плохо Ну то есть это может быть хорошо если пользователь видит более быстро интерфейс Оле на картах Google картинка это вот просто закон если эти веле у вас не интерактивные То есть если в них тыкнуть нельзя вы просто даже не думая делаете картинку и всё Ну и если вы можете посчитать что-то в параллельном потоке Сделайте это Это хорошо и смотрите вот я сейс дого рассказываю как оптимизировать вычисления как их уменьшать но есть такая проблема что иногда вычисление нельзя оптимизировать что я имею в виду например никакой сервер Ну настоящий сервер который в интернете не ответит мне скажем быстрее 100 миллисекунд Ну вот я ничего не могу с этим поделать задержка будет и пользователи будут видеть какие-то даже ес У меня супер красивый интерфейс который До мелочей если у меня Все вычисления оптимизированы всё равно будут задержки Что делать с задержками есть два способа во-первых нужно использовать прозрачную обратную связь то есть показывать пользователю что Да я знаю что есть задержка И что это нормально а во-вторых можно немножечко обмануть пользователя Сейчас я вам расскажу как это делается во-первых рассмотрим правильную обратную связь вернёмся к инстагра с котиками и добавим немножечко взаимодействия вот у меня есть котик и пользователь хочет к это Коти он наводит мышку нажимает на звездочку я показываю что да ты лайкнул ты молодец больше лайков стало Но это же неправда то есть лайк - это не лайк пока он на сервере не лайк и у серверов бывает иногда такая проблема вот такая вот а что делают все разработчики Когда у нас произошла Вот такая проблема вот чтот обт связи Как надо делать Я не говорю что нужно забыть там про оми или что-то ещ я сейчас покажу вам направление что если пользователь нажал что-то и результат у этого не мгновенно показать это да Можно даже подсветить эту звёздочку как-нибудь там показать какой-нибудь другой статус она там нажа должна но хотя бы покажите что Подожди Да мы поняли что ты нажал но но но ещё не всё гото И когда у про чтото нем под этоже прозрачными нам нужно показывать пользователю что происходит потому что как я говорил это мы ответственны за впечатление пользователей от сайта это не не он дурак что не разобрался что меня пятисот и в консоль выводит когда я готовился к этому докладу я позвонил маме и рассказал о чём этот доклад и она рассказала мне анекдот зачем вы привезли мне 10 пицц Я же заказывал одну да Вы заказывали одну но на кнопку нажали 10 раз Ну вот кажется дурацкая шутка но нет ни фига я встречаюсь с таким то есть Иногда я пишу коммент нажимаю на кнопку и даже Кнопка не прогибается и вот ничего не происходит И я такой глючит что ли надо нажать ещё раз а на самом-то деле всё произошло запрос ушёл на сервер и оба запроса ушли на сервер и оба коммента отрисовать когда они видят два одинаковых коммента и почему-то считается что виноват я хотя виноват программист на самом деле Ну то есть можно же было просто показать обратную связью Да Больше не нажимай на эту кнопку пожалуйста мы поняли что ты на неё нажал и когда пришёл ответ Можно даже обнулить контекст то есть видите я удалил сообщение и дизейбл кнопку что теперь пользователь поймёт даже вот он интуитивно поймёт что это другое сообщение можно вводить Ну то есть какая-то это на этапе разработки стоит вообще ничего но интерфейс Становится лучше и задержка становится прозрачной то есть пользователь не будет в обиде он знает что до сервера нужно сходить как говорил Луи C подожди оно летит в космос пока ты там жалуешься что у меня сайт не показывается секунду тогда всё будет хорошо да А и второй способ это на самом деле пользователя можно немножечко обмануть наме ко разрабатывали компьютер ещ В каком втором или седьмом я не помню точно году у них было очень слабое железо потому что ула была задача вписаться в определённую цену и они не покупали сильно Ну сильное железо чтобы компьютер остался доступным им приходилось придумывать интересные решения и Джеф ракин который проектировал первую версию интерфейса ма он придумал следующее компьютер не мог включиться мгновенно и показать сразу рабочий экран поэтому они делали следующее они фотографировали последнее состояние экрана перед выключением записывали картинку на нулевой диск на нулевую дорожку диска и когда компьютер включался они показывали картинку почему это работало потому что человеку чтобы переключить контекст нужны секунды То есть когда мы говорим об псе люди видят профессиональные лётчики видят 270 FPS но когда люди переключают контекст между задачами то нам нужны секунды то есть Нам нужно несколько секунд чтобы осознать что происходит и когда ребята из МАСИ показывали им картинку Люди так смотрят на картинку Да здесь что-то произошло что-то изменилось и пока ты поймёшь что произошло Тебе покажут настоящий экран это решение оказалось настолько работоспособным что это работает до сих пор ма показывает вам картинку прямо сейчас вы замечали что ты открываешь noe А у тебя индикатор вай-фая уже горит на полную А через 2 секунды он такой тык и начинает искать wi-fi это фотка и второй способ - это он вытекает немножечко из первого Но это такой обрезанный скриншот это называется Skeleton screens и эту штуку придумали и как раз у них была ровно та задача о которой мы говорили чуть раньше что если мы показываем не все картинки а пользователь склит они придумали Ну мы же не можем показать сразу все картинки но мы можем пообещать пользователю что здесь картинка будет и они рисуют серый блок размером с картинку и потом когда пользователь останавливается ему показывается настоящая картинка и когда пользователь склит и видит серые блоки вот такую штуку тоже можно использовать И это хорошо давайте подведём итог Что делать если мой сайт тормозит во-первых начните с процессора то есть улучшите ваш процесс вычислений уменьшите память уменьшите память не надо её забивать делайте маленькие операции во-вторых проверьте не слишком ли часто вы производите эти вычисления врете про Отдайте сложный алгоритм кде Несмотря на то что вы красавица можете его написать потом добавьте правильную обратную связь в интерфейс чтобы пользователь понимал что да идут вычисления Но это нормально и уже после этого я желаю вам удачи в оптимизации памяти спасибо е Одно замечание во смотрите я собрал сайт у меня есть сатик вот вот он и там можно будет посмотреть презентацию и в дальнейшем я на этом же сайте буду выкладывать те примеры о которых я говорил то есть я выложу прямо код с отдельными страницами вы сможете померить производительность и в общем-то всё почитать В общем заходите А сейчас Вопросы Спасибо большое за доклад Я хотел спросить такой момент Они же вроде сериализм вычисления Ну там считалось Сколько точек на графике у человека есть Сколько пришло с сервера и там всё это мёрзла и собственно когда ке перенесли оно стало только больше тормозить Угу и на сервер эту логику тоже не вынести потому что уже сервер тупить начинает Поэтому там вот есть небольшой лак когда страница только загружается там какой-то происходит вот этот вот угу ну как-то его задекорировать но тем не менее он всё равно есть Вот как можно с такими ситуациями Бороться и что вообще вот предложишь Ну если быстро подумать то да первое что приходит в голову это то тот самый способ показать спиннером что сейчас что-то считается это нормально а во-вторых я бы посмотрел Ну в общем задача поставлена В общем виде я не могу конкретно решение сказать но я бы посмотрел на то Какие данные именно приходят с серверу может быть их там слишком много точек с данными с какими-то может быть есть смысл проредить данные Ну там поменьше их показывать если есть такая возможность ну разве что на какой-то старой ретроспективе проредить вариант Кстати спасибо Ну да то есть сначала скачивать меньше данных а потом по мере необходимости подгружать больший объём данных и тогда это будет работать чуть-чуть побыстрее спасибо спасибо за доклад я тут слева а у меня не вопрос У меня только пара комментариев А первый комментарий по поводу свг Сколько было точек в пути не знаю там очень большой Путь Да в свг есть такая проблема во всяком случае в реализации Хрома если число точек Ну эмпирически мы установили что где-то если больше тысячи то всё начинает очень сильно проседать есть то есть вариант оптимизации свг - это банально разбить большой пад на э много маленьких на много маленьких и это гораздо будет эффективнее работать Спасибо за идею Я кстати попробую Ну в общем вот в этой демке проблема упирается в то чтобы найти данные но я попробую J который у меня есть разбить на отдельные страны и попробовать отрисовать их как-то Ну параллельно страны они тоже бывают разные там бывают большие страны бывают маленькие Да но в любом случае вот эта свка выглядит так что там Ну вот все вот эти изгибы стран описаны в виде отдельных точек конечно их больше тысячи потому что я думаю на одну страну может уйти тысяча точек то есть это я так понял у тебя там трёхмерное изображение пра Нет это очень интересно вам интересно послушать как как землю рисуют на самом деле на самом деле это делается Вот так это же всё сферическая геометрия и данные стран хранятся в виде координат То есть я данные скачиваю ровно один раз и данные хранятся в виде такого на контур страны в виде Ну там какого-то вот набора точек Ну то есть относительный внешний вид страны а потом чтобы отрисовать это в виде земного шара ты просто берёшь вот эти данные и Прогоняешь их через формулу которая соответствует проекции которые у тебя есть то есть у тебя есть абстрактные данные А чтобы показать их можно сделать по-разному и чтобы отрисовать их на земном шаре нужно использовать там сферическую геометрию Вот то есть ты просто умножаешь там каждую точку на Ну Прогоняешь через формулу и у тебя получается координата Угу А и ещё последний момент у тебя там был пример с комментарием который очищается как только пользователь нажимает на кнопку вот я бы хотел попросить никого так не делать потому что это очень бесит когда сервер возвращает пяти сотую ошибку а комментарий твой уже удалён а я говорил что это нужно делать только в случае успеха А если Ну вот здесь я не показал что произойдёт при ошибке потому что это был пример про успех Но если бы была ошибка я бы прозрачно показал внутри комментария то есть нене не это был Ты рассказывал в это время про то что он много раз пользовать нажимает О'кей Да но у него всё закончилось успехом То есть я не показывал что бы я сделал в случае ошибки А в случае ошибки я бы не не очищал комментарий Конечно нет Если ты не очищает комментарий тогда нужно уже показывать что э идёт процесс и и допустим дией блит кнопку я это делал Ну я ну ты не акцентировал на это внимание Просто чтобы так я зади кнопку Я сказал что кнопку больше не нажимать О'кей спасибо спасибо за доклад вот здесь а Ага у меня микрофон уже есть я вот здесь стою коротенький вопрос Вот был пример про скролл Да и про вычитание таймаута там соточка по-моему была а вот будет ли хуже решение если воспользоваться Windows Timeout и Кром то есть мы один раз в итоге проверим это В общем это это популярное заблуждение что trle - это Windows Timeout то есть кто это придумал Я не помню кто-то из вот этих больших парней там заказ по-моему на самом деле Это другая немножечко операция это когда у нас происходят вычисления часто А мы берм только часть из них но с равным промежутком времени то есть л - это когда у меня гарантированно раз в 100 миллисекунд выполнится а пример с таум будет работать так у меня пример с тайто не гарантировано раз в 100 миллисекунд у меня будет наполняться наполняться наполняться стек А потом когда у меня пройдёт 100 миллисекунд Уменя хоро Тука называтся при пользовательском вводе То есть если пользователь вводит то там нужно не рол использовать и там вот это вот показывать не помере ввода А лучше это делать балансом когда он довёл вот Игор Спасибо за прекрасный доклад Вот вот Хотел бы уточнить кое по оптимизации на просо было сно несение в слои А ведь это тоже в общем-то позволяет экономить время на анимациях передавать вычисление на графический процессор То есть как бы а передавать именно ту картинку которую просто нужно в разный момент времени там отрисовать в разных местах вот это Will change имеется в виду Да я согласен я согласен Просто у меня был доклад такой больше про про код а Will change - это уже такой ну декларативный IP - это к HTML больше относится к разметке Ну так или иначе тоже как бы способ оптимизации Ну ладно вот и второе собственно по процессору А как бы с теми бедными пользователями браузеров где собственно сервис воркеры не поддерживаются То есть если мы в нашем приложении завязываем се на то что какие-то тяжеловесные вычисления мы перекидываем туда нам Ну мы существенно ограничены в я понял в поддержке есть мне ещё очень нравится такая штука Как приоритизация задач например react это используют они собирают все задачи которые Ну по обновлению интерфейса которые им нужны и у них есть приоритеты определённых задач и они сначала выполняют важные с точки зрения отрисовки а потом менее важные и если у нас нет сервис воркера но нужно как-то всё это распределить мы можем набрать пул задач и в зависимости от приоритета выполнить сначала важные а потом менее важные Вот react fibber это под капотом делает И это круто Ну то есть я так понимаю это что-то в духе такого при блинные отрисовки сначала более грубые потом более деталь ту Ну это очень грубое упрощение Но примерно так да спасибо Привет Спасибо большое за доклад очень интересно у меня такой вопрос по поводу анимации дома пробовал ли ты использовать vs например да и проводил какие-то тесты это быстрее которые как раз таки направлены на улучшение производительности анимации именно дома Да нет я как раз-таки показывал всё Ну вот так хардкорно железно то есть анимация у меня руками вся написана просто было бы интересно вот именно такие тесты увидеть с точки зрения инструментов Ну это хорошая идея я задумаюсь Я же говорю у меня есть сайт на который я дополняют быть в течение времени я попробую и би они просто как раз-таки утверждают что вот они могут сразу очень много нот анимировать там без каких-либо лагов там и у них есть там тесты согласен с тобой но понимаешь там же под под этим под капотом то же самое что я прямо сейчас рассказывал и ну нужно понимать направление куда двигаться и если ты понимаешь что там вот эти библиотеки используют вот это то хорошо и это поможет Хорошо согласен да Окей спасибо особенно докладчику но время уже прямо вот прямо сейчас он начнётся уже следующий доклад нам надо подготовить Всё спасибо боль Спасибо вам большое У меня"
}