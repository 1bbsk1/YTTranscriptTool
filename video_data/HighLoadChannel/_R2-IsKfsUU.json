{
  "video_id": "_R2-IsKfsUU",
  "channel": "HighLoadChannel",
  "title": "Блокировки в PostgreSQL / Егор Рогов (Postgres Professional)",
  "views": 20431,
  "duration": 2922,
  "published": "2020-04-14T10:50:10-07:00",
  "text": "доброе утро всем меня зовут егор я работаю в компании по сгрыз профессиональный владели образовательных программ наша задача нести оргрэс людям с этой целью мы пишем всякие статьи и книги помогаем другим авторам писать книги про postgres сейчас мы заканчиваем работу над второй частью книги бориса сенхи новикова который называется основой технологий баз данных такой фундаментальный труд кроме этого мы готовим учебные курсы все что мы делаем есть у нас на сайте в открытом доступе это все можно брать смотреть читать изучать ну давайте к делу базы данных использует блокировки используют их достаточно активно блокировки нужны нам для того чтобы упорядочить конкурентный доступ к разделяемым данным понятно что с этой задачи сталкиваются не только база данных но и вообще любые программы поэтому у нас есть блокировки которые похожи на те что используются в обычной практике но в суде довольно много своей специфики поэтому спектр разных блокировок он на самом деле шире блокировки нужны без них мы не смогли бы обеспечить корректную работу д д с другой стороны блокировки могут очень легко стать источником проблем когда увидите что у вас есть процесс который вместо чтобы работать висит кто-то ждет и вот есть такой закон термодинамики мэрфи который гласит что под давлением все ухудшается так и тут если у нас есть высок нагруженная система то у вас больше шансов получить каких им проблем связанных с блокировками дальше буду говорить о том как блокировки устроены в подгрести и обращу внимание на те проблемные места которые есть в реализации начнём мы с обычных блокировок традиционных они используются для того чтобы защищать структуры данных оперативной памяти самое простое что тут есть это атомарной инструкции процессора которые работают на да там одной ячейкой оперативной памяти с одним адресом в этом случае для программы все выглядит так как будто никаких блокировок нет на самом деле не есть просто реализуется на аппаратном уровне это сделано эффективно и это хорошо к сожалению не всегда удается все построить исключительно на атомарных операций воскресе довольно много построенным на них но если есть какая то достаточно сложная структура там кончаешь таблица например то вот не получается обеспечить работу с ней исключительно там арно поэтому используется некий примитива синхронизации обычно они предоставляют с операционной системой их много разных с разными характеристиками но смысл сводится к тому что есть какой-то счетчик в простейшем случае нолика ли единичка нолик значит что ресурса нетс единичка что свободен работа со счетчиком производится естественно товарными операциями но обычно это компонент своп если какой-то процесс смог уменьшить значение счетчика до 0 он считаете что структура данных которая защищена блокировкой свободной с ней можно работать если процесс не смог уменьшить кто он встают в очередь его потом будет когда блокировка освобождать в адресе есть блокировка которую встроен аналогичным образом она называется легкой lightweight блок почему легкая потому что ее использовании не влечёт за собой каких-то серьезных накладных расходов но в связи с этим и инфраструктуру который предоставляется она тоже достаточно скудная есть два режима в которых такая блокировка может захватываться монопольный разделяемый монопольно используется когда нам надо поработать какой-то структурой данных и там что-то поменять ее может удерживать только один процесс одновременно а разделяемый режим используется когда нам нужен структура данных только прочитать соответственно несколько процессов мог ту делать одновременно и друг другу не мешать есть тучи эти ожидания но как мы увидим она не вполне честно и есть кое-какой мониторинг а вот чего нету нету обнаружения взаимо блокировок на самом деле не так страшно как кажется потому что у конечного пользователя доступа к таким легким блокировкам нет их используют только ядро субд и вот но разработчики ядра они уж как-нибудь разберутся на поэтому считается что это нормально куда смотреть в плане мониторинга есть такое представление пережили startactivity она нам показывает информацию на текущий момент времени о том что у нас происходит в системе какие есть процессы и какие у них есть ожидания если какой-то процесс ждет легкую блокировку мы увидим тип события lw лоб и в поливает event мы увидим название блокировки но в данном примере у нас процесс волрайд ждет записи журнал на диск а какой-то клиентский обслужишь процесс ждет блокировку под названием у фирмы pink про неё мы чуть попозже поговорим потому что она достаточно важная обычно недостаточно получить картину на текущий момент хочется понимать как у нас события развивались во времени единственный способ сейчас сделать это в подгрести сэмплинг то есть периодически и смотреть что находится в пабе startactivity и получать такие срезы в ядре возможности такой нет но есть несколько расширений например переживаете сэмплинг которые позволяют вот такой sampling осуществлять в примере которую видите на картинке у нас добавляется столбец со счетчиком он показывает сколько раз мы вовремя сэмплирования обнаружили процесс ожидающим именно эту блокировку если умножить этот счетчик на интервал сэмплирование мы получим примерное время ожидания этой блокировки почему примерно и потому что сэмплинг это вероятностный процесс и тут когда точных цифр и говорить невозможно точные цифры ядро к сожалению пока нам не дает только сэмплинг есть теперь вернемся к нашим блокировки буфера мэппинг блок посмотрим не подробнее ну легких блокировок очень много про все рассказать невозможно ног проекту чуть подробнее поговорим эта блокировка защищает хэш-таблицу который используется для доступа буферном укажу процессом чтобы найти выше нам кэша страничку которым нужно нужно понять куда смотреть вот для этого используются хэш-таблицы это хэш-таблицы прикрыта блокировкой буфер мэппинг те процессы которые хотят и таблиц штук читать они берут блокировку разделяемую режиме которые хотят ее поменять берут ее в монопольном режиме тут надо понимать что в этом смысле читающий пищей процесс это не то не то же что select там или скажем апдейт потому что select может вытеснять страницу из буфера ему для этого придется поменять хэш-таблицу а там например апдейт он может уложиться в рамках одной странице который уже была в буферном каши и в этом смысле ему не потребуется ничего менять в хэш-таблице поэтому ножка разные вещи что плохо в таком подходе то что такая блокировка очень быстро становится узким местом скапливается очередь процессов которые хотят что-то поменять и они могут делать только один за другим как это лечится ну стандартная практика разбить структуру данных на несколько частей которые независимы друг от друга и прикрыть каждую часть своей собственной блокировкой иными словами увеличить гранулярный в этом случае у нас очереди становится меньше и статус улучшается первый раз буфер мэппинг блок распилили еще версии 82 это был они с 2006 года и и разделить на 16 частей спустя 10 лет версии 95 количество этих от частей увеличивать до 128 а но надо сказать что на современном серьезном железе сотнями я der и 128 иногда бывает маловато очередь ожидания как я уже сказал не вполне честно и в чем это выражается если у нас есть какой-то процесс который захватил блокировку разделяем am режиме то когда у нас появляется еще один процесс который тоже хочет блокировку разделяемым режиме он проходит без очереди он не ждет всех пищей процесс которые сейчас в очереди стоят с одной стороны это хорошо потому что это увеличивает пропускную способность системы с другой стороны может возникнуть неприятный момент если у вас есть большой поток читателей они могут откладывать пишущий процессы на неопределённое время это проявляется когда у вас есть много ядер и есть большая большой поток процессов которые обращаются буферном у кэш особенно охотно это вылезает на ному архитектурах на этот случай у нас есть пальчики он написал саша коротков которые делают очередь ожидании более честный сожалению этот патч в общем случае может производительность ухудшать поэтому его применять стоит только тогда когда действительно есть к этому показания так теперь переходим блокировкам которые специфично именно для баз данных тут мы посмотрим на два вида таких блокировок первый вид это тяжелые блокировки еще не называются обычным дураками или просто блокировками почему они тяжелые в противовес легким да на их захват требуется больше ресурсов за счет этого мы получаем несколько более богатую инфраструктуру вокруг там есть множество разных типов этих блокировок множество режимов которых они могут захватываться они предназначены для решения самых разных задач и по сути все что их объединяет это как они внутри устроено у нас есть тучи эти ожидания и она честная в отличии от youtube блокировок у нас есть более богатый мониторинг перестать activity нам по-прежнему показывают ожидания процесса в том числе и тяжелое но есть еще представление пережил огс которая показывает все тяжелые блокировки системе которые есть и у нас есть обнаружение за им блокировок поскольку тяжелые блокировки используют в том числе при выполнении из куриных команд то конечный пользователь имеет некоторое влияние на эти блокировки и из воды должна быть готова к тому что что-то пойдет не так поэтому здесь без обнаружения взаимного трок обойтись нельзя для примера пара типов таких блокировок есть блокировки номер транзакции воскресе сделала так что каждая транзакция всегда в монопольном режиме удерживать свой собственный номер блокировка своего собственного номера либо реального либо виртуального зачем это сделано это сделано для того чтобы иметь простой способ подождать какую-то транзакцию вот в том примере которую видите на картинке второй процесс он хочет дождаться пока завершится транзакция в первом процессе с этой целью он пытается захватить блокировку номера транзакции которую полагается первом процессе естественную это не получается он засыпается и он будет разбужен когда первой транзакции завершится вот такой способ он достаточно часто используются второй пример это блокировка расширение отношения relation extinction отношением в подгрести называют таблицы и индексы и там некоторые другие объекты такие как последние стерилизованы представления но нас в первую очередь интересует конечно таблиц и индексов когда мы добавляем строчки нашу таблицу соответственно индекс мы заполняем файл данных который у нас есть и в какой-то момент место в нем заканчивается этот файл нужно расширять нужно добавлять к нему новые страницы вот на время добавления новых страниц и берется вот это вот блокировка которую в пережил огс видно под именем extend сделано для того чтобы несколько процессов не кинулись одновременно расширять один и тот же файл но самый главный тип блокировки такой это конечно блокировка отношений их видно в пиджи logs по типу relations эти блокировки используются когда вы какими-то сильными командами что-то делать с таблицами здесь есть целых 8 режимов в отличие от обычных дух вот они здесь перечислено а справа приведены примеры из школьных команд которые этими блокировками пользуются название режимов некоторые достаточно понятны и некоторые вызывают вопросы почему они так называются вот но самое главное эта матрица совместимости здесь ею не привожу но в документации по просьбе что она естественно есть большая таблица в которой нарисована какие режимы с какими совместима с какими нет запоминайте летит название режимов эту таблицу к и смысла нет но какое-то время над ней помедитировать достаточно полезно так я и туда вот так ну просто для примера самый легкий режим который здесь есть самые слабые the excess верхняя строчка его использует команда select когда вы просто делать selects таблице вы берете блокировку в режиме к саше а самая сильная блокировка это xs эксклюзив нижняя строчка ее берет например команд дроп что это нам дает это дает то что пока у вас выполняется запрос к таблице вы не можете таблица удалить что общем логично ну и наоборот если вы уже удаляйте таблиц что вам не надо обращаться книги запрос потому что сейчас все он не станет очередь очередь здесь абсолютно честно и с одной стороны это хорошо потому что это нам гарантирует что никакая команда не будет ждать вечно когда-нибудь да не очередь обязательно дойдет с другой стороны если вы не вовремя выполнить я кончу команду это может вас парализовать систему вот простой пример у нас есть было процесс который что-то читают из таблицы а select ученик может долго работает достаточно большой запрос дальше администратор запустил команду вакуума full которая берет блокировку xs эксклюзив и после этого система падают еще запрос на чтение select и они встают в очередь за вакуумом авакумов стоит в очередь за selecting и все это стоит и ждет пока доработают первые два запроса потом пока доработает вакуум и только после этого вас могут выполняться следующий запрос поэтому тут администратор надо быть аккуратным если есть шанс что ваша команда которая берет тяжелую сильную блокировку выполнится быстро а есть например команды типа вальтер ты был там некоторые на которые выполняются быстро но им нужно блокировка исключительно то есть такой известный трюк можно установить параметры лог тайм-аут в такое небольшое значение в этом случае если ваша команда за это время указано в параметры не смогла получить желаемую блокировку она завершается сообщением об ошибке и тогда вы ее можете потом еще раз повторить но по крайней мере у вас есть гарантии что вы не повезти всю систему надолго уж вакууму full такая история еще не пройдет потому что обычно он работает долго второй вид блокировок про которые я хочу рассказать их блокировки на уровне строк почему про них надо говорить что то отдельно делов в их количестве если таблиц и индексов у вас в системе ну наверное сотни может быть тысячи строк могут быть там миллиарда и больше шанс спокойно и соответственно каждую строчку заводить оперативной памяти отдельную блокировку тяжелую это удовольствие которое мы себе позволить не можем тут есть две стратегии которыми обычно пользуются с у б.д. первая состоит в том что мы все-таки заводим на каждую строчку отдельную блокировку но если мы видим что на таблицу уже находится определенное количество таких блокировок то мы вешаем блокировку на всю таблицу целиком а блокировки на уровне строк убираем то есть укрупнением блокировку повышаем ее уровень проблема тут в том что при этом теряется эффективность и без того чтобы блокировать отдельную строчку мы блокируем всю таблицу по сгрыз и многие другие субд и идет с иным путем он ставит признак блокировки непосредственно внутри страницы данных они в оперативной памяти в этом случае нам совершенно все равно сколько таких блокировок будет это ни на что не влияет по сути она появляются некоторые сложности с организацию очереди ожидания потому что чтобы подождать освобождения блокировки нам все-таки что-то оперативной памяти нужник поэтому приходится совмещать блокировки внутри страниц данных с обычными тяжелыми блокировками оперативной памяти но таких тяжелых блокировок нужно гораздо меньше пропорционально количеству процессов они количеству строк которые мы хотим заблокировать блокировки на уровне строк хранятся у нас внутри и заголовка каждой версии строки там есть такой поле xmax системная может быть знаете ну плюс специальные служебные информационные биты чтобы понять какие блокировки есть у нас на строчках нам надо реально прочитать страницу данных посмотреть в ней вот рушение пейджера looks которая нам такие блокировки показывают аннора он это и делает она не оперативная память смотрит а читает саму таблицу к счастью такие блокировки не надо явно освобождать потому что следующий процесс который заглянет страницу он посмотрит заголовки версий строк проверить все статусы и если чтоб сам поменяет всю информацию которую там есть для блокировок на уровне строк есть четыре режима два режима используются для изменения и 2 режим для чтения почему режимов 4 а не два как обычно дело в том что не которую некоторые изменения некоторые чтения можно совмещать когда мы меняем строчку в таблице как правило мы не меняем ключевые поля то есть поля который входит в первичный ключ или в какие-то уникальные ключи это обычный случай поэтому можем одновременно менять что-то в обычных полях и блокировать ключевые поля для чтения это друг другу не мешает поэтому 4 режима тут важно заметить вот что чтобы просто прочитать строку никакие блокировки не нужны вообще вот два режима для чтения имеется ввиду что вы явно хотите заблокировать строчку но в разделяемым режиме сам postgres делает это только в одном случае когда проверяет внешние ключи но в принципе вы можете сами этим пользоваться есть команда select ваше которая вот ставит блокировку на строчки в таком режим с о чуде ожидания тут все весело как это работает допустим у нас есть процесс который хочет заблокировать первую версию строке первое что он делает он на захватывает тяжелую блокировку специальным типом to pull the plot то же самое что версия строки если он захватил эту блокировку то дальше он может пойти внутрь строки и проставить признак там что он работает с эту строчкой после того как он это сделал он блокировку тип утопал отпускает поэтому если вы просто напишите об dates а потом посмотрите в пережил огс вы там ничего не увидите потому что блокировку the pale была захвачена и тут же отпущено если появляется еще один процесс который хочет обновить ту же самую строчку он тоже захватывает блокировка типа то пол но потом влезет строку видит что с ней сейчас работает какая транзакция и соответственно он повисает в ожидании завершение этой транзакции вот после этого еще может набежать какой-то хвост из других процессов которые тоже выстраиваются за блокировкой тапу вот получается такая двухуровневая схема с одной стороны у нас есть признак странице данных с другой стороны мы используем блокировку в оперативной памяти и у нас есть такая вот очередь как бы нам ни есть 1 который удерживает блокировку и все остальные которые стоят за ним проблемы начинаются когда первое транзакции завершает свою работу если она обновилась строчку это что означает что она создала новую версию этой самой строке 2 транзакция будет разбужена она увидит что версия строчки освободилось пойдет внутри таблицы заблокирует ее и отпустит блокировку типа то пол которой она удерживает но остальные транзакции которые стоят за ней и вот эта вот блокировка первой версии уже не нужно потому что сейчас актуальная версия 2 им надо менять именно ее поэтому получается что они стояли не затем чем нужно и над стоять с другой блокировкой и вот вся эта очередь рассыпается и перестраивается кто-то из них 1 и успевает схватить блокировка второй версии строке все остальные встают в очередь за ним получается такое вот перестроение очереди каждый раз что не очень здорово у нас над тем тоже есть пачек за авторством кости книжника который заменяет блокировку попал в данном случае на рекомендательную блокировку по первичному ключу таблиц это работает несколько лучше но к сожалению пока почти не доведем до такого состояния чтобы его можно было отдать ванильный под gris вот такая вот история что интересно вот это вот очередь ожидания на ко всему прочему ещё и нечестное примерно также как то с легким блокировками происходит если у нас есть какой-то процесс который удерживает разделяемую блокировку на строчку по процессы которые хотят получить блокировку монопольном режиме они конечно выстраиваются в очередь но если появляется еще один процесс который точку 4 стреляем блокировка он пролезает без очереди он даже не пытается взять блокировку тип то полон сразу прописывают себя внутри строки опять таки с одной стороны это хорошо потому что пропускная способность увеличивается с другой стороны если у вас вдруг откуда-то есть большой поток процесс в которой хотят разделяемые блокировки то вы можете таким образом затормозить процесс которые хотят строчку изменять обычно не происходит потому что разделяемая блокировка используется только при проверке внешних ключей но вот если вы в приложении сами их используют что в принципе такую ситуацию можно создать вот когда один процесс завершается второй процесс просыпается видеть что строчка по-прежнему заблокирована и он просто встает в очередь затем процессом которую строчку удерживают настоящий момент так теперь проза им блокировки поговорим иногда их называют тупиками эта ситуация когда у вас первый процесс блокирует 2 2 блокирует первые и они в таком состоянии будут бесконечно друг другу ждать на самом деле может быть это и не два процесса три или больше это в принципе не так важно взаимовыручки нужно обнаруживать что делать с ними чтобы их обнаружить нужно построить граф ожиданий ну типа того что нарисовано на картинке и поискать в нем контур если контура обнаруживается значит и из-за ему блокировка процедуру поиска она достаточно тяжелая поэтому сделал вот как когда процессу нужно схватить какую-то блокировку он звонит себе таймер на время до блок тайм-аут такой параметр есть по умолчанию равен 1 секунде и пытается получить блокировку если он получает блокировку за эту одну секунду значит хорошо ниши делать не надо но если за это время блокировку получить не удалось то процесс просыпается и инициирует проверку взаимо блокировки если выясняется что взаим блокировки нет то он дальше засыпает уже до победного конца а если взаимо блокировка есть тот процесс который инициировал проверку его система прибивает а все остальные продолжают работать нормально обычно взаимо блокировки вызванные какими-то ошибками в приложении как правило это связано с тем что одни и те же ресурсы блокируются в разном порядке в разных процессах но на самом деле не всегда вас может быть ситуация когда просто две команды апдейт которые обновляют одну и ту же таблицу за ему заблокируется вот например допустим у вас есть какой-то поток апдейтов которые меняют несколько строк в таблице вот власти апдейт выполняются выполняются в какой-то момент почему-то происходит какое-то какое-то замедление и несколько команд апдейт встают в очередь в этот момент у вас срабатывает вакуум который заодно перри собирает статистику по таблице и при этом план запроса может измениться например у вас одарит выполнялся с помощью яндекс к на а после перебора статистика он начинает выполняться с помощью bitmap индекс к на и тогда вот те апдейт которые стояли в очереди уже спланированные они идут работать со старым планом а новая бдует которые прилетают они работают с новым планом и для команда апдейт могут схлестнутся и заблокирует строчки в разном порядке будет займу блокировка это просто случай из практики так бывает вот по сути все что хотел сказать на самом деле сказать тут можно еще много чего но просто времени хватит а вместо этого я приведу некий пример тоже из практики в котором много из того что я говорил нашлось щеками все вместе вот представьте себе есть у вас система мониторинга она работает на достаточно большой железки там примерно скажем что я der происходит постоянная запись в одну и ту же таблицу каких-то показателей 15000 строк секунду вставляется дпс of меньше потому что они вставляются пачками но все равно вот достаточно большой объем вы где-то примерно 100 соединение открыто они делают одновременно с этой записью есть еще и активно чтение из этой таблицы какие симптомы работает система работает в какой-то момент она захлебывается и производительностью падает до нуля что произошло чаем разбираться выясняется что система все свое время самозабвенно ищет за ним блокировки проблема с ними какая пока мы строим этот граф ожиданий нам нужно заблокировать монопольно все структуры которая то есть к тяжелым блокировкам чтобы не появлялись новые процессы чтобы граф не менялась пока мы устроим поэтому не то чтобы прям вот со всей системы встает на любое действие которое требует тяжелые блокировки но встают в очередь по сути все замирает особенно все плохо когда несколько проверок инициируется одновременно они там еще как-то друг другу начинает мешаться и общем совсем все становится плохо есть на эту тему пара пачиков один написал ей сколов этот патч пытается часть работы по поиску взаимо блокировок делать без монопольного режим становится чуть легче другой патч сделал кости книжник он не дает нескольким проверкам работать одновременно то есть они выполняются получили то есть какие-то такие вот припарки значит можно делать но это все борьба симптомами а в чем причина оказалась что причина в блокировки расширение отношения relation in extinction в чем с ней сложность а до версии 96 по адреса файлы всегда у нас увеличивались за раз на одну страницу ну представьте себе если вы вставляете 15000 строк в секунду то каково это значит по одной страничке файл расширять на это очень эффективно к счастью в 96 сделали так что таблицы расширяются сразу на некоторое количество страниц блоком но расширение индексов по-прежнему в пол эгриси работает именно так за раз одна страничка и вот именно это стало узким местом саша коротков написал патч который чинит расширения индексов и теперь они у нас расширяются тоже как и таблицы сразу группами страниц мы надеемся этот патч отдать ванильный под grease какой-то ближайшее время вот а почему за ним блокировки но дело в том что когда у нас несколько процесса встают в очередь за блокировкой relation to шин проходит время которое отведено в параметры d-блок тайм-аут и они запускают процедуру поиска за им блокировок 1 потом 2 потом 3 и все это снежным комом накапливается и система больше ничем уже не занимается кроме как проверяет займи блокировки все встает ирония в том что в этом месте взаимо блокировка вообще невозможно то есть эта процедура вообще не надо запускать и самое лучшее что тут есть это еще один патч который сделал ооо масахико савада который заменяет тяжелую блокировку на легкой в этом месте и тогда поиска взаимопроникает it out ровно то что нужно но этики к сожалению патч пока не доведён до состояния которым он может быть принятым автор его подзабросил но вот почесть с помощью всех этих вот заплаток удалось система привести в состояние когда она перестала заниматься за им блокировками стал делать что полезно и вылезла еще одна проблема то есть производительность ставок по прежнему была неудовлетворительной а оказалось что теперь проблема в том что есть активное чтение смышленого кэша и это чтение за каширу им страничек она за счет нечестности очереди легких блокировок откладывает изменения новых страниц на неопределённое время ставка должна заменять страницы а она это сделать не может потому что постоянно идет чтение вот в этом случае как я уже говорил помогает патч сделанный саша коротковым который очередь этих легких блокировок делает несколько более честный чем она есть на самом деле вот мы не надо пренебрегать организационными мероприятиями зачастую удается снизить нагрузку какими-то орг мерами если это невозможно сделать другими способами классический пример вы можете сделать так что с например днем работают пользователи да а ночью когда пользователи спят вы запускаете какие-то тяжелые задачи то есть можно разнести нагрузку по времени а в данном случае клиент просто разделил свою систему мониторинга на несколько частей и каждый из этих частей стала справляться с той нагрузкой которая на нее подала вот наступило счастье давайте некоторые выводы значит сделаем к сожалению тут очень сложно давать какие-то советы и по если так то делай так и вот будет счастье тогда потому что любой совет в каких случаях работать в как их то нет поэтому на мой взгляд единственный правильный путь это понимать как систему устроено внутри и разрабатывать систему с учетом этого понимания в качестве какого-то универсального совета можно порекомендовать избегайте всякого рода горячих точек если вы из нескольких процессов одновременно обновляете постоянно одну и ту же строчку например то скорее всего в этом месте у вас вылезет какая-нибудь проблема не надо пренебрегать рубин сонными мерами если техническими уже не получается справиться вот ну и в крайнем случае да есть поддержка вендора которая помогает с трудной ситуации справиться с проблемой потому что хорошо иметь специалистов которые могут смотреть квалифицировано на ситуацию разобраться и предложить какое-то решение возможно связанная с изменением кода самой чтобы дать так вот внизу тут есть ссылочка на серию статей на хабре там про блокировки написано гораздо более подробно и детально чем я успел рассказать сейчас на этом у меня все спасибо можно задавать вопросы если если вам захочется задать вопрос потом то вот адресок который вы всегда можете написать письмо два вы заметили я выразил бутылку пластиковый в специальный контейнер у нас на входа в зал и есть такие в общем и вы может быть читали в чате об этом что можно раздельно вернее выбрасывать мусор поднимайте руки те у кого есть вопросы вот я вижу в первую руку наверное оближи дам микрофон вот вы говорили что в пускались начиная с версии 95 принять 128 ограничение дано количество lace я так понимаю либо кидз lace количество блокировок на группу baci вот а этот параметр он как-то меняется в меня возможно изменить количество лачи да пусть мы высоко нагруженной базе с большим размером кэша может ли вы быть такая необходимость повысить его можно поменять в исходных кодах там define стоит если вы сами postgres собирается вы можете поправить пересобрать но вот качестве параметра это не вынесенные как еще руки ребята по тебе поднимайте пожалуйста руки заранее чтобы мы вам могли микрофон передать если есть вопросы поднимайте прямо сейчас спасибо вопрос прадед локи вы сказали что апдейт при перестроении плана может все перепутать и сам себе помешать без перестроения плана в апдейта разве задан какой-то порядок который гарантирует что он сам себе не будет мешать вообще как этот порядок устроен когда мы валим кучу апдейтов и они не должны ничего себе попортить ну довольно сложно создать такую ситуацию при которой два апдейта будут работать в разных порядков но обычно клип секс can который идет в одну сторону вот но в принципе можно такую ситуацию получить никто не гарантирует что 2 да это не не взаимо запираться это может произойти это не часто случается но это может случиться если задаться целью построить такой пример его можно сделать но приходится вышка попотеть потому что вот он не сразу хочется надо чтобы один пошел в одну строчку сторону строки обновляется другой в другую ну или как то так ну в общем да обычно везет все-таки либор тоже стороне вопрос и поднимать руки кто еще хочет спасибо случай в нашей практике у нас происходит каскадное удаление некоторое удаление объекта и потом еще каскадная и во второй таблице которые множественные отношения имеет туда идут активные там апдейты и чтения и происходит предло который у нас на патч повисает вопрос как с этим бороться если бы это был блог он бы не повисал на парни он был бы разрешен просто запрос повисают и все опять там что-то действительно повисает значит тут не до блок значит и какие-то ожидания но это надо смотреть гарри его вопрос об их практика при каскадных удалениях таких что у нас в одну таблицу сейчас много чего много апдейтов и select of a идет удаление из другой таблицы с каскадным я наверно так вот в общих словах не скажу может быть хорошо посмотреть что-то действительно происходит потому что но можно сказать спасибо скажете вот ситуацию с заголовками сдано высоконагруженные базе вот это и нельзя было тайм-аут увеличить без всяких патчей не помогало то есть она чуть дольше держалась но ровно загибалась вот еще вопрос и вот здесь вопрос еще поднимите руки руки пожалуйста спасибо случай из практики есть несколько таблиц ну там понёс к миллиарду строк и одна таблица там не особо ногу строк вот и каждый из таблиц она jojen с этой таблицей но это на время несколько select of и после этого и зарница в одну таблицу все если делать только с одной таблице join и это insert the все нормально а если я делать это параллельно несколько вопросов таких запросов select + insert the производить очень сильно падает почему может такое ну такие вопрос сложно отвечать так вот ничего не видя надо смотреть все запросы ну я имею то что он может быть это предлог низким антилопами связывающими ты ли вряд ли а само соединение быстро работает да да нужно чуть больше детали да ладно домов может быть это вот такие вопросы можно обсудить после доклада дискуссионный огонь если может показать вот как вы какие есть еще вопросы поднимите руки у кого не появились а вот я вижу спасибо есть таблица в которой происходят активные не тверд и и дали ты и вдруг одна строчка блокируется минут на тридцать вот как будет вести себя в этом случае of the vacuum ну в нашем случае у нас просто зависала системы и кбм базы данных переставала акты адекватно отвечать а почему строчка блокируется на 30 минут открывается транзакция делается с select for a bit и транзакции висит 30 минут долго долго висит ну обычному вакуум это мешать не должно он просто пропускаете странице которыми может работать идет дальше чуть не смущает это может мешать вакууму когда он делает заморозку тогда он действительно должен там дождаться освобождения но это не должно очень часто происходить то есть возможно о чем-то другом все-таки не внесла как связано но удержать блокировку строки 30 минут от cais плохая идея согласен вот так что шубу красиво у нас я вижу еще один вопрос вопрос то что вот вы рассказали по поводу проблемы с производительности это очень похожа на нашу проблему тоже то есть у нас скажем есть какой-то отель процесс который мы в течение дня запускаем утром он работает замечательно хорошо к обеду уже похуже к вечеру он совсем плохо работает на следующий год на следующее утро все замечательно ну то есть наше предположение что сработал вакуум и стала все хорошо вот как определить то ли это проблемы из-за того что появляется уйма мертвых строк то ли эта проблема вот как вы рассказали что там идет поиск стал взаимных блокировок какая отделить одну ситуацию другой ну смотрите дауд есть эти вот табличка про которые говорил пиджи startactivity который нам показывают что происходит если вы подозреваете что вас дело в том что накапливаются мертвые строчки то можно пытаться оценить насколько у вас таблицы распухают но то как вы говорите это возможно в случае если вы of the vacuum не пользуетесь запускаете вакуум по ночам это не так тогда но это вот тогда надо смотреть насколько у вас успевают таблицы распухнуть задними потому что есть таблицы увеличиваются в размере это естественно ухудшает всех сканы им дольше приходится работать но и в плохом случае это может и на индексах сыграть если у вас индекс на уровень вырастет лишний то тоже будет не очень хорошо вот есть расширение перестать тапу которая позволяет посмотреть распухание таблички и есть всякие запросы они в пузыри совы и вики есть поищите там послал бог там есть ряд запросов тоже можно имя попробовать оценить степень распухание возможно действительно в этом дело один очень короткий вопрос мы еще успеем до спасибо огромное спасибо за доклад вы упомянули что в ядре и пока не существует точного механизма подсчета el w лоб вопрос какие есть альтернативы то есть например там профилировщика операционной системы baby лев или еще что-то как можно общей их посчитать посмотрите не ленись и так далее сейчас еще раз что ходить ну как бы кроме сэмплинг а то есть apple рование не даёт нам информацию об их количестве сколько они как каждый задержалась и так далее если какие-то возможности построить гистограмму ну кроме sampling ничего нет на самом деле то есть это все что все что есть у нас от сэмплинг больше егор спасибо огромное за доклад медлить и ведь почетная грамота и великолепно полезное в путешествии к надеюсь ты выступаешь на конференции не только в родном городе называется нас sr я узнал это слово несчастна да то есть косметичка в девочку мальчиков на ссср или может быть там какие-то более тонкие различия спасибо большое the clutch его скажи пожалуйста какой вопрос понравился тебе больше всего данный сложный вопрос сложный вопрос который пусть будет вопрос про бот вопрос про bloat выходи сюда пожалуйста про вопроса так давай сделай это быстро пока идешь вспомни как тебя звать где работаешь почему ты задавал именно этот вопрос меня зовут игорь деев меня зовут игорь деев я работаю в башне пи нефть вопрос ну собственно это наш актуально проблем с которым учат боремся спасибо большое и тебе приз вот-вот докладчика за лучший вопрос"
}