{
  "video_id": "RGkY-pz2LG8",
  "channel": "HighLoadChannel",
  "title": "Тестирование на бэкенде. Рекомендации по написанию, виды тестов, пирамида на бэке / Руслан Измайлов",
  "views": 945,
  "duration": 2384,
  "published": "2023-10-06T07:16:05-07:00",
  "text": "Всем привет Меня зовут Руслан Я работаю бэкенд разработчиком в Avito я пришел не так давно поэтому сегодняшний материал это больше результат своих личных размышлений и рассуждений мы поговорим про тесты и первое С чего начнем А зачем вообще нужны тесты вот однажды я курировал стажера и Он задал мне этот вопрос весьма интересная формулировки говорит Слушай тесты это ведь тоже код зачем писать код который тестирует другой Код да И на самом деле такая формулировка моменте вела меня в ступор я не нашел что ответить Вот и немножко подумав Я понял что нужно максимально простая формулировка Вот и Давайте вспомним Как выглядит процесс разработки то есть мы что-то делаем какую-то доработку и получаем какой-то мы все веб-разработчики вот и получаем в конце насколько мой товарищи ответственны хотим нашу работу проверить и что мы делаем мы делаем запрос в постмане либо это может быть куру Не суть важно выполняем этот запрос проверяем respons как бы все здорово Идем дальше Передаем задачу на код review как правило квадривью не обходится без замечаний мы делаем какие-то доработки снова выполняем ручную проверку и дальше уже Передаем сдачу на тестирование Вот снова получаем замечание снова делаем доработки и благо мы сохранили наш запрос в космоне и выполняем его снова и проверяем да то есть Обратите внимание что даже в ходе там не сложно задачи мы проводим там несколько циклов э ручного тестирования вот если приложить чуть больше усилий то можно увековечить эту проверку в виде автоматического теста то есть самая банальная причина почему нужны тест это автоматизация то есть наверняка был какой-то очень ленивый разработчик которому надоело тестировать всё вручную и он придумал тесты вполне возможно было так вот следующий кейс который встречается на квадривью слушай все слишком очевидно тест не нужен взглянем на следующую функцию и на первый взгляд она окажется идеальной надежной и безупречный я думаю что мало кому придет голову писать песню такую функцию но тем не менее можно сделать там простой проверку на пограничных условиях и мы поймём что наша функция не так идеальна как изначально казалась Да что с этим делать решать вам Возможно вы там поменяете тип данных на флот Возможно вы там по этих продукту и уточните то есть какого порядка могут данные приходить вот Возможно вы ничего не сделаете но факт в том что э то есть простой тест заставит вас как минимум подумать и задуматься О том что ваш код может быть не так идеален как сперва показалось вот и что я считаю самое важное это Баги и повторяющиеся баги вот представим следующую ситуацию мы бродим по просторам проекта и опадаем попадаются на вот такое незамысловатый код Он написан Давно он работает и приносит деньги вот но там Лично я перфекционист и вот у меня глаз цепляется за эту костыльную проверку Почему Да хотя Казалось бы должна быть там трущена проверка да Ну вот и я скрипят зубами Думаю нет всё надо поменять и меняю на трущую проверку диплою и хожу счастлив потому что всё классно дёргается всё прекрасно вот но спустя время появляется бак мы начинаем разбираться в чём дело и оказывается что пришёл ноль Да я думаю не сложно понять что с нулём поведение двух проверок разное и что мы делаем мы возвращаем код в исходное состояние и забываем как страшный сон Ну на самом деле очень важным в такой ситуации будет можно взять и этот кейс с нулем покрыть тестом ведь После Вас могут прийти такие же перфекционисты которым тоже захочется сделать эту гениальную оптимизацию и наступит на те же грабли на самом деле это реальный кейс потому что на прошлой работе мне попался такой код и я открыл историю Китая и увидел там что в этой оптимизация повторялось несколько раз один человек пришел там оптимизировал условно за ним приходит другой править бак и так несколько раз к слову тест так и не написали Вот теперь давайте обсудим каким же должен быть идеальный тест вот Первое это тест должен нам что-то гарантировать то есть мы ожидаем что если тест прошел то наш код работает можно диплоить следующая Мы хотим чтобы Тест был покрывающим о чем это говорить то есть покрыты все сценарии которые только возможны если тесты Прошли мы уверены в том что работают абсолютно всё и работает корректно дальше мы не хотим заморачиваться Мы хотим чтобы у нас тесты были без окружения да то есть мы не хотим какое-то тестовый кластер сервис диплоить мы не хотим там тестовую базу поднимать хочется чтобы всё было Вот максимально просто примитивно взял любой проект начал писать тест и там запускать и пользоваться вот следующий момент это скорость да то есть теста должны быть быстрыми Я думаю многие из вас сталкивались ситуации когда тесты проходят там 10-15 а то и 30 минут Да особенно это критично когда там Пятница вечер конец принта и хочется Там побыстрее все задеплоить А у вас pipeline там вы ждете его полчаса поэтому тесты должны быть быстрыми вот также они должны быть стабильными да то есть я думаю тоже Там многие сталкивались ситуации когда там зависимости от порядка либо количества тестов они проходят по-разному да то есть мы хотим чтобы тест либо всегда проходил либо всегда падал чтобы не было такого что один раз прошёл а другой рассыпал то есть мы не хотим тратить время и разбираться в причине нестабильности Вот и независимые тоже я считаю это важно характеристика потому что мы часто меняем реализацию делаем какой-то рефакторинг и очень хочется чтобы При этом тест приносил пользу и показывал настолько успешно прошёл рефакторы но к сожалению не всегда так выходят вот Ну дальше мы это обсудим Теперь давайте посмотрим как можно протестировать вот такое незамысловатый код это Action and Point там на получение товаров то есть мы предположим пользователя вводят страховку это поисковой запрос и получает список товаров с ценами вот и что мы хотим проверить первым Мы хотим проверить базовый успешный сценария что у нас все работает второе Мы хотим попробовать сделать поиски с разными поисковыми запросами посмотреть как у нас обрабатывается там кириллица латиница спец символы и регистр Вот и также мы хотим проверить ценообразование как у нас формируется вот ну там сходственное образованием будет чуть-чуть дальше развёрнут Вот и начнём мы с первого пункта это просто проверим что у нас всё в связке работает и напишем функциональный тест Да что такое функциональный тест в моём понимает тест который проверяет всю функциональность целиком то все компоненты в связке вот что важно Важно то что мы используем реальную инфраструктуру мы поднимаем там базу данных наполняем текстурами вот как в этом примере логини пользователя Ну и собственно пишем сам тест принципе он значит просто выглядит выполняем запрос и сравниваем response с ожидаемым вот кажется Все очень просто Давайте обсудим насколько вот такие тесты могут быть насколько они идеальны в принципе вот Первое это тест действительно он гарантирующий потому что мы используем все компоненты в связке мы используем реально инфраструктуру я думаю что такой тест более гарантирующего наверное уже ничего не придумаешь вот к сожалению его нельзя назвать покрывающим потому что мы делаем просто запрос и при этом стригирить какой-то специфичный кейс например там с ошибкой база данных с помощью такого теста не получится поэтому к сожалению все кейсы с помощью специального теста не протестировать вот без окружения но к сожалению тоже не без окружения потому что нам нужно задеплоить приложение нам нужно поднять контейнер с базы данных наполнить тестовыми данными вот быстрым тоже не назовешь потому что у нас опять же поскольку используем реальную инфраструктуру у нас происходит запрос запрос базу данных это все время вот со стабильностью тоже проблема потому что поскольку используется реальная инфраструктура которая сожалению не ну то есть в любой момент может отказать то такие тесты имеют свойство иногда проходить а иногда нет вот и последнее это Независимый да такой тест Я считаю независимым потому что в принципе пока у вас контракт не поменялся Как как не переделывая реализацию тест будет работать например после рефакторинга тест покажет насколько успешно и факторы вот рекомендации по функциональным тестам я стараюсь писать хотя бы один функциональный тест на каждую точку входа в нашем случае это end point да то есть обычно это просто какой-то успешный сценарий если хватает если есть Время и терпения то можно добить еще всякими негативными тест кейсами Вот и также Мне кажется важным формировать тест-кейс именно на основе контракта да то есть наверное будет странным с помощью api-теста проверять там отправилась или не отправилось письмо пользователю Потому что сам респонс этого верх не отображает Поэтому я считаю что нужно проверять то что явно видно респонденция вот двигаемся дальше Мы разворачиваем наш Код Да и уже проваливаемся в сам айтом searching Service Вот и видим что уже с первым пунктом мы справились и переходим дальше А как же проверить что там у нас разные запросы работают нормально там с кириллицей латиницей и так далее вот опять же напомню что написать еще функциональные тесты нам не выгодно потому что они не быстрые и нестабильные поэтому нам нужно придумать что-то другое потому что нам нужно много тут эскизы набросать Вот и если Обратите внимание на код видим что у нас есть Нам повезло у нас есть репозитории в которой пробрасывается поисковой запрос и почему бы не протестировать этот репозитория на репозитории мы напишем интеграционный тест Да что такое интеграционный тест в моём понимании этот тест который проверяет взаимодействие бизнес-логики с инфраструктурными компонентом да то есть э-э в нашем случае есть репозитории которая возвращается сущность сущность это э-э это наши предметная область А сам репозиторий его реализация это инфраструктура то есть база данных как раз-таки вот стык без слов если проффиктуры и такие стыки лучше всего проверять миграционными тесты а тут принцип тот же мы используем реальную базу данных тоже там инициализируем ее как-то наполняем тестовыми данными и пишем тест принципе тоже выглядит не сложно мы просто выполняем поиск там проверяем Что у нас там вернулся нужен список товаров то есть опять же кажется Все очень просто но давайте тоже вернемся к тому насколько такой тест может быть идеальным Вот первая гарантирующий дату тут уже я выделил раньше свет потому что он гарантирует только взаимодействие инфраструктуры мы проверяем только то что у нас репозиторий работает корректно Ну к сожалению там арбасой репозитория не означает что у нас в целом функциональность работает правильно то есть этот тест он гарантирующий но менее гарантирую чем функциональные дальше покрывающие также он с ним можно покрыть больше кейсов чем функциональным тестом потому что мы Тестируем конкретные нам проще из кейса набрасывать Вот но опять же Вернемся с проблемой там допустим кейсы комбы специфичной ошибкой база данных но при этом стригирить какую-то блокировку BD очень сложно поэтому как бы все кейсы тоже к сожалению проверить не получится Вот он также не без окружения потому что нужно развернуть там приложение Развернуть базу данных вот он быстрее чем функциональный тест но опять же поскольку инфраструктура мы используем он всё равно не так быстро как нам хотелось бы вот стабильные тоже стабильнее чем функциональные но всё равно как бы есть куда расти хотелось чтобы он был более стабильный потому что всё равно Я думаю сталкивались ситуация когда там тесты запускаются параллельно бывает там один тест текстуры другого и происходит Вот такие неожиданные падения Вот Но зато этот тест Независимый опять же пока интерфейс репозитория не поменяется наш тест не будет нуждаться в доработках то есть мы можем там использовать другой драйвер или другую рынку сам тест продолжит приносить пользу рекомендации с помощью интеграционных тестов покрываем все стыки с инфраструктуры это могут быть репозитории почти клиенты в принципе любые другие там компоненты ввода-вывода Вот и сами компоненты делаем максимально тонкими это просто Случайность репозитория мы просто достали данные из базы И смапились да то есть не стоит репозитории пихать какую-то дополнительную обработку потому что задача репозитория - Это только взаимодействие с инфраструктурой Давайте Вот так и оставим только взаимодействие И тем самым нам проверять мы будем только взаимодействовать Вот Но вот мы пример репозитории мы увидели Но вот интересно как же тестировать HTC клиенты потому что кажется если там репозиторией Понятно Мы развернули базу данных ходим в эту базу все окей Ну допустим кейс со сторонним API Да что делать мы же не можем прямо в тесте Да там использовать тестовые API какого-нибудь нашего партнера Она же может просто там отвалиться быть недоступна и Странно что наши тесты будут очень нестабильными из-за этого вот но решение есть можно использовать э мог серверы есть разные решения мы используем Hover Fly Вот и у ховерффая можно настраивать э эмуляцию ответов сервера То есть вы просто описываете пары запрос ответ разворачиваете сервер в тестовой среде и ваши тесты ходят Ну они в API партнёра А ваша мог сервер то есть тем самым вы проверяете инфраструктуру проверяйте что вас а клиент работает корректно но вы не зависите от нестабильности стороннего API вот двигаемся дальше здесь уже Мы разворачиваем тело форыча тут видим что это происходит какая-то незамысловатая логика с ценообразования Вот и вспоминаем что в одном окраске я осталась проверить Последний пункт ценообразования Вот теперь у нас есть понимание Что ага там репозиторий протестированы нам их проверять не нужно и остаётся прямо а кусочек цена ценообразования вот тут мы уже напишем Юнит тест да Э что такое Юнит тест unite-тест - это тест который проверяет отдельный компонент без взаимодействия инфраструктуры Да почему я говорю компонент Да я не использую слово класс Потому что есть Ну в моём как мне кажется это небольшое заблуждение что юнитест должен проверять только конкретные класс А все остальные зависимости Не важно какие они должны могут Мне кажется такой подход он не очень перспективный Вот потому что а ну зачем все подряд мокать мне не совсем понятно Вот я считаю что нужно вот unit-тестах изолироваться только от инфраструктуры посмотрим как это выглядит то есть мы делаем некую инициализацию то есть подготавливаем Оки создаем тестовый экземпляр сервиса Вот и также пишем тест вот принципе тоже как как и прошлые тесты кажется что блин все хорошо Да Почему эти тесты не писать Вот но опять же есть свои преимущества и недостатки которые мы сейчас обсудим Первое это я считаю минусы не тестов в том что они нам гарантируют минимум они гарантируют только то что наш код работает так как мы этого ожидаем потому что мы вот замокли репозитории и просто проверили что Ну вот что кусочек ценообразования работает правильно на самом деле там Что что вернет репозиторий непонятно вот поэтому тут гарантия минимум потому что он мог вот покрывающий да это тесты Они самые покрывающие потому что опять же мы все мокрым можем допустим там тот кейс репозитории там с блокировкой например можем замокнуть драйвер репозитория там вернуть какой-то Exception и Ну в принципе можем проверить абсолютно любой кейс вот без окружения Да супер нам вообще ничего не нужно нам нужно просто создать Файлик с тестом настроить моки и всё погнали дальше быстрые поскольку мы изолированы от инфраструктуры у нас нет реальных операций ввода/вывода такие эти тесты самые быстро стабильные по той же причине это теста изолирован инфраструктуры изолирована от внешних факторов поэтому они очень стабильные их легко параллелить Вот это точно плюс вот но есть существенный минус как правило Unit тесты факторинге приходится кардинально переделывать либо просто удалять и писать заново и лично для меня вот кейс-факторингом он самый чувствительный потому что и факторы часто приходится делать И вот ты ждешь что блин тесты есть они тебе помогут понять что всё хорошо или всё плохо Ну ты просто открываешь с тестами там всё красное потому что надо теперь заново всё замокнуть вот и это реально проблема вот но над этой проблемой можно поработать Давайте посмотрим Ну то есть один из вариантов как можно эту поэтому решить вот Ну вот например Здесь пример простого рефакторинга мы просто взяли и логику ценообразованием вынесли в отдельные компании на самом деле ничего кардинально не поменялось просто взяли кусочек кода несколько строк и принесли в отдельный класс Да ну разве должен тест пострадать казалось что не должен но тем не менее тест пострадает потому что мы в тесте вручную инициализируем класс и нам нужно либо замок этот прайсер либо передать реально экземпляр прайсера Да и кажется что Ну вот это просто банальные банальные факторы уже Ну настась не переживай банальные факторы вот и что можно сделать первый шаг это надо подготовить стабы это вспомним Что там у нас были репозитории вот что такое stop это просто тестовая реализация какого-то компонента вот тут мы сделали стаб для репозитория пользователя то есть схема очень простая мы просто там взяли два яичника делаем свечки думаю всё понятно То есть в принципе стаб очень простой аналогичную операцию мы проделаем для репозитория товаров Вот и дальше что по этим нам пользоваться э дело вступает контейнер зависимости вот мы можем в контейнере зависимости настроить что а дружище Давайте нам в тестовой среде будешь вместо реальных компонентов подсовывать стабы а боевой среде Ну уже боевые реализации вот есть таким подходом посмотрим что у нас получается то есть было так стало вот так вот возможно это спорное решение потому что кажется что как бы в июне тестах контейнер используется не должен Но на самом деле оно достаточно эффективное и реально приносит пользу потому что во-первых вы стабы можете переиспользовать в разные тесты Вы один раз создали стаб и можете использовать во всех тестов контейнер будет всегда его тестовой среде создавать Вот только вам возможно придется эти стабы дополнять какими-то новыми данными например новый тип пользователя добавить или какие-то новые товары там репозитории подавлять Вот и посмотрим что у нас получилось то есть да мы улучшили независимость теперь при рефакторинге у нас тесты будут собирать меньше потому что мы не делаем никакую ручную инициализацию Вот Но при этом у нас как бы простота самого теста характеристика без окружения да то есть теперь нам нужны какие-то слабые нам уже Конфи контейнера зависимости на принципе нужен самый гадание зависимость уже какое-то минимальное окружение оно появилось но тем не менее там основную боль Я считаю мы устранили теперь вот до этого мы там спирали что-то там в примерах были моки потом стабы и вы давайте обсудим чем они отличаются это это можно создать с помощью PHP Union то есть на самом деле PHP тоже может создавать стабы то есть не обязательно делать там пример который я ранее привел Вот то есть печь перьями тоже позволяет делать стабы Вот в чем разница Остап это просто так как бы тупая тестовая реализация где просто вот метод Get будет вращать пользователя вместе с Табу всё равно вызвался метод не вызвался то есть абсолютно без разницы вот а мог при этом э-э мы настраиваем то есть мы ожидаем вызов метода то есть мы понимаем что вот у нас метод Get в муке должен вызваться один раз если он один раз не вызвался то тесты упадёт вот я стараюсь чаще использовать стабы Вот потому что в это ожидание вызова оно сильно привязано к реализации его компонента Тестируем потому что вам нужно открыть код посмотреть там А сколько раз этот метод вызвался Сколько раз в другой момент выдался таком порядке они вызвались то есть И при этом использование моков оно уже делает тест не независимым потому что как только у вас меняется реализация Как у вас меняется там количество вызовов метода у вас начинает падать хотя на самом деле сами проверки остаются актуальными Вот Но бывают ситуации когда без мока не обойтись но при этом Читающий метод непонятно вот мы делаем ставку которая что-то возвращает вот а что делать с пищей методами метод репозитория Да как с ним быть Он ведь ничего не вернёт Вот и тут как раз-таки мокки могут быть полезны потому что мы можем ожидать именно вызова этого метода вот рекомендации по Unit тестам это первое покрываем все безслойку да вспомним что у нас уже инфраструктура протестирована у нас функциональность в связке протестирована и остается только бизнес-слойка и опять же поскольку почти во всех приложениях бизнес-логике больше всего а Unit тесты очень быстрые и стабильные то как раз таки Им тут самое место дальше Unit тестами можно дополнять иммиграционные тесты вспомним пример там с базы данных мы там на репозиторе написали интеграционный тест какой-нибудь специфичной ошибкой что не мешает дополнить его Unit тестом то есть замок и драйвер и воспроизвести любую ошибку дальше больше стабов меньше моков на предыдущем слайде в принципе обсудили Вот и простые компоненты Это простые тесты да то есть если у вас код тяжело тестируется то возможно имеет смысл подумать о том что проблема не в тесте отправляем в самом коде Возможно у вас интерфейс не очень хороший можно как-то интерфейс поменять Вот то есть в первую очередь я думаю надо в эту сторону смотреть Вот теперь давайте обсудим Вот блин как-то я задался вопросом Зачем все так сложно Почему нельзя было просто найти вот мы пишем тесты все Зачем надо было придумать Там юниты интеграционные просто хотим писать и не заморачиваться Вот но обоснование есть они всё-таки отличаются Нам нужен только кот их в принципе можно легко запускать параллельно для интеграционных тестов нам нужна уже инфраструктура и параллельно их запускать сложно вот и если она в коде явно разделять интеграционные И юниты то это можно просто сделать Там две папки либо можно сделать То есть мы используем аннотации то есть мы интеграционном тесты помечаем аннотации которые парсятся при выполнении тестов то можно оптимизировать наш paypaline Вы можете запускать на более ранних этапах потому что тебе не нужно диплоить приложение никуда нужно просто код и Нам нужен PHP в принципе то есть мы можем есть например у нас упал какой-то unitest то у нас пайплайн упадет гораздо быстрее потому что мы еще даже не дойдем до диплои приложения в тестовую среду в принципе такое разделение позволяет нам делать всякого рода оптимизации например опять же можем там часть юнитистами запараллелить а часть тестами вот посмотрим что у нас получилось в результате Можно прийти к выводу что идеального теста они существуют если мы хотим писать хорошие тесты то нам придется их комбинировать учитывая их сильные и слабые стороны вот теперь можно на основе там да как бы прошлой информации обосновать Вот почему вот пирамидами тоже это был вопросом Вот почему-то почему вообще пирамида почему она так выглядит Вот но обоснование всему есть начнем с верхушки пирамиды это функциональные тесты Вот почему наверху потому что они самые верхнеуровневые и самые абстрактные потому что там мы делаем акцент только на какие-то контракты каких-то Вот и мы проверяем все связки Ок Обратите внимание что функциональные тесты занимают самую маленькую площадь на пирамиде Почему Потому что они нестабильные и медленные поэтому много таких тестов мы не напишем следующий уровень это интеграционные тесты то есть мы тут делаем акцент на инфраструктуру эти тесты чуть-чуть быстрее и чуть стабильнее чем функциональные вот Поэтому соответственно их побольше и площадь на перемене они занимают больше и последний уровень пирамиды это Unit тесты Да поскольку тут мы делаем акцент на бизнес логику бизнес-слойки приложения у нас больше всего поэтому площадь занимаемая тестами в этой пирамиде она максимально большая Там где-то далеко у нас летает НЛО это системные тесты ручной тестирование все то что уже непосредственно на самом бэкенде мы не пишем и в принципе наверное разработчики уже по крайней мере тестами уже не занимаются Вот теперь посмотрим подытожим материал вот Первое это стоит писать я думаю тут достаточно аргументирована следующая баги покрываем всегда то есть бывают ситуации когда вы приходите уже на какое-то легасе проект где очень много кода и тестов в принципе нету и непонятно с чего начать вот Я бы начал именно с багов потому что как правило в таких проектах багов много и они небольшие и почему бы хотя бы начать покрывать баги тестами вот Идем дальше тест-кейсы формируем на основе контракта опять же если вы формируете тест и по принципу Что ага Вот у меня код тут If мне надо вот их попасть и Тут другой их надо туда тоже попасть то у вас сильно тест Будет привязан к реализации и скорее всего там при любом изменении реализации ваша тест и поедут я думаю что надо в первую очередь отталкиваться от бизнес-логики от бизнес требований то есть использовать там принцип черного ящика то есть не заглядывая в реализацию просто думать А что мы ожидаем от этого компонента и формировать кейсы на основе этого дальше дальше жонглируем пирамиды Что это значит что если мы хотим получить максимально эффективное тестовое покрытие то нам придется использовать все виды тестов и функциональные и интеграционный и унитаста то есть обойтись каким-то одним видом тестам к сожалению не получится чтобы получить очень хороший эффективное покрытие и следующее Это хороший код порождает Хороший тест и наоборот то есть опять же если что-то не получается протестировать то в первую очередь Задумайтесь А все в порядке с этим компонентом сбивает Например у вас интерфейс компании таков что у вас он ничего не возвращает и непонятно как его протестировать возможно можно как-то компоненте композировать и сделать так чтобы он что-то возвращал и уже будет кончить Профи тестировать То есть это в принципе нормально менять реализацию чтобы она проще тестировалась вот принципе на этом У меня все по материала Спасибо за внимание готов ваши вопросы послушать супер Руслан Спасибо огромное напоминаю переходим по qr-коду и оцениваем доклад я вижу три руки минимум пожалуйста Helper передайте микрофончик прошу Привет Руслан Спасибо за доклад очень погружено очень интересно я с параллельного стека Spy там скажи как тестируешь асинхронные вызовы как их встраиваешь в Ci Ну и заключительно маленький такой вопрос Какой вы приняли кавередж для проектов начну с простого в последний вопрос пошло самое простое у нас принципе все очень лояльно у нас каждая команда сама вправе выбирать то есть какое будет covarage в принципе у нас рекомендация по коврожу это Порядка 70 процентов но опять же каждая команда сама вправе выбирать какой им каверач нужен потом про про асинхронные вызовы Это очень хороший вопрос потому что на самом деле тестировать асинхронные вызовы очень сложно и как правило мы просто отдельно Ну то есть Тестируем сам worker Да например если речь про какую-то очередь мы пишем именно про очередь мы отдельно Тестируем сам worker то есть по принципу Юнит или интеграционного сан-класс Передаем ему Да вот и отдельно Тестируем часть которая пушит там сообщение но связки мы все не Тестируем потому что там тяжело со временем угадать то есть Поэтому мы одет По отдельности Тестируем Как строили смогли встроить это все все да все встроено у нас все встроено вся сиди и как я сказал у нас как раз таки По отдельности у нас запускается и интеграционные тесты вот так у нас аннотациями отмечается интеграционные тесты и они запускаются отдельно да это всё настоящий встроено и у нас Прям вся сиди формируется отчёт Вот и мы также используем выгрузку тестов тестовое хранилище то есть тестировщики знают какие-то слезы покрыты на бэкенте а какие нет чтобы понимать то есть ну что стоит давать А что нет супер Спасибо огромное Следующий вопрос Передайте пожалуйста микрофончик прямо за вашу спиной молодой человек благодарю Добрый день Семён тестировщик я не программист часть того что вы говорили я слушался интересом мало Что понимаем тем не менее У меня два вопроса вопрос Первый вы использовали стандартную терминологию теории тестирования но при этом значение терминов отличается от классического понимания то есть насколько это специфично именно для вашей компании или для вашей профессии потому что вот я не совсем понимал Вот почему вы это тогда я понял вопрос просто это лично Ну термины которые применял это лично как бы мной сформированный термины Потому что я в принципе в работе стараюсь пользоваться там Ну больше там здравым смыслом и эффективностью и поэтому То есть я сам Вот честно говоря долго не понимал Ну вот типа Каким должен быть юнитест да вот например как я сказал что есть там заблуждение что там тест должен проверять конкретный Класс вот то есть термины которые Я использовал я их подбирал исходя из практически пользы там разделения юнитов от интеграционного например ну то есть да то есть на какую-то А как бы академического правильности они точно не претендуют Ну просто вот как раз к тому чтобы вы сказали юниты тесты у меня вопросов не было Вот к тому что вы называли функциональными интеграционными Я не сразу понял что вы имеете в виду предлагаю Продолжить это обсуждение у нас уже после второй вопрос как бы хотел задать Вы обращались за тест дизайном к профессиональным тестировщикам потому что у меня впечатление что вот многое из того о чём вы говорили они вам очень сильно помогли но я сам готовился Нет это продумать что и как проверять супер Спасибо огромное Я предлагаю продолжить в зоне кулуаров пока нам помогают нести к следующему человеку который хотел бы спросить напоминаю если вы смотрите нас онлайн вопросы можно задавать в чате слушай меня да зовут Михаил некоторые вопросы задали особенно да человек с тестировщик правильно подметил какой-то путаницу На мой взгляд Я тоже хотел уточнить почему вас по моему функциональные тесты интеграционные это одно и тоже это по моему мнению когда тест зависит от чего-то третьего чтобы не контролировать в том числе база данных которая запущена даже на том же Косте не является чем-то надёжным Вот то есть тест может сломаться просто потому что к базе Дань не получилась под коннектится и из-за этого не должен условно там себя сиди или какие-то дальнейшие вещи падать вот э-э атакующий вопрос интересный вопрос момента стабы моки по-моему тоже мог абсолютно злойки нужно использовать и вы сказали что невозможно проверить как бы пишущий метод не вижу проблемы создать свойства внутри стаба которые хранит в себе это записанное свойство потом в конце теста просто проверить что оно там есть и ещё один момент по хабра Fly я не очень понял зачем последнее а-а Зачем тестировать клиент Зачем делать мог на стороне другого Теперь я очень рада что Тема горячая У нас очень много вопросов Давайте мнениями будем делиться в дискуссионной зоне я видела много рук у кого не точка зрения а именно вопрос к спикеру вот пожалуйста так Прошу прощения вот здесь рука была раньше Извините Да привет Спасибо интересно доклад У меня как раз насчёт моков и было вопрос э-э Мы тоже у себя Тестируем потому что это по клиентов вопрос в том Зачем ответа от них хардкодить ведь Если ваши партнёры запросы к которым вы отправляете вдруг своё изменит тесты ваши пройдут А когда в продакшн выкатите они все лягут слышал какой их Именно хардко ходить а смысл в том чтобы проверить инфраструктуру то что ну сам запрос формируется корректно Вот Но в принципе с поинтом Я согласен что изменения контрактов мы не застрахованы но тут мне кажется от такого в принципе никакой тест но тут мне кажется не поможет Ну чтобы проверить Ну часть которая ну инфраструктуру супер Спасибо огромное так у Дмитрия вот здесь была рука Скажите пожалуйста какие риторические приемы вы используете для дискуссии с коллегами которые все еще не согласны с вашей позиции относительно тестов и не хотят их писать Ну например мерж не приму без тестов не протестировано значит не работает используются такие словечки или нет но супер спасибо и хороший вопрос но в принципе мы стараемся договариваться То есть в принципе мы его также собрались подсветили Ну там подсветил важность тестов и мы вместе выбрали инструменты которые мы хотим работать в принципе на квадривью тоже таким тоже пользуемся Вот Но у нас в принципе не принято наседать Поэтому как-то стараемся больше уговаривать супер и еще один вопрос Иван Скажи пожалуйста где хранить тесты где должно быть папка с тестами Это холеварный вопрос мне кажется что тут Как Вам удобно с одной стороны кажется что тест должен лежать рядом в тестируемым компонентом поддерживать просто проще с другой стороны кому-то не нравится что какие-то тесты Да это не Production код и он лежит рядом с продакшн-кодом и кто-то выносит отдельно тут мне кажется какой-то Панацея нет то есть кому как удобно Мне кажется там можно размещать потому что мы Ну то есть у нас в принципе по командам всё индивидуально у нас какие-то команды там хранят в отдельные папке Да там папочки тест например а кто-то хранит тесты прям рядом с тестированием кодом так все вроде бы вопросы закончились Хотя я очень рада что их было так много Руслана Вот тебе теперь предстоит выбрать самое интересное Я понимаю что это безумно сложно пока Руслан Думает я Предлагаю перейти всем кто еще не перешел по qr-коду и дать обратную связь по докладу это очень важно для формирования будущей программы Итак лучший вопрос но мне на самом деле понравился вопрос Дмитрия потому что действительно бывает очень тяжело коллег уговорить То есть это очень сложная часть поэтому спасибо огромное Дмитрию и подарок Руслану пожалуйста Спасибо огромное за подготовку Я знаю что готовить доклад это очень непросто благодарю Спасибо большое за внимание и будет рад обсудить весь этот фидбек который у вас явно скопился"
}