{
  "video_id": "8AR1u5OZIm8",
  "channel": "HighLoadChannel",
  "title": "Распределенные транзакции в YDB / Семён Чечеринда (Яндекс)",
  "views": 4235,
  "duration": 3118,
  "published": "2020-04-14T10:48:36-07:00",
  "text": "я разработчик в кровь команде индекс а то бы из и сегодня мы поговорим о том как мы сделали распределенной транзакции в яндекс зато bass мой доклад надеюсь покроет а вопрос о том зачем нам вообще нужны транзакции потом как мы их реализовали о том как наше решение масштабируется мы обсудим overhead нашего решения и поговорим о доступных уровнях изоляция представляем наши базы данных зачем нам все это нужно транзакций вопрос немного исторически яндексе много сервисов которые взаимодействуют с пользователем к этим сервисом подавлены высокие требования по доступности и надежности все сервисы которые используют нас как backend автоматически прикладывают требования по доступности и надежности на нас на backend мы должны соответствовать с в яндексе часто проходят не часто даже регулярно проходят учения подключение одного из дата-центров так вот наша модель отказа это -1 дата-центр и минус еще стойка в двух оставшихся до центрах в рамках такой модели отказом мы остаемся доступным как на чтение так и на запись данных у яндекса большой опыт использования но искры лишениях но искали решения хороши надежная до доступны до но нам не хватало транзакционных изменение нескольких строк из таблицы либо из разных либо из одной таблицы либо из разных таблиц поэтому нас к и лишения нам не подходила и и вершину консистенции но и скрыли решений также добавляла лишних сложностей которых просто не хотелось с которыми не хотелось работать так вот мы хотели транзакций когда мы говорим хотим транзакций обычно подразумевают операции которые атомарные консистентные изолированно друг от друга при выполнении надежно сохраняет результат свое выполнение атомарный все либо ничего никаких промежуточных результатов транзакция либо закончилось и мы видим все изменения либо не закончилась и никаких сомнений не осталось консистентная здесь давайте понимать саму общее понятие консистентной это какая ценность и внутренних структур база данных так и консистентной приложения то есть все что приложение в рамках транзакций проверяет мы хотим чтобы было валит на и после применение этой транзакции в случае успешного коммита надежность все изменения принятые в рамках транзакции должны быть надежно сохранены и если система доступна на чтение запись никакие изменения ранее сохраненные в систему не должны потеряться соответствует вопрос о модели отказов и изоляция изоляция сам интересный опрос потому что изоляция много разные базы данных предлагают разные изоляции по умолчанию и во многих базы данных она настраиваемое чтоб щетку изоляция ну допустим сериала из глубин изоляции в нем ваши запросы выполняются как бы последовательно в системе и ни один из запросов не видят аномалий конкурентного доступа при конкурентом выполнение таких запросов в системе есть еще более строгий уровень изоляции the strict so real ой забыл все то же самое что и сериала и забыл уровень изоляции но выстрелил и забыл гарантируется порядок выполнения запросов в системе этот порядок регулирует с тем порядком с которыми вы задаете запросы если вы работаете с базой данных в синхронном режиме вопрос-ответ запрос ответ дожидайтесь все время ответа то каждый последующий запрос будет видеть результаты предыдущих встречала и забыл в изоляции но также популярны даже в реляционных однородных классических базу данных и другие уровни изоляции допустим snapshot уровень изоляции он всем хорош защищает от многих anomaly конкретного доступа но не защищает от перекоса записи пройти скилл давайте на примере snapshot организация рассмотрим задачку у нас есть аккаунт пользователи в ком-нибудь банки и у пользователя в рамках своего канта есть двигательный расчетный счет глобальный бренд то что сумма двух сумма средств на двух счетах пользователя положительно всегда банк не позволяет входить минус но каждый что-то может быть отрицательным главное сумма положительное 2 параллельно выполняющихся трансакции читают одни и те же данные они начались одновременно взяли snapshot с одинаковыми данными читают их в рамках транзакции они делают анализ каждой транзакции хочется писать какое-то значительное количество денег с одного из счетов пользователей каждый проверяет можно ли списывать деньги останется ли у пользователя в сумме больше нуля при успешно таком анализе каждая транзакция делает запись 1 трансакция делает запись вычитает сумму избегать насчет а а вторая из расчетного и вот здесь вот появляется аномально конкретного доступа в райский если транзакции выполняемые конкурентно не пересекаются по ключам для записей то есть они записывают в непересекающихся множеств ключей то они не конфликтуют между собой даже несмотря на то что они почитали одни и те же данные обе транзакции в рамках snapshot изоляции приходят к успешному комету но глобальный инвариант нарушается после коми то это не очень удобно вам надо помнить о том что не каждая логика в рамках этой акции валит она такому не изоляции и либо изменить логику либо что то еще думать так вот snapshot уровень изоляции не предоставляет вам консистентной с точки зрения applications in на такой логикой вам надо хитрить и изменять свою логику но если бы вы работали на сериала и забыл уровни изоляции обе ваши бы транзакции работали бы корректно и консистентной с точки зрения приложением соблюдалось в сигала из глубин изоляции зритель транзакции выполнились быкам последовательны в зависимости от модели блокировок они были бы действительно выполнялись последовательно либо одна из них получила ошибку блоккер валидация блокировок и повторил бы свое выполнение с новыми данными так вот я рассказываю о индекс зато bass индекс представляет database как паблик и view уже мы доступны в инфраструктуре облака мы надежно и с избыточностью храним данные автоматически репетируем их автоматически восстанавливаемся после сбоев наша модель отказа -1 dc и минус еще одна стойка в двух оставшихся мы предоставляем распределенные aside транзакции сакала и забыл уровнем изоляции распределенных значит а вы можете изменять консистентной либо несколько строк одной таблице либо несколько строк разных таблиц и у нас уже есть кластер а в несколько тысяч вот который работает под управлением ношения на их зато бэйс кот теперь мы говорим о самым интересным как мы реализовали нашей распределенной транзакции вопрос к сожалению большой и давайте его есть по частям вначале надо понять кто участвует в транзакциях и на какие сущности какие у них свойства какие недостатки может даже или ограничение лучше сказать потом рассмотрим какие именно запросы надо этими сущностями мы умеем выполнять то что запрос это не просто экзешник все выполняют а запросов своими свойствами и ограничениями и как мы выполняем множество таких запросов на наших объектах конкурента и достигаем изоляция между ними так вот вопрос кто участвует в транзакции исходит из вопроса как мы храним данные данные пользователь своей базе данных хранит в таблицах таблицы это упорядоченный набор строк каждая строка представляете себя набор колонок каждая таблица упорядочена поправили ключа попадаем ли ключу ключ это некоторое подмножество столбцов таблицы за неправильный диапазон ключей отвечает такая сущность когда-то шахте ну и так называем может не называть шарды шахты с данными таблицы может стоять и снова тогда либо из нескольких этот шаг это примитив параллельного выполнения запросов над таблицей примитив масштабируемости нашей системе надо понимать как работает да то шаг и что это такое именно он выполняет распределенные запросов в системе это шаг приставить все таблетки таблетка это устоявшееся уже термин в распределенных системах но давайте раскроем что же такое для нас таблетка это примерно что-то то же самое что и actor актах знаете то же самое что и ок так но со своим пикси стенам хранилищем точнее сайт экстента состоянием у него есть собственные данные за которые он отвечает который может изменять свои данные он хранит в распределенном сетевом хранилище им на распределенности в хранилище отвечает за гиа распределенности хранения данных то есть данные хранятся в нескольких копиях доступны из разных дата-центрах дата шахта работает одна по точно тут так в кавычках 1 по точно на самом деле он действительно на поточность реализует все свои изменения в распределенной хранилища за счет этого достигается то что он может менять свои данные с уровнем изоляции сексоголизме все как в классике один поток стерилизует все изменения получаем строгой изоляции применяя их изменений дата шаг также как таблетка представляет из себя отказывай устойчивую единицу системы если у нас какие-то проблемы с процессом на ноге либо целиком с надой дата шахте может быть запущен на любых доступных ресурсах системы в любом месте кластер и конечно какие ресурсы кому выделять и сколько это вопрос о о конфигурации базы данных для конкретного пользователя но на всех доступных ресурсах дата шаг не можете работать дата шаг сам по себе является очень легкой структурой и накласть один работает миллионы инстансов разных этаж актов отвечающие за разные куски разных либо не хотят же таблиц как таблетка в нашей системе дата шаг не единственная сущность на базе таблеток мы построили и другие сущности в нашей базе данных будь то пользовательские таблицы это один из примеров использования таблетки также мы очень где реализовали на таблетках хранилище сенсоров мониторинга также реализовали ногах логике таблетки системные таблетки которые координируют вашу базу данных и весь кластер целиком тоже работают на абстракции таблетки и сетевые диски облака это тоже один из видов таблетки кластер можно представить следующим образом у нас есть множество хвостов и ресурсы памяти и secu отдаются для работы таблеток это будь то сервисные таблетки верху и по дата шарды в большом количестве для разных таблиц а ресурсы дисковые системы hasta отдаются в сетевое хранилище сетевое хранилище знает где и диски расположены в каких дата-центрах в каких стойках в рамках одной ли они надо и либо разных и тем самым данные таблетки она хранит герой распределена и в разных файл доменах чтобы достичь модель отказа нужно соответственно и масштабируемся мои просто добавляю not дисковые ресурс уходит в часть том же компьютере source уходит к таблеткам внутри себя таблетка может быть представим в виде нескольких слоев конкретно 3 это именно конечный автомат который реализует все изменения и с помощью протокола специально в протокола общается с распределенным сетевым стали джим кстати летом владислав кузнецов рассказывал о интерфейсе и о внутренностях работы дистрибьютор столь жена хай-лоу я можете посмотреть также все свои данные которые хранятся в распределенном хранилище внутри таблетки представлены также виде таблиц просто таблицы в глобальном смысле как пользователь ведь таблиц в некоторым локальным то есть собственные данные таблетки это также набор некоторых таблиц и я как разработчик applications & вилла в таблетке очень удобно с ними работают примерно так как и вы только немножко другим интерфейса так вот свойства и особенности да тогда как таблетка он надежный и доступный надежных они данные и можешь без запущен где угодно случае проблем intrinsic ционно применяется изменение к своему сайту он 1 по точно сирле зуют все свои изменения и способен выполнять одношаговый запроса которые адресованы к ключам и снова шага он имеет некоторые венчание в признательности за счет того что ему приходится реализовать все свои изменения в один поток но мы от него не требуем большой производительности сам дата шахт в системе используется как примитив масштабируемости вас много данных больше дат шагов вас большая нагрузка больше дата шагов теперь поговорим о том какие запросы над этими шагами мы умеем выполнять а именно вот про эту часть шарды и про то какие запросы внутри кластера над этими шагами выполняется стоит сразу быть внимание что запросы внутри кластера не совсем то же самое что запросы с точки зрения клиента который работает базы данных это немножко специфические запросы у них есть свои свойства и свои ограничения мы это все обсудим так вот внутри кластера мы умеем атомарная распределять атомарном выполнять операции которые выполняется детерминировано и для которых известны ключи из которых она читает и ключи в которой она пишет то есть вид в ракеты для таких операций заведомо известны идею как изолировать много таких операций над разными шахтами в системе мы подчеркнули и статьи про колвин за за авторством даниэль и апатии и александра томпсона интересные люди почитайте про них интересная вещь пишут так вот основная идея если транзакция выполняется dither минирован а то их упорядоченное выполнение также будет dither минирован а наш класс запросов в котором мы выполняем над шахтами выполняется сам по себе dither минирован чтобы достичь общие дети гмо неровности выполнения всех запросов в системе нам всего лишь надо навести порядок упорядочить эти запросы и если каждый шаг будет выполнять о големант на ему транзакции но соблюдая глобальный порядок выполнения таких операций в системе будет детям минирован и так вот много запросов выполняется на множестве тот шагов каждый запрос выполняется на нескольких шагах все запросы в системе имеют некоторые порядок как это сделать а давайте сделаем следующим образом сделаем специальный тип таблетки как координатор мне будет свой стоит в распределенном хранилище она будет в нем хранить данные о порядке всех транзакций все транзакции будем направлять сперва в этот координатор он их будет получать и в том порядке в котором получил будет сохранять в свой локальный state vs пеленок хранилище после того как он сохранил информацию о порядке он транзакция будет кушать в dota шарды этот шаг до их будет выполнять ровно в том порядке в котором их скоординировать фрязино так это система теоретически работает и работает корректно но корзина так будет являться узким местом наташа годов миллионы на кластере окраина то всего один поэтому сейчас мы поговорим о том как мы штабелю ли именно эту идею для начала рассмотрим очень полезную может быть не единственную оптимизацию это давайте на координатора немножко по бочче ведем команд планирование он нам в дальнейшем будет полезен а именно кван планирует объекты промежуток времени ограниченный в рамках которого когда-то принимает все транзакции но не обращается к своей локальной базе записью и только по истечении кванта планирования он формирует порядок в рамках этого кванта планирования и записывает этот порядок в своей локальной базе после того как он успешно записал он расскажет всем по шагам о том в каком порядке что нужно выполнять в принципе это лучше немножко лучше тем что когда так делает меньше обращение к своей локальной базе что тоже не бесплатно и здесь мы сэкономим но все равно кабинет узкое место в системе давайте сделаем несколько координаторов пусть системе будет конфигурируемый число координаторов заведомо такое чтобы держать предполагаемую нагрузку все транзакции входящие в систему мы будем распределять по координатором распылите и будем по функций хэши нет номер транзакции в номер координатор и тем самым каждый кавина так работает точно так же как мы раньше обсудили будет строить свою часть плана свою часть глобального плана фиксирую его в своей локальной базе и точно также будет рассказывать всем кто то шагом о своем виде не план но дата шаг теперь чтобы двигать чтобы в прогресс чтобы выполнять транзакции должен получить планы со всех координаторов для конкретных квантов иначе он просто не знает если на другом кори на таре что то что нужно выполнять либо нет поэтому даже пустой план в когда ты в которой закон отклонение ничего не пролетела должен будет рассказать всем по шагам о том что ничего не надо по моему мнению но дождись других такая система будет работать уже хорошо каинат оружие не узкое место совсем но с этой перспективе не очень хорошо видно давайте посмотрим на другую перспективу на образовавшуюся проблему а именно каждый когда так общается со всеми тот шагами и доставлять до них свой частичный порядок транзакция который он видел дата шагов очень много и этот квадрат мы себе не можем позволить слишком много давайте оптимизируем это место ведем такой сущность как медиатор и на медиа так будет общаться со всеми арендаторами то как общаться получать от них планы частичной планы строить глобальный порядок и уже каждый медиатор будет общаться с своим x земным набором дата шагов до то шаг будет получать план от одного медиатора тут тоже по функции решения от номера это тогда в доме медиатор определяем с какого медиатор мы получаем план и тем самым у нас теперь линия с линейное количество связей медиа тогда-то шаг и квадратичный когда-то медиа так количество кредитов и медиаторов сесть в базе данных конфигурируем и ограничено это можно считать вообще константы и общее количество связей линии от количества воды шагов нас это устраивает и последняя ремарка о том как мы еще оптимизируем наш pipeline мы прежде чем идти в координаторы и сохранять о них в них транзакции мы сперва для каждой транзакции идем в элегантные этой транзакции дату шахты и сохраняем на них саму программу и ее параметры зачем программа и параметра к этой программе могут быть достаточно тяжелыми и гонять их по системе лишний раз не очень приятно поэтому сохраним сначала их наташа годах в координаты медиаторы будем посылать уже только мид информацию просто и нижних транзакции и затронуты дат шагами а теперь давайте посчитаем их от нашего решения сперва о том что мы считаем и как давайте уговоримся мы не считаем ничего что связано с запросом если запрос читать много данных запросов читать много данных тут что поделать если запрос пишет много данных то же самое если запрос много считает времени мы не будем это учитывать давайте посчитаем только overhead нашего решение по организации транзакционные модели поверх стоимости самого запроса то есть мы будем считать добавочную стоимость будем и выражать виде добавочного latency к стоимости самого запросов некоторые тезисы которые мы будем использовать время самого запроса не учитываем я уже сказал все метаданные для выполнения транзакций в памяти их читаем мы тоже бесплатно и одновременно выполняющиеся запросы мы будем считать как один почему если какое-то кайт объект таблетка делает распределенные делает параллельно несколько запросов других таблеткам просто будем считать 20 худшего из них класса запрос в которой мы рассмотрим это где-то он ли евро it only на самом деле здесь стоит сказать что ит в райт выглядит аналогично адресованный одному шагу мы будем называть первыми did i owe me get это запроса который выполняется на одном ш где они могут затрагивать либо один ключ тогда гарантированно не выполняется на одном ш где-либо несколько ключей но которые попадают в 1 шард также мы рассмотрим класса запросов with only i right only выполняющийся на многих шагах и последний класс запросов которые посмотрим это ведь в рай транзакция на нескольких шагах и того чтение чтение с одного шага до самой оптимальной операция у нас трогать в системе только один этаж акт с которой надо прочитать и выполняется максимально эффективно затрагивая имея overhead 11 просто надо дойти до этого шага и посчитать слепая запись skype я запись также эффективно она задают тоже один тот шаг но тут мы посчитаем что все-таки не надо записать поэтому одна запись будет то есть один из детей + 1 запись здесь уже запросы которые дороги и трогают несколько шагов на картинке изображены несколько шагов первым делом как мы и договорились ранее мы сначала на этих шагах который участвует в распределенной транзакции сохраним тело транзакции и параметры на этом мы потратим 1 5 и 1 райт после того когда душа где уже знают после чего нет транзакции мы с мета информации идем в группировку координаторов медиаторов на планирует о транзакции мы потратим получите так как это общение в одну сторону в поход до координаторы координаторы как повезет потратить в худшем случае один квант планирование на то чтобы забывчивости входящей транзакции и сделает запись в свою локальную базу про порядок транзакции вошедших в этот команд планирования то есть когда так пишет свою базу медиатор соберет все планы с координаторов которые ему пошлет это одновременно поэтому здесь мы считаем просто на 5 хотите все этот шаг закончен и следующий шаг медиатор собрав глобальный план из частичных планов координаторов отправит его всем элегантных шагом дата шаг до на этом потратить тоже полных сети сообщение в одну сторону до то шахт по факту получения плана сможет его выполнить сразу же в своих базу данных он запишет одновременно и факт получения плана с порядком транзакция в рамках этого плана и результат выполнения транзакций если это было допустим слепая запись и после успешно записи он ответить пользователю с результатом выполнения транзакции в результате мы потратим при подсчете я учитывал то что одна запись локальную базу таблетки стоит примерно до даже не примерно в нашей модели совершенно точно 11 и 1 детского операция еще 1 таблетка пишет в свою локальную базу с 17 11 и 1 детского операция чему потому что она параллельно на все на дэ в распределенном хранилище которые содержат и данных отправляет запрос каждая надо по этому запросу делает дисковая операцию будь то чтении либо запись и отправляет ответ все запросы параллельны поэтому как мы договорились в этом все худшего запрос запись ответ один из детей 1 диска операция в результате такой операция для нас стоит 6 детей квант планирование на координаторы это и дисковых операций воспаленной хранилище а самый самый сложный и самый на самом деле мощный класс запросов это чтение и запись это такой кола запросов которым мы можем атома рынок прочитать данные и на основе прочитанных данных записать данные в систему такой класс запросто стоит применять когда у вас есть высокая конкуренция под данным для того чтобы не толкаться разными транзакциями ненавидели друг друга луками локи о которых мы чуть позже поговорим вы можете атомарных прочитать и записать данные в систему причем сделать это распределена что самое главное в этом классе запросов будет взаимодействие между шагами а в предыдущих классах запросов заметьте взаимодействие между шагами не было совсем шарды между собой не взаимодействовали так вот его транзакция в начале все то же самое мы на все шарады здесь они поддельные на две части факт из которых читаем мешок из которых пишем сохраним тело транзакции сделаем это параллельно тот же самый 11 1 райт потом смит информации идем в группировку когда-то комитетов тратим то же самое выход на планирование дальше медиатор отошлёт планы как наших без которых читаем так и наши органы который пишем шарды с которых читаем по факту получения транзакции смогут сразу выполнить транзакцию и записать свою локальную базу первое факт наличия транзакция и и и порядок в рамках кванта планирования второе все вычитанные результаты для этой транзакции который необходимо послать на пишущие шарды она также сохранит в свою локальную базу как результат выполнения пока никуда ничего не управлять только сохраняет зачем это надо сделать для того чтобы читающий это шаг мог выполнить транзакцию сохранить результаты которые надо отправить следующим шагом и продолжить выполнять следующий транзакции возможно которые уже будут изменять данные который он прочитал так что повторить запрос не получится но результаты вам и надежно зафиксировали в локальной базе читающего да . да а пишущий этот шаг по факту получения плана ничего не сможет сделать кроме как запомнить факт получение этого плана и порядок транзакции запомнит в рамках этого плана выполнить запрос без получения данных и сочетающую да тогда он не сможет поэтому здесь добавляется еще одна стадия а именно читающий dth акт отсылает надежно зафиксирована своей локальной базе данные пишущим этот шаг до на это мы потратим полог сети по факту получение этих данных пишущий это шарф сделает наконец-таки записи завершить свой свою транзакцию и отошли от результат пользователю и того на такую мощную транзакцию мы потратим немногим больше чем на слепые записи если при чтении multi шаговые это семь с половиной те квант планирования no cry no tori и 4 дисковых операций подведем итоги самые эффективные все-таки конечно же 1 шар давая транзакции на 1 шаг 2 транзакции вы можете выполнять если при чтении и слепые записи и на самом деле здесь я почему-то не вина нарисовал но также и чтение и запись тоже на dat ashe где выполняется с ценой как вот посчитано для слепой записи для многошаговых транзакции конечно все дороже и это стоит понимать когда вы работаете с базы данных дороже но это не главный point главный поле что мы умеем это делать мы умеем изменять консистентной несколько строк в рамках вашей базы данных будь то эти строки из одной таблицы из разных шагов либо даже из-за разных таблиц мы умеем это делать и вот стоимость чтение и слепая запись будет вам стоить шесть 5-ти + квант планет не 3 дисковых операций а такой класс транзакции как атомарной и прочитать и записать будет чуть дороже но мы также это умеем делать теперь я quelle транзакция что вообще такое слово за я курю давайте вернёмся к нашему общему виду до этого мы говорили о том как мы надо то шагах выполняем специфические запросы достаточно специфичный напомню что это запросы и терменировали с известным этого rights этом то есть они знают откуда читать и куда писать а выше как клиенты базы данных работаете немножко с другим видом запросов мы вам предоставляем ни много ни мало диалекта сквере в документации описан чем именно этот директорское или отличается других баз данных новые лица он на первый ряд точно так же в рамках своего запроса пользователя имеет никто контекста транзакции от begins to commit a в рамках транзакции делать несколько запросов к системе транзакций у нас могут быть и открытыми то есть вам не обязательно весь запрос передавать в один ход к серверу им вы можете интерактивно взаимодействовать системой и на основе полученных данных решать какой же следующий запрос в рамках транзакции нужно сделать именно логика клиента может быть вы лидерами в рамках транзакции на самом клиенте не обязательно ее оформлять в виде какого-то языка и отправлять на север вы на клиенте работаете с данными в рамках транзакция так вот у вас достаточно мощный язык и он умеет работать там например со вторичным индексами работа со вторичным индексами немного не ложится в один в один в тот язык в тот тип запросов которые работать на сервере почему да потому что вид вы отсек полностью неизвестен если вы хотите по вторичному ключу изменить какие-то данные непонятно какой первичный ключ так просто это не узнать поэтому мы такие запросы разбиваем в несколько то есть сперва мы сделаем распределенная либо точечное чтение и за шаг до с таблицей индекса получим первичный ключ а потом будем уже работать с известным основным ключом и продолжать делать ваш запрос то есть ваши запросы разбиваются настолько подробно на сколько нужно для того чтобы каждый запрос работающий раз по зеленой в системе знал свой вид выйдет входить обменялись каждого запроса достигается просто если вы использовали функцию рандома либо взять ее времени мы это все заменим на стадии процессинга вашего запроса накид константы чтобы на разные тот шагах транзакции который будет выполняться в разное момент времени видели константы они разные числа и выполнение вы ладите гневно так вот еще особенность нашей нашего языка в том что все изменения которые вы делаете в рамках транзакции откладываются на самый последний шаг к этой транзакции это некоторые тогда в которой мы выбрали чтобы оптимально сделать нашу систему а именно вы не можете читать свои изменения и все запросы которые мы выполняем на сервере в рамкой транзакции они по сути только чтения а самый последний запрос это запрос чтение записи самый последний запрос который применяет все ваши накопившиеся изменения должен прочитать ранее взятой блокировки которые берет каждый читающий запрос из вашей транзакции удостовериться что они валидны их никто не сломал пока транзакция работала и если это так произвести запись в системе здесь кратко там чем я вам рассказывал на слайде с общим видом рассмотрим я курить транзакция из себя представляет серию рид онли запросов который выполняется на нескольких шагах эта серия запросов каждый запрос берет оптимистичные блокировки на тех шагах для того диапазона данных которые он потрогал и самый последний запрос который будет применять изменение в рамках транзакции будет читать в рамках его транзакции значение оптимистичных блокировок и случае успеха случае если они все валидны применять ваши изменения на всех год шагах здесь ключевая прям особенность в том что мы сохраняем атомарный за просто все даты шарды придут к одному и тому же заключению о статусе транзакции будь то это либо commit либо откат атамана здесь не потеряется потому что последний запрос это rv транзакция а то марина прочитать данные и записать если же пока мы выполняли некоторые запросы к нам пришла какая транзакция в какой-нибудь этаж акт с которым мы прочитали и изменила данные которые мы ранее читали на которые мы опираемся при нашей в нашей логике и из которых мы вычисляли те данные которым хотим записать последний запрос коммита его транзакция гарантированно увидит и сломанную блокировку и пойдет к отказу выполнение транзакции вы получите тонны блокировки теперь а у них изоляции по умолчанию мы предоставляем стиралась был уровень изоляции сигал ой забыл уровень изоляции на потоке как к единицам их в перемешку с 1 шаговыми транзакциями кажется здесь все понятно но также мы умеем выполнять запросы в рамках строгой изоляции в рамках стрельца реала и забав в этом случае все ваши запросы должны быть проведены ruim ими это дороже потому что у вас не будет уже супер эффективных одношаговый запросов даже одношаговый запрос будет проходить через стадию координации и иметь больше overhead но мы это умеем самый текст на поиск от армий дальше обсудим это почему же при наличии миди транзакции мы теряем слова стоять перед сериала и забыл и работаем новую изоляцию просто сериала и забыл а не стригся резьбу представимся ситуацию есть транзакция а кем-то запущены мы не знаем кем но она выполняется в системе конкурентно с нашими запросами пользователь допустим мы делает последовательно два запроса b и c так вот если мы работаем в режиме стригся милой забыл то для нас порядок выполнения запросов бэйтс и строго определен он выполняется в системе сначала б потом c а это значит что если б увидит результаты выполнения транзакций а то и транзакция c гарантированно strict заголосил изоляцию увидит все эффекты от транзакции по другому быть не может но у нас сериала и заблуждений изоляции и если b и c были одна шахта выми запросами а а было координируем запросам выполнялась на нескольких шагах имела стадию координация то для нас может быть видно следующие б пришло на шахте на которую уже дошел план от транзакции а и которая уже выполнила транзакцию а и b видит изменение от а отсек пришел на другой шахте до которого еще не дошел план от транзакции a и c не видят результатов выполнения а там это нарушение стрелял ой забыл но это все еще сериала и забыл потому что релиз был не гарантирует вам порядка выполнения транзакций гавин тип что такой порядок и есть и в конкретно этом и мере порядок выполнения запросов сначала c потом а потом б вот такая вот особенность так вот яндекс зато bass надежная отказоустойчивая автоматическое восстановление после сбоев всем хорошо распределенные оси транзакции сигала и забыл уровнем изоляции мы обеспечим высокую пропускную способность при малом времени отклика и у нас есть инсталляции нашей базы данных в несколько тысяч not мы доступны в паблик превью пользуйтесь с нами пользуйтесь нами вот код всем спасибо есть вопрос вы можете задать добрый день спасибо за доклад мне несколько вопросов коротеньких какой критерий по увеличению количества координаторов и медиаторов и надо ли их масштабировать синхронного всех ваших dc и 2 коротенький вопрос конфигурация самого от координатора медиатор даже на ли она линейна масштабироваться или она фиксированная не зависимости от их количества давайте есть словно по кускам первый вопрос по увеличению количества координаторов и медиатора и какие-то метрики тоже не знаю у нас есть формула о том кода какой размер железо сколько как натаров и медиаторов нам надо поэтому когда вы заказываете доступные вам ресурсы мы вычисляем сколько вам когда-то медиаторов нужно на самом деле их количество мы берем с некоторым запасом до верха запас тут не влияет на вашу на ваш overhead выполнение транзакции по сути кажется мы посчитали для вас он валиден для широкого диапазона количество когда-то медиаторов типы там запросто два порядка возьмем мы 1 либо возьмем мы сто доехать будет примерно такой же ну точнее один конечно лучше будет типа пойдем едва либо стали хоть будет примерно такой же собственно вот какая то есть правила в это положение стоимость моих где это мои деньги да я буду платить больше нет вы платите не за то что медиатор и когда так работает я точно не помню политику с которые берут деньги с пользователя но вроде вы платите за дисковое пространство и время работы вашей базы данных надо почитать и конфигурация координаторов 5 на фиксированные что они же хранят там к для тары все данные обо всех медиаторов то есть я должна увеличиваться в зависимости от если вы взяли сначала маленькую базу на попробовать а потом хотите ее увеличить там четыре порядка то мы можем вам поменять конфигурация медиаторов спасибо вопрос вот меня смутил тот момент когда мы надо шарди выполняем запрос и он сохраняет вычета ный объем данных свой по запросу локально на себе чтобы там его дать да вот нет этого закона вода дарит сет вот а вот рецепт который всеми а вот рецепт а не было смысле сделал какое-то versio не рование строками хе-хе какой-то чтобы эти данные не поменялись не копировать их каждый раз на каждый запрос локальный президента к себе смотрите мы их сохраняем в локальную базу читающего да тогда не потому что у нас нет офисе они вне чтобы они apple типа можно было бы хранить оригинальные данные на которых мы посчитали этот запрос и не сохранять его допустят у нас внутри нет физически у нас внутри нет новосиб потому что мы считаем что это дорого вы полностью все строчки вычитанные то дешевле получаются чем версию строк или блоков строками на каждом этаже где мы ограничиваем количество вычитанных данных и на самом деле для пользователя такой класс транзакции в рамках у отеля доступен вот для чтения взятых блокировок информация о взятых блокировка это очень небольшая информация по сути валит на ли блокировки либо не валидно блокировки для такой транзакция поэтому вы правы что если использует эту транзакцию как угодно то здесь можно наткнуться на то что слишком много на данных надо записать но мы ее используем с умом можно будет узнать поподробнее там в кулуарах потом конечно по конечно трудности хожу по силам добрый день а я здесь где вы вот я мажу в фонариком да спасибо же за доклад у меня вопрос про медиаторы правильно понимаю что медиатора должны выстроить глобальный порядок и хищных проекта которые пришли из координаторов если да то как он это делает доводят картинка вы правильно понимаете смотрите медиатор получает про каждый квант планирование с каждого координатора информация каждый квант плане вне мы ты героем временным там с темпом который просто монотонно растет после того как медиатор получил кванты планирование на какое-то время от всех когда-то raw то он может на время до этого факта собрать полный план а там где у него есть еще неотвеченные координаторы он не может собрать полный план поэтому если у нас прям часто если у нас координатор валяется и не поднимается транзакции конечно же будут прибавлять в леденце но казино так это таблетка она очень легковесная потому что она работает с метаданными она специально я как бы на нее никто больше кроме как запросами пока гнаться метаданных не идет и она работает нас стабильно и не наблюдали еще таких случаев когда то когда то не может работать он работает на всех доступных ваших ресурсах и и только делает что планирует спасибо получается у вас узлы синхронизированы по времени между собой строго синхронизации нет мы допускаем некоторое количество с механизации время и этот вопрос решается медиатором когда он может планы спасибо по вопрос на схеме где вы показывали план вообще всех ваших компонентов и вы сказали что клиент выбирает координатора по хеш вот номер транзакции количеству координаторов что происходит если координатор умирает или добавляется новый они как-то между собой общаются сообщает клиент что появился новый и старый удалите вопрос прервать вашу базу данных которые вместо двух заявленных гигабайт хочет теперь до 5 то сложный и мы сможем при конфигурировать двумя способами либо просто взять ваши два гигабайта забэкапить и вы знаете новую базу данных в которые уже настроены под ресурса на 2 петабайт а либо сделать это за некоторый момент недоступности вашей базы данных а именно мы остановимся транзакции поменяем конфигурацию когда-то raw и продолжим транзакция нехай смотрите вы заказываете базу данных вы предполагаете какой объем мы вам его гарантирует способность на этом объеме вы в рамках заказанных ресурсов диапазон линейно масштабируемость скажите что вы хотите 2 петабайт а у вас будет данные по 2 петабайт а самом деле вот все что сейчас говорит он лично моей фантазии потому что в облаке которые нас доступна для паблика продаются заранее с конфигами слоты и вы заранее берете некоторые бьем данных вам там просто не сделают такую информацию которая будет плохо работать просто вот автоматика не позволит она сразу вам сделать чтобы ваше решение работала вплоть до там не знаю всего размеры кластер и но я понял то есть неа динамического нет а если координатор умер смотрите учениями что нет потому что мы пока еще не пришли к тому что это целесообразно инкрементировать но и было сообразно с точки зрения финансов если сразу не покупает место на 2 терабайта делать какой-то пруфов концепт который завтра 6 шторм случился прилетела там 10 миллионов пользователей у каждого пользователя свои медиаторы когда тары типа они никак не не как бы шарится между пользователем следующий опрос координатор если у иры это таблетка она быстро перри поднимется на другом другой ноге вот но то есть часть запросов будет фелицата который на нее будут попадать по часть запросов в этот момент времени небольшая часть запрос получат ошибку недоступности координаторов которые в нашем sdk имплементировать как полностью ветра я была ошибка и следующая попытка того же самого запроса без инвалидов и транзакций скорее всего пойдет к успеху какой-то силой на пире поднятие координат конечно нашей документации спасибо закончилась к сожалению если у вас есть вопросы вы можете обсудить их в зоне дискуссионный но ой у нас есть подарок на самый лучший вопрос 7 он сейчас выберет вопрос который мы понравился больше всего и мы вручим подарок книгу и я не помню людей я помню только вопрос синхронизация по вопрос синхронизация по времени"
}