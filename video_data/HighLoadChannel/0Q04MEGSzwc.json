{
  "video_id": "0Q04MEGSzwc",
  "channel": "HighLoadChannel",
  "title": "Getting started with LLVM using Swift / Алексей Денисов (Blacklane)",
  "views": 1037,
  "duration": 1906,
  "published": "2017-05-17T12:40:40-07:00",
  "text": "всем привет зовут меня алексей я занимаюсь разработкой для ios уже порядка шести лет и мои настоящие хобби и моя настоящая страсть и компьютер сайнс это именно компилятор и все что связанно с этим если кому то интересно вот можете меня почитать там в твиттерах блогах посмотреть какой код я пишу на гитхабе и и так далее наш план на сегодня таков сначала расскажу о том что такое собственный ловим затем немного ударимся в теорию и пройдемся потому что происходит с исходным кодом во время компиляции а после этого собственно расскажу зачем это все нужно то есть приведу несколько примеров применения этого всего вот в нашей реальной жизни то есть не где то там в академии в абстракциях а вот в реальности завершение покажу пару слайдов о том как легко и просто можно использовать м вместе с и для этого не нужно быть каким то там красноглазым винт уж ником где-то в терминале вот современные тулы позволяют делать это все удобно и без боли так чтобы рассказать что такое llvm я сначала расскажу о том что такое компилятор как он вы как вообще выглядит компилятор вот это вот собственно типичный компилятор на экране сейчас на слайде он состоит из фронтэнда и бэг-энда очень похоже на какой то вот в приложении например при этом задачи фронтэнда это как правило парсинг самого языка проверка всевозможная проверка типов проверка того что функция вызывается с корректным количеством параметров и и тому подобное завершающая одна из главных функций фронтэнда это непосредственно кода генерация и это генерация кода не машинного а не к его а внутреннего представления для для общения с бэкхенда то есть если опять таки провести аналогию с разработкой то вот мы front-end и back-end общается посредством кого-то джейсон xml про табов что угодно вот у компиляторов тоже есть свой некий промежуточный язык который используется для этих целей вот в задаче бэкенда входят более низкоуровневые вещи такие как оптимизация то есть улучшение программы чтобы она занимала меньше места на диске либо чтобы работала быстрее либо чтобы меньше батарею ела и и тому подобное кроме этого бэкенд занимается куда генерации уже непосредственно машинного кода для какого-то конкретного процессора может быть rm x86 и любой принципе процессор завершающая фаза это как правило linker очень очень грубо говоря это некая программа которая берет вот несколько объектных файлов и склеивает их в один который на выходе является непосредственным приложением задумка такая что front end of может быть несколько например вот как как на сайтах сейчас там си плюс плюс 1 свифт хаски ада defort ранд там дюжины наверное две дюжины этих front end of для разных языков и бэкенд он вот один вот в случае слове это вот собственно элвин и есть бэкенд и ловим скрывает под собой вот все то что фронтэнда то о чем frontend узнать не обязательно например как генерировать код для mips или для spark или для поверки си ну нам вот-вот вообще это не нужно если наша цель например р.м. у такого подхода есть много преимуществ вот одно из них это если вы допустим решили свой язык программирования написать вот крутой без без изъянов и и так далее то вам не нужно опять-таки париться об оптимизациях о том какой ассемблер генерировать как это все линковать достаточно просто написать front-end и подключить его к голове это гораздо менее трудозатратно чем реализовывать вот всю frontend часть собственно своими руками в то же время справедливо и обратное производители железа каких-то чипов если они хотят выйти на рынок с новым процессором то они вероятно хотят чтобы а какие то высокоуровневые языки имели возможность использовать этот процессор вряд ли кто-то ломанется вот писать чистая землю для вашего процессора но может там пара пара человек но вот это не сработает условиях рынка вот поэтому тоже произойти ли железо им тут тоже достаточно просто расширить backend а теперь вот немного скучную теорию вот о том непосредственно что происходит с исходным кодом на его пути в код машины вот как правило первый этап это да это вот функция на не функция исходный код вот кусочек кода на его примере я буду показывать собственно что происходит вот нас есть определение глобальной функции глобальной переменной из ложной глобальной функции которые эту переменную используют первый этап в компиляторах это как правило lexer или таки найдер вот его задача это взять исходный код и разобрать его на на маленькие кусочки которые имеют какой-то более глубокий смысл чем просто символы или или строки вот это так называемые токены или лексемы там могут быть ключевые слова определения типов ; и вот буквально каждый кусочек он имеет некое соответствие вот в этих лексема на выходе вот вот такой вот поток нечитабельный не для человека неудобный вот но код при этом он вот побледнел на этом слайде потому что с кодом уже больше не работаем вот нам он уже не нужен мы получили лексемы нам нам хорошо мы можем двигаться дальше и передать эту информацию паркеру задача парсера это собрать эти лексемы и представить нашу программу в виде некоего а дерево в виде некой структуры с которой можно будет работать дальнейшем более эффективно вот например для такого маленького кусочка кода вот нас есть четыре лексемы iparser из этих четырех лексем вот он создаст вот вот такое дерево может создать такое дерево я не буду вдаваться почему дерево вот именно такое это тема отдельной отдельного доклада может быть на бюро лекций но суть в том что вот формально это будет выглядеть вот вот примерно вот так для каждого узла в дереве будет соответствовать некий класс или ином что угодно для изначальной программы вот все дерево оно будет выглядеть вот вот примерно так как только у нас есть это дерево мы уже можем с ним работать и проводить всевозможные проверки другими словами проводить семантический анализ проверить семантику нашей программы насколько она корректно вот первым шагом как правило первый шаг в семантическом анализе эта проверка типов и вот в этом дереве у некоторых узлов типы не указаны и для всех из них на самом деле очень легко более менее легко вы вычислить этот тип и на это в этом в этом дереве вот видно что вроде как все хорошо все здорово но есть одно проблемное место вот здесь потому что возвращаемый тип функции это интер а тип от умножения двух флотов это все-таки флот и мы не можем просто так взять и присвоить канту флот разные компилятор они ведут себя по-разному разные языки точнее ведут себя по-разному например свист в такой ситуации покажет нам ошибку скажет вы не можете этого сделать и вот вы как как программист нам нужно будет указать явно тип каст какой-то сделать языки более дружные в кавычках они более дружелюбны и собственно такая ситуация вот мы не можем к винту присвоить флот просто так и в зависимости от языка поведение разная вот например sea & sea подобные вот там все плюс плюшем си плюс плюс объекте все они вот добавят здесь impressed каст допустим вызов некой функции там флоту интеджер которая вот разрулит всю эту проблему со свойствами как только мы удостоверились что наша программа корректно и она имеет корректную семантику мы можем двигаться дальше мужа уверен что программа корректно и мы можем генерировать из нее код и это последняя фаза фронтэнда это кода генерация для общения с бэндом вот сейчас на на экране видно наша программа вот изначально вот то самое но в виде уже промежуточное представление llvm вот если присмотреться она выглядит немного как ассемблер но в то же время выглядит немного как си и просматриваются связи между изначальной программой и программой вот в этом представлении промежуточным следующий шаг от правил оптимизации вот в этой программе есть сейчас 4 инструкции 3-му во ii 1 мультипликация вот и если опять таки если присмотреться то видно что мувы они просто делают они берут какую-то переменную кладут ее во временную переменную потом временные перемножают результат кладут во временную переменную и и возвращают вот это бессмысленно абсолютно потому что нам нам не нужны временной переменной здесь и можно вот-вот сократить программу в данном случае вместо четырех инструкций 1 инструкция если это было 1000 стало 200 то это огромный прирост в во всех понятиях это это очень важно да как только мы выжали из нашей программы вот все что мы могли все что мы хотели выжать то можно сгенерировать ассемблер вот я например вообще не понимаю что происходит это семьи для кого-то rm в s7 не знаю что здесь происходит вот выглядит это так заключительная фаза это linker вот я попробую привести пример вот он немного сложные для понимания крайне мере для меня но грубо говоря у нас есть одна программа могут ее компилируем в kalk . а это наш объектный файл потом нас есть другая программа которая вот этот калк использует мы тоже и компилируем и если мы заглянем в программу вот в main то видно некие символы вот этих подчёркивания калка printf main это символы некоторые из них у них нет адреса вот первые 3 и буковка узнать что они ondemand то есть они не определены вот задача линкера потом вот это все все эти объекты собрать в один склеить и поправить вот эти адреса чтобы функция когда мы вызываем мэй например программа знала что куда кого дальше вызывать вот принтер все еще он define здесь но это задача уже динамического загрузчика это часть операционной системы туда я тоже не буду заныривать опять-таки выглядит вот компилятор наши примерно вот так и наверное у многих возник вопрос вот зачем вообще это все рассказываю вот что ты несешь вот до плюс плюс этой архитектуры еще в том что вот есть у нас frontend есть у нас backend и теоретически теоретически и на самом деле практически мы можем вот вклиниться между между fontaine там ибо kindom мы можем брать этот л.м. ai ore то есть промежуточное представление intermediate representations и что ты с ним делать то есть такая вот себе men in the middle атака но вот атака на компилятор и что можно из этого сделать вот я уверен вы можете какие-то сами применения найти этому вот я просто три самые топ-топ идеи своей головы достал и вот они первое это разработка юань вот я уже сказал да я 6 лет около шести лет наверное чуть больше занимаюсь разработкой под ios и единственная тема которая длится вот-вот на протяжении всех шести лет константной это как делать юань люди постоянно халли варят использовать инвизе вы или описать все кодом использовать сториборды или sip of the layout сет фрейм и прочее прочее вот было бы здорово если бы можно было вот вот прям вот в школе вот так вот написать восемь строк кода который нам на рендере от табличку и еще закон лет кейс когда у нас нет данных вот мы можем использовать какой-нибудь х муслим rb что угодно вот мало кто знает но вот vx коде есть такая фича настройках проекта настройках таргета есть последняя вкладочка builders вот там можно указать как обрабатывать файлы которые подпадают под какой-то регулярку вот здесь например файл с расширением slim мы их можем вот компилировать неким slim кампай лером а на выходе у нас будет объектный код который вот просто будет автоматически интегрироваться в xcode и она она вот работает только вот компилятора для slim нет вот никто еще не написал именно для для такого кейса вот и это может выглядеть как неработоспособное решения или страны но я вот я заявляю что это работает я вот таким образом храню например настройки вниз я мыл файл я малком полер который компилирует это все объекте все и как skoda то поток подхватывает все это вот просто smooth работает как как некая магия при этом очень стабильно это было одно применение потенциально вот второй атом моки вот я я сам не пишу еще на свифти тестов но я совершал от людей что проблема есть а типичная ситуация и то есть некий класс юзер у которого есть некий метод aged name который что-то возвращает и есть некий класс юзер консьюмер который сработать с этим юзерам вот как мы делали это уже эти все вот это выглядело примерно вот так мы там какой-то мог создали нажали там став users with name и там вернуть что-то потом этот стоп мог скармливали собственно консьюмер у вести такой не работает вот нам собственно на семантическом на этапе семантического анализа нам компилятор говорит что тут типа не совпадают вот можем его перехитрить и вот например кастануть вот это все так вот так вот дважды и компилятор хотя бы перестанет ругаться но если мы запустим это приложение то она вероятно страшится потому что но мы не можем просто так взять какой-то левый класс смог коснусь какой-то класс юзер но с другой стороны если у нас есть некий промежуточное представление этого кода которая мы между фонтанным брендом если мы туда вклеиваем ся то мы можем отловить все эти моменты здесь вот сидят на самом деле смотрел этот выхлоп и там четко видны эти паттерн это как вот класс мог создается как он на станции руется с каким-то конкретным типом и и мы можем вот эту информацию взять и на ее основании сгенерировать в прям вот объектный код который будет нашим маком то есть не надо руками писать второй момент это там die-cast это тоже там четки поттер там 3 или 4 инструкции вот не помню точно но это это вот легко увидеть и пропатчить вставить туда вот наш какой-то мог объект который будет этим всем заниматься и ну никакой боли почти но опять-таки этого тоже нет вот по крайней мере с в мире и весь разработки я не видел этого но это работает в java есть фрейм or powermac power mac и вот на эти по моему изолятор какой-то тоже мог изолятор чего-то не помню названия вот третье самое экзотическое вот мое любимое применение возможно это мутационные тестирования вот я в двух словах сейчас расскажу по пытаясь занести идею она простая но очень интересное вот допустим нас есть метод сумма который суммирует два числа там a и b и у нас есть некий тест вот а тест у нас в принципе справедливой он использует математические свойства какие-то вот там тест как а сам шин делает предположение что сумма двух позитивных чисел она больше 0 и если мы прогоним тест то он будет зеленый если мы посмотрим на код к вырыть он будет вот сто процентов вообще ну вот офигенно круто а если присмотреться в программу в изначальную то там вот не плюс было умножение вот и вот это тождество которое в тесте проверяется она работает все также для нашей некорректной программы идея мутационного тестирование в том что для каждой изначальной программы вы для суммы мы генерируем некоего мутанта они что что слегка отличается от изначальной программы например вот сумма возвращается сумма не а умножить на b a + b либо возвращается просто а либо еще что то можно там быть вот и если мы на каждом из этапов из этих мутантов прогоним наш тест тот тест должен падать если тест не упал то у нас либо тест корявый либо само приложение коня вы то есть сумма это тоже может выглядеть чем-то неработоспособным но во первых это работает java как меню там есть framework и тест это работает в рубин там есть тоже пример библиотека гим гим называется он мутант есть даже помощь печки вот в сексе + + и их ты-то всего нет вот и это сам деле я вот работаю над этим это занимает много времени но она выглядит как что-то простое вот ну как она выглядит как что сложно и но как только я поближе подошел она не выглядит как нечто сложно просто требует немного времени и усидчивости опять-таки в чем в чем проблема вот этих проблем этих применений вот я здесь указал до 3 который вот у меня в голове есть вы можете я уверен что то что то тоже придумать есть какие-то у вас point point и которые может решить вот этот аят и и вот эти все прочие магия но проблема проблем несколько на самом деле эти применения они не они не готовы потому что люди заняты как правило вот сейчас все пишут парсеры для же сон на swift а либо пишут какую-то библиотеку для там реактивного чего-то там на монада вот но самая большая проблема в том что порог вхождения в это все как правило высокий но не потому что тема сложная а просто потому что информации мало у нас на самом деле много информации только компилятор работает вот высокоуровневой какая-то такая абстракция а как поближе как это все использовать вот этого всего нет даже если посмотреть в земли джесси какую-то документацию вот оно как правило устаревшая или или просто некорректно вот и как правило новичок который пытается что-то сделать он видит массу массу ошибок и сложно понять как с этим бороться вот я вот начал этим всем заниматься года три назад и я до сих пор вот борюсь еще периодически какие-то вылазят очень страшные вещи которые я не понимаю и уходит очень много времени вот по этому я решил сделать небольшой шаблончик вот на в это xcode проект в котором я нас это пил уже а вот эту связку лил вейн и свифт вот то есть всего того чтобы это все завести нужно всего лишь его скачать нажать вот там mixed up майк билд в терминале и открыть проект вот mixed up он просто спланирует элвин куда надо моих build это все соберет вот все нужные библиотеки будут собраны скачает он собственно вот там там есть в проекте один файлик x c конфиг вот там есть два две переменные которые вот указывают куда качать и куда собирать и вот там есть linker flex это то какие элвин такие кусочки llvm нам нужны и это все работает очень просто вот я уже сказал да вначале что не нужно быть каким то красноглазым бинт уж ником живущим где-то в терминале там vimeo и макс что угодно можно просто вот xcode открыть и вот пользоваться этим вот эта программа например создаст модуль вот это модуль это вот промежуточное представление нашей программы исходной программы то местные языки сели там си плюс плюс нового llvm это вот то как она выглядит на вот этом на рубеже фронтэнда и и бэкенда вот и с этим можно уже работать можно например вот легко пробежаться по всем функциям которые определены в файле в модуле точнее а либо пробежаться вот взять какую-то функцию да по по некоему имени вот или просто первую функцию любой пробежаться по инструкции вот и это это все от работает очень очень просто на самом деле и удобно я вот в работе над этим фреймворком для мутационного тестирования на самом деле пишу на си плюс плюс потому что по другим причинам но вот для кого-то прототипирования если мне нужно быстро программная пробежаться по а ярко вот по вот этому внутреннему представлению посмотреть какие там паттерн и какие инструкции используются подобное я вот вот вот это вот использую и она очень удобно и легко вот но дальше я конечно же хотел бы чтобы вот все все бросили побежали вот клепать и титулы и вот работать со мной вместе над этим это сумму тестирование помогать всячески но будет здорово если вы хотя бы мне хотя бы если вы какой-то информации из этого почерпнете если может быть какая-то мотивация воспаляются вот я несколько ссылок дал первое это от криса лотнера он вот туалет может пять-шесть назад написал статью о том как работает и ловим вообще как какие там решения были приняты каким причинам вот то есть я читал лотнера и почитал его еще до того как это стало мейнстримом это здорово вот вторая ссылка это часть документации lanvin там туториал о том как создать язык программирования игрушечный но он вполне себе работоспособен вот если кто-то всё ещё боится компиляторов то вот можете пройти этот туториал он очень небольшой на самом деле и там вот вот все просто вот компилятор это просто вот это тезис моего выступления дальше вода ссылка на мой блог там я тоже пишу провел им и как правило я я сам это всем новичок и я пишу то что может помочь новичкам людям которые тоже пытаются как-то изучать эту область вот две последние ссылки это непосредственно код всякие пример о том как как можно использовать и и пьянь предоставляемый лови вот из и свифта но последнее это вот не постоянно тот шаблон который который я показывал вот который просто просто работает сейчас порцию спасибо ты рассказывал вот что у себя в проектах ямал используешь для хранения настроек можно чуть подробнее как вообще во что это в итоге транслируется и как ты это используешь садись но ямал да все все в курсе до примерно как он выглядит вот короче это не некий формат чисто текстовый и вот в этом я мля я определяю один объект здесь какой-то допустим давала момент station и продакшн и для вот каждого из этих яму объектов там есть настройки допустим и pr and point какие-то ключи для google ключи для какие-то крышки текстов и прочих прочих и вот потом просто xcode заменяет a hand но я я написал там такой псевдо компилятор который генерирует из этого yabla объекте все файл и потом xcode сам разруливает вот я ему говорю что вот я мол финли вот таким то компилятором на выходе у тебя будет объекте все файл их скот сам этот объект и все файл подхватывает компилирует его в нативный код вот то есть работает очень вот с музка как как магия и года полтора назад я это внедрил в проект и не трогал вот просто просто работает я я не знаю я куда-то могу потом ссылке добавить на этот на это все тоже я только не знаю куда да вот я флаг сброшу ссылку если кому-то тоже еще интересно вот еще вопрос а из я спал файл заголовок файл заголовок он поможет нет файл заголовок создан отдельно да это 33 да да но в теории можно это тоже его генерировать но я не знаю почему я принял вот решение иметь исходный заголовочный файл сразу фреймворк для мутационного тестирования используется контролем проекте а нет когда-нибудь посмотреть есть есть планах под но я я все еще работаю над этим как бы в 1 в свободное время поэтому я не могу дать каких-то обещаний по срокам но у меня вот есть есть серьезные планы где-то его использовать вот в чем то большом я увидел плохо может быть и там там много есть а кейсов вам много вещей которые требуют скажем так много вопросов на которые у меня нет четких ответов вот вот еще там и и вот эта проблема это одно это не самая большая проблема на самом деле которая там есть еще насчет графон ключи работает хорошо вот он отключался по ходу по-моему проще разобрать это генерировать распарсить и второй код и на генерит смоков возможно я не утверждал что это единственно верное решение вот это просто одно из возможных применений да и проще возможно проще не давать имена софтовый код но вот у этого подхода есть другие плюсы например в том же java или тут найти фреймворке которые делает что-то похожее у них есть огромные плюсы в том что они позволяют вам макать какие-то приватные методы например но у джавы и сишарп runtime очень гибкий и есть рефлексий на записи соответственно там можно не углубляться не в компиляторы не в парсинг не в таки найдер и тем не менее существуют в каморке которые углубляются и и делают возможно ли применить без рефлексий на запись для генерации мог объект теории да можно и ловим он просто генерирует объектный код он генерирует вот машинный код на самом деле скажу то есть два инстанции разных одного протокола вполне можно сгенерить один реальный заставить его подменить отдельные функции вызывать я я думаю что это возможно я не знаю насколько это трудоемко насколько это трудозатратно но это точно возможно вот все вот эти вот вещи такие как там протоколы инстанции это все вот часть фронтэнда это то есть грубо говоря защита от дурака вот и ловим вот ему все равно там есть машинный код который как-то выполняется и мы можем его патчить можем делать с ним вообще все что угодно а вот но на на уровне машинного кода у нас нет никакого понятия о классах функциях типах протоколах extension ах вот этого всего нет это просто можно сказать такой синтаксический сахар для для ассемблера вот все эти высокоуровневые языки давайте еще один вопрос и потом можно будет продолжить общаться пахали варить да и кто еще да давай два потому что там ее держали руки вопрос может не совсем по теме но ты-то мутационной тестирования она вообще где применим от по ощущениям в реальной программе может быть ключ время заняться созданием этих мутантов проверку что они нормально работают что эти можешь сказать про области применения где он может где то это очень долго займёт и про мне нужно это использую применение это unit тестирование как правило таркетт tarkett группа скажем так коммутационное тестирование the unit is the unit тесты и это применимо по-моему вообще к любым программам но там вероятно есть какие-то и кейсы вот у меня нет собой сейчас никаких цифр я не буду врать но я смотрел один из докладов о и тест мутационной тестирование для java и там какая библиотека математическая библиотека огромная там про гонялись вот эти все мутационные тесты на ней и это занимает очень много времени там какая-то первая версия этой библиотеке там прогоняла 16 часов это все там какая-то улучшенная версия там четыре часа это это очень много это трудозатрат трудозатратно но я думаю что мы можем себе позволить например раз в неделю это гонять на каких-то своих там unit тестов или раз в месяц зависимости от размеров проекта да и как как результат на самом деле очень много багов находится вот я прочел пару бумаг как пересечь peppers на на тему мутационные тестирование там очень интересные цифры пишут вот я тоже не помню их напомню что они высокие достаточно большое количество багов находится при помощи от нато со мной тестирования а также помогать с мертвым кодом вот в этой математически библиотеки в на java там какую-то функцию нашли которая вызывает другую функцию и вот то функция она тяжелая и она не нужно на самом деле она просто устарела ее дрогнули и привез в библиотеке получился и это сложно ну это наверное невозможно отловить как-то вот руками скажем так ману ли спасибо а смысл ссылку на эти персонажи скинуть флаг то что интересно почитать да а может можно еще последний вопрос как выглядят потом инфраструктуры то есть если мы сделали освоил ловим модули водки например для этих же мог of а как потом будет выглядеть инфраструктура вот у меня enterprise как будто какие-то там бил сервера стоят там какие-то дженкинс и fast lane и то есть мне надо будет целиком кастом-байк символы ремонт выкатывать свой собственный или там как-то runtime модули подключаются вот к тому который идет соплу как будто мы выглядит потом не сложно сказать вот я я не знаю вот так скажем я не знаю это может выглядеть вот там точно не тран тай модулей мы не можем подключать голове мотай модули в теории мы можем некий свой что-то вроде компилятор своего выкатить вот например а есть статический анализатор в xcode вот там клан кстати к на лазер используется это на самом деле там кастомный компилятор немного расширенный вот клан и он вот просто заменяется там мы копируем низ лангом например а вот с этим сквонк там clang человек какой то и то же самое возможно вот вот здесь"
}