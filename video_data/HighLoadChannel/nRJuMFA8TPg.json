{
  "video_id": "nRJuMFA8TPg",
  "channel": "HighLoadChannel",
  "title": "Программистам не нужны стринги / Георгий Полевой (Dodo Pizza)",
  "views": 1289,
  "duration": 3034,
  "published": "2020-04-14T11:23:02-07:00",
  "text": "меня зовут георгий полевой я и сыр я инженер в компании додо пицца додо пицца это международная сеть пиццерий нас больше 530 и пиццерии в 13 странах распределенную мощная система и да да из которые обеспечивают деятельность всей нашей франшизы у нас весь код на песчаной сишарпе более 100 виртуальных машин в облаке и мы заботимся о производительности конечно же производительности наших систем приходится заботиться потому что вот это число 530 каждый год удваивается в общем-то а бесплатный сыр закончился все такой бесплатный сыр вот еще лет десять назад самый лучший что можно было сделать для улучшения производительности систем на сишарпе это было просто подождать два года и производительность вашей системы просто само собой улучшится мы потому что уже заказали новый дорогой сервер он едет он приедет и система начнет вдвоем быстрее работать потому что плотность транзисторов увеличилась двое и соответственно вы ушло производительность мы видим что бесплатный сыр у нас закончился в 2003 году приблизительно производительность одного потока уже практически не растет никогда и плотность транзисторов уже достигается за счет увеличения количества ядер а если у вас желез в облаке то за каждый ядро вы платите мы не будем говорить таких аспектах которые вообще привычные разработан там enterprise и разработки об архитектуре еще о чем то мы вот это вот стандартная теория частицы нас не интересует мы будем об очень простой вещи говорить самый простой но из которой состоит все я утверждаю что все это string и ну по крайней мере когда речь идет о производительности системы сша стринги у нас везде этот параметр в базах данных это самка программы с джейсон из quelle что угодно а ключи в одессе и значение тоже это тоже string объекту string это самый первый метод который мы знаем и это очень плохой метод кстати если сравнить с другими языками где принято производительностью вообще говорить но знаете раньше вообще разговор с артистом си плюс плюс ником был такой говорит о мой кот в четыре раза быстрее ты с этим ничего не сделаешь вот и действительно было так вот мы видим что здесь некая таблица где приведены параметры производительности функции интернету аске написано сеют она не является частью библиотеки и у каждой оси там пишет сама или носит этот код собой у них свои реализация вот мы видим тут рекордсмен даже есть который его bunch марка там 72 процента от зла и на по скорости вот это ужасный кот он ужасный почему то есть усть sharpies то вообще должны дам ну то есть который занимается enterprise разработкой продуктовой разработкой бизнес логикой когда он видит что мы разминаем указатель идем по памяти до что-то пишем он скажет нет только не в моей программе этого быть не должно и никогда почему потому что это арифметика пойнтеров она очень быстрая и и сложно делать и она злая-злая на в каком отношении ну вот она может продырявить ваш стек кучу стену поссориться с соседями пнуть вашу собачку так далее вот и оно чревато ошибками от спорные утверждения на самом деле она гораздо проще например для меня как потому что в прошлом программировал на оси и все плюс плюсе и в принципе мне когда работаю с пингом не бы легче было делать логику на пантерах но это опасный код вот что же делать разработчикам из sharpie я очень рекомендую прежде всего посмотреть улучшение в кор 30 там сок в этом блокпосте собранные полу request и которые отвечают за производительность 30 здесь тондо очень характерная манч марка 20-кратное ускорение работы со стрингами мы берем daytime это в этой пт и другие улучшения не такие драматические на среднем можно сказать что если вы возьмете среднее мое приложение его просто запусти на карте но ли она на 40 процентов быстрее станет от не случайно происходит потому что команду ты то они вкладываются очень сильно в оптимизацию в последнее время они стали то есть монет уже в ряд с высоконагруженных дисками который миллиона request of обслуживать на одной ноте и так далее ну да я уже говорил этот код работает со стрингами это метод парс и раньше с методами парс и формат всегда были проблемы мы разберем какие собственно да но я говорил же string плохая штука плохая вещь почему она плохая вот простой string он по идее должен занимать 16 секторов занимает он 32 байта в памяти но если просто разместить черты в памяти да и казалось бы большего не нужно но мы видим что в 32 байта у нас вылезет тот хлоп остальное займет в общем-то мало релевантные вещи ну наиболее релевантный оверхед это лен то есть там в принципе loyalty объект будет длина строки хранится это еще хоть как-то полезная работа со строками дальше у нас метод эйбл и там 7 блок все это мало относится к слингам он пример все это всё нету там string это просто область памяти оканчивающихся нулем тому orchid это 1 ч ректор да ну и соответственно здесь вот чертой минимальная размер strenx'а указан 24 даже если вы сделали вот так string длиной 1 в 1 ч ректор это двадцать четыре байта пишите бенчмарки пожалуйста включаете там колонку allocate и смотрите сколько вас ирана очень много инсайтов от этого получите и дальше мы рассмотрим вот такой момент когда разработчики пишут код нам очень важно maintain обелить а иногда она нам важнее производительности даже бывает то есть если мы не пишем какую-то там дробилку данных где мы работаем с битами да мы пропишем простой код который обслуживает бизнес нам важнее читать код нам очень важен важно интерполяция стрингов что мы смотрим глазами видим что мы получим в конце и здесь кроется очень много проблем ну собственно этот пример из букваря как говорится то есть у джеффри виктор и в принципе все это есть в чем в чем здесь подвох у нас что на самом деле синтаксический сахар вот к такому методу сделать кучу локаций новый массив делается boxing в конце вызывается tanks формат еще одна локация с mustang в итоге мы получили больше 14 аллокаций на этот метод скука там внутри string формате сделается непонятно 14 вдумайтесь это очень маленький string это мы делаем ставим его героем например что то мы делаем лог дебаг и если подумать вам мы можем отключить уровень логирование дэбак да мы втыкаем эти строчки они нам нужны для диагностики в каких-то ситуациях в режиме разработчикам мы включаем этот уровень логирование в производстве отключаем потому что там у нас слишком много всего но когда этот лаггер самый поймет что ему не надо ничего записывать файл уже после того как будут все эти локации произойдут потому что он через параметры принимает этот стрим ну давайте попробуем расправиться с этим стинга мы уберем boxing для него вот у нас будет больше восьми локаций все еще плохо используем stringbuilder зачем здесь этот код мы все знают как пользоваться этим бендером для сравнения этот кот уже гораздо лучше но его гораздо труднее писать в принципе не сильно принципе можно попросить разработчиков стоит такой код нам его я например даже предпочитаю писать вот в таком виде они в виде интерполяции стринги мне этот код понятнее вот но он тоже плохое здесь есть две локации кстати непонятно сколько локации потому что в предыдущих версиях висели там могли возникать аллокации это же мог возникнуть boxing или вызов ту стрингах то есть у нас больше двух аллокация возможно больше восьми вот зира locations из предыдущих докладываю должно быть понятно почему вообще в принципе это дорого лоцировать будем бороться за то что у нас их вообще не было в принципе 100 колок о котором вы уже знаете и вот посмотрите у нас уже шесть строчек кода чтобы просто отформатируйте 1 чисел вот тяжело писать такой вот да и кстати он не совсем zero лук потому что в конце делаем черный new string то есть мы совсем не можем вроде как избавиться или можем что мы с этим можем делать но давайте подумаем зачем нам вообще этот string если мы пишем форм что-то форматируем мы как-то собираемся используют соответственно это request response pipeline например в в спамить и мы можем использовать запись по принципу голливуда да они не зовите нас мы сами вас позовем у вас pipeline он как бы говорит вот все у вас уже есть память вот вам что-то на вход вот вам память куда писать то что на выход пожалуйста работаете это очень экономит память потому что memory- менеджер который там написано он уже он он тоже оптимизирован и нам меньше об этом нужно думать и в принципе мы так делаем жира лодку все-таки остались еще стринги какие-то нута точнее вот давайте еще раз посмотрим на этот любимый интерполяцию стринги нам хочется этот код все-таки иметь а теперь нам надо писать вот такой код да потому что теперь мы работаем в режиме zero лака и здесь два экрана кода вот наверное вы уже слышали большинство из вас слышало провели you stay on byl ирака там говорил станислав в принципе я не пользуюсь этим валим stringbuilder am да и не там не копирую код из исходников вот на это я пишу свой это young водород и tariffs тракт вот и в принципе вот то есть в нем есть спам нём есть длина и на нем есть кучу таких вот методов up and таких же как мы ставим билл гарь и вот например один из методов это интернету аске вдумайтесь да насколько стал шар другим раньше такой код sharp разработчику можно было разве что на экзамене по информатике институте написать вот потому что да а сейчас оказывается что это один из основных методов оптимизации ну кстати вот это вот семейство функций трой формат она появилась последнее время почти что у всех вылетает методов они все на вид выходе дают длину принимают span вот и можно им пользоваться но свой получается быстрее что здесь интересно вот у вас получился код который так работа ну да он в конце мая цитирует string мы знаем что это можно избегать за счет pipeline of например но тем не менее этот код это практически такой же код который можно настроить билл гарь и единственного нам надо сделать 100 колок и создать от encoder со и посмотрим что мы получили в плане производительности последняя строчка короче это лучше это быстрее соответственно больше чем в 3 раза быстрее даже не это важно мы будем смотреть то что происходит с памятью с памятью у нас происходит в старых методов то есть мы постепенно пытались улучшить сделали вызывают у string у нас выросла производительность но работа с памятью осталась такая же плохая вот мы видим предметы которые лоцируется в 4 раза больше чем это плохо по многим разным причинам потому что у нас там у нас x палец кэш процессора у нас garbage collector нагружается мы знаем что это очень плохо даже если мы это делаем оптимальный тут же сумма жда им объекты как бы мы не научились работать с его церан строками если их совсем нету то это самое лучшее что можно сделать ну и вот рассмотрим такой вот кусочек кода который дело точному уже какую-то серьезную работу он не просто там интерполяция string когда мы получаем на вход какой-то большой string например война и мир толстого то и нам нужно через какой-то фильтр пропустить каждое слово и tostring replace ну на минуточку если мы просто сделали string риплейс было бы совсем плохо омывают я думаю понятно но в принципе вот эти вот три строчки это очень и очень оптимальный метод который несколько лет назад маму писали даже высокопроизводительным прилагаем приложение он очень недурно работает по сравнению с вызовами string риплейс что он делает он сразу делать tanks плейдо создает ворох объектов на хиппи чего делать мы не хотим совсем заменяет каждая и собирает их обратно посмотрим как он справляется со своей работой bench парочка слил показывают время его работы по сравнению зверолов методом которые справа сразу видим в три раза худшее производительность инструмента просто она просто за счет аллокаций вот это вот уже собственном и пощупали да мы слышали теорию сейчас мы видим как это реально влияет то есть это моя мари менеджер в чистом виде это кэше процессора это все что угодно что связано с а локациями да и самое худшее здесь что здесь не совсем заметно без объяснений не может быть попробовать сюда показать посмотрите вот на вот эту вот область это у нас запуск на разном количестве потоков что мы хотим мы берем 16 ядерную машину и запускаем на нем много таких задач и хотим на 16 ядрах получить в 16 раз быстрее обработку задачи и мы не получаем мы получаем наши нас театрах производительность 6 ядер это режим горушка электро серверный до зеркалок метод работает чётко мы получаем на 16 ядрах 13 лидер ну как бы условно производительность 13 over 16 16 мы не получим да мы получим всегда немножко меньше тут суть всех поточных систем но тем не менее это гораздо лучше это вдвое лучше уже то есть этот метод работает не в 3 раза быстрее а в шесть раз быстрее есть мы говорим о им поточность а вот режим garbage collector workstation мы знаем что он более конкурентным как бы он немножко по-другому работает там он чаще старается собирать память и не позволяет раздуваться соответственно у нас garbage collector вызывается чаще и более дешевые сборки делает и видим что на многопроцессорной системе он совсем плохо работает но почему мы вообще запустили workstation горбач коллектор на сервере на 16 ядерным он в принципе для этого вроде как не предназначен оказывается иногда бывает так нужно потому что мы хотим получить маленьком селе сервисах у нас может быть куча ворох микро сервисов развернутым на 1 виртуалке в кубе рн и все каждое приложение маленькая ну работает в маленьком workin' сети и там важный режим короче коллектор workstation у нас не получится так работать если мы ассоциируем память не думаю об этом правый метод как как и прежде работает совершенно спокойненько масштабируется это масштабирование на ядра процессора с точки зрения локаций память и но опять же в этом методе мы или intel используя и номеру здесь мы этого это роскошь а у нас нет потому что у нас интерфейс соответственно нам нужно что-то другое нам нужен реестр от вот чтобы работать с этим также чтобы какой-то приемлемый интерфейс построить что очень важно у нас появились все кнопки для оптимизации но разработчикам важно писать красивый кот мы не можем просто братья производительность нам нужно везде экономия на локациях нам нужно везде даже в бизнес логики но мы не можем себе позволить писать код который на несколько экранов поэтому нам нужно что-то вроде ленку потому мы будем писать оператор вот в принципе вот такой вот код он с моей точки зрения приемлем потому что он в принципе делает обычный for each по сплиттера мы не бежим мы здесь не делаем арифметики panther и снаружи то есть мы сделали strings плит по сути но это итератор то есть проблема использовать обычные линки вот в этих вот двух интерфейсах reeves тракт не запихнёшь туда внутрь да мы уже знаем вот и это огромный член сделать приемлемый интерфейс для того чтобы описать красивый кот тест на в чем заключается проблема что здесь клаузуру да и в этой строчке у нас есть y он делает захват и создает объект потом он еще и создает делегат это уже локаций ту же не zero lo код но если бы мы сделали что-то вроде вот этого мы бы получили zero логкат это же самое за счет чего это происходит за счет того что мы здесь работаем состоит им смотрите здесь кроме лямды этот метод еще принимает state это значит что мы не ассоциируем delicate и не делаем клаузуру мы все что нам нужно собираем в нете объект или мы уже передаем куют вылетает туда и вот y штрих в этом выражении это как раз полученный из параметров делегата вот этот самый state это паттерн который позволяет делать зеркалок лямбда выражения пожалуйста пользуйтесь потому что это шикарный инструмент узнаем домой делегат может статически ассоциироваться он может один раз на весь lifespan программа аллоцировать его вызывать дешево почему его дешево кстати в кори третьем вызов делегата стал вдвое быстрее я просто мне просто интересно вообще что-то произошло но он всегда был медленным чуть чуть дольше чем вызов виртуальной функции скажу сейчас это порядка 1 наносекунду в результате легато просто и есть у такой метод который пользуется таким же принципам он использует state и tostring рейда смотрите появился отличный способ создавать стринги да мы создаем стрингер затем без них нельзя ну у нас в конце концов есть базы данных до нам иногда нужны стринги но вот этот вот метод string рейд и он используется и в bethel и повсюду если посмотреть переписку датчиков которые пишут bisel они сначала очень полюбили пулы stringbuilder of вот и все активно на них переписали а сейчас они вычищают это потому что но есть более эффективная вещь которая работает на 100 колоки который работает со спамом вот что здесь происходит собственно мы задаем мы знаем что за строку мы хотим создать мы ее могли ну например представьте мы бы здесь какой-нибудь делали там склеивания двух стрингов мы вычислили их длину вот передаем длину вот а дальше что происходит дальше принцип голливуда опять на нам аллоцировать память и говорят смотри вот тебя в делегате позвали на те память пиши вот твой string ты как это так как это мой string я же не могу менять string а вот ты можешь теперь менять string изнутри вот этого самого делегатов стайен трети тебе уже дали память и этот метод он экономит копирование смотрите мы могли сделать бульбу fix буфер директором до могли даже его сделать нас такая локи а потому что задать стрим прям бы копировался вот на этом на на секунды экономятся живем без стрингов нам очень хочется в принципе делать a + b string формат вот это все и то есть со стрингами удобно работать как с отдельными объектами а теперь у нас их нет у нас есть какие-то директор и они в каком-то с пони кусочком лежат вот отсюда сюда и как с этим работать а что теперь с addiction dictionary кстати это вообще просто секретное оружие тут нальчика всегда была вот такая вещь которая опять же если так вот представить какую то оппонент уютом программисты носи а что ты скажешь про dictionary а у нас их нет но у нас и так все быстро там ладно dictionary то очень дико быстрая вещь прежде потому что это в хип структура а теперь dictionary чего мы сделаем у нас нету их да кстати почему он быстрый dictionary если вы попробуйте хрестоматийный там dictionary написать то есть хэш-таблицу свою где будут bucket ее linked лист и у вас получится в пять раз быстрее попробуйте и вы ничего с этим не сделаете никак вот до тех пор пока у вас будет linked лист которая лоцируют объекты на куча вожди канале будет в несколько раз медленней но он реально быстрый и он быстро не потому что он написан на ассемблере он написан на обычном сишарпе он использует of hip эта концепция пришедший из залов жарю все очень плохо с виллы этой пами всегда был поэтому они там этот принцип развивался скажем так там и очень многие методы можно подчеркнуть из-за вы то есть они берут какую-то область памяти и рассматривать ее как массив и объект выбирают оттуда они не говорят дальний объект дай мне какой-то там адрес массиве что-то там лежит и также работает dictionary у него по сути внутри маленький garbage collector такой то есть он аллоцировать тот же linked лист но в буфере вылетов ну соответственно для такого словаря нам нужен вылью string это вообще ну вот об этом это такая дикость да вы попробуем string из 4 сделать в илью string из четырех характеров встречайте white string 4 вот понятно что это такое ну с этим работать нельзя мы поэтому будем объединять в string 4-го и танк 8-го 16 и так далее это все рок коротенький string но и в и он фиксированной длины можно вообще с этим работать мы сможем вообще из работать со стрингами фиксированной длины сможем мы же с базами данных работаем дамба фиксированной длины да у нас есть там поля текст но в принципе баз данных наиболее оптимально работает когда мы ограничиваем колон длину колонке мы стараемся то делать почему здесь мы не можем это делать мы же все мы работаем в конце концов базой данных ну вот как мы его будем делать то есть мы будем их объединять как матрешку один другой и в какой-то момент нам нужно работать как со спамом че ректоров у нас появляется 2 интересных вещи aggressive in-line young & memory маршал мы видим вот на этом методе я попробую буквально чуть-чуть о них рассказать aggressive in-line что такое aggressive in-line к это атрибут который вам будет абсолютно необходимы если вы будете работать с валютой пами и писать какие-то методы которые очень быстро выполняются в а лайнеры какие-то если вы попытаетесь без этого the compiler может это финал только хендай компилятора но компилятор вам может сделать это как вызов методы и передавать вылью type через стек очень дорого поэтому лучше все и майнить все так работаете вот и memory маршева мы видели ты такой memory маршал на самом деле это intrinsic принципе это такие штуки когда вы в принципе видите какой-то код а там ничего то есть если мы вот зашли в метод кредит span он ничего не создает это но об это просто каста пойнтера ну кто знаком с арифметикой пойнтеров при обгоне пантера она как правило вообще ноль операции там нет никаких инструкций процессора не вызывается иногда делается какой-то вольман пойнтеров что то такое но в любом случае это как-то о чем знает компилятор и он выполняет это очень быстро как правило за одну-две инструкций процессора соответственно если ваш тулкит знает о платформе который работает он сделает оптимальной код здесь ну и мы будем пользоваться векторизации но вылью стринги векторизация это концепция single in страх сам мало тепла дейта пользователем фактом что у нас много ч ректоров лежит mlm структуры разметили так что у нас на самом деле интеджер мы можем и еще в или уст белье стринги у нас есть особенность что у нас 0 и 1 узнаете как всегда там один нолик в конце стинга мы чтобы определить длину у нас длина не хранится мы бежим от начала до конца до 0 здесь нам можно пойти в сразу середину стинга и посмотреть если там 0 если там уже не 0 мы можем пойти в другой тестировать только половину этой структуры за счет этого мы будем экономить то есть в принципе у нас есть шанс сделать ту string быстрее чем все ой то есть стерлин быстрее чем все посмотрим от действительно так вот слева это обычный проход по методу индексов ой проход по спо ну индексов справа и это работа со с помощью работы с помощью вот этих вот с помощью векторизации адресация куда-то в середину сразу и проверка 0 там нам важные инструменты для работы с zero волокон потому что реально мы уже видели ситуацию когда мы просмотрели кучу бак синга кучу нежелательных действия lacie провокации лямды это все можно просмотреть и компилятор вас не всегда будет принадлежать нам нужен интер вот это инструмент которым я пользуюсь он вот так вот нам показывают смотрите я сделал страшную вещь которая никогда не надо делать это я попытался вызвать метод equus неправильную сигнатуру метода у меня там есть специальный который сумел этапом при там уже работа это может быть его и нет он оранжевым подчеркнет и скажет что же ты делаешь в час здесь boxing также он вот посмотрим в этом коде который для этой бенчмарки был написан для этого доклада и мы видим что этот инструмент здесь у подчеркивает я очень советую вам пользуется плагин для райдера вот когда я его первый поставил было очень много в коде который я считал тим аллен и обнаружил много таких оранжевых штук как можно себе выстрелить ногу ну например загрузить сто пятьсот стрингов память вообще нужна нам что петергоф памяти когда-нибудь я считаю что нет никогда не нужно один из докладов вот на этом мероприятии посвящен крепостным структурам данных насколько я знаю про блум фильтр рассказывается позже нам нужен фильтр паролей и у нас есть файл 30 там 30 мегабайт на диске что будет если мы его в память закачаем опять же наивным методом вот прям вот заборчик сил так это вообще тривиально файл редон string сплит дикше миры и оттуда или нюхаешь сет из стрингов и 37 мегабайт на диске и 700 мегабайт в память как вам такое 700 почему и еще и фрагментированный la джорджик хип чудесно не надо этого делать сделать теплом фильтр он будет занимать 4 мегабайта и одну локацию ровно на всю загрузку файла вот таких вещах нужно думать сто пятьсот сингл в памяти нам не нужно ни baxi не боксе валютой по не вызываете стинг формат никогда не создавайте стоим билдеры сами если надо берите их из пула и либо вообще лучше забудьте про них ай-q это было немножко отдельная вещь она чуть не про стринги она в принципе про производительность если вы будете работать с целью этой пами не забывайте про то что я пил с очень не оптимальна для них реализован дефолты нужно делать свою и квиты был и логе мы говорили да мы пытаемся что залакировать слоги масло в режиме до бог отключены но оказывается что даже до того как строчка узнала то что она никуда не запишется она уже была создана для ее создания в ворох временных объектов нам загадил ну дал нагрузка на garbage collector тут надо что-то придумывать найти лучшие вч их написать вы можете в нагруженном методы делать логирование но сделать и их чик включен ли у вас джим багирова нее zero allocation понятно всегда им принципе ваши друзья изучайте что каин принципе есть если вы начнете попытаться высокопроизводительный qotsa с деньгами писать вам так или иначе придется с ними познакомиться принципе есть для каких-то инструкций процессора которая компилятор вам обычно не дает делать вы вызываете метод на самом деле это вызов одной инструкции процессор есть и такие и много всего еще архип если вы не знаете что такое там не слышали про это слово это на самом деле хип то есть мы работаем в happy alone сырым большой объект но работаем с элементами по отдельности и это валютой по используйте linder он вам поможет просто писать код и не наступать на такие вещи как не нечаянный boxing начальной локации да но нам теперь нужен был метод стр лин вот тут я немножко расскажу о такой вообще экзотические вещи до вспомним про наш вот этот string вспомним про структуру которого пытались сделать только здесь мы видим что на самом деле он не случайно 32 байта на самом деле это rx200s 6 или два средства 28 набор инструкций который есть или их нет в разных процессоров но ими можно пользоваться если вы знаете о какой железки будет запускать код как может работать от метр стерлин вот смотрим да у нас много нулей у нас не 10 в конце как все а у нас много нулей поэтому мы можем сделать вот так вызвать 3 вызвать 4 инструкций загрузить вектор в регистр вызвать операция кампер который нам возведет старший бит для всех ненулевых секторов и вызывать собрать это в маску битов и вызвать попка und кубка он будет в два раза больше чем or мы поделим на 2 вот мы получили длину string опять смотрите это intrinsic и то есть принципе мы вызываем функции каждый из этих функций вот так вот если из общих соображений подумать должна была очень долго работать вдумайтесь 32 pointer на 32 байта мы передаем в одной функцией она куда-то это грузит это уже как бы ни одна инструкция процессора явно а здесь это 1 потому что это intrinsic который работает ну и вот такая производительность вот мы писали самый высокий столбик это индексов обычный ну и лестерленд вот это мы пытались уже видели диаграммы вот это с с е а вот это вы x 1 наносекунду место 8 это быстро то есть за 1 наносекунду ну да 4 такта процессора в принципе так получилось опасная вещь во первых там есть инструкция fix ты мы и делаем он сейф метод насколько это вообще можно это сомнительно вещь я да скорее всего экспо ментальная вещь такая если мы начнем что серьезно писать ну вот смотрите просто хотелось проиллюстрировать что в принципе сейчас можно на сишарпе достигать то есть абсолютно любого уровня низкоуровневые производительности которые традиционно там все fi + плюсе вы имеете что-то маловато мне было шестнадцать директор если честно 16 тоже делать ну есть же utf-8 вспомним и смотрите как получается спасибо у меня все на самом деле у вас осталось на вопросы время спасибо большой гриб или вы за ваш вклад и мы хотим поблагодарить вас за ваше выступление примите благодарность и подарок наших зрителей попрошу не расходиться вы можете задать вопрос георгию и напомню что за самый лучший вопрос по мнению георгию вы получите подарок от нашего спонсора оргиями павилоста кто хочет всего за доклад хотел спросить вот вы когда показывали что там обработка текста через select да через получается через линки и делали на многоядерной системе вот я может быть не очень понял но почему он ожидать надо ускорение до если мы делаем через линки логичный через пылинки мире нет я понял вопрос на самом деле здесь я бы не стал бы испано приложение делать пылинки никогда здесь речь идет просто о многопользовательской системе у вас нагрузка у вас куча пользователь вас куча правильных request of пользователи это могут быть другие сервера могут быть живые пользователи которых в интернете много да они просто делают параллельные запросы здесь говорится о том что размер задачи он рассматривается в совокупности как вся нагрузка которая идет на сервер скажем если мы возьмем не одну войну и мира ацилут книжную полку до то время ее суммарной обработки на многих я дрых будет вот такой то есть это не речь не про пылинки тогда непонятно почему скорее не происходит потому что если у нас каждый запрос обрабатывается отдельно да то ускорение мы должны просто получить до очень хороший вопрос большое спасибо дело в том что я хотел это включить доклад думал что мне не хватит времени смотрите в чем проблема почему не масштабируются на ядра аллокации у нас память на самом деле хип если рассматривать все типы вместе да в принципе это структура данных распределенная структура данных с синхронизацией потому что она должна работать в многопоточности мы мы обмениваемся объектами правильно мы собираем мусор где-то синхронизация должна быть закопано о том как это это не тема этого доклада да потому что есть лучшие доклады есть фолиант конрада кокосы на 1000 страниц читайте об этом там почему именно так я показал с помощью бенчмарки как это что что вы получите если сделайте вот так если вы будете в самом методе кидаться вот так на garbage collector стрингами я показал ну я надеюсь мне удалось показать что такой код не будет масштабироваться или будет масштабироваться на ядер процессора хуже чем зеркалок код в этом был смысл здравствуйте пасибо все очень круто и я большой фанат сишарп и это прикольно на эти приходится так возвращаться может быть культ нормально смысле другой язык да очень хорошо вопрос на мапри а вы вот но представьте вы разработчик у вас вы тесно с бизнесменом сотрудничать и ну как мы например в dota пиццы да у нас реально продукт оунер может прийти и сесть с разработчиком читать код вы пишете код на сишарпе тут вы упираетесь вот как система и все дальше выйти не можете потому что вы уперлись производительность вот вы не можете вы уже уже алгоритм человечеству известной самые лучшие используется и все дальше только локации или там например дальше только вы xm принципе что вы будете делать да вы можете сделать там серверные вставки там siplus плюсе обычно делать здесь можно вызвать вообще другой процесс и там написать кусочек да мы можем сделать ну можно написать микросферы вот так и делаем кстати мы пишем о сервисе в кубе рн с игоряном разворачиваем но здесь хотелось показать что в принципе вот этот вот этот барьер да он сдвинуть сейчас за счет того что в принципе уже теперь все шар этот сишарп не медленнее чем сидом это вообще абсурд говорить о скорости языка до законе от скорости скорее всей к системе си sharp в ней теперь можно быстро вот собственно суть была в чем спасибо за такую историю у меня есть вопрос насколько усложнилась разработка для непосредственно разработчика как я не понял ответа на этот вопрос насколько усложнилась когда мы теперь хотим работать zero locations она сильно усложнилась вам как минимум нужны конрада кокосов просит но грубо говоря overhead который получили работе с этим zero локейшн он покрыл оптимизацию я понял если говорить об его x и это вообще экспериментальная такая вещь да я хотелось просто показать что так можно было тоже конечно я был то есть честно не стал бы в продакшене у прям сейчас делать трём или даже в люлю string я бы каким-то обошелся например вот этим вот в или stringbuilder ом до который говорил станислав предыдущем докладе чем-то таким более легковесным мне хотелось показать что вот есть кот совсем плохой до заволок но есть в лоб решать да трой формат outward аму кошмар есть код на стрим бил бери я сделал интерфейс в принципе точнее oh well as them by лари тоже есть который в принципе разработчики могут писать дальше я надеюсь тоже я пытался показать что можно делать for each можно сделать итератор можно даже линки сделать это тема для отдельного доклада очень сложность дизайне такой pr вот для ленку который будет на валютой пах работать и какие-то техники показал эту с делегаты которые принимают стоит например код конечно же усложняется не бывает так что вот ничего не усложнилась всегда чуть-чуть стало тяжелее опять же dd взять хотя бы просто drink для нужд ринга который теперь надо думать это уже немалый концерна самом деле это нужно вот представьте раньше мы писали но там string и string сколько угодно ходит 2 гигабайта а теперь мне нужно встать пойти поговорить дружище бизнеса умер там ну я не знаю там продукт оунер до аж какой длины string кучу ну имя может какое длинным быть aunty такой говорит ну вася иванов то генерал могу так у к системам ва за банга у нас не будет такого длинного strenx'а у нас там у 16 хватит да и все в принципе норм сделай 16 окей согласился с бизнесом вот но видите уже сколько действий пришлось сделать чтобы просто длину стринги определить а это первое что придется сделать потому что вы 100 колок как вы будете с этим работать нет это не из разряда экспериментов то что касается логирование это очень даже актуально когда вы лагер уйти экономики не пытайтесь джейсон весь вывалить все что было прям туда влог нет делайте это прям вот вот эта вещь это реальные производственные инциденты это профилирование которое выявило дырки в happy boom фильтр это реально у нас работает это нам срезала по 700 мегабайт 3 реплик авторизация тэн секционного сервиса проверка паролей это крошечный микро сервис который должен 200 мегабайт занимать а тут он занимает гигабайт почему память там она не течет она вначале старта приложений вытекло и все это экономит на деньгах потому что это но до их надо покупать в облаке нас разработчики знают вас туда пиццы разработчики знают о том сколько стоит железом который будет запускать у нас те кто на груше на тестирование занимался они придут скажет вас ты знаешь память-то течет среды ты растут вот все это все как бы на реальных событиях скажем так кроме вы икса икс это вот ну это такая заготовочка и последний вопрос молодой человек да здравствуйте спасибо так вот интересный вопрос такой когда в какой момент вы начинаете усложнить работу со стрингами то есть в любом случае проще всего начать с интуитивным а чего тогда вот мы сделали функционал затем мы начинаем его улучшать оптимизировать вот когда как и да какой поры где та грань где восстановитесь я уже говорил даже тут код на ленку на пишет разработчик сразу который понимает суть проблемы алгоритмически сложности там и такие вещи базовые поэтому в принципе мы с ним какой-то one of code сделаете лично я начинаю сразу я не верю в прежде временные оптимизации простите их нету когда речь касается garbage collector а вот это вот слово она испортилась и очень многих сишарп разработчиков преждевременная оптимизация а когда нам начинать оптимизирует ребята научитесь писать оптимальной код и сразу его пишите быть для меня не существует этого вопроса понимаете я не могу написать н квадрат код там где нужен от единицы код ну я могу да если я ошибся но если я умею я буду сразу его писать ну я не знаю это может быть это мой недостаток кстати вот я перфекционист я буду делать я вижу что там аллокаций я сразу к сожалению что у меня были открытую в карьере проблем поэтому ну да пока я не научился сразу писать быстро еще спасибо ну че за вопросы георгий вам надо выбрать самое нам надо менять самый мечу вопрос кому достанется подарок самый хороший вопрос ну мне понравился вопрос про про то когда нужно начинать думать об оптимизации хотя последний до"
}