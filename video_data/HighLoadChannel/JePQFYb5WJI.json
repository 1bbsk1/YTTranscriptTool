{
  "video_id": "JePQFYb5WJI",
  "channel": "HighLoadChannel",
  "title": "Чистая архитектура. Погружение / Евгений Мацюк (Kaspersky Lab), Александр Блинов (REDMADROBOT)",
  "views": 16019,
  "duration": 3058,
  "published": "2017-06-28T07:13:02-07:00",
  "text": "Итак будем начинать на самом деле у нас время уже началось ребят Всем привет Меня зовут Евгений мацук я представляю компанию лаборатория Касперского и сегодня мы продолжим тренд который наметился в этом зале здесь в основном были доклады про архитектуру и сначала были доклады про архитектуру микросервисов хайповую вещь в бэнде А сейчас мы с вами поговорим о наверно не менее хайповые вещи в мобильной разработке это чиста архитектура Окей Ребята а кто вообще вот хотя бы краюшка муха слышал что такое вот ну про чистую архитектуру Ага Так а кто применяют вот эти принципы у себя в проде Понятно Ну нормально а кто вообще здесь мобильный разработчик Ну это они мобильные Получается кто сколько вас Ребят а откуда вы вообще что пришли то название понравилось отлично но на самом деле как бы архитектура Да она применима ко многому чему вот а поэтому Давайте с вами начнём наверное первый вопрос для многих это будет почему вот чисто архитектура сейчас ну такой хайпят довольно-таки простой чисто архитектура позволяет вам ваше приложение разделять вертикальное и горизонтально на некото такие модули которые у вас изолированы тестируемые и легко подменяет жизни вы сидите вечером там спокойно ходите никого не трогаете жизнь хороша и к вам прибегает продук owner с кровавыми глазами говорит всё всё пропало Воронки падают туда-сюда нужно срочно там вводить вам оффлайн режим в приложение Вот вы скажете такому продукто нуно то что всё что о нём думаете в этот момент но нужно внедрять и с если у вас приложение по чисто архитектуре написано да вы просто поменяете нижние модули и всё у вас работает прибегает дизайнер говорит нужно срочно там переве тать половину экранов вы такие Ну конечно же скажете ему тоже что вы о нём думаете но поменяете там верхние модули ваши остальные части не трогайте и то есть такие фундаментальные вещи как редизайн да поде офлайн режима они не потребуют от вас переписывания всего приложения и это на самом деле очень круто но сразу же логично вопрос как бы а что будет завтра Да вот с чистой архитектурой ведь не только лишь каждый может заглядывать завтрашний день и никто не исключает что завтра на конференциях поднимется Да какая-нибудь новая хайповая тема скажет вот это новая архитектура это круто а чисто архитектура как бы ну ерунда ребят и чтобы ответить на данный вопрос я начну с небольшой предыстории вообще появления данного доклада в прошлом году на площадке анфа и на площадке моса Я выступал с докладом пишем тестируемый код где как раз рассказывал про то вот как писать вот используя вот эти подходы да то есть Нам необходимо внедрить фичу Как там разделить на слои как их покрывать тестами и прочее прочее и что сразу после докладов что немного Том было много вопросов довольно-таки широкого спектра начиная от каких-либо нюансов А и заканчивая такими концептуальными вещами как что делать вещами Да как к примеру У меня есть Вот такой-то пример такая-то задача Как мне её реализовать в чистой архитектуре и появилась идея организовать некоторый такой доклад продолжение Поэтому в январе появился вот манифест архитектурный боли статья на хабре где я призывал всех делиться болью Да вот архитектурной где каждый мог рассказать про свой опыт и на этой волне возник Telegram чатик Android архитектуры А сейчас этот чатик уже 5 месяцев там уже более тысячи разработчиков практически каждый день там были сотни и сотни сообщений обсуждения бесконечные с самого разного Спектра и каждый мог прийти спросить вот мне необходимо реализовать такую вот штуку да Вот как вот её сделать вот в чистой архитектуре и самый главный вывод который можно сделать за вот всё время существования этого чати что чистая архитектура Она реально тащит она действительно делает ваше приложение Лучше вы можете делать его быстрее и это здорово поэтому сегодняшний наш Саши доклад это будет некоторый такой срез тех обсуждений которые мы там ведём то есть начнём мы с теории немножко погрузимся рассмотрим некоторые юсм будет часть рассмотрим реальные жизненные кейсы Да и как они ложатся в чистую архитектуру и наконец самое классное - это рецепт перехода любого вашего по сути приложения на чистую архитектуру этот подход опробован лично Сашей в роботе уже много приложение переведено поэтому действительно живой рецепт Окей ребят начнём сразу же чисто архитектура в теории нюансах классическое Да начало вообще любой лекции о чистой архитектуре вот эта картина а и я думаю каждый из вас Кто первый раз вот видел эту картинку и пытался осмыслить её и перевести на своё приложение вот он мог немножко Улетать в космос потому что Ну сначала действительно думаешь что что тут вообще но не всё так сложно вот Как вы считаете вообще вот на этой картинке что вы вот в первую очередь видите зала выкрики ребят что в первую очередь видите ру Круг слои во слои правильно на самом деле самое главное что вы здесь видите это слои То есть у вас приложение разделяется на слои внутри ваши бизнес логика Да ти кейсы дальше ещё слой контроллеров презентов и дальше уже там UI Web и прочее и самое ещё главное что внешние слои знают о внутренних но внутренние не знают о внешних это немножко тоже так сначала вводит такой ступор небольшой но давайте переведём это всё на язык Андроидах Вот видите внутренний Круг en Да запомнили его и вот он это у нас entities внизу entities в Android мире - это просто вашей бизнес-модели данных То есть например у вас новостное приложение и вашей бизнес-модели здесь будет новость категория вот вот это всё далее У нас идут кейсы ше правило написания кейсов - это если ваш юзкейс выражает бизнес логику одним простым предложением То есть например кейс О - это добавить платёжку ке 2 удалить платёжку ке 3 - редактировать платёжку всё понятно и Сначала мы в Андроиде использовали именно кейсы а то есть каждый юзкейс - это класс который лезут какую-то вот такую бизнес логику Но это немножко такой получается Bo plate код если у вас сложное приложение Кроме того м Когда у вас возникает ситуация что один зависит от второго от третьего Вам их как-то надо объединять и эти объединения они получаются Ну не совсем как бы красивыми поэтому появился интерак Тор канонического определения вообще интерак Тора так такого нет мы примеру приняли что интерак - это некоторый такой кейс фича фасад То есть он под собой объединяет кейсы конкретной фичи в данном случае так как у нас зде кейс удалить пжку ЖКУ то это будет interactor payments собственно это будет публичный класс где каждый публичный метод - это конкретно кейс О'кей вот у нас интерак и вот это два наших э внутренних к слоя от дядюшки Боба далее это вот наша домейн логика далее У этой бизнес логики Да к ней имеют доступ а получается м два внешних Круга раз два Data Фло определённых первый dataflow - это у нас UI Да через vient они вот общаются и имеют доступ к бизнес логике второй Фло - это база данных интернет прочее это всё дата уровень и вот они общатся то есть вот до ваша дой И вот она с Да UI вот у вас DF какие здесь можно внести коррективы первое что по ню вот репозиторий на самом деле относится полностью Да Интер репозитория относятся к бизнес-кейс то есть о своей Ну то есть о бизнес-кейс действительно здесь получается консистентность в том плане что бизнес бизнес логика ни о ком ничего не знает но они знают и второй момент видите здесь у нас есть локация контакты в Андроиде например локацию контакты мы получаем с помощью там специальных классов и часто вопросы да А где должны находиться в схеме а Андроидов ские классы которые отвечают за получение подобной информации данных Но самое главное что это данные и собственно они должны быть сокрыты репозиторием а интерфейсом репозитория потому что теоретически те же контакты мы можем получать не с телефона А например с сервера либо как-то нам их надо синхронизировать О'кей а далее Как правильно расположить файлы по пакетам уже пошли нюансы а по чистой архитектуре да то есть мы с вами рассмотрели слои Да мы с вами рассмотрели вот эту структуру и как же вот мы начинаем писать приложение как у нас всё должно быть расположено по пакетам мы придерживаемся гибридной модели то есть мы сначала разбиваем по слоям а потом по фича то есть вот здесь у нас по слоям presentation domain repository Data и Di - это depend injection то есть где мы связываем эти все наши классы Далее в entation а он не хочет что-то да вот в entation уже дали у нас разделение по фича операции И платёжки что же такое вот сейчас момент вот операции платёжки внутри них снова по слоям VI презен тоже самое для дой репозитории в Data У нас например уже разделение по источником получения данных Network db Man ничего сложного Как быть жизненным циклом в Андроиде на самом деле есть такая Боль это жизненный цикл и эта боль она распадается на две части это убийство активити при той же вашей переориентации и убийство вообще вашего приложения тире процесс если с убийством уже более-менее сено ироски класс использовать для обработки данной ситуации типа лоров либо использовать подходы Гугла которые они представили на 17 Кстати кто смотрел немного Ну в общем да они представили свои определённые подходы Где вы можете их брать и использовать и обрабатывать вот убийство активити можете использовать сторонние фреймворки типа библиотеки Мокси вче СВ задаче Потому что когда у вас приложение в бэкграундер и восстановление идёт тоже там пример у вас был первый экран второй третий четвёртый да И когда у вас грохнуло приложение у вас восстановится как бы четвёртый экран а первый второй третий они будут восстанавливаться Если вы будете на них переходить Если у вас на Первом экране грузилось что-то важное то вот на четвёртом экране если он восстанавливается Вы должны предусмотреть что у вас может быть что-то важное не подгрудной вот данной проблемы - это просто не замечать её Ну убивается процесс да и всё Бог с ним далее взаимодействие экранов по классической чистой архитектуре на самом деле взаимодействие экранов никак не прописываться потому что ну Прай какой там UI но у нас на экранах очень много что завязано и поэтому тоже взаимодействие должны как-то его обрабатывать по взаимодействие между экранов понимается навигация и передача данных между экранами собственно навигацию нам лучше реализовывать через роутер а передачу данных через модель в mwp давайте я раскрою каждой из этих понятий что она означает роутер роутер - это специальная сущность которая отвечает чисто за вопросы навигации то есть вопросы навигации они довольно-таки важные и вот ответственность эту размазать между слоями её ну не очень хорошо получается Особенно если навигация сложная и вот за это всё дело отвечает роутер который предоставляет понятные IP типа navigate to такой-то экран Back to Finish Chain и инжектится он обычно в презентер в редких случаях может в интерак Тор вот Саша кстати про этот случай один и расскажет а взаимодействие через модель передачу данных Если у вас есть два экрана и с одного экрана нужно передать информацию на другой экран то лучше всего это делать через модель mvp mvp - это Mod View pres да то есть модель - Это всё что ниже презен То есть это может быть интерак репозиторий не суть и схема выглядит предельно простая то есть презентер оди на Первом экране что-то вот кладёт в модель потом стартует второй экран и второй экран с модели эти данные забирает и отображает их на вьюшки 2 при этом как бы два экрана друг о друге вообще ничего не знают и используя такой подход как бы них проблем со взаимодействием между экрана не будет далее вот частый вопрос Это можно ли в одну из фич выкинуть один из слоёв Потому что если у вас экран например просто что-то загрузить в сети и Показать на экране то на самом деле хочется например не использовать интерак потому что ну он там ну какая там бизнес логика там её особо нет но мы придерживаемся консистентность лучше везде у вас будет единообразие И если у вас вдруг там появится бизнес логика и так далее то у вас уже то вам не надо ничего рефакторинг их использовать в качестве Di вам не обязательно использовать dager Вы можете использовать Ну хоть сами руками написать весь этот Di а RX Java просто облегчает вам жизнь позволяет вам абстрагироваться от вопросов многопоточности а но при этом RX Java её использование освобождает вас от необходимости знаний многопоточности И это всё по первой части то есть мы рассмотрели немножко теоретические теоретические аспекты небольшие нюансы теперь как бы жизненные кейсы Да вот кейсы которые встречаются которые обсуждались в чатике и к чему мы там пришли а к примеру наше решение которое мы представим Мы не претендуем на абсолютность что вот только вот так вот делайте мы просто предлагаем варианты ваше дело уже использовать не использовать надеюсь что мы просто сможем А в необходимые для вас там задачи Да натолкнули интересное решение Итак первый кейс рассмотрим это визард но я думаю визард каждый знает что это такое то есть это Вы установили приложение первый раз заходите и там какая-нибудь вспомогательная информация экран информации там введи эсэмэску Отправь её туда-то Продай душу дьяволу ещё прочее и цель всех этих экранов Да она простая зарегистрировать вас в приложение но какие у нас тут могут быть исходные данные во-первых что здесь как бы много простых экранов решающих одну общую задачу то есть классический дизайн Android приложений Ну вообще мобильных приложений Какой у вас есть экран да Он решает свой скоп каких-то задач переходите на другой экран Он решает свой скоп задач и все экраны ну более-менее в основном они независимы друг от друга А тут как бы много таких простых экранов которые один максимум два кейса каких-то делают и как бы они подчинены общей задаче потом э могут быть пере используемые то есть тот же экран информации Вы можете показать его в начале визар и в конце и вирв может быть много и тут вопрос заключается в том что вот у нас есть логика которая должна определять Да какой следующий шаг должен быть у визар на какой экран мы должны перейти и не совсем понятно где должна находиться эта логика и всё усложняется тем что если у вас много визар и много экранов которые пере используются вать архитектуру таким образом чтобы Вы могли А легко там создавать новые визард дополнять их экранами удалять экраны и как можно вот сделать какие у нас есть варианты можно всё отдать на откуп экраном плюс роутер То есть у вас есть экран да Он решает определённую задачу и он через роутер говорит всё Давай переходи там на этот экран либо на следующий в принципе если у вас один Wizard то такое решение вполне работает и оно нормально Но если у вас много вирв и у вас экраны и она принимает решение да На какой экран перейти и получается это не бизнес логика так таковая супер презентер тоже решение то есть у вас экраны У вас есть презентер и у вас есть некоторый такой супер презентер который решает да Что делать Куда как и проще идти Но получается что это уже ну такой не презентер получается потому что презентер он что делает он просто прослойка между ю и бизнес логикой То есть он говорит Покажи вот это и при необходимости дёргает необходимые методы Ну необходимые кейсы но здесь получается уже на презентер вешается Ну несвойственно моего задач Окей хорошо Тогда что нам делать как нам быть в этой ситуации Лучше давайте тогда для начала рассмотрим пример нам необходимо реализовать First Wizard и он из себя представляет три экрана информационный лицензионный активационный каждый экран - это например экра информации это свой как бы слоёный пирог То есть тут у нас есть вьюшка презентер интерак репозиторий и Вот такая у нас общая схема получается наверное вопрос почему Wizard interact Wizard репозитории здесь используется Дело в том что так как данные экраны они могут вообще не выполнять никаких кейсов а могут там один-два то плотить для каждого отдельный интерак отдельные репозитории Ну зачем мы просто используем как бы общий интерак репозиторий и всё нормально То есть пока по чистой архитектуре всё идёт То есть у нас слои всё нормально и вот экран информации например он выглядит вот так вот а теперь нам необходимо подумать Да как нам необходимо Аа Вот наши вот эти экраны их соединить с чем-то что будет ими управлять для начала вот посмотрим вот экран информации Да вот что он может чему-то внешнему сообщить а он может сообщить на самом деле две вещи это то что пользователь Нажал кнопку Next и пользователь решил выйти то есть здесь по сути больше ничего не происходит ничего не может то есть этот экран больше ничего не сообщит получается у нас такой интерфейс интерфейс общения универсальный интерфейс общения данного экрана с любым чем-то что отвечает за Wizard и вот через презентер Да мы этому внешнему что-то сообщаем то есть мы передаём в имплементации и к примеру по нажатию на кнопку Next мы этому внешнему передаём что о либо получается что у нас три экрана ри репозитория и у каждого репозитория свой интерфейс общения с чем-то внешним и теперь главный вопрос Да кто должен имплементировать ВС эту логику кто должен связывать эти экраны вместе И тут появляется такая новая сущность это в данном случает он содержит некоторую логику то чтобы принимать ему решение да На какой экран переходить и он содержит некоторые состояния и Давайте взглянем на код Как выглядит этот смартер то есть он имплементировать вот эти три интерфейса и собственно примеру в inf Wizard Next он такой ага Окей я пометил у себя состояние и через который рассматривали во взаимодействи экранов говори переходи на следующий экран тоже самое с если пользователь выходит с информационного экрана то всё viser прекращается Мы через роутер говорим всё Finish chin заканчиваю всё А таким образом здесь появляется новая вот эта сущность Smart роутер она если по уровню смотреть находится где-то на уровне презентер и интерак Тора Но это и не презентер и не интерак Тор Это несколько такая в стороне специальная сущность для разруливает собственно на этом У меня всё далее продолжит Саша спасибо Так принимаем эстафету продолжим дальше следующий кейс который мы рассмотрим это работа со списком очень часто встречаются задачи Когда нам нужно так я пришёл назад нет вперёд отлично разобрались Да так поехали значит задача следующая нам нужно загрузить данные постранично и их довольно много то есть мы не можем загрузить одним запросом и тут кажется задача уже давно решена Существует множество решений реализованных Инне инженерами из Индии где есть Волшебный и он умеет не только загрузить данные но ещё и там отобразить Прогресс показать ошибку и всё вроде бы хорошо но когда дело доходит до крайних ситуаци реально возникают проблемы например Когда у нас ничего не загрузилось и тут Сначала мы должны взять и показать экран заглушку и она уже выходит за пределы нашего Rec тогда у нас нужно возобновить какой-то из промежуточных запросов То есть к примеру он упал м сначала отобразить заглушку снизу и потом при нажатии на неё нажать на кнопочку и всё подгрузить когда мы хотим данные перегрузить полностью используем СШ в некоторых ситуациях если мы работаем с чатом то у нас могут возникнуть новые данные и мы хотим показать снизу плашку и потом по ней при нажатии проскролить вниз Иногда у нас триггером перезагрузки данных может являться нечто из например геолокация и в этом случае мы вообще Выходим из нашего Rec viw и это логика совсем сбоку давайте рассмотрим как это всё реализовать У нас есть данные которые хранятся на сервере мы загружаем этот список добавляем снизу индикатор прогресса и отправляем в наш адаптер когда мы проскролить экран достаточно далеко то мы данные загружаем в некоторых ета наме с чатами то нам нужно уметь загружать в обе стороны и тогда когда мы будем дочи экран донизу то мы будем загружать элементы вот при этом окно Мы хотим оставить фиксированное чтобы не грузить наш ресайклер Ну соответственно обратная ситуация когда мы загружаем вверх Давайте посмотрим как будет устроена на Значит первое - это непосредственно сам список вторая часть это уже обновление геолокации обычны там сй я говорю то что Ребята у нас дальше будет немного кода на котлине вот будете осторожны но после последнего уже котлин стал официальным языком программирования поэтому законом не разрешено Пиши на кот хо Итак порите г трактор он включает в себе панар панар - это будет сердце системы у панара несколько методов значит это загрузить предыдущую страницу загрузить Следующую страницу перезагрузить полностью пона будет у нас типизированный он типизированного мы будем отправлять наверх плюс conditions в нашем случае это будет имен геолокация по которой мы будем осуществлять загруз списка Итак как будет выглядеть то что мы отправляем наверх рож у нас торчит который отправляет наверх State И на самом деле это просто обёртка над списком вот плюс Она имеет некоторые флешки флешки о том загрузились ли у нас данные полностью есть ли у нас ещё они на сервере достигли ли мы предела плюс некоторый ое пойдёт наверх наверх из бизнес логики уходит интерфейс интерак тут у нас уже он не параметризованный и заметьте у него есть методы просто Загрузи дальше Загрузи предыдущее и их будет наш дёргать наш когда мы до грузим до конца полностью весь стейт Мы запихнули в наш поги натор тут надо отметить то что поги мы пишем один раз и потом его в дальнейшем Вот но на самом деле ВС Так просто и в реальной ситуации У нас будет куча осложнений Например у нас картинки не одинаковые а они просто различные и Google Maps Они не умеют работать с гладом то есть мы не можем также закинуть картинку сказать а ну-ка Загрузи севака там обработай вот Причём я сказал картинки уже находятся на серваке поэтому их нужно скачивать и вообще их может быть довольно много а если мы возьмём все наши организации с картинками и добавим на карту то у нас весь интерфейс будет тормозить потому что Go карта она тоже не Волшебная Давайте разбираться по очереди что с этим делать Итак логотипы которые мы хотим отобразить на картах они бывают вполне нормальные квадратные быт вертикальные бывают горизонтальные вообще их очень-очень много и Прим Некоторые из них просто огромные А некоторые громадные ещ и в формате и картинка весит Ну намного больше чем и вот нам нужно загрузить вот такой маленький маркер И на самом деле вот в такую-то вот часть и тут мы понимаем тофт что-то делать и наша Фло начнётся далеко до того как пользователь запустит приложение оно начнётся набил сервере там Мы скачиваем картинки обрезаем их переводим в формат GP делаем их квадратными далее Когда уже пользователь запускает приложение мы распаковываем архив придем список организаций и начинаем постепенно из картинок в формате GP нарезать наши маркеры маркеры помните они были именно пинами на карте в формате png давайте рассмотрим это фу Здесь также будет две части первая часть стартует непосредственно когда мы запускаем приложение на сше вторая часть - это уже работа с картой когда пользователь заходит на экран карты Итак рассмотрим схему работы нам будет помогать хемо из с workflow и будет на ней такой зелёный индикатор о будет показывать Где мы находимся в данный момент также будет индикатор в интерак Торе он будет показывать то что в интерак Торе идёт такая либо работа Итак мы стартанул наше приложение далее если у нас архив не был до этого распакованный списка и вот с этого момента начинаем конвертацию маркеров при этом заметьте мы ушли уже с полша это всё делается в бэкграундер дает на экран с карты после этого экран появляется он коннектится к общему интерак тору который занимается конвертацией картинок и забирает те картинки которые уже готовы при этом на карте мы отобразим соотвественно все организации Вот но некоторые картинки у которых е не готовы маркеры там будет маке и для пользователя это будет выглядеть как работает тот же самый й далее мы будем потихоньку конверти картинки процесс довольно долгий и например по 20 штук отправлять их наверх выглядит всё волшебно Мы ещё не решили одну проблему как быть с тем что у нас организации много помните на карта тормозила изначально мы будем в итератор передавать именно те координаты в которых мы сейчас находимся окошко и по ним будем грузить соответственно только нужные маркеры если нас будет ещё больше тормозить мы туда отправим прямо иконку кластера Таким образом мы победили довольно сложную задачу и тут надо понимать то что мы получили такое хорошее распределение нагрузки то есть часть мы вынесли именно на бисер Вер часть у нас была в фоне постепенно и она не происходила когда пользователь открывал экран с картой и тут у нас ю не тормозило мы не висели на спл очень долго и тут как раз нужно отметить то что у нас хорошее распределение ответственности между сями карта у нас отображает uui бизне слойка рулит что нам показать Итак переходим к следующему кейсу это последний из кейсов это авторизованная зона Вот и этот кейс с которым сталкивается Ну пожалуй каждый разработчик рано или поздно что он собой представляет У нас есть некоторый токен с котором мы можем ходить в авторизованного получаем его После логина далее этот Кен может действовать какое-то определённое количество часов после этого он проха ет и установить его можем с помощью либо например какой-нибудь Захарова парыгин пароль Как это всё у нас работает у нас есть запросы в авторизованного мы имеем 41 ошибку далее все запросы авторизованные зоны будут приостановлены при этом запрос неври зо льном порядке После этого мы идём перелоги с помощью рефреш токена и все запросы далее будут выполняться нормально Итак давайте теперь это опишем уже более формально за это у нас будет отвечать АХО Какие вообще у него ответственности во-первых он должен хранить должен иметь им подписывать запросы и при необходимости блокировать Севы запросы плюс восстановление Фреш токена иди авторизация если она нужна на сервере смотрим какие у нас зависимости возникли значит в зависимости по первому пункту наш ахор зависит от Режа вот далее он должен зависеть причём ахор должен иметь восстанавливать токен по рефреш токену значит он будет зависеть ещё и от Ау репозитория посмотрим на слоях как это отображается мы тут видим то что всё уложились довольно нормально кроме одной зависимости вот этой вот и у нас получается сущность из Нижнего слоя знает сущности верхнего слоя избавимся от неё и добавим отдельную сущность House Network с помощью неё мы будем уметь восстанавливать токен по рефреш токену То есть у него будет отдельная например ретрофит клиент итак уже непосредственно схема работ тут мы ещё больше усложнили например когда мы работаем с банковским приложением для того чтобы у нас всё было довольно секьюр у нас токен хранится 3 минуты Вот и после этого у нас отображается экран с пином значит пользователь вводит пин И после этого может продолжить exp Итак FL значит непосредственно то что работает с пином Вот и вторая часть - это тот экран на котором у нас может возникнуть ситуация с отображением Пина Итак у нас про и об этом мы оща наш нкр хороше он должен отобразить экран с пином но интерак же нет привязанного VI это как раз именно тот случай котором говорил жене когда у нас роутинг опускается глубже в бизнес логику в данном случае мы роутер получаем из текущего открытого экрана и роутер говорит отобрази мне экран с пином после этого пользователь вводит просто можем убрать Гран спином и продолжить эрис пользователя какие выводы мы имеем довольно чистое решение для такой сквозной и сложной логики как Туха токена и экран Пина роутинг может опускаться реально немножко глубже на уровень бизнес логики и у нас со ответственность распределена чётко по своя Давайте перейдём уже к более веселой части как перейти на чистую архитектуру и когда вот хорошая ситуация когда вы приходите и у вас проект с нуля вы сразу же накидывать чистую архитектуру вот всё это сказки Вот и в реальной жизни У нас есть уже отстроенный такой большой проект с кучей и нам нужно уже его реактори и понимать что переписываться ни при каких условиях потому что бизнес не любит ждать и уйти в полный редизайн на 3 месяца никто не позволит вот даже если у нас будет редизайн то он будет происходить одновременно с какими-то фичами на старом приложении и тут рецепт Значит предусловие у нас есть несколько экранов которые такие довольно монолитные хардкорные активити вот которые умеют всё делать Значит первое что мы делаем Это разделяем наши активити фрагменты кастомной вьюшки на View prenter и тут Обратите внимание то что зона рефакторинга будет не очень большая то есть мы сможем менять именно по экранной по очереди Сначала один экран потом другой третий мы не переписываем полностью приложение L"
}