{
  "video_id": "NCOf9az_2Rk",
  "channel": "HighLoadChannel",
  "title": "JIT компиляция в виртуальной машине Java / Алексей Рагозин (Deutsche Bank)",
  "views": 640,
  "duration": 2599,
  "published": "2017-04-22T14:45:58-07:00",
  "text": "добрый день сейчас нас ждет полтора в глубины g в.м. и начнем мы с проблемы jit компиляции на самом деле вот не знаю то что он доклад называется джек джек компиляция виртуальной машины java я где-то половину времени потрачу на то чтобы объяснить какие задачи вообще решает компиляция тоже на самом деле это например совсем не то и не совсем не те проблемы которые решают ahead of time компиляции и соответственно совершенно другие методы для этого используются соответственно jit компиляция наиболее хорошо себя зарекомендовала с такими динамическими но я считаю я в динамическим языком кто-то считает ее не настолько динамическим но тем не менее и здесь у нас есть такие проблемы как то что все вызовы виртуальные то что в некоторых языках таких как java script там груббе питон нас данные не имеют предопределенной структуры соответственно существует два основных подхода jet компиляции это более классическая компиляция на основе методов которая продолжает идеи ahead of time классической компиляция и специфическая трассирующая компиляция об этом будет следующий мог докладе и наконец закончу я уже более глубоким рассказом про те трюки которые умеют делать с кодом на лету hotspot живем это бесплатная java моторику и так начнём с виртуальных вызвав вспомним что такое виртуальный вызов в си плюс плюс например где их очень любят потому что они медленные в объекте у нас есть некоторый указатель на таблицу виртуальных методов каждому методу соответствуют некоторые индекс в этой таблице и чтобы сделать переход код сначала должен прочитать адрес процедуры выполняющие метод из таблицы не только после этого передать управление дальше все может становиться веселее если у нас есть множественное наследование этих таблиц может быть несколько может все быть еще веселее у нас есть все плюс плюс так называемые виртуальные базовые классы не виртуальные базовые классы но это уже как бы черная магия ходу в той компилятора проблема заключается в том что в тот момент когда процессор доходит до того места где должен быть вызов виртуального метода он не знает на какой адрес памяти будет переходить управление процессор вот наши современные там 2 с половиной tragedy лицо вы и процессора это очень сложные конкретизированные машины которые могут вам выполнять за так доме несколько инструкций там до 2 по моему современные умею даже на одном потоке но выполнение одной инструкция занимает десятки тактов сказать что проиллюстрировать глубину проблемы я здесь привел цену на цену это не длина конвейера это величина которая требует требуют это время которую нужно процессору чтобы откатить конвейер при неправильно предсказанном переходе это на самом деле очень близко к той величине которую которую тому простую конвейера которая вызывает факт того что мы не знаем какой адрес выполнение будет следующим соответственно цифра это для разных архитектур достаточно большие умножив на тактовую частоту получается что-то сопоставимое с походом в кэш второго уровня но все но как бы это то цена которую приходится платить практически в каждой строчке кода то что мы постоянно что-то вызываем поэтому это аккумулируется и становится проблемой соответственно помимо того что у нас есть простой конвейера у нас еще и само по себе обращение в память и если она проходит мимо каша она тоже может существенную величину вкладывать скажем проще как с все-таки разогревается простой конвейере к сожалению остается всегда для тех языков которые бы не имеют статической структуру типов все еще хуже потому что если для языков типа java проблема только при вызове методов там структура данных в памяти и фиксированной по крайней мере здесь компилятор сразу может вставлять правильные смещение так далее то в языках типа java-script руби питона там собственно говоря и данные хранится все же хранился время хэш-таблицы то есть обращение к полю чего-либо это поиск хэш-таблица что включает себя арифметическую операцию операцию с памятью у сложную операцию снова операцию вспомнить в общем это довольно тяжело и опять же может приводить простоем конвейер из за того что у нас есть условия есть части не из памяти арифметические операции тоже не очень хорошо потому что как бы не всегда есть свободное место в этом модуле процессора который занимается возвращаясь проблемы jet компилятора из хотя вот из того что я сказал то что проблема не в том что мы интерпретируем код проблема в том что у нас код сам по себе менее предсказуем чем код которые создают статические статически компилируем языке одессит в принципе да следующий вопрос про структуру интерпретатора быстрый интерпретатор сделать достаточно просто и он будет работать очень быстро но если не будет решена проблема вот этого динамичности как бы выигрыш от него будет не очень большой собственно говоря возвращаясь к созданию интерпретатора самый простой наемный способ сделать интерпретатор по байт-кода допустим для текстовых или языков типа java script это будет по дереву абстрактного синтаксиса ну грубо говоря самый банальный подход сделать некоторые свечи вставить туда инструкция switch приведет к еще созданию достаточно большого количества условий в коде еще простоем конвейерах ну отвечай избавиться не сложно например в hotspot живые интерпретатор байт-кода сделан следующим образом всего в java существует там около 200 инструкций байт-кода не так много на каждую из них на ассемблере написано процедуру которая соответствует и цикл интерпретатора выглядит следующим образом читаем байт из памяти поэтому байту находим адрес процедуры делаем jump на эту процедуру процедуры проходят в конце выполнения делает jump на снова она начала цикла интерпретации то есть за счет этого мы избавляемся от необходимости создавать кадры стека каждый раз выполняя байт инструкцию мы используем простые команды jump которые не нарушают не нарушают механизм привет выборки центрального проем то есть в тот момент когда на конвейере процессор atom заканчиваются выполнение инструкций предыдущий инструкции байт-кода он уже знает что следующий переход будет снова на начало вот этого цикла он уже может поставить в очередь к модулю доступа в памяти запроса на чтение соответствующих ячейку памяти опять же таблица переходов она очень хорошо помещается в кэш первого уровня с точки зрения вот именно выполнения логике такой интерпретатор будет очень быстрый проблема в том что останется все равно проблему виртуальных вызов поэтому jit компиляция требует немножко более интеллектуального подхода и основная ее задача как раз по возможности и склон исходя из той информации которая доступна компилятору в контексте выполнения программы убрать неопределенность заменить виртуальные вызовы конкретными вызовами расставить по возможности адреса процедур непосредственно в код братьев из всяких дополнительных таблиц соответственно активно развиваются два подхода ну прежде всего для языков типа java достаточно хорошо подходит способ когда мы просто компилируем отдельным методы там схемы компиляции схожа с компиляция в языках типа си си плюс плюс но плюс используется еще дополнительные ухищрения вроде анализа поведения кода в реальном времени и соответственно оптимизации которые устраняют некоторую неопределенность вызовов есть принципиально другой подход который начал развиваться именно с такими динамическим языками это трассирующая компиляция смысл ее заключается при длительно следующем вот у нас есть некоторый код которые если часто выполняется вместо того чтобы постоянно им прийти интерпретировать мы можем просто записать те операции которые выполняют интерпретатор и скомпилировать вот этот trace и просто выполнять именно его звучит не очень понятно я надеюсь с дальше будет чуть более понятно где применяются те или иные подходы компиляция методов это прежде всего жалеем виртуальная машина вияет тоже использует комбинацию методов и как бы последней версии кабели jit компиляторов для java скрипта в фаерфоксе они тоже перешли на а ну там конечно все немножко более сложную но в целом они уйдут сторону компиляции именно методов где хорошо себя проявила трассирующая компиляция ну прежде всего это flash это flash и в чем прелесть трассирующий компиляции для сам с точки зрения выше выше это у нас какие-то ролики это какие-то циклы которые там постоянно делают одно и то же по большому счету и собственно говоря вот весь этот цикл который делает одно и то же там 30 раз в секунду чтобы прорисовать пририсовать очередной кадр он очень хорошо атрофируются его можно эффективно перекомпилировать и как бы что важно для трассирующий компиляции чтобы вот все условия ветвлений они каждый раз на каждом проходе вы давали 1 и те же результаты то есть трасса она линейна и в ней нет ветвление как только мы доходим до какого-то условия в коде которые дает нам отправляет нас в ту сторону который не записано в трассе то все при выполнении трассы прекращается и управление снова переводится в режим интерпретация есть дальше схемы которые позволяют из этих трасс строить какие-то деревья но в любом случае переход от одной трассах другой или переход из трассы в режим интерпретации это все дорогие операции но вот для таких языков тип flash которые как раз в них очень много горячих циклов и поэтому трассировка там работает очень хорошо соответственно виртуальная машина слыша его аджит компилятор он был передан в firefox там на его основе сделали соответствующий jit компилятор для java скрипта no trace monkey но для java скрипта такой подход не очень хорошо прижился почему потому что в java скрипте у нас очень много года который выполняется один раз то есть бесполезный компилировать его нам просто один раз нормально проинтерпретировать или быстро скомпилировать и выполнить трассирующий компиляции она плоха тем что она очень большой она очень увеличивает стоимость интерпретации потому что интерпретатор должен помимо того что выполнять команды еще записывать трасса пи пи это реализация питона на питоне очень интересный проект который бы помимо того что реализует питон на питоне он в принципе предоставляет такой фреймворк у них есть подмножество питона который поддерживает вот их не убежит компиляцию р-р python если написать интерпретатор для любого вашего языка на rp таня и запустить его вот пеппи то ваш язык автоматически получит трассирующий компиляцию за счёт того что просто там есть соответствующие вызовы которые позволяют трассировать то что делает этот питон но этот проект чисто академический он как бы коммерческой поддержки никакой не умеет поэтому людям интересно они этим занимаются с точки зрения таких проектов которые имеют коммерческую поддержку сейчас трассирующий jet развивается в уо уо опять же это язык который в том числе очень много используется в разработчикам игр них в чем-то сходные задачи его в играх там много циклов которые делают одно и то же которые делают сложные и имеет достаточно богатый набор математических функций они то есть они можно писать сложную математику и это сложная математика она очень здорово оптимизируется в ходе компиляции и поэтому там трассировка дает серьезный выигрыш более подробно о трассирующий компиляции трассе ваш компилятор это всегда интерпретатор плюс вот такая какой то механизм компиляции интерпретатор он ведет vogue рование он так или иначе отслеживает пути выполнения погоду и когда видит что один и тот же путь по коду он повторяется несколько раз он может попробовать вот эту вот трассу записать и скомпилировать соответственно когда он идет по вот этой трассе он как везде где есть условные переходы в трассе появляется гарт то есть там не будет условного перехода там будет проверка если она выполняется идем дальше по трассе если она не выполняется тогда трасса прекращается продолжается интерпретация там с какой-то точки либо происходит переход на другую тарасу если существует механизм который способен строить дерево этих трасс соответственно вот это логирование она здорова и нагружает интерпретатор но вы если нам удается идентифицировать вот эти вот горячие цикл то она позволяет скомпилировать достаточно значительное количество кода вместе как единый блок игнорируя все цикуты с точки зрения центрального процессора то получается идеальный код там отлично работают предсказания ветвления потому что они все идут в одну сторону он может выполняться достаточно достаточно быстро там можно эффективно лоцировать регистры и так далее опять же одним из существенных факторов которые сейчас помогают развиваться в этом направлении это такая библиотека как овал в млм и очень машин это такой компилятор низкого уровня который позволяет делать серьёзная оптимизация то есть написать код который генерит про хороший машинный код это сложно это как бы надо вложить много усилий но фишка в том что эта библиотека уже существует оно используется и план своих компиляторах оно используется во многих других мест то есть это библиотека в которую люди вкладывают некоторые работает хорошо и она отлично решает вот эту задачу построение хорошо оптимизированного машинного кода по трассе и позволяет соответственно при разработке трассирующих компилятора заниматься вот именно проблемами интеграции с языком они генерации кода соответственно в при трассировке что мы получаем у нас исчезает все виртуальные вызова на пути трасса потому что как бы это то же самое что и условные переходы бы мы проверяем если там тип класса такой какой мы ожидаем тогда в коде сразу проставлен адрес если не такое переходим в режим это пытаться выполняем все вот этот поиск правильной виртуальные функции так далее отчасти это складывает проблему динамических типов хотя здесь как бы уже приходится немножко сложнее придумывать но даже вот тот поиск по хэш-таблицы как бы он сводится к следующему мы проверяем если размер хеш-таблицы там 31 если значение по индексу 7 равно нашему ключу значит читаем из ячейки 7 то есть мы исключаем из трассы условный мы исключаем из страз и те инструкции которые ожидают чтение из памяти то есть они остаются но под но процессор он достаточно хорошо спекулятивно выполняет код вперед не дожидаясь пока придут эти данные из памяти и будет проверенную суда если она окажется неверным то придется откатывать конверт процессора но в том-то весь и смысл что мы находим те трассы которые наиболее наиболее часто встречающиеся пути через алгоритм нашего кода недостатки трассировка происходит не быстро и если у нас код запускается один два раза то он просто работает сильно медленнее опять же нужно чтобы он какое-то время поработал прежде чем будет выявлено водки трассы которые пригодны для оптимизации отдельно проблема виртуальных типов не на вот в различных системах решается по-разному например вв-8 существует скрытая система строгих типов когда как комната объекты java скрипта автоматически присваивается некоторая структура памяти если он меняется уйти в динамике соответственно ему присваивается другой скрытый тип в фаерфоксе там тоже свои хитрости на эту тему вот про то как решает проблему поиска похожу лоджик я только что рассказал то есть оно просто в трассу включает сразу те условия которые соответствуют структуре этого хэша на момент записи этой трассам и соответственно за счет этого позу получает тоже неплохие результаты несколько ссылок по тем компилятором мы которых я упомянул и о плавненько переходим к тому что имеет умеет hotspot же в мвд в.м. у нас на самом деле как бы проблема только с виртуальными визу на структура объект в памяти она сама богу фиксированная но виртуальных вызовов ногу потому что в отличие от там пайтона или java скрипта на джаве любят писать все от и до не полагает что на какие-то библиотеки написанные на seo реализации полная реализация алгоритмов а учитывая что все вызовы методов виртуально это может быть не так дешево как кажется с точки зрения выполнения кода hotspot есть как я уже сказал очень быстро интерпретатор для дебага всегда используется интерпретатор то есть если вы ставите breakpoint в программе то этот метод будет автоматически до компилирование сон был скомпилированные выполняться режиме интерпретации иногда очень четко на производительности ощущается даже если ваш быть понят никогда не срабатывает в живые есть два компилятора есть быстро компилятор есть оптимизирующий компилятор которые соответственно соответственно метод может быть сначала скомпилирована одним компилятором потом перекомпилировать потом еще как-то перекомпилировать зависимости от того как меняется структура активен их классов как меняется информация о том какие методы наиболее часто вызываются в конкретных точках а кода соответственно происходит профилирование профилирование это прежде всего вот у нас есть инструкция которая вызывает метод там например лист сайт или лист get и что нам интересно это вот а какие именно методы выполняются в этой точке может оказаться так что 99 всех вызовов вот в этой точке это вызов метода get и зарей листа а другие листы туда просто не попадают и тогда можно там применить оптимизацию помимо этого hotspot умеет совершенно сумасшедшая вещь она умеет менять код который в настоящий момент выполняется то есть у вас есть некоторый метод он выполняется он вызвал другой метод то есть он остался на стыке в настоящий момент выполняется другой метод и в момент возврата java может взять подмену скомпилировать этот метод переписать стек и соответственно после того как произойдет возврат вот в этот метод он уже будет выполняться него интерпретирующих режиме авто скомпилирован им причем как бы он будет продолжать выполнять этой же точки или наоборот или он был скомпилирован jewish и кто-то в него поставил black point and раз живем его компилироваться до оптимизировал и переписала кадр стека который теперь соответствует интерпретируем коду они скомпилирована что естественно оптимизирующие компиляторы будет создавать немножко другой кадр стека это тоже очень полезная полезная на практике вещь полезная в основном для микро бенчмарков потому что они любят игнорировать разогрев а далее саммады виртуализации как я уже сказал профилирование идет для конкретных точек вызову . конкретная инструкции байт-кода в конкретном методе мы считаем куда она какие реализации она на самом деле вызывает и есть соответственно 3 классификация либо большинство вызовов идет на одну реализацию либо есть две лидирующей реализации либо как бы не понятно то туда то сюда и приходится ее оставить вернули этот вызов виртуальным соответственно если профилирование показывает что место вызова on a man аморфное либби можно тогда живым подменяет его вот при компиляции компилятор подменяет его привезли в такой конструкции если тип объекта равен конкретному классу указатель на классовом плане хранится в заголовке объекта то есть точки зрения программного кода это почитать указатель на квас из заголовка объект и сравнить его с константой если класс тот который мы ожидаем тогда непосредственно передаем управление по конкретному адресу метода реализующего этот функциональность classen иначе делаем обычно иди виртуальной dice почти из таблицу виртуальных методов соответственно вот таких iv и их может быть максимум два там делать их больше уже не эффективны с точки зрения времени выполнения но очень часто 2 более чем достаточно далее само по себе компиляция она инкрементальный и мы компилируем метод мы и ну а ним в него какие-то другие методы результате этого нас получаются новые call сайты которые как бы уже привязана ни к инструкции байт-кода в исходном методе а с инструкцией его реплики которая оказалась внутри того методы которые wosign ваню и дальше у нас может идти развитие по следующему сценарию вот у нас есть в классе collections метод индекс баяна research который сам по себе в нем есть метод get есть методы комфорту они полиморфные в классе collections и у нас есть некоторый метод который вызывает этот баян research после того как этот метод компилируется баян ресорт оказывается внутри него ну видно из кода что внутри этого метода массив по которым ведет по ведется поиск всегда будет arraylist и значение которые сравниваются всегда будут строки то есть внутри вот этого за январь иного метода call сайты get и com-порту они превращаются из полиморфных в моно морф ные и в какой-то момент живым это понимает и она может снова перекомпилировать этот метод и уже в этот раз она скорее всего включит и реализацию метода get и реализацию метода com-порту которые соответствуют строкам то есть на самом деле после такой инкрементальные компиляции мы получаем некоторые оптимизированный кусок кода который по сути очень близок к рейсу тому трассу которую получают трассирующие компиляторы просто способ его получения он принципиально другой он 100 припас modcloth пример у нас есть метод main в котором мы сразу начали крутить тяжелый цикл и сливаем решает что этот цикл достаточно тяжелый метод main стоит перекомпилировать она может это сделать когда вот внутри этого цикла будет к это вызов каждому нету brass при возврате оказывается что уже другой кадр стека уже другой код маги еще одна еще одна совершенно выносящий мозг вещь это оптимизация связаны с escape on оазис в принципе вот эти оптимизации это на самом деле тяжелое наследие молодости и и как бы того что у нас в джаве очень много классов было помечено ключевым словом синхронности они включают себя очень много ненужной синхронизации вот например такой пример у нас есть метод tostring который создаем string буфер добавляет к нему что-то возвращает строку кто как бы занимается работать животе знают что надо использовать не стриг буфер а stringbuilder потому что string буфер он синхронизированная стринги удар он не синхронизированы но как бы код который писался 10 лет назад тогда еще не простим билдера и такого кода достаточно много так что господа из она теперь господа и 40 у они считают что конечно хорошо учить всех писать правильный код но иногда стоит подкрутить jet компилятор что модуль это обходить как это обходит компилятор комбинируя метод tostring он анализирует что происходит с вокальный переменные baff и он видит что никакой другой поток эту переменную видеть не может а следовательно никаких проблем с синхронизацией с бесконечными быть не может он убедился что вот этот объект никогда не выйдет за пределы вот этого метода и со спокойной совестью удаляет весь код который связан с синхронизацией опять же само по себе синхронизация тоже в отжимаем сделано очень эффективно но все равно даже как бы самый быстрый способ синхронизации это включает себя атомарной инструкцию процессора на самом деле были быстры но тем ни менее выкинуть его вообще это идеальный вариант помимо того что escape analysis может использоваться для выкидывания ненужных синхронность блоков бы его ищут научили делать другие полезные вещи здесь у нас другой пример два метода вот методу distance приходит 22 класса то есть два объекта джаве что если этот код выполняется нормально то вызывая distance of the dance мы создадим два объекта овации ruim под них память до памяти лоцируется очень быстро это просто in crime большинстве случаев это увеличение регистра там существует 32 кого акишина буфера это все быстро много это все равно это память которую потом надо чистить которое создает нам мусор если ее не выделять вообще было бы лучше как можно пожалуйста вернуть картинку спасибо соответственно что может сделать живым при компиляции методов она опять же видит что вот эти два класса то есть она должна за январь нить не the distance после этого у него получается жирный метод и она видит что вот эти вот 2 класса они не выходят за пределы вот это вот метода каждый из этих классов содержит там под вода была что делает живым она берет выкидывает объекты вместо этого создает 4 новых локальных переменных которые используются уже дальше при компиляции этого кода таким образом эти два объекта не создаются в принципе сожалению не работает с нашим любимым stringbuilder am потому что это оптимизация работает только для скаляров то есть для тех классов которые можно привести к совокупности скалярных переменных с массивами этого вы не работает сам работал было бы и была бы еще более эффективной оптимизации может быть когда нибудь это появится помимо от того что джет компилятор может включать прямые ссылки на реализации то есть прямые ссылки на код если у нас есть например какой то статическое поле которое файлов по в принципе в создаваемые джед компилятором код он может опять же вставлять до прибыла адрес этого объекта но тут есть тонкий момент что мы знаем что объект у нас живут в куче при очистке кучи у нас объекты могут перемещаться из одного адреса памяти в другое адрес памяти соответственно с точки зрения сборщика мусора вот эти блоки коды которые создают компилятор они являются тоже объектами в которых могут быть указатели на объекты из кучи они эти указатели учитываются при расчете достижимости объектов соответственно соответственно вот это вот все интегрировано вместе за счет этого код может использовать напрямую указатели в на объекты внутри кучей в качестве заключения и рассказов про ту зачем пишут специальные компиляторы для именно джастин тайм компиляции я рассказал про оптимизации очень глубокие которые позволяют может делать hotspot живым вопрос как все это использовать на практике как писать код чтобы он был оптимальным самое правильно не думать об этом вообще при написании кода код должен быть как бы код должен быть красивой опять же с точки зрения jetta самый лучший кот это много маленьких методов каждый который из которых решает свою задачу тогда компилятор уже сам анализируя то как программа выполняется правильным образом сгруппирую ты там эти методы и применят все свои хитрые оптимизации у авиаконструкторов есть такая поговорка красиво и самолеты летают быстрее тоже самое относится и коды для java пишите красивый кот и инженеры и 40-го позаботиться о том чтобы этот код выполнялся максимально быстро на этом все можно перейти к вопросам спасибо могу рассказать пару слов про joe rocket хотя это умирающим продукт принципиальное отличие в джобсе нет быстрого интерпретатора там сразу используется their ван компилятор ну и собственного а и она не умеет делать он 100 крис placement то есть в этом по по этому показателю она немножко хуже ведет себя в банк марках но он с такой опасен такая спорная тема в принципе если код написан правильно он особо не нужен но иногда часто бывает такое что есть какой-то жирный метод который вот он большой и и жмем не успел его заранее скомпилировать огнем там то есть стартует метод в нем цикл на миллион итерации понятно что ждать пока еще несколько раз вызовется имеет смысла скомпилировать день обычно тысячной итерации не мучиться до open g т.к. и коммерческие распространяемые hotspot живым они в принципе имеют практически идентичные коду кодовую базу то есть те пачек которые делаются для придите к и они попадают в коммерческий релиз опять же детей не собирается так сказать изначально под windows только с цикле нам ну и плюс сейчас происходит поскольку joe rocket умирающий продукт то полезное что в нем было например flight control он мигрирует вход подкуп bass это скорее всего не будет в консольной части то есть коммерческий hotspot будет open source плюс какие-то это самое дополнительные дополнительный функционал с другой стороны опять же hotspot опять же дикие он используется многими свободно распространяемым дистрибутивами и они следят за тем чтобы он был хорошим станет кода bass это основной коду gs1 то есть сборка мусора jit оптимизации это все однако так вот вопрос здесь все что вы рассказали про компиляцию в джаве правильно я понимаю что все это относится ко всем языкам над живым как-то скалы кожа и все остальное да да это все относится ко всем языкам также на все зависит от того как они создают капнуто в 7 джаве появилась такая инструкция и наук динамик который не используется джавой в чем например ее смысл в том что при написании там какого-нибудь робби у нас здесь равно есть интерпретатор ruby который постоянно делает вот эти вот виртуальные вызовы и получается то что в живым есть вот одно место которое отвечает за поиск правильного метода для руды и она не оптимизируется неэффективно оптимизируется потому что оно одно на все методы она остается всегда полиморфным бы инвок динамик он позволяет для динамических языков вот этот вот кол сайт отделить от кода и превратить его в отдельный объект то есть там динамик работает со специальными объектами которые живым профилируют отдельно и соответственно может там для них создавать код но в принципе до появления ног динамик с этим успешно справлялись путем динамической генерации байт-кода то есть вместо того чтобы писать одно какое-то место которое отвечает за все вызовы там тот же g руби он генерит огромное количество байт кодов генерит метода на лету которую уже достаточно хорошо оптимизируется оптимизируется живым и в принципе как бы все кто серьезно относится там jira бийского а не все это понимают они понимают как работает jet компиляция в живым и по возможности пользоваться этим ещё такой вопрос не знаю глупый сколько я помню в.м. не было хвостовой оптимизация хвостовая рекурсия нету и не будет потому что опыт а потому что отказаться от stack trace of это очень грустных очень не хочется разбираться с кодом который выкидывает exception-ы непонятно откуда аджит не может нам фронтами как-то понять ну проблема хвостовой рекурсии то что она эффективна если мы вообще в принципе и выкидываем весь контекст если мы как-то пытаемся этот контекст где-то сбоку оставлять то все ломается вторая проблема почему одна из особенностей java то что она использует истина нативной стак операционной системой и на нем могут например перемещу то есть стек кадры стека которую выполняют аджарский метода там переход в какую-то нативную библиотеку и и как стек нативная библиотека снова может выкинуть джаву то есть стык остается один и он управляется операционной системы там нет проблемы с тем что нужно какую-то эмулировать свой стек и вот такие оптимизации уровень хвостовой рекурсии они тоже ломают эту модель в дот найти они что-то придумали на эту тему но тоже там для того чтобы обеспечить нужный уровень безопасности получается что оптимизация не очень себя правда красиво прошу прощения большое за доклад не могли бы немножко пролить свет на java 8 и использование функциональных моментов и насколько это будет оптимальная я до сих пор использую 6 да я думаю принципиально ничего не изменится это как без синтаксический сахар на самом деле там те же кожи они существовали всегда это анонимные класса вопрос в том сколько строк нужно чтобы создать этот класс я чуть давали по поводу восьмерки но там как раз 8j будет использоваться львов динамик ровно вот machinery связан с лиманами вот и вторая по поводу тоже языков и живем надо понимать что java она сначала компилятор делать код и компилятор любого языка другого тоже делать байт-код а собственно как под живем он работает с байт кодом поэтому какой бойкот приходит как бы настолько качественно можно оптимизировать живем он там ну какие то какие то там паттерн или что то что там происходит он умеет какими-то определенными наборами байт-кода хорошо работать или последовательностями какие-то хуже соответственно ну и идет работа в двух направлениях люди которые пишут компиляторы под языке они стараются генерить такой байт код который потом будет эффективно копируется ной наоборот то есть ответственно роково инженеры пытаются что то же со своей стороны сделать с двух сторон идет работа собственно все отличный доклад я еще хотел задать вопрос спасибо за доклад из 10 его jit компиляция она по умолчанию в контексте гнал java отключена и как-то включать можно параметры она включена и она в принципе настроена так что лучше не трогать если точно не знаешь чего хочешь получить у нее достаточно много параметров там есть три skoda на то какой как сколько раз должен метод выполняться перед компиляцией есть три школы на глубину и майнинга на максимальный размер метода которые может быть скомпилирован разные наборы параметров включаются в зависимости от того запускается режим с флажком минус клиент или минус сервер также она там немножко сама может эвристики добавлять зависимость того то на каком железе она запускаются параметры есть компиляция включена лучше туда не лезть то есть не стоит играться с этими параметрами там a production system чтобы не ну зависит от того с какой целью вы играете sisley для того чтобы лучше понять как она работает то может быть это и стоит сделать вот автор же руби часа верна то у него достаточно много докладов можно поискать в интернете которые именно связано там с тюнингом jet компиляции рекомендую поискать вот его работы если хочешь если интересно экспериментировать получится ли у вас как то есть будет ли польза от этого я сильно сомневаюсь но кто знает цифры это сильно не увеличена я думаю нет спасибо"
}