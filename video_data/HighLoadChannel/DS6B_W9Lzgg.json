{
  "video_id": "DS6B_W9Lzgg",
  "channel": "HighLoadChannel",
  "title": "Объектное Реактивное Программирование / Дмитрий Карловский (SAPRUN)",
  "views": 2829,
  "duration": 2796,
  "published": "2018-01-16T13:31:19-08:00",
  "text": "меня зовут дмитрий карловский я из компании сопран руководитель группы web-разработки наша компания занимается внедрением сабов крупнейшие российские компании но в последнее время мы смотрим активно сторону разработки собственных программных продуктов одним из таких продуктов является кросс-платформенной open source веб-фреймворк для быстрого построения отзывчив интерфейсов с говорящим названием смол в котором мы используем возможности объект на terranova реактивного программирования о которых я и расскажу далее давайте представим что мы решили открыть интернет-магазин по продаже игрушек причем сделать мы хотим все не абы как а стильно модно молодежно быстро гибко и надежно игрушек у нас много а начать продажу мы должны были еще вчера поэтому мы хотим сделать все как можно быстрее но при этом не потеряв юзер экспириенс мы можем загрузить данные основные данные игрушек на мобильные устройства и быстро bio сетевых задержек позволить пользователю листать наш каталог листать его конечно увлекательное занятие но пользователю хотелось бы ограничить свой выбор лишь теми игрушками которые интересуют его в данный момент поэтому мы добавляем фильтрацию сложная фильтрация на больших списках мост занимать продолжительное время поэтому нам бы не хотелось чтобы она повторялась лишний раз например если мы отфильтровали по размеру то при изменении числа отзывов нет смысла повторять фильтрацию а если мы отфильтровали по числу отзыва в тонну вы понимаете нам важно знать от каких конкретно свойств каких конкретно товаров зависит результат фильтрации чтобы повторять его только когда в этом есть необходимость пользователь обычно хочет просматривать товары не в произвольном порядке а в определенном например отсортированным по мере увеличения цены или помине по мере уменьшения релевантности поэтому мы добавляем сортировку сортировка на больших списках хитро как они сортировка может применяться тоже продолжительное время очевидно тут повторную сортировку нужно будет применить нужно будет произвести лишь при изменении критерии сортировки и при изменении тех свойств по которым мы сортировали но не всех товаров а лишь тех что сад что соответствует критерии фильтрации а значит и при изменении критерии фильтрации и при изменении свойств по которым мы фильтровали если мы попытаемся описать в коде все зависимости между всеми состояниями то это придет к комбинатор нам у взрыву и вам оторвет руки тут мы описали лишь два шага преобразований но в реальном приложении их может быть и больше десятка чтобы обуздать эту экспоненциально растущей сложности было придумано реактивное программирование которое позволяет делать приложение быстрым стабильным компактным а без него так не получится если вы будете отображать все данные что у вас есть то алгоритмическая сложность рендеринга будет пропорционально объему этих данных 10 товаров рендерится мгновенно 1000 задержкой но если 10000 что пользователь успеет сходить попить чайку если у пользователя такой экран что одновременно в него влезает не более 10 товаров то визуально для него не будет никакой разницы будете ли вы рендерить всю тысячу или только 10 из них поэтому каким бы быстрым у вас не был react шаблонизатор он не как он всегда будет проигрывать по отзывчивости ленивые архитектуре которая в меньшей мере зависит от объемов исходных данных если размеры карточек нам примерно известны заранее я-то знаю высоту окна можно ориентировочно sky какие-то того какие товары точно не вылезают виделась а какие может хоть краешком но в неё попадает вырезать из огромного списка товары с 1 по 10 этап левой операция но только если у нас этот список есть где-то за каширин нам виде если же на каждое передвижение скроллинга мы будем заново его получать путем сортировки и фильтрации прочих преобразований то никакой плавности скроллинга не может идти речь о кей данные мы подготовили осталось отобразить их пользователь решение в лоб срубить старое дом дерево и вырастить из его новое именно так работают все речкина у шаблонизатор и она мало того что медленно но она еще сбрасывает динамические состояние узлов такие как позиция каретки и позиция скроллинга состоянии открытости selecta и прочие другие некоторые из них потом можно восстановить программно но к сожалению не все короче говоря реальность упорно не хочет быть чистой функции от состояния чтобы наше приложение работало как следует нужно изменять существующие состояние и от этого никуда не уйти а если не можешь победить то возглавь как натянуть у жан ришар правильно давайте генерировать новая виртуальный дом дерево сравнить его с предыдущей версии находить отличия и применять к тому реальному дом дерево что видят перед собой пользователь звучит как костыль неправдами сколько работаю приходится выполнять только лишь для того чтобы изменить значение текста узла когда в модели изменилась составив значение строкового свойства а как могла бы выглядеть работа наиболее эффективного решения все очень просто между исходными данными их отображением устанавливаться прямая зависимость при изменении одного состояния изменяется лишь зависимы от него и никакой больше при чем работает это не только между так называемыми моделью и отображения но и между любыми состояниями на начиная от базы данных на сервере через кучу промежуточных и заканчивать дому злого браузере именно в этом и заключается суть реактивного программирования они в шаблонизатор и со звучным названием которые продают нам на каждой конференции ok вы можете сказать что я сгущаю краски на самом деле конкретного вашего приложения никогда не будет столько данных и сложных обработки и запускать ваше приложение будет лично мощной рабочей станции они на хилан китайском танке в режиме энергосбережения но у меня есть простое соображения на этот счет чтобы ваше приложение работало со скоростью 60 кадров в секунду она должна успевать выполнить все свои операции за 16 миллисекунд и превысить их очень легко перед вами известны дыма созданная ребятам из фейсбука который показывает как сложно и приложение на ринке начинают тупить сейчас они пытаются решить это путем размазывания вычислений по нескольким кадрам в реакторе бери таким образом они добиваются завет на 60 кадров в секунду но это приводит к визуальным артефактом например в данном у дома каждую секунду обновляются числа но если вы будете возникать мышью в реакции бери то обновление чисел прекратится фундаментальная же проблема у них до сих пор остается не решенной а именно кучи лишних вычислений на каждый чих rp напротив позволяет писать код приводящий к минимуму вычислений который автоматически оптимизируются где автоматически оптимизируются потоки данных от источника данных двоих потребителям как вы можете видеть эквивалентный iq варианта реализации с применением реактивном программирования показывает гораздо больше отзывчивость и плавность анимации и это даже без размазывания вычислений по кадрам которые тоже можно применить но тут она не нужна давайте наконец добавить немного человек кто использует свои практики объектное программирование поднимите руку пожалуйста я ожидал больше окей объектное программирование это программирование про данные и функцию для работы с этими данными в рамках одной в рамках одной абстракции с относительно простым интерфейсом объекте а кто использует функциональное программирование так видимо все оставшиеся функциональное программирование это программирование на чистых функциях и то есть таких функциях которые не изменяют никакого состоянии сами не зависит от за меня его состояние наконец кто использует реактивное программирование лес рук штан да спасибо тут все приложение описывается в виде набора правил описывающих как одни состояние зависит от других и когда изменяется там какой-то третье это приводит к ск одному обновлению всех зависимых создать состоянии даже касались их у многих реактивной программирования прочно ассоциируется с функциональным однако на куда ближе к объектам у так как основные действующие лица в нем это изменяемые состояния есть два принципиально разных способа реализации реактивности первый это всякие рэкс и бекон и и прочие стрим панк также известный как функционально реактивная программирование суть его в том что вы явным образом берете стримы придаете значение из них на в чистую функцию которая возвращает новое значение и это значение автоматически передается во все зависимостями а что с этим значением делать или не делать если мы уже решают сами посмотрите на этот frp ребус и попробуйте сходу сказать что и зачем он делает а делает он простую вещь он создает стрим для критерии фильтрации стрим для списка игрушек и на их основе и создает новый стрим для отфильтрованного списка игрушек тут уже примерно несколько типичных методов оптимизации тем не менее этот код все еще крайне неэффективен так как фильтрация выполняется каждый раз изменение любого свойства любой игрушки куда проще и эффективнее использовать другой подход где вычисление начинаются не от источника данных от их потребителям возьмем например наиболее продвинутую реализацию у rp мол ним не правда ли кот куда проще и понятнее это ровно тот же самый код который мы бы написали без всякого реактивного программирования но мы добавили специальный декоратор который динамически отслеживать зависимости кэширует результат работы функции а когда зависимости изменяются сбрасывает от каш таким образом все вычисления выполняются только по необходимости правильно реализация логике этих декораторов позволяет снять с программиста головную боль по ручному контролю за потоками данных позволяя ему сконцентрироваться на бизнес логики аналогичным образом мы можем добавить сортировку в данном примере мы по умолчанию сортируем по цене а значит при изменении цены будет произведена повторная сортировка но фильтрация будет взят результат фильтрации будет взята скажи но если же мы фильтровали тоже по цене то будет призвана и фильтрации сортировка ну и под конец мы можем вырезать из нашего списка лишь видимый на экране задача для этого мы берём информацию о видимой области и вырезаем ну все очень просто при этом перемещение скроллинга приводит лишь к незначительному по времени в рязани из списка какого-то кусочка без бессмысленно при фильтрации перри сортировок сразу же введём свойства чилтерн которая будет возвращать список тех компонент который мы хотим чтобы были от рендеры внутри нашего данном случае это список видимых игрушек а теперь мы можем реализовать простейший обобщенный рендеринг компонентов для этого мы реализуем метод рендер который знаком всем react авода знает этих катар компонента мы ищем соответствующий элемент в дом дереве а если не находим то создаем эти элементы и устанавливаем у нужный индикатор чтобы в дальнейшем он его можно было найти в дом деле обратите внимание на реактивный декоратор который кэширует результат работы функции рендер а значит она не будет запускаться лишний раз только когда изменится те свойства которые мы обращаемся обращаться мы к ним будем далее в данном случае я опустил собственно обновление узла чтобы было попроще но там ничего сложно мы обращаемся каким-то свойствам получаем значение актуализирует состоянии дом узла часто исключение безвозвратно ломает приложение например она может начать глючить она может не дорисовывать страницу она может вообще перестать реагировать на действия пользователя однако исключение это такой же результат работы функции как и возвращаем а ей значение если при рендеринге компонента возникла исключения то упасть должен именно этот компонент они все приложения целиком устранение причины исключения должно восстанавливать работу компонента как если бы он и не падал сейчас вы видите что периодически там падает ответ от сервера и компонент помещается как упавший а потом снова стали свою работу и как положено поэтому давайте завернем рендеринг нашего компонента в блок tracker в случае ошибки мы будем эту ошибку это логировать и записывать имя исключение в атрибут а если все прошло без эксцессов тогда этот атрибут удалять что нам это дает мы можем элементарным образом через с и стилизовать сломанные блоки блоки какой бы блок не упал мы можем указать ему например стать полупрозрачным и перестать реагировать на действия пользователя как только он поднимется атрибут будет удален и пользуйтесь может с ним взаимодействовать давайте сделать шаг в сторону и поговорим о загрузке данных взгляните на этот код который показывает сообщение которые генерируются общение а числе те зубки текущего пользователя сначала мы загружаем информацию о пользователе берём от туда его имя потом делаем запрос к серверу за числом пользователей данным именем ну и под конец мы загружаем тексты берем нужный текст и подставляем туда число код простой понятный не правда ли но тут есть одна фундаментальная беда так как виртуальная машина java script 1 по точно а запросы в данном случае блокирующие то пока идет каждый из этих трех запросов все приложение встает колом ипользуйте не может с ним не как взаимодействовать чтобы решить эту проблему ява скрипте принято писать код на колпаках получается вот такая вот тарелка макарошек обратите внимание что тут мы грузим информацию о числе пользователей и текст и параллельно так как они не зависят друг от друга это уменьшает общее время загрузки ресурсов но код становится сложно сложнее поддерживать чем если бы он был синхронный недавно в москве те появились средства синхронизации но действуют они лишь пределах одной функции они всего столько вызов если мы пометили функцию как синхронную то в любой момент мы внутренние можем ее приостановить в ожидании каких-то событий как видно это не сильно спасает положение код все еще достаточно сложный нам приходится применять по-прежнему специальные заклинания чтобы распараллелить загрузку а что если я скажу вам что вот этот вот код может быть не только не блокирующим но и грузить информацию о пользователе и текст и параллельно вся магия в адекватные обработки исключительных ситуаций если синхронный код обращаться к данным а данных нет то это самая натуральная исключительная ситуация для синхронного кода поэтому в этот момент бросается специально исключения это исключение остановить текущей стек вызовов а когда приходит данные благодаря реакции реактивности вычисление перри запускаются но на этот раз вместо исключения приходят уже реальные данные и исполнение продолжается как положено а чтобы добиться распараллеливания реактивные свойства не просто пробрасывать исключения они возвращают прокси объект этот прокси объект может можно его куда им сохранить его можно куда-то передать но при попытке доступа к его содержимому будет брошена то самое сохранена исключение в данном примере запрос за текстами из-за пользователям будут инициированы сразу но при этом исключение возникнет только при доступе к ядерной а значит загрузка пойдёт параллельно но дальше она все всех все синхронизируется благодаря реактивность давайте наконец добавим не блокирующую загрузку списка игрушек вместо локального хранения как виде нам для этого пришлось изменить всего один метод этот совершенно не изменил сигнатуру мы просто взяли содержимое файла как если бы она была у нас доступна локально обработали его и вернули ru это остался последний штрих пока данные не загружены у нас бросается исключения а имя исключения записывается в атрибут а значит если какой-то блок не смог до рендерится потому что ему не хватило каких-то данных и он ожидает их загрузки то мы можем пометить этот блок что он ожидает загрузки на прям нарисовав анимированные индикатор ожидания который автоматически пропадет когда вся загрузка загрузка будет будет устранена завершена это избавляет от программиста и от еще одна головной боли пока что мы говорили лишь продвижение данных от сервера к пользователю но не стоит забывать и про обратный поток данных на диаграмме каждое звено это некоторое состояние выраженное в различных моделях на бэг-энде например дата это какое-то число в таблице на фронте де это виджет календарик в определенном состоянии но в голове у пользователя это тот день когда я выступал на конференции если опустить информацию о если опустить посредников то источником истины о том что видит пользователь является бэкон а источником истины о том что нужно изменить на бэг-энде является пользователь но самое интересное начинается когда мы добавляем посредников например политики пользовательский интерфейс который одновременно зависит и от сервера и от пользователя как же реализовать его так чтобы он работал четко и предсказуемо что если пользователь будет менять toss the именно состояние которое сейчас видит в том виджете на который смотрит как вы думаете что за фреймворк использовал для создания приложения с этой архитектурой нет нет но я уже близко до angular это типичное приложение на angular когда пользователь меняет состояние начинают срабатывать watcher и которые итеративно начинаю синхронизировать состоянии это приводит к временно не консистентной sti как самого клиентского приложения так и клиент-серверной система в целом это логика мало того что неэффективно она еще и требует очень аккуратно написании кода и точно выверенных костылей вида подождать пока синхронизация закончатся и потом вызвать мой обработчику потому что мне нужны именно актуальные данные а как называется архитектура со следующей диаграммы да это просто фэйсбук подол подумал придумал flags где поток от сервера к пользователю идет как положено через иерархию компонент а в обратную сторону он так перескакивать через глобальной процедуры так называемой экшена проблем адская с консистентную мы таким образом побороли но появилась другая компоненты сталине перри использование чтобы сделать переспорю мне нужно там мутить много кода как в самом компоненте так и в окружении полвека назад эта проблема уже была решена с помощью абстракции инкапсуляции ну до сих пор мы ходим по одним и тем же граблям проблема двустороннего связывания angular а было не в том что она двусторонняя а в том что состояние сначала изменялась а потом отложенный синхронизировать чем меняться оно могло как со стороны сервера так и со стороны пользователя что вносило дополнительно неразбериху именно в этом был корень всех проблем они как же его выкорчевать решение в объект на программирование существуют опять же не один десяток лет просто не давать пользовать пользователю объекта менять его состояние напрямую вместо этого этот доступ asus осуществляется через специальные функции так называемые аксессор и пользователи объекта может лишь изъявить желание изменить что-то в объекте но как на это желание отреагировать объект уже решает сам он может изменить свое состояние он может делегировать обработку пользоваться кого желания другому объекту на диаграмме можно видеть как новое значение передается от объекта к объекту не меняя его состояние ничего состоянии она доходит до сервера и только когда она начинает возвращаться но уже актуализирует состояния компонент точно актуальными значениями в этой архитектуры нет проблем angular а с его некой ассистент ностью так как прямой и обратной потоки данных не пересекаются но нет проблемы флаг со так как каждый компонент взаимодействует лишь со своим непосредственным владельцем и непосредственным имуществом и без всяких там глобальных экшена данный пример компонент строкового поля ввода который имеет два свойства для примера это hand который текст который вводится если значение не задано и вылью собственно текущее значение благодаря декоратору возвращаемая функция вылью значение кэшируются в локальном состояние объекта но мы можем его настроить это очень легко мы создаем из компонента и говорим о что теперь hand у тебя будет возвращать всегда известного персонажа комиксов или мы можем сделать чуть посложнее мы можем сказать чтобы в качестве значения свойства вылью он использовал не свое локальное состоянии а нашу локальную переменную тут при затягивании когда поле ввода будет затягивать значение вылью она будет фактически обращаться к нашей локальной переменной потому что мы возвращаем в этом в этой функцией его значение а при проталкивании нового значения она будет записываться в нашу локальную переменную возвращаться уже актуальное значение вам может показаться что это дурно пахнущий код и так делать нельзя и вообще мы там влезаем во внутренности какого-то стороннего объекта однако на практике это не доставляет никаких проблем и работает на отлично мы не можем записать левый метод из или изменить его сигнатуру начатой pci керна настучит нам по башке надеюсь многие из вас используют typescript или flow поднимите руку кто использует много людей надеюсь все остальные тоже значит используют потому что это полезная штука есть только два ограничения конструктор не должен обращаться к своим свойствам и потому что мы их в дальнейшем можем переопределить и и переопределять свойства можно только сразу же после создания они там в любой момент времени и там переопределять по десять раз этих правил достаточно легко придерживаться поэтому проблем это не доставляет лучше конечно не создавать объекты в воздухе не разбрасываться локальными переменными а хранить объекты в контексте другого объекта например мы в данном примере кода создаем свойство name с большой буквы которые являются фабрикой при обращении к нему создается incense вложенного компонента настраивается этот instance и возвращается а благодаря декоратору все это кэшируется причем декоратор он мало того что кэширует он еще контролирует время жизни пока этот компонент который возвращает name кому-то нужен на прямо на рендере сын страница он находится в кэше как только он никому становится не нужен the cash автоматически очищается и объект де структурируется это приводит это позволяет своевременно освобождаете заняты ему ресурсы то есть не нужно никаких wheelchair видно чень ши прочти ерунды для настройки вложенного компонента мы можем просто провязать его свойства с нашими свойствами на примере вы можете видеть односторонние связывание и двусторонней связи реализуются они простыми 1 строчными замыканием такая простая но мощная архитектура позволяет создавать самодостаточные компоненты которые не знают о внешнем мире ровным счетом ничего но их владелец владелец нескольких компонент может произойти в друг с другом через свои свойства таким образом что компонент который друг о друге не знают начинают взаимодействует друг с другом при чем четко и без всяких глюков типа там в одной панели одно значение в другое другое и что-то там накосячила синхронизацией напоследок хотелось бы дать совет не гонитесь за хайпом мода переменчива и постоянно тянет нас болото если ваш единственный аргумент при выборе технологии это число разработчика которые знают то готовьтесь к тому что через пару лет никто из них не захочет с ней связываться а еще через пару вы не найдете никого кто сможет разобраться в коде вашего проекта разумеется большой компании выбираться из жопы увлекательней но если вы хотите вырваться вперед пока ослиные буксуют нужно трезво и рационально оценивать технологии выбирая те которые позволяют писать простой и ясный эффективный код который возьмет на себя большую часть головной боли позволив программисту сконцентрироваться лишь на бизнес-логики именно такой технология является объект на реактивное программирование и надеюсь мне удалось это показать это у меня все если у вас возникли вопросы я с радостью на них отвечу здравствуйте я использую сразу две технологии то соответственно объектное ориентирование в вебе потому что место валидаторы все красиво и я пишу на к самаре ipad 3 платформа там сожалению чтобы завтра нету приходится использовать то что называть реактивное программирование конкретно впервые был вот то есть хорошо знаю две две стороны монеты скажем так вот те принципы которые вы заложили ваш так это библиотека framework у нас фреймворк который состоит из кучи близок у меня была очень похожая идея то есть мы меняем только то что нам надо это конечно подтверждает в десятки раз быстрее react а потому что не надо строить то виртуальный домом сравниваю это дело обновляется до действительно быстро но есть и обратно опять же страна монета которую как бы вы здесь не привели почему-то это духи в чем проблема я привел пример рендеринга как это все раны например реактор scanf их например же секс узкой я могу немножко разместить логике прямо в юте например я могу посвятить каждую пятую строчку просто напишу там взять там остаток от 5 до пусть у меня посвятите каждой пятой я-то могу использовать iv и v классов тома и ладно еще много таких вот примеров то есть когда там могу вывести степень там ну как бы самая тупая примитивно логика я могу обещать вам you have вот здесь получается вам всю эту логику надо размещать строго в контроллерах то есть полностью готовить данные для в ухе строго в контроллерах наоборот ну конкретно в нашей реализации рендеринга все делается по ленивые архитектуре то есть потребитель данных он запрашивает данные то есть когда мы рендерим например какой-то список все что знает юха который рендерит этот список а то что там внутри какие-то элементы дальше элементы уже запрашивать какие-то данные и когда они запрашивают идет уже там процесс типа там нету данных нужно их подготовить мы не загрузили сервер нужно загрузить серверы такой вопрос вас в юхана чем вообще на хтмл там у нас и кастомный язык кастом средства про допустим вас в ухе нужно ввести одежде пользователя и вы к этому адэшников хотите там прибавить число 5 как конкретно у нас это реализовано так что нас вообще говоря нету бью терминология реактор или angular а у нас есть отдельно декларативное описание компонента где указывается как компонент и связаны друг другом как свойства связаны друг с другом и все никакой логики и отдельно идет императивное описание компонента это просто расширение typescript класса который генерируется с декларативной вьюшки и там уже описывается любая логика которая может потребоваться ладно это да еще только маленькое дополнение как вы реагируете на изменение объекта в массиве у объекта там точно такие же внутри свойства если кто-то к ним обратился то он на эти свойства подписывать вот эти устройства тоже удобно оборачивают в аннотации каждый сну пример свойств я же приводил как свойства объявляются это просто функции которые возвращают какое-то значение вот например свойства вылью и свойство hand это просто hand это просто функция возвращающие какое-то значение ну то есть это реально и свойства были это уже пали марта функции которая который можно вызывать без параметров либо с одним параметром мы могли бы сделать через геттер и сеттер и но тогда были бы проблемы с переопределения благодаря тому что это просто функция мы можем переопределить ну переопределять и геттер и сеттер одновременно понятно то есть спасибо здравствуйте дмитрий спасибо за доклад вот вы во время вашего доклада много говорили не правда ли что вот этот код проще я наверное тупой но мне не показалось что проще честно говоря вот мой вопрос немного абстрактные как считаете что лучше писать быстрый год или понятный код я предпочитаю писать быстро и понятный ну то что те не показалось это проще потому что ты не знаком с этим подходом но банально если посчитать число идиом которые там использована число там методов которые нам пришлось вызвать сейчас найду где этот газ было вот тут у нас идет куча вызовов усы куча расплав к костылей и код все равно неэффективной чтобы сделать эффективным нужно его усложнить еще на порядок но вот у меня простая не осилил моих мозгов не хватает чтобы сделать no rx действительно эффективное решение на с используем например мол men мы можем писать вот такой ход и он эффективно уже просто по умолчанию то есть эффективный код писать просто сделать его медленным ноет нужно постараться в отличие от какому тирекс и которые по умолчанию будет тебе при каждом ивенте будет прогонять его через всю цепочку зависимости даже если там это будет тот же самый я про не понимаю что в молле если функции нет аргументов то это гендер а если есть один аргумент это сеттер ну хорошо не не кажется это простым да ладно вот использовал джек вере на мобилках тоже можно использовать например тот же вариант нашего декларативно описание это не кого-то хтмл это именно декларативное описание компонента их взаимосвязи и то есть это все транслируется той стрип класс который ты расширяешь уже добавлять свою логику и и это может быть не только на выходе дом это может быть на выходе и нативный элемент и чтобы дмитрий спасибо за доклад у меня такой вопрос глядя на код смола вашу приборка мне показалось что он похоже немного на моб x да но собственная в танце и привожу список реализаций бросить много ли вообще общего между macbook стану вашим пригорком если да то с какими проблемами во мраке проблем вам пришлось решить при сработке вашего приложения магазин и тогда для течки память или что-нибудь еще но утечек у нас тут не происходит скорее всего дня не болел конечно но у нас автоматически контролируется время жизни объектов поэтому чтобы создать утечку это нужно специально постараться константина разница с максом мобы не подержится и фича которых я сейчас рассказал например синхронная запись синхронно не блокирующая загрузка данных еще не смотрел как он там реагирует на исключения возможны как дмитрий спасибо за доклад я работал с одним коллегой тоже адептам реактивного программирования написал там наверное малоизвестный реактивный пор креста кажется цель x тоже его я потом работал с его кодом и сталкивался с тем что стектрейсы получаются довольно ужасные и отложить какие-то баги очень сложно в такой приборке но это особенности видимые его реализацию но у нас тоже не прям чудесные stack trace у нас там есть куча промежуточных функций и например например у нас есть какой-то код который зависит от какого-то значения какого значения какого значения так далее изменилось вот это значение нужно ли перезапускать всю эту цепочку мы не знаем чтобы это узнать нужно при вычислить только вот та который непосредственно зависит если она не изменило значение то все дальше не нужно перечислять а вот если изменило то нужно перечислить зависимыми проверить не изменилось ли она и так далее и так далее мы доходим до корня и таким образом нас вычислений идет от такой с двух сторон сначала мы идем в эту сторону а потом идем уже в этой считаем как ну как обычно то есть когда мы вот так вот идем у нас и так trace содержит все там методы которые мы проходим по мере погружения но когда мы идем в обратную сторону у нас не могут быть все методов стыке что да он называется или практика вопрос а ну на самом деле это декоратор это обертка над другой библиотекой называется мулатом который реализует все это реактивность но дико rotapost позволяет в объектах создавать такие реактивные свойства у меня вопрос спасибо за доклад я возможно выпал из контекста мы услышал фразу что react компоненты нельзя сделать три использования я конечно react а вот и в доке как бы когда этом захожу там первая строчка типа изобильном все кого чего 60 и звездочек и вот вы говорите что нельзя ли использовать я такой типа них еще переиспользовать и если компания чистого воля данные то и это просто замечательно перес пользуется если он как-то реагирует и если он по флаг папа flags он начинает кидать вот эти вот и вон те которые там глобальная у него получается такая жесткая завязка окружении да это называется контейнер и поэтому контейнеры делается пустым нему так вот эти ивента есть внутри он адресует youtube одни данные какие-то и все больше ничего так ну и получается контейнер у нас не переиспользовать да ну ладно можно еще один вопросик вот там треки используется исключительно для того чтобы если вдруг возникнет ошибка внутри компонента если данный вдруг пришли неправильно но мы там теряем браузеры на оптимизации уже не теряя получается что использование треки никаких минусов не дает у почти не дает но там есть какие-то накладные расходы но они не такие фатальные как их раньше это было интересненького будет уточнить спасибо спасибо за доклад очень интересно я конечно с реактивным программирование не знаком но у меня походу доклада возник такой вопрос там на одном скрине вы сравнивали про майсы и вот не блокирует что что вы можете юзеры использовать а как тестировать вот такие вот ну функции грубо говоря то есть как мне в тесте однозначно понять что вот вы сказали что если у вас при обращении к юзеру ну есть еще юзер нет то будет падать ошибками в потоке получается а в тесте как однозначно интерпретирует что эта ошибка была или все еще запрос выполняется думай конечно проверка что за ошибка нет но вы же говорите что у вас постоянно ошибка если еще данных нет значит ну падает ошибка ну да поеду ну соответственно когда мы обрабатываем проверяем результат работает нашей функции мы проверяем что за ошибка возникла нет ну вот смотрите в тесте я сделал там замучил какой-то запрос на сервер который допустим поставил там одну секунду он выполняется мне получается этот тест где-то в цикле конечно покаяние в течение секунды не получу какой-то результат а но тут на самом деле я не сторонник синхронных тестов лучше как раз зам замочить грубо говоря время и внутри теста ты просто пишешь типа сделать запрос а потом пишешь а промотать время и дальше уже у тебя время пока буду как будто бы promod она и там допустим от эта цель уже пришел и ты можешь сразу тогда теста получаются такие достаточно простыми и последний вопрос спасибо за доклад интересные тезисы с некоторыми я согласен конечно может даже с большинством но в целом для меня это выглядит как такая ну не щепотка мобиля такая большая волшебная палочка магическое виде вашего декоратора мол мем который вы повесили везде и от каким-то магическим образом работать вот хотелось бы понять на самом деле во первых присоединиться к предыдущему вопросу я так понимаю что он видимо существует какая-то еще экосистема которую вам позволяет мочится таких функций да ну писать тесты во-первых сколько временно не уходит на общество да нет такой экосистемы потому что но видимо и нет вы же сами так понимать делать второй вопрос что все-таки под капотом этого магического декораторы rxd стритом что ты так на ещё такой вопрос конце отличный вопрос конце когда к вам приходит человек и вы говорите вот мы пишем на мол мэм вообще огонь присоединяйся к нам что вы слышать в ответ на самую к систему сколько человек поддержит это warfare панды а ваше руководство когда ставит вам задача ну как они вообще согласно все это терпеть разумеется иначе мы не разрабатывали ну собственно почему затеяли разработку чтобы смотрите мы пробовали на мобильные приложения делайте на найти вино это куча работает там нужна куча людей чтобы разрабатывать под разные платформы все библиотеки пишут другие люди не выше команд нет суд не библиотеках в том что приложение нужно писать нужно несколько людей которые синхронно вносят одинаковые фичи в разные кодовой базы и эти люди должны быть доступны примерно одновременно а это не всегда так получается что знаете бывает один человек там сильно занят на другом проекте и пока он там освободиться и то там может быть уже очень поздно вот кроссплатформенная разработка новых технологиях позволяет писать все это одному человеку групп кореи компилировать под разные платформы мы пробовали использовать полимер пробовали использовать ionic но все это приводило к таким не шустрым приложением вот поэтому мы затеяли как раз разработка собственно прибор который оптимизирован под как под мобилки так и по две стопы то есть нас и компоненты все у нас кстати и стандартная библиотека компонент не нужно там искать гуглить мы их сразу кладем стандартам летим вот и все компоненты разрабатывал так чтобы они хорошо себя независимо от экрана по бличу парке у вас есть какие то есть куча бенчмарков но боюсь у нас сейчас нет времени показать там тоже хорошо спасибо а если интересно но собственно домен а нет вот на этом домене у нас есть все дымке и там ссылка на git хоп на гитхабе документации прочее а и на гитхабе там же имеешь маркер сюда я может чуть-чуть дополнят вопрос по поводу стектрейсы ну часто такое бывает что приложение что-то страшное происходит если увидите что вас совершенно безумный stack trace вы можете написать свою кастомную обработку ошибок который будет какой-то адекватность актрис который вы понимаете я так делал на нескольких проектах совершенно разных задач в бэг-энде на фронте и в принципе работает редко нужно когда лезть в нутро framework а чтобы все функции pastry как нам работать что там баг с креслом все тестирования работает ошибка где-то у вас соответственно чем мы поощряем зале за нее внутри поговорка мы пишем код маленькими модулями достаточно простым кодом так что есть внутри цифра марка это наоборот полезна нет я согласен просто каждый раз когда кайт ошибка лезть внутрь и да это за нравилось типично там огромным фреймворком это очень странным все нам его лицу кучу кода и ты там пытаешься понять и где там что все спасибо вот"
}