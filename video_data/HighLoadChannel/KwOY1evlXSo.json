{
  "video_id": "KwOY1evlXSo",
  "channel": "HighLoadChannel",
  "title": "Доменно специфичные базы данных и рассылка Aviasales / Борис Каплуновский (Aviasales)",
  "views": 175,
  "duration": 2701,
  "published": "2017-04-22T12:21:44-07:00",
  "text": "меня зовут козловский борис а я работаю в aviasales и сегодня я хотел бы вам рассказать об изобретении 1 довольно небольшого велосипеда а этот велосипед называется доме на специфичная база данных которую мы используем для рассылки такой термин как доменной специфичный базы данных хлам наверно раньше не встречался ну вот сегодня знакомимся и так я расскажу о том откуда откуда взялась проблема которую мы решали почему мы решили и так решать я расскажу подробно довольно об алгоритмах которые использованы нашим в нашей базе данных об ограничениях решения о том как это все дело масштабируется и на какие грабли можно не наступить когда вы изобретаете велосипед и так что делает aviasales aviasales подает как наверно догадываетесь авиабилеты к нам приходят пользователи формирует свой запрос указывает даты направления мы получаем этот запрос создаем аналогичный запрос для ну вот тут видите 4 стрелки online travel agencies авиакомпаниям на самом деле в продакшене таких стрелок штука 80 то есть мы посылаем порядка 80 50 и 100 запросов к внешним сервисом получаем и получаем от них ответы даем пользователю пользователь выбирает нужный ему билет покупает и счастливо летит проблема в том что мы за эти запросы не платим а вот travel & jones s и авиакомпании пользуются adds это global distribution system эти системы проектировались шестидесятых годах на данный момент они работают но скажем так далеко не в ногу со временем поэтому вот эти вот товарищи на эти и авиакомпании платят за каждый запрос что это значит для нас это значит что мы не можем по своему желанию зала заваливать их запросами да и стимулирует нас переиспользовать результаты всех поисков как можно более широко что на 4 использовать это значит что онлайн тв и джинсы с авиакомпаниями тем выгоднее работать с нами чем больше отношении поисков к покупкам это и порождает проблему проблема такого чтоб нам приходит пользователь смотрит какую-то цену на билет но уже в курсе что цены периодически меняются и он у него есть время перед вылетом и он не хочет покупать билет прямо сейчас но оформляет подписку он оставляет параметры своего поиска мы пользуюсь и использовать параметры не можем осуществлять паразитные поиски и используем поиски осуществляем и другими пользователями для того чтобы уведомить этого пользователя о том что цена по интересующему направлению перелета и параметрам изменилось пользователи оформляющие подписки могут оставлять довольно много при предпочтений они могут указывать что он хочет человек хочет лететь и из из москвы например в таиланд или может предпочесть сказать что его интересует билеты только определенных авиакомпаний пользователь может пожелать подписаться только только на определенный рейс например потому что это а380 он хочет полететь на а380 пользователь может предпочесть дня аэропорты пересадок другим аэропорту ну потому что в одних аэропорта хороший duty free в других не очень и конечно же пользователи довольны сильно волнуют длительность перелета и количество пересадок просто из соображений комфорта это слайд ну так вот сумбурный сделано специально чтобы показать что таких вот параметров по которым пользователи могут оставлять подписки их много и здесь они все не поместились при этом как понимаете когда не стали бы создавать расширяемая система да и не хочется накладывать лечение что наша система работает с этими параметрами не работали с другими соответственно хотелось настроить систему которая позволяет эти параметры добавлять когда нам хочется и убирать когда нам хочется и так вот такие вот так вот выглядят требования к системе движок который мы создаем должен примерно миллион раз сутки проверить 1 мегабайт ней документ на соответствие примерно миллионам предикатов и не вспотеть собственно что такое миллион раз сутки это количество поисков примерное количество поиск в которое совершается у нас на сайте а один мегабайт документ это собственно смешанные результаты поисков от 50-80 сотни а те и ввв одни результаты поисков самолетов на планете как вы догадываетесь летает довольно много и миллион предикатов это примерно то количество булевых операций и просто логических выражений из которых состоит подписка в общем если это все перемножить до получится довольно довольно большой набор данных с которых сказ которым нужно работать чтобы чуть чуть больше дать вам представление о том что такое этот мегабайт данных и насколько сложно он структурирован данные которые наш движок отдает на frontend содержит всю необходимую информацию это и курсы валют на текущий момент чтобы пользователь мог выбрать валюты в полетов которые он предпочитает понимать цену информацию online travel agencies информация об аэропортах информация об авиакомпаниях ну и конечно же с вами предложения причем предложение выглядят довольно сложно имею довольно глубокую вложенность предложение предложение много это массив одно предложение предложение это по сути набор перелета в одно предложение может содержать несколько цен от разных online travel & jones s line & jones s имеют разную известность скажем так вряд ли из вас кто-нибудь слышал такой революции как кликали например да наверное все слышали об ozon travel поэтому да некоторые пользователи предпочитают покупать даже чуть более дорогие авиабилеты в более известных агентствах соответственно предложение состоит из сцен от разных агентствах дальше они есть несколько сегментов да если это one way перелету один сегмент если раунд 3 2 перелета если придет бывает и многое называется alpen ja внутри сегменты у нас есть перелеты в каждом перелете есть аэропорта даты вылета дата назначения авиакомпания следующий перелет ну и много много всего я наверно устану рассказы описывать вам структуру этого интересного мегабайта данных и структура подписок я довольно довольно сознательно оформил эти четыре булевых выражений а похожими на es que el выражения ну потому что они примерно такие есть обращаю ваше внимание что они все неоднородны то есть в них используются разные свойства да это чаще всего человек довольно точно указывает место в или ты это там москва или петербург сразу скажу что процентов 80 поисков из москвы вот а дальше человек может указывать разные предпочтения по цене разные предпочтения по стране назначения количество пересадок ну в общем все то что было на замечательной кашицы фильтров и таких ip и таких выражать но собственно одно такое выражение представляет одну подписку и таких выражений у нас в базе данных сотни тысяч причем каждое выражение состоит еще из нескольких предикатов в общем система получается довольно развесистая при этом требовании к базе данных выдвигались довольно строгие но потому что скучных задача решить никому не интересно проверка на соответствие вот этого самого мегабайт нова документа на соответствие миллиону предикатов нужно было осуществлять за 50 миллисекунд также была требования к низкому потреблению ресурсов просто потому что на момент когда мы начали работать над этой системой мы не знали сколько там сколько там денег да поэтому потребление ресурсов могло сильно повлиять на рентабельности этого проекта конечно же хотелось просто просто интегрировать эту систему в общую инфраструктуру ну и традиционные слова даже не буду объяснять это расширяемости масштабируемость это мантра смысла в этом нету но так принято а почему не подходит мы с queen но собственно на я нарисовал эту замечательную девушку которая привлекает с собой своим велосипедом и отеай оттянула нас от иска или решение и так это очень неоднородны и наборы предикатов да одни подписки с одними с одними предикатами другие другими это очень нетипично для иска входные данные это огромное дерево да если вы помните то есть цель это обычно очень-очень табличная плоская структура запрос туда это ну это это некоторое логическое выражение у нас же запросом в базу является огромный документ на тот самый инверсия логике вы скорее обычно хранят данные и выбирают данные соответствующие предикатом запросим у нас стояла задача ровно наоборот мы храним в базе выражения буль более выражение и и и на вход на вход база у нас падают подается этот самый документы нужно найти именно те выражения которые так которым соответствует этот документ ну собственно после того как вы предпочли сквере вот это вот вот девушку и велосипед стали думать как же это все делать понятно что затягивать затягивает долго долгострой и из и делать что-то что-то неудобно долго разрабатываем и не хотелось поэтому опишу архитектурные решения которые были приняты чтобы этот проект как можно быстрее вышел на рынок и не оттягивал на себя ресурсы компании первая ловушка это которых мы хотели избежать избежали это протокол взаимодействия наверное зная заметили что очень очень многие сервисы изобретают свой протокол взаимодействия казалось бы майской или padre а это и другой база данных но протоколы протокола там разные почему я до сих пор понять не могу но так есть regis memcache тоже вроде довольно похожие штуки но протоколы у них разные непонятно зачем искренне считаю что изобретение протокола это трата времени это может быть не на 100 процентов правда но процентов на 95 для почти любых ваших задач протоколы уже изобретены достаточно взять и использовать я с детства была нежные чувства к протоколу и степи просто потому что зная этот протокол и уме и и имею доступ команде таймер можно проверять ваш сервис протоколы и что хиппи не надо писать клиент-сервер они есть на всех на всех из для всех известных фреймворков языка языков программирования его действительно удобный добавить и тестировать если вы умеете пользоваться браузером куру и в гетто ура вы можете с этим работать кроме того это самый широко используемый протокол в интернете он отлично проектируется балансируется кэшируется и все его знают никому не придется это программировать и учить как то так следующая ловушка в которую тоже очень очень многие влипают это низкоуровневый язык часто подходя к проектированию алгоритмических задач и говорят ну что же это у нас число дробитель на я задача давайте брать java se que ir long чтобы работало быстро я считаю это большой проблемой если вы придумали адекватный алгоритм то ни один сам медленные язык программирования вам вашу систему не испортит ну а если даже если даже скриптового языка вам не хватит то лучше всегда написать на скриптовом языке чтобы чтобы оценить оцени производительной системы оценить качество алгоритма если потом потом окажется производительность недостаточно можно будет по мере тп имеет поменять алгоритм или язык программирования но но лучше начинается скриптовых ну понимаете низкоуровневые языки громоздких сложно отлаживать да и программиста которые умеют ими пользоваться обычно стоят подороже у нас в я съел сложились довольно нежные отношения с питоном после того как мы переписали на питон движок нашего поисковика о котором я рассказывал год назад на этой же конференции почему питон на этом замечательном скриптовом языке можно быстро написать прототип проверить эффективность алгоритм много сторонних библиотек компактный читаемый год и мои личные предпочтения питона например перед рубим рубим вокруг руби живет такое большое программист к комьюнити которая приводит к огромному количеству кода сфокусированного на красоте кода питоном больше пользуются в научных кругах никто не думает о красоте кода все думают о скорости и качестве и самая последняя ловушка самая большая и самая опасно это одно решение для всего наверняка вы сталкивались в жизни когда в компании придумают написать какой-то свой продукт под это выделяется пара программистов команда и эта команда еще сразу же думает ну что ж мы будем писать вещи всего для одной задачи давайте давайте сделаем универсальные решения которое спасет африку от голода поможет нам завоевать удаленные планеты вот на моей практике общими довольно давно работаю в анти индустрии все это заканчивается довольно грустно компания теряет 1 2 3 человек люди занимаются большим важным делом в итоге получается еще один комбайн которых на рынке и так очень много и ну и собственно лишенную задачу не под этот комбайн комбайн поставленную задачу этот комбайн не решает но но зато программиста который вы разрабатывают полны собственного достоинства и увлеченно создают вот такое вот кольцо саурона ну и как вы понимаете если мы создаем комбайн который решает все планеты на земле это приводит долгостроем до цель ради которой создавался проект теряется проект начинает заниматься всем кроме изначальной цели в общем очень очень этого не хотелось вертись так ну теперь вернемся немножко к алгоритмам которые мы использовали для этого разберем разберем структура это логическое выражение на что выражение состоит из нескольких дюймов причем дизъюнкции несколько проще чем вас кавер базах данных они состоят из свойства документа это собственно в левой части дизъюнкцию нас находится в этом примере вы видите три свойства origin это пункт вылета destination пункт назначения и прайс цена второй важной частью является булевой оператор дам здесь два это равно и меньше ну и третья часть является константа причем особенность подписок такого что мы никогда не сравниваем два свойства документа в левой части у нас всегда свойства нам наличие были в кале количество булевых операторов ограничено и в правой части всегда константы это на самом деле довольно важно вот эти вот свойства а режим destination прайс они ну когда вам приходит этот самый мегабайт ней документ на эти свойства мы можем из этого документа вычислить такие свойства как origin и destination вычисляются по документу довольно просто да мы просто берём этот развесистые джейсон и на первом уровне вложенности у нас есть одноименные свойствам и их просто читаем это очень быстро на а вот со свойством цены немножко другая история как я говорил в результатов поисков у нас много билетов это 1000 билетов нисколько не чтобы найти минимальную цену нам нужно по этой тысячи билетов проинтегрировать очевидно что итерация по нескольким тысячам билетов на пару-тройку порядков медленнее чем чтение свойства и затем следует выводов что у свойств документов разная сложность вычисления далее оператор и вот эти вот булевые операторы да они тоже имеют разную сложность это станет понятно немножко немножко позже но оператор равно ощутимо проще операторов больше и меньше при этом важно и важная вещь которую мы поставили в основу системы это порядок вычислений дефектов не оказывает влияние на результат ну понятно это свойства булевой алгебре и того как как мы должны осуществлять осуществлять проверку на соответствие как и говорил свойств свойств свойств некоторые свойства вычисляются просто некоторые очень сложно соответственно до начала до того как свойство нам понадобилось мы очень не хотим его вычислять а потому что свойств много и вычислить вот тот двадцатых свойств которые у нас сейчас есть системе по одному документу может занимать но там 10 миллисекунды поэтому свойства вычисляем сознательно лениво причем мы не просто должны вычислять их лениво мы должны упорядочить дизъюнкции в таком в таком так чтобы документ отсеять как можно раньше почему это экономит ресурсы соответственно мы должны поднять самые самые простые проверки наверх если документ по ним не прошел то нет смысла проверять остальные и самые сложные проверки вниз тут я разобрал это выражение но уже немножко перри упорядочил опере упорядочил я пункт вылета и пункт назначения почему я так сделал есть только нить идея рук немного ну окей на объясню вот предикат destination phuket сильно более от сеет намного больше запросов чем origin москвы а потому что большинство поисков как и говорил раньше делаются с вылетом из москвы соответственно вот именно такой порядок обеспечивает нам сильно-сильно большую эффективность на 2 предикат 2 deathwing нам придётся вычислять сильно-сильно реже дальше мы должны приоритизировать не только с детей приоритизировать дизъюнкции только по свойствам которые в них используются но и по операциям да причем чем дешевле проверка тем выше в дереве должен быть приоритет и чем больше ну то есть если и и приоритет оператора равно выше чем приоритет операторов больше меньше 2 2 замечание чем больше урезается дерево тем выше приоритет тут я привел origin in it идиte режим пункт вылетает эта дата вылета особенно системы такого что железки продают авиабилеты не более чем не более чем на год вперед это 365 дней и в то же время на планете несколько тысяч аэропортов это значит что пространство дату нас 365 пространство в аэропортов вылета ну там 2 2 3 4 тысячи это значит что фильтрацию по пункту вылет вылета мы должны мы должны сделать раньше в общем случае это приведет нас к большему от сечения дальше иной конечно же чем проще рассчитываются с значение свойства тем выше приоритет как говорил origin рассчитывается просто поэтому поднимаем его вверх прайс рассчитывается сложно вынимая убираем его вниз и того здесь я пытаюсь показать структуру нашего дерева узлы дерева состоят из двух вещей это свойство в данном случае эта цена это что мы утверждаем относительно этого свойства что цена например меньше и дальше мы храним в узле ни одно свойство свойства вынуты из из разных подписок таким образом мы можем за одну проверку за одно сравнение проверить проверить документ на соответствие сотням однородных предикатов и того что мы имеем это свойство это оператор и константы на те самые константы которые которые которые есть выражение в чем констант таких у нас много пойдем дальше как это все выглядит языке программирования вот в этом самом нашем питании и того мы в ноги храним храним строку которая обозначает свойства храним оператор храним hash hash детьми хэш устроен так что ключом сша является та самая константа до мкад которые вытянуты из выражения значением сша являются являются другие другие другие ноты как которые тоже нужно ну то есть если если конце если совпадение с константой найдены мы обходим детей под из знать и значение хэша да если не и если в хэш мы не попадаем то собственно отчисления продолжать кроме того мы храним здесь сортированные ключи этого же хаша это нужно это не нужно для операций равно но нужно для операций больше меньше чтобы проверять на проверять на соответствие сразу сразу нескольким константами за одну операцию бинарного поиска настоящим слайде я показываю как устрою устроен лист дерева но собственно там есть ссылка на родителя плюс есть call back url это url на который при обнаружении совпадения отправляется совпавшая часть документов папаша часть документов собственно ну а если мы дошли до этого до этого листа и следам эда листа не дошли то ничего никуда не отправляется вычисление прекращаются разберем немножко поподробнее как дерево работает вот мы пришли в воду с аль origin равно вычисляем свойства origin по документу и пытаемся из hishe по значению этого свойства извлечь из извлечь детей в данном случае тот проиллюстрирована что мы вычислили это свойство оказалось это яичко идти это phuket собственно где наша штаб-квартира и куда я вернусь после конференции и собственно у нас получилось совпадение мы начинаем обходить обходить детей этой ноды это был простой вариант вариант равно да тут тут делается очень простая операция извлечение из hishe как мы все помним сложность поиска по хорошо это большое от единицы то есть константа быстрее быть в принципе ничего не может следующая операция это операция меньше она немножко сложнее а смотрителям мы приходим в эту ноту и вычисляем свойства цена вычисляем самую-самую низкую цену которая есть есть в этом массиве берет предположим получилось 22 тысячи при этом в в данной ноте в хэши включились 10 20 30 40 тыс очевидно 22000 это меньше чем 30 это меньше чем 40 но больше чем 20 10 20 тысяч а что получается что в этом месте мы методом половинного деления находим находим две но до 30 и 30-40 и дальше рекурсивно обходим эти ноты как понимаете эта операция ощутимо сложнее чем операция равно да тут есть у нас и бинарный поиск и извлечение и несколько обращений крышу для извлечения этих данных ну и обход ну на эта операция примерно на порядок помедленнее будет кроме того дерева должно обладать фильтрующими свойствами смотрите какая штука предположим у нас в дереве и у нас неделе у нас выражение последовательно идут два свойства например цена меньше чем 20000 и пересадок не больше чем 2 до таким образом если мы скажем что действительно в дереве есть билеты дешевле 20 тысяч но и и и передадим вниз на проверку на проверку количество пересадок документ как есть то получится что билеты дешевле 20 тысяч например содержит себе 345 пересадок больше на а вот те билеты которые которые дешевле 20 тысяч черт-те билеты которые соответствуют требованиям пользователя да они стоят дороже поэтому при пей при отправлении документов ней вниз по дереву мы должны вы фильтровать из него нет не подходящее под данные приди к данным куски то есть например мы вычислили что количество пересадок ну что в нашем в нашем при пришедшим документе личный пересадок меньше чуть-чуть у нас включает а не меньше двух да получается что для того чтобы продолжать вычисление документа мы должны удалить из него все предложения в котором больше двух пересадка но в данном случае три нам при этом этот же документ подходит под требования количестве пересадок меньше 1 он подходит но только чтобы он удовлетворял этому требованию из него нужно удалить не подходящие данные соответственно мы в этот момент данные удаляем и отправляем документ вниз по дереву таким образом дерево еще и модифицирует этот документ ну и дальше расскажу о некоторых довольно небольших оптимизациях которые нам пришлось сделать чтобы чтобы это работало все пошустрее поинтереснее и так все подпи все по подписке это неправильное слово все узлы дерева имеют ссылку на родителя для ускорения операции удаления то есть смотрите дерево у нас работает в какой-то момент человек отписался и ли у нее время прошло или еще что-то вам нужно удалить удалить из дерева лист и если у нас нет в обратные ссылки эта операция может быть довольно сложно сложной нас обратной ссылкой мы доделать нам просто кроме того рядом с деревом и храним сортированный массив ссылок на все листки дерево чтобы опять же не обходить дерево мы храним этот сохраним этот список когда нам приходит запрос на удаление мы из этого списка находим ссылку удаляем его из родителя ну и все все это работает довольно быстро кроме того мы все еще помним что некоторые свойства документы вычисляются реально сложно и поэтому результат вычисления свойств документа кэшируется на анну чтобы там в одном в одной ветке по дерево не считать считать цену несколько раз ну и собственно вот это вот дерево котором я рассказал является только одной частью системы а вот целиком система которую мы собрали с дерева выглядит вот так очевидно это все это это дерево работает целиком in memory да ну потому что заниматься сложными алгоритм хранение на диске не хотим однако данные нужно перси stick вот в данной ситуации я воспринимаю но и скрыль как not only сколь то есть за сохранность данных у нас отвечает москве да все данные хранятся в нем на момент старта дерево данные выгружаются из москве или загружаются в дерево и дальше рабочее приложение новые подписки заправляя дерево устаревший удаляет вот но моя сквер сознательно используется в качестве надежного хранилище создание удаления подписка работают were в рельсовом приложение он же работают с mais quel им дерево обращается к этому приложению для того чтобы получить данные для первичной инициализации и потом в ходе своей работы дерево делает call back в рисовое приложением самом деле это одно кольцо в приложении но я разбил его на 2 чтобы разделить роли это рисовая приложение принимает call back соответствующий предикату частью документа создает письмо принимает решение можно ли сейчас беспокоить данного пользователя очевидно у нас есть там некоторые гистерезис который предназначен чтобы не заваливать письмами от человека на и если человек человеку мы еще не сильно задолбали создает письмо и отправляет его пользователи через smtp сервер ну вот такая система получилась собственном дальше немножко расскажу о масштабировании масштабировать эта система имеет смысла по двум направлениям первое это по количеству обрабатываемых документов тут масштабирование делается довольно просто что мы делаем мы создаем два абсолютно одинаковых дерево загружаем в них одни и те же правила и потом и потом каждый каждый приходящий документ отправляем либо в одно либо в другое дерево таким образом получаем масштабирование по количество обрабатываемых документов при этом увеличиваем overheat оверхед на память на потому что процесс память питание очевидно не очень шарится если отдельно об этом не позаботится второй вариант масштабирования это масштабирование по количеству предикатов дереве здесь мы сталкиваемся с прямо противоположной картинкой каждый все документы мы делим правило на две части одна 1 часть правил отправляется в одно дерево другая часть правил управляется другого дерева при этом нельзя правило дробит а то есть правило из одной подписки не могут быть растянуты между деревьями соответственно мы раскидываем разные подписки по разным деревьям и каждый документ а каждый документ отправляем и в то и в другое дерево эти два способа масштабирования можно можно можно все вмещать до однако совмещать их можно до разумного предела очевидно если у вас будет десяток деревьев дай свой сотни десяток деревьев дублирующих еще десяток для и еще это умножить 10 раз мы получим 100 деревьев для того чтобы увеличить производительность и по правилам по документов 10 раз но то есть по масштабирование ограничения есть но на данный момент производительной системы такого что мы этот горизонт очень очень очень далеко дальше ограничение решения алгоритм который мы выбрали очень сильно очень сильно подобном под наши данные и под наши логические выражения почему смотрите если система у нас система такова что подавляющее большинство запросов отсекается в первом слое дерево не то есть скорость обеспечены тем что мы очень быстро отсекаем если же нашу систему модифицировать немножко чтобы набор данных и набор правил таковы что на первом на первом слое дерево на первом-втором слоях дереву до простых ничего не отсекается мы столкнемся системы что это все будет адски тормозить из-за того чтобы можно сочетать сложные приди сложные свойства считать проверять удовлетворяет ли свойство с предикатом больше меньше да это все сложные операции как только мы до них доходим начинаются тормоза если мы будем находить до них часто и много тормоза будут всегда дальше как я уже говорил данные мы храним не в дереве и не никогда их не пишем непосредственно в дерево просто потому что мы не позаботились о том чтобы эта база данных думала о сохранности данных поэтому когда человек оформляет подписку она первым делом складывается в надежное хранилище москве а уже потом отправляется в дерево да и еще один небольшой минус решение это функции которые вычисляют свойства документа они написаны на том же языке что и все дерево это питон и собственно внутри внутри лежат прямо с сырым кодом соответственно если нам нужно добавить новый функцию вычисляющую новые свойства дерева да нам нужно вот это вот приложение наши перезапустить ну и что же у нас в итоге получилось на данный момент система работает как то так это она она выживает два процессора она занимает два процесса собственном им с масштабировались сейчас по количеству обрабатываемых документов е100 2 2 ядра процессора выживает полтора гигабайта памяти собственно этот миллион документов сутки срабатывает и рассылает 150 тысяч писем в день время ответа базы в среднем 20 8 миллисекунд если помните требования было 50 миллисекунд то есть это в общем мы уложились с большим запасом при этом если вы помните то мы создавали изначально прототип на питон да ну вот он оказался настолько качественного хорошим что мы превзошли требования почти в два раза оставшись работать с прототипом ну и как вы наверное понимаете все это делалось не ради алгоритмических изыскание это делали все ради бизнеса что же мы получили для бизнеса продукт был запущен через 2 месяца после начала разработки да ну разрабатывали мы это командой там из пяти человек и меня вот проект был запущен он работает и по сей день проект окупился в течение в течение пару месяцев ну понятно не положено следить за тем как эти продукты окупаются и этот показатель показался мне довольно привлекательным до создать базу данных за пару месяцев чтобы она еще за пару месяцев купилась это довольно не свойственно для баз данных согласитесь вот кроме того полученная технология открыла дорогу новым вещам продукты например каким ну вот человек приходит на сайт ищет билеты мы запоминаем этого человека добавляем в дерево человек приходит на сайт на следующий мы ему сразу говорим о пока тебя не было тут вот цена вот так вот игралась график там показать все дела новые фичи продукта кроме того вот сама это дерево и фичи на рынке вы это уникальное решение мета поисковиков авиабилетов довольно много momondo skyscanner многое на так такого дерева ну вот по крайней мере дует и конференции не было дальше могут рисовать но эта фича окупилась и вот технологические преимущества мы получили более того пока они его с рисуют мы еще что-нить придумаем собственно на этом все я готов ответить на ваши вопросы если они есть у нас есть несколько вопросов из мобильного приложения просьба у них ответить так смотрите на пути эти отлично все отлично а значит смотрите по по текстовом протоколу ftp то что он текстовый это и боль и радость этого протоколом радость в том что можно работать с мэттом да а если вы вчера слушали доклад про спиде мой вам прогноз и пить и не взлетит также как и тв-6 потому что плюшки которые от него получаются значительно меньше чем чем вещи которые мы которые мы теряем теряем и переходе на спиде именно этот текстовый протокол мне дико нравится тестировать такие системы про просто с командной строки да не нужно писать неких утилитку рулон все отлично работает далее для прототипа конечно всегда берем ее степи но если вдруг производительности и чтить и пик нам не хватило то если производительность и 4 нам не хватило то потом может винить но никогда ни в коем случае не не вначале кроме того кто нибудь помнит какой оверхед дает использование протокола и степью ну вот например скриптовых языках это порядка четверти мили секунды то есть если у нас требование 50 миллисекунд четверть мили секунду в общем не самое страшное дальше я все таки не понял почему нельзя построить такую систему на обычных технологий писать свой значит смотрите очевидно ну вот с теми контрагентами что у нас есть то что мы делаем должно соответствовать очень бизнеса конечно же мы долго и упорно сопротивлялись необходимости необходимости писать писать писать что-то свое мы предприняли несколько попыток смотреть это низкий часть попыток из от команды исходила часть я сам придумывал мы столкнулись с рядом проблем во первых все таки довольно сложно запихать на проверку восковые базу данных мегабайт них документа вот он не предназначен для этого дальше а мы пробовали лениво вычислять например самое простое свойств заправлять его в базу данных смотреть соответствующие предикаты этих предикатов взялся большой список нам приходилось перекидывать данные между сервером базы данных и и собственно приложением вот чисто на этих коммуникациях еще до дохода доктор до 2 предиката мы получали такое overheat что уже не укладывались по времени да почему не использовали сфинкс фильтрация по атрибутам что такое смотрите вот еще раз вот так хитро инверсия с которой мы столкнулись до в дереве мы храним в деревянных по храним именно предикат ну и как вы понимаете сфинкс ну совершенно для других вещей предназначен кроме того смотрите тут так получается что да действительно не хочется изобретать велосипед но и действительно можно было бы еще потратив некоторое время см аппетита может на неё пиджей может на искре но так получилось что логика этих баз данных очень не соответствует логике предметной области да и по зубам с субъективным ощущением и меня и команды мы считали что для преобразования логике пола понадобится сложный неудобный непонятный какой-то механизм прослойки до который который все равно нужно будет нужно будет разрабатывать получилось ли мы бы получили кучу кучу кода да вот вот тот ядро дерево алгоритм который я говорю это порядка двух сотен строчек кода там есть еще немножечко обвязки но согласитесь не с каким сфинксом риск велим v202 сотни строчек кода вы бы не уложились а строчки кода это очевидно сложная система сложность поддерживаемый поддержание системы ну и как-то так можно выразиться спасибо за доклад если я правильно понял то ваше дерево является статическим в том плане что она построена на неких и в листиках и имеет ну более-менее заданный порядок проверок не думали ли вы о том чтобы адаптивно генерировать дерево исходя из селективности тех или иных ну проверок ну например если у нас самолет летит например из какого города в которой летает одна авиакомпания дата очевидно что логично в этом случае проверить пункт вылета сначала досмотрите но тут получилось вот вот это вот упорядочивание упорядочивания слоев дерево конечно же с точки зрения алгоритмический и это интересную программисту до сделать чтобы вот этот порядок вычисляется автоматически конечно но вот так получилось что я бил себя и своих ребят пороком чтобы этого не делали просто потому что вот принять правила как их упорядочивать проще чем запрограммировать эту логику да то есть мы можем создать систему которая которая запоминает историю да там как как что вычисляется но это будет немножко сложнее если мы сели и вот чисто эмпирически зная о предметной области упорядочить и дерево сами и и она стала работать нужной нам скоростью зачем писать что-то еще лучший кот как вы помните это не написанный код но то есть рынок не требует этого роста пока до потребует сделаю но вот пока бью себя по рукам это интересная часть ее интересно запрограммировали сильно интересным но нет спасибо еще вопрос спасибо за доклад очень было интересно но вот такой вопрос у вас на каждом из ловить фильтрации слои дерево вас происходит в какой-то момент либо обрезание документа и прогони проход дальше на в на слои либо его все-таки клонирования с ним ничего потом никогда не планируем то есть соответственно если напрячь человека устраивает что у него есть две пересадки такой документ есть но в другом предикате в этом же слое у нас происходит от сечение по другому условии что ему нужно меньше пересадок то человек который устраивает 2 пересадка он получит документ с одной пересадкой вы меня просто поразили вашу прозорливостью то и это что-то вот эта проблема с которой мы конечно я столкнулся кстати готов сразу вас на работать над ничего смотрите да именно такая проблема есть что мы обрезаем часть документа и и получается что если мы будем его модифицировать возникнет возникнет необходимость планирования документ большое будет копироваться в памяти до поэтому мы делаем так что мы не заменяем вот это вот это вот удаление документов до фильтрации это всегда только удаление она происходит всего в одном хэши да и получается что мы правим только про правил только один хэш в иерархии но не правим не правим все дерево да то есть вот это вот копирование мегабайтами грани происходит то есть из дерева дерево подается вниз либо как есть либо с частью части удаленных ключей при этом копирование там не происходит а не было ей просто сделать на эту же структуру дополнительно mapping который бы разделял уже нам средств на следующих уровнях для раздельных клиентов у средства примерно появилось второе дерево дополняющий другую логику но клиент получал больше информации который бы он мог воспользуется например если он хочет добраться в например из москвы до пхукета но хотел бы заехать в сеул ким образом да и то почему бы нет на самом деле с помощью этого же дерево такая проблема замечательно решается да то есть мы могут быть требования что есть есть пункт пункты пересадок до человек может потребовать чтобы в его билетов участвовал какой-то аэропорт аэропорт сюда кстати сил мало кому интересно интересен всем дубай на вот но это можно это можно прямо сейчас в этом дереве собственно там где-то и никого не тот просто еще один еще один из юрт в этом выражении но это будет это будет deathwing это будет другое выражение нет это будет прямо из юрт в этом выражении но все равно это это нечто достраиваем и и они и скорее всего это нужно будет новый проход поняли реву нет мне нужен смотрите что мы проверяем мы проверяем что в конкретном берете существует конкретный аэропорт то есть это операция операция эндо она печальна вписывается в это дерево да просто нужно вот это запрограммировать новые логические операции в него дописываются дописываются довольно просто с фильтрация my в общем это делается но правда пока пока пока не просили нечестно ждем запросу томат маркетологов каких-нибудь на новые на новые свойства в дереве но не просили пока"
}