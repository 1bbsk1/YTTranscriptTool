{
  "video_id": "tYXvr7BWULQ",
  "channel": "HighLoadChannel",
  "title": "TechTalk \"Обновление ПО и управление зависимостями\" / Сергей Богданов",
  "views": 579,
  "duration": 599,
  "published": "2025-01-17T02:36:03-08:00",
  "text": "Всем привет С вами Андрей Смирнов и H п+ сегодня с нами Сергей Богданов главный технический руководитель разработки приложений в Газпромбанк тех Серёж Расскажи пожалуйста чем ты занимаешься в газпромбанке Я занимаюсь разработкой сервисно цифровой платформы Это новая система розничного ДБО И помимо того что она ещё является таким техническим локомотивом который показывает остальным системам Как нужно реализовывать энд и поэтому мы регулярно проводим технологическое обновления и мы регулярно обновляем весь стек Какие вообще сложности у вас появляются Когда вы обновляется технологический стек Легко ли это делать на таких больших масштабах мы уже набрали большой опыт для нас в принципе легко но иногда бывают сюрпризы вот в частности мы сейчас вот ведём обновление с семнадцатой Явы на двадцать первую и оказалось что это гораздо сложнее чем бы это было с восьмой на одиннадцатую или с одиннадцатой на семнадцатую А в чём разница Казалось бы даже разница по числам между этими Ява примерно Да это один лтс релиз на другой лтс релиз до этого мы переводили всё было понятно всё было ожидаемо А тут мы короче начали обновлять и потянулось за дцать первой яво сразу же надо обновлять всё И при этом у нас совместимость не будет соблюдаться нам нужно сразу фактически новую систему выкатить и Для нас это было неожиданно Вот сейчас как раз разгребаем И какие выводы Вы сделали Каким образом можно было избежать таких проблем как с этим обновлением Да у нас есть регулярные мероприятия на которых мы обсуждаем наши проблемы это для нас очень полезно У нас есть комьюнити где мы как раз можем это делать и когда вот что-то такое происходит то мы собираемся и там кто-то делает доклад Вот я как раз делал такой доклад и пока его готовил провёл анализ что же там произошло Чем отличается обновление на двадцать перво Ява от там одиннадцатой например очень интересные выводы мы сделали вот предположим если есть у нас какая-то система Она состоит из разных компонентов и мы их должны обновлять по частям потому что мы не можем взять там скажем на выходные там на 3 дня Всё вырубить чтобы всё обновить нам нужно делать обновление маленькими кусочками чтобы в каждый момент времени у нас всё продолжало работать вообще мы должны обеспечивать 24 на 7 с пятью девятками и это нам удаётся и вот у нас есть какие-то компоненты они друг от друга зависят например есть компонент А и компонент б компонент б от компонента а зависит и нам нужно обновить их чтобы реализовать новую фичу который их оба затрагивает и А и Б И вот как нам нужно это делать обычно Если всё нормально Мы сначала берём вот компонент а от которого зависят остальные в нём эту фичу реализовывали у нас получается какая-то версия А1 который продолжает работать с прежней версией компонента B значит система будет А1 и B всё нормально после этого можно переходить к обновлению компонента B реализовывали в компоненте B новую фичу получается какая-то версия B1 и у нас получается А1 B1 в которой новая фича уже работает это когда всё нормально а здесь получилось что при обновлении компонента а обнаружил что он не может работать с компонентом B э А1 и B несовместимы оказались и тогда надо искать другой migration path Ну можно наоборот наверное сделать да то есть получается на надо идти по-другому то есть мы выпускаем B1 который какое-то время будет работать с компонентом а но она уже будет готова для работы с компонентом А1 и вот у нас получается система ab1 а потом через какое-то время мы обновляем а компонент у нас получается А1 и B1 то есть результат одинаковый Но вот промежуточный шаг он разный тут А1 а там А1 Это только с виду кажется что результат одинаковый у нас в первом случае после выкатки двух релизов получалась обновлённая система с компонентами А1 и B1 и во втором случае мы обновились у нас получилось а11 но между ними тем не менее есть принципиальная разница Дело в том что новая фича которая реализована в А1 она в первом случае уже работает а если мы обновлялись в другом порядке то у нас новая фича не работает мы просто Обновили компоненты а новые фичи Мы ещё не активировали это изза проблем совместимости изза того что сча выпустили компонент должен был работать совместно с компонентом а от которого он зависит а там этой фичи ещё нет это значит что нам для включения новый фичи нужно сделать ещё одно обновление лишний шаг Ну да ну та а если этих зависимостей много то тогда это может реально потянуть за собой очень много проблем в общем-то лучше так не делать К сожалению в современном по мы с этим сталкиваемся так случается вот мы короче с ребятами обсудили на нашем вот внутреннем тиктоке мы сделали следующий вывод что Несмотря на то что вот в серьёзном коммерческом там по или в он Source нам такое допускается Мы у себя такое допускать не должны если у нас есть какие-то компоненты которые друга от дружки зависят мы их должны обновлять в определённом порядке Мы ещё провели анализ Почему вообще может так получиться что вот у нас А1 и B несовместимы и выявили две таких причины первая причина - это когда в компоненте а от которого всё зависит ломается совместимость То есть была там какая-то фича которой пользовались и в новой версии она была сломана отключена удалена и так далее А второй вариант когда вот потребитель который пользовался этим компонентом в нём просто захард Коди версию то есть поставили искусственные ограничения не позволяющие обновляться иногда такое делают К сожалению и вот это приводит к тому что приходится лишние шаги делать по обновлению И то и другое плохо И несмотря на то что вот так сечас к сожалению тся мы так делать не должны и мы как раз договорились что если где-то у нас такое произойдет то мы не принимаем это типа ну ладно пусть Значит судьба такая Нет мы считаем что это баг вот серьёзный баг это нарушение наших стандартов разработки если кто-то такое допустил ему делается бак репорт мы требова чтобы он исправил обратную совместимость искусственные оять компонент от которого все зависят а потом зависимые компоненты правда здесь тоже есть сюрпризы Какие вот Дело в том что если мы обновляем скажем Яву играл Тут всё понятно Ява от грала никак не зависит а грал от неё зависит тут мы можем взять нарисовать два компонента провести стрелочку сказать Вот компонент А вот б Вот вот зависимость А если мы берм бизнес какие-то микросервисы Оказывается там это не так тривиально понять кто от кого зависит какой-нибудь там компонент там управляющий банкоматами и компонент управляющий картами кто из них кого зависит иногда вообще не очевидно и разные команды могут понимать по-разному и важно как раз чётко представлять какие у нас зависимости в каком они направлении находятся и не допускать циклических зависимостей вот за этим тоже надо следить и насколько при этом вот после вашего исследования вы поняли что в современном по такими проблемами вки собственные пакеты страдают где есть циклические зависимости где есть вот проблемы Вроде вот того что ты описывал с этими схемами Да вот к сожалению в осор допускаются такого рода нехорошие вещи и главное Они же показывают всем пример Типа если такое сделали там в яве котлине Град то значит нам можно вот и это не очень хорошо Хотя если подкопа там на самом деле скажем в грал за сабли в комьюнити барер о том что Ребят вы вообще вот так вот выпустили вы это сделали зря Давайте что-нибудь придумаем чтобы такого не было сделали ли они что-то Ну они там написали что это мы не виноваты у нас внутри забаню них проблема И вот туда и сабмит эти бак репорты и там куча ссылок значит в котлине что-то не так в амрид что-то не так это вот они виноваты а мы типа тут ни при чём Так что тут перевод Стрелок и так далее Тоже имеет место то есть в принципе если ты от какого-то компонента зависишь то не надо так вот жёстко в него Как грал поступил например и забаню он забаню другие компоненты и для того чтобы обновить что-то одно Нужно обновить целиком грал и вместе с ним все остальные компоненты обновятся и тогда у нас как раз происходит каскадные изменения это практиковать вот не стоит и надо как раз вот Не брать пример плохой пример надо брать только хороший а когда сам ведёшь какую-то разработку надо ещё и пример показывать Когда будет пример Как надо делать тогда есть шанс что со временем это распространиться на все остальные продукты супер спасибо большое что поделился решением проблемы Здорово что Вы у себя в газпромбанке её подробно разобрали вот а на этом мы заканчиваем тикток С вами был Сергей Богданов и я ведущий Андрей Смирнов пока-пока"
}