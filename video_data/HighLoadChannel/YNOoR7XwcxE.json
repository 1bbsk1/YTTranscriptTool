{
  "video_id": "YNOoR7XwcxE",
  "channel": "HighLoadChannel",
  "title": "За счет чего Tarantool такой оптимальный / Денис Аникин (Mail.Ru)",
  "views": 4084,
  "duration": 3013,
  "published": "2017-04-22T14:48:17-07:00",
  "text": "сегодняшний доклад будет посвящен таран Но на самом деле Обычно я всегда рассказывал про кейс про что-то такое что Что вет пользователь сегодня буду больше рассказывать про его внутренности на самом деле когда когда я первый раз увидел мне как бы не то чтобы это показалось подозрительным потому что вс-таки я уже уже до этого программировал больше чем 10 лет и примерно понимал что можно выжать из железа при оптимальном программировании при оптимальном коде но всё равно мне показалось подозрительным Как как так получается что он такой быстрый Уно ЕС все ба данных мот работать скорою Ну в лучшем случае десятки тысяч запросов в секунду То сотни тысяч и вплоть до миллиона Вот и поэтому Прежде чем начать применять его в продакшене в почте И потом в Облаке Я всё очень внимательно изучил и выяснил вот именно как как таран устроен внутри и что его делат таким оптималь други Поль тоже есть же такое же подозрение То есть что-то он какой-то слишком быстрый и както это подозрительно кстати говоря поднимите пожалуй кто ни разу не слышал Кто не слышал А те кто слышал продакшена Поднимите руки не очень много вот то есть на самом деле скорее всего не применяете в том числе и потому что вы не понимаете А как он так вот Такой быстрый а все другие медленные и вот за счёт чего а е если это действительно та причина по которой вы пока его побаивались применять тогда вы пришли в правильное место вот и я надеюсь что я сегодня Вам расскажу и объясню Ну конечно не всё потому что на самом деле база данных - Это огромный продукт в ней Ну в базе данных очень много фич очень много функций и рассказать про ВС про ВС там за 40 почти невозможно поэтому Просто я расскажу про основное вот ну что ж Поехали Да вот ещё я кратко хотел рассказать в двух словах чего ожидать И чего не ожидать от доклада ожидать конкретику то есть конкретику Почему такой быстрый почему там он быстро читает быстро пишет быстро стартует и так далее при этом Ну и какие на самом деле были причины у нас в mailru сделать его и Именно таким быстрым И чего не ожидать то есть не ожидать самом данных для своего кейса и в общем мы не претендуем на то что быть универсальной база данных для всего вообще как раз опять же не стоит ожидать Ну каких-то новых там структур или новых алгоритмов потому что наверно основная си тарату в том знал а в том что они правильно применяют и компот уже существующие алгоритмы и они на самом деле пишут код очень оптимально в том смысле что ну вы все знаете там О большое от вот такую как бы нотацию о большое Кто кто про это не слышал о большое А кто слышал Супер Ко Говорите что Ну если там в два раза наме там О большой ан в два раза больше набор данных в два раза дольше работает алгоритм Но вот сколько он работает конкретно это неизвестно То есть можно написать его оптимально А можно сделать там кучу копирования и прочих вещей которые не повлияют на его апатичен но при этом повлияют на просто скорость работа вот так вот в тарантуле тоже очень много уделено вниманию Вот именно вот этому коэффициенту который стоит перед О большое то есть на которой всё умножается Вот но на самом деле так это теория А сейчас мы переходим потихоньку к практике начнём как бы с самого главного что Тарантул он хранит всю копию данных полностью в памяти То есть это означает на самом деле не то что когда машина рестар то всё теряется а то что просто ко данных есть в памяти данные и на диске тоже есть естественно но при этом все всес все данные Они лежат всегда в памяти и никогда оттуда не выгружаются тут тут стоит стоит сделать оговорку что тут речь именно про оригинальный движок Тарантула который который называется КС который вот по сути всё всё хранит в памяти и который in но у тарантула появился ещ недавно дисковый движок Вот как раз кость про него сегодня расскажет сразу после меня про устройство дискового движка который позволяет не всю копию данных хранить в памяти а только её часть Вот тут я буду касаться только оригинального движка Тарантула то есть только inem движка вот ну очевидно что ну как бы наверно для всех что память быстрее чем диск Поэтому если Всё лежит в памяти то в общем всё всё происходит быстро а такая картинка в принципе символизирующая это то есть tantal всё читает из памяти а дисковые базы данных там mysql pog Oracle SQL сервер все Они читают с диском поэтому Тарантул быстрее Это вроде бы очевидно Вот Но есть нюанс Вот вы наверное так вот сейчас сейчас сейчас на меня смотрите да и с таким прищуром Да а вот как же как же кэш Ведь у у дисковых баз данных у них есть кэш Вот и почему тем не менее таран быстрее ведь дисковые базы Они же кэширует всё да то есть они по сути тоже ну как бы не всё каширу но самые популярные запросы каширу значит они тоже должны быть такие же быстрые Вот вот как вы думаете то есть в чём В чём отличие Когда у вас кэш от того что когда данные Просто просто в памяти Есть ли какое-то отличие там с точки зрения производительности устаревать может да да вот сейчас сейчас сечас сейчас как раз про это и расскажу то есть вот Давайте посмотрим как как Тарантул взаимодействует с памятью он просто читает данные из памяти которые там всегда лежат уже подготовлены в идеальном формате который позволяет их быстро читать быстро читать быстро искать быстро делать делать запрос по индексу А теперь посмотрим как работает дисковая база очень примитивная схема естественно Ну все базы как бы они разные у всех ш кэш устро по-разному но в целом логика такая Сначала мы смотрим Ну если да то есть допустим приходит от пользователи чтения там какой-нибудь сек звёздочка там бла-бла-бла Сначала мы смотрим Есть ли данные в кэше Если есть то мы лезем в кэш и возвращаем если нет то мы читаем с диска пишем то что прочитали в кэш ели кш уже забит а кэш он как бы всегда забит по определению потому что там он он всегда полный в этом его смысл Значит мы вытесняет вот вся эта длинная цепочка причём надо заметить что это же всё идёт не бесплатно считали с диска в какой-то буфер взяли из этого буфера скопировали в кэш вытеснили старое освободили память записали новые выделили память освобождение выделения память это дорого это это всё копирование это всё поиски это всё не бесплатно это всё тот тот самый коэффициент который перед О большое то есть вот много-много действий нужно сделать То есть оно по сложности наверное ну там обращение по какому-нибудь по в хш таблицу Да в какой-нибудь ш индекс оно по сложности возможно плюс-минус или е дерево логарифмическое Но вот это ВС Вот вот то что умножается на большое Огромно количество работы плюс данные они на диске лежат в одном виде вше лежат в другом виде потом каширу часто по страницам чит соответственно мы загружаем чуть больше чит выделяем памяти чуть больше освобождаем тоже чуть больше всё надо понимать что даже если вы попали в кэш то есть вот вот произошёл Рид и данный уже в кэше то у вас процессор в фоне всё равно делает вот всё вот это вот все всю Вот эту вот цепочку Она всегда делается в фоне без остановки Поэтому если данные даже уже в кэше то процессор или другие его ядра они чем-то заняты а раз другие ядра чем-то заняты то происходит блокировка происходят мьютексы вот много-много работы в общем по сравнению вот просто с тем чтобы считать из памяти и всё вот вот такия вот такая вот как бы штука да по поводу кэша то есть на самом деле почувствуйте разницу всегда в памяти и Кэш - это не одно и тоже это разные чуть-чуть вещи а тепер а теперь давайте про запись Ну то есть почтению ВС более-менее Понятно читает из памяти быстро а что же вот на самом деле Тарантул Он работает на запись почти так же как на чтение при этом он стн все данные вс всё равно на диск Вот вот как вы думаете почему он такой быстрый Хотя данные всё равно сохраняются на диск при записи есть идея последовательно Да ключевое слово последовательно сейчас я это покажу то есть что делает тарату когда когда выполняет транзакцию он грубо говоря её выполняет в памяти и записывает её в лог транзакций в лог транзакций он её записывает только с целью recy То есть если всё упадёт чтобы подняться из Лога всё накатить и привести базу данных в то же самое состояние в котором она была до старта просто пишем Файлик последовательно нуно и все вы знаете да что последовательно вот тут правильно сказали слово последовательно что последовательно файл пишется очень быстро вот а тут вопрос там это это немедленно да то есть это Это достаточно быстро на магнитных дисках это где-то 100 мб в секунду можете прям она на SSD это ещё больше это там 250 Мб в секунду на самом деле можете прямо сейчас это проверить вот прямо вот на макбуках там SSD обычно стоят просто как бы сделайте огромного файла там что-нибудь или там CP из из там куда-нибудь в файл или из куда-нибудь файл и посмотрите как это будет прямо сейчас это будет там Адские сотни мегабайт в секунду это на SD на магнитном диске чуть медленнее но всё 100 мб в секунду Тае 100 ВМ е транзакция Например размер транзакции 100 байт что в принципе много да то есть какая-нибудь там транзакция по обновлению чиселки это просто Ну там например там update там что-то Set Ke равно value нужно просто записать Ke И value если это чиселки то это там несколько байт буквально Но даже если транзакция 100 байт это по сути 100 вернее миллион транзакций в секунду То есть Ну пиковая производительность будет миллион транзакций в секунду это такая производительность которая обычно никогда не нужна она очень большая и обычно узкое место даже и не диск Там на самом деле а процессор или или ампер память а то есть просто не хватает памяти чтобы хранить столько данных чтобы сделать столько столько транзакций на на на одной машине вот а как же дисковые базы данных пишут на диск почему они не могут также оптимально писать Как вы думаете точно абсолютно точно И кстати кстати говоря А почему они данные сбрасывают они могут тоже только влог писать как Аран не на кат чтение Да смотрите на самом деле Ну сейчас сейчас я про это расскажу Смотрите Они делают ВС тоже самое что иним они пишут тоже в лог транзакции потому что как же без этого Потому что Лог транзакции это единственный способ как бы восстановить базу данных после после Крэша и Кроме этого они ещё обновляют данные данные на диске Как они это делают Ну они обычно используют старые добрые б деревья это это на сегодняшний день самая популярная структура данных для хранения на диске Хотя надо сказать появились уже новые структуры данных типа как раз ко про это сегодня расскажет то есть они применяются вот уже в таран дисковом движке они применяются в от Фейсбука сегодня по-моему тоже будет выступление марка калаха на эту тему они применяется в у Гугла в lel db но в принципе все традиционные обкатанные базы данных они используют там по Oracle все построены на деревьях вот дерево это по сути Ну как дерево только у него только оно как бы такое рно у него в каждом узле блок данных и дальше Идёт много ссылок на последующие блоки и за счёт ности оно очень короткое но но всё равно чтобы чтобы считать данные которы которые хранятся здесь нужно сделать 2 чтение с диска и эти чтения с диска происходит медленно вот а тут самый главный вопрос а вот правильно было было сказано что б деревья у баз данных у дисковых нужны только для того чтобы данные потом считать если бы дисковые базы данных хранили бы как Тарантул всю копию данных в памяти То есть если бы они были тарантулом то им не надо было читать а когда не надо читать то то не надо и писать то есть они пишут в этот в эту структуру только чтобы потом считать только ради этого это не для recy для для Rec они используют также как тара ло транзакций и вот это просто делает их их медленнее на на запись просто потому что они дисковые как бы не потому что там плохие программисты они там очень хорошие естественно просто потому что они дисковые просто потому Вот такая структура данных она с одной стороны Она хороша она не приводит к линейным поискам Но с другой стороны Она приводит к случайным обращениям к диску на магнитном диске это всего 100 обращений в секунду максимум Вот вот как вы думаете почему магнитный диск позволяет читать писать данные последовательно 100 мб в секунду а случайно обращаться всего 100 раз в секунду Гать Да потому что это приводит к физическому движению головки диска и головка диска она не может очень быстро двигаться то есть 100 раз 100 раз в секунду это и так очень много Да просто Представьте как бы себе это Но если вы читаете вот банально 100 байт которые разбросаны по всему диску вы будете их читать или писать со скоростью 100 байт в секунду тоже Приведите простой тест можете взять там написать там простую программу на си взять какой-нибудь Файлик там неско гигов чтобы он не поместился вш и случайно какие-нибудь байты из него почитать или пописать у вас будет в лучшем случае 100 раз в секунду а Но если фрагменти будет ещё хуже потому что тогда при каждом обращении ещё будет несколько сиков это будет там несколько десятков раз в секунду Да это отдельная проблема что фа е ится вот э вроде как базы данных они умеют с этим с этим бороться они по сути создают какой-то там большой сразу файл заранее и правят его куски но они его ужи мают там раз раз раз в какое-то время чтобы не ну чтобы как бы не было фрагментации вот на SSD это чуть быстрее но тоже самое это там ну тысяча раз в секунду ну то есть как бы вот опять же почувствуйте разницу то есть в мым Милн тци секунду вот в Table Space вот в этот в B3 Да мы пишем там ну на HDD несколько десятков Ну 100 раз там на SSD Ну 1.000 раз То есть просто там разница на три порядка на три на четыре порядка Вот теперь пойдём дальше про Старт то есть то смотрите я рассказал про прочтение и про запись Тарантул быстрее читает потому что всё in Memory и in Memory - это не кэш потому что это гораздо меньше работы чем кэши акши там выделять освобождать менять структуру данных копировать и так далее и Таран быстрее пишет Потому что ему не нужно ать tace потому что у него диск только для Recovery а не для выполнения транзакций теперь про Старт пойдём Как происходит Старт у тарантула у тарантула есть Лог транзакций есть ягодня не говори скажу snapshot это состояние базы данных на какой-то момент времени а tantal периодически сбрасывает Всё своё состояние на диск для того чтобы Лог транзакции сильно не разрастался вот чтобы потом можно было легко восстановиться соответственно запуск Тарантула - это просто чтение двух файлов причём файлы не фрагментированные и линейные то есть в смысле чтение из них происходит линейно это просто от начала и до конца прочи snapshot от начала и до конца проче слог и в процессе прямо этого чтения применить вс всё в памяти Вот вот что такое Стар Тарантула всё по сути это ну как быстро там это на опять же на магнитном диске это 100 мб в секунду на S там 200-250 меб в секунду вот а как это происходит у у дисковых баз данных на самом деле вопрос очень интересный потому дисковая база данных надо дать им должные они стартуют почти моментально Потому что им не нужно считывать память Snap Но что происходит потом вот допустим у вас там по или mysql они стартовали А что дальше они Они тут же работают быстро во прогревается кэш это жесть пока кэш пока кэш не прогрет то сечас находимся на конференци нагрузкам если у вас высокие нагрузки то конечно у вас используется кэш вовсю и это означает что без кэша база данных Нормально в принципе не работает Она просто не справляется с нагрузкой да да можно как раз тут вот написано если небольшой объём Да Смотрите бывалые dba Они коне умет принудительно прогревать знают разные техники и так далее факт остаётся фактом Как как он прогревается от Ну обычно да то есть как как как прогревается кэш да Ну вот примерно так он прогревается То есть как бы не быстро то есть то скажем так пользователь идёт в базу данных что-то у него просит база данных случайно читает что-то с диска случайно потому что данные не в кэше и потом ему отдаёт и кэширует потом происходит следующий запрос он проходит в другое место диска опять случайно да можно пригревать можно делать к файлу индекса можно делать много много много всего но факт остаётся фактом когда данных много то горячие данные они вот те которые должны быть в кэше где они находятся на диске Никто не знает Вот как это узнать вы это не знаете пока пользователи не начнут их запрашивать но вы знаете что индекс - это горячие данные Да можно иде такая в котором лежат и горячие данные они где-то находятся случайно и чтобы прогреть кэш нужно Ну прочесть каким-то оптимальным алгоритмом эти случайно лежащие данные что конечно гораздо медленнее чем просто прочесть вот опять же мы вернёмся к Тарантул чем чем просто прочесть два файла линейно Вот вот они горячие данные других у Тарантул это и нет он он как бы для горячих данных а у дисковых баз данных нужно соответственно эти эти горячие данные как крупицы где-то где-то выискивать вот по практике mailru Ну наши там супер супер крутые админы они на самом деле вот всё что могли выжать из My это там 1-2 мегабайта в секунду ну как бы там на наших объёмах там у нас там 100 мегабат Рабат базы вот больше чем с этой скорость не получается прогревать там со всеми соми техниками что собственно не удивительно потому что данные я вот ещ раз скажу они разбросаны горячие данные разбросаны по диску в разных его местах нужно делать хики нужно делать движение головкой там условно вы килобайт там или 10 Киба данных прочли сделали движение головой потратили миллисекунду ещё мил там тире 10 КБ тратите миллисекунду у вас получается 1 Мб в секунду упираясь того что кэш и всегда в памяти - это разные вещи то есть Тарантул хранит всегда в памяти то что надо и оно быстро стартует быстро чтение быстра запись а диско база данных устроена по-другому они рассчитаны на то что данные лежат на Дис а в кэше что-то такое иногда есть и соответственно эти данные они разбросаны прямо среди дисковых данных не лежат где-то отдельно поэтому медленно Старт происходит вот разница в 100 раз где-то Ну да это вот как раз то что то что я сказал что что Тарантул группирует все горячие данные в одном месте просто by Design Вот теперь давайте поговорим олан вот Илин если правильно это сказать по-английски latency - это время между началом началом запроса и получением результата а на самом деле я тут когда буду рассказывать про я буду его сравнивать не с дисковыми базами данных потому что ну там всё понятно а я буду сравнивать его с другими inem базами данных с чего всё началось когда-то давно у нас в mail каждую ночь мы видели вот такие вот пикин то есть почему-то периодически у нас вырастала там в 000 раз время время выполнения запросов то есть оно было там не миллисекунды оно было секунды тьму проходит причём происходит это по ночам Ну то есть это явно не пользователи в этом виноваты это что-то у нас внутри вот мы стали с этим разбираться и в общем мы выяснили что причина на самом деле она простая это спшн база данных в отличие от дисковых и это их минус да такой очень известны они вре дан себе работает она изменяет данные в Б деревьях она пишет влог транзакций ей не надо сбрасывать из памяти всё состояние на диск периодически потому что Просто у неё данные уже хранятся и так на диске в том в том формате в котором они пригодны для чтения А у баз данных у них не так они должны раз-то время спш Потому что если этого не делать то будут скапливаться огромные логи транзакций которые будут очень долго применяться вы понимаете да почему Лог транзакции применяется дольше чем snapshot понимаете Ну ну в снапшоте тоже ну по сути как транзакции О да то есть Может быть реально 50 там 100.000 операций к одному и тому полю и они в логе транзакции будут каждой операции идти отдельно и это нужно всё накатывать А в снапшоте она будет как одна просто текущая последнее значение вот поэтому бас нужно постоянно снапшоте а как оно происходит на самом деле почему спшн всё тормозит Ну Казалось бы ну снапшоте база данных и снапшоте она же спш на диск Казалось бы диск узкое место но она же работает с памятью Почему спшн может тормозить всю базу данных блокировка да на самом деле тут интересно ну то есть это блокировка Ну такая очень интересная блокировка на самом деле Чтобы не снапшоте с блокировкой всей базы данных Мы в своё время это сделали форком форк - это такой системный вызов в линуксе там или в юниксе который создаёт просто копию процесса То есть он создаёт дочерний процесс целиком из контекста родитель про как мы как мы делали спш мы делаем создаём дочерний процесс имеет все данные которые имеет его parent Да и спокойно ну пишет эти данные на диск а пан в это время обслуживает транзакции но оно при этом тормозит Почему копирование а пря тут так написано на самом деле как происходит он во-первых Он копирует Крипто всех страниц от пантов чада А если у вас там сотни гигов памяти на машине то это там десятки миллионов страниц да Или миллионы страниц десятки наве миллионов страниц там под 100 Милн страниц там 4 Киба потом после копирования вот всей как бы этой Марай начинает работать cy onr что это такое Это при любом изменении одного даже байта в панте или да изначально йд когда стартует он наследует все прямо прямо полностью все все страницы памяти от панта То есть у них общая память там полностью шарена но как только parent или у себя меняют хотя бы оди байт Неважно где это страница полностью копируется а страница - это 4 КБ таким образом чего происходит в таран в parent идут массовые апдейты он он апдейт там см и и на каждый апдейт 4 КБ вот тех нескольких байтов которые апдейт и вся страница она копируется пришёл апдейт ещё в какое-то место опять страница то есть понимаете да то есть на грубо говоря копируется не знаю в сотни раз больше чем меняются данных соответственно даже от небольшой нагрузки происходит Ну просто как бы вс всё уходит по цпу Вся машина Вот кстати говоря эта проблема она у других у других баз данных насколько мы знаем Пока не решена они делат также включая вот но мы как бы решили эту проблему в какой-то момент решить вот я надеюсь что все остальные тоже последуют за нами и тоже будут такие же оптимальный а то есть вообще у вас У вас есть идея как это улучшить То есть как вот избавиться вот этого копирования который происходит при снапшоте А ну да это это хорошая идея А как тогда вот то есть вы понимаете да Что данные в панте постоянно меняются и мы не можем спш данные которые меняются там будет фарш мы должны иметь некое целостное состояние базы Ну в общем новый старый на самом деле основная идея но только нело по сути это собственный механизм C on который конечно не подменяет сист но который Просто реализован внутри тарату и кото страницами а с полями и с записями А это чем-то похоже на а на multiview concurrency Control Если Вы слышали такое слово это а во многих баз баз данных таким образом устроены транзакции чтобы не блокировать чтение когда идёт запись вот мы тут в принципе ну делаем тоже самое Да наша наша идея - это не не блокировать А запись в Тарантул пока идт чтение и вся база данных читается и дам на диск идея очень очень простая мы во время спшн любое изменение любого элемента данных оно приводит просто к копированию этого элемента прямо так же как C только не вся страница копируется а копируется только маленький элемент Вот и соответственно Ну от этого прот так вот очень крат при этом Ниго cost в виде копирования таблицы дескрипторов просто начинается спшн Начинаем потихоньку на каждое изменение дела делать копию элемента которые меняется вот приме примерно так это происходит то есть есть старая версия новая версия как бы что-то изменилось отковырять идут в новые версии старые версии они не меняются старая версия базы она целостная и она по сути мы не копируем всю базу мы копируем только то что поменялось и только то что только прям те байты которые поменялись Ну те записи Да скажем так Или те поля которые поменялись вот собственно Вот это поре эту спайки пропали Это начиная с версии 166 То есть это где-то наверное месяцев де назад я уже не помню ну плюс-минус а а потому что сшт был включён ночью если он был включён бы днём то было бы всё ещё хуже Ну это видите это всегда трейдо или или как бы раньше заметить но больше навредить или меньше ну как бы это всегда проблема или или мы катим всё сразу на всех тут же всё падает откатывать на а там на 1% и мы об этом там когда ещё узнаём но при этом это это 1% он страдает То есть как сделать лучше тут Ответа нет Нужно всегда смотреть вот а то есть мы поговорили про чтение про запись про йн Давайте теперь значит Ну наверно последняя тема на сегодня 36 минут уже прошло надо мне ускоряться это узкие места в базе данных на самом деле узких мест конечно очень много мы не будем тут все узкие места освещать осветим такое самое узкое скажем так вот смотрите вот есть Ну там в c+ в Джаве и в других языках встроенные структуры которые очень похожи на базу данных например в c+ есть scd unap это хш по сути это по сути как индекс то есть там можно писать ключ значение быстро читается быстро пишется всё всё за о от единицы и всё хорошо это по сути Как как база данных токо Она находится в внутри вашего процесса вот э база данных она работает скорою можете проверить опять же я проверял это на макбуке Она работает со скоростью 2 милна операций в секунду на одном ядре на самом деле можно ещё больше ускорить Я просто как бы не заморачивался сильно просто чтобы дать вам оценку миллионы операций в секунду ну то есть просто вы делаете цикл и начинаете там как-то случайно это хш там читать писать вот при этом индекс в базе данных все знают что он С такой скоростью не работает лучшем случае там ну 10.000 операций на на одном идре Ну там 20 То есть это вот это отличие на на на два порядка и вот странно получается смотрите стандартный c+ плюсны хэш который уже есть использую не хочу в 100 раз быстрее чем такой же ну по сути там хэш но внутри базы данных Вот почему так вот а Ну вот есть там на самом деле есть одно одно слово которому это всё объясняется и это слово системные вызовы А значит что такое системные вызовы системные вызовы - это когда процесс обращается в ядро с целью чтобы оно ему что-то сделал чего он сам сделать не может там считать файл записать файл считать из сети там и так далее а каждый системный вызов - это зло а Ну во-первых на самом деле откуда системные вызовы берутся ну вот смотрите это Это минимум минимум пять системных вызовов нужно сделать на обработку одной транзакции в базе данных потому что нужно считать из из сети Ну обязано да считать как бы наш запрос из сети Без этого никак дальше мы должны данные заблокировать это тоже системный вызов это КС дальше мы должны с ними что-то сделать дальше мы должны их разблокировать опять даль мы должны обязательно записать вло транзакцию и да даже пи че в T а пишем только вло транзакции мы должны ещ дать ответ в сеть то есть меньше пяти системных вызовов сделать очень трудно на самом деле их гораздо больше можете поть Oracle там их будет на каждый запрос Ну на самом деле 10 там плюс плюс-минус вот и Memory он находится в том же адресном пространстве То есть это вот на самом деле это вот это вот который работает в том же адресном пространстве Что работает база Ну что работает Код да А можно можно долго обсуждать Что лучше потому что когда у вас код работает вее Ко когда у вас база данных работает в том же адресном пространстве что и код у вас У вас как бы теряется сетевое взаимодействие вы не можете из другого места туда ходить то есть а если вы доходите из другого места И по сети то вы получаете вот вот это всё да да вот сейчас я про это расскажу Казалось бы да Вот что мы сделали да Ну почему системные вызовы дорогие тоже очень важно просто может быть это не всем Понятно Потому что происходит очень много копирования чтобы чтобы сделать вызов нужно войти в ядро выйти из ядра и очень много данных скопировать потом восстановить вот по сути вся эта работа с делает из из Def Ну вот то что-нибудь такое самое простое и читает оттуда по одному байту вот чтение одного байты из Def Z которые на самом деле никуда на диск не ходит Оно просто вам возвращает нолик там оно оно внутри почти ничего не делает ядре оно оно будет происходить Ну хорошо Если там миллион раз в секунду То есть даже простейшей системный вызов он работает медленнее чем полезный вот этот вот std unordered Map который вс нашу чёрную работу делает даже один а их тут пять и на самом деле больше Вот то есть то есть представляете да то есть налог на системный вызовы он огромен он там не знаю 90% да там 95% то есть просто огромен соответственно значит что что мы решили ну как мы эту проблему решили в тарантуле мы просто а сделали не то чтобы сделали Мы подумали А почему бы на один системный вызов не делать больше полезной нагрузки то есть идея такая что мы сот используем параллельно То есть например если есть какой-то какой-то клиентское приложение вот все все клиенты которые стоят на на одной машине Они все пишут в один сот параллельно Они конечно на клиенте делают много системных вызовов й но но Тарантул за один Рид считывает из сети сразу все запросы которые там параллельно к нему пришли за один Дальше он эти запросы параллельно обрабатывает там за одну блокировку на самом деле в тарантуле там блокировок нет Там там такой подход как бы ну специальный который делает его работу без без блокировок Но даже если бы они там там были мы как бы пачку запросов приняли заблокировали выполнили разблокировали соответственно Меньше меньше меньше системных вызовов дальше одной пачкой всё записали на диск то есть тоже один й один сий на много много много транзакций и одной пачкой всё отдали тоже so вот выглядит примерно так это по сути несколько Ну там несколько фредо каждый из из которых просто ну делает всю работу параллельно То есть это клиент клиент параллельно из из разных там скажем так процессов Да фигачит всё в один сот параллельно прямо таран это всё ловит одним Рим отдаёт это дальше на обработку транзак процессору Он обрабатывает in Memory дальше эту же пачку одним райтом Ну в смысле как бы пачку отдаёт этому реду ТД тред пишет на диск одним райтом Дальше он всю пачку отдаёт назад опять же весь Communications и все блокировки которые есть если они есть они пёр как бы пачка не пёр один запрос а пёр пачка и оно всё обратно отдаётся при этом всё работает параллельно пока это это обрабатывает Этот новый принимает новую пачку новую пачку новую пачку Вот это очень хороший вопрос на самом деле нет Потому что если здесь пришёл всего один запрос он один обработает Да он съест больше процессора Но поскольку больше запросов нет то нам процессор не жалко он курит нисколько сколько есть столько есть это можно знаешь с чем сравнит кнов людей сколько там стоят стоят 100 взял 100 уехал стоит один взял один уехал Нан не влияет идея такая что чем больше тут скапливается запросов от клиента да тем оно эффективнее использует процессор если их тут мало процессор используется неэффективно это правда но но при этом он и так курит Почему бы и нет много машин много сокетов тогда мы воем вот старые добрые системные вызовы Ну как много если каждый клиент в один сот всё пишет синхронно то Мы возвращаемся вот в эту схему оно оно как бы тоже быстро естественно Но вот вот этого вот вот этой магии нет Да давай кость все будут курить в этом тре е ближе втори третий раз нет у нас эта активность на много сокетов Да много клиентов она всё равно не будет влиять на ткш процессор потому что сетевой тред будет их все эти сокеты обрабатывать отдельно и потом уже транзак процессор получит это ти важно поэтому у нас и есть сетевой тред Да в редисе Вот в одном треде то есть вот если сравнить нас и редис то когда клиентов много и нагрузка небольшая дис жрёт меньше цпу реально вот за счёт этого подхода что он не делает ит коммуникация у неё всё в одном треде Но если нагрузка растёт и клиентов много то у нас пропускная способность этого выделенного треда который обрабатывает транзакции выше потому что всё остальное из него вытащен и он делает только полезную работу потому что вот эта хер она скалится тут же на все ядра Да они всег работают неэффективно Но потому что такой паттерн нагрузки все используют свой соке Вот чем Ну через внутренние очереди скорее всего там там спинки Да Кость или А есть Мо Татьяна хабре лучше почитайте там подробно в двух словах в каждом треде работает ивент машина и в каждом треде свои файберы работают ещё поэтому обмен сообщениями между фабера - это просто часть ши под капотом когда есть сообщение пишется Исе отдельная большая Тема что Уго этого дело у него параллельные запросы обрабатываются в фарах это по Су вот чего я не рассказал Вот и И проа это тоже где-то должно было быть вот да то есть это можно видимо там ещё сделать там два или три доклада но общая идея такая Да что быстрее пишем быстрее читаем быстрее Стартуем и быстрее обрабатываем массовую Ну как бы массовую нагрузку просто просто потому что применяем правильные подходы правильные алгоритмы и всегда думаем о производительности и насле Вот кстати Можете зайти У нас же всё Open Source как бы не только код все наши тузы у нас есть такая туза Вот вот тут ссылка на неё там она показывает производительность по каждому коммиту то есть там по каждому коммиту происходит полный полный набор перфоманс тестов если мы видим что какой-то комит что-то там там один из тестов уронил то мы значит тут же это фиксим вот такой метод как бы не технический Но вот это как мы держим себя в чтобы чтобы быть чтобы быть всегда быстрыми вот на сегодня всё здесь перечислены все наши контакты также я хочу сказать что у нас в 14 часов будет митап в комнате 1.7 Приходите туда вот мы ответим на все ваши вопросы но сейчас на осталось сколько там минут 10 Да 12 даже сейчас есть время на пару вопросов Спасибо Боре на пару вопросов Спасибо Здравствуйте спасибо за доклад я я справа Кто кто а мы поверили ваш продукт и у меня короткий вопрос один есть ли возможность реализовать транзакции Так они там есть то есть там прямо вот вот допустим е если вы пишете функцию на лоаке то вся функция - это как транзакция она или всё или ничего А мы можем вот из разных клиентов с одного клиента заморозить видет только один спт вот того что заморозили а с другого в это время делать изменения Я бы что что нет то есть мы это Мы это можем или нет А ну винили да А вот а вот здесь нет вот моём докладе буду рассказывать про новый движок там там это возможность есть он сейчас в бете Да следующий доклад дисковом движке Мы это можем а нет но вы как мы делаем обычно если вам нужна транзакция у вас всё какой-то есть там код который как бы её реализует вы его запихивает в процедуру у вас на всё или ничего и другие не видят то что то что у него внутри Вот то есть вот базово для 99% случаев Ну по крайней мере вот у нас в mail.ru этого достаточно Денис Спасибо большое за доклад очень зажигательный так сказать оптимизм выражается такой вопрос SQL Когда появится он сейчас есть в таком полу Альфе Я думаю что до конца кода должен появиться плюс-минус Да Кость я думаю что мы собирались сделать Альф в ноябре вот сейчас мы немножко опаздываем сечас вот закончится через 10 минут у нас выступает Константин Осипов как раз хранение данных на винили на самом деле Спасибо если у вас ещё остались вопросы можете Я прямо сейчас тут отойду и вы можете мне их мне их все задать"
}