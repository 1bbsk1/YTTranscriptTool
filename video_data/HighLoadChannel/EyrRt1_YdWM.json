{
  "video_id": "EyrRt1_YdWM",
  "channel": "HighLoadChannel",
  "title": "Повседневная практическая векторизация / Ignas Bagdonas",
  "views": 627,
  "duration": 3205,
  "published": "2022-03-21T13:57:32-07:00",
  "text": "добрый день поговорим о некоторых аспектах векторизации и особенно практических аспектах векторизации как это можно пользовать в повседневной разработки для всяких ежедневных применений о чем здесь разговор сейчас если мы смотрим на всю индустрию векторизации все что связано со всякими расширениями векторного вычисления это большой всякие тестированиями измерения производительности графики растут только верх из этого начинают расти всякими ты об произвол производительность и применению всех этих технологий попробуем эти мифы немного россия посмотреть как это работает и как это действительно можно пользовать не только в контексте высокопроизводительных математических расчетов назвать числа дробилка но и других применениях и также сделать это так чтобы общая производительность всей системы она не стала хуже чем до начала таких кораблей перераб изменений что такое векторизации очень упрощенно мы берем тот же самый скалярный алгоритм те же самые скалярные данные и применяем этот алгоритм непоследовательно а параллельно на множестве это звучит просто в реальности все проблемы как и всегда лежат на маленьких мелких деталях вот одних будет дискуссия как это характеризуется со стороны производительности надо разделять когда мы делаем такие вот параллельные операции надо разделяет два понятия отчисленных понятия производительности это задержка и пропускная способность всей системы а по-английски это будет в деятельности трупы то что допустим абстрактный процессор может выполнить страшную инструкцию за единицу времени это необязательно коррелирует с тем сколько много параллельно таких же самых инструкциям может обработать какой-то каким-то количеством параллельных да и практическое применение векторизации и почему такие механизмы они имеют право на существование это именно увеличение пропускной способности системой при той же самые задержки одной операции мы можем выполнять множество операций параллельно иногда может быть что и если перед на пересчете на один элемент это получается больше по задержке но в сумме пропускная способность увеличивается и в нашем конкретном примере мы говорим о том что называется синдром страшновато плоды это когда у нас есть одна инструкция одна операция и она применяется на для всех элементов и это значит что для всех элементов от и выполняется одна и та же самая операцию или команды зачем вообще в 2021 году надо от таких вещах говорит вот компилятор умный ему надо только сказать подходящий ключ и он все сделает сам и будет все прекрасно работать действительно это правда если мы говорим то что в общем называется бердская вертикальные операции и как правило это или логика арифметические действия которые хорошо ложится одну одна на другую и нет никаких впечатлений нет никаких зависимости от данных до эта сфера применения в японском пью think это так было изначально и так и остается и действительно там компилятор управляет всем и делает это довольно хорошо но если мы посмотрим на некоторые другие сферы применения справа как раз живой пример это функции 732 тут и всякие зависимости по управлению в зависимости от длинны и тут и всякие интересные ветвления и теперь представьте что вы хотите эту gear функцию вычислять параллельно несколько в один проходы для нескольких разных потоков данных что получается получается то что компилятор говорит извините я не смог а может быть вы как-нибудь сами задумайтесь как это делать для того чтобы применять векторизация таких в таких не особенно тривиальных случаях несколько простых теоретических аспектов которые должны быть выдержаны первые для векторизации не может быть ветвление зависимости по управлению все это надо переводить на зависимость по данным вот этот большой большой большой ветвление по длине объектов надо переделывать на последовательность в которых те части которые нам нужны обрабатывается все другие маскируются потом векторизации не дружит сразу с разными шире нами элементов с которыми мы работаем их надо приводить к общему числителю и ты рации которые зависят от данных которые зависят от каких-то еще других параметров а не для того чтобы избегать зависимости по управлению их надо сводить 5 к общему кратному и все это для компилятора не всегда выглядит тривиальный вот попробуем посмотреть да что же можно с этим сделать если мы смотрим на базовые конструкции для успешного викторе zero вания главная задача нам это перевести зависимости по управлению к зависимости по данным значит что у нас получится прям елена прямолинейный участок кода в котором вместо того чтобы управление переходила туда и сюда мы включаем или выключаем обработку отдельных элементов данных да это значит что мы будем делать часть работы без полезного результата и векторизация баланс оба слияниях последовательной работе и отключению ненужных элементов данных к если мы использовали бы множество скалярных проходов и да действительно часто бывает такое что несколько несколько последовательных скалярных проходов итоге работает лучше чем быстрее чем один вот такой красивой speak to rise раваны механизм для того чтобы можно было это эффективно пользовать нам нужны горизонтальные операции это платформой компилятор к которой мы пользуемся жены поддерживать и пользе и использовать это эффективно для того что мы делаем что ли это такое горизонтальные операции они работают над элементами вектор а не вертикально как при допустим арифметическим или логическом пересчете они работают сами с самими элементами с отдельными частями элементов с блоками могут их двигать его права переставлять копировать изменять загружать из скалярного домена и или и дней с прямолинейного участка памяти и для того чтобы можно было отойти от зависимости по управлению алгоритм нужно модифицировать так чтобы мы просто могли его где данные над которыми мы работаем переставить туда или сюда как-то их включить выключить и потом вся арифметическая логическая обработка будет идти параллель посмотрим на историческую перспективу откуда все эти векторные расширения на платформе с 86 пришли кстати здесь в контексте этой презентации мы говорим только велика 86 так первое что было этим 1 pentium mmx это 96 год и у него появились 8 мая регистров каждый посев 64 бита технически они были совмещены 87 для плавающей точки это значило что то же самое время нельзя пользовать с 87 или или mmx в то же самое время раздельно конечно и при очистке состоянии что что это расширение дела но он дал возможность работать с целочисленными элементами шириной 8 16 32 или 64 бита одна инструкция выполнялась на вот такой вектор из до четырех элементов то что осталось и до сегодняшних дней это то что гранулярный с операции неравномерная и как правило чем уже элемент тем труднее с ним работать допустим многие логические операции для 8 16-битных элементов не существовали только для бойлера и то есть технические ограничения реализации доступ к этим регистром был только через память через kest кеш технически напрямую из регистров доступа к ним и не было новое было то что появилось с и tury.ru ющие арифметика топить переполнения когда арифметическая операция переполняло вверх или вниз она оставляю вас на максимальной величине это было связано с применением в первую очередь во всяких графических применениях для того чтобы белый цвет не стал более белый чем выше высшая граница и со стороны операции сравнения были только две на равенство и на более все другое надо было делать самому при при помощи логических операций и также было введено понятие маскирования результата сравнивания оно давало результат те же самые регистры данных была или ноль или или все единицы и при помощи логических операций можно было делать вот такие ветвления поданы все эти инструкции были 2 аберрантное так как и все оставшиеся с 86 время и 1 значит что 8 и регистров это было довольно трудно что-то не разбежишься с 8-го семью регистр так следующее поколение то pentium 3 стриминга с индик станешь нас по маркетингу по маркетинговое название новые раздельные отдельные регистре 128 бит каждый и логика работы опять такая же самое у нас есть элемент 816 3264 они могут интерпретироваться как целочисленные как пинпойнт и доступ к этими регистром ко всему регистр только через память через кеш а к младшей его части можно и через регистры общего назначения и было понятие а также скалярного упакованного вектора скалярный вектора такой oxymoron получается немножко регистр в котором задействовано только самые младшие его часть это было как бы смена модель а работать с 87 отход от от модели стека то же самое со tury.ru ющая арифметика она осталась и и это инструкция уже были 3 операндами это значит что они на не меняли один из странных регистров и это действительно помогало а58 регистрах это не так уж много и это помогало для сохранения значение которой перри использовались параллельно в других местах следующее это было и викс расширения те же самые регистры они были удвоены по длине но что важно они были удвоены не обязательно во всех операциях логически то что физически не выглядит как 256 это не значит что мы можем работать со всей длиной этого регистра без ограничений логически они все равно являлись двумя числами 128 128 не битного регистра и это кстати остается и по сей день если мы хотим делать перестановку крайних элементов физически невозможно доступ такой же самый младший часть и регистра можно через другой регистры общего назначения ко всем другим элементам только через кеш главный главный фокус здесь шел на floating point операции просто довольно довольно производительный в то время числа дробилка если можно его так назвать и кстати регистров в сумме 16 следующая логическая усовершенствования в этого модель а это дополнение интерпретации данных целочисленными операциями и ведения как бы я бы назвал это самом самых базовых компонентов для успешной векторизации горизонтальные операции с блоками и с элементами внутри этих блоков возможность из двух векторов по какому-то шаблону по маске сделать один выбрать только нужные элементы возможность то что называется gear когда мы можем не только прямолинейный блок памяти собрать но собрать это по индексу кстати это только gear если мы говорим о записи не прямолинейным ничего такого пока еще не существует и те же самые операции логические операции сравнения которые мы знаем еще со времен это равенство и но больше и ничего-ничего привлекательных беги кованых привлекает перетыкать механизмов для того чтобы можно было легче делать и переводит ветвления походов ветвления подарка в то же самое время в параллельной вселенной так если так назвать intel работал над графическим процессором лорроби он не был продукте zero ван но документация по системе команды и и по программированию она уже была сделана публичный и потом этот продукт он не вышел так как была проник планировано но он сильно повлиял на дальнейшее развитие это были тридцать два регистра отдельных регистры ни с кем они совместимы по 512 bit каждый интерпретированы как интерпретируем как 16 раздельных элементов и также 8 отдельных элементов предикатов по одному биту индикации занятости от того большого регистра которые напрямую могли быть доступны из регистров общего назначения доступ опять только через память а нет нет прямого доступа регистров общего назначения только предикатом и также специфически для применения для графических аппликаций это было конвертация всяких разных типов данных представления int32 ее флотом point также были механизмы году рисковал полноценно работающий и действительно сильно развиты и инструкции для работы с битвами операции допустим 3 3 отрадный логика она появилась впервые в лорроби и это действительно мощный инструмент следующее поколение куда-куда большинство этих нововведений прошло и было прошло и было продукты zero ван vision довольно специфические специфическое числа дробилка больше она не существует как продукта эта линия закрыта но она опять имела большое влияние на следующее поколение те же самые 32 и 8 регистра переди катофф и из-за того что сенпай был собран векторная часть была унаследована от лорроби а скалярная часть это первый пентиум для него было сделано много расширение как управлять памятью кеширование им загрузкой and этих широк эффекторных регистров и как последствии сенпай трансформировался то что сегодня доступна как зеленый спи платформа серверные процессоры и она там приходят под именами векс 512 те же самые меня 532 регистра шириной по 500 бит но они выполнены как расширением надо регистрами и вес значит что опять у нас есть один физические регистры который может быть виден для разных систем кодирования как разный элемент но технически совмещено он является совмещенным по данным и это значит что те ограничения которые идут современной сосед по 128 бит они присутствуют и в век 512 8 привлекательных регистров для каждого байта минимальная гранулярный x 512 является один байт напрямую доступный из регистров общего назначения интерпретации каким-то жалели floating point гибко и так как нужно и теперь важный аспект и и 1 из 1 из бы причин всяких мифов и и некоторого не понятия windows три это то что и вес 512 является набором функциональности это не один на механизм это множество всего которое может для разных продуктов быть выполнять разные разный функционал и не быть совместимым базовые 512 это foundation логика и арифметика а если мы хотим работать с элементами 32 и 64 расширения даблы кода если мы хотим работать с байтами словами это набор других расширений и кстати разные поколения просто 40 несовместимы поэтому и еще один очень-очень интересный вариант это вектор лампа погано лэти значит что мы можем использовать тот же самый подход программирование и векс 512 над регистрами и access оси из этого у нас получается 32 регистра и века 1232 регистре vex 2 и тридцать два регистра si se от слов к делам попробуем посмотреть на практическое применение вот таких механизмов здесь примеры пример и они немножко притянуты и большинство этих примеров они идут из сетевого применения сетевой сферы я сам сетевой инженер я занимаюсь перебрасывание им пакет с одного интерфейса на другой и из этого тематика примеров которые здесь они связаны со всякими сетевыми аспектами и причина почему я стал смотреть вот на всякий эти организационные аспекты вот есть у нас большой проект большой горячий и быстрый процесс а вот у него есть большие векторные блоки которые и простаивают из них не пользовать вот если попробовать все те довольно простые алгоритмические подходы потому что для пересылки пакета слева направо там много думать не надо там надо просто много делать вот если попробовать использовать эти векторы расширения для такого класса задач самое первое у нас есть очень простая структура всего восемь байт в нее есть тип есть данные и мы хотим найти такую структуру потока данных и просто посчитать что сколько там у них их пришло в пакет и что для этого нужно ничего особенного скалярным для меня до одна операция сравнения посмотрим так и здесь вы видите забегая вперед некоторые результаты вот тестирование разных подходов мы будем более детально с ними разбираться шумеры и векторизация вам бесплатно может дать бесплатно потому что вы уже заплатили за свою платформу может дать вам ускорение в разными в проценты а раз смотрим на очень наивный вариант когда мы загружаем полную структуру весь набор их вектор и здесь мы ищем значение 1 2 3 4 в шестнадцатеричном и смотрим что у нас тут получается загружаем нашу структуру сравниваем его с тем что мы ищем получаем маску маску еще надо обработать потому что сравнения также сравнил ее нули и дала ложный ответ получаем правильную маску маску умножаем на 1 и прибавляем к нашему счётчику все очень просто работает но если посмотреть практической точки зрения у нас есть 8 полос для для нужно для для практичной работы мы используем только маленькую часть технически это только одна восьмая всей ширины хорошо белые это когда более логично загружаем по два блока здесь вот последовательно четыре элемента и здесь последовательно четыре элемента для того чтобы с ними нам с ними что-то сделать их надо привести к одному вектору эта функция блин сперва один копируем на второй шаг и потом мы сливаем их в одном и делаем тоже самое здесь у нас уже получается немного более эффективное использование ресурсов так как мы не выбрасываем одну полосу и ничего с ней не делаем здесь мы уже пробуем сравнивать значения на каждой полосе но вот что бросается в глаза вот здесь все эти пять ненужные а байты которые которых нам надо опять только отбрасывать хорошо смотрим с другой стороны если есть функция гида который может забирать к нам элементы не прямолинейно а по адресам по которому мы запрашиваем пусть загружает а нам только части элементов одну половинку вы здесь мы ставим оплаты по восемь байт каждый и загружаем но если мы смотрим на результаты вот здесь это получается практически в 4 раза 3 раза не длиннее чем довольно брутальная перестановка и слияние двух векторов почему по очень простой причине для того чтобы загрузить что-то из памяти надо сделать две операции доставить строку доставить в кеше строку кирша ту строку из памяти в которой мы загружаем и также транслировать логический адрес физически эти две операции они делаются более-менее параллельно это связано опять системы и кеширования как как эффективно она может работать и распознать доступ к той же самой строке кеша а вот из разных потоков но если мы берем обобщенный вариант получается 8 раз больше нагрузка на транслятор адресов и 8 раз больше нагрузка на систему кеширования чем при последовательность последовательной загрузки в сумме это получается проигрыш смотрим еще один вариант сейчас пробуем загружать по 4 линии сразу и строить из них вектор шириной 16 бит вот фиолетовые желтые зеленые синие переставляем и двигаем туда и сюда и вот у нас получается один вектор в котором уже только те части значения которые мы напрямую сравнивать здесь также мы получаем выигрыш потому что не надо больше смотреть на нато является ли эта маска корректной или некорректной смотрим на результаты практически 16 раза увеличение это не 16 процентов 5 6 раза действительно стоит таким заниматься не смотря на то что здесь логических операций получается даже больше чем более более как бы логически чистом варианты использования полной маски если мы смотрим на сторону и x 512 там ситуация получается довольно похожие векторы шире можно больше при той же самой для той же самой инструкции можно обработать дважды больше полос это не прямолинейная зависимость система по милен памяти кеширования она динамическая очень зависит от того является ли этой строки в кеше подкачиваем или мы сами это и еще от очень многих других факторов сравнивая авторы there'sa цию это то что компилятор сделали вот то что мы пробовали делать руками компилятор действительно нас обогнал по памяти но даже не очень сложные варианты визирования руками или объяснение компилятору как это надо делать они дают результат результаты они зависят от величины с которыми мы работаем здесь несколько графиков показать как это наглядно им действует система памяти и кеширования и соотношение логических инструкций к количеству инструкций которые работают напрямую с памятью и также тот же самый график профилированные на большее количество большее количество элементов авторизированный вариант он и идет и где то два с половиной раза ускорения по сравнению с скалярным вариантом функции и огр они чем больше элементов мы работаем тем больше нагрузка на память тем медленнее он становится а вот варианты с предварительной загрузкой кэшированием и ps когда мы работаем два или четыре прохода можно согласиться что выигрыш в общей пропускной способности в 5 раз по сравнению со скалярным вариантом того стоит хорошо идем дальше следующий пример тоже из сетевого пространства это трансляции из by gingham little indians обратно такое такое всех повсеместно потому что последовательность байтов в протоколах она выглядит обратный если мы по сравнению с платформы x86 все очень просто ты та же самая наша структура только вот и внутренние интерпретации в зависимости от типа есть разные поля их надо перевернуть так или иначе скалярный эквивалент примерно здесь ничего особенного добавить своп она активно выполняется но их много и они зависят от тип попробуем посмотреть что можно с этим сделать социализации и если мы смотрим на варианты перестановки байтов да такая такая горизонтальная функции есть и это сводится к созданию маски с какого индексов которые байт должен переехать тогда все получается просто по типу и по типу этой структуры мы строим часть вектора которая является просто перестановкой тогда собираем все эти су векторы в один и применяемых к полной строке наших данных и смотрим на результаты и результаты довольно впечатляющее ускорение примерно два раза да действительно какое можно пользовать опять важный аспект перестанут и такое преступление работает в контексте ширины 128 бит привет истории с оси если мы хотим переставлять с 1 по 30 30 кроме довольно новых расширений вес 512 такого функционала дня следующий вариант тот же самый поезд только у нас структура немного более злая она получается шириной бегать байт и напрямую конфликтует с шириной наших векторов попробуем посмотреть что можно с этим сделать вот как это выглядит первое дело здесь уже надо работать с блоками а не только с одним вектором потому что общее общий делитель 9-30 2 они они взаимно взаимно первичные из этого получается блок бегать или 18 векторов с которым нам надо работать как с одним объектом и тут получается проблема вот именно в той истории с связь и в некоторых страха в некоторых векторов наша наша структура переходит границу 128 бит или переходит границу вектора под красными помечены все эти элементы которые нам будут делать проблемы все остальное там все просто делаем маску применяем эту маску нашим элементом отфильтруем значения прибавляем и получаем результат смотрим на результаты факторизации и тут ради интереса несколько разных компиляторов с довольно разными вариантами один из них не смог сми специализировать это кстати он сгенерировал тоже сгенерировав простой скалярный код который оказывается еще медленнее чем просто да такое бывает а потом смотрим на разные варианты как мы работаем с этими исключениями вся вся сложность и все затраты по работе они приходят именно на обработку вот этих исключающих ситуаций и как правило если у наши структуры данных плохо ложится на векторизация надо подумать заняться ли это или нет а здесь вот в общем результаты выглядят не так уже плохо но по количеству затрата для выработки такого алгоритма другой вопрос об считывания функции хеширования разные точнее здесь очень красиво пора ли лизирующего задачи если сама функция не используя это широкой арифметики два конкретных пример это мармарис city они обе обе работают с 32 разрядными числами внутри и если мы можем просто подать данные для для обсчитать и хеш-функций само собой просится векторизации смотрим как это можно сделать большинство операций в функции хеширования логика и там всякие перестановки логические операции простая арифметика это очень хорошо ложится на векторизации проблематичная сторона является умножением это может быть переполнение и да действительно такое случается тут надо подумать как это сделать данные собираются по указателям и работа с указателями в векторном контексте она является довольно больно и как правило такая проще сделать на скалярным домене в прологе эпилоге работа с указателями подготовки данных а потом параллельно идет просчет просто уже подготовленный просчет года надо уже подготовленными дар результаты говорят сами себе ускорение в пять раз да действительно за такое можно и побороться дерево образные структуры начиная от этот самого тривиального бинарного дерева к более сложным редкостным берегом деревьям опять это сводится к логике ветвления по управлению надо перевести а ветвлением по данным это логические операции и склеивание одного вектора из из двух или больше изначальных то что тоже может быть значительно производительности всей системе если допустим у нас есть элемент для обработки которого нужно 5-ти раций и другой элемент для которого нужно 25 итерации обработки пошагового прохода по бинарному бинарному дереву общая длительность такой операции она будет равна 25 они 25 потому что нельзя так просто выйти из из такого от векторного прямолинейного потока именно из этого если у вас есть возможность перед сортировать элементы над которыми будет работать по их длине обработки это может дать значительное ускорение когда они все более менее ровные те же самые проблематичнее места с указателями если мы работаем с 32 шириной 32 битный бедного вектора операции gear тоже робот работает с 32-битным указателем и и для этого ваша локатор элементов должен уметь создавать элементы которые находятся не дальше чем плюс-минус 2 гигабайта от начального адреса все что осталось всякие всякие всячины атомарных векторных операций она не гарантируется то что гарантируется это что операция будет выполнена атомарный для каждого элемента если этот элемент выровнен если не выровнен последовательность этой операции не гарантируется может быть что последний элемент будет загружен первым или наоборот из этого если вы думаете использовать векторные операции для синхронизации примитивов синхронизации допустим одновременно захватить несколько спин log off теоретически это работает практически это не работает это приводит конфликтом потому что эта платформа зависима и это не гарантируется последовательность работы с памятью тоже самое это зависит от того как работает система хеширования и является ли это выровнена мини выровнены по сравнению с травой кеша по сравнению со страницей имеется ли у нас тел бен при для всего всего для этого региона памяти надо бета делать дополнительно и как правило загрузка из памяти она не обязательно идет в такой последовательности не обязательно последовательности выполнения программы всякие специфические расширения как правило для оптимизации всяких много много много ресурсов запрашивающее вычислений связанные с обучением на перемножением векторов и прочих других применений да это важно это нужно это действительно помогает только немножко других сфера применения взаимодействие с операционной системой и то довольно много контекста и его сохранения она не бесплатно и если вы посмотрите на систему в которой будет много переключения контекста между потоками или потоки не фиксированные конкретно недрам и не не снять шиллинга один из путей уменьшения производительности может быть именно из за того что количество коньяка или вещества состояния которое должно быть сохранено но все-таки является довольно большим так вопросы которые вы хотели задать но не успели добежать до микрофон я попробую ответить на некоторые из них со это действительно замедляет весь всю систему и замедляет значительно это один из вопросов о котором есть очень много мифов и просто ложных данных да это замедляя существенно это вам решать здесь вот график иллюстрирует три разных поколений зеленый спит которая делает ту же самую операцию и тасс normalize равана для для до тех же самых данных и то что мы видим это очень сильно зависит от конкретной реализации и платформы и как внутри это выполняется в контексте и викс есть лицензии питания и есть три и зависимости от категории инструкции она получает одну или другую в разных поколениях процессоров эти эти лицензии питания раздуваются по-разному и то что было допустим в одном поколении являясь как сложные и и тяжелой операции на следующем поколении это выглядит не так с другой стороны технологическое ограничения с эволюции технологического процесса это уменьшение становится все меньше и меньше до законы физики они все еще в силе и это останется и если вы хотите сделать больше работы для этого нужно больше не результат тепловыделение увеличивается но зависимость она не особенно прямолинейно и это очень зависит от многих факторов реализаций так что до 5 лет назад действительно использование векторных инструкции тяжелых век там эти инструкции особенной века 12а она сильно влияло на общую производительность на сегодня это влияние есть но она намного меньше выражены если мы говорим о конкретных цифрах то что было это было минус 45 процентов сегодня то же самое функциональность она дает минус 15 процентов от общей производительности вот вы говорите тут всяких intrinsic обсе и прочих других низкоуровневых вещах 2021 году это как это хорошо это только пример если вы хотите использовать что-то свое ржавые крабы суслик или там еще какой-нибудь ваш язык который вам нравится с очень большой вероятностью все там это уже есть и также есть всякие сторонние библиотеки которые закрывают большинство свойств что что здесь видно от ваших глаз но для того чтобы понять как это работает и почему это иногда не работает очень помогает взглянуть немножко и ближе и действительно я вам не предлагаю все переписывать на intensity надо делать более продуктивным путем это просто пример так говорят что ivy x 512 больше не будет опять первое дело это спекуляция другое это тема которая очень обвешаны всякими мифами это сводится к технологическим аспектом также да некоторые клиентские процессор этого поддерживать не будет и при том что прежнее поколение поддерживали это связано именно с ограничениями по тепла пакету и с некоторыми программными спиртами наверное со временем это будет вылечена как выглядят альтернативные вселенные что в других платформах и как как это part обильно если мы смотрим на армии риск 5 у них обоих теоретические такие расширения есть парма и потому что не он это это более исторически и смотреть на него особенно нет смысла такие расширения есть они конечно напрямую не совместимы это если мы смотрим на уровень им принципов и и и прямого доступа к коду если мы смотрим на уровень библиотека шаблонов это довольно все-таки совместим она практически аспект является в том что эти платформы пока еще только существуют в дизайне реальных компонентов еще нет которые поддерживали бы такие расширения что будет после ivy x 512 наверно будет хорошо на более серьезной ноте следующее следующий большой шаг это то что называется матричные расширения и и перед переводя на на вот его лет язык это век 8192 и это интерпретации регистра как матрица 16 на 16 которая будет довольно скоро но если мы говорим просто расширение и x2 и и 512 расширяться там особенно нигде потому что системе кодирования инструкции пустого места больше не осталось и обе эти системы кодирования они подошли к своим лимитами из этого нам придется жить так как и то есть вот сейчас все остальные вопросы которые есть у вас буду рад подискутировать также в материалах материалы в результате есть немножко больше всяких технических деталей и и логов если интересно покопаться в детали спасибо вам спасибо большое инга станешь ты нас слышишь хорошо я тоже надеюсь добрый день отлично на самом деле у меня был вопрос к тебе и дело в том что ты на него ответил прямо в докладе по поводу процессоров совершенно замечательно очень точно попался будет это очень-очень круто если зале есть буквально два вопросика если есть там и их зададим да хорошо да можно вот малым человеком гармонику большое спасибо за доклад такой вопрос вы сказали что использование vx инструкции замедляет весь прямо процессор именно процессор или все-таки ядро если какой то можно отдельно изолировать а все остальные используют добились цели все на процессах замедлится это связано и если мы первые deal это замедляет конкретные дрона которым это выполняется потом в зависимости насколько потому что зеленый спину них распределенные кеш и строки которые принадлежат одному ядро они не обязательно являются близко к этому яду он не может быть в сегменты которые где-то на другом конце и для чем больше мы делаем таких операций начинается как и побочные эффекты от такого потом есть общий тепла пакет всего процессора который является меньше чем сумма этого пакетов каждого из ядер и вполне может быть так что если вы допустим посмотрите вот на тот график с мутациями там даже видно что если мы можем если мы выполняем это на больше чем каком-то количестве замедления начинается всех оставшихся не только тех которые делают у работу тот тесто на одном ядре крутилась просто скалярная скалярная операция без никаких векторах и потом от от 2 до 32 делались мутации так что зависимость есть и она не прямолинейно и это довольно трудная тема в том что детальная эта информация она подается только по индии и если у вас такого нет у вас остается один единственный выход это тестировать спасибо большое разных грязных компонентах если есть разные параметры и недокументированные еще раз спасибо уважаемые коллеги я попрошу сейчас вместе с игры сам переместиться в дискуссионную зону которая здесь на выходе у нас значит соответственно сбоку там можно будет тоже задать он-лайн вопросы или переключиться а нужно зал будет сейчас освободить еще раз всем большое спасибо за участие и у нас тоже большое"
}