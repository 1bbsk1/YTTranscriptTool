{
  "video_id": "l0Wy_FDkXAY",
  "channel": "HighLoadChannel",
  "title": "Не очень большие данные / Павел Лузанов (Постгрес Профессиональный)",
  "views": 3735,
  "duration": 2936,
  "published": "2019-12-05T08:30:20-08:00",
  "text": "понимаю последний день доклад последний доклад первого дня всем тяжело поэтому начну с анекдота тем более а этот анекдот вот мне предыдущий докладчик володе сальников как бы просто вложил так хоть в руки но правда он не новый это вот история про там богатого человека когда я у него спрашивать как вот ты разбогател но вот там был у меня 1 доллар там купил яблоко помыла вот он продал за два там купил два яблока значит помыл продал там в общем потом умерла бабушка я оставил наследство вот это к вопросу о переводе документации который тут был анонсирован действительно когда я пришел в компанию подписи под гриль профессиональный первое что и зачем я занимался переводом документации и там даже успел там что-то чуть чуть там под перевести потом дальше мы искали каких-то еще людей которые могли бы нам помочь мы даже танки эта схема оплата разрабатывали вот и где-то у нас уже процента 34 документации была переведена а потом мы нашли сашу lachen и который перевел все остальное очень быстро и очень качественно вот поэтому все лавры конечно же ну скажем так подавляющее большинство лавров по перевод документации принадлежат вот нашему сотруднику александр елохин кстати кто знает что на прошлой неделе вышел в ней очередной релиз козырь сан у всех версий 11 там 10 9 не очередной почтит вот он по идее должен был выйти в августе а вышел в июне в связи с тем что было обнаружено проблем с безопасностью а именно безопасность крам аутентификации если кто которая появилась десятой версии если кто-то использует 10 или 11 версии томск рамы аутентификацию то нужно срочно обновляться это я все к чему к тому что вот эту проблему обнаружил тот же самый саши лохин очень удобно было его сунуть в этот момент а теперь я перехожу к своему доклад но все любят большие данные однако с другой стороны он говоришь когда искать большая задачи и и для того чтобы решить ее хорошо поделить на честь но вот базах данных про которые мы говорим что там может быть большим ну там вот большим являются таблицы таблицы могут расти и становиться совсем большими вот и как бы одним из инструментов и способов борьбы с кстати и деление на части больших таблиц является то что по-английски называется потише о ней до а по-русски часто так и говорят парте церовани я вот и партиции проецирования вот а я буду использовать термин который ну по русски звучит более правильно и в документации которую мы переводили она так и звучит секционирование именно этому будет посвящен доклад скажите а есть те кто использует в продакшене десятую версию под gris ухты одиннадцатую ними на ноутбуке в продакшене а двенадцатую а 12 еще не вышел все верно да но действительно а те кто меньше чем версию чем 10 9 какие-нибудь там восьми нот обычно вот эта история такой от какой-то момент инерции он имеется да то есть несмотря на то что десятая версия вышла там в семнадцатом году 11 18 м тем не менее сразу обновляться там на новые мажорные выпуск там не всегда правильно нужно там дать момент устаканится и так далее а тем не менее в десятой версии пожгли со появилась важная функциональность так называемые встроены или декларативные а секционирование из коробки в 11 версии она была улучшена серьезно улучшена в 12 version еще больше была улучшена и вот собственно предметом того что я хочу вам рассказать это как раз обзор того чем на момент двенадцатой версии выхода 2 12-ой версии которые официально выйдет вот осенью бета-версии вот уже даже 2 получается уже имеются на текущий момент вот что там у нас сейчас имеется вот это хочется посмотреть я рассматривал сети все те патче которые накопились вот с 10 по 12 релиз вот примерно в первой половине июня и разбирался с этим там стрелки премьеры и так далее это время как раз совпало когда за океаном шла финальная серия национальной баскетбольной ассоциации а я сказать по-честному болельщик и в общем я там жил от матча до матча номер не между матчем я занимался секционирование мы вот кто мог смотрел так далее в общем когда подошла пора оформлять все это дело в каком-то виде то вопросом как именно подавать материал у меня вообще не было и вот я вот собственно сразу был уверен как это все должно быть вот ну и в качестве вот какого-то партнера там спарринг для нашел встроенного секционирования естественно было выбрано а подход когда мы можем секционирование рис наследование это тот способ который был и до десятой версии под грехи и он и сейчас может использоваться более того сама наследование еще stone breaker там 80-х годах прошлого века то кстати вот делая проект под gris оно изначально было тогда заложено вот и оказалось что вообще-то говоря объект объектно-ориентированные возможности в базах данных они вроде как не очень сильно прижились но вот вот это вот наследование она прижилась подгрести благодаря тому что ряд задач для чего используйте секционирование мин разбиение там на части большой таблицы их отдельно и обслуживание разнесения по дискам и так далее вполне себе подходила вот но единственное к нему там существенное усовершенствование было 2005 году версии 81 когда добавили параметр constraint эксклюзив и благодаря этому параметру если мы еще на отдельные дочерние таблички повешенным ограничение check the при выполнении запросов значит все эти ограничения будут сканировать и и не нужные для запроса на родительские табличек дочерней таблички будут отсекаться вот презентацию меня будет построен так что в ней не будет ни одной команды вообще нет но с другой стороны а как же вот рассматривать какой-то функционал если не смотреть на команды тем не менее команды все равно есть вот внизу по ссылочке есть некая демонстрация которую можно открыть хотите сейчас хотите потом и там в виде такого сквозного большого примеры которые можно вот от начала до конца как бы просмотреть различные возможности которые предоставляет встроена или декларативное секционирование там рассмотрены но я в нескольких местах презентации тоже туда перескочу для того чтобы вы могли себе примерно представить о чем там идет речь вот ну и тогда начнем но если говорить там опираясь на спортивную терминологию то там а тот же баскетбол там вот куча самых разных характеристик собирается там броски передачи подбор и перехват ошибки там все что угодно и по разным категориям это раскладывается сравнивается и там проводится анализ кто же там вот лучший за счет чего кто кого там смог победить вот примерно в каком-то таком ключе но для начала создания структуры собственно самой секционирование таблиц и декларативные секционирование позволяет нам разбивать таблицу на по списку значений лист по диапазонам и начиная с 11 версии добавился еще способ разбиения похожу ну помимо того что мы должны создать основную таблицу дальше еще нужно создать некие таблички секции и тут у пьян чтобы все-таки было примерно понятно о чём идёт речь давайте я вот до листаю для этого момента вот команда crate apple и наша задача унесет дописать parties in buy range и мы вот указываем нас некой таблица с бронированием там три колонки все достаточно просто номер бронирования дата там к этой суммы и вот мы хотим подать по месяцам секционирование там июнь июль август вот создали такую табличку и дальше можем создавать секции в которых конкретно указываем границы от для каждой секции вот вот такой подход вот после того как мы сделали основную таблицу и вот эти две секции мы можем сразу же начинать с ней работать в отличие от секционирования на наследование там вы наверное знаете помимо того что мы создали родительскую дочернюю таблички надо обязательно проследить чтобы на дочерних табличках были ограничения чек а потому что никто вас не заставляет их делать вы можете это случайно пропустить нужно обязательно следить за тем чтобы эти ограничения чек были взаимоисключающими например они не пересекались случае с декларативным подходом там у вас команда сама будет ругаться если вдруг там уже что-то с какой-то секции пересекается нам не нужен триггерный insert одна из бед секционирование на наследование то что мы вставляем как бы записи в родительскую таблицу а по факту их нужно куда-то унести поэтому там пишем триггер который что-то там куда-то переносят если вдруг используется подход когда нам нужно обновлять ключ секционирование тогда нам еще потребовались куча триггеров на одной на каждую таблицу секцию он там должен быть обязательно вот ну и параметр constraint эксклюзивом как вишенка должен быть включен для того чтобы вот но момент выполнения запросов мы могли исключать ненужные для запроса сердце в подходе с декларативным этого всего можно избежать тут у нас есть некое упрощение дальше жизнь идет и допустим нам нужно подключать отключать какие-то новые секции но вот сразу можно сказать что вот подхода с автоматическим созданием каких-то секций его по крайней мере сейчас декларативного варианте его не существует вот если у нас там скажем созданы секций там за июнь там июль и август и вдруг прилетает строчка добавлением тут какой-то дать записи за сентябрь если у нас соответствующей секции нет то она упадет по ошибке максимум что мы можем сделать в 11 версии появилась возможность создать секцию по умолчанию тогда туда будет валиться все подряд все почту секции явно и не определены вот ну а потом это можно как-то разгребать и переносить там куда-то ну и тут такая вот такой момент есть но в принципе ту же самую секцию по умолчанию можно сделать и в варианте с наследованием поскольку у нас там триггера сам разносят записи тону создали мы какую-то табличку туда там все все что угодно можем туда и относить вот а что касается подключение отключения секции вот здесь-то я показывал подход когда мы секцию именно создаем но этот подход не самый лучший в тех случаях когда нам нужно создать новую секцию не прерывая доступа к самой таблице то есть вот запросы по-прежнему идут а нам нужно создать новую секцию в этом случае гораздо лучше будет пользоваться подключением новой секции для подключения новой секции там все просто мы выполняем сначала создаем какую-то табличку creed iii был мы можем указать что она должна быть по образу и подобию нашей родительской вот кстати за сентябрь и и дальше мы делаем alter ты была тысяч пар тише чем это хорошо почему именно так лучше делать а вот здесь не случайно эта командочка выполняется внутри транзакции там не позволяет после выполнения этой команды не завершая транзакцию посмотреть что у нас по galax появилась для нашего процесса и мы можем увидеть до что вот access эксклюзив у нас для вот этой новой секции для сентября это нормально а вот для родительской таблицы абу king ranch у нас блокировка не эксклюзивное это говорит о том что мы добавлять новую секцию тысяч пар тишины можем делать прямо не прерывая запроса к самой таблице вот это очень хорошо что плохо то что detech парте шин если нам нужно отключить все таки секцию мы не можем делать в не эксклюзивно в режиме это пока еще просто недоделанный функционал и поэтому то что у меня и тысяч написано 12 110 это ровно то и говорить что вот в двенадцатой версии добавили возможность не эксклюзивного подключения секций а вот отключение его вот пока еще нет а в таком режиме и это кстати тот момент где секционирование по наследованию пока еще лучше чем встроены потому что там что команда alter ты был он верит или now in heaven там начинать нашей родительские таблице они обе не требуют эксклюзивные блокировки индексы ну понятно что никто нам не запрещает создавать отдельные индексы на отдельных табличках секциях случай там с в обоих случаях вот а что касается глобальных индексов вот если мы все-таки хотим сделать яндекс который был бы глобальной используя секции понятно это не всегда нужны и во многих случаях именно локальные индекса они предпочтительнее вот но иногда всё-таки бывают на такие ситуации когда бы мы хотели бы скажем мы там вот нарезали нашу таблицу скажем там по периодам а внутри периодов мы скажем у нас очень много клиентов да и было хотим еще сделать яндекс глобальный по клиентам и вот нам а то а потом для чего нам нужен так что получить все записи по этому клиенту нам мы не знаем в какой период вообще все что по нему был свою историю предполагая что по этому клиенту их не так много вот вот такой запрос встроенными средствами никак не сделать нужно тут что-то хитрить нужно как то придумывать точнее галя запросто сделать можно но он будет ходить по всем секциям в обязательном порядке исключения секции здесь как бы не предполагается вот но зато декларативное секционирования предполагает так называемой централизованную поддержку индексов вообще говорим мы можем яндекс создавать create index на самой секционирование таблиц и это будет секционирование индекс что под этим понимается если мы добавим новую когда мы создаем вот такой индекс а у нас автоматически они создаются во всех секциях сразу же если мы добавляем новую секцию на ней сразу же автоматически создаться вот этот индекс который был создан когда-то на основной таблицы если мы попытаемся удалить из какой-то из одной секции вот этот вот так индекс зато мы получим ошибку то есть взгляд будет считать что это у него вот целостный его индекс да они сами в себе записи саммите объекта они опять же порезаны на такие же секции как и таблицы но тем ни менее поддерживаются они централизованы ограничение целостности какие мы можем указывать на таблицах вот тут наконец-то в двенадцатой версии все о том о чем уже давно все мечтали и по крайней мере часто спрашивали похоже что уже реализовано хоть и с некоторыми оговорками мы можем на секционирование таблиц и создавать первичный ключ уникальный ключ мы можем на нее ссылаться из других таблиц мы можем из нее ссылаться на какие-то другие таблицы ну ну и чеки они там и раньше никто не запрещал но тут может возникнуть такой вопрос по крайней мере здесь он совершенно уместен вот если мы говорим про первичный ключ или уникальный ключ как известно в пожгли сидеть и ограничения целостности реализуется при помощи уникального индекса нам нужен уникальный индекс по всей таблицы для того чтобы мы могли вот обеспечить уникальность а глобального индекса как вот на предыдущем слайде я говорю его в под грехи не имеется вот как же здесь тогда создается первичный ключ а просто есть одно очень важное ограничение в состав первичного ключа обязательно должен ходить ключи секционирования но чтобы на примере вот если скажем мы разбиваем например по какому-то полю айди условно говоря от единицы до до миллиона там это первая секция там 2 миллиона там вторая секция 3 million третий и так далее вот а дальше создаем уникальный индекс вот на такую таблицу у нас записи да будут локальные индекса с 1 до миллиона от одного там миллиона до двух но тем ни менее сама разбиение таблицы по принципу 1 миллион 2 3 она нам гарантирует то что в секции там 2 миллиона никогда не встретиться значение 10 там или 15 а в секции 1 миллиона никогда не встретиться значения больше чем миллион поэтому в принципе мы можем используя правила разбиения таблица на секции плюс уникальность внутри от этого ключа секционирования по индексу мы можем гарантировать что такое значение она всегда уникальна вот именно исходя из этого мы можем создавать первичный уникальные ключей на таблиц мы можем помимо ключа секционирования добавлять какие дополнительные столбцы в первичен и например ключ вот но сам ключ секционирование там обязан быть иначе мы такое увлечение сделать не сможем но и с учетом этого ограничения тогда мы можем теперь уже на нее ссылаться из других таблиц в принципе все это делалось еще и для 11 версии пузырь со но вот просто до первичные ключи вот поддержках сделали внешний ключ и секционирование таблиц и например на какой-то справочник сделали а вот вот эту часть ссылку на саму нашу табличку секционирование просто не успели доделать доделали в двенадцатой версии запросы ну прежде чем выполнить запрос над построить по нему план план запроса и вот одна из проблем секционирование через наследование она как раз заключалась в том что когда у нас много секций план запроса начинает строиться мире чем больше секций тем медленнее будет строиться план запроса ну причина здесь понятно что для того чтобы нам на этапе планирования откинуть секции в которой не нужно ходить по сгрыз мониторит проверяет по словарю данных все ограничения чек который есть на таблицах сверяет их с запросом понимает нужно ли можно ли вытянуть вот эту табличку и чем больше у нас вот этих секций тем так ставите себе больше на это надо времени но вообще понятие больше и меньше они достаточно относительные и поэтому здесь всегда нужно видеть каждой конкретной ситуации здесь просто пока можно сказать про тенденцию чем больше сердце тем меньше план выполнения запроса тем медленнее будет план достаточно ли это ваших конкретных условиях это уже вторая история вот ну например там по моему в документации даже какие-то вот чтобы он хоть на что-то там операция там по моему так говорит что вот для наследования то словно там сотня там сотни секции это еще ничего а вот там когда уже речь идет о тысячах то это уже там не очень но опять же даже в этом случае то есть надо все-таки смотреть на конкретные потребности например если у вас какой-то о лоб приложение какой там где запрос работают ну скажем там минутами а то и десятками минут она построение плана там тратится там скажем там на две три секунды там больше чем если бы секции было мало вот то наверно это не сильно страшно но если у вас свой лтп приложения где там запрос должен за доли секунды работать а на построение плана кстати добавляется там две три секунды рн это уже не допустимая скорость ну важно то что вот оптимизации для быстрого построения плана на большом количестве секций они были сделаны еще и на 11 версии позвали в 12 там еще что то сделали в общем там сейчас должно стать лучше но еще раз лучше и хуже когда вам кто-то говорит никогда не верьте нужно проверять на конкретных условиях кому-то и лучше плохо а кому-то и плохо вполне себе достаточно ну и что мы там в этом плане хотели увидеть не только в плане один из элементов для чего делается секционирования одна из задач это ускорение выполнение запросов которые выполнить достигается за счет того что мы исключаем ненужные секции из просмотр взгляд умеет делать на двух этапах выполнения запроса во первых на этапе планирования запроса это так же как и все то же самое что и было при секционирование через наследование также теперь это можно делать и декларативным то есть если мы прямо в запрос написали константу там вот наш ключ секционирования там равняется там какое-то конкретное константа или функция имеют обл которую планировщик под газ и имеет право выполнить прямо на этапе построения плана потому что это значение не должно меняться и дальше принимать решение в замесите зависимости от этого и огромным шагом вперед по сравнению с наследованием стало то что теперь декларативным секционирование мы можем отсекать секций на этапе уже выполнение они построения плана а это позволяет нам например писать запросы в которых мы не обязательно константы пишет а можем вообще говоря писать любую функцию которая возвращает выражение stay бл правда пока это работает только для select если мы будем делать апдейт или до лета то у нас не будет работать такое исключение но опять же чтобы не только были слайды и какие-то картинки можно найти наверное этот примерчик на команде посмотреть да ну вот вот верхний запрос если мы пишем константу то здесь все конечно же по ключу секционирование мы смотрим только в нужную нам секцию за этот месяц и больше ничего если же мы сейчас в двенадцатой версии да и в 11 напишем функцию а функция ту там за таймс темп это функция stables вот то у нас по-прежнему исключение секции будет выполняться она только в плане запроса будет отображено чуть-чуть по-другому у нас будет написано со план с риму вид то есть у нас уже запрос начнет выполняться и на начальном этапе выполнения запроса будет вычислено эта функция и только после этого уже puzzles выполняя поймет что не везде надо смотреть и вот у нас со план своему with 2 вот мы две секции можем пропустить и только в третью пойдем но вот та же самая штука вот для запроса билеты для авдей точно также она пока умеет не умеет так делать она будет ходить во все три секции вот поэтому для команд обновления пока по-прежнему лучше использовать константы если такая возможность есть ну и также что тоже достаточно важно на этапе исполнения если мы соединяем нашу большую секционирования таблицу например с каким-то небольшим справочником под запросы типа int а ну или просто какое-то соединение то планировщик теперь у него есть еще одна стратегия выполнения плана он может выбрать про план значит соединение а таблицы nice tits boobs вложенные циклы тогда вложенный не внешний цикл будет выполняться по небольшому под запросу и на каждой итерации вот этого внешнего цикла которых должно быть не так много он будет смотреть ходить акционерную таблицу но только в те секции в которых реально сейчас есть значение вот от этого от внешней итерации от внешнего итератора это вот тоже замечательная возможность она сейчас появилась но не все конечно бесплатное то что нужно и смысла учитывать это то что если мы отсекаем секции на этапе выполнения это здорово с одной стороны но с другой стороны когда у нас начинается уже само выполнение если у нас секцию очень много значит пожгли сначала выполнит эксклюзивную блокировку ну access же она он сделает так саша эксклюзивную конечно access шея блокировку наложит на каждую секцию нашей таблице поэтому если их будет там несколько тысяч условно то соответственно впг looks у вас вы увидите вот столько же вот строчка это наверно повод будет задуматься о том что наверное нужны параметров макс лог супер транзакций нск скорее всего наверно придется там и увеличивать из для того чтобы выделить больше размеров оперативной памяти под блокировки объектов это вот один как бы способ расплаты за такое удобство другой это то что клиентские процессы когда выполняют запрос вообще когда работают у них там есть разные каши и в том числе есть конечно системного каталога в которой вот те значит объект с которыми мы недавно выполняли они там в нем сохраняются для того чтобы можно было быстрее доработать соответственно если мы работаем с табличкой у которой там десятки тысяч условно там скажем секций то они все попадут вот этот локальный кэш ну и наверное на каком-то количестве это начнёт давать о себе знать что может быть не очень хорошо это все опять же к вопросу тому что нужно кстати вот подходить к выбору количество секций которые должны использоваться ну так стать имея какие-то измерительные линейки и проверяя все своих реальных условиях вот потому что с одной стороны может быть удобно с другой стороны это могут быть какие-то недостатки добавление запись здесь тоже произошли некоторые важные изменения ну вот в первую очередь от некоторые формы они там любят вот чтобы вот insert или торнинг мы делаем и вот эта риторика мы должны получить что но только что вставили если мы говорим про секционирования через наследование то там у нас ничего не вставляется потому что там вот сидит вот этот вот наш триггер который переносит insert в нужную секцию и возвращает null потому что в родительскую таблицу ничего не вставляет ensure тритон не работает нет у нас триггера теперь декларативным секционирование returning отлично работает еще одна команда insert с опцион конфликт если мы загружаем какие-то наши данные откуда-то массово и у нас предусмотрено возможности до загрузки повторный и в этом случае если такая запись уже нас там действий на только обновить да вот insert конфликт замечательная фраза но вот до 11 версии пожгли say if секционирование через наследование она работает совершенно неправильно ну наверно проще сказать не работает потому что она пытается только искать запись есть она или не только самая родительской таблицы по секциям она не ходит там она ее скорее всего не находит и считает что надо делать insert это неправильно начиная с 11 версии insert конфликта отлично работает ну и сама скорость ставки опять же здесь понятие быстро медленно которые мы опять же верить на слово нельзя нужно только проверять но наверное понятные причины что раз у нас в наследовании есть триггер то он точно не должен ускорять работу раз у нас триггера нет ну значит это наверное должно быть быстрее ну плюс к тому появились некие патчи в частности в двенадцатой версии но вот задекларировано что есть патч который существенно ускоряет работу команды копи которая массово загружает данные вот в таблицу но в секционирование через нас ли давние там известный там есть прием если мы загружаем код объём больших данных с вами заранее сами понимаем покатим секциями нужно развести то лучше прямо разбить на отдельные куски и загружать непосредственно вам нужную секцию нежели вот это вот все пускать через триггер для декларативного секционирования есть еще некоторые оптимизации которые были предусмотрены они работают только для него и поэтому есть смысл говорить только про него ну я их сейчас покажу сортировка по индексу понятной общем-то темы известно вот если забыть про секционирования вот у нас просто есть таблица мы из нее выбираем записи и пишем ордер buy там какой-то столбец как можно выполнить сортировку как postgres точнее говоря умеет это делать ну либо мы выбираем записи и там в плане у нас будет узел сорт который запись сортируют и дальше выдают некоторые накладные расходы ну так делает а если у нас по этому столбцу есть яндекс то планировщик может предпочесть b3 яндекс может предпочесть сканирование по индексу потому что в яндексе данные уже сохраняться упорядоченными и можно использовать этот так вот это вот ровно та же самая идея только теперь она еще и распространяется на секционирование таблиц и если у нас есть несколько секций и мы хотим результат возвращать отсортированы по ключу секционирования например мы по датам там реже мы хотим по датам живется отсортировать отпуска сейчас умеет эту оптимизацию делать ну как бы это могло выглядеть вот смотрите запросу проще некуда вот select звездочка из таблички букин гринч вот ордер buy books do it вот по умолчанию как он будет делать если у нас индекса побуждает нету вот мы сначала просканируем все секции соберем их узи и append а дальше вот у нас узел сорт который начинает их сортировать и прежде чем отдать первую запись ему вот надо потратить вот какую то там вот он оценивает ее вот там почти 25 тысяч там каких-то попугаев вот если же мы создадим яндекс по этому столбцу ключу секционирования то вот какие говорил нас создадутся отдельные индексы на каждую секцию но теперь этот же самый запрос он будет уже использовать яндекс can то есть сами секции они секционирование симости от значения то есть если у нас здесь было по месяцам то понятно что июня то раньше чем июль вот июль раньше чем август это мы можем уже сразу так понять а внутри секции у нас есть индексы узел сорт нам не нужен минимальная начальная стоимость прежде чем мы отдадим первую запись вот здорово отлично и еще есть 2 оптимизации они очень похожи агрегирования по секциям соединения по секциям я сейчас попробую быстренько найти вот они но сначала с агрегирование начнем она так вот визуально вообще просто запрос select звездочка from секционирование таблиц и сейчас она тут уже секционирование списку значений до принцип тот же по месяцам как он может выполняться мы можем выполнять так мы сначала прочитаем до в параллельном режиме но тем не менее мы соберем данные из трех секций а дальше уже у нас будет их агрегации дальше мы посчитаем сколько их там записей но в тех случаях если у нас одна из секций является например у внешней таблицей подключены через после свадьбы и расположенного на где-то на удаленном сервере это означает то что нам нужно скачать оттуда все данные и только потом мы сможем приступить к und что на самом деле наверное для производительности ну точно не очень вот у нас появился в 11 версии такой параметр и если мы его включим то тот же самый запрос теперь может выполняться вот таким образом мы сначала делаем паршиво логре great в каждой внутри секции мы вычисляем этот каунт а потом уже только на самом верхнем углу финала из-за грига и тут эти три числа она служит между собой и все поэтому этот пошел а кредиту на удаленном узле нам посчитает а даст 1 ci слот это понятное дело что будет намного быстрее ну и похожие же вещь связанные с соединением таблиц ну вот здесь у нас есть две таблицы bookings лист и и каждому бронированию еще может быть одно или несколько ни один или несколько билетов в него могут входить они тут по какому-то условия соединяются нам не важно важно то что это две таблицы они секционирования dynaco выпад они лишь по тем же самым месяцам и у одного есть секция за июнь июль август и у другого за июнь июль август и как вот такое соединение можно делать можно делать по простому сначала но вот у нас выбирается хэш соединения мы сначала собираем данные из таблицы бронирования и строим по ним хэш а потом опять же собираем данные со всех секций из таблички билетов и и и сканируем эту полученную выборку и fresh этом ищем соответствием опять же в том случае если у нас часть секции расположены удаленно это точно не эффективный способ работы и если включить соответствующий параметр а по умолчанию кстати они выключены от предыдущей вот этот то у нас то же самое с джо и но только внутри секции то есть сначала у нас секция за ее 2 табличек сливаются секция и за июль сливаются секции зовут сливаются и потом уже результаты выдаются наверх это существенно эффективнее по умолчанию и возможности отключены обе потому что считается что но не всегда не все во всех случаях вам идти оптимизации нужны они когда они включены время на планировании немножко возрастает поэтому про них есть смысл знать если вам точно подходит тогда их можно включать я не случайно вот эти несколько раз говорил слова про внешние таблицы и как вот мы можем с разных серверов там получать вот эти данные вот эти оптимизации которые в эту сторону а делаются все дело в том что естественным продолжением работы в этой области является вот так называемый sharding вот у нас пред предыдущий доклад в принципе уже был на эту тему мой коллега андрей ли пиков рассказывал про попытку которую мы делаем в нашей компании рисовать значит sharding в сообществе тоже ведутся какие-то работы и мы на самом деле как андрей говорил будем пытаться свои наработки туда включить но понятно что вот секционирование и когда секция могут являться внешними таблицами подключенными через пол сптв это вот та база на которую уже можно дальше строить и развивать вот это направление у меня дальше будут какие-то ссылки и в том числе ссылки на презентацию брюсом жанна но наверное брюса в этой аудитории не надо представлять от которого у которого есть доклад и в оформлены виде презентации на ютюбе можно видео найти он уже последние полтора или два года он периодически обновляет вот посвященные именно шарден гу в пожгли си понятно что от прежде пока вот эти базовые вещи не были сделано дальше не было смысла про это думать и говорить вот но тем не менее вот брус по крайней мере отвечает что отмечает то что в этом направлении нам о чем нужно думать нужно подумать о том как параллельно выполнять запросто есть уже сейчас можно раскидывать запроса чтобы они выполнялись на разных узлах но пока не выполняются последовательно андрей кстати пройти сегодня говорю хорошо бы еще сделать также некие глобальные менеджер транзакций для того чтобы свойства песен когда мы меняем данные на разных узлах одновременно соблюдались хорошо бы чтобы данные согласованные мы помогли получить с разных шар дав нам нужно никита кстати управления глобальными снимками но и управлять этим всем не каждый раз там писать там корейцам форинт эйбл там там то там то что это у нас секционирование таблиц и а тоже иметь какой-то более удобный способ управления но это все будущие там еще наверняка много чего нужно сделать непонятные пока сроки потому понятны направление в каких двигаться сроки пока они не очень понятно но это вот тем не менее это интересно наследование если вдруг кто то все таки уже с давних времен использует наследование никак не может отказаться от таких вещей как то что у вас на секциях должно быть разное количество столбцов вот на одной там 10 столбцов на 3 там три вот на родительской там минимальный набор да она она дочках может на надо детка хуже их может быть там побольше поменьше так далее если вы хотите множественное наследование когда у вас там не только от этой трагической таблица у нас у вас счетом есть и второе родители третий и так далее вот тогда встроенные секционирования но не подойдет потому что там есть жесткие ограничения внутри там сидит это наследовать но количество столбцов должен быть жестко совпадать с иронической таблицей множественное наследование запрещено но и такой еще спорный момент когда нужно сказать что ограничение чек вообще-то говоря но пошили чем раньше листы хэш условия которые мы можем вложить там можем чеки указать вообще любые условия вот если вдруг это важно то это тоже следует имейте ввиду это гор но на самом деле никакой битвы не предполагалось изначально потому что все таки встроенное секционирования это то ради чего она делась и его и нужно использовать и наверно сейчас уже можно говорить что в двенадцатой версии да по большому счету его один сторона уже такой утку до зрелости достигла его с ним можно уже работать и те основные задачи которые обычно используются для чего используют секционирования она уже успешно решает вот ну секционирование через наследование нужно сказать спасибо пожать руку вот ну возможно продолжать его использовать если у вас все устраивает вот но тем не менее этот большую битву я не ожидал устраивать ну и самом конце хотел сказать что если вы хотите получить еще какую то информацию по этой теме то я подобрал по крайней мере те источники которыми сам пользовался но в первую очередь безусловно документация это релизнуться которых вы можете узнать что появилось каждой конкретной версии это какието доклады которые я посмотрел это какие-то статьи в блогах там тоже много еще всего интересного и опять же напоминаю что вот есть демонстрация в которой достаточно длинный длинный развернутый пример по всем возможностям максимально по всем возможностям он в этой демонстрации доступен вот продолжая спортивную терминологию я вот несколько раз туда включался типа там вот обзор лучших моментов вот но тем не менее этот обзору не заменяет кстати просмотр всей игры вот поэтому если у вас есть желание дальше смотреть интересоваться этой темой то посмотрите но и в любом случае игра это и есть игра вот а настоящая жизнь и она у вас с вашими системами и я надеюсь что если вы встретите системы секционирование то вы подойдете к этой встречи во всеоружии спасибо спасибо большой павел ребята интеллектуальная игра будет во время автомате и стал и только для игроков для команд сейчас когда закончим задавать вопросы в зоне визиток запишитесь на мозговой нею а сейчас задайте вопросы просто для того чтобы участвовать в игре нужно записаться заранее да пожалуйста добрый вечер спасибо за доклад дима по силе всем этим вопрос такой у меня несколько вопросов можно 1 очень хотел спросить у то всем докладе я ничего не услышал по поводу статистике просто работа администратором oracal и знаю что при проецировании есть масса разных нюансов со статистика связаны и и специальной технологии которые помогают с этим бороться что можете сказать о статистике и марте церовани ip-адрес акционерами а о какой статистике идет речь тут надо уточняющие вопросы статистики для реализаторы я понимаю что статистике оптимизаторы какой конкретно имеется эту статистика по конкретно partition иметь свою я имею эту информацию о составе строк размере среднем значении так далее эта информация вне зависимости от того секционирования таблицы или нет по сути дела за секциями скрываются обычные таблицы по которым оптимизатор при команде он alive собирает статистику о размере строк о распределение значений гистограммы все дела эта статистика она есть как для обычных табриз так и для секционирования она никуда не девалась просто вот есть понятие глобальная статистике то есть некие подобные значения но собранные для всей таблицы в целом здесь собираются значение только по отдельным секциям не понял еще вопрос есть по поводу рекомендации потому что я знаю что например там жорке есть определенные проблемы при достижении некоторого количества партиций какие то вы можете дать рекомендации поводу тогда ну когда стоит задумываться парте церовани при комнатном объеме и таблицы в размере количество строк и так далее и по распределению грубо говоря качества по партийцам там по дням лучше делать по месяцам по годам но вот этот медленный а вы знаете это самый такой вопрос на который нет однозначного ответа и вот на самом деле в документации по пожгли су там вот сейчас в двенадцатой версии там даже появился вот такой раздельщик который посвящен ровно ответу на этот вопрос но он там настолько размыт что вы никакой вот там есть некоторые общие советы по тому как это нужно делать но в любом случае все нужно проверять на конкретных данных потому что для кого-то 100 много для кого-то 10000 мало некоторые моменты я про них говорил то что огромное количество секций оно неизбежно ведет к тому что конечно системного каталога в запросах он будет увеличиваться расти в размерах и это точно не будет способствовать производительности но вот в какой момент это конкретно конкретной системе рванет на каких значениях там на 10 тысячах или на 50 или на пятистах это все-таки надо проверить эмпирически но по большому счету да и еще последним просто вот я обратил внимание что если это ограничение на 100 версии я надеюсь что меньше но тем не менее вопрос заключается в том есть ли какие-то преимущества в подлости профессиональными понимает что код довольно сильно отличается от оригинального по поводу например авто создание партиции или по поводу браунинга для динамические параметры завалит выполнение смотрите когда ну если говорить про нашу уже сборку пропускаешь пару у нас там есть модули по г пасман он появился примерно в одни строки с десятой версии когда появилась декларативное секционирование но тогда в по здесь она была совсем слабая пасма не были реализованы куча вещей которые сейчас двенадцатой версии уже все реализованы почти все по моему вот я могу навскидку сказать что в нашем plasma не вот там по моему есть некий call callback который позволяет при вставке записей если еще нужны секции нет автоматически эти секции сосуда создать с одной стороны с другой стороны если мы хотим разбить таблицу обычно у нас есть таблица и мы поняли что ее пара разбивать вот там есть тоже набор функций представления мы можем допустить их на таблицу указав правило разбиения и она пончиком так стать не прерывая запросов к ней начнет потихоньку разносить и за этим процессом можно мониторить на какой он кстати идет вот эти вещи а все остальное вот ну в 12 версия по крайней мере точно то что встроена в пожгли со но вот уже догнал а то что было в паз мне ну то есть паз на доступен на в комьюнити я имел ввиду именно встроенном порционирования позволь стройнит отличие вот он у нас встроенного не было бы делали в виде именно в виде расширения я понял спасибо чем пожалуйста да ваши вопросы написать сейчас используются такие объекты час он у сложно объекта катарина то использовать используем укроп если пост про из для этого и вопрос о том как он работает на секционирование работать фокус воскресе плане секционирования то есть часто используем сложные поиски которые используются внутри джейсон объектов и как секционирование может поможет или не поможет в этом данном вопросе когда надо параллели раз проверить данном случае поиск сложно такие как скажется на объекты смотрите ключевая вещь для секционирования это ключ секционирования то есть то как вы разбиваете большую таблицу на отдельные секции вот джейсону насколько я понимаю не может служить таким ключом эффективном по крайней мере до поэтому для того чтобы эффективно исключать ненужные секции из запроса вам нужен какой то явно выраженный ключ к месяц там не знаю там день там или там филиал там или клиент вот если в вашем запросе это будет указано а дальше уже внутри нужные секции уже можно там искать что-то внутри джейсону спасибо друзья еще вопросы отлично кому книжка подарим о чем человека 40 лари конечно же я тоже какое-то время работал 40 мм я знаю что там встроенное секционирование появилась в oracle 8 если не ошибаюсь это вторая половина 90-х годов и очевидно что за те двадцать с лишним лет секционирование в подписи прошло наверное уже существенно больший путь чем в полисе и наверное там те вопросы которые мы обсуждаем там коллегам кажутся уже немножко такими странными и давно решенными но тем не менее у нас это так тем не менее у нас то все равно работает вот а вот а коллеги большое спасибо за вопросы и ему конечно же этот подарок спасибо большое памятные призы"
}