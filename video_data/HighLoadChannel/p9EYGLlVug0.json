{
  "video_id": "p9EYGLlVug0",
  "channel": "HighLoadChannel",
  "title": "Toggle your app / Евгений Кривобоков (Авито)",
  "views": 1201,
  "duration": 3073,
  "published": "2018-01-16T12:02:10-08:00",
  "text": "компания vito и занимаюсь разработкой основного мобильного приложения под android и так крупными мазками что это за приложение это приложение в котором разные люди могут публиковать объявления о продаже товаров важных или новых и за последние годы наша команда уже сильно выросла у нас больше 20 android-разработчиков только она вот это приложение довольно активно кантри beauty вносим изменения мы уже довольно давно перешли накоплен начале эксперимента еще когда он был в бете из релиза 10 уже начали мигрировать старый кот это тоже способствует лучшей работе в большой команде но о чем же будет доклад доклад будет о том с какими проблемами сталкиваются большие команды большие приложения и и об одном из подходов который помогает нам разрабатывать более стабильный продукт спать спокойно при этом оставлять себе возможности пространство для экспериментов чтобы наша работа и наши эксперименты не влияли на стабильность продукта потому что пользователи много и цена ошибки довольно высоко бывает и мы должны себя оградить от этих проблем немножко расскажу предысторию что было раньше и как у нас была организована работа у нас были раздельные команды по функциям то есть была отдельная группа тестировщиков отдельная группа разработки front and back and мобайл и задачи двигаясь по вот этому плану они постепенно переходили из одной команды в другую и у этого есть свои пределы масштабируемости то есть постепенно мы начали понимать что нам нужно дробится на какие-то более мелкие независимые команды появилась такая матричная структура она была довольно сложной и вот это вот эти стремления не совпали с общими изменениями в компании и постепенно мы перешли на независимые команды юниты как они работают в каждой команде есть представители всех функций то есть и менеджеры дизайнеры тестер во всякие там вплоть до юристов и принцип разделения на эти команды он не технически а именно с точки зрения бизнеса то есть вы дели одну команду которая решает проблемы продавцов другая команда решает проблему покупателей и каждая такая команда она может независимо поставлять пользу вот этой своей группе пользователей и решать какие-то например проблему техподдержки их независимость она в кавычках она неполная но в принципе они могут самостоятельно принимать большинство решений но хоть они и работают независимо все равно не модифицируют одно и то же приложения точнее говоря модифицировать они могут любые сервисы любые приложения если они считают что это им необходимо то здесь нет привязки вот этих команд к отдельным приложением и так как и раньше каждый разработчик делать свою задачу в отдельной ветке тестируют ее борется там с конфликтами чтобы на пол request и их не было много периодически подливают основную ветку здесь можно много поговорить про то что большие ветки и большой пузырь крест это плохо и как можно с этим бороться потому что это можно решать именно уже инструментами например об source позволяет просматривать более изолированные кусочки и бороться с большими бури квестами но все равно вот это изменение она остается довольно большим и так разработчик все это сделал протестировал проверил и сливает в основную ветку и один из основных вопросов которые ставят это можно ли теперь это релизе ведь казалось бы все проверено все протестирована причем протестированы июне тестами и функциональными тестировщик глазами посмотрел все должно быть хорошо но не все бывает хорошо все равно иногда вылазят боги потому что невозможно предусмотреть сто процентов ситуации что же делать в такой ситуации конечно надо решать в индивидуальном порядке где-то это быстрее исправить где-то может пойти на компромиссное решение но мы не можем оставить это подвешены в воздухе все равно нужно подключаться разработчик подключаться может быть поэму разбираться в ситуации анализировать а скольких пользователь это затронет это все отнимает время в большой команде когда людей становится много продукт меняется довольно быстро в нем постоянно происходят какие-то рефакторинга этому внедряются новые фичи такая нестабильность она начинает накапливаться и конечно мы регрессионное тестирование проводим на отдельные ветки чтобы была возможность изолировать эти измене но все равно возникает ощущение такой бесконечные гонки что мы догоняем вот эту стабильность мы постоянно исправляем вот эти баги которые были внесены в процессе этого релизного цикла и мы вкладываем много усилий в авто тесты автоматизацию но кажется что можно решать эти проблемы другими способами мы тоже так подумали что может нам зайти сбоку эффекты с другой стороны на это посмотреть и посмотрели на подход фича tables впервые он встречается у мартина фаулера его оригинальной статье там очень красиво все рассказывает если очень кратко то эта возможность изменять ваше поведение без изменения кода конечно здесь стоит звездочка что совсем без изменения кода вряд ли получится если это что-то нельзя подправить на бэг-энде то никакой магии не бывает и нам нужно менять код приложения можем лишь обсуждать подходы как это делать дешевле там же в оригинальной статье приводится очень хорошая классификация которая построена на двух очень важных параметрах это время жизни этого фича тогда и его динамизм и в зависимости от этих параметров и их сочетания эти переключатели могут решать самые разные задачи из наиболее очевидных это обед с ты проведения различных экспериментов здесь все понятно нам нужно просто подержать разные варианты поведения в приложении управлять ими с бэг-энда и проверять различные гипотезы плюс есть различные переключатели которые вызваны именно техническими проблемами например если мы знаем что по нагрузке мы не уверенны что выдержим такой поток пользователей и наши нагрузочные тесты все равно могут не отражать реальность вот эти все переключатели они могут жить довольно долго там несколько месяцев нормальная история потому что эксперименты могут проводиться вплоть до месяца зависимости там от аудитории прочего но я бы хотел сосредоточить ваше внимание все мое повествование на релизных переключателях потому что без них собственно не будет вот этого подхода внедрение новых вич и не будет стабильности то есть вот эти все различные виды они хоть и могут управляться немножко по-разному но в принципе подходы всеобщее идеи все одинаковые и поэтому рассмотрим вот именно релизные переключатели и так как выглядит жизнь 1 фичи и каким образом вот уже поставленной задачи код попадает к пользователям есть вот эти независимые команды каждая из которых поставляет новую фичу в продукт и они конечно хотят успеть какому-то релизу но срок говоря нужно различать эти два процесса то есть есть реализация какой-то фиче есть я поставка к пользователю здесь хорошая концепция торелли стрэйн когда мы просто берем то что уже готова то что сделали различные команды и выкатываем это пользователям здесь команды они не должны заботиться вот этими техническими моментами как это все это происходит и препятствие здесь только одно это неготовность фич какие-то баги недоделки с которыми надо что то делать одно из решений просто их отключать точнее даже не отключать они включая до тех пор пока мы не убедились в стабильности фич собственно фичи тогл и и реализует подходом и прежде чем обсуждать технические тонкости надо упомянуть одну важную вещь что это все сильно не бесплатно и прежде чем использовать вот эти способы обеспечивает гибкость в коде надо подумать можно ли бизнесу предложить такие варианты чтобы фичу выкатить более мелкими кусками начинать какого-то мвп потому что всем так будет проще и разработки и бизнесу но если уж пришло дробить фичу то можно выделить следующие фазы в первую очередь мы должны думать о том как фичу отключить если что-то пойдет не так возможно ли у нас запасной путь потому что если бак выявится уже на этапе регресса или уже на проди то нам нужно будет паниковать и думать как же теперь закрывать эту проблему если мы заранее знаем что фичи сможем отключить у нас есть как минимум один запасной вариант мы всегда знаем что по-крайней мере мы сможем это быстро отключить после того как мы подумали об отключении фичи мы уже можем начинать ее реализовывать здесь как раз таким неограниченный ветками можем делать маленькие полые крест и как ветки живут сильно меньше чем если бы была одна большая в процессе можем отдавать в тестировании исправлять какие-то баги и уже по окончанию этого процесса фича включаются причем этот момент он по времени может отделен то есть у нас принятие решения отделена от того как мы ветках уже доставляли сам код и через какое то время когда мы уже убедились что фича стабильно мы можем удалить переключатель и избавиться от части технического долга который мы привнесли ранее определение времени когда рекомендуется удалять фичу это момент такой интересный потому что по сути здесь это баланс между рисками и тех долгом здесь нужно всегда смотреть на то когда она может понадобиться отключать фичу как правило это происходит уже в следующем релизе когда мы увидели что на реальных пользователях это работает по данным мониторинга все хорошо в аналитике тоже нет опасений и мы знаем что скорее всего нам не понадобится ее уже отключать итак еще раз акцентирую внимание что это все бывает доброго и поэтому надо понимать ради чего это все происходит и не забываем также планировать удаление то есть это все живет мне постоянно в приложении а временно для пояснения идеи подходит самый простейший способ написать обычно их флажком который показывает что до того как мы переключим наше поведение на новую реализации у нас какое-то время их будет жить в коде 2 просто переключаем от одной из другую и конечно по умолчанию новое поведение должно быть отключено потому что мы еще не уверены в нем также есть еще такая концепция как-то город анапа она появляется по одной простой причине что со временем такие флажков становится по приложению довольно много и за ними всеми тяжело следить то есть разработчику даже самому трудно сказать объяснить тестировщику или поэму а что сейчас включена что отключена и хочется иметь централизованный контроль и одним взглядом обозревать все вот эти переключатели в приложении эта схема конечно начинает еще усложняться но что мы понимаем что нам не хватает просто флажка появляются разные типы плюс эта информация что можно представить в виде этой меткой информации например если мы генерируем какие-то отчеты или показываем интерфейс это у нас должно быть человека понятное описание этой фиче на русском языке у нас для автоматизации есть какие-то уникальные ключи к которым мы можем эту фичу найти плюс у нас здесь может быть спрятана знание о зависимости эта фича от каких-то других это происходит редко но тем не менее то есть с одной стороны можно прямо в значении присвоить через логическую проверку зависимость от другой фичи но с другой стороны это можно использовать только в ран тайме но нельзя уже при генерации отчета или в интерфейс и когда мы одну фичу отключаем чтобы другая тоже само отключилось вот эти сегменты придется описывать в метаданных и это все будет спрятана вот того кода который используют фичу он будет просто использовать флажок и интерфейс роутера становится уже более красивым и так у нас есть набор флажков мы начинаем по всем слоям приложения размазывать эти переключатели и изменять поведение и конечно разумные опасения что это может стоить довольно дорого есть риски допустить ошибки и самый дорогой слой это конечно размазывать это в слое view надо как то с этим бороться в принципе все подходы не довольно стандартные не пришли из рефакторинга и надо просто прятать от знание об этих вещах от клиента например нужно всегда помнить о том на каком уровне абстракции мы работаем то есть когда мы принимаем решение о том какая логика сейчас должна включаться мы должны улавливать вот эту разницу между самой логикой и способом и переключения в простейшем случае мы просто прячем эту функцию знания про фичи и клиент не знаю о том каким образом принято это решение он просто знает можно ли им использовать эту новую логику или нельзя а значение этой фиче она может зависеть от самых разных параметров следующий подход это аналог инверсии управления когда клиентский код не знает о том откуда он получился и как он реализован то есть например на уровне dependency injection а мы просто переключаем логику подставлен другую реализацию с тем же им интерфейсом и клиентский код который использует уже эту инвестированную зависимость он не знает о том что там уже на самом деле нового реализация этот подход бывает довольно дорогим если здесь большая абстракция а бывает наоборот самым дешевым надо уже смотреть по ситуации но отчасти вам провоцируют делать нашей сущности меньшую и больше соблюдать срп еще один подход из рефакторинга который часто используется это ветвление с помощью абстракции они с помощью веток и в принципе этот подход довольно точно и емко отражает саму суть вот этих фич это глав когда мы реализацию не привязан к нашим деткам а привязана к нашим абстракциям в коде на простом примере у нас есть несколько клиентов которые используют общую зависимость и нам нужно ее поменять и мы понимаем что самый дешевый способ это написать новую реализацию этой зависимости но как ее подставить старым клиентам ведь в каждом из этих клиентов придется сделать какое-то переключение решение здесь поэтапно нам сначала нужно ввести новый слой абстракции постепенно переключать на него клиентов и когда они все будут использовать новые слои абстракции то уже внутри него мы можем подставлять разные реализации в этом в общем то есть основная суть подхода когда мы отвязываем логику от того как мы управляем ветками после реализации когда мы все написали покрыли тестами тестировщик посмотрел настало время что-то включать здесь зависит от того какая эта фича случае экспериментальных фич самый простой пример это обычный переключатель в бэг-энде который просто меняют поведение здесь можно здесь конечно не учитываются никакие версии клиентов версия операционной системы это обычный рычаг переключатель в случае с собой тестами тут уже не обойтись такой простой схемы и нам приходится делать именно реализацию в коде чтобы можно было понять какой группе пользователей относится данное приложение но такие переключатели могут быть например в кнр релизах если мы хотим пользователям предоставить какие-то фишки которые еще экспериментальные но мы готовы их уже показать например в браузере google chrome целый огромный список таких экспериментальных возможностей которые можно включить на свой страх и риск у нас еще нет такого ну почему и нет интересный сценарий когда нельзя просто так взять и выключите фичу рассмотрим на примере когда две команды независимых делают изменения и при этом им необходимо поправить api это могут быть две команды в рамках одного приложения или например android и ios команда который просто имеют разный релизный цикл и не могут с одинаковой скоростью поддерживать какие-то задачи и так одной команде понадобилось внести новую функциональность и они понимают что для этого нужно поменять api потому что старые клиенты не должен увидеть эти изменения они поднимают версию метода теперь другой команде понадобилось тоже внести эти изменения не в приложении закрыли их переключателем а папе чтобы изолировать эту разницу от старых клиентов также нужно поднять версию но какая тут проблема в том что выбранный способ изоляции данных и изменению их относительно старых клиентов он подразумевает строгую линейность то есть то что было во второй раз и метода оно должно быть поддержано в 3 и мы не можем на клиенте выключить поддержку второй версии так чтобы третью так чтобы 3 работала то здесь нужна строгая последовательность она разумна если меняется формат ответа и не поднять версии мы просто сломаемся старых клиентов как вот примере с пилотом в ушах было недавно но если меняются самые данные а парсинг на старых клиентов не ломается они просто они должны видеть какие-то новые записи то тут в принципе у нас есть варианты мы можем сделать более гибкую схему и например из приложений передавать знания о том какие сейчас фичи в приложении есть какие из них активны передавать это легко например на уровне о качестве типа interceptor а в клине ца и добавлять заголовком будут перечислены идентификаторы активных вич чтобы немножко сэкономить можно подумать о том что нам нужно передавать для каждой фичи эти данные плюс не каждый фича может в принципе влиять на ответы запишем отдельно помечать запросы в которых мы знаем что backend будет учитывать эти знания но идея становится все так же клиент публикуют часть вот этого внутреннего состоянии чтобы бэкон подстроился под под него это можно сделать также со стороны бэкенда но это уже вариант такой более жесткий потому что он не учитывает эти сборки из разных веток сборки с разным состоянием фич он подходит только для каких-то жестких и простых решений поэтому хорошо если у нас есть один источник правды и приложения говорит что да действительно я эту фичу поддерживаю вот верни мне для нее данные что собственно происходит дальше когда настает время удалять переключатель то мы должны найти все места в которых он использовался и удалить старую реализацию попутно убрав часть технического долго который мы привнесли здесь можно порассуждать про то как найти такой код который использовал старый фичи но там в общем то не рокет сайенс и это решается простыми средствами отдельно я выделил тестирование приложений потому что это довольно такая важная область которую мы сейчас активно вкладываемся и здесь есть не очевидные моменты как знания про эти переключатели проникают и наши тесты и так если бы у нас не было вот этих переключатель и мы бы тестировали по старинке отдельных ветках дожидаясь полное завершение тестирования тестировщики собирают сборки из разных веток проверяют в изоляции эти изменения и у нас не соблюдается идея сей потому что уверенность в том что это все в совокупности будет работать после слияния уже меньше но боремся с этим инструментальными средствами например теста у нас запускаются не на отдельные ветки когда пол request we sit on результате слияния develop в ветку с фичей но все равно остается определенные риски плюс то что нельзя не исправить никакой автоматизации это опять же конфликт и потому что даже постоянно подливая develop все равно в конечном счете если тестирование задерживается у нас в devil api могут накопиться какие-то изменения которые потребуют ручной правки и автору фичи придется это все исправлять если у нас мир жил уже заранее то ему не нужно постоянно вот это подправлять за это за него это делают другие люди которые лезут его код вот этот экран мы предоставляем тестировщиком и не только чтобы была возможность в не релизных сборках во-первых узнать какие сейчас есть фича в приложении какие из них каком состоянии и включите для тестирования в коде это выглядит как еще один слой абстракции когда мы над фичей делаем ее изменений вариант оригинальное значение она в этом декораторы просто берется из самой фичи из релизной потому что для любой фичу у нас есть дефолтное состояние а значение это по сути то что могло поменяться и сравнивая эти два варианта мы можем тестировщик подсказать что он сейчас включил экспериментальные это фишки и приложение может вести себя нестабильно возникает вопрос как это все скрыть от тех людей которые любят ковыряться в чужих приложениях сейчас вот этот экран и по сути большинство этих абстракций которые работают фичами они находятся только в дебаг спросите и поэтому пользователь за точно никак не попадет но если кто-то раз ковыряет и посмотрит какие-то остатки кода ну ничего страшного если бизнес считает что новая фича критично и you нельзя никому показывать даже чтобы вы не могли найти отключенные то этот момент обговаривается и просто на уровне интерфейсов делаються разные реализации и опять-таки у нас настоящий реализация до какого-то времени находится в дебаг форсети и не попадает в релизную сборку есть у нас вот этот набор переключателей по всему приложению и каждый из них меняет кусочек поведения и хорошо если они еще не связаны но все-таки как это все тестировать ведь нам нужно перебрать хорошему все состояния и если это обычные флешки то это 2 в степени состояние и кажется что это не то чем мы хотим заниматься и мы не хотим писать только тестов ленин тестах история получается простая и мы просто пишем тест на включенное состояние и на отключенные все выглядит просто то есть никаких казалось бы подводных камней но есть кое-что это взаимное влияние когда тестируемый год несмотря на то что это unit-тест он должен проверить строго одну маленькую вещь всё-таки может использовать какие то другие переключатели уже внутри и мы этого можем не узнать то есть например кто-то другой включит фичу и она сломает эти тесты и мы к этому не готовы то есть мы рассчитывали на то что проверяемый код он не должен использовать другие фичи как это выявить выявить довольно легко потому что в нем тестах мы создаем только небольшой под граф наших классов и поэтому надо просто не создавать дефолтное состояние фич а надо создавать пустой мог и любые неявные использования каких-то других зависимости они сразу вылезут тест упадет и мы тогда уже будем разбираться а почему этот код используют два флажка вместо одного если это запланированное проведение и действительно логика такая что надо использовать два два флажка то тогда мы определяем какие состояния нужно перебрать здесь пример с g-unit params чтобы была возможность каждому методу теста указать свой тестовый набор данных и по сути перечисляем на варианты все комбинации фич и прогоняем тест в ей тестах история другая потому что здесь у нас нет возможности так уже строго изолировать проблема код и здесь нам приходится мириться с тем что приложение уже стартовала она имеет довольно сложное состояние и состояние вот этих релизных переключателей она как правило дефолтное здесь нам тоже нужно написать два теста на отключенное не включенное состояние но мы не можем уже мог от фичи как в июне тестах причем тест на отключенные состояния он уже кажется не таким очевидным вот пример мы добавляем кнопку на наш экран и раньше этой кнопки не было и у нас в голову не приходило писать тест на отсутствие этой кнопки но сейчас это является обязательным условием иначе если это не сделать в прод может уйти версия в которой эта кнопка отображается даже если переключатель отключен то есть в первую очередь мы в день ей тестах думаем о проверку на регресс и мы должны проверить что пользователь увидит чего-то лишнего он не увидит кнопку которая еще не работает который не уйдет на какой-то сломанный экран эти тесты связи пишут разработчики это у нас уже стало обязательным условиям здесь это white box где есть возможность менять общее состояние есть также функциональные тесты где внутри перри используется вот эта обвязкой вокруг с прессой у автомата ра но там уже чистый black box чтобы вот эту возможность манипуляций скрыть и там уже приходится подстраиваться под то что доступно только пользователю а зачем так усложнять жизнь разработчикам и тестировщиком тоже ведь жили раньше нормально там исправляли баги делали стабилизацию ради чего эта гибкость то есть чем оправдать вот эту сложность эти затраты и основной порт это непрерывно доставка то есть мы должны обеспечить разным командам и в целом бизнесу возможность доставлять свои фичи как можно быстрее чтобы они были уверены что они ничего не ломают они никому не мешают и в приложении это труднодостижимо потому что хоть мы и стараемся разбивать на маленькие независимые модули там применять лучшие практики все равно мобильное приложение большой монолит и с этим концептуально ничего не поделать но в принципе жить с этим можно и мешает нам только то что наша лист может быть нестабильным а в идеальной ситуации мы просто берем срезаем с мастера делаем сборку прогоняем этот тест и выкладываю на пользователи но до тех пор пока у нас нет стопроцентной уверенности в наших авто тестах нам приходится оставлять это прочные проверки и вот это непременно доставка она может задерживаться и как один из хороших инструментов которые позволяют избавляться от такой нестабильности это как раз таки гибкость который дают нам фича того следующую область куда проникают знания про переключатели это автоматизация вот пример вопросы от менеджера который немного растерялся от этой гибкости и вариативности когда у нас фича сначала отключена потом включена мои в регрессии опять можем отключить а в jiri у нас есть эти различные версии которые поставляются задачам и они могут начать врать даже если человек очень ответственно к этому относится и вот эти сущности нам нужно связать фичи в приложении которые могут быть отключены и версии в жире и так же как с ситуацией сопи это решается тем что приложение должно опубликовать свое внутреннее состояние то есть то логика который отвечает за диплом она просто на вход принимает отчет из приложения у него одинаковый формат то есть от логику можно переиспользовать и в андроиде его yes потому что это вообщем-то не привязана где луффи че есть вот в метаданных уникальный ключ он описывает как ее найти в джерри у задач есть костанае поле туда разработчики поставляют название этой фичи и эти сущности можно связать друг другом и проставить необходимые значения уже в процессе сборки релизной версии итак что же дает нам эта гибкость ради чего мы платим такую цену она дает нам возможность делать маленькие короткоживущие ветки делать маленький pull request и в процессе реализации задачек и таким образом это приближает нас к непрерывно доставки мы можем доставлять до пользователей быстрее новые фичи всем спасибо с удовольствием выслушаю вопросам добрый день вопрос будет такой вы в своем докладе несколько раз упоминали о ios команду скажите пожалуйста она у вас по той же горизонтальной структурой работает то есть там точно такая же методика применяется до подхода все те же самые используются это как раз таки в этих коров эмоциональных командах там и android разработчики айос front-end и back-end и они по сути делают бизнес фичу если она затрагивает приложение то вот эти различные функции они подключаются как в таких условиях соблюдается единая стилистика дизайна если каждая команда может делать свою функцию независимо других получается что что же должно их объединять да это решается как раз таки горизонтальными решениями если говорить про единообразие стиля это дизайн платформы где уже дизайнеры из разных юнитов договариваться как у нас должны выглядеть приложение какие у нас есть там стандартные кнопочки стандартной панельки это все поддержана в приложениях мы просто реализация новых фич ограничено этими компонентами то есть это вопрос коммуникацией и горизонтальных таких решений которые пронизывают все юниты спасибо у меня вопрос по поводу вот вы рассказали о том что есть фичи тогла и они вот есть плюс минус по всему приложению хотелось бы вот такой задать вопрос как то есть какой закономерность между тем на каких слоях обычно происходит ветвление вот это вот локи возможно это не знаю только верхние слои ли вы разрешаете абсолютно где угодно где будет удобно там и вид вим запретов у нас нет исходим из во-первых оценки того кто будет делать это где это сделать наиболее дешево если это максимально дёшево воткнуть одно условие в вьюшку хорошо пускай это будет а вьюшки если от дешевле всего сделать в день и не нужно размазывать кучу и fav по клиентам то пускай будет там то есть исходим из рисков где получается где самая дешевая реализация она и сама безопасно тут просто я боюсь такой вещи что у нас если мы разрешаем на всех слоях делать вот это вид леди локи у нас может получаться что для на каких-то экранчиков у нас будут зависимых друг от друга фича это уже очень неприятно то есть там она и в я и есть этот флажок это мы и на верхнем слое там где-нибудь ниже в сервисах дрожжи и все это флажках они от разных там переключателей завести это уже очень сложно цитировать есть такое опасение но на практике зависимых fitch у нас за всю историю было от силы пару штук и они даже если расположен одном экране они как правило переключают разные вещи и не влияют друг на друга а если влияют и нужно уже договариваться но это это уже не совсем техническое решение то есть это по сути 2 одновременных задачи то есть одна команда говорит мы хотим здесь менять вот так другая команда считает что мы здесь должны менять по-другому они должен договориться какие варианты мы здесь проводим может быть они действительно ставят разные эксперименты над одну и сущность они должны договориться между собой и обсудить какие у них варианты есть сего но но без этих переключателей они бы были вынуждены в принципе ждать окончания реализации и нельзя было вообще переключить спасибо я правильно понял что вы сделали интеграцию с jira и в джерри и в джо ременную кто-то ставит флаг о том что данная фича будет включена в сборку либо не будет это правильный понял а история какая разработчики когда делают какие-то куски и задачи которые могут быть размазаны по разных задач они поставляют принадлежность к wi-fi читаю то есть вот то что я сейчас делаю его можно отключить и читал им или нет если можно я проставляю ключ этого переключателя а автоматизация в чем заключается что в процессе запуска мы на основе вот этой связи между переключателями и зачета и проставленными атрибутами задачки мы можем актуализировать и проставить например fix вершин сказать что да вот эта фича включена и она вошла в эту сборку не бывает таких проблем что кто-то случайно в задачу jiri там этот поменял значение этого поля и несанкционированно из в итоге в итоге птичка полос по полу сборку хотя не не должно было не пасть то что мы делаем жире она не влияет на то что попадет сборку то есть мы можем ошибиться в жире и мы все стараемся автоматизации сводить к такому сценарию чтобы то есть лучше чтобы она якобы попал в релиз чем наоборот то есть если у нас в жире не будет поставлен правильно или вообще отсутствует фича того а на самом деле фича отключена то автоматизация просто вид fix вершин тестировщики буду думать о задача вошла в релиз они начнут смотреть увидят что я на самом деле нет моя шавку это твоем это не страшно в обратную сторону гораздо хуже понял то есть у вас нету такой программный автоматизации интеграции с jira и то есть от больше для тестировщиков специальное поле стоит да в принципе стараемся вот этот подход released района соблюдать то есть как в стиле карбонат команда делаю делаю делают то что уже сделали она выкатывается чтобы они не думали о том о каком включить это в релиз а когда это выйдет они делают они знают что после реализации все это может войти в релиз понятно спасибо меня вопрос сколько в итоге занимает по времени релиз фичи значит вот того момента как начинаний работать и до того как я увидел какой-нибудь уже реально же вы пользователь это ожидаемый вопрос здесь какая история есть такая фраза что чтобы что-то менять в процессах они должны быть сейчас у нас релизы долгие занимают до месяца и собственно помимо усилий которые вкладываем в автоматизацию и в тесты по сути мы хотим устранить вот эти все возникающие проблемы как на которые мы тратим время во время регресса и это всего лишь один из инструментов которые позволяют нам вместо исправление вместо борьбы с богами просто нестабильная выкидывать из релиза это конечно не отменяет необходимость хорошего покрытия тестами ну касательно того сколько времени задача будет выкатываться от начала ее реализации ну в худшем случае пройдет месяц как раз таки вот релизный цикл мы будем его сокращать до недели 2 на практике у вас примерно месяца не до релизиться просто кажется немножко гипотетически говорите это практически средние или в чем я поясню вы сейчас просто объясняйте говорите что мы стремимся но при этом будет я просто хотела уточнить это значит и именно сейчас у вас они занимают релиз фича занимает примерно месяц верно худшем случае на а в лучшем случае в лучшем случае если ее начали сделаете сделали непосредственно перед регрессом где-то две недели и хотелось вот в дополнение к предыдущему вопросу чужой touch нитевод топ-менеджеры который запутался запутался попала фича в релиз или нет в каком виде он в итоге получает ответ на свой вопрос что я понял что джерри там все отмечается чашами но как в итоге мы разобраться это отмечается постфактум но здесь все равно есть ручные фактор когда до того как у нас автоматизации просто вид все эти версии все равно приходится людям следить и оценивать какие задачи они хотят чтобы вы шли в релиз потому что там все равно нужно составить какое-то человека понятно описании там для релиз ноут для техподдержки и в этот момент тот тестировщик которые собственно но отвечает за эту фичу со стороны киеве он понимает в каком она состоянии находится то здесь ручная синхронизация на до автоматизации оно все равно есть и люди все равно смотрят какие фич ему примерно успеваем или уже успели а какие вот все равно не укладываемся то есть менеджер должен найти тестировщика который я тестировал и он скажет попал и нет нет если нужно проверить сам факт попала или нет то один запрос джерини пофиг свершено все это видно я говорил лишь только про оценку как оценить успевает или нет давайте в следующий релиз у меня такой от вопрос получается каким образом то есть никаким образом а кто именно выпиливает потом фич итоговая можете это прослушал то есть вот мы его создали там какой-то момент добавили фичу зарелизили и вот теперь нужно будет удалить этот читалось проекта кто каким образом это делать там возможно в джерек это задача для этого добавляется и так далее и второй вопрос сразу задом хотя ладно давать и так про удаление удаление нужно планировать еще до того как мы добавили сумму фичер то есть в идеале это отдельная задача она заводится ее можно заводить сразу при создании этого переключателя делает как правило тот же разработчик или из того же юнита ну если есть желающие помочь до могут быть разработчики из других юнитов просто тот кто это делал он там в курсе зачем это добавлялось каким образом вот этот тех долг приносился и он скорее всего это сделает быстрее ага ладно все понятно спасибо здравствуйте спасибо за доклад собственно вопрос используете ли вы вот данную архитектуру с переключателями для того чтобы поэтапно внедрять релизы пользователям то есть возможно как-то на 20 сначала на 50 процентов пользователей эту фичу что посмотреть если краше нет краше или это используется только в процессе разработки по сюда а здесь какая история вот эти все подходы они применимы в принципе клип большинству переключателей но поэтапная выкатка если это именно б тест до или такие какие-то более тонкие моменты то здесь уже все равно нужно управлять из бэг-энда и здесь нельзя зашить вот такое дефолтное состояние в принципе подходы все те же самые что у нас есть вот эти переключатели есть конфиге но интересность в том что для того чтобы реализовать вот эту поддержку двух вариантов apts все равно нельзя это сразу смел жить желательно закрыть и вич итогам уже релизом то есть именно для поэтапной выводки да это полноценно тогда б тест большинство практик они применимы понятно спасибо так она процент может фичи выдаваться то есть не полностью может до 1 вот здесь не была реализация таких fitch но по сути это обычный ремонт конфиг которые регулируют проведение да здесь уже можно выбрать любую реализацию или мы пользуемся к угловым решением или на своем бы кондишн это делаем она ничем не отличается от аббата 100 backend понимает по данным который передает клиент это какой девайс там какой пользователь в какую группу попадает и может делать любые варианты уже поэтапной выходки привет спасибо за доклад вопрос такой вот не бывает ли у вас ситуации когда у вас один разработчик делает одну фичу и часть ее сливает вдв и 2 разработчик в большой компании до начинает куда другую фичу делать и начинает ее основывать на тех кусках которые относятся к фичи которые чем-то еще не закончено не бывает вас потом с этим проблем особенно если первая фича никогда не выйдет в продакшн у постели решили что все плохо выпиливаем здесь и плюс 3 минус а тот факт что мы перри используем год из 1 еще и фича которая не зарелизили это может быть как раз таки плюсом потому что если вот эту первую фичу решат мне выкатывать то при удалении естественно они не смогут удалить код который используется же следующий фичи потому что ну и компилятор будет ругаться и там тестами уже покрыта и мы видим что это использовалось плохо плохо в том что могут коммуникация усложняться но другой стороны если представить что не было бы у нас этих переключателей тогда два разработчика делали бы похожее решение не перес пользовали кот у них возникли бы потом все равно конфликты то есть лучше если они увидят вот этот конфликт потенциальные раньше они уже момент когда все будут сливать здравствуйте спасибо за доклад у меня такой вопрос а может быть стоило внедрить два этапа тестирования то есть на когда это изменение еще только ветки а потом уже после нужен регрессе то есть 2 этап например то и еще у меня вопрос было ли такое что вы подготовили сборку да и от пришлось отключить все спасибо касательно двух этапов в общем то никто не запрещает тестировать какую-то фичу с начало ветки а потом интеграции здесь уже вопрос того какие мы видим в этом риски насколько она покрыта тестами различными и бывают да такие ситуации когда разработчик видит что-то слишком дорого закрывать фича табло просят протестировать ветки вручную сначала и только потом можно будет думать как это все интегрировать то есть смотрим по ситуации и здесь нет каких-то жестких правил то есть главное обеспечить стабильность и люди уже решают какими средствами можно второй вопрос напомнить ада когда все отключали когда все там нельзя ли это такой шуточный вопрос в любом нечто вообще все отключали бывало до что много удаляется но все равно даже если релиз выходит и казалось бы пользователь ни чего не привносит все равно там 0 из библиотеки как были какие-то изменения и лучше если вот это все поэтапно выкатывать потому что если накапливать вот эти изменения обновления на 3 м библиотек если полезут баги из-за этого нам тяжелее будет устранить поэтому здесь вот технические риски все равно нужно устранять постоянными релизами даже если для пользователя казалось бы там мало что нового спасибо если все тогда всем еще раз большое спасибо за внимание"
}