{
  "video_id": "ksdr3XEvHwA",
  "channel": "HighLoadChannel",
  "title": "Apache Ignite, взгляд изнутри / Дмитрий Павлов (SberTech)",
  "views": 6580,
  "duration": 3512,
  "published": "2021-10-04T02:45:36-07:00",
  "text": "дима привет о чем-то нам сегодня расскажешь сегодня но прежде всего всем спасибо что пришли в такой ранний час всем спасибо кто подключился к трансляции сегодня попробуем совершить невозможное пройти по сложной технической теме всего за 30-40 минут рассмотреть все основные механизмы которые используются в определенные базе данных и механизмы и структуры в идеале после доклада будет некоторое понимание как эту базу написать с нуля меня зовут дмитрий павлов я являюсь вице-президентом продукта подчеркнуто камерам естественно тоже участвую в проекте апачи тренинг и работают в сбербанк технологиях земли дом команды каста мир секс с apache игнайт достаточно давно в раза в разработке в джаве давно первая версия java на n14 на которой работал стандартный дисклеймер что я выступают своего имени не от имени фонда apache и не от имени фазбер тех а любой компании то есть доклад это мой опыт и мое личное мнение не используйте услышанную сегодня информацию для принятия стратегических решений о чем поговорим ну что такое игнайт конечно если не знаете как подобрать идеальную моду среди а точнее выбрать идеальную ноду для конкретной партиции посмотрим на устройство поймите на устройство 100 раджа как положить данные как считать данные выглядит ряду лог в пачек найти и зачем apache и гнать тормозит сам себя начнём с очень бегала поговорим о том что продукты себя представляет прежде всего это распределенная база данных для высокопроизводительных но вычислений исторически это in-memory datagrid то есть первая версия гна это не умели хранить данные был просто метод put дед положили данные на ноду читали данные с этой ноты и храним в памяти но я сказал распределенная база тоже верно в версии достаточно давно можем хранить данные самостоятельно диски и естественно это все сканируется если у нас добавляются ноды мы начинаем использовать новые ноты для хранения и поддерживается сиквел он конечно же есть хотя и гнать не полностью ведется как реляционная база данных например для вторичных индексов нельзя обеспечить уникальность то есть сказать в каком-то поле что она уникальна нельзя между кашами читать таблицами сделать constraint силами игнайта хотя вторичные индексы конечно же есть по нему запросы прекрасно оптимизируются и это все работает в терминах in-memory дейта гряда прежде всего мы храним данные memory нам persistent сценарии таким образом становимся дельты grid если мы поскольку мы можем отправлять код к данным и делать какие-то трансформации мы становимся компьютере дом а все вместе это in-memory datagrid с появлением persistent а достаточно давно храним на диске с версии 21 умеем это все хранить причем конечно когда у нас есть persistent каждая нота хранить свой кусочек то есть у нас нет центрального стороны на который мы должны сходить причем вот 2 таки ипостаси продукта они могут быть скомбинированы у нас часть кашей может быть в под persistent най памяти а часть in memory а есть ли у нас какой-то внешнее хранилище где лежит основной источник правда это зависит от кейса в кейсе кэширования конечно же дарует пор окутаны любая любая база данных позволять неважно а это может быть сторонний систем это может быть сторонний сервис в кейсе когда мы крым и праймеры столь же естественно источника правда нет а кстати в кейсе каша бывают инсталляции когда игнайт является ковшом но при этом пирсе стать нашим то есть мы сохранили какие-то сторонние давно и но при этом еще и в персис ты их тоже храним так да про игнайт овский кластером образуют топологию кольцово кольцо из server not серверы это те ноты которые умеют хранить данные если вот так их определить а клиенты это те ноты которые данных хранить не умеют на самом деле клиенты толстой в этом случае являются нодами есть еще тонкие клиенты под разные языки достаточно много разных платформ поддерживается толстый клиент понятно умеет больше чем тонкий но например не входит с топология распределение как раскидать данные по кластеру определяется affinity функций в случайной ты рандеву affinity функции и про нее как раз поговорим в игнайт persistent когда я сказал каждая нота хранить только свой кусок данных нет единой точки отказа нет единой точки в котором мы упремся по производительности если что вдруг и но без persist он сам естественно часть данных хранят в мире лучше если in memory будет больше чем больше памяти доступна на нотах тем в целом лучше когда продукт нужен или когда нужно скорость или когда особо скорость не нужна но сейчас но она может понадобиться в будущем то есть нужно скалер у имость тогда игнайта будет удачным решением введём термин кэше он нам понадобится простыми словами кэш это какое-то отображение ключ от значения джавис там будет понятно это что-то вроде java util map только распределенные с транзакциями и со всеми этими плюшками на конечно также можно смотреть примерно как на таблицу и складывать туда обычно туда складывается одна и та же бизнес сущность одинаковая технически можно положить в кэше разные сущности но на самом деле так почти никто не делает так у нас с презентацией какая-то заминка сейчас все вернем дальше сейчас технические специалисты на восстановят пока более-менее понятно пока ждем восстановления спасибо это здорово потому что дальше будет сложнее нам придется пережить многое и я буду очень рад если в конце я спрошу вы поняли и кто то хотя бы там пара человек поднимет руки это будет просто супер на самом деле готовьте вопросы самый лучший вопрос будет подарок книга от man иванов и фербер так что да ладно на самом деле про partition но это все таки хайло тут все все знаете про партиции можно и без слайдов рассказать как делятся на партиции такие независимые кусочки данных которые не пересекаются в партиции лежат n 3 января это пара ключ-значение если я говорю entry это key + валью ну что-то типа рекордов таблицы кэша обычно разделяется на and партиции n число постоянно его время жизни кэша mapping как мы собственно партицию на узел отправим мы выбираем на какой узел положить эту партию не напрямую из ключа на даже не так здесь двухуровневые affinity функциям и из ключах определяем его хэш из сша определяем партицию в которой будет принадлежать этот ключ во время жизни этого ключа всегда когда он живет в этом кэш и он всегда будет принадлежать этой самой партиции достаточно частый вопрос пока у нас восстанавливается слайды немножко отвлекусь достаточно частый вопрос а можно ли портится распухла можно ли руками куда то перенести вы знаете нет выгнать этого сделать нельзя потому что ну во первых эта ситуация не очень часто и в случае если у нас достаточно хорошо написано finicium функция то есть у нас нет такого что у нас хэш-код какой-то убогий он постоянно бьется в воду в одну и ту же партию все партиции будут примерно равны по объему данных и такой задачи переносить вручную партийцы вручную этим управлять не так знаете этим занимается самое неплохо в этом преуспевай как у нас дела кстати с презентацией наснимали специалистов кто нам сможет перезапустить экран но онлайн презентации видят поэтому прошел идет о надо знать кто смотрит нас здесь оффлайн придется представлять что нам рассказываешь раз ты продолжай до на самом деле у нас много много народов мы мой сеньор специалиста позвали или там лиц специалиста возможно нам нужен chef специалист я думаю что очень много очень хороших специалистов как минимум поэтому придется придется представлять голове ну все нормально да на самом деле давайте пойдем дальше партиции представим два типа каша портится не рованный и реплицировали реплицировали кэш он будет хранить все свои данные на всех своих новых то есть ну под капотом он там все равно портится нирваны но не запоминайте он хранит полную реплику на всех нотах достаточно редко используется в основном для каких-то словарей где у нас очень мало данных который нам легко записать на все ноды запись будет в этом случае очень дорогая потому что надо раскидать на весь кластер это естественность частая чтение но редкая запись это хороший кейс например если нам нужно за joy нить в распределенной формате с какими-то данными то есть у нас есть таблица на на н-надо парте цианирование на разных родах и мы с джо ним с какой-то таблицы возможно эту таблицу стоит сделать репрессирован и хотя конечно более популярный кейс это позиционирован эй кей кэш когда мы храним независимой пачки данных на нотах в играете дефолтное количество партийцы 1024 можно строить до 60-ти тысяч по моим внешне если не ошибаюсь если у нас хочется обеспечить надежность мы не готовы терять данные если нашу выходят какие-то ноды мы можем использовать back of backup фактор а он определяет сколько раз еще хранить эти штаны так здесь все сказал и так вот в общем про продукт наверное все игнайт распределенные базы данных предназначенной для скорости скалер у и масти кэш это в каком смысле распределенной map данные распределяются по узлам через affinity функцию она определяет куда-куда какая к партийцами отправиться сейчас поговорим о том что нужно сделать для того чтобы подобрать нашел идеальную ноду так на самом деле да здесь чтобы объяснить нужно нужный слайды онлайн видят презентацию и записи потом если придется пересматривать запись запись будет конец так сладко ладно окей показываем на руках там там просто так если что экрана уже занимаются поэтому если здесь полегче слайд можешь прийти туда одно вернуться вдруг так можно так щас секунду ладно давайте попробуем у нас есть ключ если ключ является примитивом int бланк дабл перевести его в бинарный формат несложно в но это тривиальная задача если у нас ключ сложный он состоит из нескольких полей у нас есть наш бизнес объекта в нем есть филби то чтобы преобразовать его использовать базе данных нам нужно как-то к на вернуть его в баню на баннере представление и в и гноить и обычно это делает встроенный с реализатор так называемый бояре маршаль в ключе можно выделить sap сет полей который будет отвечать за то чтобы распределять данные по нодам а кстати вы на самом деле почти все видите там внизу ничего нету так что вообще шикарно будем так в ключе выделяем сообщать данных это affinity ключ та часть ключа которая определяет куда едут данные по дефолту естественно неравный ключи определяет получили бинарное представление и от него можем посчитать некоторую функцию профи широт и в принципе достаточно наивно поделить на количество партиций получим партицию куда этот ключ надо положить вот до сих пор вот это часть affinity функции она прекрасно работает потому что количество партиций его время жизни крыша as постоянно вот первая часть чуть более простой вторая часть первая часть акиту портишь им можно назвать статической вторую часть можно назвать динамической партий shen tu not партий шелтунов рассмотрим подробнее кроме ключа вот я не знаю видно ли в кроме affinity ключа такие же бинарные преобразования делаются из ключом а вот отлично спасибо огромное видно сейчас сейчас видно в целью если у нас есть то речные индексы мы тоже сиро рисуем каким-то образом поля оттуда что делать с динамической частью можно взять наивную но вообще сразу отказать ей объясню почему можно взять consist in fishing и он когда-то даже в продукте был если интересным там про него почитать ссылки оставлю выгнать используется рандеву рандеву affinity функции или х из трендом weight хай стран выйти мне лично проще запомнить потому что он нас но он основывается на весах сейчас поговорим про него пока про наивную что если мы возьмем и поделим колись хэш-код партиций на количество нот пусть у нас там один cache partition и запишем номера партиций просто от 0 до и так далее и посчитаем остаток от деления на 3 на 4 и получим вот что синяя часть она полностью поменялось у нас все почти партиции поменяли свои ноты на которых они должны лежать это значит они все должны переехать между 7 и поэтому наивный подход сразу отказать эту проблему минимизации ребаланса решает михай страндом weight и посмотрим на примере одного каша и 1 партиции для некоторого каша возьмем его идиш ник возьмем портишь и найдеш ник и из конфет конкатенировать not айди для первой ноты для второй и так далее ну что это за едешь не кину в принципе in the key to not айди но не неважно в принципе любые любые данные можно использовать потому что потом мы посчитаем от этого хэш то есть мы возьмем комбинаций украшает из одной нотой с другой но да и так далее посчитаем ряд лесов вот этот ряд весов он нам будет говорить о том насколько для нас для этой партийцы 0 но до привлекательно насколько она нам идеальная пара одышка ноды может быть например тот же самый айпишник вот получили псевдослучайный вес дальше дальше можем отсортировать все полученные веса и вот в нашем случае для но дойди вес на то есть вес оказался мы с максимальным то есть наша partition partition 0 поедет на первую ноту это наша идеальная пара максимально привлекательно и если нам вдруг нужны бэкапы то есть нам нужно хранить праймари данной и какие-то backup а еще то можем взять серебряного и бронзового призера вот этого соревнования и сказать ну как бы ты нам не идеальная но да но на случай может пригодиться хранить бэкап и вот она не приключилось сразу еще один слайд и как же минимизируется ребаланс если входит еще одна четвёртая нота в нашем случае но 3 что будет на самом деле ответ зависит от того насколько она вдруг окажется по весам привлекательная для нас и это естественно не рандом его и ты так это псевдослучайный вес но его сложно предсказать это действительно как будто рандом поэтому победа вот этой новой ноды в соревновании за за нашу идеальную ноду она вероятность победы будет где-то 1 4 то есть для каждой отдельной партиций для каждого куска данных только 1 4 вероятности что новые надо будет ее новым мэром про affinity функция тоже немножко неточно но я немножко вру потому что affinity функции она определяет туда куда в идеале мы должны поехать это процесс нему ментальный в то есть мы может идеальную выбрали но еще в вещи не перине перевезли поэтому на самом деле по факту мы смотрим по таблице какие какие партийцы где сейчас лежат процесс переезда тоже вы гноить и естественно предусмотрен автоматический называется ребаланса это когда мы выбрали какую-то новую ноту для партийцы три и семь нашем случае победила но до 2 мы на нее начинаем переезжать и в но до 2 начинает затягивать данные со остальных нот при том что важно еще понимать этот процесс может быть еще не быстром потому что у нас индексы по вторичным полям они жарятся на всю партицию то есть partition строится по пара и море ключу а что там если у нас праймари ключ допустим синтетический клайн пойди а вторичный ключ в номер паспорта какие там будут номера паспортов вообще сложно понять и поэтому индексы строится по всем локальным партийцы когда у нас уезжает partition с одной ноты и приезжает на другую в старой ноги мы должны почистить в энтри в этих индексов новый добавить на таблицу партийцы где реально лежат короткие партийцы в каких сайтах можно смотреть просто как нам эту то есть что-то типа ноту map и все надо об этом знать так на самом деле все наверное про ой ой секунду это у меня как эта проблема не как будто запала кнопка перемотки сейчас восстановим так переклюк видно уже отлично пасибо про глобальный кластер на этом все двухуровневая finiti вы знаете используется статическая и динамическая часть статической остаток отделения второй уровень хай сторон давай посмотрим более прицельно на конкретную ноду на устройство памяти в ней на устройство персистенция как найти значение как его обновить сначала как найти значение так мне почему-то по-прежнему западает кнопку на коллекторе ok давайте попробуем мышка переключать в что такое посмотрим на одну ноту на одну партицию и нам нужно найти какой-то key value прежде всего ключи вылью также си реализуются баннере марша lerom в бинарный вид но зарезервировать в файлах мы говорим здесь про persistent определенный офсет про под них наверное сложно целью может худеть увеличиваться и так далее поэтому изначально можно поделить поделить на в основу у нас да да рассказывай дальше но отлично сейчас прям починит на сам деле сейчас можно даже почти без лайков рассказать давайте поделим блоки в смысле поделим данные на чанки пищеблоке одинаковой длины прежде всего это делается потому что все жесткие диски так или иначе блочное устройство мы пишем 1 байт на самом деле запишем в худшем случае один блок пишем два байта хочем случае два блока и так мы приходим концепция организации памяти на ноги который пользуется игнайт в терминах на это герой был моим а ринусь ноунейм ps memory там надежно или страничной памяти блог или страница обычно 4 килобайта для файловых систем и для хдд я на практике другого не встречал может вам встречались но если вдруг встретиться на практике блок побольше то возможно вы найти той тоже сделать страниц по-больше чтобы оно кратно было нам надо каким-то образом связать построить структуру нам прежде всего надо научиться связывать странице здесь вы знаете все максимально просто в устраниться есть номер от нуля до бесконечности не пронумеровано 1 2 а если к этому номер добавить айди партиции которые относится эта страница то мы уже получаем некоторые подойди который идентифицирует страницу рамках кэша а если еще и к шаги добавить то вообще в этом full поезжайте которая в рамках моды уникальной идентифицирует страницу если вот такой пи джей ди вписать в определенное поле страницы то можно сделать ссылку между двумя страницами причем это что-то типа по интера но этот pointer будет переживать сброс на диск и в установку с диска потому что это просто номер страницы это никакой там адрес ла-манш памяти или в случае java it once эванс или это просто достаточно постоянный адрес как только мы научились сделать указатель и мы можем построить в принципе любую структуру и игнайт использовать старые проверенные b плюс дерево которая горит optima есть если сравнивать с сэмом которая в которой ну может быть чуть сложнее писать моменте потому что мы как-то очень случайно будем писать в но зато читать из него здорово потому что на него можно смотреть как на линк от лист и из упорядоченных not упорядоченное значений по которым может бежать мы можем бежать в случае fusca на по этому листу или если мы говорим про индексы при при силу в случае рейнджа франческо на нам не надо там ходить по нескольким деревьям если говорить про первичный индекс то он строится наши шахты тот ключа вторичные индексы по полям у там на самом деле ничего интересного нет по полям ключа мы и строим по вылью или по старту или поначалу в лесу на все были в яндекс не влезает про дерево это in our на и дерево в котором перемежаются вершины и линки ну здесь почти все видно там посередине там тоже блоки в каждом блоке целью между вылью нас алинке и линк нам указывает на странице направо и налево относительно каждой вылью мы поднимаем страницу смотрим на вэлью интересуемся по ней если искомое велю меньше идем налево больше идем направо то есть на самом деле у нас процесс похож на обычные бинарное дерево в только у нас несколько вершин в конечном счете мы добежим до какой-то конечного листа почти всю вину вот здорово да бежим до листа в котором будет вылью то есть наше значение которое мы искали мы можем почитать если говорить в конкретных примерах с конкретными значениями то вот статическая статическая демонстрация такая давайте я попробую сделать динамическую сейчас переключусь на на браузер если можно увидеть пожалуйста браузер вот отлично это сталь сайт сан-францисского университета там много на самом деле разных алгоритмов но давайте начнем ставим допустим какое-то значение 6 а у меня уже чет что ты есть дерево ну ладно все равно вставим вставили значение 6 у меня здесь максимум кардинале тему дерево стоит 2 то есть в нем может быть два в илью и 33 линки если вставим ещё там значению 5 допустим то мы пойдем в страницу расщепил их каким-то образом давайте еще построен ставим сразу 1 и 3 у нас будет вот такое красивое красивое дерево нет не очень красиво но в но все равно таким образом в природу то есть на нижнем уровне есть все валью так сейчас я попробую еще увеличить немножко масштаб чтобы это было чуть более видно чуть чуть меньше даже меньше вот так вот наверное так можно еще 0 вставить он он явно уйдет у нас в первую страницу что еще можно вставить ну наверно так оставим то есть в нижнем уровне у нас все вылью которые есть таблицы а на верхних уровнях они еще повторяются то есть такой link at лист с шорткат амину почти искать лист map но в целом естественно отличается от него можно еще что-нибудь поудалять чтобы посмотреть что произойдет вот пятерку удалим с удалением когда происходит удаление дерево схлопывается когда происходит добавление там операции сплита происходит так что мы ещё можем добавить давайте семерку добавим и и прям восьмерку добавим чтобы у нас еще еще уровень был она еще уровне не получилось потому что нас кортни налить и хватает но более менее понятно как она строится но и таких операций вы знаете происходит огромное количество так сейчас вернёмся к презентации да все b плюс деревья используется для поиска разобрали как дойти до странице найти нам нужный ключ на теперь посмотрим на запись на диск обещания надо выполнять доклад называется до записи на диск надежная ли страничную память состоит из регионов как сконфигурируем а каждый регион он содержит ряд страниц они имеют разный тип какие-то дата странице какие-то страницы бы плюс деревьев какой тип где лежит мы заранее предсказывать не можем они все выделяются в перемешку и и более тем они могут более того они могут перерождаться в новый тип то есть раньше это была дата страницами она переквалифицировалась у страницы хедиры понятно у определенного типа странице есть тоже свои гидры и если посмотреть на примере дата страниц это в природе у нас будут уже лежать наши наши entry наши ключи и значения причем значение заполняются с конца в начало а в начале есть внутренний указатели так называемые в терминах игнайта айтемы которые это 2 байта вы указатель который говорит странице вылью лежит там и это нужно для того чтобы как раз в или могло худеть там а набирать и мы постоянно ссылались на один и тот же на 1 этаже ой там страницы ой там лежит всегда в одном и том же месте дома снова выключилась презентации смысле выключился экран зале как определить как определить куда дописывать как определить где есть нужный нужный объем свободного места для этого есть та же структура free листы которая является отображением списком страниц в которых есть определенное количество свободных памяти свободной памяти с точностью до восьми байт то есть когда нам надо дописать в отлично теперь видно когда нам надо дописать в двадцать три байта мы сразу понимаем что нам вот во второй пакет этого free листа берём от туда страницу что-то дописываем куда-то переставляем вов released эту страницу таким образом нам не надо не надо перед перебирать постоянно страниц куда дописать с короткими объектами надеюсь понятно с длинными история похоже только мы из длинных собираем уже некоторую 1 односвязный список когда конец одной странице нам указывает на продолжение объекта причем неформатный вот этот кусочек мы тоже берем is free листа чтобы максимально утилизировать память если смотреть на регионы более верхнего уровня если разложить вот у нас наша перед перемешку страницы в какую-то структуру то мы увидим примерно и b плюс деревья у нас образуются и free листы но здесь упрощение естественно не 25 процентов а более гранулярными гранулярный делению в апреле стах ну понятно что в как это все хранится в памяти вот еще что ну что нужно обязательно сказать в памяти в памяти то поднимается в достаточно рандомизированном порядке вот сегменты сегмент это набор страниц памяти у которых есть определенные хэш-код у их айтишников хэш-код условно дает 7 и они пойдут там 7 сегмент количество сегментов в раме равно по дефолту можно настроить равно количеству цпу то есть чтобы у нас разные коры не мы максимально распределились такой строй pink происходит между страницами в памяти чтобы мы максимально эффективно использовали меньше били за один сегмент в естественно с не линки которые мы обсуждали они кровь сегментные то есть они никак не зависит от сегмента и могут ссылаться 11 на другой до сегмент таким образом это то к чему где именно у нас стране страница доступна в памяти так на сегмент это на самом деле не только хэш-таблицы которая по старой плена по одному плохо skoda иди странице это еще способ но без картинка на сложно будет понять но это еще внутри каждого пакета сегмента лежит хэш мапо с открытой адресации по которой мы пойди странице понимаем адрес lancer то есть мы берем пдд считаем 1 хэш-код выбираем багет в боккетти выбираем там хэш maple это же за константное время на находим адресу уже конкретные wanze или куда сейчас это странице пони поднята причем эта штука не только разыменовывает нам опять зайди в адрес one seven она еще позволяет быстро понять какие страницы у нас на руках то есть она же может быть persistent мод и в этой таблице мы можем быстро проверить а у нас есть вообще такое иди или нет посмотрим еще на изменение то есть как как изменяется страница тут с нам слайды на самом деле не супер нужны как изменяется страница и записывается на диск конечном счете в играйте mapping айди жки страницы в адрес солнце и вам происходит а там arm на с захватом локоны эту страницу пока мы держим этот лог мы не скинем эту страницу мои не не запишем на диск не выкинем из памяти то есть пока она живет лодку нас живет-адрес это все синхронизировано когда мы перестанем со страницей работать мы локоть должны опустить в саму страницу мы идем через набор утилит ных методов которые реализованы вы знаете но в конечном счете они все попадают в сан мескан сейф для для кучи примитивов такие методы есть но еще можно обернуть нашу страницу с direct буфер в кровавый и работать через его api как происходит в запись немножко новые темы дана без лайков может сложно понять на в общем если представить stack trace в верху стектрейсы будут наши классы которые отвечают за вот вы в этом все у все что угодно файл и а дальше мы используем файл в райт файл членов это java api для низкого уровня низкоуровневые работы с файлами в файл china white он проваливается в его util если открыть код его у тела можно обнаружить что там проверяется просто наш буфер который мы прислали instance of heat буфер уже есть хип есть на онлайн испанец сам мескан сейф и вот это все и самыми стакан сейф это дайрект буфер то есть то что у нас ван - памяти хранится и java порт проверяюсь что если у нас пришел байковый массив типа their мы можем просто взять адрес у этого буфера и отдать его операционку то есть на самом деле вот эти странички которые мы рассматривали в durable мраморе у них есть сегменте определенный адрес и и игнайт просто в операционную систему отдает фактически этот адрес и оттуда происходит запись но естественно пока держится лак никаких копирований не ничего в этом плане не производится окей рассмотрели как то более менее странично организована как страниц друг на друга ссылаются кое-что используется бы плюс дерево что структура которую мы построили она в целом переживает спрос на диск и теперь можно перейти поговорить о том как устроен сторож и в райт этот лог кто кто знает что такое в right ahead лог здорово примерную даже треть наверно даже треть наверно тут принципе пока слайде нужный но скоро скоро прямо не нужны будут там есть обсудить в рай the heat look ahead потому что мы пишем в период с записи ясном в основную сто раз на этом этапе когда мы пишем вал странице даже они не записаны никуда они есть просто в in memory в видите идете по j после того как запись в right ahead лоб прошла мы можем отпустить транзакцию сказать что он тут прошел транзакцию закомитить а уже запись в основной сторож произойдет потом как-то по расписанию либо по количеству до грязных страниц произведет произойдет процедура чекпоинта в right ahead лог дает нам из эйсида он нам дает и иди нам дает durability даже если все упало там и поэтому логу можно мне его посмотреть то и понять по операции она прошла она не прошла она там прошла частично как to eat a more ность мы можем понять вот эта транзакция на таки случилось или нет ни случилось и сделать либо все либо ничего в играйте в right ahead логе есть два типа записей физическое и логическое на логическое то про нашу бизнес сущность допустим у нас есть юзер который в какой-то момент заходил messenger то есть юзер last was to life than last visit at times стенд мы хотим его записать мы мы делаем сет и там пупка в вал попадет логической запись что у юзера поменялся time стенд сделай такую операцию а есть еще физическая запись которая говорит о том какие страницы поменяли как своем значении то есть п с таким-то айтишником по все тут а кому-то теперь имеет вот это такое новое состояние в куда попадет этот timestream зачем это все нужно рассмотрим чуть позже теперь попробуем все вместе рассмотреть в как происходит операциях я смотрю ум ведущий называется потому что у меня в зале не по-прежнему нету нету экрана а там такая схема пока без схемы ключ вы из него выделили affinity ключ из него выделили парте шин из него выделили ноду таким образом мы понимаем куда нам идти этого каста мира юзера обновлять ему таймс тем придя на конкретную ноду мы можем во-первых захватить лопну эту янтру можем записать логическую запись во вред ищет лог вот там вот внизу это вот right ahead лак и логическая записи зелененькая отлично после после этого мы идем в b плюс дерево которое мы посмотрели как работает и ищем конкретно конкретно где какие надо произвести правки потом возможно идем по даты по играм если длина объект находим нужную дтп модифицируем его и пишем в рейд и setlock что вот эта страница модифицировал с определенным образом после этого можем вызвать файл channel force или который на самом деле в пасек пасек совком api переносится в sing или of data sync а кто знает в чем отличие между ними я книга я мне кажется слышал правильный ответ метаданные данные спасибо действительно действительно так игнайт использует сколько я смотрел все таки of data sync без метаданных вот насколько часто он его использует зависит от модов все-таки после каждой транзакции вызывать sing с диском будет очень дорого почему два типа записей если мы смотрим на в right ahead лак упавши ноты которые не писала сброс на диск не писала чекпоинт она в общем то основное сторож не меняла мы можем посмотреть на это и скажи основной сторож прекрасном состоянии с ним все хорошо давайте просто не докатим операции поставим каста миру таймс темп нужный и таким образом у нас все страницы поменяются случай простой если у нас надо в момент крыша писала писал основную сторож то что она туда дописала там могут быть 0 это может быть мусор там может быть вы все все что угодно в этих страницах которые в этот момент писались вот здесь на сцену выходят физические записи по которым мы бежим по в рай ты хит логу и в те же места основного 100 роджер прописываем нормальные правильные значения но естественно самцы в right ahead лог там сердце control но в нашем случае в нашем случае у нас в right ahead логе были страница 1 из 0 партиции 13-14 и из первой партиции ему все их запишем в чем есть полностью пшат когда мы полностью страницу пишем есть дельта чтобы как экономить память то есть не все изменения не записываются полном сны что там страницы в вал что же происходит получается в случае 1 пуд of cash мы пишем одну логическую запись одну физическую запись если у нас еще поле поменяла значения нам все листы надо изменить они тоже persist и если у нас произошло если у нас длинный объект то у нас несколько обновлений несколько страниц поменяют свое значение если у нас еще индексные поле за зацепилась то нам еще надо индекс поменять и в этом яндексе тоже проезжает произведет операции расщепление слияния еще чего то там может быть там сплит мер счетом 2 3 5 страниц изменится ну чё под капотом там мы это не обсуждали там модификация трек трассирую ца и вот это все представляете сколько нужно изменить страницы сколько надо записать данных для одного простого в принципе пута хорошая новость том что последние версии более-менее то оптимизируют то есть если у нас есть физической и логической запись они а не шарят между собой повезло то есть одна на другую ссылаются так сейчас извиняюсь но тем ни менее нам надо достаточно много написать на диск написать в afraid i hit лак имеет ли смысл каждый раз говорит диску за синкай все файлы обязательно вот прямо до железа после каждого каждого put a shot at the lock можно делать вы знаете это мод пирсинг который самый хардкорный он переживает вообще все падение ноды падения с у после падения сервака падения операционки принципе все что угодно ну естественно он синкай все каждый раз но он очень дорогой по дефолту стоит такой режим логан ли который дает управление операционки то есть он говорит операционки в райт вызывает в п в рай нет вали в райдеру в истории поверит в валя вызывает в рейд и операционка разбирайся сама в принципе разбирается если процессор на это закрасится то все прекрасно отработает если за крышки сама операционка ну тут может потеряем какие-то последние записи самый расслабленный режим background мы просто по таймеру сбрасываем там раз в 3 секунды что что происходит что происходило последние три секунды в худшем случае мы эти три секунды можем не не потерять если у нас был краж по url о смотри на серваке естественно я говорю в голову вал вал это не один файл это набор файлов или сегментов и причем сегменты делятся на те в которых с которыми мы сейчас работаем и в них опишем записи и те сегменты которые нам в принципе уже не нужны мы их за финализирован и очень здорово что сейчас работает экран потому что без него сложно понять верхняя work директория в которую нас сегменты пишутся в нашем случае пишутся третий сегмент и worker и добавляю добавляют туда рекордов из периодической у нас спрашивают сегменты по дефолту 10 штук в word директории 64 мегабайта размером но это все естественно настраивается и мэй цикличный бежим по этой word директории записываем в последней когда мы записали мы отпускаем сегмент и он доступен фоновому процессу архиве ru archer и забирает сегменты и перекладывает там откладывает в папочку архив но папочка архив может не очень удачно названа потому что ее периодически удаляют считаю ее не нужен и хотя на самом деле естественно она может пригодиться когда чистить архив есть старая настройка по числу чек-поинтов есть более новая настройка по размеру волок то есть мы можем настроить коко мы готовы под bright i hit лог выделить просто просто в мегабайтах гигабайт провал поговорили некоторые весь такой оперативное некоторые скользящее окно над нашими последними операциями думаю уже сейчас понятно что в базу лишние выписать не стоит это касается естественно не только игнайта любой базы данных и если у нас есть pdf-файл наверное это не самая лучшая идея сразу его кидать в базу или если у нас есть какой-то string который на самом деле in the наверное лучшим том же записать но я понимаю что я глупости говорю и вы так не делаете но бывает что что возникают такие кейсом вторая идея которая уже можно в принципе из этого доклада вычленить что в right ahead лак и основной сторож их можно разделить чтобы диски тормозили независимо и про основной сторож как раз и поговорим как она устроена здесь в принципе не очень сложно вы знаете организована каждая partition to file каждый кэш это папках в right ahead лак он общий для всех кашей но это понятно потому что если бы это было не так мы бы не могли сделать кровь скажет транзакцию естественно вы знаете они поддерживаются плюс индексы это отдельные файлы и как мы уже обсуждали они жарятся между всеми локальными партийцами то есть они не принадлежат к определенной партиции если нам что-то надо поднять в оперативную память из файлам и мы сразу можем понять из какого файла из какой портите нам нужно понять данные и обратиться конкретно к этому файлу а в раме естественно все каши и партийцы они вперемежку могут существовать как они там сегментах разлом разложите непонятно читаем естественно методом basics basics методом перед мы рассматривали запись когда мы делаем по в райт здесь парит в каком месте файлы читать здесь в принципе тоже ничего сложного никакой магии берем индекс который мы ввели в самом начале умножаем на размер страницы вот нам и офсет по-сексистски метод перед будет нам читать определенное количество байт с определенного места он не не работает скульптура она в этом случае файл нарисованы вертикально то есть у нас есть страницы это мы все начинается мета поищи tracking поезда то пусть вот это ну и так далее по возрастанию индекса мы можем сразу читать нужную страницу и и с ней начать работать то есть файлах нефть не все так сложно как в этих сегментах там никаких лишь таблетки не надо мы сразу знаем куда идти за диском куда идти за страницы на диске чуть pointing процесс сброса на диск мы не говорили о том как записывать мы говорили что 100 запись происходит а как именно ну либо по таймеру либо потому что мы запачкали весь регион первый первый шаг мы знаем какие страницы грязную нас есть сет на это короткая пауза которая полностью останавливает все операции над модой на копирование этого сета в подушку то есть у нас есть от грязных страниц и мы из него копируем их сет в то что мы должны сейчас сделать это наш план на день когда сбрасываем ставим флаг дети в ноль и удаляем и скоpо скоpо записываем их страниц в принципе пока я думаю что понятно на посмотрим для понятности еще на примере запишем 2 страницы в два файла с первой страницы в принципе все понятно мы дошли дона до нашего дела списать страницу 1 пишем и все хорошо страница 13 счастлива и потому что мы ее писали в файл 1 но при этом кто-то захотел в нее еще записать то есть там уже модифицированные данные грязные который надо списать на диск естественно нам нужен срез начала чекпоинта нам не нужно то что нам еще worker мне напишет то есть за неё был получился какой-то конфликт конфликт решается копиям в райтон это страница берется откидывается в отдельный сегмент памяти check point пул который как раз таки и конфликтные страницы и хранит в этом check point пули как раз лежит то что мы должны сбросить и check point ул он по памяти ограничен то есть он не бесконечен может так случиться не анлоки что мы очень много используем пишем вот в именно именно те конфликтные страницы которые только что пошли в check point поэтому если вдруг мы начнем заполнять эту память то включится экспоненциальный букаф играет будет просто нажимать на тормоз он будет тормозить ноду это к вопросу о том как игнайт тормозит окей разобрали 100 рассчитаем парит пишем по в райт в конце of data sync v для волос для чипа и тинга естественно тоже и тут уже можно догадаться что чек pointing как так как он мы не предсказан не можем предсказать какие страницы грязные это рандом запись это рандом в рай то есть волку в момент работы кластером и пишем быстро мы делаем секвенцию когда мы делали pointing это случайная запись какие выводы но наверное если есть возможность ставить ssd достаточно очевидный вывод не использовать сразу несколько нот на одном обе найти потому что у нас одна виртуальную not to knit на не использовать несколько нот на одном серваке то есть мешает железный сервер на 8 но тогда это будет тормозить еще как потому что куча надо сбрасывать ее случайно записи и тут 2 надо будут случайную запись сделать опять же говорю простые вещи но такое случалось на и извести и еще о том как еще и гнать тормозить сам себя такой же педаль тормоза есть для всего рейнджа для всего нашего региона если у нас бежит check point мы спрашиваем где на диск страницы с определенной скоростью то мы можем предсказать когда примерно этот процесс будет закончен когда мы закончим этот чек-поинт если у нас скорость пачками страниц му татарам выше она обычно выше потому что память то изменить гораздо проще чем на диск потом скинуть игнайт опять-таки нажимаем нажимает педаль тормоза и не в зоне over спида он будет тоже тормозить worker и тормозить worker и чтобы они не работали быстрее быстрее чем мы сбрасываем на диск и теперь ты тогда когда вы увидите файлы от игнайта или другой базы данных я думаю что вам уже будет гораздо проще узнать какие-то знакомые вещи естественно там вы знаете папки настраиваются очень многие мы не рассматривали какие-то бинарные метаданные каши и чекпоинт маркеры на которые можно смотреть просто мы timestream но по-крайней мере это узнаваем как вы в этом не пишите в базу лишнего длина в байтах все еще имеет значение принято говорить пусть железо-то куплетом и программисты программировать как умеем будем но на самом деле с точки зрения база это не так лучше разделять воле повторы не использовать одну ноту но используется создает а поговорили ну и самый главный вывод который я бы хотел чтобы вы сделали не пишите свою базу данных это это сложно если вам все еще хочется в этом разбираться хочется хардкора вот-вот чтобы разбираться ещё более подробно естественно многому не рассмотрели присоединяйтесь к сообществу apache игнайт в на слайдах ссылка статья как как контрить выглядит в ну и ссылка надев лист оставлю несколько ссылок ну понятно игнайт на то что мы рассматривали сегодня чтобы спокойно посмотреть как это все устроено team там чуть больше информации и последняя ссылка на визуализацию алгоритмов очень залипательная тема там красно-черные деревьями можно построить настроить в общем весело спасибо ребятам за это вам огромное спасибо что послушали если будут любые вопросы пишите на мне на почту просто погуглите дмитрий павлов apache и больше кейсов использования игнайта более такие жизненные жизненные простые доклады отказ таймеров которые его используют можно послушать на игнайт саммите совсем скоро бесплатно но требует естественно регистрации можно потренировать он английский добро пожаловать на юзер лись с вопросами если какие-то проблемы возникают или надевались если хотите что-то внести и спасибо огромное тогда к вопросам дим спасибо тебе большое"
}