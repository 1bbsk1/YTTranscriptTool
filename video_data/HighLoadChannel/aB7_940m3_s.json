{
  "video_id": "aB7_940m3_s",
  "channel": "HighLoadChannel",
  "title": "Визуальное проектирование масштабируемых приложений / Максим Цепков (CUSTIS)",
  "views": 2278,
  "duration": 2210,
  "published": "2023-01-19T07:03:34-08:00",
  "text": "я буду рассказывать вот про визуальное проектирование масштабируемых приложений это будет нет про модель вчера было несколько докладов я слушал которые посвящены вопросам устойчивости когда мы приложение но поднимаем много инстансов одного сервиса сервисы взаимодействуют с друг другом активно и чтобы это вот все устойчиво работала были доклады с рассказами о паттернах но мало разработчику знать паттерны вообще говоря надо чтобы это умели сначала проектировать в том числе не только сами разработчики но и аналитики это надо чтобы умели тестировать тестировщики понимая вот проблема устойчивости писать тест кейсы и вообще говоря ситуация усложнилась когда это все пришло в enterprise вот эти веб решения современные потому что в энтерпрайзе и и аналитики и тестировщики и сами разработчики имеют нет при груз прошлого прошлой традиции как моделировать создавать приложения писать постановки и в том числе руководитель и войти которые сформированы давно и заказчики которые особенно в случае с боев хотят понимать во первых что произошло а во вторых когда им айтишники говорят ну мы это проанализировали и устранили часто спрашивают а вот объясните как вы устранили что она не повторится собственно вот поэтому новые модели нужны но еще надо понимать а какие модели были чтобы ну вот взаимодействовать с теми кто работал и причины по которым они возникли чем новые отличается от старого на самом деле в классических приложениях важно что конкурентная работает инфекционности консистентной она была возложена на субд и и поэтому не было заботой не проектировщика не вообще говоря разработчика а зубы инфраструктурный уровень свободы все это обеспечивало излечим мы ставили мощную железку мощные серые такие вот получали масштабирование было два подхода к проектированию процедурный объектный подход и хорошее средство чтобы на этом деле проектировать там какой-нибудь типичная постановка включала описание бизнес-процессов схему база данных схему состоянии документов которые гонят по этим бизнес-процессам презентация уже выложено на моем сайте так что можно и и там найти вот ссылка в конце будет значит разница процедурного и объектного подхода но вот на примере задачи интернет-магазина в том что в процедурном мы делали таблицы алгоритмы потом интерфейсы и вообще говоря вот всё куда интерфейсов это wierd алгоритма плюс структуры данных равно программы 1976 год а дальше и это многочисленна переписывали в новых учебниках вот в объектном подходе который позднее все объекты товар заказ платеж и алгоритмы в методах объектов инкапсуляция сложности разница возникает как раз перри развитие например если у нас есть доставка самовывозом и курьером то в первом случае мы размазываем iv и по алгоритмам а в другом случае мы пробуем делать по типу разделяя общие час и таким образом делаем этого проектирование вот в процедурном подходе это таблицы и алгоритмы в объектном типы и статусы и там была концепция интерфейсов на и к тому же очень эффективная когда мы на интерфейс вытаскиваем методу упрощенная чуть разные api в одном случае ремонт холл произвольной в другом случае rest api и вот разница в положении бизнес-логики объектный подход дальше развивался с вот сложными фреймворка me to mp3 звонки могло получаться не обязательно речь обжиг в реализации анимешная модель транспортных объектов и соответствующей контроллер на разных уровнях а domain гривен дизайн просто заслонила объектный подход на модель предметной области антология понятие связи bounded контекст и так далее фишка в том что в современных эктор ных моделях все и в современных микро сервисных структурах все это плохо работает как только мы берем объекты внутри одного микро сервиса я такая маленький кусочек который не интересен интересно взаимодействие все взаимодействие многих сервисов в объектной модели плохо описывается вот и собственно то что я буду рассказывать она позволяет раз позвонить подход д д д н а вот современные виды приложений просто способ моделирования меняется но описание в этой модели получает с одной странной понятно бизнесу заказчиком аналитиком а с другой страны отражает структуру приложения в этом махнул фишка начата собственно вот ddd он как раз от фактически водопадный структуры с многими моделями сделал переход к единому описанию на едином языке которые основа коммуникации я сейчас предлагаю в некотором смысле единый язык но вот для новых условий единый язык нужен в enterprise он нужен потому что у нас система вписана в 100 техническую систему вот предприятия людей и там для нее место которое в общем случае не соответствует этап внедрения это как раз утапливания системы в то место которое предусмотрено со сглаживанием острых углов вот чуть-чуть в сторону вот про историю это сложная история она интересная она есть в моих статьях ссылке внизу приведены я тут хочу сказать что вот это вот развитие которое я рассказала но вот шло появлялись многие парадигмы в 2000 bach развивающиеся независимо в 2008 году произошёл подрыв появился мульти парадигма иная версия сишарп 30 который включил как объектный парадигме при мешал функциональную реляционную и вот хороших принципов объектного программирования они были и для функционального тоже а вот хорошие принципы разработки на смесь их не было векторная модель а она та же старая small talk сервис 4 года впервые появилось это еще одна парадигма она сейчас за счет синтаксического сахара примешана к языкам и мы пишем как бы классические процедурные вызовы а внутри там это разворачивается в и синхронную работу и разработчики обученные старыми учебниками тоже не понимает что там творится внутри в общем но произошло все это закономерно они из того что мы хотим сложнее сложнее потому что public веб потребовал уйти от реляционных баз данных они просто не выдерживали нагрузки и по-прежнему не выдерживают а как только это получилось у нас транзакционный стигом системность стало поводом заботы тех кто проектировали приложение я вообще говоря войти начинал давно в 90-х и тогда еще реляционные базы данных тоже были слабы были база данных там гибель эти самые не помню как называется вот debris foxpro который без плантаций тогда и ты это писал об api предложений я это помню и там все это не просто восстановление узлах кластера данные получаются не консистентной потому что одни узлы ушли вперед и вот тоже интересно соответственно бизнес запрос обрабатывает много сервисов много экземпляров экземпляры падают по ошибке причем если соответственно цепочка запроса она прошла 1 2 ну и там рассыпалась на обращение брюс ди асинхронный оно легло в очереди ожидается ответ после этого экземпляра основной упал а там то все осталось и обрабатывается и с этим надо разбираться тестировать устойчивость и так далее вот очереди они же тоже не в пространстве висят они при падения если в месяц сын солнца могут теряться ну вот и так далее и собственно вот нам нужна модель которая показывает способы масштабирования сервисов способов взаимодействия и по которой можно моделировать поведение при падении экземпляров проектировать устойчивой системы проигрывать кейс и потому что вы приходите к заказчикам например кверху айтишником водород прозит при носите свой проект ну дизайна они хотят знать вот что происходит инженеры заказчика они погуглили кейсы падения аналогичных систем и они начинают спрашивать а почему в вашем решении вот это падение не приведет плохим последствиям ну им надо понятно объяснять вот взаимодействовать у меня есть такой опыт вот собственно это вот одна из источников почему родилась такая модель и собственно в чем состоит модель она дает новую метафору представим себе что в компьютерах живут такие гномики которые как раз и действует как микро сервисы и всю эту работу делают а это метафора очень наглядная ее можно объяснить и еще понятно что гномики они активны они все время что-то делают даже если просто ждут очередного сообщения вот это можно обсуждать и проигрывать и собственно вот в этом фишка что ее а можно на этом языке можно говорить не только с разработчиками вот сейчас дальше это будет развернуто на модельном примере интернет-магазина он модельный в том смысле что ну как реальные примеры все требуют большого бизнес-контекста про интернет магазин вы все примерно знаете что это такое можно не рассказывать и так покупатель приходит делает заказ понятно что это один сервис второй сервис это оплаты он наверное отдельный потому что вот дальше есть кладовщик ему нужны заказы на завтра собирать нужно как-то приходовать товар и являть остатки на складе и тут получается что значит там отдельный сервис по поводу остатков они внутри заказов это явно другая активность вот вопрос кому сообщать про грушку потому что она ее остатки меняет и заказ меняет и это надо это может быть решаться по разному и в зависимости от этого при падениях при нагрузке будет разные вещи дальше есть курьеры ему нужен и маршруты и заказа чтобы вести соответственно возникает планирование доставки и опять же вопрос кому отвезли такая вот схема и на первый взгляд она не очень отличается от классической схемы где мы вот нарисуем компоненты ведение заказов оплат доставки и так далее вот в чем фишка и отличие отличия появляется в том случае когда мы начинаем думать про масштабирования вот значит возникает ситуация что не справляется один instance мы естественно их поднимаем много и естественно тут же получается вопрос что нужен диспетчер который входные в запросы переадресует нужным выходным и он вот на той функциональной схеме где одна компонент он скрыт вот такие рисовки они заставляют все эти места проявлять а появляется очевидно очередь потому что невзирая на то что их много их может быть недостаточно для покупателей и эта очередь может лежать либо у каждого ведущего заказы то есть диспетчер быстро-быстро балансируя пишет куда ну нужному ну по циклу либо наоборот она может быть централизовано диспетчер быстро-быстро в нее записывает а эти как освобождаются выбирает и это разные решения и разные вопросы устойчивости потому что если у вас например 2 дата-центрах распределенные географически и в каждый свой диспетчер ну и свои обработчики то дальше вопрос падения дата-центра еще чего-то вот какая очередь пропадает потому что любой en sus в любой момент пропадает вместе с очередью которые в нем лежит вот и в случае тестирования устойчивости это вот надо прорабатывать вот это скрытие дальше ищу вопрос тут же понятно возникает вот при такой рисовке что с клиента цессии идут много сообщений последователь но вопрос что происходит если они попадают на разные инстанции потому что балансировщик ну тупо пишут подряд информация это должна сохраниться и тут есть разные решения и и тестировщиком и аналитикам надо понимать какие решения сделанные самим разработчикам можно например вспомнить что клиент не напрямую делает запросы а работает в браузере который вполне себе отдельная программка и который может например хранить заказ покупателя и каждый раз отправляйте его целиком со всем контекстам те которые ведут на стороне базы данных ну вот тогда не все равно какому агенту очередной запрос придет вот и там еще можно отдельно выделить ведущего каталога товаров с большими базами данных и так далее а можно наоборот пришить что у нас на стороне сервера быстрая база данных в которую мы пишем вот а агентов которые вот обрабатывают заказы много заметим про базу данных что вот она тут не нарисовано как гномик потому что ну если мы берем java стать джитибиси обращение базе данных синхронная это только к sobre mi книг при современном новую сколь базам данных есть асинхронные драйверы и это с одной стороны упрощает но с другой стороны получается если у вас это поднята на разных инстанциях то там всякие штучки сетью и прочим и прочим задержки начинают играть вот и это тоже ну имеет свои проблемы понятно что в этом случае тут же нужно идентификация через авторизацию через токены вопрос как она передается и вот дальше возникает опять же интересные вопросы у покупателя завис его компьютер или не завеса он просто побежал и решил продолжить на телефоне или наоборот он начал на телефоне в какой-то момент ну что-то выбрала тут увидел бо надо посмотреть фотографии крупнее и перешел на большой экран хочет перейти вот эти вот все сценарии довольство но он просто закрыл браузер отключился брошенная корзина остались с ними будет вот эти сценарии надо прорабатывать дальше межсервисные взаимодействию уже там вот с осадками на складе с заказами все хорошо там работала калина остаток на складе он разделяем и если на складе 2 единицы товара и пришло на них три или пять заказов то мы не должны их зарезервировать не должны продать больше чем есть поэтому получается узкое горло но вообще говоря устроенное по-другому и это тоже надо проектировать есть там три варианта можно решить что вот остаток это очень простая задача мы бы там оставим мощную железку с мощной базой данных и один в домик справиться со всей нагрузкой может быть шарди рование мы весь каталог как-то поделили и каждый гномик ведет остатки своих товаров чё при этом происходит это происходит что когда мы резервируем товары по заказу крутимся по спецификации то мы должны обращаться в разные инстанции гномиков резервируют их товары в зависимости от вот этого шарден к либо может быть еще ситуация что много гномиков остатков и одна база данных если кредитные ресурсы процессора они базы данных и тут одну с остатками казалось бы чё там добавил число вышел число но на самом деле надо же например от парсить входящий джейсон или ли xml а во вторых на этом уровне часто и при работе с ресурсами включают всякие проверки авторизации полномочий имеет ли право этот агент использовать вот этот этот остаток в случае вот сложные системы ну уже за рамками простого интернет-магазина но аналог примерно понятен и она может оказаться действительно вычислительно нагруженное вот во всяком случае в любом случае понятно что тут будут встроены в очереди вот для балансировки нагрузки потому что их разное количество идут варианты соответственно measure дневного взаимодействия синхронные известные из процедурного программирования очень простой инкапсулированные и фишка в том что асинхронное синхронная плохой чем понятно кто вызвал он ждет ресурсы заблокирована и так далее хотелось бы чтобы он чем-то другим позанимался вот соответственно переходим на асинхронные при этом современный синтаксический сахар их маскирует под синхронные и разработчики уже не понимают что там творится на прошлом хайло дерена позапрошлом в общем я слышал доклады как раз вот на эту тему что синтаксический сахар вот ну позволяет писать асинхронные вызовы через всякие осинка weight и как бы в старом стиле а дальше получается что вот ну проблемы вот соответственно синхронные тоже бывают в двух видах во-первых с опросом результата такой классический асинхронной стороны клиента когда связь односторонняя либо вот реактивная на call back ах когда ты передаешь обработчики она более эффективна и внутри оно устроено по разному том числе с чувствительностью к падениям и когда мы начинаем смотреть максимальную нагрузку отказы и так далее в этом надо разбираться причем вот опять же там же проблема надо часто донести до пользователей или до заказчика чё тут произошло на понятном языке иначе он говорит думает что произошла хрень которые от глупых криворуких разработчиков которые ну даже не понимаю что у них как работает раз не могут объяснить вот соответственно получается например что если мы ведем остаток на складе через шарди рование по товарам то вот какая то такая схема еще отдельно у нас запросы состояний общая база данных и вот на этой схеме можно трассировать рисовать диаграммы timeline и важно что на ней можно проигрывать много разных ситуаций дальше у нас подключаются оплаты с внешним сервисом оплаты и особенностью этих самых ну особенностью работы этих сервисов потому что там же тоже падение связи и другие сложные протоколы и собственно задачу службы поддержки вот на этой картинке это быстро разобраться где гномики накосячили она тоже получается такая олицетворяя мая и эти кейсы тоже можно проектировать писать сценарии инструкции раза службе поддержки чтобы они понимали что творится внутри системы они отвечали что черт его знает что там получилось вот ну и дальше соответственно можно прорабатывать сложные кейса для проектирования их придумывают покупатель быстро добавил позиции так что они попали разным разработчикам ну это не знает что он быстро-быстро молотят по клавиатуре это знаете что он набирал в браузере заказ а связь была неустойчиво поэтому они там где-то зависали на реках и потом наконец свалились одновременно сми когда связь восстановилась или нажала платит резервирования пошло резервирования она идет долго страница оплата не появляется и и покупатели уходит в другой магазин заказчик прибегает говоришь или пишут жалобы сайт не работает я жму приходит заказчик высокого уровня начинает спрашивать что это у вас тут происходит и говорит например а пусть резервирование если у вас так сложно может быть решение что может и не надо резервировать опустить на оплату ну какой то процент заказов потом мы ему позволят извиняться скажут сам нож на складе могут реально товар не найти этот процент есть вопрос насколько он вырастет от такого решения вот когда оплаты нет вы обратились к серверу оттуда не нет ответа не факт что можно ли трой и так далее в общем и вот проектирование устойчивости потому что в но миков отстреливают как ну вот во многих докладах это распространенная штука на сервере со здоровьем следят эти watcher и которые если ресурсов становится мало для операционной системы начинают отстреливать король коньяк конкретные сервисы чтобы не упал весь сервер это разумная стратегия при этом отстрел может быть не потому что очень много памяти съели а просто ну в смысле вот отстрелили самого жирного по памяти но не потому что в нем ошибка а потому что его garbage collector сейчас не успел вызваться еще бы там и отменный секунду он бы вызвался память бы сдулась ну вот так вот в моменте в этом смысле там внутри никаких ошибок нет но гномик сервис который вел резервирование от стелился при этом две позиции зарезервировано 1 нет этот заказ подхватывают ну надо подхватит продолжить покупатель как-то в браузере проявляет активность и собственно вот чтобы не было зависших было понятно состоянии это все надо прорабатывать и соответственно служба поддержки могут быть какие-то штуки на ручной разбор они что интересно могут быть всегда мы тут как то вот для высокого при ну для требования надежности выяснили значит masters in buy oracle кластера и оказывается есть неудачные ситуации когда при падении мастера переключения на стендбай не может быть выполнено автоматически а требует ручного разрешения инженером нет так зависших транзакций типа а дальше времена же заказчик хочет чтобы если мастер упал то стан buy подхватил быстро вот вот как раз на разных судах что происходит в принципе тоже хорошая метафора которая в том числе показывает что разные соды разные домики обращения в соседний домик сложно или невозможно и мы на метафоре это понимаем показываем объясняем и так далее этого это не tprs чек-лист для проектирования о том как масштабируется каждый сервисов под нагрузкой где общее б д где отдельно как взаимодействуют сервисы где есть скрытые очереди как обеспечивается устойчивость то есть в принципе такой мусор остается от незавершенную сессии когда покупатель его прервал ну или закрыть браузер или интернет у него пропал потому что он выехал из зоны интернет а ну а потом не вернулся и так далее в общем очень интересный кейс вот для меня лично я периодически едет сапсан в питер с неустойчивым мобильным интернетом пытался там купить билеты в театр и это такой вот квест потому что на нестабильные интернет и нестабильную смесь все эти сайты нифига не расчитаны и ты каждый раз переживаешь ада питер расставить не можешь потому что типа билетов мало осталось риски вот вот и вот потому что те кто проектирует они в эту сторону вообще говоря не думают потому что вот связь между заказчиком и ли там уровнем аналитики которые думают они не понимают как устроено внутри а разработчики наоборот датой абстракции не поднимаются метафора дает возможность построить язык начаты например вот мы часть я прошел по проектировал там вот есть ведение заказов нужд абирова нее есть остатки на складе с шарден гам но дальше надо проплаты про доставки про исполнения доставки причем там если углубиться тоже будет вот появляются отдельные приходы потому что как только мы sharding сделали остатков на складе получается что приход должен отдаваться отдельному серверу который их уже поделит между они просто добавят планирование исполнения доставки совсем разные процессы и вот мы их разнесли а потом возникает приходится задачей перепланирования потому что пробки и курьеры в них неожиданно попадают а у них на сегодня еще запланировано снова приехать на склад и уехать со следующей партией и вот когда у нас исполнении планирования в одном флаконе мы это в монолите переписываем в микро монолите в нашем микро лети а когда это два сервиса то тут вот получается что мы развили что сегодня планируем на завтра тут надо внутри с этим надо что-то делать вот это там сложно еще выясняется что кладовщик при укладке в машину должен знать маршрут и это вот такая обратная связь а это значит он должен не просто коробки подготовить а знать маршрут заранее ну чтобы выгружать удобно либо надписать так чтобы вот это вопрос в момент загрузки он мог по-разному положить зови вот это тогда будет известна и вот локализация тут же нет стрелочки от кладовщика как раз к планированию доставки ее надо отдельно ковырять этого вот старые способы описания предложений не работают современные архитектуре с другой стороны вот то что очень вот domain-driven design взлетел потому что как раз очень удобно когда модели описание приложений проявлены в в реализации прозрачного но в обе стороны есть трассировка и собственно вот метафора гномиков она частично эту задачу решает получая позволяет эффективно проектировать приложение векторной модели на языке понятном не только разработчикам могут потребоваться другие метафоры их надо искать вот как я уже сказал тут вот мой сайт mcp of arc ну и я просто ищут как maxim zubkov вот на этот сайт выходит там на первые страницы где анонсированы мое будущее доклада ссылка на страничку где эта презентация выложена мод можно скачивать прямо сейчас вот а запись появится все я готов ответить на вопросы очень спасибо за выступление это подарок от конференции что ваши вопросы пожалуйста здравствуйте меня зовут антон спасибо за доклад такой вопрос а кто это рисует какими инструментами при этом пользуется самое главное когда приходит патчи эта схема перерисовывается до патча после патча разработчикам ещё кем-то ну смотрите пока ну это вот свежая свежая штучка поэтому это рисуется в подручных средствах то есть которые приняты но в этом смысле можно рисовать в видео можно рисовать в мира можно рисовать вот прямо в powerpoint и если у вас основное средство общения с заказчиком это слайды так тоже бывает вот формальных над от ну вот эта вот аннотация на полу формальная у меня было в планах сделать на эту тему тренинга для этого довести ее до более формальной вещи чтобы на но пока это не получилось вот хотя у меня было несколько выступлений на разных конференциях когда я не лекцию рассказывал а там минут за 10-15 давал модель а потом мы брали из публики кейсы неизвестные мне заранее и пробовали на этой модели проиграть она хорошо вроде получается вот это вот вопрос где риса и можно даже на бумаге и фоткать на самом деле мысли схема пока схема простая то нарисовать на бумаге а фоткать это эффективный способ с некоторой сложностью когда вот начинаешь изменения ну вот где-то рисуешь а вот если несколько версий то это точно так же я не знаю как с диаграммой классов то есть ты в документации ты проектируешь новую ну рисуешь старую оставляешь и versio не рование в этом смысле это не отличается от других визуальных документации диаграмма состояний каких-нибудь ну а на что же меняется вот вот так"
}