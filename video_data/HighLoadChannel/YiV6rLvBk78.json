{
  "video_id": "YiV6rLvBk78",
  "channel": "HighLoadChannel",
  "title": "Как сделать тесты надежными: property-based-тестирование и fuzzing на практике / Николай Климов",
  "views": 620,
  "duration": 2789,
  "published": "2025-01-17T02:34:37-08:00",
  "text": "Всем привет А смотрите мы все хотим писать надёжный код чтобы он не стрелял ошибками чтобы радовал пользователей чтобы вот эти вот зелёные галочки все они действительно говорили нам что всё хорошо Вы можете смело нажать клавиши merge И я тоже этого хочу и на самом деле это не просто моя хотелка так получилось что в ходе моей карьеры Я всегда работал над задачами где цена ошибки Она какая-то довольно не нулевая мы не могли просто выкати на прот и посмотреть как там работает я читал много книг каких-то блогов по методикам тестирования и 2 года назад когда я пришёл в команду коф ВКонтакте меня познакомили с техникой Property bas тестирования вот сейчас оглядываясь назад Это наверное был самый большой бу в уверенности в том что я пишу причём Сначала я как-то отно к этому несколько скептически потом постепенно распробовал и сейчас почти весь код который я пишу покрывается именно проперти тестами на этом докладе я хочу как раз рассказать что это такое поделиться своим опытом и надеюсь может кого-нибудь из вас тоже заинтересуют это попробовать доклад будет состоять из трёх частей Мы сначала посмотрим на каком-то очень дурацком и тривиально примере как-то В принципе выглядят в коде дальше мы будем возьмём какие-нибудь примеры уже из ре практики и посмотрим как проти тест работают на них и в конце Мы немножко поговорим про фанг Почему вообще мы о нём говорим в рамках этого доклада как он находится в этой картине мира А давайте возьмём функцию разворота строки Наверное каждый в эту аудиторию хотя бы раз в жизни её писал Вы знаете как её писать И самое главное вы знаете как её тестировать мы берём несколько каких-то примеров несколько примеров прогоняем через функцию И сравниваем то что она выдала с тем что мы ожидали всё довольно просто такой метод тестирования называется Example bas TES и как и у всего в программировании у него есть свои плюсы и минусы но плюсы что такие тесты очень легко и быстро писать Они быстро прогоняю довольно неплохо выглядят в качестве документации но есть И много минусов первый самый глав заключается в том что ОНТ низкое покрытие естественно я тут не говорю про C coverage Надеюсь никто не считает C coverage хорошей метрикой хорошего теста я говорю про покрытие всех возможных состояний в которые может находиться ваша система Ну то есть Понятно выбрали всего несколько примеров про прогнали на них а состояни может быть огромное количество и смотрите например вы всё-таки решили запарить и сделать пример теста на каждый релевантный путь исполнения вашей программы Ну вы у вас есть какие-то фичи вы сделали на каждый из них тест а потом вам нужно ещё протестировать взаимодействие фичей друг с другом потому что ну обычно там всё самое интересное происходит то есть э вам нужно сделать какую-то комбинатор ную перестановку всех этих вещей для каждый написать Unit тест и количество кода Оно просто у вас взорвётся по экспоненте а соответственно это ведёт к тому что у вас будет много кода в этом коде будет баги потому что код без багов мы писать не умеем этот код будет очень хрупкий потому что ну вы что-то поменяли небольшой код в проде и потом вам нужно 30 Юнит тестов менять как-то это неприятно что мы можем с этим сделать давайте мы не будем приводить примеры на которых мы Тестируем а будем их генерировать Единственная проблема здесь если мы генерируем инпут у нас нету ожидаемого атпу как бы что мы будем проверять давайте мы для нашей задачи сформулируем какое-то свойство катори нежен Нару и собственно будем проверять в в коде вашего теста что он действительно не будет нарушаться такой подход тестированию называется и например для нашей функции разворота строки таким вариантом может быть что дважды развёрнутая строка она равна оригиналу код теста может выглядеть примерно так в примерах мы будем использовать будем использовать не зависит ни от фреймворка ни от языка все проперти теста выглядят примерно одинаково вы пишете вашу тестовую функцию загоняется её в фреймворк она будет запускаться много-много раз при каждом запуске будет генерироваться какое-то случайные входные данные и вы дальше Просто пишите тело вашего теста как обычный готе А как такое запускается опять же как обычный готе там есть опциональный параметр вот Rapid checks можно задать сколько раз оно будет запускаться можно не задавать по умолчанию оно запустится 100 раз вот и Как видите нам сказало что всё хорошо А что бывает когда Всё нехорошо А давайте в наш тест добавим ещё одно свойство дополнительное что мы будем рассматривать именно как utf8 строчку у наши входные данные и что её разворот тоже должен быть корректно utf8 строкой И как вы наверное знаете там сразу начинаются сложности мы не можем просто менять байти нужно смотреть на utf ты в общем наша Функция которую мы реализовали этому свойству не удовлетворяют запустим наш тест увидели что он заел он написал С какой ошибкой заел очень важно он нам написал как это всё дело воспроизвести если это где-то упало на C и Какие данные он сформировал в процессе прогона Ну собственно это всё именно с механикой проти тестов это наверное не так сложно но вот на этом примере с разворотной строки непонятно как Что с этим потом делать как это использовать на практике давайте рассмотрим какие-нибудь реальные примеры и в качестве первого примера мы рассмотрим задачу БПА базы данных А смотрите сейчас я потрачу какое-то время чтобы прямо в детали описать эту задачу прямо Уйду в какие-то нюансы Я это буду делать не для того чтобы рассказать вам как делать бэкапы это вот что-то для другого доклада я буду это рассказывать чтобы вы в процессе в голове прикидывая сложность насколько сложна будет имплементация вот этих модулей которые выполняют эту задачу и соответственно насколько сложными должны быть тесты которые проверяют это имплементация А потом мы сравним А так Ну поехали мы будем бэкапить именно журнал база данных То есть это какая-то последованность события которые записаны в AP файлики файлики периодически ратиев где записаны незаконные транзакции его бэкапить ни в коем случае нельзя то что он может откатиться А и добавим ещё некоторые условия которые были важны нам что мы хотим сохранять сетевой трафик поэтому мы все эти файлики будем сжимать причём Мы хотим также потом эти файлики сразу использовать Поэтому нам нужно делать внутренних сик и Для этого нам нужно будет сохранять кучу Мета информации о том как находить конкретные события вот этого бенга в за архивированное которое мы хотим это чтобы это был то есть нас не устроит что мы там пим раз сутки Раз в час нет вот как только у нас появились какие-то данные мы их сразу отправляем на сервер как Мы это можем решать мым тахте нех модум не буду делать компрессор на старте будет смотреть на то какие у него уже архивы есть будет смотреть на файлики базы данных и находить место с которого ему нужно начинать бэкапить а в процессе он будет не просто перетаскивать битик он будет честно читать все блоки подсчитывать все хэш-функции обязательно нужно делать чтобы мы не закапали что-то закараева всю Вот эту вот Мета информацию чтобы сделать Этот архив seab когда мы дойдём до конца файла мы эту Мета информацию должны аккуратно сохранить перейти на следующий файл если мы дойдём до комит поинта нам нужно обязательно остановиться и ждать когда комит дальше продвинется а в процессе этого он будет генерировать ещё так называемый compress рер Это для экара это просто список вот всех вот наших архивов и для последнего архива там ещё будет байтик а номер байтик по которой мы можем бэкапить этот репорт отдаётся всем экара Да их может быть много они могут работать с разными с разными скоростями а он выполняет примерно такую же процедуру идт на п сервера скачивает список файлов смотрит на корер понимает откуда нужно начинать бэкапить Пит если дошёл до конца остаётся ждать и в общем смотрите в общем-то это всё не так сложно Я думаю каждый из вас такую систему может написать но вот вспомните что я всё говорил и подумайте сколько там внутри всяких ифв сколько там всяких циклов причём не от нуля до конца А вот момента по определённый момент эти моменты нужно очень точно вычислить нигде плюс-минус единички ошибки не допустить ещё естественно тут на каждом уровне какие-то свои кшики В общем сколько тут потенциала Для ошибок и теперь самый главный вопрос Сколько нужно Юнит тестов написать чтобы быть уверенным в имплементации этих модулей у меня есть ответ один мы напишем только один юнитест и сейчас мы на него посмотрим выглядит он примерно так это проти тест в начале у него будет какая-то инициализация неинтересная и дальше будет два цикла в каждом цикле мы будем вызывать Run Это просто функция которая делает какой-то Прогресс то есть в реальном продом коде он просто крутится бесконечным цикле там в своих рутин А здесь мы будем запускать руками в первом цикле у нас будут происходить какие-то внешние события То есть это запись базу данных коммиты рестар сейчас мы на это всё посмотрим ещё во втором цикле никаких событий Нет это такое важное свойство что если системы перестают происходить события и просто дать ей поработать она дойдёт до какого-то логического конца и после этого мы будем проверять наш главный инвариант что каждый байтик который Мы записали он дошёл до п сервера А теперь посмотрим в какой-то реальный код Ну первая сть инициализация она нам не очень интересная начало первого цикла од неявное событие оно будет происходить просто на каждой Ира запись базу данных Нам нужно будет только выбрать Какого размера эта запись будет дальше мы на каждое возможное событие будем подбрасывать монетку и решать вот на этой итерации оно произойдёт или нет что у нас есть ну у нас может ратиро файл произойти сервер может заели мо Наша машина может портиться дальше буде то мы будем пере инициализировать все наши переменные кроме файловой системы мы будем писать блок заданного размера если у нас тиру файл мы будем добавлять если у нас происходит комит Мы будем выбирать позицию этого комита чтобы она монотонна возрастала и сообщать о ней компрессору дальше мы будем просто прокручивать наши вот эти функции R и будем проверять Наш первый инвариант Явный что эка позиция она строго меньше либо равна за комично позиции всё первый цикл закончился У нас второй цикл мы просто прогоняем R смотрим чтобы они не зациклилась и проверяем наш главный вариант Мы честно открываем все файлики считываем из них данные открываем соответствующие архивы декомпрессии их и сравниваем по байту чтобы всё совпало собственно на этом всё это весь тест когда Я взглянул на это свежим взглядом у меня вот в голове была такая постоянная мысль что-то как-то всё просто Неужели вот такой тест он действительно надёжно защищает вот реализацию что она написана корректно и я решил проверить этот тест и я знаю единственный способ как проверять тест - это попытаться вносить Баги и смотреть тест этот поймает или нет Я залез в имплементации вот этого п модуля это там пара тысяч строк гого смотрел просто каждую строчку и пытался внести баги там плюс единицы менял на минус единицы инвертировать какие-то участки кода в общем пытался везде вносить ошибку и на каждую ошибку которую я вносил проти тест находил такую безумную комбинацию вот этих вот записей блоков коммитов ротации файла перезагрузок которые вы производили мне этот баг самое сложное Когда вы пишете проперти тест - это собственно придумать Вот это свойство которое вы будете проверять И вот в предыдущей задаче мне в некотором смысле повезло Вот это главное свойство что у нас всё переходит на сервер оно вот прямо в условии задачи есть Давайте посмотрим на ещё примеры каких-нибудь задачек и уже не так подробно и посмотрим какие варианты мы там можем придумать Например у нас есть зада заказа такси наме что водителю не назначили два маршрута или если второй маршрут назначили то мы уже идм по первому нам условно Осталось каких-нибудь 5 минут доехать ещё такой инвариант Я его использую Практически везде это такой инвариант что при отсутствие каких-то явных проблем и в данном случае если у нас достаточно машин то каждому пользователю назначит какого-нибудь водителя то также раци будем генерировать какие-то ивенты что мы можем генерировать какие-то Рандомные Заказы от рандомных людей отмены заказов отмена заказов водителям мы можем имитировать какие-то сетевые проблемы в общем мы будем дёргать за все какие-то разумные ручки за которые мы можем дёрнуть в принципе и смотреть что что бы мы там не надр ли наши инварианты они выполняются абсолютно всегда а другой пример допустим у нас есть какой-то у нас есть система которая качает в изначальной задаче бы шла речь про криптобирже У нас есть менеджер который распределяет Вот перекачку вот этих данных по каким-то воркера и мы хотим проверить этот код что он работает правильно Какие тут могут быть инварианты Ну что по каждой активной подписке в данный момент кто-то качает данные и что нагрузка между рми распределена плюс-минус и то так будем возе дублирую подписки менять паттерн нагрузка на воркеров мы будем перезапускать и ВС и в каждый момент времени проверять что наши инварианты они выполняются Ещё один очень интересный пример который я Надо был в интернетах чувак пишет свой видео эдитор у него там есть маленькая функциональность классификация видео то есть вы смите его видео он говорит что в этом секторе есть какие-то движущиеся обекты в этих секторах э Джени нет И вот тут уже сложно Потому что если мы будем генерировать так случайное видео то что нам проверять вот мы мы отдадим его классификатор он выдаст нам какой-то аутпут и какой он вариант тут придумать автор вот этой статьи он что сделал он он решил генерировать не видео а ожидаемый аутпут то есть вот это вот разбитие на секции по нему Он сгенерировал видео там с какими-то своими движущимися паттернами дал это классификатору и уже сравнивает аутпут с тем что вот с ожидаемым атпу и вот этот пример Мне нравится на самом деле по двум причинам Ну во-первых это довольно оригинально что он генерирует не инпут для системы а ожидаемы апу Вторая причина Ну смотрите если мы зададим вопрос проверяет ли этот тест все возможные релевантные варианты Какие существуют видео в мире что на них наш классификатор работает правильно Ну наверное нет он проверяет только то он проверяет только то что классификатор правильно работает на вот этом вот сгенерированный автором видео но при этом это всё равно гораздо лучше чем если бы он написал много тестов вот так руками с какими-то своими ручными примерами И кстати автор тест автор вот этой статьи он согласен потому что этот функционал уже у него был на него он уже работал На него были написаны какие-то тесты но когда он решил написать проти тест он нашёл какой-то отдельный кейс на его классификатор ломался Ну давайте теперь поговорим о том о каких-то общих паттернах которые может возникать ну вообще каждая задача - это вот такая уникальная снежинка для каждой нужен свой подход в поиске вот этих вот о свойственны вариантов но какие-то общие паттерны существуют есть вот такой пате его привод строки на самом деле в практике он редко встречается раз все приводят Я тоже его приведу есть такой паттерн что мы просто проверяем что ничего не падает что мы нигде не вылезли за границы массива Ну в общем-то хорошая свойства нашей системы ещё один паттерн что мы можем вычислять одни и те же значения разными способами Например у нас есть какой-то кэк который содержит какие-то чиселки мы можем вять из этого и расчитать его заново или сходить в базу данных за ним и проверять что значение в кэше у нас совпадают с каким-то нашим Таким образом мы будем проверять что наш кш работает правильно ещё есть такой очень часто встречаемый паттерн это сравнение с простой моделью Ну смотрите например мы пишем какой-то магазин пользователь кликает по каким-то товарам на каж Вот это клири какой-то запрос базу данных чтобы Мы записали что вот этот товар добавлен в такую-то корзину а фича у нас может быть больше там мы можем удалять какие-то товары можем удалять корзину мы можем менять количество товаров в этой корзине и вот если мы хотим проверить чтобы Весь вот этот код работы с баз данных работает правильно причём при взаимодействии друг с другом вот всяких различных таких ивентах Мы можем Что сделать Мы можем написать какую-нибудь очень простую модель просто хш маку в памяти написать код который выполняет логически те же самые действия причём этот код должен быть супер простым чтобы вы на него посмотрели Так пару минут подумали и сказали да это точно корректно просто потому что он простой дальше Вы будете применять все возможные события к обоим моделям и смотреть что они приходят к одному и тому же состоянию тоже паттерн это какие-то внутренние варианты Ну смотрите например в примере с кпом который был выше вот мы вызывали там компресор Run и он внутри проверяет всякие различные всякие разные варианты например там есть переменная которая обозначает вот в каком месте файла мы сейчас находимся и есть например файловый дескриптор этот файла есть и вариант что если одно существует и второй должен существовать если кого-то из них нету то это какая-то ошибка имплементации я сразу выкидываю ошибку и про мне это ловит а есть ещё вот один такой очень интересный паттерн - Это проверка вторичных свойств иногда Вот то свойство которое вы хотите проверить А вам сложно выразить его как-то формально на языке программирования например опять же вот вернёмся к развороту строки мы там приводили мы писали тест который проверяет что двойной разворот равен оригиналу но если честно это какая-то фигня нам никогда на практике это не нужно нам нужно чтобы строка была развёрнутая это это свойство так чтобы оно было в общем если мы начнём реализовывать это свойство мы обнаружим что мы пишем вот ровно такой же цикл как есть и в тестируемый функции То есть у нас один в один начнётся схождение и это такой понятный антипаттерн так делать не надо поэтому мы проверяем какое-то вторичное свойства которое нам просто проще сформулировать но тут есть такая опасность А давайте представим что мы реализовали функцию reverse которая просто принимает аргумент и сразу его отдаёт ничего не делает и тогда вот этот тест с двойным разворотом она пройдёт Это получается какой-то плохой тест и действительно вот со вторичными свойствами нужно быть осторожнее Я в данном случае обычно делаю несколько эмл тестов чтобы проверить что на на некоторых примерах он 100% работает и потом запускаю ещ протест который уже будет в состоянии в пространстве ваших входных данных искать какие-то интересные места где вторичный вариант нарушится и соответственно ваша реализация где-то там неправильная Ну вот я говорил что Про какие они все хорошие есть у него конечно и минусы первый глав минус их ба сложнее какие-то примеры на которых всё происходит Хорошо или нехорошо Это довольно просто отойти на шаг назад попытаться осознать всю вашу систему и какие в ней есть варианты Это несколько сложнее и причём Если вы это постоянно не практикуете то это становится ещё сложнее тут есть такая аналогия с функциональным программированием Если вы начинаете писать на функциональном программировании вам очень тяжело поначалу просто потому что вы привыкли думать в таких концепциях Здесь тоже самое Тут нужен какой-то опыт ещ минус проперти тестов что если у вас в задаче есть какие-то кейсы Ну например у вас для всех пользователей работает какая-то одна логика а для пользователя с id1 другая совершенно Почему так ну неважно вот так получилось тогда вам придется вот этот ке запихать так или иначе ваш проте То есть вте вы просто его проигнорировать проперти тест Вам он найдёт и вам нужно либо эту логику пихать тест либо как-то явно говорить что для ID равно оди мы ничего не проверяем В общем так или иначе в этот в тест он зайдёт и чем больше таких вот кейсов тем более уродливым будет ваш тест Аа ещё одна проблема которой я периодически вижу на практике что я не уже не упоминал Иногда вы пишете такой тест и он начинает в Один в один походить на то что вы тестируется а почему так происходит Ну опять же иногда вот это вот первичное свойство которое вам интересно просто как-то очень сложно Вырази а иногда бывает что это просто задача иногда бывает что вы выбрали просто неправильную абстракцию что в ней есть слишком много ручек что в ней сложно сформулировать вот это вот какое-то свойство тут можно было посмотреть то чтобы вообще переди зайни вашу систему и ещё несколько замечаний что вообще говоря я ничего не говорил Ни про тест ни про интеграционные тесты потому что проти тесты так же как и Example тесты на самом деле они их можно применять на всех уровнях и более того У нас на работе Мы делаем проперти теста в - to end случае А и ещё такое замечание вот если вы сегодня вечером решите написать какой-нибудь протест а не обязательно сразу кидаться и описывать абсолютно все свойства которые вам могут прийти в голову в том смысле что это может быть каким-то итерационным процессом и итерация ноль может быть Вот как раз вот это свойство что ничего не падает и это уже будет лучше чем какие-то написанные ваши руками тесты фанг Ну смотрите фанг на самом деле несколько более популярная концепция чем проте положу что каждый В этом зале хоть хотя бы на концептуальном уровне знает что такое фанг поэтому мы поговорим только о том как фанг вообще участвует в этой картине мира А и участвует он очень просто я сделал у меня есть такое Утверждение что фанг - это и есть Property bas тесты Но по крайней мере в его некотором таком абстрактном математическом понимание что если у нас что протест - это какая-то часть которая генерирует для систе потом передаёт её в эту систему и проверяются какие-то её свойства в этом плане фанг отличается тем чем Ну просто у него такой очень хитрый и крутой как раз генератор входных значений он по какой-то метрике выбирает наиболее интересные входы сохраняет их как-то мутирует чтобы сделать ещё более интересным и в этом плане вот эти вот то что мы классически называем проте соно с фангом примерно как алгоритмы Random и какие-то эволюционные алгоритмы которые могут потихоньку подходить к какому-то результату Ну да Ифа в классическом фанг свойство которое мы проверяем это что ничего не падает если мы посмотрим на код здесь вот приведён код нашего проперти теста разворота строки и точно такой же фанг теста и мы видим что они в общем-то Один в один совпадают кроме вот рации инпута и я сделаю ещё одно Утверждение что всё что мы можем протестировать с помощью проперти тестов мы можем протестировать И с помощью фанга Нам нужно только понять как вот эту вот строчку интерпретировать в виде наших данных Ну на самом деле задача довольно простая У нас есть какой-то by сй мы его можем в общем-то представить в виде строки и как будто там написано какое-то число даже какая-то структура нам только нужно придумать как эта структура ложится в этот by сй более того Мы даже можем эмулировать какой-то набор набор событий или команд вот в примере с бкпо базом данных мы могли бы просто интерпретировать вот этот бай слай что ну мы смотрим на первый символ если там записано W Это значит что у нас команда в Right блок следующие два байта Какого размера если там написано C значит у нас происходит комит если R Бут и так далее и мы получим просто Набор э событий которые происходят с нашей системой а и более того если вы используете Rapid Вы можете просто обернуть ваш ID тест функцию Make F и передать её как Таргет файзера и вот это вот всё будет реализовано под капотом Так ну вы можете спросить Коля Вот ты говоришь что фанг всем лучше чем проперти теста Так почему ты вообще разговариваешь про какой-то ID Зачем он нужен честный ответ на это что чтобы использовать фанг нужно преодолеть какие-то такие административные вопросы Что нужно настроить C добавить там какие-то таргеты решить что делать с корпусом там каждый раз обнулять его или сохранять где сохранять в каком-то репозитории lfs В общем нужно решить вот такую-то кучу вопросов и на самом деле вам зачастую не нужен фанг смотрите вот где фанг обычно применяется это какие-то туы архиваторы вот такие задачи кото которые получают на вход просто сырую строку и пытаются её как-то интерпретировать найти в ней какую-то структуру нужную им и вот я сделаю ещё одно такое очень ещё одно Утверждение что в этих задачах фанг используется Не потому что фанг хорошо на них работает он там используется потому что ничего блин там больше не работает что вот это вот пространство размерность пространства входных Оно настолько огромное что надеяться найти там найти что-то интересное в НМ простым рандомом Ну это вероятностью близка к нулю а и если у вас такая задача да вам нужно использовать ванг Но если у вас задача что у вас есть просто в вашей системе какой-то набор ивентов довольно конечный у них есть понятные аргументы то обычный проперти теста например с помощью пита он вам и так перет все возможные варианты и и отработает довольно быстро Вот и плюс этого того что вы можете вот прямо сегодня вечером пойти что-нибудь написать заржать и такой проперти тест у вас уже будет гоняться в C и не нужно дёргать никаких псов Ну и в заключени Я хочу немножко поразмышлять на тему того зачем мы это всё делаем смотрите мы хотим писать хороший софт чтобы пользователи радовались когда они его используют а не было никаких ошибок Докучаев Я думал что это в общем-то вопрос про корректность того что мы делаем что мы выбрали правильно алгоритмы что мы правильно заимствовали вы начте прямо сильно париться и пытаться продумать Каждую из этих вещей как она должна работать Вы в какой-то момент у прёте в границу эта граница - это просто когнитивные возможности человека что мы не можем обращать внимание абсолютно на всё и в этом смысле я рассматриваю проперти теста не как какую-то технику которая вам докажет корректность работы вашей программы доказать корректность сегодня это невозможно я рассматриваю это как возможность написать более лучшие тесты и наоборот убрать фокус своего внимания с корректности и распределить его по каким-то другим областям чтобы софт был лучше и весь мир который мы Строим вместе тоже стал лучше спасибо спасибо большое за доклад ели вопросы в зале Если у вас есть вопросы поднимите пожалуйста руку к вам подойдут с микрофоном задавайте пожалуйста свой вопрос громко и ясно в микрофон которые находится у рта также Если вы не хотите или вы смотрите нас онлайн задавайте вопросы в чат Да добрый день спасибо за доклад у меня такой вопрос Почему вы Файн не рассматриваете с точки зрения секюрити А можно повторить погромче поближе фанг в частности он в основном используется для того чтобы проверить насколько скажем так уязвим тот или иной метод или там функции модуль Почему вы это не рассматривать с точки зрения секюрити А да это один одна из областей где действительно используете фанга но мне кажется это частный случай что у нас ничего не падает что мы не проезжаем Нигде По памяти а и Security и они истекают как раз из-за того что у нас есть какие-то ошибки в нашем коде не знаю ответил ли я на вопрос Спасибо Следующий вопрос из зала с правой стороны на втором ряду Да спасибо за доклад у меня такой вопрос под Все ли задачи подходит про тестирования и Если да то как мы доказываем что этот тест точно корректный а если нет то под Какие не подходит Давай нано формули везде можно применять Ну наверное нет а опять же в некоторых местах просто сложно сформулировать какой-то инвариант системы Вот который можно просто взять и как-то просто описать А есть различные области где может можно применять но я об этом как-то не думал там например какие-то мейли фронтэнд не знаю наверное там можно как-то применить Я этого не знаю А И какой ещё был вопрос скорее ты ответил Нет я ответил пример Хорошо Спасибо большое Есть ли ещё вопросы в зале Давайте дадим слово по центру зала а так спасибо большое за доклад было очень приятно узнать про подход и очень интересно а ты приводил такие скорее вот искусственные немножко синтетические примеры того как у тебя проти bas тесты находят какие-то вот внесённые тобой ошибки в систему вот в качестве такой наверное более действенной пропаганды были ли у вас какие-то реальные кейсы Где вы находили какие-то баги в процессе разработки с помощью этих тестов довольно хитрые или какие-то регрессии А да было много примеров То есть я сейчас разрабатываю проперти тесты одновременно с тем как я пишу собственно реализацию и он ловит очень много каких-то сложных багов Вот м что при подготовке доклада что я их не записывал куда-то чтобы мог Вот так их привести Но действительно находит очень много всего и того что я вот руками бы никогда не написал Спасибо Есть ли ещё вопросы в зале Давайте дадим слово центру зала Спасибо за доклад Слушай вопрос такой А ты смотрел в сторону прогресса встраивания к фанте потому насколько я знаю например Google тестировал свой какой-то Нетворк стек с МКА и там нашёл всякие критичные уязвимости там типа баф Flow и так далее вот что вообще об этом думаешь как какой сейчас над этим вообще Прогресс и использова были ты это Угу А ну смотри честный ответ то что я не смотрел на это всё закончили а нет ну моё мнение скажем так пока что скептическое то есть вот это процесс когда мы придумываем инвариант Какой тест он довольно творческий он сложно формализуются поискать Угу Хорошо спасибо Есть ли ещё вопросы в зале Добрый день спасибо за доклад У меня вопрос следующего рода вот когда мы используем классическое тестирование мы имеем некие метрики когда мы понимаем что тестирование нужно закончить Ну грубо говоря полнота тестирования полнота покрытия и так далее вот есть ли что-то аналогичное для Property bas тестировани как мы понимаем Когда нам пора уже остановиться с тестированием и можно отпускать это дальше а можно я встречный вопрос задам А какие такие метрики ну в частности мы можем полноту тестирования проверить Да мы можем А что это такое полнота покрытия функционала тестами что мы по каждой веточке функционала прошли проверили coverage Да вот собственно это единственная известная мне Метрика и я считаю что она очень плохая Метрика а потому что если мы начинаем смотреть на код coverage На вот эту вот одну чисел и стремимся растить её вверх то мы неправильными способами что мы должны проверять не Cage а всех состояний в котором может находиться наша система и простым кам это не задеть вопрос оригинально о том ели вот какие-то метрики чтобы посмотреть наверное нет вот прям вот чтобы они везде работали это всё-таки тестирование это очень творческий процесс Спасибо большое Есть ли е вопросы Из зала вопрос давайте пока я здесь я зачитаю вопрос из чата нам пришёл вопрос в чат от Павла Киселёва вы выбрали для таких тестов прот Есть ли другие пакеты и сравнивали ли А другие пакеты есть если честно я не проводил такое сравнение тне очень удобно тем что Автор этого пакета работает в Мом отделе вот и кстати он присутствует в зале Если есть какие-то вопросы по нему Я думаю что его нужно будет тоже в дискуссионный зду с собой забрать Да но по фича Пит меня устраивает всем поэтому я даже не думал на что-то вы менять супер спасибо вопрос Привет Спасибо большое за доклад Вопрос такой В общем если у системы которую мы Тестируем на которую пишем Property bas ну перестало существовать какое-то свойство с Property B тестами подход такой же как с остальными типа с юнитами просто обновляем их так чтобы они проверяли новые свойства модели да да если появляется новый тест и новое свойство или это свойство перестаёт быть актуальным то его нужно убрать и придумать какое-то новое супер спасибо Есть ли ещё вопросы в зале а Привет ты сказал что для того чтобы фанг тесты использовать нам Нужно настраивать сначала C но я не очень понял это видимо для того чтобы фанг прямо постоянно происходил в фоне и говорил что что-то упало а проти bas тест они же тоже не один раз гоняются они должны гоняться какой-то время постоянно Почему для них Тогда не нужно настраивать C понятный вопрос действительно проперти теста они тоже в некотором смысле бесконечно идут у них нет какого-то определённого конца А тут скорее вопрос технику которую мы используем А задача в которой мы это используем то есть фазеры мы обычно вот используем Когда у нас есть просто сырая строка нам нужно её сгенерировать это долго и это действительно может занимать годы чтобы найти что-то интересное проперти теста мы больше чаще используем Когда у нас какое-то конечное число ивентов какие-то ограниченные значений из которых мы можем выбирать В общем го больше т структуре вашей программы потому что вы это их написали в этой структуре И поэтому они быстрее находят что-то интересное и Да их тоже можно гонять довольно долго Например если я там что-то поменял существенное я не 100 раз запускаю а 100.000 локально а потом на сие уже достаточно каких-то дефолтных значений Они быстро что-то находят Спасибо ещё вопрос из зала Да подскажи пожалуйста так меня слышно ра раз раз микрофон не не смеётся сейчас мы быстро произведём замену а вы пока сканируйте QR код ставайте оставляйте отзыв на доклад выставляйте рейтинг Да ты упомянул то что Example тест они хрупкие а получается фаззинг тестирования более устойчивое И за счёт чего это достигается за счёт того что меньше кода То есть вы обычно фанг или пропети тестах дёргается только какие-то интерфейсы они реже меняются и они не используются там у вас в сотни Юнит тестов Везде они только в одном каком-то или двух тестах и поменять Это довольно быстро Спасибо Есть ли ещё вопро ещё вопрос в зале Привет Спасибо за доклад а такой вопрос Что лучше использовать тестирование по компонентное Property Бейс или фанг или лучше глобальные Например если с точки зрения Вот как раз датабейс бэкапа не могу сказать что лучше зависит от задачи то есть в этом плане проти теста они ничем не отличаются от Example тестов Если вы можете это использовать в компонентном тесте заводя какие-то моки замечательно Используйте если вам этого недостаточно И вам нужно какое-то интеграционное тестирование Ну Тоже замечательно Используйте хорошо спасибо Есть ли е вопросы в зале вытяните пожалуйста вверх ру м Да добрый день спасибо за доклад одно из условий сертификации это фази тестирования знаете ли вы подходит под условие или нет сейчас можешь повторить погромче да для сертификации нужно предоставить результаты в фа тестирования те подходят для или изучали вопро знаю профика даже не знал что она какая-то существует Спасибо Есть ли ещё вопросы в зале Привет Спасибо за доклад ты приводил пример вот где по атпу гнется инпуты Да и кажется здесь есть проблема с тем что мы как бы принимаем на веру что у нас вот э туза которая она работает корректная и получается что нам её тоже как бы надо покрывать тестами да Или как нам здесь быть что ты об этом думаешь Слушай ты абсолютно прав Единственное что мы тут можем сделать это удостовериться что вот эта функция генерируется она очень проста и она Ну либо действительно тоже покрывать её какими-то тестами либо просто её просто написать и увидеть что она работает так тоже иногда можно делать Спасибо большое Есть ли е вопрос в зале У нас есть время на ещё один вопрос Если вы ещё не задали вопрос мы идём к вам добрый день Андрей Озон тех такой вопрос какой имеет смысл брать гранулярность тестов скажем так то есть насколько я понимаю они достаточно трудоёмкие и Если писать Извини можешь погромче насколько я понимаю написание таких тестов достаточно юнитов то есть какой вообще размер юнитов сложность юнитов имеет смысл покрывать скажем экономически экономически целесообразно имеется в виду Ну смотри это всегда трейдов которые зависят от вашей бизнес-задачи если вам нужно надёжно вы вкладываете в тесты если если вам нужно фига фига и в продакшн Ну наверное такое тестирование не подойдёт единственное что я могу заметить что вот если вы наберёте какого-то опыта в написании таких тестов это будет становиться всё проще и проще потому что вы в процессе написания уже будете думать какие варианты в вашей системе есть и сейчас я бы не сказал что я трачу какое-то прям значительно большее число времени на написание таких видов тестов Спасибо Давай скажем что это был последний э вопрос в сессии вопросов и ответов А давай выберем с тобой вопрос который тебе больше всего понравился для того чтобы подарить матрёшку во Подожди я же го подарить матрёшку онтико онтика матрёшка у нас всего одна Не обманывайтесь кому подарим морошку А ну давайте вопрос про кот coverage я его ждал он прозвучал крано Извините я умудрилась выключить и включить микрофон поднимите руку пожалуйста чтобы мы вас видели и нашли вас а также принесли вам матрёшку Давай теперь выберем вопрос которому достанется подарок от твоей компании а давай вопрос про насколько долго можно вот запускать это всё в C прекрасно Не уходите пожалуйста мы вручим вам подарок от компании ВК вас Мы тоже Хотим поблагодарить Спасибо большое это было очень круто Мне было очень интересно послушать пойду обсуждать опять это с даниилом Спасибо N"
}