{
  "video_id": "NLnszBkKbP0",
  "channel": "HighLoadChannel",
  "title": "Эффективное использование современных x86 совместимых CPU / Алексей Тутубалин (Ашманов и Партнеры)",
  "views": 1821,
  "duration": 2702,
  "published": "2021-07-05T04:41:55-07:00",
  "text": "легенда российского интернета когда мы ходили в школу алексей программировал свой черный квадрат вы не знаете учите матчасть один из лучших специалистов по интернет-технологиям разработки сложных сайтов высоким нагрузкам большим объемом данных алексей тут у болин из ашманов и партнеры на сцене а на самом деле я с сайтами как-то давно уже не занимаюсь а последние годы 4 занимаюсь обработкой изображений в цифровых фотокамер и соответствие вашего наши партнеры а в собственной компанией маленькой но речь не об этом а речь сегодня примерно вот о чем что давайте посмотрим на наши с вами процессоры к такой процессор я имею ввиду длинное определение современной x86 совместимый интинский м душной то есть об обаме разговор не пойдет о of power писи разговор никакого не будет а мы говорим о самых распространенных серверных и десктопных процессоров если мы посмотрим на то что случилось за последние лет семь но вот левая колонка презентации то вроде бы производительность не растет тактовые частоты примерно постоянно супер скаляр ность то есть количество инструкция так например кто-то постоянно и если все это по тестам и хорошо видим я соберем вторую программу пускаем на ногу на новом процессоре с той же частотой производительность будет примерно той же самой что и 5 или 7 лет назад может быть чуть чуть побольше 10 20 процентов а есть другой взгляд на те же самые вещи это те же самые процессора на самом деле стали в 30 60 раз быстрее смотрите сами по ядрам мы выросли с 2005 года от 4 до 6 раз на на десктопе и наверное до 8 раз на сервере потому что в пятом году были 2 таверны и серверные процессоры расчеты 16 ядерные то же самое случилось с векторными командами в пятом году pentium 4 делал два сложения с плавающей точкой в за один такт а сейчас он белый современный процессор делает на вы exe восемь сложений 8 умножений и все это за один такт вам и то чего хочется с нашими программами это жить не по левой колонке а по правой то есть все вот эти возможности и многоядерность и и из с.е. а вы из команды использовать . я буду рассказывать это о том как перевести старые написанные в 90-е годы или в духе 90-х годов программы на новый на новые рельсы и двумя на самом деле методами замены обычных циклов исполнения программы на параллельные циклы которые исполняются сразу на многих играх и о замене обычных команд на векторной вот когда я презентацию писал мне было ощущение текут банальность пишу все должны назначить а потом смотришь на охотно open source которой есть вообще вот на все что происходит в вокруг и если все эти все это знают о почему-то не использовать пункт первый это локальная многопоточность речь о том что мы а циклы длинные которые есть программе хотим исполнить параллельно мы не хотим стать многопоточной программы сак настоящие потому что с ними ужасное количество головной боли д т раисы или в синхронизации который нас назовут время хочется делать многопоточность очень маленькую очень компактную исключительно в рамках циклов которые долго исполняются у этой конструкции есть накладные расходы и как правило создания нового потока создание и ожидании его завершения занимает микросекунды на современном оборудовании дано больше это цифры которые я сам не верил я взял у людей которые изменяли поэтому слишком короткие циклы расстраиваться не станет то есть что такое 10 микросекунд на три мерном процессоре и это десятки сотни тысяч команд элементарно значит цифры длиной миллионы расстраивается смысл есть а цикла короче нет это для которой для этого существует как ни странно вот такого исполнения есть поддержка у компиляторов я расскажу про open mt и в принципе упомянуть что еще бывает и можно солнце закатывать вручную с помощью трейдинга библиотек int и начнем этот довольно старый лет 15 уже конструкции которая придумана для фард романских компиляторов в первую очередь идея в том что циклов подобные вот этому конечно можно сказать параллельным потому что никаких взаимозависимости нет порядок исполнения неважно что хоть что делать гитлер воткнём вот такую программу хищный ход для компилятора который поддерживает о пенальти компилятор сделать следующий простую вещь он ставит вызывая об open и пишет ворон тайма придет циклом там запустится сколько ты потоков обычно подчистую доступных ягер хотят регулируется он сформирует кусок кода который в этих странах будет запущен этот код обработает кусочки данных потом будет ожидании всех со всех треков и вроде все как было раньше довольно развесистой возможности есть у пинки есть redbull самое придвинуться есть о томики критические секции ну так по большому счету более менее все вот здесь второй пример анализ тенге это как сделать мы previews а мы говорим в программе что надо будет редуксин что дедушка лодка оператором плюс для переменной сумму калькулятор сделать временным временную переменную про инициализирует ее в каждом потоки будет свое купит из этой самой суммы и компилятора же автоматом породит код для радиуса который все эти самые копии служит вот такое чудо 1 pragma и вроде уже провели исполнения если обратить внимание вот это прогноз все убрать например компилятор не поддерживает опытными пили мы выключили его то останется последовательный код который вполне валидный который исполняется на одном евреем и у него все хорошо и наоборот внедрение а ты нынче вашей программы делается в обратную сторону вы делаете нормальный последовательный код profile рам смотрите где он медленно исполняется отец в тех местах в тех циклах которые допускают распараллеливания вставляете pragma и все начинает работать быстрее для си плюс плюс ников надо отдавать себе отчет что поддержки к сапсанов нет все exception-ы должны обрабатываться внутри иначе все развалится protection что делает она сворачивает стек наверх у какого ты в основном строки где все исполнялось этот стек есть выше на остальные на остальных играх его нет и свернув instek уволить просто не туда эксепшен а ведь внутри ставить флаги в памяти и после завершения правильного блока обрабатывать exception а дальше естественно есть ошибки самая ужасная чем а сталкивался это в mac os 10 6 а опытным пи не работал moody от вредных программах в обычных работал как только делаешь многопоточную программу все разваливается и то же самое с поддержкой хочу поддерживают все распространенные компиляторы кроме силы кроме м а то есть интеловские microsoft аске gcc все поддерживают оперным пим силен конец значит опять пролетают mac os уже новый потому что новый xcode а живет на селенджер кроме отмены мпэ есть еще похожую конструкцию у интела называется силка плюс они купили у какого-то университетом в месяц разработчиками она более развесистой по возможности но это только им плоский компилятор все + + и и они за канске beauty ли в gcf 48 но это пока на какое-то неживое мог бы через пару лет мы увидим альтернативу пока его нет есть альтернатива захватывать солнца вручную все то же самое может библиотекой породить 3d вскормить туда код дождаться завершения все это абсолютно тривиальна только требует больше работы библиотек таких много то есть есть интуиция трейдинге building blocks которые самые известные есть юте конкурент есть boost мы предустановку называется думаю что к миллион на самом деле вот тот же самое сложение векторов но с помощью intel тебе by the dog не пойму что здесь с указкой укладки нет хотя тараса снизу вверх читаем вот тебе by провел диджус делаем всю магию он запускает 3d передает туда данные передаются туда же объект типа сумм который выше определен у этого объекта из важного нам есть оператор круглые скобки который получится итератор с кусочком данных и там все что нужно про формирует и есть выдох джон который делает уже devil's то же самое что мы видели на примере сапина пицца со сложением элементов вектора как мы видим существенно менее компактно но от этого не менее понятно вот этот подход позволяет цикл и ускорить достаточно эффективная станет позволяют если алгоритм параллельной провериться вот если нет связей типичный speedup который получался у меня 4 играх обычно три три с половиной раза на 24 я верх у меня были всякие эксперименты правда с большими очень данными там получалось 22 23 раза на 24 кадрах то есть чуть выше 90 процентов эффективность дешево сердито надо пользоваться то есть от вашей программы это почти ничего не требуют кроме того что алгоритм должен иметь возможность исполняться исполняться параллельно 2 резерв производительности пожалуй не меньшей это векторные команды процессора который им позволяют с местными элементами данных работать одновременно в для тех кто не в теме мы из три слайда который потому что это такое был mmx слава богу парня можно забыть читаем что его нет потом было есть из я вот сейчас последних процессоров fx с.е. эта работа со 128-битным регистрами в каждом регистре содержится какое-то количество элементарных типов там четыре фута 32-битных или восемь 16-битных энтов дальше одной команды процессором и нас у меня регистрами ну четырьмя парами float of делаем сложения вот с зеленым показано команды процессора к красным псевдокод который соответствует этой команде это это очень быстрой команды то есть две команды затакт простые в одно сложение одно умножения это типичная скоростью современных процессоров fx pro fx обычно думают что это тоже самое только с длинными докторами на самом деле там больше там появились там команды стали из двух известных всех адресными то есть верхний вариант у нас разрушается один из источников мы делаем плюс равно а нижний вариант с оба источника сложения оставляет неприкосновенными и результат пишется встречи регистр это для компиляторов очень приятно им легче делать код если под пирс вручную тоже бывает полезно и кроме трех адресности расширился вектор регистры они стали 276 бит ними но только для плавающих типов то есть для целых типов данных все еще 128-битный как многие знают а кто не знает о на это сейчас в сортов этого 7d к сожалению очень много и софье появился в пень чуме 3 потом pentium 4 повелось с е2 потом в каждой новая версия процессора intel что-то обновляла и возникает большая проблема так что же мы будем делать код и ответов на нее правильных нет есть и неправильных 1 неправильный ответ будем делать из с е2 потому что он есть везде и так 4 pyncheon и были новые процессора более 40 процессоров не осталось можно использовать чем плохо плохо тем что окна те у кого процессор и более новые тени получат полных возможности потому что в каждой новой версии секс я добавляла какие-то полезные команды по полезные возможности второй неправильный цвет делать по 2 x потому что скажем мы купили наши сервера в прошлом году они все поддерживают а bx и более старые сервера над не интересуют и третий вариант который на самом деле правильный но очень трудоемкий это делать в одном коде а потом в одном бинарники три пути исполнения вот а вы x потому что использование винкс а там где он есть этот огромный выигрыш в производительности подняться с е2 потому что это та минимальная совместимость которая бывает и что-то промежуточные светский высоцкий 4 смотря от того какие команды нам на самом деле нужны здесь краткий обзор что в из с java x есть чего нет я зачитывать его не буду скажу о важно что что важны эти 16 регистров в процессоре 32-битном режиме доступна только 8 поэтому и 4 поэтому если все четыре бита режим нам доступны лучше пользовать использовать его 4 размеры целых два размера с плавающей точкой цели бывают знаковых by знаковые 16 32 бита самые длинные самой коробке только без знаковые чего нету нету flow control а то есть мы делаем операцию целиком с регистром утрата лежит 4 flow там и два регистра складываем складываем та ладно я то мы делим обе на другое а там не тонули будет xx-ом который довольно сложно поймать потому что непонятно какому элементу вектор он относится чего нет 2 это нет ни сплошной записи не страшного чтения то есть когда мы читаем из памяти 128 бит мы читаем страшный кусок когда напиши мы пишем сплошной кусок это вызывается огромные проблемы потому что нужно данные организовать по другому вот здесь левая колонка это то как обычно пишут ну скажем на си плюс плюс у нас есть тип данных там есть поля x y z члены класса ну допустим за это учит вычисляется из икса и игрека по какой-то простой формуле а и b константы допустим мы хотим иметь массив этих самых форм и считать z векторизованное считаем нужным прочитать нам нужно в 1 регистр творю 4 икса x0 и x1 x2 и x3 в другой 4 энрико там встретила новый 4 жить константы и посчитать начинаем учитывать икс и икс эль вад память не подряд значит нам о чтении возможно только большим куском нам нужно 4 чтение за одно чтением они как 400 не считаем и нам еще нужно три операции которые никак не учтены это переупорядочить мы сделали сами чтение в разные регистры давних сложить в один даже не считаем это тоже самое с игреками хотят можно схитрить их среды реки от к лицу просчитать вместе дальше три действия там два умножения и сложения записи cd лежат в памяти тоже не подряд поэтому будет четыре операции записи а вот альтернативный вариант зелененький который против правил объекта не терном программирование против всего зато он эффективен от есть массив x of massive ледников марсе взводов заодно чтение читаем 4 икса за другой 4 игрека три действия 1 запись это будет быстрее в разы чем тот способ который слева но зато плохо организована внуку что выбирать производительность или читаемость программы это всегда огромный вопрос третий момент который нужен всё и не нужен говорится это выравнивание до 7 7 in the lan не выровненные данные читались медленно быстро читались данные с выравниванием на 16 байт и медленно не выровнены начиная с 7 разницы почти нет поэтому если вы целитесь старые процессоры вам нужно выравнивание если целитесь новый то можно без него обойтись как она организуется куча мелкой технической работы хочу для переменных есть а трибьют и лайнер для гтц и декольте x-line для microsoft за динамическая локации есть специальные вызове которые дают а выровненных данные на выходе для эстель а вот а выровненный вектор сделать можно только собственного котором это единственный способ и застряли получить из 3d вектор выровнены 16 байт как локатора делать просто но он позвать дела нет молок например но его придется делать самому как сделать вектор у которого выровнены все элементы ну вот так то есть опять же куча лишние технической работы который придется сделать это практически даже не де-факто рынка просто для всех тех массивов и там вектора с которым мы хотим работать должны так интересно курсом по сути дела тоже самое сделать наши типы данных выровненными то есть начинающих агриппа адреса кратному кратному 16 байт допустим мы все это сделали то есть вот мы сделали и выравнивание и упаковку данных теперь просто на code откуда можно взять идеальный вариант мы взяли какой-то чужой код чужой библиотеку который все нам сделала дальше не обсуждаем скучно второй вариант это мы считаем что компиляторы сделает нам хороший из с верхней африканский код это иллюзия то есть она к сожалению очень большая иллюзия и за время доклады никак не могу и обсудить но по факту простейший случай компиляторы викторину это современные а чуть-чуть шаг вправо шаг влево им уже плохо и приходится докачивать под до состояния когда он может быть fix арестован на этом заначке есть некоторых количество примеров если будут вопросы я их покажу и отвечу вариант номер 2 мы возьмем и напишем этот скот руками в принципе никаких больших проблем с этим с этим нет сейчас я покажу как это делать во всех распространенных компиляторов во всех четырех intel и microsoft gcc сила нг есть одни и те же механизмы которые позволяют писать ассемблерный код как бы как бы на оси значит в левой колонке стандартные типы данных до подчеркиванием 128 это представление соседей и стран нато мили юнин в котором четыре фута или восемь татарский битных хантов и или 4 32 битных янтарный так далее отдельный тип данных для двух дабл of и отдельные два типа данных для алекса 206 бит а теперь справа вот такого типа мамок 1 и 2 подчёркиванием м и дальше имя команды транслируется компилятором в одну а сам в одну команду процессора они есть для всех а команд из известных они все описаны ну и в хелпе microsoft of scam вам настроение и в индуистской документации то есть какой секрет в этом нет калькулятор в этом случае делает всю техническую работу регистр адреса переменных все-все-все вот этот пример вот справа а сам блин ну такой вот компилятор ный слева sim давайте вот что делает что происходит происходит следующее мы берем из это реальный код из реальной программы которую писал не я мне достался по наследству то есть мы берем 4 флота из массива мы этот вектор умножаем на маске с размером 4 на 3 и получаем вектор длинной 3 записанному в тоже место откуда взяли и четвертый компонент 0 вот эта штука на моем рабочем десктопе работает со скоростью двести семьдесят семь миллионов элементов в секунду элемент 16 байт то есть она 4 гигабайт 400 мегабайт в секунду читает и столько же пишет есть вариант справа сверху снизу сверху вниз и почитаем первые три команды и там и матрицу на которые умножаем прочитали в 3 регистр и запомнили а дальше в цикле мы считываем четыре элемента делаем 3 в полярных умножения это встроенная команда процессора начали начинается с s41 она скалярным на жается два вектора длиной 4 результаты перемешиваем и пишем обратно вот этот код чуть больше чем вдвое быстрее я добивался варианта чуть менее компактного который просто на одном ядре на возвращает память 12 1 секунду пишу 12 гбайт секунду читают это уже двор где то быстрее чем сильный компиляция при том что компилятор это викторе завал он не угадал конечно скалярного произведения сделал вручную но в принципе как написано компилятором был неплохой просто тот ход который написал за руками он даже более компактный на мой взгляд он не менее понятной и он куда-то раза быстрее значит что мы можем и того главный секрет в этом месте это как начать потому что это просто это конечно требует большей поддержки по кода потом чем относились и при флюсе но результат ускорением два три четыре раза он того стоит на мой взгляд правильный способ начать он следующий нужно взять второй том intel ского руководство процесс room а по какому нибудь они все примерно одинаковые и и вы прочитать этот скромных 1200 страниц но читать его не надо целиком а нужно делать то есть и второй том это собственно список команд список команд он там немножко всякой ерунды а вы читаете название команды вы читаете десять строчек что она делает дальше там для из известных команд есть носиш там псевдокоде понятное описание что она делает на самом деле и вместо 3 страницы описание команды вы прочитали 23 строчек перевернула страницу паркет следующей команде и следующий момент это уже поняв какие команды вам интересны вы идете в морду и вы берете help a micro авторскому компилятору это называется из с е2 а также 34 макросы интерсекс и там у каждого ведь и у каждого в хелпе есть при мне почти у каждого есть пример который можно внутри тебя в редактор скомпилировать и быстрого тачки понять что делает данная команда реально начать можно за неделю я думаю то есть вряд ли быстрее в принципе есть всякие блогеры я например которое на эту тему немножко пишут дают вам примеры кода и так можно начать в принципе есть альтернативный способ который позволяет эффективно писать параллельные и одновременным векторные программы на их языке похожим на оси я расскажу о двух об одном расскажу о другом по упомяну вот такая игрушка называется из писи intel и спереди программ компания метафора там такая мы пишем программу для одного взгляда для одного индекса вектора то есть а дальше компилятора размножает ее на всю ширину нашего наших векторных команд это open source очень хороший лежит на гитхабе на гитхабе же лежат и бинарники готовые под винды под mac и помогли ну кто же а и давайте посмотрим пример это такой 7 в котором есть новые слова вот пример с в левой колонке это сложение двух векторов вещь абсолютно банальная но интересно на таком простом примере можно понять что и как и uniform это слово означает что данные переменные работает во всех этносов программы есть как это антоним в ринг это в каждом инстансе который работает как бы с элементом вектора есть приватной копию переменной for each for each делает магию а именно он делает как бы из одного цикла на самом деле 21 шагом 4 или 8 и зависит от того из и съели а вы x по индексу а тела меняет векторным аналогом вот для сложения двух векторов получается просто абсолютно идеальный код идеально руками не напишешь а вот пример как здесь сделано много процессор ность многопоточность там есть саппорт библиотека маленькая который делает три вещи запуск трейда обстановку ожидания труда и локацию памяти а нам надо системные можно свою такую написать и дальше появляются слова значит task вид сверху вниз и это компилятору говорится что это будет работать в контексте многозадачности тоска индекс это если кто писал на куда или аппенцеллер это встроенная переменная которая говорит программе в как в каком она месте в картине мира костюм есть много task-ов вот этот номер один обрабатываешь элемент с 1 по 10 таб дома 2 с 11 по 20 и так далее дальше зелененьким дам покрашена как я считаю admir тоска в данном примере абы как я считаю что меня каждый элемент каждый тоска обработает миллион элементов а сколько тоска сколько получится столько получится и ланчи и угловые скобки это опять магия которая запускает много инстансов программы сеть ну собственно стоит поскольку создана сколько доказано task-ов как ни странно но а из писи получаются гораздо более эффективные программы даже в простых случаях чем у виктории дующего компилятора вот давайте пример еще один пример такой это мы то есть у меня есть массив им я над ним делаю некую операцию peшили about какая операция делаю если у меня им меньше чем три тысячных то я делаю подпишу ян умножить на константу если больше чем ский тысячных ту я пишу вот эту сложную формулу со степенью visual studio делает такую штуку со скоростью 137 мегабайт секунду он электризующее он вообще компиляторах но такой на любителя а и довольно медленно интинский компилятор делает код который работает со скоростью примерно 500 мегабайт в секунду а а из 1000 еще быстрее о а из писи есть специальные макросы для правильной работы с условными переходами вовнутрь и векторных операций в чем проблема есть четыре элемента и и если я каждым из них начнут проверять с а ты какого папу ветхих и я пойду побольше или поменьше я верну предыдущего что было понятно это будет медленно что делает имперский компилятор он объявит киев и считается одновременно а дальше в зависимости от того значения в и не он смешивает их правильном в правильной пропорции вот да да 0 первого элемента было меньше для первых 2 было больше но для и тех и для других посчитаем обе ветки ифа и потом смешаем 1 с имбирной команды оаэ спасибо предлагают уже штуку делать еще эффективнее мы можем проверить если мы для всех а элементов вектора у нас выполняется условие мы идем по одной ветки вот это значит б это условия по такой вид киев мы идем значит тесто для всех выполняются будем по одной ветки и фа на всех не выполняет берем подругой и только если у нас случился разнобой мы идем по 3 это позволяет выиграть еще полтора раза что довольно полезно и приятно кроме из печи есть еще пинцет который я рекомендую вам рассмотреть если 2 1 и это выполняет сразу два условия во-первых вы хотите перенести переписать какого-то довольно большую вычислительную вычислительную штуку то есть нет ни одна срочный пример хотя бы строчек 100 или 500 тогда имеет смысл шопен сель им связываться потому что у него есть куча мелких недостатков которые мешают ему работать с мелкими программами и второе если вы собираетесь идти со всем этим кодом на ум на видеокарты то конечно от лимсы это ваша и тренироваться при этом на циpкa а то вполне эффективный компиляторы шопен сель и существуют вполне имеет смысл значит позитив уже как финал всего этого делаешь ускорение обычных подследственных программ в 1015 редко больше раз вполне достижимо и довольно легко просто у придется в денвере в памяти и дальше идти уже некуда и это часто достигают даже на одном ядре простым и домашними ассамбле ными средствами скорее всего риф акции для этого будет нужен то есть старые структуры данных которые проектировались абы как придется проектировать с точки зрения производительности ну если вы в один раз делали то дальше он вам поможет и на видеокарте и на новых версиях процессоров и когда вас фидер прибавился в принципе переход просто на правильные эффективные структуры данных один раз он потом окупятся многократно такая вот такая вот история вопроса да скажи голосом продублирую потому что потому что ну цикла очень простые а правильной жизни в циклах длинных знать какая гадость вот я такой нехороший пример приведу но это вот тренда жизнь столько как функция рефракторы которой нет никаких сил очень оно сложное там сто пятьсот раз insertion sort вызывается что что вызывается when searching сортировка вставкой то есть данных много операций много хочется вот как-то посту казацким способом получить на максимальный выигрыш не сильно напрягаясь как быть алексей петрович ну вот если не параллели цветовой алгоритм то ты уже про на самом деле мертв раз не знаешь об этом сам же то количество данных сам быть расти а если ты не пролезешь одним из 200 лучше обоями у тебя не станет быстрее вызывается функция с одними и теми же данными могу параллельно да то есть вот как бы она независима в этом смысле внутри там работают с какими-то большими объемами данных туда лезть на хочется мотоцикл хочется запара лилит в котором стоит гадкой функции но pimpin казалось бы да то есть мозги у тебя есть два вида проблем один вид проблемки алгоритма ты не пролезет параллельно полностью так жизнь устроена эту разбираешь xml это не пролиться то есть там есть альфа ки-хен ты обычно разбирают от начала к концу ну ничего ты не делаешь ты можешь много xm или разбирать пропала разбирать одновременно многопоточность как правило она твоя структура данных нам алгоритмы не меняется эту тебя экзамену взаимосвязи тесных нет многопоточная вот то что я все начинал папиным пиццы винтовки baby на прикрути и пользуюсь какие проблемы у меня такой же вопрос вот в новых процессорах которые там даже не очень новых вовсе всей все эти все эти векторные струсить и векторные инструкции по работе с данными насколько они еще все насколько они работают с кашами процессора ну врачом найти обычно когда говорят про кэш процессора почему-то брать только провели один но потом последующие теперь еще как-то остаются в стороне вот когда сколько надо еще про прокачку помнить когда занимаешься всеми этими попытками оптимизировать которые иногда кэти перри ничего не приводится одеваемся для такое что скажем они работают так как и любых всегда там есть дополнительные функции эту запись ними крыша бывают очень полезным что просто крышник конечно равна вался такая фишка есть но работают они дают как любые данные но обычно когда ты приписан что-то на стриме ног у тебя получилось по сотне татар на уступа 31 второй все эти глупости со скачками их нету пути тут есть готовую вещь который я щас вам покажу ананасом и принципиально важно вот и если мы посмотрим на табличку вот синее это чтобы нас памятью восьмидесятом году у нас память blast 1 мегабайт в секунду и вытер все 200 с чем-то надо секунд в двенадцатом году у нас 12,8 мегабайт в секунду это просто формальный за доллар рассчитана там канальный реально быстрее это в тысячу раз быстрее чем 22 года молод и вытерся не в тыщу раз уменьшилась а только все исправить только 60 на 1 а что происходит из памяти мы пришли подписчики на работу на работу с диска мы должны работать на вики последовательно вот не занимается указать время вот прыжка прыжками и так далее а делать последовательные 1 2 3 4 запада так вот этот паттерн быстрый а паттерн заключался он медленный то же самое гифка у нас примерно в 500 раз ворон рифу диска у нас в какое-то невероятное количество раз вырос объем деятельностью только в 10 раз с гифками работать как с как мы работали с ленты 20 лет назад всякие по случайных сиков а вот вам вот именно опаздывает на чтение все и как только мешает работать последовательно вас проблема с кашами нету у вас работает при фея чехарда верно автоматически работать можете сами prefetch а если вы начинаете работать с бинарными деревьями размером гигабайт ну а ты так все плохо дайте мне микрофон на надо жать на кнопку говорят все заготовки спасибо за доклад меня интересует бан реализацию open библиотека который делать правильно вычисления вот как они идет проверить свои вычисления во-первых держит ли они полпредов то есть когда у нас произошел пошел одна задача у нас запустить потоки держится ли они дальше на следующую задачу наркоз как они работают в памяти то есть учитывают 2 а не то что маленький ли у меня массив который помещается в один в два в три либо же это гигабайтный массив который и процесса состоит на обращение к памяти если так то учитывайте они модель памяти сэм тишина она либо numa можно ли нам запускать второй поток на этом же ядре чтобы не щипаться полность канал к памяти два потока работает то есть насколько они интеллектуально сколько они могут работать потоками и памяти хорошо насчет потоков насколько я понимаю варианты бывают разные вот насколько я для себя уяснил я исходников ты смотрел microsoft и приходит с 8 версию десятую они перешли именно та запуску налогов 3d к полу трендов и то же самое случилось у интела в районе 2011 компилятора это местами хорошо местами плохо потому что там нами в мае небольшой спину который а в каких случаях вас очень много жира и процессора это по трудам но теперь по памяти смотрите во первых когда вы обрабатываете количество памяти сравнимые с кэшем вам не нужно много потоков и пока запустите строят пока синхронизируете все же убежала имеет смысл обрабатывать данные которые ну хотя бы десятки ну хотя бы мегабайты а значит что происходит там пса numa опять реализации от разные то что я видел на линуксе ведет себя с виду разумная получит рады там хотя бы между процессорами не скачет их affinity жестко прибивается в реальной жизни с affinity на больших машинах на которых реально много процессоров не на десктопе софии приходится разбираться дополнительно было бывает и такое то есть вот это полный автомат естественно невозможно остается надеяться что все будет хорошо но вы 0 целуете данные и вам ядро linux на и смотрит на кого процесс и дает данные как бы в вашей памяти корабль только делает когда вас локатор вот он был в одной поточной программе а потом дайте данные по 3 браться за в другом потоке но дат в этом смысле могут быть небольшие несчастья но опять же в ситуации когда вы ограничены по памяти poбин верху вам не надо много много потоков запускать вы из двух потоков на сыщики памяти то есть вам нужно по потоку на просто даже не наигранно процесса правильно проблема побегу я понимаю там много мелких проблем возникает когда вы начинаете реально использовать многопоточность особенно серверах ведь еще пыль другие процессы ну в рабочем порядке решается наган учить чудес-то не бывает все меня оставим этот самый перволь и я готов кунара хочет пообщаться"
}