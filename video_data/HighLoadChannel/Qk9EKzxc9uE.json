{
  "video_id": "Qk9EKzxc9uE",
  "channel": "HighLoadChannel",
  "title": "Архитектура и алгоритмы для индексации всей музыки ВКонтакте / Алексей Акулович (ВКонтакте)",
  "views": 4251,
  "duration": 1995,
  "published": "2017-04-22T14:48:16-07:00",
  "text": "Всем привет Меня слышно хорошо всё да так Ну меня зовут Лёша там написано собственно я занимаюсь разработкой ВКонтакте на задачах связанных с мультимедиа кэндо там и смежных темах более-менее А в качестве маленького в топика Ну времени осталось мало на доклад кто возникнут вопросы у нас есть тендик там можно Вопросы задать и ещё мы сделали в слаке канал тоже можно зайти и описать вопросы постараемся ответить Ну оба дня и после Итак поговорим мы собственно о аудио записях вот Кто думает что в ВК есть Ну минов 50 допустим Ну не меньше а вот хотя бы 50 есть кто-нибудь нет Так а допустим 100 млн А 200 что загруженных вообще так а допустим 500 400 примерно миллионов это то что именно люди именно залили физически загруженные файлы которые лежат на дисках Это примерно 4 пита байта выходит ну плюс-минус то есть ели считать такими Ну двухбайтным дисками это такая пирамидка 2000 кирпичиков и ещё по одному кирпичику загружается в день примерно то есть вот такие вот большие маленький объём и есть Что послушать Когда настроение есть что с этим можно сделать что можно было раньше сделать на на том уровне который поддерживался это найти по названию то есть человек при загрузке указывает теги файлики мы их парсим загружаем отдельно по ним можно поискать но при этом мы получаем дубли в поиске потому что разные загруженные файлы там если они отличаются у них написание похожее мы эти каждое отдельное написание видим в выдаче а плюс несоответствие грузил один Файлик в тегах указал что-нибудь другое и вот тоже сталкивались с этим довольно неприятная ситуация а и в общем-то всё на этом заканчивается То есть можно найти и послушать всё не очень а что бы хотелось когда вот встала задача во-первых хотелось бы фильтровать дубли то есть не показывать одно и то же трек ка физический при наличии нескольких качеств наверное интереснее показать более качественный там битрейт получше там длительность побольше может быть Ну помоему это приятная вещь если некоторые файл загружен скажем одно указанный исполнитель Год В другом есть текст в третьем обложка хотелось бы в одно место и чтобы у всех файлов была вся э максимальная Мета информация выводилась Ну и были некоторые вопросы связаны с легализации чтобы хотелось выдать максимум музыки но как-то чтобы никому не было больно и обидно самое важное что должно было быть обрабатываться на основе восприятия человеком на слух ни какой там хэши от файла хш от сырых аудиоданных Нет это именно как человек воспринимает пес считает что эти два трека одинаковые Ну по его мнению на слух Либо они разные там почему-то это бы важный момент который был с самого начала постановки задач При этом так как мы хотим использовать разные качества Как одну сущность то есть Нужны требования было устойчиво перекодирования смена битрейта там пережатие кода потери идут вот дол устойчиво при этом всякие вещи как добавление и убирание всякой тишины мусора кусочков начало и конец песни оно должно быть всё равно обрабатываться корректно похож на наш Эталон Ну да он Чуть поменьше похож он там каким-то дополнительным мусором Но это он же мы не стали бы такие требования таком уровне гото велосипед чтото сочинять посмотрели какие есть решения на рынке доступные для встраивания в нашу инфраструктуру нашли одно которое нам в принципе подходило требующиеся нам он делало лишь отпечаток файла который Потом оно должно было отсылать на собственные сервера там что-то делать а мы собственно сделали свой поиск по эти Потому что не было реализации серверной части а данное решение Ну как-то работало я не буду его озвучивать а потому что начались с ним проблемы уже при тестах когда мы сами составили руками небольшую тестовую выборку и вот некоторые проблемы лись во-первых Это пример звуковой волны То есть это конец песни в начале музыканты доиграли песня постепенно стихла тишина то есть такая хорошая качественная студийная запись а та же самая песня исполненные на концерте выглядит примерно вот так а музыканты доиграли фоновый фоновый шум стихли шум там сист и прочее на слух эти песни очень похожи Ну то есть ну там за отключением какого-то фонового Но вот аудиоданные там довольно разные и та система которой мы пользуюсь Она не очень хорошо искала по таким песням а из подобных проблем возникает ещё радио версии когда играет песня по радио а потом ла-ла-ла там какая-то да песня А потом ставка там не знаю Руссе радио там какая-нибудь да там и снова песня играет то есть в целом песня Вся та же самая то несколько этих рекламах коротких вставок они портят собственно трек и он становится какими-то с разрывами а в качестве сложный варианта разрыва - это вариант подкаста когда на фоне играет музыка ли что-то говорят а хотелось бы детек собственно фоновую музыку находить её и мачит а другой вариант Не пытайтесь найти разницу она есть это один и тот же трек Но к нижней версии добавлено маленькое Эхо на слух его практически незаметно визуально его тоже практически незаметно но то решение которое мы использовали сбивалось и не находило вообще не похожие совершенно разные Я не знаю что вы мне тут подсовывает третий вариант - это склейки и каверы А когда идёт несколько песен склеенных либо целиком либо маленькие фрагменти там есть машап это там трёх-пяти сеен дный фрагмент их там 30 за песню Ну то есть найти маленький пятисекундный фрагмент там в пятиминутный песне Ну это решение которое мы использовали вообще не могло То есть как мы не пробовали Ну и в качестве такого дополнительного пожелания которое нам не требовалось первоначально Очень бы хотелось учесть при разработке это поиск шумного фрагмента Ну вот это логотип Шазама Кто знает Примерно вот такой функционал нам бы хотелось сделать к этому приступали ничего из перечислен решения которые мы выбрали сделать нам не смогло то есть как мы не пробовали там корли ну в общем нет поэтому мы решили как-то сделать попробовать сделать своё решение которое могло бы нам помочь с этим но какого-либо опыта в команде У нас не было с этой задачей то есть мы на уровне там Универа обще сведения были но всё ничего более точного А как мы себе представляли эту задачу в момент когда мы к ней приступили что у нас есть некие файлы мы бы хотели из них достать данны торы данные что-то с ними сделать получить какие-то данные и потом на основе эти данных поискать это был пример как Мы работали с той библиотекой хотели наверно что-то тоже самое надо сделать примерно но сами Давайте по шагам пройдёмся собственно вот что надо сделать во-первых мы берём фай на вход и нам нужно получить аудиоданные весь код этой системы у нас работает ногой и старался делать про него поменьше Ну бы это не тема доклада но кадры слайды где есть специфика для Go отмечена собственно феро внизу кому не интересно можете пропускать как бы вот Итак а в общем мы взяли стандартную библиотеку lpm это обычная Ну нативная сиш ная так можно нать библиотечка а на ней был впер Наго который собственно по сути говоря подавал на вход этой библиотеки файл кусочками она на выдавала аудио фреймы Ну всё то есть совсем простая вещь потом мы переделали и заменили вместо сиш вызовов посто вызываемых в Пек внешним эком и через Пай мы ему файл он нам Рав данный всё то есть как бы и избавились от вызовов сиш ней библиотеки Ну практически бесплатно А как бы мы не делали там через библиотеку или через Пек мы на выходе получали массив коэффициентов построили график получили вот примерно такую штуку поняли идём верным путём это что-то похожее на звуковую волну Видимо всё у нас хорошо Итак мы получили аудиоданные то есть огромные огромный массивы вот этих коэффициентов А что с ними делать дальше как Мы помним Ну с Универа звуковая волна - это в общем-то комбинация Ну бесконечное количество читы синусоид то есть каких чито сигналов и нам бы хотелось для восстановления уникальности аудиозаписи получить данные по наиболее слышим и наиболее заметным на слух синусоида То есть их коэффициенты по сути а для восстановления из звуковой волны исходного синусоида используется преобразование фуе Я про не рассказывать не буду как бы это ну чтобы никто не уснул неинтересная вещь Это единственный слайд в фре больше не будет всё а единственное важное из этого в том что если мы возьмём оконную функцию пробежимся по нашей звуковой волне то на выходе мы получим график Типа такого Это аудиофайл созданный генератором частоты то есть некое программное решение генерить файл 1 кгц 2 4 8 и так далее там секундные интервалы и мы получаем что поси X у нас врем поси Y - частота яркость пикселей - это слышимость этой частоты в этот момент времени и мы видим такие характерные ступеньки соответствующие собственно генератору как он сгенерировал часто так мы получили в случае генерации не сгенерированного специально ступенчатого графика а звукового файла созданного с учётом того что человек который скачал файл захочет открыть его в пиктограмму А некоторые авторы засовывают собственные песни вот всякие эти Пасха например котино для спра это название пес исполнитель хочет посмотреть есть котики есть там глаза там руки это видимо исполнительница Ну вот это зарание сне на слух этот фрагмент выглядит как ужасные искажения какие-то шумы там вообще не песня но красиво выглядит в пекто в случае же обычного трека который не был заранее создан вот с целью повеселить своих этих фанатов фрагмент песни Примерно вот так вот непонятный график опять же яркость точки - это собственно слышимость частоты в этот момент времени то есть трек начинается слева идёт вправо более-менее тихие частоты низкий а потом в конце начинаются такие более-менее какая-то активная звуковая часть в таком формате когда мы посчитали сколько это объём займёт у нас получилось что из че пи файлов мы получим 10 пи Таких данных это было не очень удобно для поиска по такому обму И следующий шаг уменьшить обм этих данных сохранить максимально сть но предоставить Като обм по которому можно хотя быто разумно искать вот на фрагмент песни который был В чём смысл заключается человек воспринимает наиболее громкие звуки то есть частоты допустим если с кем-то разговариваете спокойным Тоне Аям взрыв хлопок то вы на это время не слышите собеседника он заглушает его речь собственно более громким звуком на этом основан собственно и алгоритм отва находим локальные максимумы то есть громкость частот в массиве отфильтровывает только вот наиболее яркие точки Ну на таком варианте то есть сначала бежим слева направо пробега если есть точка идущая перед ней была более тихая то мы её выкидываем потом бежим в обратную сторону и фильтром в обратную сторону после этого Получается примерно Вот так это выделено более жирным это Точки которые остались хорошо видно что в принципе то что было ярким на этом графике осталось Ну выделилось какие-то характерные особенности остались объём данных уменьшается в 200 раз коэффициентами и в принципе такому объёму уже можно как-то Ну разумно искать и мы убрали кучу всякого мусора фонового шума не интересного для нас дальше так как у нас есть ка точка Это собственно частота и время когда оно произошло то мы объединяем их собственно в пару в кортежи и сохраняем просто массив чисел всё то есть на этом этапе Мы забываем про громкость звука мы сохраняем только координаты точки всё сохраняем массив мы спему не используем Окей мы получили некий отпечаток то есть массив чисел и теперь как-то нужно научиться их сравнивать на есть две песни почитали по ним два опечатка Что делать дальше что было использовано вот Представьте что у нас есть два массива чисел Ну то есть два отпечатка мы берём и двигаем Один массив относительно другого перебирая все возможные смещение и находим то смещение при котором у нас будет максимальное количество совпадений частот Джи Масси и читаем как совпадение если у нас два трека не имеющих какой-то общей звуковой часть совершенно Независимый треки то мы получим вот на распределение сдвигов то есть от минус п секунды до СТ секунды Ну да кое-где были совпадения каки там или коллизия или ка там общая там нота там инструмент Ну да есть что-то но какой-то там зависимости незаметно в случае же нас есть два одинаковых трека ики с общей частью то мы получаем Примерно вот такую картину и видим что вот одиннад по тринадцатую секунду сдвига У нас у обоих треков есть общий фрагмент и не просто он есть а сколько совпало значений в этот момент времени на основе этого уже можно как-то посчитать там похожесть треков вот таким-то сдвигом с такой-то вероятностью Они похожи А а вот когда мы попробовали эту вещь собственно начали тестить а всё описано обще доступно Кто хочет побаловаться потестить вот всё что было сказано там получить эти коэффициенты похожести можете попробовать Э поэкспериментировать А ну вот посчитали у нас получилось примерно 20 ТБ отпечатков это вот собственно эти массивский чисел поджатые а сонно два вопроса Где это хранить и как нам их собственно по ним искать перебирать каждый новый по всем 20 ТБМ чтобы проверить на что он похож это не очень хорошее решение и не особо масштабируемой Итак А как выглядит архитектура решения которое использовалась с этим генератором отпечатков У нас есть какое-то количество плод серверов это Машина на которой можно залить файлы сейчас Либо они были залиты ранее то есть уже какие-то забитые машины на них на всех запускается движок который занимается генерацией то что обсудили читает файл там ну и прочее до генерации А есть группа серверов отпечатков они хранят сами отпечатки физически это обычные KV неважно какой для нас просто дишни трека массив чисел всё то есть не более того и на этих же машинах работает движок индексации которой Мы ещё поговорим Ну соответственно код который работает с одами и с серверами генерации похожи СВТ подобные операции Итак генерации работает на каждом сервере он параллели лишь на уровне обработки отдельных треков то есть заливаются два трека они об параллельно но фрагменты одного Т никак не разделяются соответственно одна песня обрабатывается 2-4 секунды от стадии прочита 3 до Получи массив отэ чав бывает аудиокниги ну оно Лине может бы полчаса считаться как бы нам это приемлемо Ну если будет нужно переделаем движок индексации гораздо более интересная вещь То есть как мы пот 20 рабам искать собственно более-менее быстро да в реальном времени хочется там не используется не полный индекс хранить 20 ТБМ это жа данные там 30 или 40 ТБ получается А в памяти очень прикольно этот движок хранит лиш небольшой компактный Примерно вот до 100б ВМ его смыт из отпечатка те частоты которы отча наиболее часто по суто основную мелодию и основной тон сохра только его в индекс Да это приводит искажениям ложным срабатывания или не найде нужно подстраиваться как-то писать код чтобы он вс-таки старался эту это ограничение как-то обойти нивелировать Ну в принципе-то работает индекс Где в качестве ключей - это значение отпечатка то есть частоты А в качестве элементов То есть это собственно списков это те треки в которых эта частота есть Поэтому Когда нужно найти какой-нибудь новый трек на который он похож мы берём большой отпечаток по нему строим маленький индекс прорезанные поэтому прорезаны получаем новые нужные линии хэша и просто жим эти линии выбираем те которые чаще всего нашли более часты по ним сделали полное сравнение которое со сдвигами массивов и получили какой-то топ похожих треков То есть это вот это работает на вот каждый запрос поиска А когда это дело было написано первый вариант запустили начали вливать в него Данные из пощи отпечатков где-то пару дней это проработал и мыли прикинуть сколько времени займёт с текущей скоростью в Лике тот там эти вот терабайт данных в него и у нас получилось примерно год а мы поняли что всё очень очень плохо то есть это было совершенно неприемлемо для нас а и как-то ну несколько собственно пунктов сейчас будет про профилирование не профилирование но оптимизацию го такие очевидные вещи более-менее во-первых использование сингла То есть у нас далеко не везде он использовался были функции которые лоцирование Здравствуй сборщик А после переписывания на си стандартный собственно этот пакет сократили до 10 месяцев это было приятно но было слишком медленно это вот нет 10 меся не хотим вторая ве вот была обратны индекс я говорил что мы используем слияние массивов То есть он бежит собственно операция выбирает линий и бегает по ним по всем по элемент получается сложность собственно количество линий длину максимальной линии В общем случае очень спе вот отлично вообще не буду рассказывать это просто структура когда мы добавляем элементы в любом порядке забрать можем минималь максималь добавленных ВМ слу используется минималь элемент что на элементы здесь отсортированы по возрастани авиу было Поня добавляем нужные лини в выбираем минимальный элемент это у вра а следующий шаг контейнер хип реализуется на интерфейсах собственно получается Ну так в терминологии jav Unboxing Ну назовём это так да мы попробовали переписать стандартный контейнер скопировали код и заменили интерфейсы на наш конкретный тип элементов рисков и получили экономи ещ примерно в месяц то есть вот примерно Ах в Go 1.6 на работу вот этого пакета получился и этого было на мало собственно дали нашим сикам реализацию этого типа они Т не оптимально по Да чек у нас сидит в зале Если не ошибаюсь который это предложил Вот и они предложили свой вариант который по их мнению это был более оптимален мы переписали его как бы на год попробовали получили ускорение до 3 месяцев Казалось бы классно замечательно но проблема в том что это изменение изменило публичное а этого пакета А так как в го обратная совместимость первой версии Ну требуется полная то просто отправить порек в Go с это пось а делать контейнер 2 и знаю это осталось на уровне пакета это есть в том кому интересно реализация этой штуки ну и в качестве такого небольшого плюса Что за время развития движка и получили немножко ускорение приятно полезно 17 то есть мы уже запустили не просто какой-то тестовый выб который мы сами составляли а именно вот на всё что люди к нам загружают весь объём аудиозаписи со всеми их безумными вариантами и получились упсы первый Упс изменённая скорость а Нижний трек - Это тот же самый трек но ускоренно процентов на пять на слух это практически не воспринимается если не вслушиваться заранее не искать то есть ну непонятно Но для системы которая основаны на матчинг одинаковых смещений шеи в разные моменты времени как раз разная скорость меток времени в двух массивов ломала систему ломала работу что пришлось делать а есть алгоритм наибольше общей подпоследовательность которая ищет одинаковые значения идущие последовательно в двух массивах не подряд а последова если в обоих массивах есть элемент А и В обоих есть B Пусть там не сразу за ним значит AB - это общая под последованность соответственно А вот левые два графика - это два трека красные точки на них - это собственно подпоследовательность Мы выбираем только их в обоих массивах а затем попарно первые и последние элементы двух треков мы сравниваем считаем коэффициенты А насколько была деформация все коэффициенты всех пар последованности мы кластеризованный вещи то мы пробуем ещё раз сравнить два трека при условии что второй трек у нас как будто бы визуально там растянут или Ну сжат на этот коэффициент это очень сильно помогло это количество Чили быто очень низкие похожести стали сразу очень похожими замечательно было Другой проблема о которой я уже немножко говорил собственно склейки То есть у нас есть либо склейки одинаковых тре вырезки вставки версии официаль либо неофициальные песен на разных языках когда вокал разный язык там какие-то вставки там приго Яри св довольно забавны Н В случае к нам в зале это по-моему 60 или 80 вариантов этой песни Где вся разница только имя поздравляет раза за песню там это на одд секунды вставка другого имени читать ли это всё одной песней казалось там крошечные изменение либо Это разные песни вот непонятно и самое наверно забавное для меня это мы называем это у себя рэп Рем школьников то есть некий там условный Вася взял какую-нибудь популярную песню очень популярную от неё микс и попытался на неё зачитать собственное гениальное произведение после чего залил его ВКонтакте так как обычно все эти минусы популярных песен и так загружаются к нам в оригинале в большом количестве А тут ещё вот эти вот изменённые минусы это получается после кластеризации похожи отпечатков кластеры там на тысячи тысяч похожих они сливаются все в одну Где в корне является собствен исходный трек то есть челок ИТ зна Каю услов исполнительницу находит п Это не то что хочет человек скорее всего как с этим вот можно бороться те ситуации когда у нас фрагменты одинаковые фрагменты разные Я раньше картинка была Где мы искали оптимальное смещение количество суммарно со всего трека совпадений Давайте посчитаем не все совпадения при этом смещении А сколько было совпадений на каждую секунду трека Левы график е у нафа аудиофайла и в нимен в данном случае фрагмент с шестой по че секунды то есть мы посчитали сколько совпадений есть всё класс то есть один трек содержит фрагмент другого И мы знаем интервал и сколько А в случае же если у нас есть какое-то исполнение изменённое какие-то фрагменты похожи не похоже типа ва произведение это правый вариант то мы видим что у нас есть там где он молчит то похожесть высокая по что музка совпадает вот собственно пики вверх тамде начинает зачитывать похожесть ли падает либо вообще но либо нет интервалы похожести величину похожести и можем из движка собственного поиска выдать наружу эти интервалы и коэффициенты А там уже Като бизне скажет тот же самый трек не тот же самый трек это уже за пределами компетенции движка есть простое решение работает довольно быстро но позволило решить эту проблему не надо читать этот слайд Лио так скажем оно было очень заинтересовано В качестве работы этого поиска оно в общем-то взяло какой-то свой трек выпа над ним вот эти вот всякие варианты издевательств искажений попробовала потом прислала нам Проверьте вашу систему Сможет ли надо по ней найти все эти вещи были найдены это было приятно то есть система выдержала Ну вот хотя бы эти варианты Ну с разной Степе похожести коне есть жестокие издевательства на треком но сработало это было приятно В общем всё наверное на этом то есть система сейчас активно развивается она была запущена довольно давно пилки доработки новые проблемы которые мы стараемся решить чтобы это работало Ну хорошо и качественно по мнению человека а не по мнению машины вот Ну возможно было интересно первый доклад с утра Всё спасибо вопросы Здравствуйте спасибо за доклад Вопрос такой интересный насчёт склеек А часто бывает ВКонтакте Так что один альбом сливают в одну аудиозапись и вот э когда много подряд они эти Ну разных записей идёт на что он будет похож скажем какой какой аудиозапись он отнесётся если будет склейка песен это будет не будет склеиваться просто это будет отдельная какая-то Ну будет отдельные фрагменты каждой пес они будут общие какие-то большие фрагменты там по несколько минут которые полностью например включают одну и ту же песню м В смысле одну песню неско минут каждой песни песня ри ти ма вки как сделаем нема Ну он найдёт разные фрагменты вопрос как отсе возможно будет находить интервал нужной песни для поиска каждый раз Типа она есть в этом фрагменте Здравствуйте СБО за Как вы масштабированных Ну полный индекс или короткий маленький Ну лучше про все рассказать который полный там эти терабайты весит Да это обычный движок который собственно запущен там в большом количестве Просто он он просто ходит на диске н кэш какой-то в памяти есть а движок который хранит в памяти ма индекс которы собственно основная руску принимает это хэш мап Да обычная но просто а при чтении он использует RV Log собственно на чтение они все паралельны читают при записи лочи только нужные линии которые меняются поэтому когда какой-нибудь трек добавляется и удаляется запросы на поиск по другим линиям не блокируется выполняются параллельно вот так Так ребят у меня это больше тоже вопрос про общую структуру Я насколько понял это всё на одном сервере работает поиск всех треков или это было шардирование немножко больше рассказать тогда э сейчас секундочку вот э там просто визуально это группа серверов все триблок - это группы а а принцип шардирование какой типа как А по ключу по дишни у трека А ну в смысле Всё равно нужно делать поиск по всем машинкам там не а доступ к серверам во-первых можно отправить запрос на каждый руками Да а плюс есть прокси который просто отправит на нужный или смерт ответ о всех это как не знаю как в монге есть вот типа Отправь на все собери отправить дальше АС сколько по объёмом их Ну машина которые Сколько шардов получается на ваш объём данных просто 32 по шарда 32 шарда на 200б Угу спасибо и ещё маленький вопросик Смотри у меня есть ощущение что когда у тебя есть много-много одинаковых треков они это попадают в один создают большую кишку Да в твоём инвертном индексе и ты попадаешь очень часто на то что много одинаковых треков по ним нужно делать в смысле линии которые очень большие Да линии очень большие ко выглядит как мусор скорее всего Като общий шуб которы есть почти везде то есть небольшой процент самых длинных линий не используется в поиске считается какие-то неле Просто после создания индекса пересчитывается постоянно всё время он же всё время обновляется и но пес тся постоянно поэтому А какого-то процессинга нет чтобы например выкинуть из поиска те мелодии которые никому явно не интересны Ну а если она станет интересно надо пере индексировать что ли Всё ните вообще всё без спасибо спасибо за доклад Подскажите удалось вам сделать так чтобы работало Сха так оно работает всё что было описано в начале оно было собственно сделано Не ну как бы от сил э зависит несколько секунд будет уже другой Т получается Если многократно вобще с этим мать нельзя е такой вопрос а если два трека название одинаковые а исполнение разное типа камера или что нет Ошиблись с названием А эта штука не смотрит на название ОБЖ ничего нет Здравствуйте спасибо за доклад используете ли вы ваш алгоритм для ну проблем с авторскими правами нахождения песен соответственно там была легализация да Ну например вот вы сказали что вы решили проблему ускорения и замедления записей буквально недавно встречал альбом который просто ускор и не удалён ну либо не смачило либо что-то ещё опять же как бы если он ускорен там процентов на 20 мы не будем это мать нет ну тоже незаметно для слуха Но заметно по тайми В итоге а точно нуже бы забанен быть да остальные варианты забанены бы значит ошибочка Понятно так не скажу я не внг Добрый день Можно узнать почему го на нём очень быстро разрабатывать потом мне нужно переписывать на другой язык и скорость вполне классна c+ вариан работал э ну рассматривали его но смысла особо нету как бы всё понял спасибо Просто пока вопроса нет Там есть не так много вещей которые себе аут в основном Это работа с сетью и какие-то многопоточные взаимодействия то есть писать на сину можно там вряд ли будет какой-то очень значительный плюс от этого а врем Работки поддержки больше ну смысл Здраствуйте Спасибо большое доклад А можно вернуться на слайд про сжатие вот где происходило сжатие трека Здесь был вопрос такой вот да вот он самый Ани пробовали какие-то Data Science алгоритмы pca и так далее ну сжати просто максимум И всё работает и работает Быстро то есть прижаться по массивам Здравствуйте а скажите пожалуйста вы обрабатывали когда мелодия трансни то есть на тон выше ниже не счи нет то есть это будет уже другие частоты совсем другого как бы банда нетки гоже другая песня Но это как-то ну уже другой тон это уже слишком на цель была похожа по звучанию и с тем же текстом А тоже Пес в другом качестве там склеен измен перекодировано О спасибо сва там я думаю можно будет позадавать какие-то вопросы рекомендую не расходиться следующий доклад будет на наверное схожую немного тематику про поиск совпадений поэтому"
}