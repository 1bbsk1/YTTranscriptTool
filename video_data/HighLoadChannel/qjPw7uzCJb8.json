{
  "video_id": "qjPw7uzCJb8",
  "channel": "HighLoadChannel",
  "title": "Переход с Objective-C на Swift — все ли так просто? / Олег Алексеенко (SuperJob)",
  "views": 1326,
  "duration": 2723,
  "published": "2018-01-16T13:18:47-08:00",
  "text": "Меня зовут Олег Алексенко. Я руководитель мобильной разработки в компании SuperJob. Сегодня постараюсь вам какие-то интересные вещи рассказать, но я не знаю, что интереснее рассказать после вчерашней конференции. Надеюсь, все уже многие узнали о всех новинках и пловах. А кратко о нас. Кто мы такие? Мы компания SuperJob. Это сервис онлайн-рекрут. А на на портале нашем вы можете создавать резюме и создавать вакансии, нанимать людей, если нужно, либо же искать работу. А это порядка 1 млн пользователей в сутки посещают нашу наш сервис. А 20 млн резюме опубликовано у нас на портале и 1 млн приглашений в в сутки а получают наши соискатели на различные приглашения, подписки. и на вакансии такого рода. А что касается более интересного для данной презентации, что касается наших приложений? У нас есть три приложения. Первое - это приложение Суперджба для соискателей, где вы можете создавать резюме, редактировать его и откликаться на вакансии. Второе приложение - это приложение для работодателей. приложение, там где вы можете создавать вакансии, искать себе сотрудников. И третье приложение - это приложение для тех людей, которые планируют отпуск, длячаров, чтоб чтобы знать там, работаете 9 мая вы или не работаете. А общая база всех приложений на всех мобильных платформах порядка 500.000 пользователей ежедневно. И мы поэтому активно вкладываемся в развитие приложений и поддерживаем их в актуальном состоянии. Сегодня мы поговорим про то, как наша команда переходила от язык языка ObjectiveC на Swift, какие проблемы были по пути перехода, какие нюансы технические вскрывались и как мы их решили. Возможно, кому-то это будет актуально и какие-то практики каждый найдёт для себя. Первый вопрос: зачем мы решили переходить на Swift? Казалось бы, такая простая формулировка, более предсказуемый код, но что это значит? Это то, что мы хотели к себе в проект заиспользовать такие свифтовые фичи, как неизменяемость коллекций, там массивов, а, словарей новых свифтовых там свойств, LED, а переменные нам были очень интересны. также были прямо жизненно необходимы optionals, потому что есть много моделей, где очень на это много логики. И конкретно как пример, где это нам нужно было, это вот есть модель фильтра такая, где там разные параметры, их порядка более двадцати. Для это модель должна уметь сравниваться, реализовывать метод изву. Эта модель может изменяться из различных мест, там с этого экрана, с предыдущего там подписки. И вся эта логика, она написанная на ObjectiveC, она большая, непрозрачная. И часто бывали проблемы в бизнес-логике, что кто-то добыл проперти, добавил новую пропертию в модель, ну, забыл это добавить в изquл, и там стрельнуло, задублировалось что-то. Либо же кто-то в каком-то месте изменил, но забыл добавить там копи и тоже стрельнуло. Приехал не тот фильтр, который нужен. Поэтому вот как пример, для чего это нам нужно было. Ещё такие вещи нам были интересны, как протокол oriented programming, чтобы его использовать, попробовать, может быть, это будет уменьшит кодовую базу и дубликаты. И, ну, самое такое прикольное - это длина метода в плане то, что каждый SWIFT покороче, чем старую добрыю ObjectiveC. Что касается кода, наверное, таких больше моментов, которые нам драйвили перейти не было. Были другие моменты за такие, как заблаговременное мигрирование скtiv библиотек. А потому что я обектив все активно развиваются, выходят новые библиотеки, там UI компоненты либо ещё что-то. И в основном это свифтовые реализации. И если вдруг ты хочешь это использовать в objective C, это довольно трудно. Также старые objective C библиотеки постепенно теряют свою поддержку. К примеру, мы активно использовали Reactти Коко, там старой версии 2.5, и у неё даже на Гитхабе уже приписка, что это Zus Legacy, типа, чуваки, работайте дальше, как хотите. Ну, мы продолжали на ней писать, и сейчас ещё остатки есть, но это был была причина, по которой хотелось уйти. И третий, более организационный момент - это поиз новых сотрудников. Мы в прошлом году активно искали людей к себе в команду, и все собеседуемые, которые к нам приходили, и большинство людей хотело писать на SWIF, независимо от того, это там молодой разработчик, для него Swift первый язык, либо уже там со стажем и хочет всё равно переходить на Swift, потому что более новый модный язык. Казалось бы, что сложного подключить objective C bridging header, создать Swift файловые Свифтовые файлы и, в общем, начать писать. И проблем, в принципе, не должно быть. Но мы пришли к этой идее с перехода с Objective C на Swift к бизнесу поговорить, окей, не окей. И мы получили от них фидбекса, что они хотят постоянну доставку новых фич. Они хотят тот же самый уровень крашфри юзеров и разработку фич на той же самой скорости, как она сейчас, чтобы быть там конкурентноспособным. Казалось бы, вещи, которые простые и понятные, и для нас должно было быть для разработчиков. Но эти вещи нас заставили пересмотреть наш подход, как мы будем мигрировать. А и мы начали смотреть в сторону того, чтобы эмигрировать постепенно приложение. То есть у нас ээ приложение имеет долгую историю, порядка там соискательское уже разрабатывается 5 лет. И там есть разные архитектурные паттерны, которые встречаются, разные модели, кодстайл и всё такое, потому что там начинает MVC, то, которое мы активно переписывали какое-то время, и потом там кончая Viper, подобная архитектура используется. Поэтому всё это учитывая и хотелось поменьше наступить на грабли, которые могут возникнуть при написании Свифта, чтобы те люди, которые приходят и начинают писать на Свифте, они уже там через год имелся устоявшийся паттерн и чтобы новые приходящие сразу же понимали, что как происходит и что как нужно делать. для Свифта. Также хотелось там Swift ориентированную архитектуру, тестируемость покрыть изначально тот Swift код, который мы будем писать, и код стайл, там работа с ресурсами, чтобы она была понятна и прозрачна. Поэтому вместе собрались командой сели, подумали и решили для каждого кейса найти про решение. Я сейчас буду объяснять по каждому кейсу. Кейс и потом решение. Кейс и решение. и потом всё это обобщу. Первая проблема - это проблемати, которую мы открыли, когда открыли когда открыли проект и поняли, что у нас мало меток null ability. Но как же понять, насколько это всё плохо? Накидали какой-то простой скриптец шеловый, там где берёт regкс, помн просто ищет метки ability. Мы вообще искали просто nssну. И в итоге мы получили, что этих меток у нас порядка только 5% на проекте. Когда мы начали изначально выпробовали Swift, мы сразу же получали вот такие замечательные ошибки, типа: \"Привет, я здесь как бы optional, но на самом деле я из Свифта\". Поэтому думали, как с этим бороться, какой-то золотой пулей не нашли на это всё. Мы внутри команды договорились о том, что в течение 3х месяцев каждая новая фича, а, которая разрабатывается разработчикам, обязательно должна иметь метки, хоть это новые добавленные файлы, или же это файлы, которые просто изменены были. И для этого накидали там простой скриптец, чтобы на пулреквесте такие фичи не вмерживались в мастер, если разработчик забыл добавить что-то. И там порядка через 3 месяца у нас был показатель в районе 60%. Это тот порог, на котором мы начали внедрять Swift. И там сейчас этот порог порядка 80%, но мы уже активно до 100% не добиваем, потому что там уже тот код, который остался, он уже в Свифте не используется, и мы его просто пришли и удалили, написали новый, если нужно. Второй параметр, более такой же технический, который мы нашли - это проблема со сторонними библиотеками. Для сторонних зависимостей мы использовали CoPods. А Cocopods у нас были подключены там достаточно нормальное количество разных библиотек. И мы для себя выделили две как бы два класса библиотек. Первые - это которые легко заменить. Мы взяли их заменили там, к примеру, masson на Snapkit, там I Networking на Alamafire и как бы проблем никаких нет. Там оп галочку поставил и всё завелось в целом. Но также были фреймворки, которые использовали там какой-нибудь свизлин с ObjectiveC, на нём активно построено, либо же какие-то фреймворки, которые уже не развиваются для objectivec или аналоги свифтовые очень кардинально отличаются. Пример, вот наш самый больной кейс - это был Reactтив Cocaко, но ещё по проекту были там Objection, Mantle, SPCA, эпекта. И для конкретно каждого нужно было искать какое-то решение. Ну, рассмотрим кейс с Реактив Коко. Что, собственно, не так с Реактив Коко при использовании её в Свифте? Многие там пару лет назад её активно внедряли, а теперь каждый ищет, как её решение активно избавиться. Поэтому какая проблема? Нет понятия, что получаешь в колбэке, когда ты подписываешься на блок. К примеру, здесь у тебя все свойства. И тебе необходимо каждый раз кастить, приводить к какому-то определённому типу. И только потом ты можешь использовать, к примеру, здесь там пользователя. И это добавляет проблем, что нужно это всё помнить, это всё нужно поддерживать. Да и выглядит это не классно. тоже был так как бы собрались вместе со всей командой, подумали над решением, какое может быть, и мы подумали, что переписать всю логику сразу же с реактив какого на какое-то другое решение, не просто потому что там бизнес-логика, её нужно выяснять, проверять, и это там работа спиже нужно переделывать. Поэтому решение было то, что это нужно как-то мигрировать постепенно. И это должно быть удобно в использовании, в миграции, какую бы мы не написали. Также это должно поддерживать строгую типизацию, чтобы каждый раз разработчик понимал, что он получит в ответе, и чтобы имело Swift Like Cop и было удобно, более удобно читаемо. Поэтому взяли Reactти Коко, посмотрели какие есть open sourceные или там реактивные решения для Свифта. Их было два. Это тоже Reactive OCO, только версии 5.0 и RX Swift там версия 2.5, по-моему, сейчас выбрали в итоге RX Swift, потому что он нам показался более удобной в контексте Свифта конкретно. Но принципиальной разницы между двух этими фреймворками нет. Там есть разные исследования эту тему, но принципиальной разницы мы не заметили. Поэтому как же всё-таки мигрировать стив C-колу на RX Swift? А в итоге пришли к такому решению, что у нас есть rock signal, это объект Reactти Coco. Мы для него написали extension. Extension принимает параметр Generic, в котором вы можете уже указать конкретный тип, который вы хотите, чтобы вернулся вам в сигнале. То есть здесь происходит преобразование раксигнала в observable. похожее как сигнал, только из Свифта. И вы указываете generic, который необходимо, и этот Generic уже будет сразу же приедет в observable swiftтовый. Здесь мы его создаём, подписываемся на значение ксигнала, потому что self сейчас R signal. И в этом блоке мы пытаемся сконвертировать то значение, которое нам пришло, к типизированному значению, которое мы передали в Generке. А это функция приватная. Мы сделали, чтобы это не было наружу видно. И то, что наружу видно, мы вот такая функция, это она более чуть-чуть короче, то есть просто называется RX Map. Тоже принимает, а, типизированный параметр, тоже возвращает observable типизированный. Но зачем мы их разнесли? Как бы такой смысл-то не очень виден. А в том, что здесь мы получаем конкретные значения уже раксигнала. Это any value, оно здесь any. И пытаемся кастить к конкретному типу. Вот RX - это функция, которую чуть позже рассмотрим именно каста. И возвращаем. Но также есть проблема стико, что у Reactтико есть объект и есть простые объекты NS array, которые там легко кастятся в там NS number, VnT, там dictionary, просто V в NS dictionary, но Rpple просто так в картеж свифтовый не кастится, поэтому его пришлось отдельной писать для него распаковку вот такого вида, что мы тоже получаем значение any value. Здесь мы пытаемся any value распаковать как tle, и только потом мы конкретные значения tпла распаковываем. А сама функция там RX Map TLE принимает там, допустим, в данном случае два дженерика. И на выходе у нас тоже есть observable с кортежем из двух женериков. Но по факту нам пришлось ещё реализовать таких пять функций, которые там просто одно значение врактал 2, 3 4 и пть максимальное значение пять. Но это нам помогло иметь типизированные значения в Свифте. А, и в итоге последнее, что здесь осталось разобрать - это RXC. Сама функция RX Cast, она преобразовывает какое-то значение, типизированному значению венерике. А, и первым делом, казалось бы, просто можно let value а знак вопроса Т. И нам бы это дало сразу же понимание, стипизировалось ли наше значение any value в конкретно generic. Но с этим проблема есть в том, что если у вас, например, а string optional и вы пытаетесь вот просто завести это условие if, то у вас будет проблема в том, что если у вас any value пришло new, то вы не сможете скаститься к стрингу, потому что сю скажет, типа, я не знаю, как там new кастить к optional стринге. Поэтому следующие условия проверка на то, что если у нас generic наш optional, то тогда мы создаём как опциональный наш genнериic с нилом. То есть по сути, если бы у нас была т опциональная строка, то здесь было бы создалась бы опциональная строка, как new. И в таком случае это всё компилируется и возвращается. И на выходе что мы имеем? Мы имеем вот такую вот реализацию уже, когда мы используем Реактивку Ко в Свифте. У нас есть профайлфасад, мы авторизуемся, а там есть логин и пароль. У нас есть просто функция RX Map. Мы говорим, что из Java profile модель передаём тип, точнее, в эту как generic. И уже в subscribe у нас типизированным значением приходит там профайлмодель мы конкретно имеем. Можно чуть-чуть это потюнить и сделать чуть-чуть лучше. Можно создать extension на тот же профайл фасад и сделать более копи авторизация и сразу же сказать, что он возвращает там observable profile модель и просто сделать RX Map. И здесь как бы функция потянет generic сразу же из вашей с вашего ретрна и будет ээ на один generic меньше писать. И когда вы за используете эти функцию в бою или конкретном классе, это профайлфасад, вам уже не нужно знать, что это там Reactтив Coc живёт в себе либо там RXIFT. Вы уже сразу же просто пишете subscribe next, и usер у вас уже сразу же типизированный, и вы можете с ним работать. Если там юзер вы укажете как опциональный параметр, значит, он может быть как опциональный, там приходит, не приходит. Если строго, то значит строго должен приходить. В общем, вот такую штуку мы постарались сделать для ректив коко, разобрали её, и она сейчас работает. Пока каких-то существенных сбоев мы не наблюдаем. То есть даже багов с ней не было. Тьфу-тьфу-тьфу. А с третьим пунктом, который был для нас большим препятствием, это то, что когда ты переписываешь постепенно приложение, ты какие-то вещи хочешь использовать свифтовые, новые, модные, но тебе старый objective C код это не даёт использовать, и тебе там либо какой-то workрау, либо не использовать новые свифтовые вещи. Конкретно нам хотелось использовать там структуры для наших моделей и намы и там моки для тестов тоже бы неплохо использовать, а то в Свифте как-то всё не так прозрачно с ними, как казалось бы. А как же быть в таком случае? Тоже посмотрели то, что есть сейчас открытого, openсорсного и вообще какие инструменты есть. И мы наткнулись, в принципе, на самое с нашей стороны адекватное решение- это сорсери. Что такое сор? Сорсери - это метапрограмминг инструмент, который сканирует ваши файлы и применяет шаблоны на ваши файлы. И после того, как он это всё проделал, он генерит вам свифтовый код, который вы можете потом использовать у себя в проекте. То есть там для чего это удобно. Это для того, чтобы удобно автоматически генерить там язык quitable иable протоколы для всяких структур, для nscдинг легко поддержать таким образом в Свифте и там Jonсе реализацию. Поэтому как пример вот для чего это используется. Это стандартные уже стандартный темплейт, который можно просто скачать с гитхаба и заиспользовать. У нас есть структура резюме, и мы говорим, что она там удовлетворяет протоколам автоhable и автоe equitable. Эти протоколы формальные, они в себе ничего не несут, поэтому их даже не приводил. Они просто для того, чтобы когда ср анализирует ваш код, оно могло понять, что конкретно вот для структуры резюме нужно реализовать протокол hasable. И когда вы это всё вместе склеиваете, то вы на выходе получаете вот автосгенерированный exнtion для резюме, который удовляет протоколу hashable и в котором все там ключи вашего вашей модели учтены. Там они опциональные, не опциональные, они тоже учтены. И у вас сразу же есть hash value. И там комбайн hashes функция, она тоже автоматически генерится. И вы можете это встроить в build фазу в экскоде. И если вы добавили новую переменную, оно туда сразу же подъехала. Это очень хорошо для equitable работает. То есть у нас то же самое генери для equitable. И вы можете там сравнивать два резюме, ну либо две модели без проблем. То есть тоже новые проперртя добавились и там сразу же не появились. Пример, как вообще работать сорсери и что это, как на нём свои какие-то кастомные решения писать. К примеру, у нас есть и нам конференция, там мобильная и web. А мы к ней применяем такой шаблон. Шаблон написано на stencil. Я не очень изучал, но это про, а, как разметка для шаблонов. Она, по-моему, тоже open sourceна, её можно более детально поизучать. А, но вот то, что мы здесь имеем, он имеем цикл, в котором мы проходимся по всем типам, которые нам для них создаём extension с с именем Инама и статическую переменную с количеством кейсов конкретного Инама. И здесь мы получаем то, что вот, к примеру, применив такой шаблон и встроив его в билдфазу, вы сразу же будете получать автосгенерированной вот такой экстеншен с количеством кейсов для вашего Инама. Если потом вы добавите вдруг четвёртую какую-то очень крутую конференцию, то у вас сразу же тут обновится четыре и логика не сломается, и вы сможете использовать это дальше по проекту. Как это помогло нам? А у нас была проблема в том, что у нас была длинная большая структура резюме, в которую мы написали на Свифте уже как модель страctт, и нам необходимо было пару кейсов, где мы её должны были использовать в ObjectiveC. Структуры в objective C не видны, и для этого можно было бы просто сделать это классом и наследоваться от NS обжекта. И мы тогда теряли всю прелесть структур и но это не хотелось делать для какого-то конкретного кейса решений, чтобы потом это каждый раз боле переживать там. Ну зачем тогда в смысле переходить на Swift? И поэтому мы искали как это пробросить в objective C и придумали вот такое решение. Тоже решение основано на сорсере. Мы написали шаблон, который у нас сканировал наши резюме, на, точнее, сканировал наши модели и находил те модели, которые удовлетворяют протокол АOBC. Тоже протокол формальный, просто чтобы понимать, что для этой модели нужно его реализовать. И генерил вот такой класс. То есть у нас создавался класс resume OBC, который наследован от NS обжекта. Все переменные делались только там read. Ну, потому что в нашем случае не нужно было их менять, но это не проблема написать другой шаблон, который может изменять их. И потом также генериролась функция, которая из структуры резюме проходилась по полям и сразу же генерила класс резюме. Это очень удобно было использовать в проекте. И когда мы подошли к тому моменту, когда нам нужно было там удалить всё objective сишное, что связано с резюме, мы просто удалили этот шаблон и sorsy и сразу же вся автогенерация пропала. Нашли те места, где это использовалось, поправили и поехали дальше. Также очень хорошая вещь сорсери для моков в плане того, что проблемы с моками для, а, свифта, что не работает свизлинг. Когда пишешь objective C, многие библиотеки, там спекты и спекты они используют свизлин для того, чтобы вы могли замокать конкретный метод, посмотреть, работа, вызвался ли у вас конкретный метод. Но для свифтов, для свифтовых там различных протоколов, классов нужно каждый раз самостоятельно генерить как или описать фейковый какой-то объект либо мог. Поэтому в Sourceer есть тоже почти из коробки готовое решение, которое помогает вам преобразовать ваш протокол в что-то более удобное для тестов. То есть генерится вот такая структура, которая, точнее, не структура, а класс, которая удовлетворяет вашему протоколу и реализовывает все методы вашего протокола. Например, вот, допустим, метод там обновить данные, он сразу же преобразовывается в то, что у нас есть переменная, вызывался этот метод, не вызывался. Есть переменная, которая хранит все входящие параметры в вашу функцию. И есть, а, как бы сам метод реализованный, который проставляет вызывалась функция или не вызывалась и входящие параметры. Это всё происходит автоматически. Если вы потом добавили новый там метод в делегат, то у вас там тесты не сломаются, потому что вы его забыли реализовать, а автоматически всё подтянется. Поэтому вот такие решения были найдены для того, чтобы поддержать те вещи, которые необходимо в objectivec коде, но используя всё модное и классное из Свифта. Но также были ещё организационные моменты внутри команды в плане того, что хотелось изначально наставить, так сказать, всю команду в одно русло и чтобы она двигалась правильно. Это касается там кодстайла, потому что в objectivec у нас был кодстайл, а в Свифте там каждый ещё что-то подучивал, как-то пишет по-разному. И эту проблему хотелось решить. Хотелось решить проблему, работу там со сторибордами, с осетами, с локализованными строками, чтобы там это не забывалось удаляться, если это переписывать, не забывалось вставляться, если это дописывается. И для этого поискали тоже пару таких решений. Нашли решение Swiftlint. А я думаю, многие о нём уже слышали, и там много докладов есть конкретно. Это инструмент, который помогает вам, а, поддерживать кодстайл по проекту. Он там умеет подсвечивать ээ какие-то синтаксические ошибки в плане того, что там не там пробел поставил, не там запятая. не так отступ поставил и какие-то автоматически умеет корректировать, если вы его настроите правильно. И также он умеет генерить ошибки, когда вы хотите какую-то логику неправильную использовать. Ну, к примеру, на скриншоте показано, что там пытаемся ns object форсом кастить к интуи не даст такое даже скомпилировать. Вы не также можете настроить его, чтобы Force cast в при о Force unwrap не работал, чтобы всегда нужно было работать там через лет или if, чтобы обезопасить от каких-то крышей. А мы такое настроили себя в проекте. Нам это очень помогло. И теперь сейчас проблема с тем, что кто-то там не знает, как написать, и просто сделан он врап, заиспользовал это. Таких нет. Ещё очень Swiftlint помог нам с написанием кастомных правил, потому что когда мы внедрили решение с Реактив Коко, многие разработчики как бы: \"А да, я слышал о решении, ну, типа забыл про него, написал что-то своё и в итоге подписался нам какой-то на сигнал реактивщины скастил и заиспользовал\". И это было тоже не очень хорошо. Поэтому простойп, который там, в котором перебрали все реактив како решение, реактив какого методы и добавили в Swift Clint. Теперь при использовании Reactти co-ко у нас сразу же ругается о том, что типа чувак, ты типа не прав. Пойди, попробуй там посмотри на решение миграции, если тебе тут оно нужно. Также инструмент для работы сосетами и локализованными стройками и со сторибордом очень подошёл Swiftgen. К примеру, сосетами у вас есть там осеткаталог, в котором есть около шести, ну, в данном случае пять иконок. И если вы это настроите в билдфазу к себе, у вас сразру уже будет автоматически генериться вот такой инумчик, в котором будут перечисления ваших иконок. Там ещё будет партянка кода, которая нужна для того, чтобы правильно вот сгенерить LED icon контакты FB icon image. Но это я его не привожу здесь, там ничего интересного нет, он автоматически есть и работает. Но зато в данной случай, если вы вдруг удалили иконку из-за сетов, вам сразу же при компиляции ругнётся. Если вы там добавили иконку сет, и она сразу же там подтянется, и при компиляции снова появится иконка типизированная строго. А работа с локализованными строгами почти также строится. Она чуть-чуть короче. У нас есть просто теперь функция, в которую мы передаём а строку, которая у нас зашита в localizable. Как бы мы её там не форматировали, там через точку, через фис, оно это всё подчищается, и мы можем просто там сказать, что нам нужен тайтл какой-то. И теперь, если вдруг кто-то там при очередном рефакторинге удалит эту строчку, то здесь ему ругнётся и не даст совершить ошибку. Можно ещё настраивать для сторибордов, чтобы сцены автоматически генерились, и сразу же там инициализировать в VIWю-контроллер тоже строго типизировано, что если вдруг кто-то сториборда его удалил, он сразу же подсветился. Можно там сториборды настраивать, то под Мак работает. Можно с цветами и фонтами так делать. Но для нас это не зашло, потому что нужно каждый раз там экспортить цвета и фонт в тxt файл, правильно его описывать, но это можно делать, если это очень действительно нужно. Ну нам оно не очень зашло. Поэтому чуть-чуть резюмируя то, что мы сделали, мы вначале решили проблемы и посмотрели те моменты со сторонними библиотеками, которые у нас возникли. подумали о том, как использовать свифтовые вещи в objectivec, нашли для них решение и организационные моменты, которые не менее важны, тоже поискали им решения и конкретные инструменты. Поэтому, что в итоге нам дал Swift? А мы получили статическую типизацию, и в итоге у нас меньше бизнес багов в приложении. Мы теперь более понимаем чётко, что поменялось, почему поменялось. и где поменялась. А также более быструю скорость разработки фич в плане того, что теперь, когда там разработчик берёт, он понимает workflлоow, как работать там, и это даёт, ну, там процентов 10 мы где-то так примерно вымеряли, что, ну, по времени сократилось. И, ну, в конце, конечно, мы наняли людей, два человека к нам пришло в команду, и нам это очень понравилось. Поэтому всем спасибо за доклад. У меня, наверное, всё. Единственное, ещё и привёл ссылки на инструменты, которые мы нашли. Возможно, они кому-то будут интересны. Они также легко гуглятся, если вдруг то ссылку там потеряет или ещё что. Если есть, наверное, какие-то вопросы, то можно. А так у меня всё. Спасибо. Привет. Спасибо за доклад. А такой вопрос я не совсем понял. А как вы руководству аргументировали то, что вы хотите на Swift перейти? У вас же, ну, огромный проект. Я думаю, он написан довольно хорошо на objectc. Ну, и ты такой приходишь, говоришь: \"А вот мы хотим функциональщину применять\". А тебе дядя начальник говорит: \"Ну ты иди, сядь и дальше работай GTFC\", потому что это лишняя трата денег. У нас как-то это всё получилось очень гармонично в плане того, что мы искали активно людей в команду, и мы там порядка полугода не могли закрыть вообще никакие позиции. И мы вот прямо с руководителем сидели, ну, когда кандидатов собеседовали, и каждый приходящий кандидат говорил, типа вот хочу SWIFT, хочу SWIFT, хочу Swift. И там то, что мы говорили, мы хотим Swift, и то, что приходили, собеседуемы и говорят, что типа ну потенциально уже как бы рынок более Свифториентированный. Не знаю, либо, может, это нам так казалось. И сами руководитель просто уже, ну, был готов к тому, что типа, ну, надо, потому что за этим как бы будущее. Угу. Спасибо. Я ещё пару вопросов задам коротких. А были противники Свифта, которые там хотели на Object FC писать? Ну, как у меня пример в компании, мы SWIFT применяем на новых проектах мелких, ну, может больших, но как бы команда разделилась там, ну, дружеская война идёт, кто-то говорит сюди прикетит, там всё это фигня, кто-то не хочет это делать. А у нас была ситуация такая, что кто-то, допустим, не очень хорошо знал SWIFT. Ну то есть мы говорим, что мы хотим переходить, человек даже соглашается. Ну, допустим, он об этом, ну, не знает, там не читал про Swift. Ну, как бы момент был организационный в решении, то, что мы просто сказали: \"О'кей, чувак, вот там тебе условно там один день в неделю, либо же когда там мало задач, фищ конкретных боевых\". Ты берёшь там книжку на работе и читаешь, ну и изучаешь свифтовые решения. А что касается самого, почему решили переходить уже, мы решили в прошлом году, и мы сразу же переходили на Swift 3.0, у нас не было Свифта 2.1 и всех промежуточных. И казалось, что уже более-менее что-то стабилизировалось и уже более-менее какая-то перспектива ясна, поэтому особых раз в команде не было. А вы каким инструментом пользуетесь для разработки Икскодом? Да, мы нако, я так понимаю, у вас проект очень большой и там много свифтовых файлов. Э, ну, на моей практике часто XД тупит, там подсветка отрубается, там, ну, такие вот мелочи, автоподстановка не работает, приходится там перезагружать его. Вы не сталкиваетесь с такими проблемами? с подстановкой. Я не знаю, я не хожу, не спрашиваю всей команды. Лично у меня, когда я пишу, особо проблем нет. Единственная проблема - это с компиляцией стало больше. Ну компиляция - это, наверное, у всех проблема. Ну, и каждый раз, ну, там смотришь, как попроще написать, либо же там какой из Swift Lint или Swiftg выкинуть из билдфазы, либо же, ну, как-то оптимизировать то, что он там делает, хотя они довольно быстрые, но вот только с компиляцией, наверное. Ну и последний вопрос. Ну, как я уже говорю, у вас, наверное, много файлов свифтовых, а вот запуск приложения не страдает. Просто, ну, я знаю примеры, когда слишком много файлов, ну, компилится, понятно, долго. Ну и когда ты запускаешь на реальном девайсе, у тебя там устройство тормозит секунду-две, и ты ждёшь, пока оно откроется. Да, но как только мы заиспользовали по там use frameworks, этот флаг, у нас сразу же всё перелетело динамическими библиотеками и сразу же там плюс секунды две, что ли, или три сразу же, ну, на старт приложение добавилось просто из-за этого флага. А мы первым делом сделали то, что взяли все наши там всякие, допустим, кто-то UI компонент какой-то, ещё какая-то мелкая библиотека, мы их слопнули в одну библиотеку там и к себе переместили в проект. Ну и дальше там разные хаки. И я думаю, ещё сегодня будут доклады, по-моему, там в 3 часа, где конкретно люди расскажут более детально, что делали. Ну, мы тоже эти хаки смотрим, ищем и пытаемся к себе притянуть проект. Всё, спасибо большое. Олег, спасибо за доклад. Скажи, а пакет увеличился в размере, когда вы на свит перешли? Пакет увеличился, по-моему, тогда было около 20 Мб, сейчас он стал около 30 Мб. Ну, мегаб на 15, но нам не страшно в этом случае. А когда ObjectiveC постепенно вырезаете, размер уменьшается или такими же остаётся? Вот не следили за этим вот прямо за размером. Вот мы с, я так смотрю, примерно 36. Ну и ок. Вот то, что добавляем, я не следил, не могу ответить. Понятно. Спасибо. Здравствуйте. Спасибо за доклад. А меня интересует вот Swift 4 backward compatibility. Угу. А как вы будете решать эту проблему? И при переходе на Swift нако на на на как сильно застопорил процесс разработки? В общем, ээ процесс всё, да? А процес отвечу с конца. Процесс разработки как раз основная идея была мигрировать постепенно. Он не очень затопорился, потому что мы там сделали микрофичу и там релизим её свифтовую. То есть мы не делали что-то большое, мы постепенно определяли конкретно, там, допустим, переписываем этот класс, либо же вот внедряем что-то вот небольшое. К примеру, начали с то, что экстеншены написали там для работы с пушами, которые вышли для iOS 10. Мы это просто написали на на Свифте, это засунули в проект, и оно там жило какое-то время, оно там все отдельным таргетом, всё нормально. То есть мы привыкали и постепенно меняли какие-то другие файлы. И вот какой-то конкретного стопора в разработке, ну, не было, потому что всё очень медленно проходило. Порядка 7 месяцев у нас этот переход занял. А что касается, прошу прощения, забыл, первый вопрос. А, Swift 4. А, Swift 4. Мы его недавно подключили и попробовали с ним собираться. Каких-то, по-моему, серьёзных проблем не было, но вот, честно, делали ребята, и я вот не помню результата. Недавно буквально было, но вроде там нет каких-то прямо breaking changes непоправимых. Ну, либо на нашем проекте. Так, спасибо. Здравствуйте. Подскажите, пожалуйста, смогли ли вы смогли ли вы решить проблему с автоикрементальной сборкой, когда у вас обктив Swift обжектив зависимости в проекте? А я правильно понял вопрос, что это когда меняешь одну строку в свифтовом коде и пересобирается весь проект. Просто у нас довольно много, наверное, процентов 30-40 переписано уже на Swift. И, ну, действительно, бывает так, что типа там обещали в 8:3 в релизноде написано, что типа мы починили, а ты меняешь одну стаку, запускаешь и у тебя перекомпиливается там тысячи файликов вот этих всех. А я то, что помню сейчас, это то, что когда у нас меняешь встрочку в проекте, то у нас перекомпиливается objective сишные файлы не перекомпиливаются. Ну вот по беганку искода то, что я сужу. А свифтовые, по-моему, да. Ну вот пока дискомфорта это не доставляло, что там очень долго. Ну как-то порядка 10 секунд что ли перекомпиливается всё. Но в целом проблему вот конкретно вот так мы не углублялись. Ага. Ну надеюсь тогда, что вы не столкнёватесь. Просто у меня как раз сейчас такая фича есть. Ну это сложно назвать фичей. Нет, в смысле, идёт там переписываю экран и действительно, если не включить, в общем, типа для дебага минус N onon, то типа одну стоку меняешь, запускаешь и секунд 40 ждёшь, пока всё это дело запустится. А вот и второй вопрос, почему выбрали RX Swift, когда типа, ну, есть реактив какой четвёртый, и потому, что вы показывали, можно сделать и там, и там. Это во-первых. Во-вторых, сейчас RX Swift RX м Реactтив Коко для Обжектива, она перешла в новую репу и теперь опять развивается. Кстати, вот насчёт новой репы, я не знал. Это порядка там 7 месяцев назад было. Может, я плохо погуглил в то время. А что касается, почему выбрали RX Swift, первым пунктом то, что у команды были некоторые опыты больше уже работы с RXIF, то есть люди там какие-то там домашние проекты делали, либо же нас предыдущих мест работы не поиспользовали. И в том, что просто показалось, что его удобнее использовать конкретно для Свифта. Оно более Swift Life Cop имеет конкретно, мне кажется, это равнозначные вещи. в Коко там 5,0, которая, ну, сейчас, по-моему, ещё в разработке, но есть и 4.0, которая уже более стабильна, и RX Swift. Ну, в нашем, когда мы это исследовали, мы не нашли каких-то конкретных плюсов, минусов в одну и в другую сторону. Просто взяли RX Swift, который показался более интересным. Тогда я просто отмечу, потому что у меня есть хороший опыт и там, и там, что в Реактив Како от четвёртой версии, ну, как бы что в четвёртой версии стало довольно всё нормально, там из-за разделения вот этих видов сигналов, то сразу видно, какой типа у тебя, ну, какой у тебя фол выполняется уже независимо от того, будешь подписываться, нет, а какой только стартанёт с этого момента. В RX такого как бы нету, и тебе приходится как в Реатико 24 там типа додумываться. Угу. Ну хорошо, спасибо за замечание. Там ещё один вопрос. Спасибо за доклад. Менялась ли архитектура при переходе на Swift? А, менялась и МЧ продолжает стабилизироваться. Самая большая проблема связана была с тем, что был у нас, а, для objective C Framework Objection, для Dependency Injection, и он работал на Свизлинге. И как бы на Свифте это не работает и пришлось как бы мы создали отдельный слой assмблер аля наш полу самописный, либо ещё ищем решение для Свифта, для диая, который все наши зависимости бы инжектил. И вот в рамках этого у нас появился ещё дополнительный слой там асемблера. Вот, наверное, вот так. А как выглядел переход? Это была изначально заложена архитектура новая или вы сначала переписали что-то там просто на SWIFT, потом уже новую архитектуру? Как это было заложено? А у нас сама архитектура имеет как бы четыре уровня. это там а view в viewмодель, там фасады и сервисы и там адаптеры конкретно там копии или ещё к чему-то. И для СФТА мы создали ещё отдельный слой типа ассемблера, который как бы стоит сбоку и помогает собирать все свифтовые файлы и генерить конкретный модуль. А для objective C мы всё оставили как и есть, просто его там удаляем. Это новая архитектура была заложена только под Swift. Objective C мы не трогали. А вот ты говорил, у вас было и от MVC до Viper. На чём вы остановились? А, ну остановились на Вайпере в плане то, что это постепенный переход, как бы начиналась разработка ещё про Viper. Никто толком и не знал там порядка 5 лет назад. И какие-то там древние экраны оставались на MVC. Ну потому что они не меняются и не было времени их перерефакторить. А как бы objectivec сам постоянно и текущий код он на Viper подобной архитектуре. Всё, спасибо. Всё, тогда, наверное, всем спасибо."
}