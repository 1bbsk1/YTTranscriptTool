{
  "video_id": "TRLABeG2IOo",
  "channel": "HighLoadChannel",
  "title": "SWIM - протокол построения кластера / Владислав Шпилевой (Tarantool)",
  "views": 1465,
  "duration": 2643,
  "published": "2020-02-26T12:01:28-08:00",
  "text": "план доклада следующий я расскажу про предков протокола своим profile of detection протоколы про гости протоколы группой в группе которых состоит своим про сам своим как работает его классическая версия как он реализован в tarantul с какими расширениями как им пользоваться какую производительность он показывает и планы на его развитие раскрою вначале был один сервер он принимал клиентские запросы хранил какие-то данные но однажды он с нагрузкой перестал справляться и тогда придумали ему помочь сделали много серверов они стали делить между собой нагрузку и хранение данных и так появилась горизонтальное масштабирование и ушла проблема перегрузки но появились новые задачи в частности определения отказов в таких вот кластеров которые делят нагрузку или failure detection это нужно было за тем чтобы выводить не рабочие узлы из кластеров чтобы чинить отказавшей узлы и чтобы принимать в кластере решение централизованное решение вида комментов транзакции синхронной репликации перевыборов мастера перевыборов лидера и тогда в 1970 80-х годах стали придумывать много всяких разных решений протоколов алгоритмов которые пытались эту проблему каким-нибудь образом решить начиная с того что давайте все будут пинговать всех и если не пришел ок значит узел отказал и заканчивая попытками разработать надежный протокол широковещательной рассылки чтобы нужны посылали их орбиты вместо пинков но у всех подобных протоколов есть проблема общая она состоит то что я очень плохо масштабируются из за того что у них присутствует связь каждый с каждым любой протокол который вводит связь каждый с каждым носить он будет давать квадратичную нагрузку на сеть на каждом своем шаге например если взять протокол простецкий которые пинге от каждого каждому посылает и у нас кластер из тысячи узлов то на каждом шаге такого алгоритма сеть мы сбрасываться миллион пакетов каждый узел будет получать тысячу пакетов должен быть отправить тысячу ответов и чем больше кластер тем это все хуже работает и тогда придумали другие другой группы протоколов названием гости пониже протоколы слухов они же инфекционные протоколы которые решают гораздо более общую задачу чем просто failure detection они решают задачу в принципе обнаружение событий в кластере вообще не только отказов и распространение этих событий так чтобы они узнавали все узлы кластера выборе этом они дают очень хорошие оценки на то как быстро и что они обещают делать частности они дают всего лишь линейную нагрузку на сеть и обычно дают констант ную нагрузку на каждый узел который от размера кластера будет вообще не зависеть как работает типичный какой-нибудь гости в среднем схему работы любого гости по есть кластер в кластере вводится понятие события событие это отказ музло введение нового узла изменения существующего узла пикты его атрибутов настроек конфигурации в этих событиях узлы могут узнавать узел а может узнать что узел бы отказал или чтобы явился узел c это называется события и это событие хоть хочется распространить на все на весь кластер чтобы каждый узел знал что вот взял бы отказал но какие-то действия связи с этим предпринять и гость делает так только то про это событие 1 узнает он выбирает случайного соседа который ему известен посылает ему это событие дальше сосед делает то же самое итак начинаются лавину распространение событий то есть класс узлы и в кластере друг другу помогают распространять события в отличие от крылов detection обычных протоколов кроме того за счет рандомизации достигается равномерная нагрузка на кластер если у нас каждый узел будет случайно выбирать одного один другой узел посылать ему один пакет-то в среднем каждый отправляет один пакет и каждый получает один пакет на каждом шаге алгоритма то есть константной а нагрузка на каждый отдельно взятый узел она сеть линейная отсюда эти оценки и получаются все гости по есв мы все прочие они работают примерно по этой схеме отличаются в деталях его реализации начиная с того как именно они обнаруживают отказы есть наивный способ когда просто посылаем pink ждем ок если от пришел все нормально если не пришел значит отказ особо умные протоколы могут бороться с проблемами сети когда прямые bengi почему-то не ходят тогда они могут взять случайного соседа попросить минга не вот это третий узел и форвард ним не ок если он будет вообще она помогает бороться с проблемами сети и самые умные протоколы могут даже найти свой собственный отказ к примеру если узел послал pink тем ему ни от кого не пришел акту скорее всего проблема с ним они со всем остальным кластером следующее отличие это гранулярный состояние узлов узел может быть жив может быть мертв а можно вести больше состояний что он медлителен что он подозрителен или некоторые протоколы делают состоянии узла как число непрерывном отрезке от 0 до 1 и типа единицы это узел полностью доступен 0 недоступен и он может любом промежуточном состоянии еще находиться разные гости протоколы вводят различные критерии как именно они определяют степень доступности узла сколько оков нужно чтобы не дошло чтобы узел посчитать отказавшим какого задержка с микрофоном четв-тро 1 раз какого задержка оков когда посылаем pink сколько мы будем ждать пока придет так доступен узел напрямую или не напрямую через сколько узлов он доступен через сколько нет и последнее важное отличие это направление распространение слухов событие в кластеры из 3 основных группы как именно события могут распространяться первый этап уж самый простой кто про событие узнал тут и всем его рассказывает даже если об этом никто не просит пул это когда узел не расскажет про событие до тех пор пока его явно не спросит нет ли у тебя новостей о каком-то другом узле это хорошо работает когда событие очень много и push болото комбинация все вот эти способы все вот этих отличий они дают очень хорошие оценки на то что нам гости протоколы обещают они обещают нам как минимум константное время обнаружение событий в кластере то есть чтобы в кластер не произошло и где бы за это об этом за константное время узнает хотя бы один другой узел кластера нам обещается что как минимум логарифмическое время распространение будет так что о каждом событии в кластере узнают все нагрузка на сеть линейная нагрузка на узел обычно константное и гаси протоколы будучи как видно весьма привлекательны своей эффективностью легковесность you и простоте и простотой в понимании и относительной простой в реализации получили весьма широкое распространение во множестве продуктов среди которых apache cassandra это распределенная sbd который использует gothic для мониторинга узлов в кластере всё рф это библиотека который используется в консоли она реализует swim скатал бат это такой гости который ориентирован на сверх большие кластеров десятков тысяч узлом он особым образом экономит трафик и вот как раз решает эту проблему что там супер огромное количество событий нельзя чтобы все все подряд посылали сцилла это собой где используются старые и гость пока сандры для того же самого для мониторинга и lifeguard это еще одна реализация схема которая модифицирует его чтобы уменьшить количество фолз позитив обнаружения отказов есть там swim swim очень простой наверное самый простой из всех этих протоколов и помимо простоты по реализации понимание его еще очень легко модифицировать и очень расширять поэтому у него есть модификация звезд surf модификация lifeguard есть модификация таран тульская swim это скала был вы клик consistent infection стоял процесс групп membership протокол scalable означает а каждая часть названия оно означает что то что своим умеет вот скал был означает что с им очень хорошо масштабируется он дает констант ную нагрузку на он дает константное время обнаружение события в кластере и логарифмическое время его полного распространения вы клик consistent означает что протокол полностью асинхронный и не требуют никаких синхронизации между узлами никаких блокировок ожиданий то есть как только событие появляется она сразу начинает распространяться без ожидания чего-либо из этого может получиться такая ситуация что если с узлом неким что-то только что произошло два других узла могут видеть его состояние по-разному какое-то время пока события в конце концов не распространиться на весь кластер мало но когда-нибудь распространиться с им этом и нам это обещает процедуру вы клик consistent and action стал процесса 35 типичное свойство любого gossip а то есть событие распространяются не одним узлом а лавиной всеми узлами которые про него успели узнать групп membership означает что каждый узел держит у себя табличку всех известных ему узлов кластера и последних известных состояний этих узлов и обновляет ее из полученных слухов событий пакетов пинков иаков и прежде чем я расскажу как своим реализован в tarantul и я сначала поясню как работает классический swim какие у него есть проблемы и почему пришлось зарабатываете как swim состоит классический из двух компонент это обнаружение отказов и распространение событий обнаружение отказов работает следующим образом узлы периодически выбирают случайного соседа посылают pink жду так славит египте пакет pink эдипе как ожидают и так они работают в штатном режиме покати приходят если ок однажды не пришел тузи лоб являются подозрительным не сразу отказавшей потому что это египте нельзя сразу на основании потери новый пакет объявлять что получатель не до недоступен он объявляется подозрительным начинается расследование узел который не получил ок просит пингануть вот этот узел своих каких-то случайных соседей вот этот самый непрямой pink здесь используется в семье если не прямая доступность есть значит узел в порядке возможно просто какие-то проблемы с сетью временные возникли если он даже не прямым а ко мне ответит тогда он уже объявляется недоступным и здесь узел как ты которого пытались достучаться его состояние менялась несколько раз сначала на подозрительный потом на отказавшей потом он мог опять ожить это все событие каждый из них надо распространять чтобы об этом все остальные узлы тоже узнавали про не только тот кто эти деньги посылает этим занимаются модуль распространение событий отработать так все события которые происходят как про который узел узнаёт он и складывает в очередь и в этой очереди для каждого узла храниться только его последние состоянии то есть она не растет бесконечно если с кем-то узлом произошло там пять событий это в очереди он будет лежать только один раз со своим последним известным состоянием так вот есть эта очередь событие ограниченная и каждый раз когда своим хочет послать pink он в тот же hype пакет дописывает событие сколько туда влезет их напихивают и посылает каждое событие какое-то ограниченное число раз достаточное для того чтобы все хотя бы по разу его отправили и получили в кластере эта штука называется пике backing когда в один видите пакет поселяются еще одна независимая компонента действительно это было бы неразумным посылать огромный пакет с одним пингом который занимает 10 20 байт так что swim или использует тот же тебе пакет и получается что модуль распространение событий в плане сети работает практически бесплатно не генерирует вообще никаких новых пакетов swim семья пакеты генерирует только обнаружение отказов распространение событий работает как бы заодно так вот когда baby пакет дошел до получаете ли он распаковал этот pink масло лак распаковал события ему надо эти события теперь как-то в свою локальную табличку мемберов применить как это применение работает наивные наивным решением было бы просто брать все что в табличке пришло принимать за чистую правду и к себе в табличку это при нем применять тогда возникают следующие проблемы есть три узла abcd отказал об этом знает отца еще не знаю это не событием этими обмениваются и кто из них будет прав если они будут просто молча применять все что им приходит посетит они так и будут менять свое мнение про б до бесконечности поэтому этот когда-то остановить своим говорить что если у тебя есть противоречивая информация тогда предполагая худшее они предположили теперь оба считают чтобы недоступен а потом он становится доступен и ему надо убедить остальных что он доступен если он будет им просто посылать сейчас пакеты что я живой они не будут ему верить потому что предполагать худшее на и нужен какой-то механизм опровержение ложных слухов семей и он есть он называется инкарнация это такой счетчик который простые rowan с каждым узлом и который только этот узел может увеличивать и которым помечаются каждый пакет который этого узла уходит то есть это что-то вроде векторных часов которым помечаются события связанные с узлом в примере этом предположим что у нас был единички равен и b будет слать события что я живой у меня инкарнация один ему никто не будет верить потом однажды те кто то скажет что его считают недоступным ему это скажут потому что в кластере еще есть ему все еще шлют пакеты несмотря на то что они может быть и не доходят ну вот один из них дошел и боевики что его считают недоступны ему не доступным ему надо этот слух опровергнуть и чтобы его опровергнуть он увеличивает свою инкарнацию и начинают распространять слух о том что он живой с новой инкарнации и это новой инкарнации перед ряд все что было связано со старой больше того ему не придется делать это одному изменений инкарнации это тоже событие тоже слух и ему будут в этом помогать все остальные узлы его имя очищать таким образом в какой то момент мы когда вернётся он в этом всех остальных тоже убедит кроме того тоже инкарнация помогает нам защититься от проблемы и дипе когда какие-нибудь старые пакеты могли про дублироваться слишком поздно дайте берем порядочен если там будет неактуальной информации у него будет старее инкарнацией можно будет ее проигнорировать так что люди здесь никаких проблем не добавляет в этом плане это в общем-то весь swim он действительно настолько простой в теории теперь как он реализован в tarantul и вместо того чтобы каждый узел просто бесконечно рандомно выбирал случайного соседа по слалому bing мы сделали немножко справедливости tarantul и узел работает по раундам в начале каждого раунда он берет всех известных ему узлов перри упорядочивает их случайно кладет в очередь и периодически из этой очереди достает следующий узел посылает ему пинка blue события когда очередь кончается он опять перри упорядочивает опять кладет в очередь за счет того что у нас есть очередь они абсолютно полный рандом мы получаем справедливость что пакеты будут посылаться каждому узлу одинаковое количество растопкой за весь раунд по одному разу они так что один узел там 10 пакетов получит мингов один ни одного получая за справедливость при этом рандомизация все еще сохранена нагрузку все еще равномерно по всей сети следующие эту даже нет не то что изменение это уже доработка просто в семье в оригинальном нет определения как адресовать узлы там нет такого понятия как уникальный идентификатор узла по которому можно было бы узлы и друг от друга отличать моему они там просто чисел коми идентифицируются может быть нет не помню уже это не особенно масштабируется наивным решением было бы использовать и порт usb keyboard будет идентификатором узлам это тоже не масштабируются потому что эти порт мы можем захотеть поменять и мы не хотим терять информацию о том что старые ты port новый и keyboard это один и тот же узел если мы будем использовать эти порт как индификатор это не будет работать так что в тарантулы используется идентификатор видео иди внутри которого можно их и боже сколько угодно менять информация будет во всех узлах верно и не буду знать что старый порт новый порт это один и тот же узел внутри одного вида даже вид принципе тоже можно поменять просто немножко сложнее там получается вот реализован swim полностью носи но у него торчит важный интерфейс доступный до старта боксов игре до старта сторон году вообще любых под систем можно запустить своим что позволяет использовать его для того чтобы подготовить параметры для остальных подсистем вроде хранилища то есть di-box цифра г можно в одном tarantul и создавать много 7 если у нас какой-нибудь узел состоит сразу в многих кластерах это используется в энтерпрайзе можно конфигурировать практически все что я сейчас рассказывал про сферу все характеристики скорость работы протоколы это хард дмитрий то есть как часто посылать пинге с событиями когда считать pink неотвеченным ок тайм-аут можно выбирать или борт и и иди и можно выбирать еще такую штуку как gc мод дело в том что оригинальный свин он очень беспечно относится к узлам которые отказали он говорит что есть узел отказал давайте увидеть таблички выкинем перестанем что-либо посылать ну это тогда не очень хороший мониторинг получается потому что если вы зал обратно вернется потому никто не узнает такое поведение хочется уметь отключать его докторантуре его можно отключать можно вручную работать с таблицей таблицы мемберов ну зле можно добавлять туда руками знаю ее и ее и порт ново мембера можно их удалять можно делать широко вещательную диппера ссылку на заданный порт чтобы найти новые узлы если мы не знаем у них там айпи и и иди можно делать точечную рассылку это проба member это возможность практически самому выбирать когда я кому послать ding то есть мы запустились рим запустили много 7 не друг про друга не знают как надо хоть как-то первый раз связаться чтобы они могли дальше друг друга пинговать надо как-то сообщить информацию друг о друге и мы можем даже знать томатный пор даю и и иди можем не знать заранее и вот проблем берном поможет бром member посылает pink в каждом pink запросе содержится и иди отправителя и порт отправителя в аке содержится тоже самое поэтому пинками вот этим пробные верлибр отказ там можно узлы первый раз связать дальше они будут сами друг друга мониторить можно обращаться к отдельным мембером таблицы и смотреть информацию по ним можно смотреть их номер инкарнации эти порт и и и некоторые другие вещи которые дальше сейчас покажу можно подписываться на события происходящие из таблицы мемберов когда у нас новый узел появится кто подскажет изменится чтобы самостоятельную табличку не палить можно об этом узнавать моментально через триггеры и можно выводить узлы из кластер и аккуратно они просто их выключать и ждать пока все остальные посчитают их отказов scheme и короткая демонстрация того как 7 работает я запустила тарантула на каждом из них я поднялся им на левом я подписался на события чтобы дальше их печатать и смотреть что там не приходит я их связываю первый раз я вызвал проблем beer он послал им к правому своему правый послал а к левому сумму они связались они друг друга теперь видят у них таблички размер 2 то есть это сам узел и его коллега и подписка сработало я распечатал в какой мне event произошел и вы видите у меня написан самим rs котором произошло событие его every статус incarnation и индии события событие написана из-за значит что умер новый дальше я выключаю один из них и спустя время у меня левый swim заметить что паровые уже мертвый у меня тоже появится события только в нем статус будет уже get my life и дальше расскажу про расширение которые мы реализовали в таран тульском семье и зачем формат будет такой я буду давать задачу которая которую надо было решать которые классические swim не решают и как она решается определенным расширением 1 это анти энтропию рассмотрим пример есть два узла а и б они друг про друга знают и они друг друга посылают тенге еще у них замечательно а потом появляется третий узел c и он знает только проблем он ему проблем beer послал такое может произойти если у нас бы это некий опорный узел про которых знают все новые узлы и с него рассчитывают вытащить все остальные узлы так вот c узна знает про б он с ним связался b знает про них обоих как a и c теперь свяжутся классический сим нам говорит что должно произойти событие появился новый узел ц.б. об этом узнал на b появилась событие что есть новый узел c он должен его послать он посылает это событие узлу а но это юдифи пакет теряется а узел срок жизни события ограничен так что этот пакет больше может и не будет послан они будут друг друга пинговать а и b но это событие посылаться не будет теперь они никогда лице друг про друга не узнают в классическом 7 стран тушкам они узнают потому что мы вводим третью компоненту помимо failure detection иди семенишина то есть обнажение отказов распространение событий еще появляется анти intropia это когда мы в этот эдипе пакет многострадальный запихиваем в конец сколько влезет случайное подмножество таблицы мемберов отправителя с каждым везде пакетом и в в данном примере у нас b в конец всех своих пинков которым посылают будет записывать информацию о том что он знает а и знаете рано или поздно эти пакеты и да и dc дойдут потому что срок жизни анти энтропии не ограничено до пишется в каждый пакет если это место еще остается после событий и рано или поздно лице друг другу знают свяжутся и будут друг друга напрямую пинговать следующее расширение байлот полезная нагрузка дело в том что когда у нас есть несколько симов но вот мы знаем что там на каком-то эти партии работает с этим большим и про этот узел не знаем ничего мы не знаем что там работает куда там подключаться что там ещё есть даже на каком порту там работает тарантул кими кредит шел сами подключаться к тарантулу ничего не понятно а вот и swim классически эту проблему никак не решает tarantul она решается следующим образом с каждому зло можно распространить свой собственный кусочек информации до 1200 байт абсолютно произвольных которые будут распространяться как событие являться обычным атрибутом каждого мембера их изменения будет распространятся по всему кластеру и вот в этом кусочки информации можно заложить какую-то какие-то свои данные вроде портак которому можно будет подключиться к тарантулы или придерживался вроде логина и пароля рассмотрим на примере как это срабатывает я запустил 2 схема на одном из них я ещё запустил хранилище тарантула позвал горцев с каким-то другим портом не с новым и номер этого порта я буду распространять как пилот дальше я идти если мы опять связываю вместо про бибер я решил использовать бродкаст вот они связались и на левом семье у меня по илу от правого своим а рано или поздно появляется я могу его получить вытащить эту бы порт приконнектиться и все будет работать моему порта можно еще что годом то запихать это lua так что можно любые ло таблицы туда засовывать строки числа что угодно наличие такой штуки как пилот и возможности засунуть в нее все что угодно включая данные для подключения котором плуот минске наводит на мысль что с им получается невозможно использовать в открытой сети потому что если там в открытом виде будут лежать логин и пароль к тарантула все коды доступа зиона там будут находиться то любой сможет людьми пакет за снизить подключиться котором было удалить все данные выкачать все данные и вместо чтобы переложить это на юзеров чтобы они сами шифровали пилоты семья можно это сделать одной строчкой можно включить шифрование да каждый пакет каждый pink все события все приводы анти intropia даже заголовок египет ракета считается скомпрометированы мун дублировать в теле каждого пакета это все быть шифроваться приватным ключом заданным алгоритмом и за данным режимом работы алгоритма если мы которых одинаковый приватный ключ ну вот эта тройка короче которые одинаковы они будут друг друга видеть все будут шифроваться и можно в открытой сети использовать следующее расширение это выход из кластера аккуратный как можно выехать выйти из кластера по простому можно просто убить узел подождать пока все остальные увидят что он недоступен тогда придется подождать пока его кто-то пинга нет придется подождать пока он не ответит на несколько пинков потому что 1 пингов tarantul и проваленного недостаточно нужно ждать пять после этого придется дождаться пока событие об этом разлетится по всему кластер а это долго и это неотличимо от события отказа узла что может быть нежелательно в логике приложения поэтому можно выводить узлы из кластера аккуратно из такой метод queen он посылает особое сообщение всем узлам что я вышел не считайте меня не доступно больше того это является тоже событием так что если этот пакет на кого-то не дойдет дойдет хотя бы до 1 то будет дальше это тоже распространять на практике это выглядит так запускаем 2 схема и опять связываю один из них выходит я вижу статус left my life не дает а специальный статус лифт на который можно как-нибудь реагировать у себя приложение следующие новые расширения этот детектор перезагрузки он решает проблему которую создала предыдущие расширение но за заодно он это еще и фича посмотрим ситуацию она возникает чисто из-за пейлоуда в которых логическом в свинец ситуация такая есть два угла узел а у него bailo toda синий кружочек инкарнация единица бей эту информацию знает потом выключили а включили обратно с другим породам а инкарнация не персистенция поэтому при этом включится заново с другим колодам инкарнация будет даже а пилот будет другой он попробует убедить б что у него пилот изменился бы ему верить не будет потому что он уже говорит о я знаю пайлот с такой инкарнации один то что ты мне сейчас послал я даже читать не буду так что пилот не изменился и не изменится до тех пор пока оно опять что-то не поменяется пока он снова инкарнацию свою не изменит на самом деле когда прямые сообщения это еще можно решить что мол я сам тебе пакет отправил так что ты можешь верить там даже если инкарнация одинаковая по и лода разный примени новый пилот но та же самая проблема остается если добей этот брелок а как-нибудь не напрямую дойдет то есть проблема в не persistent насти инкарнации состоит решаются она следующим образом мы переделываем самую основу схема инкарнации делим на 2 части теперь это два числа итоге не generation перри системная часть инкарнации и инкарнация которая работает так же как раньше работала семье классическом пересяду состоит том что вам предлагается самому и сходить куда-нибудь файлик и указать когда создаете своим либо можно с этим тоже не парится по умолчанию уже не решен задается как timestream текущей так что можно и это тоже не особенно там настраивать если всем мире стартует каждую миллисекунду то все будет работать создаем generation единичку конфигурируем этот фильм запускаем 2 sim связываем их дальше перезапускаем 1 запускаем заново словом же не решена правом семей это вижу как специальное событие из you generation то есть это фактически равно перезапуску можно тоже как-нибудь на это завязываются и посмотрим пример как построить кластер при помощи схема причем доклад вообще есть задача много дата-центров каждом запущена две реплики я хочу в каждом дата-центре открыть рипли кассет которым будет по две реплики сгруппированных по дата-центром я буду писать скрипт который будет работать одинаковый на везде на всех углах скрипт будет принимать 4 аргумента это идентификатор дата центра и порции мареве борт хранилище бакса на которые репликация будет цепляться и ее один зла и и эти достаточно 1 задачи для снимает ли бакса в этом прикол того что у нас едет и to indicate на идентификатор и там и там я буду подписываться на события и заполнять табличку нос репликами своего дата центра я буду смотреть на каждое событие и видеть что если у меня в моем дата-центре появился новый swim то я его запоминаю вот в эту табличку но вот активируя подписку включаю swim и каждый узел будет себя в природе и распространять номер свои вот эта центра и свой стран тульский keyboard дальше мне нужно ждать пока все поднимутся они ни одно время на поднимутся так что придется подождать и чтобы узнать друг друга находили новые я вот буду бродкаст использовать потому что я заранее не знаю на каких и пикниках там что поднимется я только на номер порта готов завязаться что он будет одинаковым всех симов я запускаю файбер который будет в фоне посылать теоретические бродкасты и ждать пока у меня поднимется хотя бы 2 схема то есть я сам и еще кто-то в моем дата-центре табличка ноуз заполнена можно формировать аргумент для буксов игре и запускать репликацию все кластер построим репликацию свой шар дом сложнее читка быть это была задача построения кластер она можно решать другие задачи при помощи схема самое интересное задача это выборы лидера казалось бы причем здесь detection но как было на первых самых слайдах проблемы самые изначально этих кластеров failure detection который был нужен в том числе для выбрав лидеры дело в том что выборы лидера вроде протоколов там рафта и подобных ему бы они на самом деле гораздо сложнее любого гостя по но одна из самых сложных частей и the failure detection огонь и красоту задачу может отлично решить том числе swim так что можно взять ровд выкинуть из него этих орбиты которые посылает и использовать там swim и тогда ровд будет работать в большом кластере даже мы можно использовать для обычного мониторинга чтобы отказано хотите как-то на них реагировать и swim он весь такой обвешанной кучи всяких расширений и сказывается ли это на его производительности для того чтобы измерить его производительность была написана программа которая создает виртуальный кластер и ведем делается целая куча этих своим of генерируются событие один из узлов врубается и дальше измеряется время которое проходит до того пока все узлы про это событие узнают тестирование было при рассылке сообщений раз в секунду каждому зло мы получили следующие результаты до 25 узлах за 4 секунды об отказе одного узнали все 200 узлах об этом все узнали за шесть секунд но 300 за 7 800 узлах за восемь секунд все узнали что один узел отказал и теперь посмотрим на настоящий двоичный логарифм на теоретическую оценку то есть он с точностью до константы немножко даже быстрее получается за счет того что наверное когда события происходят об этом узнают сразу несколько узлов они один обычно этого получилось чуть быстрее двоичного логарифмов каковы итоги что такое свин еще можно использовать его можно использовать для обнаружения событий в кластере для обнаружения за за константное время для распространения событий за логарифмическое время его достаточно просто и понять и реализовать использовать у него очень простой короткий интерфейс он доступен до того как с опущены любые другие подсистемы до боксов и г что позволяет использовать его для подготовки аргументов для бокс цпг что вроде как используется в картридже насколько я понимаю и что позволяет использовать его в связке с свой шар дом планы на развитие сумма использовать его для выборов лидера для асинхронной репликации страдальческой которые все идет и идет все никак не дойдет вот и ровд это типичный протокол асинхронной репликации с лидером и там swim в принципе можно было бы использовать кроме того сын можно будет использовать для автоматические сборки кластеры из коротких когда мы просто запустили тарантула дальше они подкастами сами друг друга могут найти мы каким-нибудь стандартным портам и собраться в рипли кассет sharding в группе какие и можно будет обнаруживать топологии кластера того что проблема топологией уже довольно долго в таран предстоит в плане репликации это может когда у нас реплицирует изменения не реплицируются full меж и квадратичное количество раз это конечно же не уж сильно экономить сетевой трафик а если бы мы знали топологию кластера ту реплики могли бы строить определенные маршруты по которым они могли бы реплицировать изменения не мог бы с этим помочь с обнаружением топологии их изменений и прочим спасибо за внимание спасибо за доклад и давайте перейдем к вопросам романов александр индекс спасибо было интересно вопрос такой возник вот несколько слайдов назад вы приводили график зависимости количества нот от количества времени точнее наоборот на вот и до этого вы говорили что для того чтобы узнать что но ты умер нужно отправить минимум 5 пингов иуда и при разок сообщений 1 секунду получается что минимум пять секунд она дала в дом что ок тайм-аут от настраивается отдельно от х дмитрий то там пока пинге раки ходят действительно будет 1 секунду на когда хотя бы обить 1 pink не отмечен если у нас там pink тайм-аут стоит одна десятая например секунды то сразу поставок это одна десятая секунды проходит проходит ссылается следующий pink то есть от казани внештатно обрабатываются спасибо если что-то произошло мы не будем там целую секунду ждать пока можно будет снова пингануть спасибо за доклад у меня вопрос про то как вы хиндли те изменения протокола например у вас вы добавили например какие-то поля дополнительные ваш эдипе пакет который сбрасывается и как вы скажем так вы вводите новую версию узла в кластер либо вы там останавливайте все поднимайтесь на воде если вопрос в том как это делали ту никак потому что протокол пока что не менялся если вопрос как в дом как планируем это делать такого расширяемый он сделан как как словарь каждое сообщение каждый кусочек это словарь который можно добавлять новые ключи новые значения и расширять протокол можно добавляя новые ключи игнорируя их на старых узлах например так так что протокол вполне себе расширяемый что пока это было не нужно спасибо спасибо за доклад у меня вопрос такой я живу в сети где нет ни брат каста то есть не бывает как быть в таком случае не использовать после если нет люди пик как он политики работает спасибо за доклад не вот вопросы я так понимаю отказы все-таки сейчас осматривали сильно отказывал зла а вот если отказ ленка всматривались ну то есть причем он может быть может быть более сложным да то есть там в одну сторону до отказа например если произошел отказ лины лидка узел все еще живой значит для него может достучаться через другие узлы суматре делают понятно но имеется виду что он может быть более сложная отказ такое что там версии еще несколько веков отказала и так уж совпало что через них пустого пытаемся достучаться ну тогда не достучимся будет отказ если он на самом деле этом он сам об этом узнает и он был оборотную сторону будет опровергать и слинки все еще не подчинены он опять будет объявлен отказавшим когда-нибудь но это над починить будет просто есть еще у кого то вопросы спасибо а почему выбрали вариант с просто с тайм-аута мини посредством их и детекторов например чего фиксировал детекторы то есть на слишком сложно story mode ими проще мира задача не настолько сложно придумать что-то такое и кластер они не настолько гигантские чтобы это было реально полезно спасибо за доклад что будет если класть их на две части развалится например если он территориально распределенной и связь между объектами отвалилась ну одна половина будет считать другую недоступный на связь восстановится они опять соединяться чтобы быть нормально но это восстановится до по траве спасибо есть ли вопросы привет а есть какие-то средства администрирования сможет ли админ в x3 ситуации затей на ногу и сказать тебе показалось вот так живо ну то есть послать грубо говоря туда внутрь совать свой event интересно нет так нельзя но это можно было бы сделать ты можешь про послать да но если он не дойдет если хочется форсированно сказать что узел живой он уже добавлен ну и плюс удалить тогда опять добавить если не хочется удалять лишние пилотом какой-то полезный был который терять не хочется если у кого-то еще появиться вопросы их можно задать дискуссионный зоне какой вопрос вам показался наиболее интересным можно даже выбрать 2 ну вот человек не просто что презентации бумага улудаг прогнать вопрос хороший задавал там опечатки пока вы замечательный человек знаю кого еще выбрать себя нельзя выбрать кто отвечал я уже забыл просто поднимите руки кто отвечал а я задавал вопрос а вот например человек все вопросы хорошие не знаю что выбрать но лучше всего конечно же ваш доклад блага благодарим спикера за этот прекрасный клад"
}