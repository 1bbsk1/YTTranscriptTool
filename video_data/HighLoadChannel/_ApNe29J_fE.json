{
  "video_id": "_ApNe29J_fE",
  "channel": "HighLoadChannel",
  "title": "Такой код понравится вашим юнит-тестам / Александр Новиков (Делимобиль)",
  "views": 1059,
  "duration": 3057,
  "published": "2020-07-17T06:29:03-07:00",
  "text": "здравствуйте доклад бы мне новиков некоторое время назад я работал в компании деле mobile это важно потому что например дальше докладывают на тему аренда автомобилей вначале доклада я сформулирую проблему расскажу о своем пути кинет с там с какими сложностями и радости мнение на пути встретился на практике когда сформулировать проблему в конце этой части оставшись есть доклады будем искать решение для этой проблемы хочу начать с того что сейчас у меня нет вообще никаких сложностей отношениями тестов но так было не всегда в начале я видел только недостатки и не тестов и прошел несколько этапов на первом этапе мне казалось что юнит-тесты это такая модная экзотика тогда в печке проектах уже начали говорить про unit тесты по крайней мере вот это работал профессионал chrome там начали внедрять юнит-тесты внутри до компании андрей чернышов он сделан интересный доклад даже сейчас помню отдельные моменты оттуда но к сожалению мне тогда не посчастливилось прикоснуться к и не тестом потому что мне был на рабочем столе монитор а на нем была сверху донизу написано слово static стать ecstatic то есть сложно было писать моки static был написан потому что нужна система работала быстро потом ее переписали тесты добавили ну как искал меня это не коснулось вообще я тогда не понимал зачем нужна и не тесты то есть их конечно интересно написать но похоже очень на лишний труд потому что когда мы делаем свою работу мы сами себя проверяем потом проверяет человек который ставил задачу потом там сотни пользователей есть который проверит тут как бы на свою работу на задаче не хватает времени еще нужно найти время на юнит-тесты как минимум тут нужно в два раза больше печатать кода и это я отмечу как первый недостаток и не тест в которой я обнаружил вторая стадия отношений тестами наступил когда я попал в компанию где все было стильный прогрессивно там стояла задача покрыть тестами критически важные части кода то есть кот был уже написан он работал на продакшен не нужно было просто вот миссис скотт покрыть тестами чтобы там чего-нибудь не случилось потом и тогда мне довелось мне довелось по писать тесты на чужой код не могу сказать что это занятие правилам не примут в крайнюю степень уныния но где то рядом с этим в крайнюю степень не я пришел когда пришлось вносить изменения в покрыты тестами код то есть это было очень сделать сложно небольшое изменение в коде требовала там часов на то чтобы разбираться с тестами чтобы их поправить и чтобы они снова проходили поэтому второй недостатки не тестов трудно вносить изменения на самом деле я тогда заметил что не весь код обладает таким свойством были места которые вложились на которые unit-тест сложились очень хорошо дальше буду говорить про преимущества по-настоящему оценил я unit тесты на третьем этапе тогда у меня свалился свалился очень много чужого кода прямо целый проект он было год уже в эксплуатации это было интеграция системой внешней фермой с этой фирмой был еще заключим договор и в договоре был пункт о штрафах то есть если мы ни во время оказываем услугу то приходит сразу штраф и вот в компании были интересные люди проджект-менеджеры им хотелось знать от чего сегодня пришел штраф на 100 тысяч до не приходили ко мне и спрашивали от чего штраф к какому отделу может быть стоит снизить премию там в общем все были на нервах на самом деле такие ситуации происходили не так часто все-таки система уже находилась год эксплуатации все была отлажена проблем проблематично был то что у менеджеров было желание чтобы я доработал код внес туда какие-то изменения как вы понимаете в такой напряженной обстановке вносить изменения можно было максимально аккуратно вот система не знакомы я решил провести рефакторинг ядра это систем чтобы наконец понять как она работает что я делал я изучал код как только понимал какой фрагмент просто носил его в отдельный метод или в отдельную функцию мне было важно не только разобраться с логикой вот этой системы но также убедиться в том что созданный мной функция не содержит ошибок и при этом желательно был убедиться в этом до того как они попадут на продуктовый сервер как полноценную проверку можно было выполнить только там спустя какое то время рефакторинг был выполнен новая версия оказалась на сервере и тогда вот я очень сильно удивился тому что при таком огромном количестве внесенных изменений но ошибок практически не было система работала месяц за месяцем все было стабильно и вот первое преимущество которое нам дают юнит-тесты то что меньше ошибок доходит до пользователя потому что меньше ошибок попадает на сервер сейчас я наверное нахожусь на четвертой стадии мне уже есть несколько проектов которые на сто процентов покрыты ими тестами один из них длился 4 месяца опять который должен был представлять этот сервис был известен заранее поэтому вот все началось от роутинга и контроллеров процесс разработки чем-то напоминала доказательство геометрической теоремы только наоборот то есть вначале делать слой верхнего уровня вместо логике нижнего уровня подсовывали заглушки потом делать логика в них потом значит дошел до инфраструктурного уровня написал адаптеры для подключаемых библиотек и чтобы проверять вместо объектов этих библиотек подкладывал тоже заглушки и в общем то все на этом работа завершена теорема доказана то есть unit тесты дают нам такое преимущество что часть части кода проще ты куда стыкуется то есть можно написать какой-то класс запустить его методы еще до того как внедренные в него объекты зависимые классы будут написаны и попутно можно выяснить интерфейс которые эти зависимы объекта должны предоставлять и потом реализовывать только этот интерфейс и не как бы не ори зовут свои фантазии об этом интерфейсе где-то через два месяца мне предстояло узнать что благодаря юнит с там части кода не только хорошо стыкуются но также хорошо и раз соединяются то есть ведь через месяц была готова первая версия после того как поставили техническое задание начали и проверять и выяснили что сервисы которые мы подключаемся они не так работают как ожидалось соответственно стал добавляться логика чтобы обработать вот эти вот дополнительные случаи например повторные запросы по специальных пользователь создавался какие-то дополнительной проверки в результате объем кода в этом сервисе увеличивался и количество unit тестов тоже увеличивался она достигла где-то 300 файлов и в них не было тысяч проверок но все равно очень удобно появлялись какие-то трудности и знаете у нас были менеджеры у них нет нет бесконечного терпения в один момент терпение лопнуло и мы перестали пользоваться растопи я этого внешнего сервисы подключились к его базе напрямую в результате сократилась логик намного упростилась код вы баба за сократилась приблизительно треть и она отправилась форму вместе с третьей частью написанных ими тестов в общем неприятно но зато это произошло очень быстро что я сделал я просто удалил две папки запустила тесты посмотрел какие из них упали и приблизительно мне прямо показал показали они те места куда куда потом подключил новые модули который работать с внешним сервисом через его базу хочу еще отметить одно преимущество и не тестов это полное тестирование с меньшими трудозатратами unit тесты на самом деле очень экономные они позволяют то есть для работы для разработчика не намного удобнее удобнее чем интеграционные тесты традиционных тестах системы наблюдать такой как сейчас говорят белый ящик мы что-то подаем на вход смотрим состояние и пробираясь сквозь слои опосредованности пытаемся понять сработала то или иное условие который мы добавили в код при прохождении данного сценария не сработало но дело в том что в нашем белом ящики сценариев содержится намного больше чем нам того хотелось есть такое понятие комбинаторный взрыв в качестве примера если взять 22 модуля которая работает связки скажем один главный другой подчиненную каждого по 10 вариантов работы и в итоге мы получаем там со 100 комбинации нужно написать 100 тестов что проверьте эту систему полностью если же мы проверяем модули по отдельности по частям то нужно написать всего 20 тестов еще один момент это доверия ходу код покрыты юнит-тесты вызывает больше доверия положим у вас выбор между библиотека которой покрыта тестами и которые вообще без тестов нам нужно подключить свой проект вот какую бы вы выбрали я бы выбрал естественно первую так который с тестами потому что во первых от говорит о более серьезных намерениях автор а во вторых если даже для тех будет заброшенные будет можно подхватить разработку этой библиотеки так вот собственно выше я рассказал о том какие есть уверен тестов преимущество который я заметил и есть недостатки в чем собственно проблема проблема я вижу в том что вот эти при ему вот эти недостатки мешают нам пользоваться полной мере преимуществами unit тестов то есть из-за них мы отказываемся от автоматически от автоматической проверки кода и как следствие очень много времени тратим на то чтобы искать ошибки в коде намного лучше чтобы это делали это делал до нас компьютер автоматически нельзя ли сделать как-нибудь так чтобы сократить влиянием этих недостатков и во всю мощь его воспользоваться преимуществами вот давайте поищем причину почему юнит-тесты ну получается сложными сложными в поддержке сопровождении не знаю сразу сразу озвучу свой вариант мне кажется что основная причина в том что unit-тест длинный изображено таким длинным прямоугольником в нем содержится много всего ссылки есть внутри себя есть на внешний внешние части системы и такие длинные юнит-тесты очень сложно поддерживать дальше можно спросить себя почему юнит-тесты получаются длинными очевидно они длинные из-за того что методы которые они покрывают тоже длинные и соответственно если сократить метод сократятся и не тесты и работу наш станет намного проще соответственно в качестве решения я приду предлагаю писать короткие короткие методы но как это сделать мы же не можем взять функцию выкинуть оттуда то что нам не нравится и эта же часть тоже выполняет какую-то работу так сделать нельзя в этом деле нас спасет делегирование суть его состоит в том что часть работы мы поручаем важным объектом делегирование бывают двух видов один из них от композиции когда вложенный объект имеет приблизительный тот же срок жизни что и контейнер в котором он содержится при этом все вызовы в ложе все методы много ложного объекта вызываются из контейнера и второй вариант агрегирования когда такой сложный объект может присутствовать в нескольких контейнерах и причем этих контрим контейнеры могут быть разных классов ну очевидный пример баз данных если мы при помощи делегирования разобьем код на части как вот показана значит слева класс рэнд мы его разобьем на части в результате у нас получится много вспомогательных классов которые возьмут на себя часть работы и возникает вопрос где их размещать лучше всего их размещать в папке там же где лежал исходный длинный класс потому что ну как бы на на этом уровне влажность вложенности остается такое количество такое же количество объектов то есть не получается там путаницы каши и и другое преимущество в том что не нужно добавлять блоки юз чтобы подключать эти объекты то есть подключать классы этих объектов несмотря на то что большой лайк мы разбили на части на эти части должны работать совместно и чтобы их заново связать используется либо контейнер зависимости либо фабрики объектов либо и то и другое вместе но это мне не буду останавливаться в том же дальше примере будет примеры фабрики и контейнера то есть вот такая гипотеза если следовать принципу kiss и делайте методы короткими то сопровождении unit тестов тоже упростится теперь давайте проверим эту гипотезу на практике возьмем длинный метод поделим его на части и посмотрим какие будут тесты проще ли будет ок сопровождать примера из по теме аренды автомобилей то есть из классы рэнд аренда в нем есть метод start задача этого метода начать аренду в распоряжении этого объект имеется база данных метод start должен проверить наличие банковской карту пользователя а дальше он должен проверить наличие топлива автомобилей и наконец выполнить сначала аренды по сути внести в базу данных запись о том какой пользователь q автомобили и в какое время арендовал этот метод start он довольно длинный на один экран не помещается поэтому на нескольких слайдов щас посмотрим что внутри каждой из этих трех частей что проверит наличие наличие банковской карты нужно получить информацию о пользователе для этого базу данных отправляется запрос нас интересует поле карт поле поликарп таблицей user нужную запись находим по идентификатору дальше выполняется проверка то есть если банковской карты не привязанные там содержится 0 и то выбрасывается исключение аналогичным образом полнеет проверка наличие топлива автомобиля извлекаются данные об автомобиле если в поле сил показано что содержится но литров топлива то начинать начинать аренду смысла нет пользователь сразу не сможет завести автомобиль и в этом случае выбрасывается исключение и наконец третья часть начала аренды здесь базу данных вносится запись после выполнения запроса в базе данных появляется записи о том пользовательская ким одеть в котором какой автомобиль и в какое время арендовал получился такой раздуты метод и цели сдуть его сделать короче часть логике при этом перетечет другие методы и другие классы для этого будет использоваться делегирование давайте выполним рефакторинг это новый класс называется чек торрент то есть аренда с проверкой нем также присутствует метод start но в этом классе уже нет базы данных также называется по другому и изменилось сигнатура метода start то есть ум на вход ничего не не принимает идентификатор начнем с того что поручим проверку наличия банковской карты другому классу для этого создадим приватный свойства юзер внедрим объект класса юзер через конструкторы и вызовем у этого объекта метод рик verben карт который проверит наличие банковской карты наличие топлива проверяем аналогично то есть создается приватные свойства кара через конструктор внедряется объект класса корр и у этого объекта называется метод рик вальфул который проверяет наличие топлива автомобиля и наконец проверь регистрацию начала аренды мы делегируем объекту класс app and точно также через конструктор не внедряет конкретный экземпляр падает приватные свойства и потом вызывается этого объекта метод start то есть в отличие от первого варианта новый метод получился намного короче не в него всего три строчки его очень просто покрыть тестами но я пока не хотел переходить к тестам разобраться с рефакторинг с ре факторингом до конца то есть здесь нет ни одной строчки из первого варианта куда они подевались логика которая отвечает за проверку банковской карты попала в новый класс юзер у него есть метод рик verben карт куда собственный попал этот кусок логики в распоряжении этого класса есть нотификатор пользователя объект который ссылается который работает с базой данных оба эти значения ударяется через конструктор ой который проверяет наличие топлива автомобиля попала в класс корр он построен так же то есть индикатор автомобиль имеется распоряжении объект работающий с базой и 2 второй кусок логики длину методы попал сюда и последний класс рэнд аренда в нем есть все что чтобы сделать запись а начали аренды то есть индикатор пользователя дефек от автомобиля и ссылка на базу то есть получилось три таких маленьких вас у кого то может возникнуть вопрос что же на каждый метод который был там начали нужно создавать по 3 но новых объектов на самом деле нет их можно перес пользовать то есть класс исходный рэнд днем помимо метод start на и на следующее будет метр метод финиш а для окончания аренды очевидно там тоже нужно будет залезть в похожей таблицы вот то есть эти новые объекты можно будет перри переиспользовать итак у нас получилось вместо одного класса 4 но нам нужно собрать их вместе и эту работу прочим пятому классу а фабрика aren't ее задача состоит в том чтобы выполнить внедрение делегатов соответственно здесь не показано но у нее тоже в распоряжении есть базы данных которые внедрена через конструктор и метод майк чек тренд создает объект аренды серым показано то место где происходит внедрение делегатов здесь много то есть четыре раза встречается слово new и внутрь вот этих делегатов внедряется еще объект базы данных перед давайте посмотрим как фабрика используются перед вами контроллер аренды в нем есть метод начала аренда action старт что из происходит начали извлекаются из запроса идентификаторы пользователей автомобиля потом из контейнера зависимостей получается фабрика который создает аренды и серым цветом показано как от фабрик используется то есть она получает на вход параметры и нотификатор и юзеры пользователи и автомобиля и создает конечно этот объект агрегат чек-чек тренд вызывает у него метод start который выполняет все необходимые действия в контроллере аренды нам встретился контейнер зависимости контейнер для внедрения зависимостей давайте я в него заглянем и посмотрим как создается фабрика это конфигурационный файл контейнера зависимости здесь есть функция для создания базы данных а также собственно функция для создания фабрики aren't особенность контейнер зависеть контейнер зависимость состоит в том что если мы запрашиваем например создание фабрики aren't повторно то перри используется запишем их экземпляры этой фабрике и из контейнера по ключу можно доставать необходимые зависимости то есть мы взяли длинный метод разбили его на части и сделано это было для того чтобы упростить написание тестов итоге чтобы они стали carrot короче их стало проще поддерживать дальше я буду говорить про юнит-тесты причем не просто проявить теста про способ трансформации имеющегося кода в тест то есть это позволяет экономить время часть печатного текста можно копировать и переносить потом эта трансформация действует в обе стороны то есть можно печатать код и потом делать для него unit-тест можно же начать с йонне теста и потом преобразовывать его в код то есть перейти уже к тест реван devil кнут начнем с преобразование класса на экране шапка класса который нам уже встречался это класс юзер проверяющая наличие банковской карты давайте преобразованного в класс для начала нужно подключить библиотеку подключаем печки unit потом нужно создать класс с тестами для этого к названию класс приписывается слова тест почти юнит требует чтобы было на такой формат потому что иначе тесто из этого класса не будет выполнен и он обязательно должен наследовать и базовый класс тест кейс шапка готова здесь я хочу обратить внимание на то что код который мы тестируем и тест получает одно и то же пространство имен но с одной стороны можно копировать с другой стороны все названия классов они как бы зеркально будут и в тесте и в коде то есть мы разобрались шапкой теперь погружаемся в тело класса у класса есть приватные свойства мы переносим в класс тестами причем будем переносить только те свойства которые содержат объекты скалярные не будем функция конструктор конструктор дауна он запускается вначале жизненный цикл цикла любого объекта похожая функция есть в тестах а называется оно выполняется также перед каждым тестом называется эта функция сетап и ее удобно использовать чтобы создавать заглушки то есть по сути здесь мы назначаем конкретное значение для вот свойств класса с тестами при этом кант перед каждым тестом настройки этой заглушке будут стираться и на ее место путь становиться новый новый экземпляр который будет как чистый лист после этого преобразования у нас в тесте появились свойства и они нужны для того чтобы внедрять конструктор при создании объекта который мы собственно будем тестировать и создание будет выполнять в начале каждого теста ну предварительно подготовка завершена можно переходить собственно созданию и нет ну теста на код с будем написать тест для метода рик verben карт название тесты должно отвечать определенным соглашением традициям то есть она начинается со слов test it дальше каким-то образом нужно выразить то что проверяет этот тест можно заснул взять название метода я здесь записала с глагол чтобы соблюсти правила грамматики получился тест и 3 ква с bank карт что можно перевести как проверить он требует наличие банкса карта как уже говорила первым шагом в тесте необходимо создать объект которым будем тестировать создаем объект юзер при этом внедряем свойство ты тот теста до the bass который был на предыдущем шаге в качестве идентификатор убираем произвольные значения для скалярных значений лучше выберу то есть диска для скалярных переменных лучших брать конкретные значения если тест короткие если тест длинные в нем этих скалярных значений может могут быть десятки то нам придется чтобы сохранить читаемости этого теста водить переменные с названиями которые будут пояснять что собственно скрывается за этим скаляром значение вторая часть это лишь часть это основная нужно настроить заглушки чтобы настраивать заглушки нужно держать перед глазами тестируемый код тело метода как настраивается заглушку во-первых мы должны определить что мы ждем на вход какой метод ожидаем будет вызван с какими параметрами и еще в за ложки мы должны настроить что она возвращает то есть это может быть какой-то набор данных либо другая заглушка которая создана строчкой выше в нашем случае мы делаем на ставим заглушку базы данных то есть здесь проверяется то что будет вызван метод fitch один раз с параметрами искали запросам и параметрами к этому запросу и заглушка должна вернуть при вызове этого метода ну строку из таблицы то есть номер банковской карты и наконец необходимо вызвать метод который мы тестируем вызываем метод река варбэнд карт и в общем то преобразование закончена создан первый тест но к сожалению тестер мой метод не полностью не на 100 процентов покрыть тестами чтобы было стопроцентное покрытие нужно зайти в каждой ветвление логике мы же проверили только один сценарий когда банковской карты есть теперь проверим второй сценарий при этом чтобы сохранить себе сохранить свои усилия просто скопируем в новый тест то что был напечатан в первом чтобы сработала другая ветка логике нужно из заглушки вернуть другое значение то есть мы возвращаем карт 0 то есть проверка из 0 вернет true и будет выброшено исключением поэтому в тесте мы должны ожидать исключение есть специальный метод xp expect exception которые погибают от исключение и поверьте тест как успешный как видите во втором тесте был замена всего две строчки поэтому я считаю что копирование копипаст придется не тестов вполне уместен и он очень это очень сильно с в экономит время любой тест пишется по одному выполняются одни и те же шаги в одном и том же порядке просто какие-то из них требуются какие-то не требуются но вот вначале нужно создать заглушку для свойств мы создавали заглушку для объекта data bass функция сетап потом нужно создать объект и внедрить него заглушки свойства это мы сделали в начале теста потом нужно создать заглушки уже для параметров вызова поскольку у нас метод рик verben карт был без параметров то этой части не был в тесте следующий необходимо настроить заглушки вы настраивали заглушку базы данных дальше ждать ошибку если требуется как у нас было втором тесте и наконец после всех этих настроек необходимо запустить тестируемый метод и передать туда заглушки параметров если этот метод что-то возвращает необходимо проверить результат то есть есть специальные функции класса assert то есть acer тыкался сердце инстансов а сердцу и так далее так то есть что было проделано в коде мы взяли длинный метод разбили его на части одну часть выделили покрыли ли тестами теперь можно подвести итоги смотреть удалось ли решить проблемы которые были заявлены начале доклада первая претензия к ими тестом было запрещал в том что больше текста надо печатать может показаться что мы напечатали тесты не в два раза больше авторе потому что появились новые классы их тоже при фабрикой ее тоже надо покрывать тестами но я предлагаю сконцентрироваться не на количестве символов она времени который был потрачен на время мы научились экономить и во первых за счет шаблонности однотипности действий то есть сокращается время на обдумывание что делать следующим шагом вторых копированию же написано кусков теста также сокращает время на описание теста и есть еще один эффекта которым знают только те кто покрывал длинные портянки кода тестами с левой стороны схематически изображен то длинный метод то есть там две проверки которые бросают включение в конце квадрат прямоугольник регистрации начала аренды чтобы покрыть его тесты мне нужно зайти в каждый вид линии и ответственно потребуется написать три теста и в этих трех тестах будет присутствовать часть который является балластом оно необходимо просто для того чтобы добраться до нижележащих строчек тестируемом методе и чем длинней метод тем длиннее будут тесты и там будет больше этого балласта может быть при написании теста тесто вам не так проблематичен потому что можем как говорил о скопировать перенести просто один в один но когда будут вноситься изменения в код то со всеми этими балласами придется разбираться это отнимет очень нас много времени поэтому в нашем случае когда кот короткий тест и короткие балласт отсутствует вторая претензия и не тестом заключал в том чтобы в том что трудно носить изменения поскольку количество строк на экране сокращается понимать такие тесты намного лучше намного проще короткий тест легче понимать с другой стороны тесты стали короче но их стало намного больше может показаться что и работы из-за этого нужно делать тоже больше но я хочу с этим поспорить то есть появляются лакуны которым можно игнорировать на следующем слайде такой будет пример схематически изображен длинный метод в нем нужно поменять вместе изменений в трех местах они отмечены красными кругами естественно что работа над этими изменениями как раз то есть от них это наибольшее количество времени с другой стороны мы не можем полностью игнорировать то что написано в остальных местах тесто и кода во первых это весь длинный код надо просканировать а найти нужные места вторых можно по ошибке задеть какую-то переменную которую через пятьсот строк используются где-то вот и давайте сравним с противоположной ситуации когда та же самая логика нарезанный на части то обнаруживается что некоторые куски вообще можно игнорировать то есть вообще не обращать на них внимания даже они не попадают в область внимания и за счет этого тоже экономится время цена изменения станут сниже ну то есть вот этот подход я проверил на практике вначале я вообще не мог писать юнит-тесты хотел их выбрасывать когда начал менять код делать вот таким чтобы uni теста был проще создавать не получилось делать стопроцентное покрытие тем не менее при написании или теста по могут встретиться трудные случаи некоторые из них быстренько рассмотрим первый случай трудный случай магические вызовы то есть библиотека проедет которые подключают нас к серверу редис и там есть он класс клиент но в нем нет методов get set то что нужно обходить то что необходим для работы с кэшем соответственно создать заглушку автоматически не получится но а печка и юнит представляет нам такой палочка-выручалочка сет метод благодаря которому заглушку можно добавить не существующие методы используют заглушку но обычным образом то есть делать проверки поступающих аргументов и настраивать то что должно вернуться из метода следующие трудные случаи генераторы то есть функции в которых встречается слово и лт они возвращают генератор на самом деле генератор несложно написать вручную внутри теста то есть данный генератор вращает подобие строки из базы данных но точно так же он может возвращать коллекцию других заглушек следующие трудно случае окончательные классы это классы в которой содержится слова файл если автор библиотеки написал такой окончательно класс библиотека пичкают он то есть спички юнит наш фреймворк не сможет создать заглушку такой класс как быть в этом случае если финальный класс расширяет какой-либо абстрактный класс или реализует интерфейс то нам повезло просто используем для создания заглушки это абстрактный класс интерфейс или интерфейс если такой возможности нет то можно подключить через composer удав окружении специальный пакет байпас files который удалит просто погружаемых классах слов файл ну и наконец если можно вообще не покрывать адаптеры в таких трудных случаях тестами однако при этом нужно всю логику оттуда вынести по максимуму то есть например в обертку этого адаптер след трудный случай а файловая система предположим нужно тестировать наш объект работать с файловой системой там что-то копирует например функция ренин как быть не нужно ли создавать методе сада по временные какие-то файлы потом их удалять в тирада down как бы unit тесты должны быть не должны быть завязаны на внешние системы это важно потому что они должны часто запускаться должны быстро отрабатывать если этого свойства не представляет то в итоге они просто будут заброшены чтобы отвязаться от файловой системы есть пакет в фсс стрим который представляет виртуальную файловую систему здесь что происходит создается корневой узел то есть по сути tpabka рут виртуальной системе там file.txt дальше из виртуальных файловых систем и получаем название внутреннее название путей к файлам root ol-tex the new txt и потом вот эти внутренние название передаем тестирование that remain а потом проверяем был ли создан новый файл и пропали удаленный и последнее трудный случай которая затрону это скрытый методы предположим есть два в классе есть два публичных методов 1 of 2 и оба они вызывают приватный метод f3 тот следующий приватный метод f4 то следующие пять разбивая разбивка логике при помощи приватных методов позволяет структурировать код делать его более поддерживаемом упрощает его понимания однако в uni тестах вся эта структура исчезает и если написать тест на 1 2 заканчивать а я если написать тесты на 1 2 публичный метод то там будут большие куски одинаковой то есть происходит дублирование кода не знаю может быть при помощи могет как-то можно решить но я как не пробовал все равно в итоге получается что тут что трудно поддерживать итоге просто отказался от использования приватных метод совсем то есть в коде нет вообще классно с приватным методами только в нет в классе приватные свойства и все методы публичные благодаря тому что используют широко делегирование то есть необходимости просто нет в конце доклада я хочу вас призвать писатель не тесты без unit тестов можно потратить полжизни на то чтобы искать ошибки в коде чтобы упростить поддержку unit тестов делайте методы короткими используйте делегирования для этого чтобы ускорить написание тестов переносите в теста что же напечатанным в классе и если он встретит сложные случаи то для них решение уже есть в интернете нужно просто поискать примеры со слайдов есть в репозитории там также тесты на класс которые вошли доклад на этом у меня все есть вопросы есть там здравствуйте спасибо за доклад итак вопрос касаемо сложных случаев до сталкивались ли вы или как-то может быть уже решали вопрос когда в тестируемом классе используется например текущая дата и результат выполнения зависит ее до если какое-то решение да с такими случаями сталкивался там еще важно учитывать например временную зону ну просто внедряется ну либо обертка либо полный напрямую класс например daytime м ю табл на него можно создавать заглушки то есть я эти объекты создается ну то есть есть специальная фабрика для dat и там нет фабрика используется проверяется только то что вызван метод этой фабрике то есть там не требуется вообще обращаться класса the daytime эта проверка только есть в одном месте в тесте фабрики другу остальных частях коды этого нет добрый день спасибо за доклад александра вот у меня такой вопрос вы как придерживайте сейчас после своего опыта практике тест сестры или код feast ну не буду брать я начинал с того что делал код first потом дело unit тестирование и когда система ну как бы разрастается то ну вам нас ты она знакома тебе ты уже понимает чтобы этого достичь нужно там-то и там-то внести изменения и постепенно я отошел от тест first потому что то есть у меня стопроцентное покрытие кода я вношу изменения потом довожу опять до 100 процентного кода и на этом задача выполнена из теста получится по крайней второй вопрос все-таки ваш призыв вот отказаться от приватных методов как то на мой взгляд не пробовали вы допустим пользоваться риф тех же reflection и ну когда создаете класс кидать его в reflection и делать ему в его приваты делать пабликами а потом тестировать ну-ка цепи где то я читал что не надо вносить изменения в юниты то есть их нельзя правильно да но когда но я отказываться от приватов тоже как то не очень это ну вот мне не мешает я понимаю что они приватные методы очень широко распространен в коде они встречаются но тут приходится делать выбор то есть тогда будут бум будет сложно покрывать тестами и тесты будут такие вот неуклюже св reflection она просто открыть метод мне кажется будет проще спасибо большое здрасьте спасибо за доклад у меня вопрос насчет и именования методов ваших тестов вот я там увидел что test it потом глагол значит с правильным временем нужно делать вот а вы не думали сделать просто например шута что-то там что он должен сделать и все и не париться с такими временами у некоторых фреймворк ах парень это так но это дело привычки да конечно если пишешь shoot the не нужно думать об окончаниях название я согласен так сложился спасибо и в названии помимо функциям там дописываю и втом кайт условия воин как находим число вели авто там после чего"
}