{
  "video_id": "WSwK_c8I1sM",
  "channel": "HighLoadChannel",
  "title": "Оптимизация .NET-приложений под Garbage Collector / Станислав Сидристый (EPAM)",
  "views": 5019,
  "duration": 2929,
  "published": "2020-02-26T12:01:47-08:00",
  "text": "сегодня будем говорить про тут нет и про его горбач коллектор и прежде всего мне конечно же поскольку я выступаю не надо тексте не у себя вот мне интересно кто из вас датчики примите пожалуйста руки авто прекрасно неожиданно да хорошо кто из вас идет носила рим вот остальные посмотрите пожалуйста это же посмотрите что такое стелларию ну вот и это семинар по тут нету которая провожу будет москве начале декабря значит что хотелось бы сказать про тут нет давным-давно вот как вот звездные войны титры мы все писали на большом парке нот и сам gc он выглядел чем-то таким знаете скрытым да вот его описание выглядела такой рекламной прошивкой not к чему-то большому нам говорили что есть там три поколения а даже не мы не нам горы мы вот в первую очередь мы говорили да когда приходили на собеседование на спрашивали как работает gc как работает менеджмент памяти внутри ну как по бумажке ну там три поколения есть да вот в это говорит 2pac аллен кто-то trinus если не понимает как то в общем без разницы но на мне не рассказывали зачем мне рассказывали как это работа с подробности и поэтому не было общего понимания зачем это знать вот и все ждали когда найдутся люди которые про копают это все изучат ну вот и расскажут нам потому что вышел вышли уже исходники но вот об ее спутником можно многое понять и товарищи konrad кокоса углубился изучил но благо команда новая она любит пообщаться вот он себе пообщался то многие вопросы они друг другом порешали ноты в свет вышла книга который это все описывает но вот я решил сделать доклад который собирает всю информацию вместе вот и делает ее из теоретической практичный меня зовут стас и тресты по-прежнему свадеб пропустил вот работая в стеке тут нету но то иногда в основном я пишу конечно на вебе вот иногда когда по большой необходимости ухожу в wpf по совсем большой необходимости вспоминая что такое informs вот и когда это интересно занимаюсь на си плюс плюс но ты один раз наступил в си плюс плюс силой работаю в epam systems и пишу книгу вот сейчас она не только еще не что каждый раз когда выступая говорю сейчас она на паузе вот но постоянно к чему-то готовлюсь поэтому когда готовился нам попалась да вот она temiya можно по вот этим вот контакта начнем все слайды их сайтов немного вот я буду объяснять какая есть проблема как и она решается но в стиле вот знаете этот из книжки как паттерна проектирование да есть проблема и то есть решения то есть если проблема нет решения не надо применять и соответственно сойдут немного но в основном буду говорить первая проблема снижайте кросс по крайне ческую связанность когда мы сталкиваемся с какой проблемой мы сталкиваемся для оптимизации скорости сборки мусора garbage collector собирает возможности младшее поколение да вот он собрал по быстрому и ушел но чтобы сделать это ему нужно дополнительно знать какие ссылки и со старшего то есть он же не может просто взять зайти только в младшего поколения вот встать на какой-то объект и сразу понять что на него нет сок то есть ссылки то извините они идут отовсюду да вот но чтобы собрать младшим поколением у необходимо соответственно прогнать еще по ссылкам старшего вот но старшее поколение она огромна и может быть может быть маленькая консольное приложение он же не знает а то она может быть огромное ну вот и чтобы оптимизировать это вели карточный стол давайте немножко посмотрим что это вот есть такой график но вот на графике мы видим что есть ген ночь gen-1 gen2 слева вот есть lachesis хип его начали кстати называет gen3 вот потому что ноги очень честного называет gen2 вот на что он как бы сбоку и ну как бы никакого отношения до немедленно gen2 и о начали потихоньку назвать gen3 аккуратно вот поэтому если вытянуться беседа никто не говорит что он гента и потому что ну вы не пройдете вот не все же знают что-то или три теперь есть карточный стол карточный стол это такая битовая карта то есть этот но такой кусок памяти линейной вот где каждый бит отвечает за некий промежуток памяти задник интервал вот и если на этом промежутке у нас есть ссылка в младшее поколение the beat выставляется в единицу выставляется на единицы во время присваивания то есть вы делаете присваивание ну вот помимо снова присваивания там еще делаются дополнительные действия вот проверяется что присваивается со старшего младшая если соответственно присвоение идет младше это оставляет соединиться хорошо вот у нас ой а я привык к другому пульту вот он там влево-вправо здесь кнопки всех вниз вот у нас появилась смотрите сейчас блин опять не туда надо привыкать у нас появилась ссылка со старшего поколения в младшие вот и вон там тоже просто один показал это что значит это значит что конце должен выставить единичку все выставил единичку теперь он понимает как бы на что здесь есть ссылочка это место тоже обходить вот и когда соответственно мы собираем мусор вот мы опять же мы не можем не побитого будем смотреть до таки бежим там это критики смотрим но это очень дорого вот мы смотрим там с процессор иными словами да эти 32 раза явно система то сразу int32 1 и 6 4 раза этой системой все четыре вот такими пачками вот это значит что четыре байта над рисовых разрядной перекрывает 4 килобайта памяти либо им в максимуме в максимуме когда объект очень маленькие вот 320 объектов вот если 6 4 разряда там всего два раза больше но объекта тоже гораздо больше поэтому тоже максимум 320 объектов но получается что если у вас старшего поколения есть ссылка в маша то это значит что горбач коллектор когда будет это дело проверять он будет проверять все все 4 или 8 килобайт они будут она там значит двойной там слова на не 0 до такого не 0 а в каком бите там minolta а вот здесь ну значит я туда схожу это дольше вот поэтому он сразу проверяет весь ренч что-то о чемодан почему-то приводит к тому что разреженные ссылки в ваше поколение делает гармонь collection трудоемки понимаем да то есть если у нас одна ссылка отсюда пошла вторая ссылка из другого места 3 там еще откуда-то у нас в итоге будут куча вот разреженных единиц вот карточный стол будет забит разреженным единицами и gc придется проверять огромное пространство на то что там какие-то единичные ссылки уходят ваши поколения как решать ну располагать объекты со связями в ваше поколение рядом то есть когда мы что-то проектируем мы примерно понимаем время жизни но ну мыж там что-то планируем да как то работать будет вот поэтому если мы как-то планируем как-то будет работать мы когда создаем тип мы понимаем что этот тип экземпляра vue будет работать ну примерно вот столько то вот мы не можем предположить что он будет работать например в районе там секунды до на самом деле он прожил пару часов вот мы примерно понимаем это будет работать вот и примерно понимаем что например если мы создадим куда групп объекту то скорее всего она вся на покой уйдет ну примерно в одно время вот поэтому даже если вы не сразу же берете в работу можно сделать пул таких объектов вот проинициализировать они лягут все рядом вот и дальше когда вы будете оттуда делать ссылки на младшее поколение то сколько б там в их ссылок не сделали то в карточном стали это будет в лучшем случае вообще единственный бит выставлен в единицу но в худшем там их несколько будет выставлена но на уровне вот это вот процессор на во слова до 32 бит и 64 бита вот конце будет видеть просто ненулевое значение вот и все будет быстрее работать в этом месте не допускайте сито связанности проблема как следует из алгоритмов сжатия фаза фаза сжать извиняюсь сможешь happy d сжатия куча необходимо обойти дерево проверить все ссылки исправляя их на новые при этом ссылки с карточного стола затрагиваться у группы объектов что происходит при сильной связности вот у нас опять же кота граф вот и мы сильно связано с это не по типам имеется ввиду да то есть не когда мы в интерфейс выходим а именно когда с полей идут ссылки друг на друга и иногда добра для удобства хочется сделать какие-то дополнительные ссылочки чтобы как-то так быстро куда-то сходить нет через там 4 до шага от окрас исходил вот на если связан с очень сильная то соответственно горбач коллектора придется проверять все ссылки вот тем более если объектов много но это будет просто дольше работать фаза сжатие ну вот во первых во вторых если фаза жать и начнет работать а перед например группа объектов которые сильно связаны как раз образовался гпд и продолжать и сработала объекта все ушли на младшей адреса то соответственно горбач коллектору придется проходить вообще все вот эти вот ссылочки исправлять их на новое значение долго не удобно вот решение ну например решение может сделать какой располагать сильно связан объекта рядом до в одно поколение вот я в итоге очень много слайдов будут свои за к тому что желательно вообще во второе поколение все же самом начале вот оно там будет просто жить и никого не трогать вот поэтому если например опять же под цели zero сначала все эти короче выставить связи да ну и грубо говоря сделать двойной g c вот то эти объекты сожмутся вот и их больше никто не будет трогать потому что перед ними там какие-то вечно живущие они сами спланированы как вечно живущие вот и соответственно ссылки не буду там как то и справляться при сжатии ну избегать личные связи в целом это понятно это в жизни пригодится ну вот и для горбач коллектор хорошо избегайте кода со скрытой связанностью скрытно сильно что имеется ввиду ну вот у нас например чит работает да вот и мы такие смотрим там все shop стандарт ношу новый вышел там еще что но выше т.к. все за использую вот этот конечно метод высоконагруженные понятно но вот так будет красивее 10-ом анечку накручу здесь там еще чем накручу вот compact никас клёво выглядит здорово вот а по факту например за того что там какие-то фичи сишарпа используется там происходит огромный мэмри трафик вот там какие-то скрытые объекты выделяется для той же лямды и получается что лишние связи образуются в том числе вашего поколения потому что 0 amt образовалась дабы не и ссылку откуда пошла вот опять же лишние связь да вот если связь пошла со старшего поколения то это лишняя связь карточного стола тоже не очень хорошо если этот код нагружены то нехорошо вот там в квадрате дальше мониторьте использование сегментов на как следует из алгоритмов выделение памяти вот а память выделяется можно опять же сходить на тоже сила ремня канал есть youtube.com стелларию но там вложено 8 роликов про то как работает gc ну вот и там есть доклад один про сила реуса sell or do you вот там соответственно если роли как выделяется память там шесть алгоритму выделение памяти вот тот которым мы знаем вот не вызвали да и просто там указатель перед передвинули на размер нам того объекта который мы хотим со лоцировать вот вот вот этот адрес старой адрес отдали как типа вот выделить память это самое лучше алгоритм сама быстрый он чаще всего работает но все-таки память джона кончается от во-первых она кончается в allocation контекстах то есть на этот память выделяет у каждого потока в своем ну ranger в своем пространстве italian для того чтобы когда не вызывается соответственно не был синхронизации между потоками то есть кому там чё отдать там откуда да но тут либо блокировки либо не блокирующий алгоритма либо китовый free ужас ну вот но чтобы этого всего не делать каждому потоку выделять свой кусок вот отсюда что следует отсюда следует что если вы имеете много потоков то вопросы замусорите смог skip вот ренджа ими которые но ничего не овации руют а и небольшие то есть от 1 до 8 килобайт на поток зависимости от того насколько часто на лоцируют вот но с тем не менее у вас куча пустых буферов которые но стоят и ждут когда же в них начнут выделять память вот эти пустые буферы они просто уменьшают остаток сегмента который был выделен горбач коллектором у windows вот дальше когда вы там на выделяли на уделяли на уделяли то соответственно swig сегмент заканчивается виртуальной памяти до который мы получили от windows на intel и вот надо новый выделить вот такой типа ну дай мне новый я же ничего не стоит и так и пошел вызов уровня ядра сходили в ядро windows такое да есть вот этот кусочек свободен могу тебе отдать вот из ведра вернулись а что такое и за шпиц kernal space переход вот поскольку там соответственно есть ну там кольцо 0 до защиты кольцо 2 защиты и to use space вот то для того чтобы перейти отсюда сюда необходимо про копировать стеки потока необходимо там про еще что-то про копилось проверить уровни доступа там еще что то вот то есть это долго другими словами это долго вот и это во-первых приседа идет проседание во вторых ну как бы не очень хорошо не очень и очень хорошо точки зрения вероятности да то есть вы вызвали new не совсем не ожидали что это может чему-то привести поэтому при интенсивной работе может возникнуть ситуация когда выделение новых объектов приводит к задержкам и выделению новых сегментов под кучей дальнейшем диками ту то есть мы его на выделяли то есть у нас так алгоритм отработал ему нужно было много объектов выделить он такой ту-ду-ду-ду там тысячу да там выделил потом такое но они короткоживущие ему там столько нафиг не надо он сразу раз так освободил вот с точки зрения dota тоже не знает что у вас там происходит он такой так не там кучу сивас выделяет выделяет вот так новый сегмент нужно предыдущий кончился новый сегмент ужин так выделил сегмент потом так все так освободилось а не нужен 1 освободил сегмент то есть он выделил специально да он понял что он не нужен и освободил медленно как-то понять но с помощью например perkman как монитор от sysinternals можно проконтролировать точки выделения новых сегментов то есть вы натравливаете perform на программу и смотрите как там сегменты выделяется там прям видно хорошо вот если они постоянно выделяют освобождается то это значит что надену можно быть лучше использовать pulling опять же сделали пол из пула достаете освобождаете потому что ну как бы по хиггинса объект это как бы но на мой взгляд это оператор new и получение цис это чисто такое религиозность как бы связь да то есть можно и спала получить это тоже будет новый инст он спасая по сути то но никто же вас не просит конструктор дергать а если речь идет о life оптический pen в котором идет плотный трафик буферов можно воспользоваться рей пулом прекрасный класс ну вот рэп ул он был недавно создан его прекрасно стива супер истеричность заключается в том что вот вроде как у него запрашивайте паулы до определенных размеров а он вам выдает не тех размеров который вы просили ну да вот это вам чуть больше может быть вот потому что когда он их выделяет он их выделяет ну с некоторым шагом вот и вам отдаёт чуть больше но вам он отдает не рэй а помню спин или memory ну вот то есть указатель на собрались у этого массива вот и вам-то чего вам просто нужен был раньше да но какая разница рейтом или нервы 2-му раньше нужен куда можно писать записывать not вычитывать но а когда вы освобождаете он возвращается в пол с тем самым поскольку оно происходит с некоторым шагом размер этих массива выделяется то снижается как тасс он называется диск фрагментация вот снижается фрагментация да вот и соответственно снижается вероятность того что вызовется горбач college а если речь идет о смог скиппи надо убедиться что объект одно и то же времени жизнью выделяется рядом вот почему это важно вот и прикольно знать потому что грина горбач collection на 2 вот и оба работают оба алгоритмы работают и смогут о гриппе и влачил теперь вот 1 гарри там это сжатие он не работает по умолчанию happy больших объектов можно дорогая операция мегабайта туда-сюда да вот второй алгоритм это называется sweep вот это алгоритм ну как бы я сказал это что-то типа из мира си плюс плюс да когда у вас на хит с объектами вот и когда освобождается память вот эти вот дырки они список добавляются список свободных участков и когда следующий раз кто-то просит выделить память то сначала просматриваться с список этих дырок вот а потом уже если там ничего нет ну короче там сбоку выделяя ну вот когда там выделяется память то соответственно что там все там не просто список этих дырок там как бы в как вот в dictionary да там есть bucket и баки в пакетах и сети списке bucket организованы по диапазонам с размера свободного пространства то есть она все оптимизирована вот если вы объект и одно времени жизни выделите рядом плотника так вот зная что на покой ты они уйдут примерно в одно время и вот они в одно время на них от пуститься ссылка то вы вместо того чтобы сделать кучу маленьких маленьких маленьких дырочек через весь хип вот что в дальнейшем приведет к гармонь collection ну да потому что куча маленьких дырок они как бы ну никому не интересно туда ничего не положить вот если вы вместе положите и отпустить этого сделайте большой такой классный пробел который потом забьется другими объектами дальше не выделяйте памяти у нас груженых участках кода ну я примерно тому же говорил но смысл в чем то есть объект участок кода нагруженный вот там прям вот файлов до участок кода вот та интуитивно понятно что если там выделить память то вы получите просто но прекрасная возможность получить еще highload garbage collection вот поэтому не надо так делать вот я не буду там сена за вы проговариваете принципе все же проговорил вот как надо решать ну полный запрет на использование замыканий в тех участках которые нагружены потому что замыкание это создать трафик полный запрет ну тех же например работа со строками до они опять явно что-то вы выделяют память полный запрет boxing она граничных участках кода ну здесь да галочка это написано что boxing принципе я на критичную сейчас кого-то еще не видел вот на дальше там где необходимо создать например какой-то временный объект под хранения данных но мы возвращаем из метода что-либо до но ни одно а надо как два значения будет вернуть вот ну и такая привычка есть сделать тонкую отец там два поля воз принцы визировать вернуть а снаружи их за использовать вот так делать не надо лучше использовать структуры потому структур они вообще ничего не стоят это вообще прекрасный недооценённый инструмент он просто замечательный вот сегодня в бете в голову себе пожалуйста структура замечательных надо любить вот потому что они ничего нам не стоит вот и нам даже разработчики в новых версиях языка сделали еще один супер эпический инструмент просто бомбически это кортежи то есть вы можете из метода вернуть вот скобочки кто скобочки используют кортежа вы молодцы прекрасная штука вот просто берете кортеж сделайте два значения опа а снаружи ну вообще класс вот я например кортежа еще очень сильно полюбил но отвесе еще не спал не использовали пишите deconstruct extinction на киеве repair то есть использовать такое нет да а а уже есть а у нас просто видимо 20 под старину вот декан руки и великий рада и соответственно эти foreach по словарю мест вот это вот кий вылью да вот это вот кто потом слышно код atc непонятно ты о чем вообще вот вот вы просто даете имена вот это ключ можно так и оставить не оставили написать что-то более вразумительное и вообще прекрасно вот а лучше риф страх потому что я страх несмотря на то что это ключевое слово орех вот мне интересно писали вроде английском англичане да вот но англоязычные люди почему лев лев тетрадь начать эту ссылку на структуру ну ладно вот орех шахта это короче структуру который не может быть ни можно skip уходить то есть это интерес но на самом деле или andreev я уже не знаю как лучше то есть это полный запрет на уход хип шикарная вещь дальше избегайте лишних выделений памяти washer засыпем это вообще говоря совет на все на любое это вот везде да откуда не придете да да знаем вот ну я же пишут проблемы и решения размещение массивов life is happy приводит к фрагментация да вот и соответственно жалею процедур garbage collection но но иногда очень сильный хочется что-то разместить большое вот это вовсе не чувство того что ну занять как можно больше места собой вот а потому что надо как такие проблемы решаются ну например можно использовать разделение массивов на патмосе вы да то есть у нас есть огромный массив не то что у нас есть нам хочется использовать огромный массив бешеных размеров вот который гарантированно идет логачев захид вот руки трясутся так сказать страшного в руки делают вот но как этого избежать мы же знаем что туда уходит 65 и выше да ну тысяч байт вот на вот тоже кто не мешало сделать 65 64 килобайта учишься 5000 байт ну неважно соответственно мы просто мозге мозолит 1024 же всегда вот 85 точно и соответственно что что надо сделать мы берем в у меня примерно считаем что там массив наших структур он будет таких размеров ну например на 1000 элементов на 1000 элементов он должен влезть но еще больше но не уверен вот надо считать более аккуратно тысяч элементов должен лезть 1024 еще лучше почему еще лучше потому что отделить очень быстро да на тысячи 24 что поделить надо сдвинуть на 10 бит вот двадцать четыре элемента вот и дальше делаем что-то типа листа то есть обертку от внутри этой обертки рей ссылок на рее по 1024 вот и когда мы элементу до накидываем то соответственно он динамически расширяет cd вот а по индексу чтобы получить доступ на очень просто получая доступ по индексу мы что получить номер сдвигаем индекс на 1000 на 10 бит делим на 1024 вот а чтобы получить индекс внутри этого рея мы по маске просто сбрасываем ну 1023 да по маске вот получаем индекс очень быстро операция ничего не уходит задачу без skip шикарно но еще надо контролировать используя добавка ну что у дабл от 1000 и выше он уходит слаще риски при любом случае хотя это не 85000 быть где оправданное возможно надо использовать red stag стек потока до что имеется ввиду если есть какой-то ряд к сверх короткоживущих объектов либо объектов которые живут в рамках вызова метода вот они создают трафик объектов да например например на то о чем я тоже говорил но смысл в том что есть какие-то объекты типо типо типо дата объектов там каких то вот либо там не знаю опять же нужно из методу что-то вернуть ну что то что живет очень-очень бы очень-очень быстро но мало вернее вот но этого этого достаточно много создаются и поэтому создается некий трафик вот этот трафик забивает кучу потом при освобождении создает дырки вот эти дырки ничем забить системе выделения памяти вот и поэтому происходит сборка сборка мусора ну решение там где возможно до выделять пайпинг на стыке вот выделять на память на стыке мы умеем кто пользовался когда-нибудь 100к лаком о как там рисковые люди вот рисковые но как бы в душе на самом деле все безопасно вот смысл в чем смысл в том что когда вы выделяете память на хиппи да то соответственно вы на самом деле еще больше рискуете вот тем что начинаете связываться с такой машины как garbage collector вот когда вы выделяете память на стыке а что такое выделение памяти на стыке что такое щипаний посты и т.д. вот этот метод пишете о место вокальные перемены вот и когда метод запускается то где эти переменные хранятся они хранятся us такого потока да то есть это структура данных на вот я бы даже сказал уровня процессора но вот когда которая позволяет методом иметь свои какие-то вокальные данные вот метод вышел вот так прям откатился методы вот ну и тем самым автоматически памяти сводилась следующий вызвался поверх обнулил по использовал вышел уже еще не используется вот ничего не стоит использовать память на стыке вот но локальной переменной это одно мы же не будем то есть если кто то массив да мы будем там типа делать 50 локальных переменных от 0 до 49 но вот мы вместо этого воспользуемся 100к лаком вот там тоже есть ст эколог это команда сишарпа вот не новая она уже давно с первых версий которая позволяет выделить нa некоторое количество памяти среди локальных переменных скажем так то есть на стыке потока нот то есть выделить грубо говоря массив фишка в чем фишка в том что этот массив автоматически исчезнет это вам ничего не будет стоить когда возьми тогда вы едите вот то есть он ну как локальная переменная исчезают да так и массив исчезнет вот но что крутого то что до появления спин-офф ст эколог он как бы возвращал неуправляема указатель то есть если вы там вы делите на просто колок чар там например там 256 до то вы получите чар звездочка вот если вы получаете чар звездочка это автоматически влечет за собой что он сейф до инсеев на метод вернее он сейф блок анцев на мета танцев на класс и там еще сборочку идете так и ставить инсеев то есть вы знаете так вообще не что вас так ну такой так как лицензию заставляя подписать у точно в этом уверен вы точно в этом уверена но вот точно подумали да но смотрите вот на сборку поставили на то капец как но надо быть уверенным чтобы это все вас воспользоваться ну это же не кода это прям вот прям сборка то есть мы ее надо пометить что она блин ansi она не безопасно и все короче ну все обсе округ безопасно она нет того нет надо чуть другой использовать вот то теперь вы можете использовать спины спина не оборачивают вот они оборачивают этот кусок памяти и делает его безопасным то есть он и тот же кусок будет небезопасно достал безопасно прикольно но неважно вот а еще в чем фишка получается в чем фишка получается в том что поскольку вы используете спины аспена и тариф strap реп это не знаю что ссылка да то значит у ссылку нельзя сделать вот вот спина to reflect вот из этого следует что вы не можете эту ссылку никуда в другое место сдать то есть как только вы выйдете из метода вот вы потеряете вот именно вот эту ссылку xd вот память за чистится вот и никто не сможет это память им воспользоваться то что да действительно до того как был спин и был час звездочка этаж чар звездочка она как бы безличен и вы можете вообще кому угодно touch or задачка отдать вот он куда-то ушёл до такой все вот а сторонняя сторона она такая ну а метод вышел там все он уже отработал все другой метод пошел работать остальная страна такая ну там от дуб лилась из другого потока дай-ка я прочитаю что там поэтому в этом буфере было а там уже данные другого метода то есть но либо запишу да вот сейчас все безопасно шикарно пользуйтесь великолепная штука сейчас докажу есть два таких примера показывать не будут сами поищите вот-вот ну потому что для первого метода придется лезть в исходнике принца во втором высотники тут на этом вор к в или stringbuilder начнем с него классная вещь вот всем советую использовать просто вот постоянно советую использовать но disney's анкара internal вот находится высотник а тут носим варка вот мы чтобы вы использовать надо сходить на reference source microsoft.com найти его вот и скопипастить себе но такого впрочем я советую да вот почему если взять stringbuilder а вот обычный стрим builder которым вот приходишь на собеседовании вас спрашивают а и здрасте-здрасте вот есть такая строчка a + b до a + b вот нормальная строчка не нормально что думаете вот такую же ну не первый раз по собеседованию ходите да нет не нормально почему да потому что там память выделяется ну правильно правильно вниз не смог да вот это самое подковырнуть ну вот фишка то все мы стоим builder с фишка в том из компьютеров что он является 1 связанным списком самих себя он как бы не настолько клёвый как бы ну как выглядит то есть он точно также прокомментирует так вот односвязанны список самих себя вот и каждый сам себя да он ссылается на крутом арочек вот маленькие куда вот он соответственно аппендицит но мы как бы получается что если у вас не так уж много в синем всего ожидается вот и вы при инициализации стрибера не передали к тесте то но точно также получаете фрагментацию как в общем то получали до этого но с большей уверенностью что вы делаете все правильно ну вот что такое в или stringbuilder в лес там builder это стэм builder на локальных переменных вот крутяк дак вы просто exception в голове как так то есть вы а это экстракт тип вот и для того чтобы он принц или не раз он принимает себя s pen вот aspen это вот пункт два стенда инициализируйте с помощью стекол окон то есть помощью стека лаков вы создаете буфер вот потом так буфер передаете в или stringbuilder и в или стрим builder на этом буфере начинает строить строчку получается что вы строите строчку на локальных переменных вот вы вообще ничего не лоцируется в принципе где-то может пригодиться это может пригодиться практически везде потому что практически везде мы делаем трассировку и важные строчечки эти строчки они в принципе достаточно предсказуемы и длины то есть вы можете просто снять дам посмотреть что эти строки они не превышают а например 200 символов вот если превысит он выделит память то есть он не свалятся сексе пшеном типа ну привет production вот нет он выделит память рядышком вот но как бы в большинстве случаев да на основе вот вашей статистике в крепости выставили он не вы он не будет выделять память вообще то есть он будет работать на месте шикарная вещь тоже самое стык лист такой же класс вот ну как такое же не совсем такой же вышел набрал ну вот на стык листа он структура обычная то есть ребята из блин сэтапом криус скрыт он рассказывал несколько лет назад вот от обычная структура вот они заметили что несмотря на то что нужно хранить много элементов и чаще всего это какие-то листы да ну вот элементов на самом деле хранится не так много как правило 1 или 2 вот зачем тогда листа лоцировать вот они сделали структуру который хранит два элемента вот а третьим элементом идет ссылку на настоящий лист вот если короче а д д а д д вот еще 3 появился да вот тогда листова целуется вот а если нет то в общем структура хватит освобождайте объект как можно раньше ну вот вы можете задумать объекты как коротка закат короткоживущие да вот они на самом деле не такие же кратко живущие могут оказаться почему потому что опять же какой то цикл в этом цикле вы начали что-то там выделять выделять выделить лету трафик трафик трафик трафик трафик до короткоживущих объектов казалось бы вот газ от такой типа ну извини у меня как бы окно vacation закончилась мне надо бы там чуть почистить а ну а тебе там поколения + 1 вот что значит а знать что ваша сыр короткоживущие объекта да вот это вот пачка вот она вся ушла в первое поколение и в ближайшее время она собрана не будет вот она вся в общем немножко подождет вот кстати говоря ну времени мало кто нибудь затем не вопрос потом почему три поколения я вам расскажу интрига вот вызывать garbage collection не нужно иногда очень хочется вот взять до вызова тетка будто бы сделал полезное дело да вот но не нужно лучше взять и прочитать книжку конрада кокосового в ней всего лишь 1000 страниц но и понять как это все работает почему ггц вызывает мне не нужно потому что когда вы вызываете gcn вы даете пинок по статистике горбач коллектора вот и например может быть такая ситуация живая но та ну громко солода типа статистику испортила что испортил то такая ситуация жил был поток то в одной стороне вот живет живут ничего не делает вот и тут у него как раз собственно должен должно что-то вас триггере цион начать что-то очень активно выделять вот но в другом потоке что там происходило вот и на всякий случай перед стартом всего до конца можно сделать когда что-то грандиозное решили начать делать abby c collect что-то там начинаете фигачить вот он такой коллектив а что он делает он смотрит что этого потока я ничего не выделялась значит он и не планирует выделять вот значит следующее окно локации которым будет выделено этому потоку она будет маленькая один килобайт тут уж ничего не планировал ничего не получишь вот и тут ваши поток он просыпается начинает как бы яростно что то делать вот срабатывает еще один год garbage collection вот ему такой тип ну ну вот я один килобайт уж ничего не планировал ну вот а мог получить 8 понятно да вот лучше взять профилировщика вот взять какой-нибудь от sysinternals перф монитор там еще что то там посмотреть почему проблема возникает и вычистить вот проблемные места воспользовались своя тайна на данную доклада избегайте pinning опенинг это вообще капец вот это жуть то есть когда вы пинаете горбач коллектору тему приходится то все обходить вот прям вот реально вот если книжку возьмите у кого кокос а там прям к шикарно об этом а можно можно на ю тубе посмотреть доклады мои теорию вот там тоже там все на графике все показано вот просто и читать надо да здесь можно 80 посмотреть торсом и вот и в чем фишка а фишка в том что когда open улица то а вокруг за pin объекта что та зассала ци равана то когда конце идет муж надо как-то ну сохранять промежуточные данные он сохраняет когда вот минуется объект да чтоб понять что куда передвинуть он сохраняет эту промежуточную информацию поверх запинала на объект а вот ну сохраняя с те данные которые там лежали куда-то себе вот и дальше когда все завершается он должен эти данные вернуть то есть опять поверх за pin объекта записываться в старые данные но то есть там куча каких-то левых операций это не прикольно вот решение не надо так вот там есть одно еще на самом деле решения дело в том что pinning два типа есть два типа пилинга а первый ти пинга это когда вы делаете прям железный джесси handle то есть вы прям создали знаете то есть ну из-за того чтобы прям создаете то модераторов не помню крейда вот вы прямо вот знаете вот ну сообщаете что вы знаете чо делаите ну то есть как sunsay вам да то есть вы владелец девятом просто или где можно так и здесь вы создаете для секунду с типом пинт вот вы прям сказали что вы знаете что делаете вам это прям надо но в большинстве случаев это не надо большинстве случаев в этом вам нужно для того чтобы сходить в win32 или там еще куда-то вот и просто нужно дать буфер с которой нужно чем-то заполнить для этого надо пользоваться причем сам fix почему ключевое слово fix потому что ключевое слово fix не создает pinning она создает pinning только тогда когда garbage collector сработал между двумя в фигурными скобками где это ключевой fix написано почему-то так красиво работает потому что когда вы пишете fix вокруг какой-то переменной то в метаданных это перемены ставятся flygt анапе на балу вот это специально перемен надо это garbage collector срабатывает вот он ну в любом случае сработает посреди какого-то метода он смотрит вот короче вот в этом спектре есть вот эти вот методы которые сейчас работают там есть переменные типа пинт вот если они пинт если при этом раньше инструкций попадает я попал в этот рейс до на всех этапах вот по stack trace у значит я должен ее применить вот отсюда два вывода если вы применили переменную но будьте добры пожалуйста ну не делайте глубоких вызовов вот потому что ну это увеличивает вероятность того что вы пин получите реальный и второй вывод не надо делать и vacations внутри этих блока сделать его кеша внутри фейсбука в ну вы прям хотите получить за пьяную до переменная вот не надо так соответственно вот fix либо вообще не надо дальше подходим концу избегайте финализации финализации вызывается не детерминирована даса не вызванный де сполз привозят иной засасывать кающимися ссылками с объекта если вы забыли просто забыли сделать из полос я не люблю этот шаблон вот он прямо поперек душе мне лежит ну потому что никто не если он как бы есть 2 способа не значит что его дом надо вызывать вот то есть не понятно надо не надо кто его должен вызвать но в документацию лиц приходится зачем я не люблю туда лезть вот они вызваны dice полосу он приводит как финализации вот соответственно исходящие ссылки повисают исходящие ссылки повисают на паровую garbage collection of да вот эти ссылки могут вообще тащить все приложения если у вас совсем не повезло вам до вас нам лямда который тянет ваш экземпляр на этот экземпляр теннису памяти вот ну как бы вообще капец поэтому аккуратно вызывать response избегайте большого количества потоков почему потому что для каждого потока выделяется свой своя зона выделения памяти создание много потоков даже если они простаивают даже если они там не знаю на выйдет объектов висят ничего не делают вас все равно сможет скиппи 10 окна локации заработал горбач kollection окна локации переезжает в другое место то есть ну как бы тяжело избегайте тратить к объектов разного размера вот создает фрагментацию фрагментация создает проблема garbage collection а потому что место дешевого дешевого пометки кусков памяти как свободных от свободных адресов да где потом могут выделяться другие объекты вместо этого создается collection вот поэтому лучше как бы если у вас ожидается круто трафик либо в пол либо на там еще как то но можно попытаться привести эти объекты примерно чтобы они были одинакового размера чтобы они не прокомментировали но лучше pulling здесь три книжки ну вот первая книжка лучше значился 2 вот там где заходит на менеджмент это если вы хотите ну так одним глазом посмотреть не сильно напрягаясь как работает память муж оно коротенькое вот она очень легко написаны по книжке вообще не об этом а для того чтобы сделать объем вот ну да будем честными вот процент менеджмента просто для того чтобы сделать объем вот там вот но там одна тысяча страниц да вот но про память то есть 1 на сделано для того чтобы рассказать различный touring вот вторая половина сделано про то что предсказать как работает память вот и конрад очень подробно очень разжевывая под прям вообще вообще ну внук поймет вот все это объясняет именно поэтому объем большой то есть он постоянно повторяется да то есть вот это вы сделали да потом следующей главе описывает но вы же помните вот это вот именно вот так вот работает вот и немножко копипаста но как бы зато она приводит к полировке знания и концу вы точно все понимаете ну и третье мой скромный труд вот собственно падут нету всякие разные интересные статьи вот они скомпонованы в единую книгу но ты как говорят очень легко читается какие возникли вопросы спасибо"
}