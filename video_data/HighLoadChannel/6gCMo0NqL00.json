{
  "video_id": "6gCMo0NqL00",
  "channel": "HighLoadChannel",
  "title": "Как мы разбили клиент miro.com на ленивые модули / Олег Плотников (Miro)",
  "views": 857,
  "duration": 1793,
  "published": "2019-12-05T13:07:19-08:00",
  "text": "меня зовут олег плотников я ведущий front-end разработчик в компании мира и сегодня я поделюсь нашим опытом разбития огромного монолитного клиента на кусочки поднимите руку здесь есть front in der и да конечно пойдет отлично итак что такое мира это самая популярная платформа для коллаборации мы растем с огромными темпами за предыдущий год у нас плюс 1 миллион пользователей каждый день у нас более 5000 пользователей активно пользуются досками и мы примерно в полтора раза приросли в команде разработки сейчас нас около 70 человек за последний год отлично сам продукт представляет из себя клиент сингл пейдж applications с двумя страничками дашборд где есть список ваших досок и сама доска где вы к лоббируется со своими коллегами или клиентами и здесь на интерфейсе куча кнопочек за которыми скрывается огромное количество дополнительных вещей которые не нужны кажется сразу продукт очень большой и так как мы стремительно растем мы столкнулись с двумя проблемами количество фичей нарастает наш монолит становится тяжелее и пользователь начинает жаловаться на скорость загрузки и команда достаточно быстро растет и мы стали сталкиваться с проблемой что не всегда очевидно на что влияет твой кот изменение в твоём коде что ты можешь за аффект окей мы увидели эту проблему и пошли продавать ее бизнес у менеджмента то есть поразмысли над вариантами решения не пошли говорит что парни проблема существует как мы обозначили проблему мы взяли билды клиента за последние несколько месяцев посмотрели как быстро они прирастают по объему кода и посчитали количество разработчиков и прикинули что будет через год если мы не перестанем продолжим в том же духе наращивать наш монолит и условно через два года это на каком-то определенном соединение вот показатели как бы не прогнозы не лучше а хотим мы и можем грузится меньше чем за 5 секунд на этом же скоростью соединения как мы поняли что мы так можем можем быстрее грузится ну во-первых мы понимаем как клиент построен во вторых есть простой лайфхак вы можете посмотреть на свой клиент загрузить его в храме есть говоришь вкладка в devtools где вы слева видите список загружаемых спреды скриптов а справа соотношение зеленое используемый используем и из этого скрипта код красный не используемый как видим вот представьте приложения дофига кода просто не использовалась условно загрузилась 10 мегабайт 94 и 55 и один мегабайт просто не использовался больше 50 процентов это есть над чем поработать и кей приняли решение ускорять с чего нужно начать мы начали с того чтобы определить о чём же мы будем ускорять мы ввели понятие целевого контента целевой контент это то что пользователи ради чего пришел на данную страничку пользователь то что он хочет увидеть в первую очередь на дашборде это список досок с возможностью перейти на нужную на доске это сам контент в режиме просмотра редактирования контента и там sharing доске экспорт как доске это все третье это можно грузить отложено пользователь в среднем не ради этого пришёл на страничку договорились что будем ускорять разумеется навешали метрик в качестве дешёвого и быстрого решения мы поначалу использовали speed tracker арк это настройка над speedtest сайтом который замеряет загрузку страницы и дает развернутые графики что там происходит вот speed tracker позволяет регулярно мы настроили два раза в день замерять вскоре загрузку клиента на правде и показывать как у нас там дела вот навешали метрик потом договоримся что ж будем в первую очередь оптимизировать что происходило когда грузился у нас дашборд пользователь открывает дашборд грузится огромный монолит клиент который состоит условный из вендоров кода который отвечает за отрисовку дашбордов кода кода который отвечает за попробую тысяч до кода который отвечает за отрисовка доски и прочей фичи разумеется что потратить dash board не нужно загружать доску но и мы договорились что мы это в первую очередь отрезаем что нам нужно для этого было сделать у нас технологии были есть этот typescript vopak и англ hd с англ аджая со звездочкой потому что это важно не только для ангара все что я буду рассказывать дали angular по дефолту не предполагает отложенную регистрацию компонентов и мы это поправили про это есть куча статей в интернете это не очень интересно рассказывать интересно рассказывать про то что так как был в начале монолит в начале была просто огромная портянка компонентов которые используются при приложении вот в начале моих регистрировали при запуске приложения теперь когда мы дробим дробим все на куски так делать нельзя нам нужно говорить нам нужно регистрировать используемые компоненты по месту что мы видим на этот на этом примере мы видим какую-то вязку и использованием компонента a platform backup надо как-то сказать теперь что мы используем этот компонент мы перейдем файле файл который импортирует эту верстку это вот файл компонента project лежку которую мы видели и мы видим вверху что мы за импортировали этот компонент далее в этом же в этом же главном файле компонента мы импортировали верстку и зарегистрировали директива в приложения и вот так получается вот такая структура компонента собственно верстка стиле какой-то код и файл который импортирует все три вот этих компаний все три fight предыдущих файла вместе и плюс еще в нем же описаны все другие компоненты которые используются верстки так мы избавились от от единого монолитного вот этого единого длинного списка в начале преложения окей мы отрезали доску от дашбордов тестируем и сталкиваемся с проблемой куда ж без этого вот так выглядит окошко шаринга доски у нас и вот так она выглядела на тестирование кажется чем чего-то тут не хватает и таких мест было довольно таки много так что где компоненты по какой-то причине не трынди релиз почему это произошло потому что сейчас объясню посмотрим например вверху мы видим регистрацию компонента внизу используемую вёрст и тут мы добавляем компоненте quieres que e-mail едет дорабатываем компонент тестируем все работает ну раз все работает то зарегистрировать мы забыли потому что работает проблема в том что мы используем компоненты в одном месте а регистрируемых в другом ну в angular джесси это разные места и это проблема не только англию джесс еще и view такой же проблемой страдают и другие подобные фреймворке такой проблемой не страдает ряд поэтому его ты не можешь в реакции использовать директиву не за импортеров его и поэтому приложение на реакции легко бить на кусочки таких покормили таких проблем там точно нет окей что мы сделали мы написали в пак плагин который пробегает по на этапе сборки по html и смотрит нестандартные теги и проверяет что они в pascal кейсе есть в родительском компоненте мы прогнали этот плагин и в общем-то устранили все баги и он у нас теперь на watch режиме работает ok загрузку до сбора да даже борт ускорили и какие результаты у нас от отрезание были доске дашборде изначально то есть примерно мы получили профит в три раза по объему загружаемого года а в среднем по скорости загрузки в два раза хорошо мы только что поговорили про структуру компоненте cove о чисто верстки теперь надо договориться как в целом описывать код для большой печи для какого для какого-то отдельного функция отдельной функциональности в продукт это собственно и есть ленивый модуль эта штука которая в которой реализуется какая-то функциональность которая загружается отложена в ней и джесси html и css и к ней строгой асинхронный доступ ну потому что она грузится отложено по идее вы пак дает это из коробки в каком-то виде а именно он дает разбиение вот правило как разбивать механизм как разбивать джесс на куски и the decline шур или ис-6 импорт и и настройки по управлению java script санками кусками нам этого было недостаточно потому что вы так ничего не говорит о том как ты должен организовывать код он не дает механизма для того чтобы подменять модуль в тестах реализацию модуля когда java script загружается в браузер весь код который на уровне файла написано он исполнить написан он исполняется сразу нам и каждый раз когда его через какой нибудь рекламе шорты импортирует этот код каждый раз исполняется нам этого не нужно было нам нужно было чтоб один раз за импортировал файл все он принц али zero вался вот проблема с кэшированием решить у нас продукт отображается на разных типах устройств по разному разные ей поэтому надо было разобраться как с разными устройствами работать и когда у вас монолит у вас приложение условно либо загрузилась либо нет а когда у вас и нагрузиться почти по кусочкам может сложиться ситуация у нас она складывалась что вот этот модуль не до загрузился и функциональность мне показалось надо реализовать ретро и ok какая у нас была файловая структура она была условно следующий старый монолит то условная базу папочка где весь старый кот хранился и новая папка лайзе modules в которой мы в которой мы переносили старый кот оформлены виде ленивого модуля и писали новые фичи как конкретный модуль выглядит здесь модуль project есть какие-то компоненты ну или какой-то код который реализует функциональность есть активатор эта точка входа в модуль которая тянет все зависимости из компонент она выглядит вот так условно вот какой-то класс и в нем реализована пару методов этого модуля ладно дальше идет projects модули самый интересный файл это назовем его интерфейсный файл именно и его нужно импортировать для того чтобы обратиться к модулю этот файл выполняет роль обертки над в покровским механизмом разбиения на куски и именно с помощью него мы решали решаем обозначенные проблемы подмена для тестов и ретро и и какой-то там третий пункт так что мы тут видим мы видим здесь интерфейс собственно опять этого модуля всего пару методов далее мы видим в паковский механизм импорта асинхронный военпро the java script а вот здесь импортируется файлик projects модули активатор в который тянет за собой все импорт и и так же с помощью вы покровского комментария мы дали название дро скрип файлу в которой все это соберется далее мы это сверху все оборачиваем функция обертку которая вот решает третьих проблемы тестере троя и кэширование модулей чтобы джейс на уровне файлов по несколько раз не выполнялось по факту вот этот модуль из локатор это просто яма по где в качестве ключа у нас название модуля projects а в качестве значения функции обертка в который реализован на загрузка асинхронная загрузка дресс-кода и из модуле мы экспортируем вот эта функция обертку по ключу projects окей как обращаться к ленивому модули в прикладном коде вы импортируете вот этот интерфейс ный файл вызываете функцию обертку прочих с модулем она вам возвращает promise который завязывается когда файл загрузится с учетом retrieve и в переменной модуле вы имеете ссылку на вот этот класс с методами где вы можете вызвать нужный вам метод тут же вы можете легко ладдеры показать до того как вызвать projects модули показать loader как функция зарезал лося лось скрыть loader окей мы решили задачу мы договорились о правилах организации коды мы решили историю с подмены с тестами кэширования или троими теперь нужно решить со сборкой для разных устройств рассмотрим другой модуль даже борт дашборд у нас выглядит по-разному разные интерфейсами для десктопной версии и для мобильной и поэтому у нас две реализации этого модуля дашборд модуль активатор desktop и мобайл и в в интерфейс нам файле мы в зависимости от текущей ситуации им портим нужный файл как это выглядит переменно браузер мобайл runtime и определяет текущее окружение и если это мобилы импорте мобильные если не мобилы in parting desktop все просто со сборкой под разные устройства разобрались продолжаем резать на модуле у нас есть какая-то оптимизация и что-то пошло не так и мы это быстро пофиксили но сделали некоторые выводы и доработали систему в чем была проблема в общем то проблема была в legacy в том что у нас раньше был монолит и никто не парился из какого файла какие другие файлы импортировать потому что все грузилась разум и вот пример вы в своем прикладном клади импортируете какой-то безопасный безопасный на вид утилиты а если провалиться в этот файл с утилитами они за собой внутри себя импортирует file services которой тянут например за собой всю доску все реализацию это очень тяжелый файл и ваш маленький модуль превратился в здорово здоровенный с реализацией доски окей как мы решили эту проблему мы ввели ограничения на импорт а с помощью вот под плагина еще одного предположим как они выглядят их всего три этих ограничен ограничения допустим мы файле модуль из активатор первое правило ты ты можешь импортировать только те файлы которые лежат внутри твоего же модуля у тебя такой изолированный мирок получается твой ленивый модуль ok второе из других модулей ты можешь импортировать только заголовочные файлы которые за собой не тянуть никаких зависимостей которые только асинхронный доступ предоставляет к другим модулям и разумеется для переходного периода нам пришлось разрешить импортировать из старого монолита так конкретную реализацию из других модулей импортировать нельзя все это работ работает в ран тайме то есть watch режиме во время разработки если разработчик чего-то за ним против он сразу же неправильный он сразу же получает ошибку и правит проблему ok все было бы хорошо но так как мы разрешили импортировать код из старого монолита все равно остался риск что вы сможете за импортировать что-то нехорошее и чтобы пофиксить этот риск а такая проблема тоже всплывало и собственно вот этот всплеск на графике был связан именно с ней мы написали и еще один vopak плагин стали архитекторами выпад плагинов и он делает простое ты когда определяешь своей модуль ты можешь указать максимально допустимый размер вот он проверяет максимальный допустимый размер модуля тут собственно мобилы ней десктопной реализация дашборд а разные размеры для них указаны разработчик может не не писать тогда у нас есть ограничение сверху просто полтора мегабайта это нам гарантирует что он хотя бы кан кан ву не затянет в модуль такое дефолтное ограничение сверху отлично мы докинули еще пару проверок в нашу систему это проверка импорта чтобы ты не исходя из документации понимал что можно что нельзя а чтобы тебе сама система подсказывала когда ты что-то делаешь не так ну и проверка размеры модуля еще одна история про которые хочется рассказать это управление пред загрузкой модулей проблема мы мы хотели сделать так пользователь заходит на дашборд пока он там выбирает нужную ему доску ищет мы хотели при загружать нужны доску или какие то другие фичи вот вы паки есть встроенный плагин для этого но у нас возникла проблема что разные у нас в ран тайме определяется какой код грузить и поэтому в банковский плагин из коробки нам не подошел ничего страшного мы у нас есть эксперимент мы написали свой еще один плагин и можно в комменте было указывать для стола указывать для какой реализации грузить модуль спред загрузка и разобрались результаты тестирования чтобы все это запилить потребовалось примерно 4 месяца и два человека и в активной фазе а потом это вы фоновую работу ушло до этого монолит был примерно 10 мегабайт после вы видите на картинке даже board доска 232 дашборд двое пятью ускорения мы получили на дашборде в три раза плюс мы получили систему внутри которой можно масштабируемую систему для других разработчиков чтобы они могли писать вот свои новые все фичи в ленивых модулях и собственно у нас сейчас все фичи и пишутся в ленивых модулях то есть задача была решена с масштабированием разработки и это не эффекте скорость показа целевого контента с точки зрения первого слайда это вот как было стало вот так здесь есть есть еще над чем поработать мы еще вендоры до конца не распилили но в целом здесь видно что теперь стало лучше помимо распилке на модулей мы еще использовали другие оптимизации я наверное подскажу только ключевые которые мы использовали или собираемся использовать это для ускорения загрузки клиента седин разумеется это sharing данных между вкладками то есть ты на у нас часто пользователи несколько досок открывает и в одной вкладки загрузился нужный контент во второй вкладке пользователь открывает дашборд или доску и вместо того чтобы тянуть сервера гораздо быстрее затянуть соседней вкладке мы это с помощью посмотреть и шире соответственно отдельные виды сборок который не включает полифилы или же вообще для современных браузеров отдают сразу в с6 это мы еще не сделали но собираемся сделать и многие другие оптимизации которые вы можете потом посмотреть на приедем какие мы вывели принципы из всей этой истории во первых все что может грузиться отложено пусть грузится отложено это банально но это так то есть исходя из этого мы договорились что все новые фичи мы делаем в ленивых модулях чтобы не увеличивать время показа целевого контента соответственно ядро должно быть максимально легким если вам нужно какую-то вен данную библиотеку затащить затащите именно в свой ленивый модуль она может никому больше кроме вас и не понадобится но на на скорость целевого контента отображения это не повлияет ведут в ядро тащить будем только если прям не знаю прим почти все будут этим пользоваться модули должны взаимодействовать друг с другом асинхронно мы для некоторых кейсов представили синхронно и взаимодействие но в целом так как фичи могут быть использованы в случайном порядке пользователя пользователями лучше безопаснее чтобы модули всегда только тереза про местный интерфейс друг с другом общались ну и показывать ладдеры там где нужно банально но грузить при старте минимум данных сервера изначально у нас было так что мы грузили достаточно объемный объемный объем данных при старте приложения потом мы его сильно склок нули и договорились что теперь грузии пускай каждый модуль грузит именно только то что ему нужно это пользователи просадки не замечает потому что в каждом конкретном месте нужно грузить по чуть-чуть информации и решилась две проблемы таким образом во первых само приложение стало открываться быстрее потому что не нужно огромное количество данных сразу грузить а во-вторых решилась проблема инвалида ции каша потому что раньше надо было вот этот загруженные ранее весь кусок код объем данных как-то инвалидизировать а теперь ты всегда актуальные данные в своей фича сервера получаешь ну и при загрузке стартует после только после целевого контента вообще все тяжелая все стартует после целевого контента и еще один тип оптимизации которые мы сделали мы посмотрели на код который когда javascript группе загружается только модуль сразу же на уровне файла можно писать какой-то код он выполнит и тяжелый код там писать не надо потому что на медленных устройствах на могилах каких-нибудь это влияет на скорость открытие приложения вот это банальные правило кажется но почему-то до этого мы и мы следовали когда они явно зафиксированы гораздо проще следовать таким правилам окей спасибо это все выпад плагины про которые я говорил доступный на гитхабе по ссылке и вы можете их использовать в своих системах то есть они очень просты их можно докрутить и в общем-то спасибо вопросы спасибо олег так какого вопросы поднимайте руки будем говорить микрофон неужели нет не жили так все понятно объяснил или наоборот да ладно наверняка все понятно даже дожди микрофончик пожалуйста иначе тебя в трансляции не слышно а можно вернуть экран на котором были перечислены все способы оптимизации это не все это топчик а а а а а дальше как бы хотелось посмотреть еще раз на как перечислены но презентации презентации публикуются после завершения конференции им презентации можно будет посмотреть так вопросов еще никто не созрел ну что тогда мы наверно поблагодарим антону еще раз за его интересный доклад али вот врут вручим олега почему и почему прости вот соответственно вручим подарочек от нас до"
}