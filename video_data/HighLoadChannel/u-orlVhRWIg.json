{
  "video_id": "u-orlVhRWIg",
  "channel": "HighLoadChannel",
  "title": "TLA+/TLC: формальный метод верификации конкурентных алгоритмов для инженеров / Алексей Найденов",
  "views": 1485,
  "duration": 3290,
  "published": "2022-03-21T13:13:03-07:00",
  "text": "всей я работа архитектором в компании это labs где мы делаем телефонную платформу а также продукты на базе этой платформы включая продукт виртуаль а т с white лейбл который мы продаем через множество наших партнеров операторов даже если вы про нас ничего не слышали это скорее всего нашей платформы слышала вас да потому что я посмотрел с начала года через нашей платформы суммарно прошло уже больше миллиарда вызовов примерно 60 миллионов уникальных мобильных номеров то есть если вы созванивались говорили по телефону с кем-нибудь из 60 примерно тысяч компаний малого и среднего бизнеса ну там не знаю что нибудь заказывали в интернет-магазине то с очень большой вероятностью ваш голос прошел через одну из наших инсталляций разумеется до при этом платформа целиком своя написанный преимущество на голову и на си плюс плюс вот телефоне это такая отрасли которая массово параллельная обработка клиентских заявок было задолго до того как это стало модно и конечно же писать такие системы общем-то очень непросто но но я знаю инструмент который очень сильно помогает именно в этом деле в разработке сложных конкурентах алгоритмов если моего слова недостаточно то послушайте больших ребят в и дабл так вы и ws этот инструмент используется 2011 года и по их словам является большим успехом microsoft считает что знание тела и plaza является явным индикатором тому что человеку очень сильно заботит качество да я думаю что именно это качество кода который он пишет я думаю что и именно и это объединяет всех кто собрался в этом зале но и отличает от тех кто остался снаружи манга тебе однажды привели моделирование при помощи этого инструмента своего кода причем ретроспективное и признали что они если бы они сделали это сразу то в этом случае они сэкономили бы себе сотни часов машинного времени инженер во времени простите их их конкуренты и коллеги из как рожь тебе не стали совершать ошибки и сделали модель алгоритма своего нового протокола распределенных транзакций до того как начали его писать вот и я надеюсь что вам интересно поэтому приготовьтесь пожалуйста сейчас будет короткая но очень увлекательные экскурсии в математике 20 минут зайти и выйти пристегнулись погнали я начну запросы что такое программа для нас программистов программы как правило это код который мы пишем у себя в голове на каком-то конкретном языке программирования при этом мы можем абстрагироваться от этого кода и представить его например виде блок-схемы но в конечном итоге там внутри них железе программы это некоторый набор правил который описывает собственно говоря как должно меняться состоянии чего-то да это могут быть там не знаю пикселей линии наш линии состояния регистров памяти неважно возьмем примеру две программы которые могут выполняться в любом порядке они меняют значения двух переменных в зависимости от того в каком порядке будут выполнены этой программы конечный результат будет совершенно разными давайте мы договоримся о терминах да мы будем называть вот это вот совокупность значений переменных каждый конкретный момент времени состоянием а порядок которым эти состояния достигаются будем называть путем выполнения так вот количество состояний в зависимости от длины пути выполнения и количество одновременных процессов может быть чудовищно большим да посмотрите на визуализацию пространство состояний относительно простого протокола промышленный шины can именно это делает нашу работу настолько сложной понимаете эволюции нас этому не готовила очень тяжело уместить все это в одной единственной голове особенно это касается распределенных систем то есть таких систем где компьютер про которы вы даже не знали что он существует может сделать ваш собственный компьютер бесполезными это прекрасное определение распределенным системам дал 8 седьмом году человек по имени лесли лэмпард который вы наверняка знали потому что это человек который собственно заложил базу под распределенные вычисления такие какие мы сейчас знаем потому что он придумал вам про таймс temps из которых потом выросли vector black flags и многое другое он придумал алгоритм пекарни из которого выросли потом все мьютекс и про который вы знаете 3 класс actions он придумал алгоритм тексас сильно упрощенную версию которого вы наверное знаете под словом браст он придумал отёк и наконец он придумал тела и plaza или тэмп оральную логику действий что сделал импорт он взял обычно математическую лают о которой стоит из конвенции дизъюнкции отрицания и добавил к ним этим оператором операторы темпоральной логике то есть такой логике которые позволяют нам математически точно рассуждать о верности или неверности к ты предикатов не только в текущий момент вот прямо сейчас но и в каком-то последующем дискретном это важно дискретном будущем частности он придумал оператор а вес читается box эй который говорит что предикат эй будет верен в этот момент а также во все последующие моменты разумеется предикаты темпоральной номер оператора термальной компорально выйти можно точно также комбинировать с этой математической например смотрите не всегда нее эй вдумайтесь не всегда будет ложным это означает технически до что когда-нибудь будет возможно состояние когда предикат и все-таки будет верен поэтому для этого существует отдельный оператор который читается даймонд и который называется и венчали когда-нибудь при этом оператор темп оральной лайки точно также можно комбинировать друг с другом до например вот такая вот запись range ли у вас когда-нибудь всегда тоже вдумайтесь когда-нибудь наступит состояние при котором предикат эй будет верен всегда в дальнейшем называется и range ли у вас когда-нибудь всегда и еще он придумал описал нотацию нотацию штрих prime которая указывает на значение которое примет прими та или иная переменной на следующем шаге наших вычислений кроме того навел еще нотацию возки для того чтобы это можно было записывать отдельным текстом вот она знакомьтесь что еще важно знать про целый пласт конечно там здесь булевы константы там есть очень важный оператор define определить который позволяет дать определение какому-либо символу есть оператор равенства неравенство есть операторы принадлежности не принадлежите какому-то конкретному множеству есть разумеется квартиры кванторы всеобщности и кванта существования тоже очень полезно теперь давайте посмотрим на спецификацию вот того самого алгоритма простого который мы видели да на языке тела и plaza из чего он состоит во-первых это название модуля во вторых название модуля который он расширяет и который из которых определению он использует например вот этот вот модуль использует определение из модуля managers натуральные числа дальше мы определяем некоторые константы параметры модели для нашей спецификации делаем предположение об этих константах если соответственно это предположение окажется неверно та модель не заработает описываем переменные е то есть то что собственно говоря будет составлять состоянии вот этого нашего алгоритма описываем инвариант это некоторый предикат который обязан быть верен но любом шаге наших вычислений и описываем очень важно описываем темп оральную формулу свойства алгоритма свойства живости и корректности алгоритмы то есть данном случае мы утверждаем делаем утверждение что рано или поздно значение аккаунт будет равно мы целью обратите пожалуйста внимание что до обратите пожалуйста внимание что вот в этом предикате который является предикатом начального состояния описывает вот этот вот знак равно после каунтер это не присваивание эта запись буквально главе пуск буквально означает что начальное состояние это верно в том случае если значением переменной каунтер является мин вилью и наконец мы описываем описываем предикат действия вот то самое действие которое temple of actions здесь тоже знак равно после каунта штрих это не присваивание буквально это запись значит гласит что предикат next будет верен в том случае если на следующем шаге значение переменной каунта окажется равно либо каунтер на единицу больше если каунтер был меньше матвею либо тем же самым дальше мы описываем собственно говоря самую спецификацию который состоит из объединенных конвенций предиката начального состояния предиката действия вот это вот запись означает что на каждом шаге dropbox на каждом шаге будет либо верен предикат действие next либо переменной аккаунтор останется неизменной и описываем еще одно свойство действие next который называется wicliffe эрмес которая означает что если действие никс может быть выполнено то рано или поздно она будет выполнена значит что с этим можно сделать да ну во первых такой спецификацию можно доказать есть в инструментарии пруф assistant и собственно горя можно взять и математически доказать что да действительно это алгоритм будет выглядеть именно так будет делать именно то что делает и все это доказательство будет ссылаться на все ли мы перед этим но но во первых инженера да мы не математике во вторых доказательства даже для математика ду более ли менее сложного алгоритма может быть в общем сложным и довольно трудоемким поэтому лэмпард придумал инструмент который назвал ти вести и который в общем как бы сказать он делает полный перебор всего возможного пространство состояний и переходов между ними и пытается найти контрпример к нашему утверждению который мы сделали темпоральной формуле то есть вы говорите что вот в результате работы этого алгоритма темп оральная форма получается такой то рано или поздно будет достигнут такое состояние дел себе просто находят первое попавшееся состояние и переходы между ними который будет противоречий вашему утверждению и говорит вам у вас тут ошибка давайте посмотрим как выглядит инструментарий значит я знаю 222 интерфейса который можно пользоваться тело plaza это собственно говоря целый пласт tool-box то что написал лэмпард с коллегами выглядит он примерно так не очень хорошо видно смотрите значит верху это собственно спецификация которая записана в аске внизу это параметры модели то есть определение констант и определение какой именно темпоральный формулы мы используем и наконец справа вверху это результат прогона этой модели видно что он там нашел 4 уникальных состояний а я при этом пользуюсь другим инструментом это плагин тела и пласт написанный для visual studio код андрей мальгин за что им большое спасибо который выглядит примерно так же спецификация параметры модели только теперь уже записанной в аске и результат прогона когда лэмпард в в девяносто восьмом году написал свою статью про pixus да это такой алгоритм нахождения распределенного консенсуса то статья оказалась настолько сложный к восприятию для его целевой аудитории инженеров что в 2001 году ему пришлось написать другую статью которая называлась bags is made simple случае с тела и пласт лэмпард было больше выдержки да поэтому тело e-class появился 2001 году apple оскал ласкал появился в 2009 что такое плоско а это такой язык который позволяет вам на некоторые псевдокод описать ваш алгоритм в более ли менее привычных вам терминах потом этот алгоритм может быть а транслированы спецификацию тела и plaza которые вы уже можете проверить при помощи тексте значит что нужно знать про apple оскал во-первых самое смешное во первых pla скал это текст на программы на pascal это комментарии внутри спецификации тела и пласт вот именно так и транслятор результат трансляции записывает потом виде кода тела и пласт после этого комментария звучит безумно но к этому очень быстро привыкнуть потому что как бы всю эту цветочную сложность инструменты благополучно от вас скрывает вопрос нажимаете там команд с и у вас опыт новая спецификации на тело и пласт который можно использовать алгоритм включает себя название алгоритмы описание переменных да вот две переменные определяем некоторые определение тела и пласт частности определения team part им пора ли формулы которые вы определите как главное свойство алгоритма в данном случае мы ожидаем что сумма переменных рано или поздно будет равна 5 и описываете собственно процесс и то есть некоторые программы которые будут выполняться параллельно обратите пожалуйста внимание на вот и 1 и 2 после знака равно это идентификатор процесса кроме того очень важное понятие в ласкал это метки метки практически непосредственно транслируется в предикаты действий да то есть с практической точки зрения можно считать что весь код под ниткой будет выполнен а там арно давайте попробуем да вот так вот выглядит софта для лица трансляции определяются переменные в том числе переменная писи технически это такой словарь в котором для каждой программы написано какая метка будет выполнена на следующем шаге то есть это программка under поэтому название писи вот так вот он на инициализируется мы попозже поговорим про эту про этот синтаксис дальше он собственно описывает предикаты действие причем обратите внимание вот это вот вверху это условие то есть этот протекает действие может быть выполнен только в том из только в том случае если значение программка under для от этого процесса является p1 на текущий момент при этом если это действие будет выполнено то в конце этого действия значение программ каунтер а именно для этого процесса должна быть равна в другой другой метки который называется дан кроме того тела и пласт для вас бесплатно автоматически делает свойства алгоритма который называется терминация и который позволяет вам проверить что ваш алгоритм корректно завершается после того как он выполнил все ваши вычисления и определяет собственно предикат действие который обратите внимание здесь уже не конъюнкция дизъюнкция то есть приди как действие будет верен в том случае если верен любой из этих предикатов и дальше спецификация который уже похоже на то что вы видели раньше запускаем собственно вот так вот выглядит запуском они строки это тоже возможно это имеет смысл например использовать если вы хотите получить визуализацию потому что инструмент телки позволяет делать визуализацию пространство состояний вашего алгоритма видно что нашел 5 различных состояний вот так вот выглядит визуализация теперь давайте попробуем усложнить например давайте добавим пометки сделаем так чтобы действие внутри этих процессов выполнялись не одновременно а последовательность каким-то шагам для этого мы просто берем и добавляем к каждому действую по собственной метки запускаем и келси нашел нам контрпример при этом телки что очень полезно для наших целей выдает нам полный trace всех состояний и всех переходов между этими состояниями который позволяет нам понять а что из такой момент времени сломалась как правило в алгоритмах котор вы моделируете вот это вот глубина получает получается не слишком большой да ну там 20 но может быть 40 и как правило ошибка находится гораздо раньше вот данном случае мы видим что была нарушена темпоральная формула что он нашел контрпример и что в конечном итоге у нас сумма оказалась равна переменных не 5 как мы ожидали сасими ну те из вас кто так или иначе работал с с конкурентной или параллельной разработкой вы сразу поняли что произошло произошли старые добрые гонке до дейтерий сэс то есть нас две программы одновременно попытались обращаться к одной и той же детей ки памяти и разумеется там одна программа вот здесь видно на визуализации видно что одна программа вклинилась между двумя кистями другие получилось гонки получился результат елси нашел для нас ошибку которую мы заложили нашем алгоритме значит что еще сейчас перед тем как мы придем в практике курс молодого бойца то что нужно знать про целой apple оскал что еще есть в тело apple оскал важного для того чтобы моделировать для того чтобы нам моделировать во-первых две важные структуру данных это множество причем множество в математическом смысле смысле коллекция однотипных уникальных элементов множества можно вот так вот задавать три разных способа задачи множество можно объединять множество можно вычитать можно находить пересечении можно находить проверять присутствие или отсутствие какого-то элемента множестве множество может быть бесконечным то есть ласкал делай класс и теллсы в принципе для натуральных чисел как минимум поддерживает нотацию бесконечного множества значит второй важный важный структур данных которые делает тело и пас эта функция функция тоже в математическом смысле то есть отображение одного множества на другого множества например функции квадратов это отображение натурального множество чисел в другой натуральное множество чисел у каждой функции есть свой собственный домен да то есть это множество на котором функция определена домен может быть конечно же конечным есть вот такой специальный синтаксис который называется except который позволяет вам определить новую функцию которая отличается от той функций которые вы берете за основу одним единственным элементом то есть таким образом можно поменять какой-то элемент в этой функции значит на базе функции в тело apple ac есть массивы да потому что что такой массив это технически это отражение множество множество индексов на значение которые индексом соответствует так вот в тела и лаз есть массивы да ну они там называются кортежи тапас и они обратите внимание начинаются с единички они с нуля для массивов есть специальные синтезе с квадратными скобками для доступа конкретным элементу есть функции для того чтобы получить голову хвост для того чтобы получить какое-то подмножество не подмножеству простите а под массив до из этого массива есть функция фильтра которая позволяет найти те элементы массива которые подпадают под какой-то условие для этого очень удобно использовать лямда я не говорил но в teleatlas есть ям-то массива можно конкатенировать при этом вот это синтаксис уже не те лапласа полоскал можно там добавлять что-либо к массиву ну и можно использовать в в переменных присваивания кроме того на основе фунте можно сделать запись и потому что если подумать записи словари что такое словари это про отображение множество ключей на множество значений которые тем плечам соответствует вот для такой записи до соответственно доменом будет вот множество из трех названий ключей для записи есть синтаксис с . и синтез квадратными скобками тоже работает есть вот такой синтаксис который позволяет сделать запись из ключа и значение есть синтаксис который позволяет объединить две записи причем последующей записи будут переопределять значения для ключей предыдущих и вот при помощи такого такого синтаксиса можно очевидно можно делать записи которые будут отличаться каким-то конкретным элементам а вот при помощи такой относительно простой конструкции можно определить функцию обратите внимание можно определить запись которая в общем эквивалентно предыдущей записи из которой вы определяете за исключением одного единственного элемента то есть мы берем домен чувство ключей вычитаем из этого домена один единственный элемент и получаем новую функцию то есть новую запись в которой есть все те же самые ключи кроме этих вдох поехали дальше давайте возьмем в конкретную задачу что можно с этим делать дальше будет интересно наша платформа принципиально кластерная написанное на голо большие нагрузки все как вы любите каждый из узлов при обработке телефонных вызовов может генерировать некоторую информацию о текущей в телефонных вызовов это называется седерпауэл детей рекорд из этих they are можно вычислить много разной полезной информации например запись в истории нам хотелось бы там чтобы вот с разных узлов эти седера складывались какую-то очередь потом уходили на какой-то процессор который в их обрабатывал ну например склеивал релевантные звонки да если это был перевод по нам нужно склеить и получить одну запись истории и дальше стал некоторых хранилищ вот мы смотрим на эту архитектуру и делаем одно единстве предположения до чтобы мы хотели мы в качестве очереди будем использовать кафку да потому что это даст во-первых нам огромный запас по производительности во вторых из коробки даст нам необходимую нам надежность надежность и отказоустойчивость давайте попробуем написать спецификации для такой архитектуры первым на пир и мы возьмем сделаем опишем модели требования значит мы опишем параметре зa им модели множеством звонков которые будут совершены опишем смоделируем моделируем очередь и хранилище их очень удобно моделировать при помощи собственного массивов и то и другое и наконец опишем темпоральный формула несмотря на громоздкой запись она считается очень просто и говорит следующее рано или поздно для всех совершенных звонков в хранилище будет ровно одна запись соответствующий этому звонку с непривычки только сложно поверить и потом читаете на 1 дальше мы определим процессы обратите внимание что вот это вот нотация fair процесс call in gales означает что мы определим код для сразу множество процессов которые будут выполняться параллельно при этом напомнить явилась исследует все пространство состояний то есть он из пробует все комбинации неважно в каком практ порядке эти процессы будут выполняться пока что наш процесс ничего не делает еще мы пишем процесс процессор который будет обрабатывать единственно что мы про него пока можем предположить что ну наверное у него внутри где-то должен быть большой цикл где он будет что-то читать и потом что-то складывать пока мы тоже очень и делаем проверяем что у нас да и разумеется мы примет рисуем модель мы описываем множество звонков для того чтобы убедиться что модель работает не нужно пропускать там не знаю 40 тысяч звонков достаточно пропустить ну в программировании стриптиз лада 01 и много вот наши точки зрения пусть много будет равно трем и указываем собственно на свойства алгоритма который мы хотим это вот который мы писали раньше запускаем ожидаем и получаем ошибку видим что у нас звонки успешно завершились процессор висит и просто ему некуда деваться дальше там получился бесконечный цикл теллсы видит что впереди у него бесконечная симуляция он и останавливает потому что зачем нам бесконечной симуляции при этом он нашел уже 16 различных состояний смотрите давайте теперь попробуем написать собственно реализацию что нам для этого нужно во-первых мы опишем смоделируем дата как процессы которые обрабатывают телефонные звонки складывают сидя в очередь нам не нужно здесь моделировать сеть или придумают что-нибудь очень сложно и мы просто берем и говорим добавить в массив очередь запись где запись который состоит вот из стелс обратите внимание это слово означает идентификатор этого процесса и экшн экшн может быть либо сетап начала звонка либо комплит завершения звонка при этом обратите внимание здесь две метки эти события добавления вот этих записей в очередь происходит в два разных моментов времени теперь давайте смоделируем смоделируем процессор те кто из вас таскался со ставкой знает про семантику качки кафка представляет собой бесконечный который кафка оперирует of сетами и смысле смещениями внутри этого logo и есть понятие подтвержденного смещения то есть то смещение которое консьюмер кто-то получает информацию из этого logo получил и потом подтвердил что он получил мэтта смоделируем переменный комитет кроме того мы добавим парочку простых операторов а целый пласт до которые позволят нам не сильно отвлекаться на синтаксис делает вас нашем алгоритме это очень полезно там любой человек который хоть сколь-нибудь долго работаешь целая полоса бравого подрастает целый библиотекой таких вот операторов на свой вкус носит процессоре мы во-первых смоделируем некоторый объект данных структур данных который мы зовём work in progress то есть это словарь тех звонков которые мы обрабатываем на текущий момент смоделируем собственно смещение с которого мы собираемся читать она очевидно будет равно камера + единичка и добавим вот такого условия вот это вот вот это вот слово в.н. у него есть еще синоним который называется weight означает буквально следующее дальше можно двигаться последующие действия можно выполнять только в том случае если условие которое приведено здесь верно в данном случае мы говорим что мы будем двигаться дальше только в том случае если нам есть что читать то есть если в очереди появились какие-то данные которые больше текущего смещения которые мы ожидаем дальше мы читаем что-то из очередь вот это вот запись увести dear anna в общем позволяет определить некоторые символов не определяя переменную потому что переменную в тело и класс это довольно такие тяжелые сущности они являются частью состояния а это просто символ который вот внутри этого уэст привязан чему-то то есть мы читаем сидят дальше смотрите если это васи dior для этого звонка еще нет нашим work in progress и его действие этого si de oro равно сетап то есть это сидер который связан с установлением вызова то мы его добавляем наш work in progress и при этом сохраняем на всякий случай сохраняем то смещение с которой мы его прочитали дочери де если же этого si de oro для этого звонка еще нет кан прогресс и при этом то есть наоборот если он уже есть в орган прогресс и при этом оси direction равно комплекта есть это завершение звонка и мы его обрабатывали то мы его удаляем сохраняем дальше мы подтверждаем до обычно кафка делает для нас это автоматически но в этом моделируем данном случае да мы подтверждаем что действительно мы это прочитали и ожидаем что мы будем читать со следующего уже со следующего элемента влаги каски запускаем моделирование видим что ошибок не нашлось при этом была найдена почти 3000 состояний уникальных все хорошо но но мы же делали модель не для этого мы делали модель для того чтобы найти в ней что-нибудь что-нибудь поэтому мы попробуем добавить к этой модели чего-нибудь например грейс пул shutdown как можно это смоделировать обычно процессор завершается когда ему coslight какой-нибудь сигнал как мы можем смоделировать сигнал мы можем добавить некоторые переменную глобальную в нашем алгоритме на полоскал который будет флагом булевы переменные и мы также решим что мы эту переменную этот флажок будем поднимать в тот момент когда у нас все звонки успешно завершились и что-то положили в лоб для этого нам понадобится еще один процесс который смотрите здесь мы воспользуемся тем что все переменные внутри спецификации не делай plaza них глобальные соответственно мы имеем доступ переменной писи и мы просто пишем что для всех звонков если для каждого звонка множество звонков сад соответствующий процесс уже завершился то тогда мы выставляем флажок вот так вот просто вот мы смотрели смоделировали не знаю человека который запустил тест прогнать все звонки и после этого нажимает кнопку shutdown теперь нам нужно добавить обработка этого внутри процессора как мы можем это сделать для этого нам поможет синтаксис которая называется озер и он позволяет описать действия которые могут выполняться там либо одно либо другое при этом если оба действия в каждом конкретном состоянии если оба действия доступны к выполнению то теллсы очевидно попробует проверить все пути и тот и другой так так вот так вот значит мы добавляем вот такой вот в секцию которая говорит когда у нас инструмент ложок шар down the пора на покой вон туда с и теперь мы можем смело добавить ещё одно свойство нашего алгоритма термины и шиндо потому что мы ожидаем что все наши процесс успешно завершаться запускаем и и получаем ошибку смотрим все процессы у нас успешно завершились но при этом прочитали мы не все и в хранилище у нас всего два звонка из 3 мы нашли ошибку у нас не пустой work in progress возможно нам стоит добавить еще одно условие которое будет вносить что мы должны уйти в shut down только в том случае если выставлен флажок и если work in progress пуст меняем запускаем получаем новую ошибку разбираемся значит смотрим work at pro груз у нас действительно пуст при этом ни одного звонка которые были голов хранилище и мы вообще ничего не прочитали то есть илси нашел для нас именно ту последовательность когда все звонки успешно завершились выставился флажок процессор это увидел и успешно ушел shutdown даже ничего не прочитав то есть нам нужно добавить еще одно условие да мы отправляемся shutdown только в том случае если нам есть если нам больше нечего читать то есть если смещение которые мы прочитали больше длинные очереди текущей запускаем успех в этот раз да уже четыре с лишним тысячи различных состояний мы уверены что грейс луша да он работает правильно если мы вот так это сделали давайте теперь добавим давайте теперь добавим crash потому что ну процессоры как правило такие которые работают долго и просто так не останавливает как правило не просто падает как мы можем смоделировать крыш просто добавив еще одну секцию в тот же самый синтаксис either но но если мы добавим просто crash data есть что то что будет да во первых что такое крыш если подумать crash это технически обнуление внутреннего состояния процесса процесс умер поднялся но состояние у него совсем нулевое пустое кроме того что он успел сохранить куда-то наружу вот то есть мы в этом внутри этого крышам и просто обновляем его состояние мы говорим что все три переносного равен комментов плюс 1 и что уборка прогрессу на спуск если мы оставим вот просто так вот как есть да то это означает что у нас появится некоторый бесконечный путь для симуляции и который никогда не будет закончена конечно нам этого не хочется поэтому нам имеет смысл добавить какой-то флажок для того чтобы проверять что крышу же случился и большего повторять не нужно мы можем сделать это простым пулевым флажком но интереснее сделать это счетчиком потому что мы например можем захотеть а что будет если у нас программу пойдет дважды там или трижды поэтому добавляем вот собственный расчетчик добавляем вот такое условие в параметре зa им нашу модель количеством крыши которые нам доступно который мы хотим проверить запускаем получаем ошибку значит смотрим оркам прогресс пуст в все процессы успешно завершились у нас здесь все прочитанное и у нас всего два звонка и здесь нам помогает trace который для нас генерал келси на откатываемся назад находим то состояние которое было ровно перед корешем перед падением видим что в этот момент у нас в work in progress что-то было уже прочитано да и видимо она как раз потерялась потому что на следующем шаге когда crash случился переменная конечно увеличилась work in progress стал равен стал пустым и эта ситуация сложнее то есть для того чтобы справиться с ней нам необходимо иметь внутри программы какой то какой то структуру данных который позволяла бы нам правильно вычислять а что именно мы должны коммитить до что именно мы должны подтверждать пока мы не предполагаем что это структур данных мы просто и описываем как процесс как какое-то множество да и вот вот в этом месте там где мы завершаем завершаем обработку вызова мы добавляем все наши а все ты все наши смещение которое мы почитать для этого вызова в это множество вызываем некоторые функцию которая нам вычисляет да не забываем при этом что во время крыша нам это самое множество нужно будет обновить эту структуру данных и думаем что же это должна быть за структуру данных что должна быть фунт функция комитаса очевидно она должна вычислять максимальное значение из присутствующих в этой структуре данных последовательности в том при том условии если там есть еще и начальный элемент то есть тот элемент который на единичку больше чем текущий коммитов к счастью на тело и класс опять же это не самая эффективная реализация конечно на другом языке в утеплять по другому но тело и пласт который оперирует множествами это делает очень просто для мы берем вот значение first которое равно текущие плюс единичка и если она есть множестве и если для всех остальных элементов множества в этом множестве есть элемент на единицу меньше это тогда мы выбираем такой элемент для которого нет элемента на единицу больше вот выбираем максимальное запускаем запускаем и снова получаем ошибку что они так смотрим а у нас если посмотреть видите у нас теперь в хранилище оказалось два одинаковых звонка что можно с этим сделать самый простой это сделать наши хранящий идем патентным то сделать так чтобы один и тот же звонок продолжался но дубль и при этом не возникало но есть много разных способов это сделать мы просто в данном случае моделируем это тем что меняем мастиф на множество и заодно драматические упрощаем себе нашу темп оральную форму потому что нам нужно теперь просто сложить два множества запускаем проверяем успех 15000 состояний но подачу нас может не только процесс у нас могут падать еще например звонки давайте добавим аварийный сброс вызова смотрим проще всего это сделать тот же самый айза он у нас либо звонок от добавляет свой последний сидят либо он падает его ничего не делает запускаем получаем ошибку начинаем разбираться видим что у нас процесс 124 что такое видим что у нас есть два звонка в этом в кол и предполагаем что наша темпоральная формула не сработало потому что теперь у нас появились банки которые не пришли они fail значит нам нужно добавить еще какое-то множество куда мы будем складывать вот эти самые запыленные звонки и усложнить нашу тэмп оральные формула для того чтобы проверять что темпоральная формула верна только в том случае если вот множество всех звонков за вычетом фак за сильных звонков равно тому что хранится находится в хранилище при этом добавлять что-либо в это самый sails мы будем прямо в звонках не очень красиво но для целей моделирования более чем достаточно запускаем все равно находим ошибку смотрим звонки вроде бы на месте fpl текстур в процесс при этом осталось что-то vip осталось что-то vip и здесь нам становится понятно что нам нужно как-то смоделировать тайм-аут потому что звонок не может лизать орган процесс бесконечного звонка есть ну какая то максимальная длительность там три часа 6 часов неважно но здесь есть проблема тела и пласт довольно сложно моделировать тайм-аут и конечно лэмпард написал статью которая называется буквально делает вас очень легко моделировать тайм-аута и реальное время но но келси это нотацию которую предложил не поддерживает поэтому нам нужно придумать что-нибудь свое для этого мы берем просто переменную на удар который мы писаем прям внутри процесса и на каждом цикле винт комментируем а также сохраняем текущее значение этой переменной в запись о звонке когда мы его складываем наш work in progress ну и разумеется примет рисуем некоторым тайм-аутом и добавляем вот такое это условие если у нас в work in progress есть хотя бы один звонок который старше тайм-аута то тогда мы выбираем этот звонок добавляем его в процесс удаляемый сбор can прогресс чиним к метод подправляем подтверждаем если это необходимо и и заодно мы меняем теперь у нас за пыльные звонки обновляются здесь это выглядит лучше мини ставим тайм-аут запускаем и равно получаем ошибку идем разбираться видим что у нас на у равно 9 старт равно 9 и процесс моделирования находится станнис татарин это холостой ход ему дальше больше нечего делать почему очевидно потому что в нашем цикле который вы там видели просто не дальнейших действий чтобы инкрементировать что-то поэтому нам нужно добавить еще одно действие который будет инкрементировать на ул и здесь нам нужно очень тщательно подойти к выбору к выбору условий для этого действия потому что если она будет вызываться где-нибудь раньше-то у нас снова может получиться бесконечный путь для моделирования и нашими стимуляции никогда не будет закончена поэтому мы будем инкрементировать переменную на outtime out только в том случае если у нас shutdown процессора внутри если у нас есть что прочитать и если у нас если нас ничего прочитать если у нас в work in progress есть хотя бы один период хотя бы один звонок который мало уже поймал то для которого тайм-аут еще не наступило обратите внимание что здесь мы еще сравниваем у окон прогресс не является ли он не пустым потому что кванторы всеобщности для пустого множества всегда будет верен запускаем 83000 состояний алгоритм работает значит смотрите что я только что на ваших глазах сделал за полтора часа за полтора часа времени и каких-то там 100 113 что ли строк кода я проверил основные свойства алгоритма сформулировал для самого себя требования к хранилищу проверил совместимы ли этот алгоритм с семантикой кашки убедился что у меня есть некоторые что у купе про проверил требований к структуре данных которые мне нужно внутри этого алгоритма и самое главное я получил спецификацию эта штука называется specification ее можно дать программисту который умеет читать любой псевдокод объяснить что это такое и он сможет по ней довольно точно написать что было задумано понимаете вот теперь я уверен что вам всем очень понравилось что подождите что что что у вас горят глаза и вы хотите попробовать точно так же и у вас возникает вопрос с чего начать рассказывает во первых во первых обязательно идите книжку делили вейном этот чувак который который лучше популяризатор тела и plastep ласкала найдите эту книжку она прополоскал идеально для вхождения в тему найдите также подпишитесь обязательно на его twitter на его блог найдите все его выступления до которых дотянетесь в интернете да и обязательно просмотрите дальше найдите и скачайте книжку который называется специальностям с которую написал сам лэмпард эта книжка абсолютно бесплатно в последняя траск редакции всегда доступна на его сайте вот в это поэтому и играй дальше дальше обязательно потратит рис племя часа жизни она будет очень полезно проверить если вы разрабатываете и посмотрите его лекции которые тоже точно так же абсолютно бесплатно доступны на его сайте вроде бы даже есть переводом на английский него прекрасный медленный он идеально электро послушайте ну и разумеется я настоятельно рекомендую воспользоваться там помощью комьюнити коменте в тело и plastep ласкали очень дружелюбно и вам легко и всегда ответят на любые ваши вопросы поэтому мы на здоровье теперь я наконец готов ответить на все ваши вопросы которые мне ответить на этом слайде алексей найдено в друзья а что это такой за навык говорить настолько быстро что даже сам этот насколько ты успеваешь за собой потому что когда я говорю быстро я не успеваю соображать проходит совершенно автомате навык нет это само собой получается будем считать что это как сказать на правильный пароль надо отметить что например гель и вейн который покупает занимается тела и класс у него та же самая проблема послушаете его вот как бы его выступление возможно как это называется эта корреляция людей которые которые вот этого не умирает нравится целый пласт круто я вижу то есть люди которые успели темпом речи вот один человек с микрофоном и дальше у нас быть там вопрос ярослав очень приятно так вот теперь работает спасибо за доклад очень интересно расскажите пожалуйста после того как я напишу алгоритма целый пласт верифицируем его как не накосячить когда я буду это нас свой целевой язык в коде переносить отличный вопрос да ну это уже талант как бы сказать разработчика но но не накосячить когда у вас есть спецификации на тело и класс гораздо проще потому что это и другой код переложить один ход в другой проще чем приложить особенно если такой не очень внятное описание и если это облако мысли у вас в голове переложить один кот другой будет проще поверьте окей уже есть следующий вопрос спасибо огромное за доклад это очень интересно и очень сложно и наверное это коррелирует друг с другом а скажите пожалуйста как вот моделировать различные ситуации вы имеющий опыт понимаешь нужно смоделировать что произошел что town как вот придумывать эти ситуации которыми нужно подвергать свой алгоритм чтобы он достигал совершенства ну во первых когда вы пишите какую систему вы примерно предполагаете что там может произойти делая пласт в этом смысле плоско очень хороший что вы можете спускаться на любой уровень абстракции вам нужно смоделировать потерю пакетов но отлично делаете моделируете сеть как там массив очередь и делайте так что в какой-то там не знаю какой то из этих пакетов вы просто теряете пропускаете не обрабатывайте дальше то есть вот что именно модерировать это на самом деле уже активно и пласт не относится это ваш опыт как разработчика а вот как это моделировать ответ я ожидал идите в комьюнити там всегда ответят помогут это прям очень просто и быстро спасибо вот как моделировать как раз таки очень важно спасибо давай давайте скажите пожалуйста можно с помощью вот тела и генерировать количество тестов которые потом нужно будет написать на ход потому что там было указано примерно 4000 различных прогонов и столько тестов конечно писать не хочется хочется какой-то минимальный набор ну во первых это не прогон это различное состояние системы в которых она пробывала вот во вторых можно ли использовать тело и для того чтобы из него что-нибудь генерировать генерировать ну наверное можно вот право тесты я честно говоря никогда не задумывался про то что из него генерировать код можно но очень плохо это действительно факт то что получается но получается не очень хорошо я думаю что если поискать установить это на самом деле довольно разумный вопрос да потому что смотрите келси для нас делает проверку практически всех возможных состояний системы в том числе и тех до которых мы там никогда бы в жизни не додумались и если попытаться каким-то образом анализировать эти состояния а келси позволяет вам получить полный дамп всех состояний да и например у microsoft в и же есть готовый инстанции сделай пас потому что они используйте лапласа и если там вашу модель слишком большая да и там там на вашем ноутбуке она начинает кипятить то вы можете воспользоваться там не знаю сервером побольше потому что это полный перебор у начальника парализуется или вот именно microsoft и наверное получив дамп можно из него вот вычленить какие-то кривые состоянии из которых можно сгенерировать там не знаю не не по крайне мере не тесты но посмотреть какие переходы это мы снова состояния в другую может быть там не на особенно сложными в общем я бы рекомендовал поискать в интернете возможность этот эту тему разрабатывал нужно говорить микрофон назад и просто спасибо за доклад вопрос кому лучше получить заниматься стоило им аналитиком или программистом программистом программист им архитектором аналитиков это вообще то есть это должен должны сделать люди которые пишут код это дает понимание понимаете пока ваша пока ваша идея алгоритма не записано оно остается просто идеей вы можете записать его в код долго больно да через ошибки можете сначала записать его в в спецификации когда те же самые ошибки для вас найдет тела сие причем немножко быстрее до того как вы их напишите и и это будет чуть чуть проще вот на моем опыте это настолько проще что вот телтейл и да вот visual studio со стеллой у меня запущена просто как калькулятор алгоритмов я его использую буквально для того чтобы проверить какую-то гипотезу вот у меня там пришла в голову мысль а вот наверное можно сделать так я такое беру там полчаса быстро пишу и потом у меня хватает там на два-три дня чтобы написать коллегам как именно нужно написать потому что я уже понял у меня и спецификация давайте для сохранения темпов вот рядышком вопросы а потом пойдем вот уже на на правую часть зол алексей спасибо за доклад мой первоначального просто что заставляет поэтому я хочу другую ситуацию ставить доводим нас это очень сложный алгоритм мы по нему построили модель с помощью tlc проверка игры все хорошо то есть мы построили моделей не так и мы потом по этой неправильной модели сделаны не правильную ориентацию . оставаться бывает их можно избежать отличный вопрос да так вот умысел импорта в одной из в одной из лекций он прямым текстом говорит бойтесь успеха если ваш ваша модель ничего не нашла проверьте модель да вот поэтому дар и конечно же когда я вижу что у меня там типа а симуляция закончилась успешно я иду и начинаю проверять там несколько раз потом начинают думать о какие еще вот такие вот там кривые случае я могу забыть чтобы на мне ещё потом добавить вот эту модель для того чтобы все таки заставить ее завалится поэтому ответ это тоже приходит с опытом как разработка давай сейчас вопрос из правой части зала второй ряд а потом вот ближе к двери человек день труп спасибо за доклад то очень интересно очень практически мне вопрос такой тоже практически вот вы в своей презентации рассматривали моделирование систему который ну там в конце получилось около ну десятки тысяч состояния но тут тоже не привозили никакого там никакой информации по времени на допустим если моделирующий сложную систему и у меня там просто комбинаторный взрыв происходит и состоянии там не знаю миллионами уже измеряется как это вообще ну сколько вот со мной сам процесс верификации займет да хорошо отличный вопрос смотрите значит очень практичный значит вот конкретно вот это вот модель на моем ноуте там могу про отрабатывать за 7 секунд вот вообще самая большая модель которую мне там доводилось построить эту модель довольно сложного распределенного хранилища записи телефонных разговоров там с рдт синхронизации с там с ренж мы так далее и там стимуляция конечно я залила что-то около по моему 60 тысяч 60 миллионов состояний и соответственно нашла там порядка двух часов до причем на довольно большом сервере 40 головам но повторюсь повторюсь microsoft а есть просто выделенные фермы потому что он имеет не просто распылять на одной машине ему можно дать задание он разбросает эти задания по кластеру машин и вот посчитает вам то есть там люди считают не знаю короче тебе они хвастались что у них но не хвастались плакались что у них там количество состояний итоговый этом при прижал сотни миллионов понятно спасибо на гopoдa port of нету что на gpu нету портов учитель если вы подумайте то вы поймете что это задача вообще никак не подходит для джипе и потому что здесь просто слишком много ветвлений понятно спасибо да сейчас вопрос все-таки из правой части зала потом глубине зала около стены я вижу чего ты вдруг спасибо за доклад я бы хотел спросить мы взяли кафку и смоделировали как-то но довольно сам по себе сложная система то есть на практике можно чему-то довериться чей-то модели которая будем надеяться что она корректно либо мы будем сами пытаться что сделать сложно звучит нет я думаю что я понял ваш вопрос смотрите у него тоже есть ответ значит во первых кафка дает нам некоторый контракт она нам дает обещание что она будет работать вот именно так как записано в документации мы можем этому контракту верить не верить но но значит вот одна из особенностей целый класс и одна из наверное тоже сложностей что оно в принципе делай пас позволяет моделировать на на любом уровне абстракции и вот это вот искусство умение выбрать тот уровень абстракции на котором вы сейчас разрабатываете ваш алгоритм это тоже то что приходит с опытом этому довольно сложно научить поэтому вот для этой модели мы говорим что вот указке есть контракт такая-то семантика мы работаем с ней мы проверяем валидность в рамках этого контракта конечно можно там не знаю упороться и попробовать смоделировать еще ну хотя бы не саму кафку но там например там ситуации что у кости есть звуки и перу какие есть там соответственно что произойдет если у нас выпадает один из узлов кафки но это уже будет будет как сказать гораздо сложнее и вот этот вот трейдов да вот где вам найти степень уверенности сейчас на самом деле самый правильный ответ такой знаете стеллой пласт не важно с какого уровня абстракцию моделей вашу уверенность точно будет выше результат будет точно выше даже если это будет прям очень-очень глубокая модель вот на самом самом высоком уровне как примерно вот это супер вот теперь в глубине зала рука и если вдруг я не вижу вашу руку сделайте так чтобы у вас услышал здравствуйте я тут за колонны интерес traveler алексей правее подойди ко мне поближе тогда увидишь этого спрашивает и тоже подойдут очень интересно ничего не понятно мне очень понравилось я хочу спросить вот про вот этот слайд тут написано что насчет тогда идрис слой детально разные сложность можете рассказать поподробнее что это такое так же обертки хороша я специально специально поставила вопрос суда потому что каждый раз когда и такого читается находится кто-нибудь кто хочет возвестить городу и миру о том что знает что такое как французы называют эту как американцы по понятным причинам силки это в общем такой такая как сказать другая система формальной верификации алгоритмов которые позволяют вам описать алгоритм описать доказательство это алгоритмы при помощи там и станьте солларов подтвердить что это доказательство верно вот и и этот процесс просто на порядки более сложный если у вас там не аэрокосмическая промышленность то хотя и не знаю вряд ли там их используют то тогда скорее всего вам это не нужно вам более чем достаточно вот дела и класс и тел see при этом я бы обратил внимание что есть а палач которые делают коллеги из-за информант systems который в общем пытается не пытается они вполне успешно себе это делает которые делал это кстати вот ответы на ваш вопрос коллеги в красном который стоит правый угол стола который в общем делает берут практически произвольную спецификацию на и тела и класс и пытаются автоматически вывести доказательство этого алгоритма то есть решает эту проблему steam иными способами не перебором то есть если у вас модель которые которую невозможно решить и да там по бывают модели которые в принципе бесконечные то тогда вы можете попробовать например а палач с некоторой вероятностью это вам поможет вот что касается элой это другой очень простой инженерный способ моделировать но в первую очередь структуру данных он работает с множествами они стэмп оральным логикой вот и там где не знаю если у вас есть какая то база данных с какими-то правилами взаимодействие изменения то я рекомендую посмотреть на то как работает или скорее всего вам он поможет спасибо последний шанс и он есть только у онлайна задать вопрос онлайн а вопросов нет один из этих вопросов да человек очень прочно в середине зала тянет руку напрямую тут явно хочет спросить а там еще так короткие вопросы и быстрые ответы привет спасибо за доклад у меня вопрос . надо more ность киста более прикладных языках уатта мордасти есть но атомарных операции есть ordering можем ли мы над класс моделировать и торнинг что проверять корректность алгоритмов ну конечно вы можете за бороться и залезть там внутри железа из моделировать взаимодействие как сказать орды ринга но здесь по словам а то мордасти и подразумевал что вот именно это действие будет и именно это этот предикат действие будет проверен тел сизо один раз то есть это не атомарных том смысле в котором вы наверное к ней привыкли при этом при этом если вы поищите различные спецификации тела и класс для для на гитхабе например а их там достаточно большое количество накопилось то вы можете найти как раз как раз например модели железо до различные ordering для различных типов железо которые моделируется на тело и пласт тела и по стати говоря довольно активно используют разработчики железа для того чтобы убедиться что он будет корректным спасибо супер ну и завершающий вопрос да вот человек середине зала с рукой отсюда я тут спасибо за доклад вот вы говорили что можно на любом уровне абстракции строить модели если у нас достаточно достаточно сложная система можно ли строить модели моделей и можно ли таким образом проверять уже не алгоритмы может быть архитектуру отличный вопрос да значит ну наверное строгий ответ можно вот но практично ли это вопрос во первых ласкал в том виде в котором есть не подразумевает модульности вы можете делать alpha ind как сказать усложняем ее модели на самом тела и класс и на самом деле это вот ответ не задали да это был бы самый отличный вопрос смысле вопрос не задали себе его задали когда нужно переходить от ласк ласко у к чистому тела и вы почувствуете в какой то момент времени вы поймете что вам удобнее писать на самом тела и пласт чем сначала писать на полоскали а потом смотреть что получилось и как то это модифицировать вот на тело и пласт такие вещи наверное ну не наверное точно делать можно вот но наверное это не очень практично потому что это получается слишком большая сложность понимаете преимущество всего этого заключается в том что вот этот вот алгоритм который там стал 113 страх он умещается в голове то есть можно сделать так что вы делаете много моделей но при этом не моделируйте все целиком а каждый раз моделируйте какой-то конкретный аспект системы у вас есть протокол can шейка вы моделируете процент как раз process can шейка и говорите потом для другой модели что контракт на вот этом вот вот этого протокола примерно такой и вы считаете что вы уже смоделировали он так будет работать вот это вот работает то есть системы которые смоделированы на разных уровнях разными аспектами разными моделями до такой я примеры видел и делал сам и это действительно удобно вот при этом такое переувлажнение но я бы не стал мне было бы страшно спасибо"
}