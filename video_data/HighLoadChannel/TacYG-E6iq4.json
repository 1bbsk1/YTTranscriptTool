{
  "video_id": "TacYG-E6iq4",
  "channel": "HighLoadChannel",
  "title": "Что стоит за дженериками в Go / Илья Горкун (Тинькофф)",
  "views": 323,
  "duration": 1676,
  "published": "2024-10-29T03:08:40-07:00",
  "text": "Илья гаркун и он расскажет что же стоит за дженериками в го Илья выходи на сцену так Всем привет Меня слышно Надеюсь меня слышно такая была забавная минута молчания я уже не понял к чему это всё окей Всем привет Меня зовут Илья Я являюсь разработчиком компании Тиньков и Сегодня я расскажу вам про то что стоит с дженериками в Go Что такое мономорфные Отлично Скажите его пару миллионов раз наверное логопед вам не нужен Я вот стараюсь его повторять намного чаще и также поймём как это связано с дженериками в Go Итак немножко обо мне как я сказал Я являюсь разработчиком компании Тиньков пишу на го довольно уже давно и также параллельно Я являюсь аспирантом занимаюсь алгеброй и логикой и поэтому когда появляется какая-то технология или какой-то компонент технологии которые имеют крутую базированный ма часть а особенно если он как-то подвязать то я безумно кайфую иногда хочется поковырять его поглубже примерно так и получилось и вот для того чтобы нам сегодня ковырять поглубже дженерики в Go нужно познакомиться с базовыми вещами Сейчас будет маленький дисклеймер будет немножечко математики Вы не бойтесь да мы на конференции по программированию для программистов но там такая математика что я думаю вы все её поймёте если не знаете то узнаете что-то новое интересное и первое О чём поговорим - это полиморфизм Я думаю что вы все знаете что это такое Я даже не буду просить вас поднимать руку просто стыдно просить поднять руку разработчиков Что такое полиморфизм но наверное вы все знаете полиморфизм от ооп Да это один из основных принципов ооп но нас сегодня будет интересовать более общий его случай то есть не то что там пишет в книжках про ооп А он такой Довольно простой общий случай что его можно по факту определить через его же семантику то есть слово полиморфизм идеальное слово древние греки за нас всё придумали красиво его описали и как бы в названии запихали Да если посмотреть на полиморфизм как на слово то он состоит из двух у нас частей это полиморфный То есть то что имеет много форм и как В целом можно интерпретировать полиморфизм Если вы ти кому-то объяснить либо не понимаете сами Представьте себе что у вас есть какой-то полиморфный объект это вот тот самый Да и есть другие объекты уже какие-то конкретные и вот эти объекты начинают смотреть на этот полиморфный объект и возможно тут два варианта Исхода Либо они смотрят на него и он для них всегда различен то есть для каждого конкретного объекта он выглядит по-своему Либо вы начинаете с ним взаимодействовать То есть он для всех одинаковый а потом уже когда с ним говорите он уже умеет говорить на конкретном языке конкретные факты то есть умеет полностью подстраиваться под конкретного его оппонента и вот этот Довольно простой факт нам нам будет сегодня также если вас интересует теория типов полиморфизм и вот вся вот эта внутрянка вот которая есть там где-то на матчасти то есть отличная книга пирса Бенджамина теории типа языков программирования она довольно увесистая там Кажется страниц 800.000 она даже на русском языке есть то есть если вам влом читать на английском то это довольно хороший вариант И эта книга знаете вот где вот такие вот выражения - это как бы не Скример для программиста это реально инструментарий который используется там повсеместно для того чтобы доказывать различные теоремы Лемы утверждения но нам сегодня это не нужно всё-таки я не настолько сильно хотел упороться Я сегодня хотел вот прийти к такому более-менее какому-то не точному определению но чтобы оно было понятное для всех и определение дово простое то есть нас сегодня будет интересовать полиморфный тип то есть не полиморфный объект полиморфный Тип и это то что время компиляции или исполнения программы может вестись по-разному да то есть обрабатывать различные данные либо содержать что-то по-своему в зависимости от ситуации этого нам вполне будет достаточно и вот вообще когда в прошлом столетии математики тогда красо программистов особо не было стали задумываться о том как нам опять свои вот эти абстрактные идеи то есть ещё замечали Да что математики любят всё абстрагировать То есть им не хочется работать там с числа там с многочленами с матрицами они хотят пытаться всё вот Загирова придумывают какие-то полугруппа полиморфизм Что это такое Это вот получается такое свойство когда ты можешь описать вычисление не привязывая к типу То есть у тея есть просто вычисление где говорится пожалуйста вот сделай вот это татататата Ну и отдай Вот это то есть да возможно максимум мы можем какой-нибудь констрейнт навесить там не знаю чтобы чтобы у нас там не знаю сравнение там было какой-нибудь либо операция сложение но ничего больше И вот таким образом они стали дело делать и в целом Это довольно очень легко описывается Ну то есть вот как это математик бы сделал бы он бы сказал вот есть тип есть тип есть вычисление функция какая-то ну э функция она вычисляется нам по барабану как она реализуется я математик Ну она вот так есть но мы всё-таки работаем в мире компьютеров в конечном каком-то пространстве У нас есть процессор у нас есть чеки памяти мы так сделать не можем Да и Поэтому возникает какой-то момент когда разработчик сказал что давайте добавим немножечко приземлённый добавим немножко какой-то инженерной части и стали реализовывать специальный полиморфизм Что это такое Это такой полиморфизм у которого есть Диспетчер диспетчер - это некая функция функция которая принимает в себе всё но у неё есть крутое свойство она внутри себя умеет идентифицировать Тип который ей пришёл То есть она такая Ага То есть мне пришёл тип Я работаю со всем но я могу понять кто ты на самом деле и ты ага ты являешься числом поэтому так где у меня алгоритм который работает с числом Вот ты здесь давай выполняй эту задачу Если у вас есть не знаю какой-нибудь c+ + то вы наверное знакомы с специальным полиморфизмом потому что у вас есть перегруз То есть вы взяли плюсик определили Или допустим как Ван будет работать с матрицами там взяли умножение поделили умножение на матрицу всё довольно просто и всё довольно легко Но если вы работаете в языке допустим как го у вас к сожалению такого нет да из коробки и вы делаете какие-нибудь дико страшные конструкции в виде вот этой Да ске там тапов внутри чтобы допустим реализовать умножение Я думаю вы так никогда не делали довольно упоротый код но хорошо Объясняет что такое специально полиморфизм на пальцах так вот вообще математики программисты обожаю Понятно городить различные абстракции идеи идеи и я уверен что за 70 лет поприща связана с полиморфизмом и с теорией типов ушла довольно вперёд Ну и так получилось у нас сегодня будет интересовать конкретный полиморфизм потому что вот если вы вспомните определение которое я дал оно сильно Похоже на то что вот мы используем повсеместно в разных языках программирования как Java Go и что-нибудь подобное Что такое generic и вот получается что реально тический полиморфизм - это и есть наш дженерик возникает вопрос хорошо дал описание как его реализовывать У нас существует вообще два варианта прям базовых прям базовые базовые базовые варианты Как мы можем пойти и реализовывать дженерик первый вариант - это упаковка или боксинг как его называют за рубежом что это такое упаковка очень нативная вещь для любого го разработчика Потому что если вы писали дого 118 то вы возможно её использовали что это такое упаковка это по факту возможность взять какой-то конкретный Тип и его обезличить то есть Давайте создадим такую ситуацию Когда мы можем взять любой Тип и просто стереть его какие-то конкретные данные Теперь они все у нас равны мы сделали вот Социализм внутри гузка Гоа и таким образом мы можем создавать какие-то более-менее абстрактные универсальные структуры данных алгоритмы но у нас возникают различные накладные расходы Да Нам нужно получается делать более логику более продуманную бизнес логику чтобы не кидать различный мусор в неё нам нужно где-то сделать ty где-то нужна рефлексия В общем возникают какие-то свои гемор ситуации Ну это довольно нормально то есть упаковка вполне хорошая реализация то есть там допустим раз её применяют И никаких проблем нет понятно что у них она более сложная но язык го пошёл по-другому пути и они решили использовать мономорфная проблема с дикцией это отличное слово И вот так получается что такое мономорфная вот повторяю за мной это такое слово как это слово нет не слово это такая идея очень похожая прямо на ту что разработчики Go используют довольно часто нуно Я думаю что Не каждый это использовал но многие использовали до Go 1118 Вам наверное приходилось писать какие-нибудь различные структуры либо функции Да и они у вас отличались только одним каким-нибудь маленьким местечком это то что у вас раньше тут функция была для Инта а потом вы написали что похоже для стринги Я думаю что кто-нибудь так делал кто-то наверное так и не делал Ну вот идея в том что давайте по-тупому писать различные имплементации одного и того же просто для разных типов она как бы есть в го и вот идея мономорфная только она более такая гиперболизированное Давайте мы возьмём и сгенерить для всех типов вот прямо для всего что у нас есть мы сгенерить что с точки зрения математики типа они могут там все счётные континиум множество придумать и у них проблем не будет да если мы программисты мы находимся в конечном пространстве и мы так делать не можем поэтому реализация в Go мономорфная с го 1118 не полноценно да на самом деле это и не надо потому что если бы мы реализовывали это бы полноценно Я думаю это просто бы не реализуемая была задача как это сделали разработчики го в общем Они вели такое понятие как gc Shape Что такое gc Shape gc Shape представьте себе ситуацию У вас есть какая-то конкретная функция которая является дженериков вы где-то её написали и она ещё any то есть она работать долж совсем то есть всё что у вас есть любой тип она должна принимать и это огромное количество но Давайте начнём примерно подсчитывать сколько у нас реально бывает типов в нашем коде Ну во-первых скорее всего вы используете какую-то базу у вас какая-то схема У вас есть какой-то контракт то есть примерно вы можете подсчитать что у вас какое-то конкретное количество ограниченных типов да то есть уже как будто не надо генерить Всё то есть монетизация уже в полном смысле уже не должна парова генерить всё второе допустим хорошо Мы почитали и так получилось что у нас в контексте вот текущего кода функция Вот эта function она используется только вот в шести типах то есть да у нас есть какие-то нативные типы У нас есть какие-то ан но пожалуйста их примерно шесть О'кей то есть из миллиарда каких-то возможных типов нам надо сгенерировать только шесть типов А что если посмотреть больше и получше на конкретные пары Да допустим string и My string видно что на самом деле они как бы по факту одно и то же да называются по-разному но как будто логика как они работают внутри компилятора она у них одинаковая и возникает вопрос А зачем нам генерить одно и то же да для Вот таких вот м двух одинаковых похожих типов Давайте не будем давайте мы возьмём и объединим их в один дишей и таким образом мы возьмём и сделаем уже не шесть алгоритмов а три алгоритма и потом на этапе эпе компиляции то есть мы пройдёмся мы сгенерить конкретную реализацию уже к конкретному типу То есть даже по факту не нужно никакой там диспетчер писать то есть за нас это уже сделал сам компилятор нам только нужно получается немножко подождать компиляцию немножко подождать пока у нас там появятся все необходимые эти вещи но это занимает вообще не незаметные на самом деле никакие секунды времени и просто сохраним их конкретной ран тайме где-нибудь там в словаре и будем ими пользоваться да то есть допустим самый тупой пример вот не знаю тупе я не придумал У вас есть какая-то импотент ная функция которая просто принимает в себе что-то и отдаёт что-то запускаем смотрим Что она выдаёт точка зрения ассемблера видим Ага мы сгенерировать три gc шейпа Один string int flot 64 сразу их поставили у нас в код то есть мы сразу знаем что вот в конкретной строчке кода с конкретным типом у нас работает такой алгоритм вообще никакого там подхватывания на литу н тайме нет всё делается довольно быстро и легко и так делается с любым типом который нам нужно отлично звучит отлично избавились от какой-то утопической идеи мономорфные задачам но всё ли так хорошо а хорошо или нет наверное есть какие-то подводные камни Ну во-первых есть такое понятие как не мономорфная функция ещё Более длинное слово Спасибо большое а то есть с точки зрения семантики языка и его логики мы можем определить вот такие вот вещи но они не скомпилировать не скомпилировать просто бы не запустилась бы программа потому потому что это такой Тип который возможно себе N вкладывает себя рекурсивно и получается когда у вас происходят компиляция у вас происходят вычисление шейпов чтобы потом её добавить в ранта поставить где-то необходимо в коде вам нужно конкретный Шей который работает с конкретным типом чтобы он его знал полностью Чтобы потом он для него сделал алгоритм Но получается что к такому вот типу он не может сделать D shap потому что он он всегда расширяется и как будто Фикси он не фиксированный То есть он всегда всегда всегда всегда всегда немножечко мутирует и получается что мы не можем как-то ограничить его сверху Да поэтому разработчик языка просто сказали такое не запускается Ну Вполне логично это просто влять себя в ногу вот Ну хорошо Допустим мы всё-таки смогли сделать его не каким-то рекурсивно бесконечным мы смогли его взять и вот ограничить то есть да он довольно страшный композиционный но как бы он конечен и мы начинаем его запускать запускать запускать в теории он должен закончиться Да потому что у нас конкретное количество операций но допустим На моей машине он не запустился потому что настолько жирный он безумно страшный что просто ну не хватает ему возможности скомпилировать мне пришлось его убивать процесс Ну что поделать То есть получается что такого допустим да мы можем ть shap но он просто не создастся просто физически потому что машина у вас не потянет вот ну хорошо это кейсы То есть это то что скорее всего в вашем продакшн коде не появится потому что ну какие-то безумно сложные большие материи Но то что то что вас точно будет это вопрос быстроты и вот тут возникают Уже вопросы есть отличное объяснение того как у нас происходит разбрасывание в шейпы Да я сказал что разбрасывание шейпы происходит по логике если у Вас как бы типы смотрят на один базовый тип они попадают в один шейп но если у вас вот я прямо даже выделю жёлтым что если у вас они оба относятся к указателям они тоже попадут в один Шей То есть получается что вот допустим 64 они попадут в один То есть тут возникает катодная ситуация что для них Даше Ну мы не можем сгенерировать хороший алгоритм Да потому что ну они работали немножко по-разному получается возникают какие-то такие узкие моменты и вот эти узкие моменты они на самом деле бьют по производительности Объясню почему возьмём допустим какую-нибудь базу данных которы полною на и посмотрим на кусок кода который получается был реализован насто интерфейсах Да просто был какой-то интерфейс который свою задачу и поэтому если вы знаете что такое интерфейсы то есть напомню что Да это по факту у нас виртуальная таблица это какая-то структур с каким-то указателем мы берём минова заходим делаем смещение доходим доходи функции выполняем функцию Профит мы сделали задачу то да у нас есть как будто катодные расходы но они как бы существенны то есть ина никак но если мы возм допустим и перем это то есть нам захотелось вот мы те самые люди которые бем за хайпом мы хотим там всё переписать на дженерики потому что это сильно модно молодёжно то что происходит по факту у нас как бы семантически чуть-чуть что-то отличается но сильно кардинально нет но если посмотреть что происходит под капотом то происходят Уже довольно какие-то интересные вещи Ну как минимум смотрите что у нас происходит так как теперь у нас есть ше мы должны до него добраться отдельно разыменование дойти до конкретного интерфейса потом уже сделать конкретные вещи то есть В текущей ситуации из-за того что у нас всё работает на указателях Да и мы выбрасываем его это счёт дженерик то у нас происходит одно дополнительное разыменование которое наверное для нас как бы ну не существенно Но если вы занимаетесь каким-нибудь системным программированием И вам существенно важно ка вас памяти выделяется или что-то подобного то как будто становится больно и вот тут мы бьём по производительности возникает вопрос А зачем было переписывать не понятно Это хорошо видно по быч макам То есть у нас есть допустим три реализации мономорфные то есть написали явно У нас есть интерфейс То есть как было сделано Изначально и у нас есть дженерик с указателем Ну и видно что у нас по по по параметрам беч Марков у нас как бы дженерика с указателем она как бы уходит далеко от всех в нехорошую сторону и выводы на самом деле довольно та бы быстро получилось А что у нас имеется Сегодня я хотел вам рассказать про то что у нас есть дженерики что на самом деле у них есть какая-то мат база есть какая-то теория и у нас есть дженерики как поне Мне кажется самый хайповый элемент нашего языка не знаю допустим в ноде это Event loop у нас скорее всего это Бут дженерики по сравнению с количеством статей Или видосов либо чего-то ещё что выходит на пространство русскоязычное и зарубежное его довольно много и скорее всего этот Хай будет довольно долго идти Потому что если посмотреть на прополз в гитхабе то желание развивать данный язык и данную фичу оно огромное Да и сейчас мы имеем довольно корявые дженерики которые немножечко у нас не самые производительные не самые гибкие с другими языками Ну вполне довольно хорошая вещь которая хорошо Давно развивается и главный Мне кажется вопрос - это как бы не гнаться за хайпом то есть не хотите переписывать на дженерики Переписывай то что реально нужно и то что реально даст вам какую-то скорость Ну и Experience А так у меня всё спасибо большое за внимание Спасибо Илья друзья самое время задавать вопросы и вот у нас есть первый вопрос в первом ряду Да конечно Да огромное вам спасибо за доклад такой вопрос вопрос мономорфные но это проблема которой уже сталкивались такие языки как c+ и как почему го решил пойти своей дорогой вы имеете в виду что они решили немножечко обрубить идею моци Ну то есть вопрос этот был уже несколько раз поднимался во всех ну то есть в сином семействе языков он это ре Почему го выбрал свой путь здесь Ой я честно не знаю как реши c+ но мне кажется что в целом идея стоит как бы делится на две довольно части во-первых нужно было найти что-то что фундаментально подходило бы под язык то есть именно генерить генерить генерить какие-то однотипные функции да и просто Либо этот разработчик Либо это будет делать сам язык ну и возникает вопрос но зачем генерить ВС если можно сгенерить что-то попарное в целом было бы интересно послушать как это сделалось ПЛЮСПЛЮС потому что я честно не знаю Если вы расскажете мне то было бы интересно сделать такой див понять как они сделали Ну да но если мы говорим про фундаментальную мономорфная задача Вот надеюсь ответил Угу спасибо Так ещё вопрос в самом конце зала О я вижу руку напоминаю Вы можете задавать вопросы в чат особенно те кто в онлайне нас слушает здравствуйте да Спасибо за доклад а сразу возникает вопрос А почему не сделали мономорфные У нас указатель то тоже можно сгенерить для разных типов разные gc шейпы разные реализации А как в моём понимании что интересный вопрос Честно не могу дать на него какого-то точного ответа Но могу просто пофантазировать поразмышлять что скорее на этапе компиляции статического какой-то генерации всех необходимых вещей это просто более накладно Чем допустим явно виде тся по значению чтобы вычислить Тип и сделать для него конкретный Вот потому что Ну скорее всего тяжелее вычисляется конкретный тип то есть про или про или звёздочка допустим вот с лучших вопроса получат подарочки у на и вот появился третий Я ещё не задал вопрос Это был вопрос из Конца зала но он плавно переместился чуть поближе вы говорили про gape для any и для any типов А что с типом comparable а в общем если мы говорим про либо про другие конты то на самом деле это не тип это просто некий О ну называе это сахар как бы у меня язык не поворачивается но в понимании того что это такое могу объяснить когда мы говорим про какие-то дженерики там прописываем там в интерфейсы какие-то определённые условия того что наш тип должен иметь это на самом деле в первую очередь только для первых для разработчика чтобы понимал второе - это для статического анализатора кода чтобы он понимал что вы кидаете необходимый тип Когда Вы начинаете компилировать вот этот код то у вас просто возникает раз валидация того что данный тип подходит данному условию то есть данной семантики данные получается функции если он подходит то мы начинаем делать для него dis shap если допустим раньше мы его не создали если допустим он не подходит то мы кидаем ошибку компиляции Ну и явно это показываем То есть все вот эти конструкции когда мы из any начинаем там писать что там comparable там какие-то другие констрейнт это в первую очередь просто для того чтобы Отбери какие-то недочёты разработчиков при разработке конкретной функции вот Спасибо Да ещ вопрос Да здравствуйте Спасибо заклад самый нерелевантные вопрос там на каком-то из слайдов был скриншот Виса Почему именно витес для примера очень интересно как так где-то Используйте Поделитесь пожалуйста своим опытом и ещё Главное вы туда код пишите контри СБО Нет нет вы говорите у меня была задача найти такой проект который бы раз был бы написан до годин 18 но это сделать довольно несложно два чтобы этот код пытался идти на хайпе и пытался переписывать какие-то вещи на дженерики И после этого мне нужно было просто понять стоила ли это игра свеч вот поэтому основная такая была мотивация это могут быть что угодно Даже какой-нибудь dec там пали архив в пакет Главное чтобы он обладал тем условиями поиска которые я искал Спасибо ещё вопрос с первого ряда Да Илья Спасибо за доклад ты вот упомянул что есть различные предложения по улучшению языка го в частности Как ты думаешь Какие основные векторы улучшения дженериков в го существует и как ты думаешь что будет ну я не могу сказать что какие Ой какие кае Какие конкретные бывают именно векто развития То есть можно посмотреть пополам но как будто самые популярные проползла которые я видел это во-первых чтобы можно было делать табличные тесты используя нормальное дженерики второе Мне кажется самый жирный такой это такой Java like это когда у нас есть возможность создать Урук метод у структуры Да который Бут конкретно с дженериков Да без Прив привязки к самой а именно дженерик к структуре То есть то что мне кажется многие сразу хейтили как сразу появились дженерики сразу появился этот пропол и стали его обсуждать он коже до сих пор открытый до сих пор там есть какие-то свои идеи вот Скорее всего я думаю многие разработчики которые ждали дженерики Ну это моё личное предположение это люди которые скорее всего вышли из каких-нибудь языков похожие на java.net или скалу тем более но у меня в целом есть проблема со скалой Я у меня Скала головного мозга Иногда я пытаюсь пописать Наго похожую на скалу Вот поэтому я пытаюсь брать те возможные какие-то имплементации использования дженериков так чтобы я мог бы реализовать какие-то хотелки похожие на другие языки там Java Scala like вот Следующий вопрос да от меня вопрос Спасибо за доклад на самом деле уже частично ответили в прошлом вопросе хотел уточнить почему Ну вы как любитель теории типов выбрали язык го для написания кодов в то время как ну можно выбрать функцио Ну сейчас бы на хале писать прокш но у нас есть Ха Я сам в шоке как-то раз в репозитории искал нашл много на самом деле написано не знаю по что кто-то заливает туда код там последнее изменение было неделю назад такие люди существуют аэ Да я это это было довольно вопрос наверное разделяемый то есть у меня было как бы желание работать зарабатывать деньги да и было желание заниматься наукой и как это показывает иногда нельзя совместить приятное с полезным вот поэтому ты выбираешь одно и другое и пытаешься усидеть на двух стульях Вот иногда это больно стулия разные Вот нуно вот поэтому это никак не связано то есть но я понимаю что как будто го язык не для меня Скорее всего в какойто момент я уйду с го что-то другое Просто попробовать просто посмотреть что Есть что интересное потому что с такими вариантами которые иногда пишу на ревю и прохожу ревью сразу возникает вопрос что-то делаю не так можно будет развлечься формулами выводимость я вот поностальгировать тогда самое сложное запомнил ли ты Два лучших вопроса Ну да конечно давай первый мне понравился вопрос связанный с comp котами потому что я хотел это подсветить в докладе но не успел поэтому спасибо что появилась мотивация это рассказать там человек который Вставайте выходите к нам у нас есть подарочек вот у нас есть один подарок получается от компании теньков а есть один подарок от спонсора правильно понимаю так и второй вопрос и второй вопрос господи почему так сложно выбирать людей вот у мужчина получается да да я я помню что он был к сожалению не помню о чём о но просто в голове у меня он отразился лучше чем если Вы повторите вопрос а развитие дженериков Да да это тоже довольно хороший меня зал в голову яма на полочке стоит тогда давайте так тогда получается вам я дам прямо сейчас пожалуйста а вам сейчас и второй подарочек подарочек там стоит он называется очень Забавно он называется кофер это почти как гофер только через к Вот я думаю что доверял го в нас в тинькове пытались не могут найти там Почему телефон где-то лежит блин сего не украли с кофром В общем подарок Лайф потому что это кружка кофейная кружка позволяющая вам пить кофе а и при этом вот он вот позволяющая пить Вам кофе который как бы да не он не нагревается и не остывает поэтому Пейте на здоровье в целом У меня всё всё спасибо или я Спасибо за доклад Спасибо за вопросы друзья а тебе конечно же почётный подарок как спикеру Спасибо большое всё Приходи к нам ещё и рассказывай интересные штуки СБО друзья"
}