{
  "video_id": "ANWOHxaXj9g",
  "channel": "HighLoadChannel",
  "title": "Монолит для сотен версий клиентов: как мы пишем и поддерживаем тесты / Владимир Янц (Badoo)",
  "views": 2184,
  "duration": 3111,
  "published": "2018-11-19T02:57:35-08:00",
  "text": "всем доброго я работаю разработчикам печатями и компании буду и сегодня мой сегодняшний доклад будет наиболее полезен таким же ребятам как я которые самостоятельно пишу тесты для бэкенда не понимают как тестировать legacy код имеются этим сложности написали уже такое количество тестов что просто результатов их прыгуна ждут часами ну и хотят тестировать сложную бизнес-логику в которой много всяких нюансов и деталей конкретно сегодня я расскажу вам о нескольких вещах поговорим немножко совсем чуть-чуть о нашем процессе разработки и на то как он влияет на нашу потребность в тестах и на наше желание описать эти тесты дальше пройдемся снизу вверх пирамиды автоматизации тестирования разберем какие виды тестов мы применяем и какие инструменты существуют внутри каждого из данных видов тестов какие проблемы с помощью этих инструментов решали и в конце поговорим о том как собственно все это хозяйстве поддерживайте запускать итак наш процесс разработки я вместе с моим хорошим помощником попытался проиллюстрировать наш процесс разработки иллюстрацией вот этот богатый замечательный успешный гольфист это наш backend разработчик в какой то момент времени ему прилетает задача на разработку прилетает она обычно в виде двух документов это требования со стороны бизнеса и собственно технический документ описывающий изменения в нашем протоколе взаимодействия между бы kindom и клиентской частью client-side он соответственно наш разработчик делает всю свою магию пишет код и собственно толкает это в продакшен наш backend выезжают первым вперед всех клиентов соответственно после того как backend выехал в весь этот функционал будет защищен какими-то фичи флагами или абэ тестами это все специфи руется собственно в нашем техническом документе после этого согласно своим родом а пом начинают выезжать клиенты для нас как бы коммент разработчиков зеркало без бочкам совершенно непредсказуемо эта ситуация когда клиенты приступят к реализации потому что наши продукты очень гибко лавируют приоритетами на реализации на клиент сойди потому что жизненный цикл у клиентов несколько сложный он более долгий нежели чем у нас да мы можем два раза в день выкатывать функционал и для нас это гораздо проще что здесь важно это наша культура вот это все зон ответственности backend разработчика наш backend разработчик отвечает за хочу от начала ее реализации на бэг-энде и заканчивая последний интеграции на последней платформе которые на которой планировалось изначально это фича реализовываться соответственно вполне возможность быть такой ситуации что ты выкатил какую-то фичу например полгода назад клиенты и долго не делали потому что приоритет у компании поменялись ты уже сидишь делаешь замечательные другие задачи у тебя какие-то новые сроки приоритеты тут прибегают те клиенты говорят слушай будут начали делать вот помнишь вот эту штуку которую ты полгода назад сзади play all и она не работает и ты вместо того чтобы заниматься как бы новыми блестящими задачами ты сидишь вот такой вот и тушишь пожар и пытаешься решить все проблемы которые возникли в прошлом и вот откуда здесь у наших разработчиков появляется несвойственная php программиста мотивация делать так чтобы проблем на этапе интеграции возникла как можно меньше что можно сделать в первую очередь но наверное это ручное тестирование до всех понятное дело как-то хотят проверить свой функционал я надеюсь они берут в руки приложения приложение этого не умеет это новая фича клиенты будут там через полгода не забывайте нет возможности руками протестировать ну точнее на есть и так всемогущ и карл и все остальное но это все очень сложно и неприятно ну и никакой гарантии нет что за то время пока вы за диполь или backend и дата момента когда начали интегрировать это на клиентах ничего никто не сломает вполне возможно что придет завтра какой-нибудь коллега вася и случайным образом ваш вашу крутую фичу поломает поэтому мы делаем особый упор и особое внимание уделяем автоматическим тестом у нас их много и начнем мы самых простых которые мы пишем это юнит-тесты сразу ск расскажу что мы используем печки качестве снова языка либо когда если если кто у нас еще не знает и в качестве фреймворка для тестирования используем печь принято забегая вперед скажу что в принципе все наши б contest они все написаны на базе печки юнита не только юнита не только юниты мы используем в этом ключе и так и не тесты чаще всего тестируют какие-то маленькие изолированные кусочки кода у нас это так мы тестируем методы или функции то есть очень-очень маленькую единицу бизнес-логике и наши и не тесты не должны ни с чем взаимодействовать не должны ходить не в база не в сервисы и это правило которое мы стараемся выполнять самое главное что сказано главная проблема с которой сталкивается к написанию не тестов это не тестируемый код берется он чаще всего из legacy соответственно например компании по душе 12 лет мы когда-то были очень маленьким стартапам из нескольких человек и вполне успешно этот стартап жил нет ни писав вообще никаких тестов понятное дело что какой-то момент мы росли и начали понимать что в принципе как можно жить без тестов как мы это делали раньше и начали их писать ну много кода написано он хорошо работает не будем же мы его переписывать просто потому что нам нужны выплаты покрыть тестами этот подход с точки зрения бизнеса но какой-то не очень поэтому мы разработали такую маленькую библиотеку на самом деле которое очень сильно нам помогает писать тесты быстрее называется на софт макс работает очень просто она перехватывает все in cloud и пички файлов то есть все подключения файлов и просто на лету подменяет исходный файл который запрашивали на модифицированное содержимое буквально на переписанный код и собственно с этим подходом мы нам это нам позволяет нам локоть глобальный любой код и обходить в том числе ограничения библиотечка доступна в open source в конце моего доклада будет ссылочка на git хоп и на страницу с подробным рассказом то как это функционирует под капотом я не буду об этом на этом становится подробно примерно вот так это выглядит для разработчика то есть мы можем переопределить все что хотим вот такими конструкциями не хитрыми и в том числе мы позволяя это позволяет нам обходить стандартные ограничение стандартного махера hope you need a то есть мы можем мог и статические методы мы можем мог приватные нужен среди понять константы и много чего еще делать чего нет в принципе невозможно в обычном паха при unity проблема с которой мы столкнулись это такая скорее психологическое до при наличии софт мог of кажется что писать зачем писать тестируемый код мы в принципе можем всегда нашими глобальными муками все это причесать и все будет хорошо работать но понятно дело что такой подход ведет к нас усложнению кода к его к стильности и для себя мы приняли несколько правил которые позволяют нам держать это под контролем во-первых весь новый код он должен легко тестироваться стандартными мог ими по hope you это то есть это значит что если это так ты значит только тестируемый он легко изолируется легко выделить кусочек маленький кусочек и только его потестировать софт мог и по-прежнему допустимо применять это касается старого кода который соответственно написан не неподходящим образом для июне тестирования ну и в тех случаях когда действительно по-другому сейчас сделать дорого долго или трудно то есть в данный момент софт мог ими дешевле это сделаете быстрее запустить хочу чем что-то там начинать и factory чтобы сделать с портами соответственно мы на этом на эти правила мы уделяем время на кадре view второй момент который потом можно сказать в контексте unit тестов это качество и не тестов я думаю что у многих из такая метрика как процент покрытия кот говорит но они к сожаление отвечает на один вопрос хороший ли я unit-тест написал ведь вполне возможно что вы написали такой тест который на самом деле ничего не проверяет не содержит ни одного сорта при этом генерирует отличный кого ridge понятно дело что пример утрированно но вполне реальная ситуация седана времени мы начали внедрять новый инструмент называется мутационные тестирование это старая известная концепция алгоритмы и довольно простой мы берем код берем к нему код к врачу и собственно после этого парсим исходный код пробегаемся по нему и начинаем там менять знаки тру на фолс быть таким злобным буратино который хочет навредить и и для каждой такой мутации для каждого такого изменения которое мы генерируем мы прогоняем сью тестов который измененную строчку покрывает и если ты ступали ну тесты классные действительно не позволяют нам сломать наш код если туда придет какой-нибудь коллега вася после этого и сделать то же самое то наши тесты быстренько упадут и не позволит ничему сломаться ну вот если тесты прошли это уже ситуация интересная скорее всего эти тесты недостаточно эффективный нам возможно стоит посмотреть на них внимательнее добит докинуть каких-то heart of возможно у нас есть какой-то принципе не покрытый тестом кейс и несмотря на колареш наш тест возможно не очень эффективен для печки существует несколько готовых решений хороших решений например ханбок infection отличные фреймворке но к сожалению нам они не подошли потому что я не совместимы с нашей политикой софт бокс то есть мы ну можно было сделать совместимыми переписав там наполовину тот же ханбок и поэтому мы написали свою свое решение свою маленькую утилиту которая делает то же самое но использует наш внутренний колареш и дружится с маками сейчас мы пока сделали это только в виде консольные утилиты то есть разработчик должен проявить ответственность зайти запустить это руками посмотреть на свои тест к которой он написал и мы сейчас внедряем наш pipeline этот инструмент с тем чтобы работать с этим системно и как только у нас появится мы закончим с этим мы обязательно поделимся результатами в нашем блоге на хабре и так с юнитами все следующий класс тестов которому пишем это интеграционные тесты интеграционные тесты должны протестировать несколько компонентов связки и мы проверяем в том числе ими взаимодействия с различными сервисами которые у нас есть и с базами данных в том числе чтобы мой пример был более нагляден давайте с вами попробуем вот такое промо сегодня разработать и покрыть его тестами представим что наши продакт-менеджер захотели раздать билеты на холод нашим самым преданным пользователям который в этом заинтересован и у нас есть такие условия там определенная работа определенный бы тест и по кнопочке получить билет мы должны сохранить этого пользователь в какой-то список чтобы отдать нашим менеджерам которые раздадут билетики что здесь мы не можем никак протестировать юнитами вот эту вот штуку нам взаимодействие с базами нам мини тестами тестировать ним запрещено мы не можем это делать соответственно мы тестируем это с помощью интеграционных тестов каким образом вообще тестирует взаимодействие с базы ну вот пить пиво и предлагать нам вот такой подход мы поднимаем некую тестовую базу данных мы описываем дата требовался касаясь структуры которые описывают как нам подготовить нашу тестовую базу к тесту после этого мы запускаем тест и в конце собственно очищаем тестовую базу данных какие проблемы в этом подходе есть нужно поддерживать дополнительных структур и понятно что если вы поменяли схему таблицы вам нужно будет отразить эти изменения в том числе и в тесте это не всегда удобно это требует дополнительного времени плюс к тому же нам необходимо время на то чтобы дополнительно тебе чтобы подготавливать базу данных каждый раз при сетапе теста нам нужно что туда залить создать какие-то таблицы и это в принципе довольно долгая и на грустно когда у вас много тестов ну и сама важный недостаток который я здесь это то что параллельные запуске таких тестов они делают взаимно взаимно нестабильными друг друга то есть грубо говоря если вы запустили тест а он начал писать в одну тестовую табличку который сам создал запустили тест б он хочет работать столь же тестовой табличкой и вот здесь возникают де блоки и возникают всякие не при неожиданные ситуации и вот именно из-за этой причине мы в основном разработали свою маленькую библиотеку называется тебе макс у нее очень интересный простой принцип работы мы перехватываем суть с помощью все те же софт мог of все наши обертки через которые мы работаем с базами данных думаю что у всех используется какая-то одна редко когда кто-то там их начинает множить дальше мы когда запрос проходит через наш мог мы вытаскиваем из запроса имя базы данных тоже парсим буквально secure запрос вытаскиваем базу данных табличку из connection достаем холст которым мы обращались собственно том же хостел втм pfs мы создаем temporary tribal с такой же структура какой оригинальный и после этого все запросы которые через наши маги будут пролетать к этой таблице мы берем просто нагло переписываем sql запрос и заворачиваем эти запросы во временные таблицы при таком подходе нам в принципе не надо постоянно заботиться структурах мы эту библиотеку не запустили пока просто потому что они дошли руки но она правда очень маленькая у нас она занимает 300 строг со всеми там нюансами которые в принципе возможно повторить легко что мы получили ее применив нас тесты никогда теперь не могут повредить данные в оригинальных таблицах потому что они с ними не работают то есть мы на лету их и заворачиваем в другие мы по-прежнему ходим честно в майские ли мы ходим на выходим на тот же хвост на которой находится оригинальной таблицы то есть мы по-прежнему заботимся о версии мозг или который который мы работаем если например наш запрос вдруг перестал быть совместимым с версии мы съели новой то наши тесты тапок ловит и упадет ну это езда на что добились то есть изолированным их прозрачно завернули в разные таблицы у каждой время творится есть какой-то уникальный суффикс и все они даже запустив одинаковый тест параллельно в два три потока они в серое зайду ца по разным временным табличкам и тем самым друг другу не помешают итак с интеграционными все перейдем к самым интересным сложным тестом который мы пишем называются они опять есть вот принципе их принцип работы демонстрируются вот на этой замечательно анимации наш замочек работает отлично ну вот дверь которую мы его прикрутили вообще для этого не предназначена наши тесты имитируют клиентскую тест сессию клиентский девайс они умеют слать запросы в бэг-энде соблюдая наш протокол они знают наш протокол и backend отвечает этим тестом как реальному клиенту то есть он не понимает это android или вообще или лета тест что нам нужно чтобы написать такой тест но вернёмся к нашему промо если посмотреть внимательнее у нас здесь все про пользователю пользователь пользователи на самом деле 99 процентов таких тестов они требуют авторизованного зарегистрированного пользователя с которой соответственно будет во всех сервисах будет в базе данных с ним можно успешно работать и так далее где его взять но можно пойти в лоб попробовать его зарегистрировать момент с то это медленно ресурсоемкая каждая регистрация занимает какого-то времени после этого завершение таким пользователям что-то сделать наносим как-то разобраться там удалить его почистить тоже довольно нетривиальная задача на больших проектах ну и особенность нагруженных систем думаю что многих так вы много операций выполняете в бэг-энде как и мы фоне то есть когда у нас пользователь зарегистрировался после основного процесса еще есть всякие там подземные операции это типа репликации в другой дата-центр добавление в какие-нибудь сервисы специфичные и вот в этот момент естественно шт с может быть нестабильный если он взаимодействует каким-либо образом с этими данными и зависит от этих фоновых процессов неявно мы изобрели такой маленький инструмент самом деле уже не маленький называется он пул тестовых пользователи собственно мы в основе него лежит две идеи давайте мы не будем каждый раз регистрировать пользователь давайте их будем переиспользовать и второй надо этих пользователей очищать работает примерно так приходит к нам на наш наш пул тест или в данный момент с даже при ручном q&a мы используем этот пул или ей тесты используют тоже и тот же пул говорит нам не нужно вижу пользователь определенного пола определенного возраста вот с таким именем вот в этом городе мы идем в наш пул смотрим а если сейчас такие пользователи с такими характеристиками вот в данный момент времени в пуле свободные если нет мы их создаем и отдаем тому кто хотел по пользоваться этим пользователем и после теста мы проводим очистку соответственно мы сбрасываем данные пользователю до первоначального состояния до того момента как они были вот такими какие они были в момент его регистрации это важно потому что если этого не делать то естественно вас тесты со временем станут нестабильными потому что пользователи будут загрязнены информации из других тестов если например воспользоваться одним и тем же пользователем подряд на одинаковом тесте скорее всего он у вас 2 его запуск не пройдет потому что там какие-то данные уже есть которых изначально не ожидалось увидеть главное нас проблема которая здесь возникла которую мы решали в какой то момент мы захотели запускать наш и опять тесты на продакшен окружении почему мы захотели это делать но потому что devil это не тоже самое что и продакшен это хоть мы пытаемся постоянно повторяет инфраструктуру продакшена в уменьшенном размере это не то же самое и чтобы быть абсолютно уверенными что новый наш build увидел соответствует ожиданиям что он с ним нет никаких проблем мы выкапываем на пре-продакшн то есть выкладываем новый код на пре-продакшн кластер он работает с production данными с продакшен сервисами и на этом мы прогоняем наши опять кости соответственно если вы не будете не подумать о том как ваших тестовых пользователей изолировать от реальных у вас может быть примерно вот такая вот ситуация вот что будет нашем приложении если наш пользователи наши пользователи вы c наружу спасибо олегу чтобы произошел попользоваться его фейсбук и фотографиями как сделать эту изоляцию но мы сделали вот таким способом у нас есть флажок у каждого пользователя и стать юзер он на этапе регистрации становится если ну и собственно после этого не меняется по флагу мы во всех сервисах внутри этих пользователей за леру им тестовые только с тестовыми видят их и же живут с ними вместе не тестовые средстве на видят только не тестовых и собственно что важно мы исключаем этих пользователей из бизнес-аналитики потому что если вы этого не сделаете в какой-то момент у вас внезапно может какой-нибудь абэ тест там перекосится в не в ту сторону в которую вы ожидаете просто потому что есть сценарий который очень крепкий сам все это прогоняет ее генерируют значительно искажения статистики можно сделать дешевле в какое-то время у нас в принципе мы начинали с подходы что мы просто пользователи переселяли в условную антарктиду тестовых и собственно не там варились вместе с пингвинами если у вас дела сервис принципе наверное какой-то момент этого вполне может быть достаточно и так что еще нам нужно в какой-то момент нам могут понадобиться маки зачем нам нужны ноги но у нас вот есть ой я скакнул вперед извините помёта что нам нужен пользователь нам нужен пользователь в определенном состоянии у него должна быть определенная работа у него должно должен быть определенным в тесте и зарегистрирован более двух лет назад по словам нашего простого промо если работу мы можем легко с помощью нашел backend api стандартного для клиентов поменять то например вот уже попадание в бтс это носит вероятностный характер мы не знаем этот тестовый пользователь в тесте или нет и предугадать сложно ну и условии что пользователь зарегистрирован более двух лет назад вообще сложно выполним а потому что мы не знаем когда там этот пользователь в пулей был при боковом в там появился чтобы вот эти проблемы решать у нас есть инструмент называется крепи это по сути бэкдор для целей тестирования что это такое это хорошо документированные пи методы которые позволяют быстро и легко управлять данными пользователя и менять их состояния в обход основного протокола нашего общения с клиентами их пишут backend разработчики и пишут их для собственного инженеров и для того чтобы использовать в различных тестах такие как api тест клей тестах важная особенность что эти тесты можно при этом как тестовым пользователем то есть если у пользователя нет флажка the test сразу же упадет например вот так как то выглядит один из наших крипер методов по который позволит нам поменять дату регистрации пользователя на абсолютно произвольную ну и вот так будут выглядеть собственно три вызова которые позволят нам быстренько подкорректировать данные тестового пользователя те которые нужны чтобы он попадал наша промо граблях так как это бэкдор нужно подумать о безопасности и это очень важно мы защитили наш сервис низкими способ во-первых мы изолировали на уровне сети никак кроме как из офисной сети к нему не попадешь никаким способом не подступишься очевидная штука второе мы с каждым запросом передаем секрет выделяем секреты человеку команде естественно всегда знаем кто какие методы выполнял и без этого секрет естественно даже имея доступ к сети не копии доступ не получишь мы еще раз даже если что-то методы работы только с тестовыми пользователями и в принципе навредить сервису с помощью этих 7 копия методов тяжело у нас была история когда наша 1 наш клиентских команд встроилось в клипе сделав дыба панельки просто доступ быстрый копию естественно они зашили secret code и естественно в какой-то момент забыли вы пилите то есть продаж он дал да и это очень замечательно дизассемблер овала и в принципе секрет нас замечательная удобной xml карта и всех путей до наших кабеля методов была доступна в некоторыми в продакшене естественно мы как бы ничего не произошло потому что если тела изоляция даже это знаю тяжело еще к офисной сети подобраться ну и методы по-прежнему не работают с тестами ничего с ним поделать ну и последнее что с все что там еще помогает это бакс баунти программа на хакерман этот инцидент именно там и зари портили мы быстренько это звали этот секрет попросили конецкую команду так больше не делать вот если у вас есть какая то вы знаете о какой-то прорыв безопасности в буду приходить и на хакерман мы платим за свои ошибки последняя вещь которую нам может пригодиться в контексте оперой тестов и to make ну у нас есть софт моки но как вы понимаете бэкон как правило удаленный в пятистах мы не можем их инициализировать локально собственно эта библиотечка позволяет нам быстренько инициализировать мог в нашей промо это может быть полезно в принципе моки для таких тестов в двух вещах по-прежнему мы нам нужно как-то работать с базой если например мы в опять тесте на продакшен окружении начнем ходить в базу данных нам нужно заботиться о том чтобы данные в этой базе были очищены в результате от тестовых то есть чтобы наши тесты не засоряли production базу и какими-то данными и второй момент очень важные нам боги помогают сделать ответ теста более тестируемым о чем я говорю например у нас есть три текста выделены вот красненькими кружочками году приложение многоязычная средства у нас есть сложный компонент локализации который позволяет нам быстро переводить и получать переводы для текущей локали пользователя и соответственно наши локализаторы постоянно работают над улучшением переводов они проводят всякие б тесты на для xiaomi то есть меняют формулировки чтобы они были более удачными мы не можем совершенно полагаться в тесте на то какой текст нам будет возвращен сервером потому что он будет меняться все что мы можем сделать это проверить что мы правильно обратились компонента локализации соответственно у нас есть там называются не his name и то есть это имя текста под которым мы ожидаем которые мы ожидаем увидеть вот в этом конкретном про промо блоке мы собственно помощью ремонт блоков позволяет сделать ответы сервера более тестируем более пригодным для тестирования и так как работает ремонт make очень просто это все те же софт бокс но мы можем инициализировать их удаленно то есть тест просит backend инициализировать софт ноги для своей сессии описывает их и при получении всех последующих запросов backend проверяет наличие мог а для текущей сессии если они есть он просто инициализирует из попусту за помощью с помощью той же библиотеки софт бокс для программиста выглядит это вот так то есть если вы хотите какой-то удаленный мог вы буквально говорить о какой класс метод на что поменять и все ваши последующие запросы по кендо будут выполняться с учетом этого мог а ну и соберем наш тест месте посмотрим как мы протестируем наше промо с помощью опять теста вот этим способом мы получаем клиента эмулятор клиенты внутри которого есть уже зарегистрированный и авторизованный пользователь какое-то не важно с какими характеристиками нам в данном тесте неважным после этого мы у чуть-чуть подстраиваем с помощью копья то есть буквально вот с помощью такого способа вызываем три метода который быстренько его tuned после этого мы делаем так чтобы по нажатию на кнопки наши данные ни в какую базу данных не записались просто метод вернул что я все записал и собственно делаем запрос согласно нашему мобильному протоколу делаем запрос к бренду и убеждаемся что ответ вернулся тот который мы ожидаем что там вернусь правильные поля в той последовательности ссылка на верную картинку нужно или всем им и подергали и после этого делаем второй запрос на же есть кнопка делаем вид что где он такой запрос который пошлет клиент при нажатии на эту кнопку и проверяем что там играл за ответ который мы также ожидаем вот таким нехитрым способом мы в принципе можем тестировать любой функционал который прилетает нам на разработку в бэг-энд и требует от нас изменений в мобильном протоколе с какими проблемами столкнулись api тест у нас получились слишком удобными для разработки это правда у нас появился тягой соблазн просто очень сильно использовать их везде новым что их так классно писать это действительно занимает очень мало времени и просто мы в один момент осознали что мы начинаем с этими задачи для которых они не созданы почему эта проблема но потому что опять с той они очень медленные они по своей природе медленно и не ходят по сети они дергают backend который поднимает сессию ходят в базу ходит сервис 1 series 2 и так далее а юнит-тесты делают это очень и очень быстро мы приняли 5 для себя набор правил цель наших опять тестов тестировать протокол взаимодействия между клиентом и сервером и правильность интеграции нового кода что есть то что он начал исполняться в нужном месте и в принципе его достижимость данного в новой фичи допустимо проверки это сложный flow когда у нас есть какая-то цепочка чтобы там что-то получить клиент должен сделать abcd вот это тоже хорошо тестировать этими тестами но очень плохо тестировать такими тестами куда мелкую вариативность ответа сервера например у нас есть какое-то боли в промо блоки в одном конкретном и мы например там зависимости от ситуации возвращаем картинку а b или c разные просто пускай даже это будет какой-то бы то есть вот очень плохо тестировать t5s там это легко ложится юнитами мы проверили просто что у нас опять с там что асад промок вызывается возвращает 100 клиент а вот что-то внутри этого поля в тут вариативность там можно протестировать свободно юнитами которые выявляются за доли секунд а ну и раз уж мы прошлись по мере видеть скажу пару слов ай-яй-яй тесты мы не пишем у нас есть специальная команда в департаменте да мы в принципе не можем писать у нас клиента нет вообще что мы там не будем тестировать мы покрываем ею тестами фичу когда она стабилизируется у нас достаточно много экспериментов и тратить ресурсы на автоматизацию достаточно дорогую feci которые возможно в принципе и там дальше не тест дальше оба теста никуда не уйдёт не разумно поэтому мы делаем это когда он уже уверены что этот функционал уже какое то время будет точно в приложении и он нам нравится из мы используем коллабов для мобильных авто тестов и selenium используем для либо в конце я приложил ссылочку на доклад моего коллеги и зла наса тиша которые в котором он рассказывает про нашу платформу для автоматизации тестирования pisa кому то интересно может ознакомиться ну и последняя вещь о которой я сегодня хочу с вами поговорить это собственно о том как прогонять все тесты которые мы уже написали посмотрим на примере буду у нас сейчас 100000 unit тестов и из них 6 помимо них есть еще шесть тысяч интеграционных и 14000 опять тестов если посмотреть по времени запуска и попробовать запустить эти тесты в один поток даже на самой мощной машине которые нас на данный момент есть the program всех тестов заменить за ними неопрена unity 40 минут интеграционные 90 и опять тесты 10 часов ну то есть в принципе дождаться выпал результатов за один рабочий день с таким подходом невозможно поэтому первое что мы сделали мы решили это дело распараллелить и сразу за ложится таким образом чтобы можно было наращивать железный железяки и ресурс это сделали клауд для параллельного запуска тестов упрощенная на самом деле клауд выглядит очень просто и много деталей много нюансов но общая идея попеременно простая у нас есть не кистью тестов который мы хотим прогнать мы разбиваем его на кусочки каким-то образом дробим и каждый этот кусочек прогоняем в параллели где-то на нашем claude нашим наших железках и после этого нам нужно собрать простых результаты от всех этих кусочков собрать один в репорт и вернуть заказчику прогона самый интересный вопрос который здесь интересно обсудить это то как распределить наши тесты между потоками просто как нарубить наш суд но вот эти маленькие чанки можно поделить их просто тупо поровну по количеству но у этого подхода очевидный недостаток что все тесты разные и будет может возникнуть довольно сильный перекос по времени исполнения какого-то потока о например один поток будет бежать два часа все остальные успешно завершаться за какие-нибудь 10 минут можно взять попробовать запустить несколько потоков и просто по одному эти тесты им скармливать но тут недостаток не так очевиден но есть на инициализацию окружения pitch пию не тратит некоторое время и ему естественно нужно там погрузить какие-то файлы подгрузить наш autolot достать класс все остальное то есть на инициализацию окружения есть накладные расходы и которые при большом количестве тестов и таком подходе начинают играть важную роль что сделали мы мы начали собирать статистику по времени прогона каждого теста то есть мы буквально знаем о каждом тесте сколько времени в среднем он исполняется после этого мы начали компоновать наши чанки таким образом чтобы один поток пробегал по статистике не больше чем за тридцать секунд очень простая штука получилась при этом мы довольно плотно упаковываем наши тестов чанки максим минимизируем количество chunk of the делаем так что теперь делаем так что запуск тестов стал совершенно предсказуемым по времени то есть мы по статистике точно знаем сколько ни завершатся какая здесь проблема но она связана с нашими 5 тестами они очень медленные как вы уже поняли и они занимают много ресурсов не давая выполняться нашим быстрым тестом например мы можем занять свою очередь опять тестами просто все ресурсы клауда а юниты которым мы запускаем чаще и в больших случаях они просто буду ждать хоть они могли выводится быстрее что мы сделали мы собственно и взяли и разбили наш клауд на две части первая часть занимается только запуском быстрых тестов и никакими больше а вторая часть может запускаться как запускай как быстро и так и медленно и тесты при таком подходе у нас всегда есть какая-то какой-то кусочек клауда который способен принять быстрые запросы быстрые тесты и тем самым мы не будем забивать ресурсы нашими опять тестами что оцените получилось было вот выигрывать такие цифры напомню вы пришли к тому что у нас юниты стали про гоняться за одну минуту clicker зале по за одну минуту интеграционные за 5 и опять если всего лишь за 15 минут то есть почти 12 часов однопоточный прогоне мы щас пришли к тому что все все наши тесты про гоняются за двадцать две минуты максимум следующий момент последние которое мы хочу рассказать собственно у нас монолит монолит большой и достаточно сложный и соответственно по хорошему надо постоянно гонять все тесты для монолита потому что всегда есть риск что поменяв что-то в одном месте вы что-то там сломали в другом непредсказуемой да вроде как основной недостаток монолитная архитектура но честно в какой то момент мы пришли к мысли что нам не надо применять каждый раз все тесты и мы начинаем начали гонять тесты просто походка враджа концепции подход простое мы берем наш пронзив мы используем фича branch и при разработке и легко взять брандриф от мастера после этого мы абразив формируем список измененных файлов и по каждому такому файлу получаем список тестов которые эти файлы покрывают и вот из этих тестов мы состоим сьют и запускаем его прогон на нашем claude собственно здесь главный вопрос где взять кого ridge но мы делаем это раз в сутки собираем его ночью наша когда наша devil инфраструктура простаивает собираемого для текущего мастера и складываем в базу данных у такого подхода есть плюсы что мы стали существенно прогонять меньше тестов прям намного и скорость реакции скорость обратной связи от теста она увеличилась в разы то есть буквально можно там если ты поправил одну строчку в одном файле то скорее всего у тебя будет на это 23 теста который только надо прогнать и ты получишь результат и за секунды ну и побочным результатом стало то что мы стали нас появилась возможность прогонять тесты для патчей несмотря на то что буду уже давно не стартап у нас все еще есть возможность быстро внедрять изменение на продакшен то есть у нас есть возможность быстро залить какой-то hotfix у нас есть возможность быстро там раз катить какую-то хочу поменять ее там конфиг и тем самым сделать возможность изменить какой пропорции например там кто получает хочу акты получаете чубакка как правило нам в патчах очень важно именно скорость и поэтому ждать полного пригодностью то там не всегда предоставляют старалась возможным и прогон по колледжу здесь дан был дал большой прирост потому что нам теперь не нужно постоянно ждать три нова прогона тестов ну подхода есть минусы мы ревизий бэкон два раза в день соответственно говоришь актуален только соответственно для первого релиза для первых пирог билда до 1 голда после этого к врач начинает отставать на один билд и в принципе мы с этим что мы сделали мы для билда все время прогоняем полностью то есть ли нас такая гарантия что наш кого лишний день не отстал что прогона тестов до этого выполнились все которые нужны и худшее что может случиться что какие-то упавшие тесты мы поймаем на этапе сборки билда они на предыдущих этапах но такое случается очень редко второй подход оказался что этот подход не очень хорошо работает для опять тестов потому что для 5 ст вам это же собираем колареш но тесты эти gear уют коварж очень обширные то есть они по своему пути следования по пути тестирования логике поднимают кучу разных файлов ходят в сессии в базы и так далее и собственно по трогают все что можно и все что нельзя если в одном из таких файлов что-то поменять естественно что все протесты попадут к вам суд и принципе плюсы подхода под этим нивелированы ну и подведем итоги мы моего рассказа вам нужны все уровня автоматизации тестирования пирамиды автоматизации чтобы быть уверены что у кого-то пицца работает правильно если вы какой-то из уровень не пропустили но вероятность что какая-то из проблема осталась незакрытой и вы не может быть уверены что там все хорошо количество тестов это не тоже самое что качество уделяете времени ревью на куда review тестов и это циона тестирования полезен инструменты для себя его внезапно открыли он может действительно помочь сделать ваш ивентисты лучше если собрались работой с тестовыми пользователями подумайте пересекаются ли они из продакшен с реальными пользователями и не забудьте исключить их из статистики не бойтесь быкадоров это полезная вещь и они действительно помогают и упрощают и ускоряют написание тестов и помогают в том числе очень сильно ручному тестированию ну и статистика еще раз статистика имея статистику по теста можно вытворять всякие финты вроде улучшать например реализацию прогонов или все тот же подробный кот говорит статистика подробного код говоришь поможет вам запускать меньше тестов делать это более прицельно это ссылки которые вам обещал вот этот qr-код замечательно это собственно на саму презентацию в ее можно уже прямо сейчас скачать не ждать организаторов и внизу мои контакты если у вас есть какие то вопросы все что угодно у меня все спасибо спасибо большая красавец друзья время задать вопросы и подарить успокоительный приз спикеру а кличко не будет коньячка это это не здесь это коллеги тебя жду для подал хорошо спасибо так первый вопрос вот пожалуйста да меня слышно ильин александр компания воздев у меня вопрос такой у вас один тест клауда всех разработчиков да один на всех почему вы вы экономите то есть почему вы не можете сделать 10 тест клаудов и писать спокойно интеграционные тесты массовой вместо юнит все период помимо помимо того что у нас них не то что не хватает ресурсов нам жалко денег на железо есть еще существенное время которые мы оказываем на поддержке таких тестов данным если они взаимодействуют и сервисов они могут стать нестабильными какой-то момент ну нас чуть-чуть поменялось эта архитектура например какой то процесс уехал фон и тест стал нестабильным то есть нам нужно это контролировать отлавливать и понимать это средства на поддержку опять и ставками то что ни сам запуск проходит долгое время нам ещё необходимо тратить нрс количестве ресурсов на их поддержку с юнитами проблем меньше существенно меньше и вот мелкий функционал его гораздо проще и легче тестировать юнитами и не вкладывать в релиз то есть вам кажется что время на поддержку мог of она окупается время на поддержку да на вам кажется что это работает лучше окей спасибо спасибо за доклад у меня может быть немного похожий вопрос почему бы не поднять но я не знаю насколько у вас это сложно но почему бы не поднять попробовать всю инфраструктуру там с нуля и до там api запросов под каждое условно тест в каком-то более облегченный может быть время честно сказать страшно представить как нашу инфраструктуру сделать облегченные то есть у нас очень большим много сервисов разнородных и честно сказать у нас до сих пор мы работаем на одной площадке дизельные все вместе все разработчики работают на одной площадке что потому что развернуть каждому локальную копию инфраструктуры невозможно ну точнее был один прецедент когда один человек единственное известное в компании которая это сделала подарок какой-то огромное количество времени и вот мы сейчас взвешивали этот несколько раз подход типа засунуть в docker и раздать контейнеры но это все нужно актуализировать у нас постоянно сервисы обновляются вас постоянно что-то происходит и вот на вот этот я кашей wink да программисты буду тратить очень много времени которые в принципе можно сделать один раз для всех сделать это хорошо и они будут этим работать для тестов соответственно тоже история если мы будем каждый раз для каждого теста поднимать целую инфраструктуру во-первых сколько времени займет этот пресет от на которой мы потратим время во вторых нам нужно постоянно быть за этим следить чтобы вся эта система работала и потратить еще больше времени на поддержку инфраструктуры тут всегда the rate of время поддержки и удобство и качество тестов вот пожалуйста да здравствуйте спасибо за доклад у меня два небольших вопроса первый это при тестировании legacy кода вы макаете корт функции типа да и daytime или как у нас есть обертка на 3 times то есть мы их не используем напрямую мы их использовать через свой класс там их несколько на самом деле и их мы макаем до случае необходимо старший второй вопрос разработчик при не тем как вы хотите свою фич у него есть возможность быстренько прогнать тесты пользуюсь средой пользуясь тем самым да помимо клауд дала запуска у нас есть возможность запустить это из своего хомяка turbo говоря за чик аудит свою ветку нажать консоли набрать эту команду и тут же прям получить результаты прогона любого из тестов средства проживать их можно прямо из попы шторма если его чуть-чуть настроить можно прям нажать на пуховую шторме на ран тесты я не запустятся все спасибо будьте добры спасибо спасибо за так вот у меня вот такой вопрос я не поняла вас есть превью или нет то есть какая-то среда to like прот конечно нас их несколько у нас есть во первых devil инфраструктура на которую мы все это раскатываем из все это проверяем тестируем devil атакуй уменьшенная версия про да то есть все те же сервисы но их они гораздо компактнее запакованы да по машинам и есть еще помимо этого у нас так называемый шо ты то есть можно свою версию кодов выкатить а специальный сервер там это будет работать с production базами с продакшен данными и можно подвесить как твой код будет работать в продакшен окружение и собственно после этого есть еще на этапе когда мы собираем build у нас есть пре-продакшн у нас называется station по сути мы выкатываем код на station кластер он также работает с продакшен версиями сервисов и данных тогда вопрос сразу почему настей chingy не развернут у и такое и они пихать его в продакшн и получается у проблемы создает так код который я я понял про что вы ну тут как бы все время есть принимай гостей джим все закладывают немножко разные значения у для некоторых стейджинг это вообще короче выделенный кластер вот где все выделено вот у нас стейджинг и собственно я его назвал при продакшеном чтобы было проще объяснять мы выкатываем код на группу серверов новый код но мы не обновляем при этом сервисы и сервисы мы используем на этом кластере реальные реальные базы реальные данные поэтому у нас пользователь живут в одном месте тестовые с реальными хорошо еще последний вопрос вот почему вы забрали у автомате зато raw ответственной за api тесты ну то есть они же наверх щетки лучшего сделаем его не подниму их их не забрали ни в коем случае и собственно мы наоборот часто уповаем на эти you at st ну а пеотия капиталисты api тесты мы пишем потому что у нас нет клиентов но а кто должны вписать автомате затар и а потом это дополнительное звено то есть получается что мы должны написать код убедиться что он работает карта без клиента добыть проверить его и отдать его команде автомате зато raw которые покроют все это автоматическими тестами такой подход а программисты чем будет заниматься вот чтобы проверить вопрос этот из прошла вы бы как это реализовали да это превращается из обещаю нижнюю до быть давай поговорим дворах интересно подход может быть я что-то недопонял спасибо за доклад как я понял вы используете общей пол тестовых пользователей верно при распылении интеграционных тестов есть ли шанс наткнуться на использовании одного и того же пользователя разными тестами шанса такого нет при отдаче пользователь из пула он атомарная лучится и никакой последующей тест его не сможет взять пока мы его не почистим и не вернем статус free спасибо спасибо вас такой голос вот сверху пожалуйста спасибо за доклад смотрите есть в рамках интеграционного теста результат появляется синхронно вас есть такой и к сожалению никакого средства сейчас понять что какой-то асинхронный фоновый процесс завершился в тесте нет поэтому мы пользуемся мог ами чтобы этих процессов избежать а сами эти процессы тестирую юнитами спасибо спасибо вот быстро вы благодарю за так вот у меня такой вопрос вы говорили у вас есть и пи-пи-пи методы вы покрываете их тестами и вообще до какого момента стоит у порваться в покрытии хороший вопрос 1 часть простая до покрываем но не всегда вторая часть как всегда есть трейдов мы стараемся покрывать в зал но это все на совесть разработчика я вполне могу прийти и выкатить задачу вообще без одного теста мне на review конечно спросят где тесты друг но я скажу что сейчас вот я хочу вот так вот потому что есть обоснованные причины выкатить задачу срочных без тестов и скорее всего надо или до продакшна но по-прежнему я несу за нее ответственность если как бы мое решение написать меньше тестов написать не писать тесты она пор ищут какие-то последствия за отвечать за него буду я и я тут заинтересован сделать так чтобы тесты покрыты стремится функция у нас есть метрика гол на который мы ориентируемся это 50 процентов то есть у нас есть цель по командам покрытие не меньше 50 процентов все остальное это дается разработчику на усмотрению так ребят ещё два вопроса остальное на стенде буду ладно бы ставры спасибо большое за доклад такой вопрос как кроме мутационного тестирования катка выросший кадре view вы гарантируете качества своего тестового фреймворка особенно тех библиотек которые выкладывайте вот motors сложно сказать кресел больше никак ну то есть мы проверяем тестируем руками мы покрываем все это тестами проверяем сами качество самих тестов review наш код смотрим на нас есть какие тузы еще типа статических анализаторов но на этом все все что мы можем а как чисткой баги тестова фреймворка что делает как часто возникают баги тестова фреймворка находится как я знаю точно что вы несколько раз подсели покупаю нет не скажу конкретно про какие какими были мы там были проблемы с чем именно но точно приведет нас патченный не от хорошей жизни спасибо спасибо за доклад ольга громко интересуют тонкости вашей об аккаунте программы когда меня просят стать хотелось бы знать тонкости ваших баунти программы вот та ошибка которого описали она звучит как не критично и получил ли в этом случае участник программы баунти до reward получил но не самый топовый то есть у нас есть категории там ри вардов там в зависимости от критичности проблемы если это как-то affected production пользователей то там сразу получается самый большой reward ноут в этом случае тестовых пользуясь защитить никак нельзя реальных пользователей затеки нельзя было но reward человек получил друзья но это было великолепно поаплодируйте владимиру спасибо"
}