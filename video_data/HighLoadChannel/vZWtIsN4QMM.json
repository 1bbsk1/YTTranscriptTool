{
  "video_id": "vZWtIsN4QMM",
  "channel": "HighLoadChannel",
  "title": "noBackend, или Как выжить в эпоху толстеющих клиентов / Николай Самохвалов",
  "views": 1808,
  "duration": 3054,
  "published": "2017-04-22T14:47:51-07:00",
  "text": "Давайте познакомимся. Поднимите руку, кто код не пишет и вообще не совсем закончик. Есть такие супер. А один человек, два человека, три вон там. А, хорошо. А понимите руку, кто больше фронтенд, чем кэнд разработчик? Ага. Ага. Ну, другие, значит, я предполагаю больше, чем фронend, либо там devops, сидминство и всё такое. А, о'кей. Значит, примерно 50 на50, насколько я вижу по рукам, это очень хорошо. А потому что я примерно так и думал, и как раз мой доклад, он больше, э, такой общий а и рассчитан и и на тех, и на других людей. Ну, в меньшей степени, конечно, на тех, кто не пишет код, потому что мы будем говорить про архитектуры и про текущее положение вещей в мире. Я сейчас больше последние 3 года больше провожу времени в долине, в Силиконовой, и вижу какие там тренды и надеюсь немножко поделюсь с вами. Хотя вы, я думаю, отсюда тоже прекрасно всё видите, но там, когда когда буквально сидишь в кафешке, ощущаешь все эти разговоры вокруг, понимаешь больше, то есть не в чатике, да, а вот они реальные люди, они именно об этих технологиях сейчас разговаривают. Мой доклад называется No Backend или как выжить в эпоху толстеющих клиентов. И сначала мы поговорим о том, что же такое толстеющие клиенты и что за эпоха такая, как мы вообще до этого дошли. А вот любопытный факт, когда готовился к докладу, сам не ожидал. Например, знали ли вы, что Ruby появился тогда же, когда и PHP, и Java, и JavaScript в одно в оди год, то есть эти четыре утёнка, они появились в один год. А и на самом деле понятно, кто из них гадкий, да? Это, естественно, JavaScript. Почему? потому что он был на коленке написан за 10 дней сотрудником, который пришёл э в компанию. Это была подготовка выпуска нового браузера NScape. И просто написал скриптовый язык, а даже назвали его вначале иначе, а потом уже, когда прикручивали Java, заодно решили и, а, переименовать. И вот этот конфionн большой внесли, что Java, JavaScript потом 21 год. Вот уже некоторые новички путают. Далее нас, а ждали многие годы, когда JavaScript выполнял второстепенную роль. А он нужен был для того, чтобы что-нибудь там заанимировать, какую-нибудь реакцию посчитать на в браузере. Но постепенно где-то там с 20034, когда началась ээ шумиха вокруг Web2.0 появился Gmail и так далее. Google Maps, а JavaScript, конечно же, обрёл большую большее значение. И вот это уже было клиенты стали толстеть. Ну а сейчас мы всё с вами знаем. У нас есть очень single page applications, есть много фреймворков, огромное количество на Javaрипте есть React система, это и приложение, которое для браузера, и уже React Native, который и для iOS, и для Android, и для, а, Windows недавно вышел. И вот что касается долины, то Реакт - это огромное направление, которое, я думаю, ещё много-много лет со всеми его проблемами и недостатками, о которых многие из вас знают. Но это очень большое направление, которое вовлекло огромное количество людей. Буквально вот атапгруппа по React Native, а там была представлена ID платформа Deco которая недавно, на прошлой неделе, по-моему, она вышла в Open source, и теперь её можно скачать, попробовать. А 400 человек пришло на метап. И ещё возмущались, что в тот же день был метап по самому реакту, на который пришло 300 человек буквально там на соседней улице в Сан-Франциско. То есть этот настолько пострест, допустим, тот же собирает 50 человек, не как у нас здесь. А вот и соответственно с точки зрения именно джаваскрипта. О чём эта история? Это история о дистрибьюции, о том, что бывает продукты вначале не очень хорошие, но если их установить во все браузетеры и донести до каждой машины клиентской, в каждом ноутбуке, то, естественно, со временем нам придётся иметь дело именно с этим, потому что потому что другого просто, как правило, нет или есть очень мало количество людей. Это история о том, как ээ изначальная дистрибюция позволила этому языку развиться, превратиться, занять монопольное положение по сути. И на самом деле даже лидерское положение среди языков. Вот это квартальный кварталь первый квартал 2016 года, то есть этого года свежее исследование от redon.com. А по оси Y здесь у нас а количество тегов на вопросах в вопросах тег Overflow и по CX - это количество проектов в Гитхабе. А мы видим, что вот здесь увеличил. Мы видим, что JavaScript побеждает в обеих номинациях, но другие три утёнка тоже совсем рядом. Java, она вообще там приклеилась, а PHP Ruby на Гитхабе тоже очень лидируют. То есть это вот четыре языка, которые родились в оди год 21 год назад. Они лидеры на Гитхабе, но JavaScript с отрывом опережает. Это, ну, то есть есть разные исследования, они практически все подтверждают, что JavaScript опережает. Я немножко беспокоюсь за SQL. Я видел исследование, что на гитхабе, если скл немножко по-другому померить, то он даже джаварип опередил, потому что он во многих проектах есть, несмотря на шумиху вокруг no SQU и монги всякие и так далее. Но, по крайней мере, понятно, что JavaScript - это такой язык, который игнорировать невозможно. Аа и второй аспект, э, толстеющих клиентов. Понятно, да, что уже вот 2 года назад у нас уже произошло опережение в интернете. в рунете пока с натяжкой, там, смотря как мерить, но всё же, конечно, мобильное приложение - это понятно, тренд, грубо говоря, их больше, чем используется, чем чем других устройств, чем десктопов. А так ну да, вот год назад Google сообщило, что ищут на мобильных, а, больше, чем на а компьютерах. А с Яндексом пока, по, насколько я знаю, не совсем так. И вот эти два аспекта приводят нас к идее, что когда мы стартуем новый проект, то нам вообще не хочется думать про бкэнд. Мы с вами видим, что конференция frontend занимает два потока на этом фестивале, а акend один поток и плюс ещё есть коф. И, соответственно, я по сути, мой доклад по сути больше про бкнд, несмотря на название, но я вот влез в большой зал, пользуюсь административным положением. А, ну понятно, что фронт, конечно, да, он он за 10 лет вот этого фестиваля, этой конференции он, конечно, изменил э вес интересов аудитории. И это понятно, это диктует бизнес. А идея такая, давайте мы вообще не будем думать про бкэнд. Понятно, что на если у нас много пользователей, они как-то взаимодействуют, там какая-то social медиа или какая-то какое-то приложение, которое типа Инстаграма, Твиттера, неважно, а то нам нужно где-то всё это хранить, естественно, на сервере и как-то с этим работать. И просто должно быть, должно быть эффективно, надёжно, безопасно. А, и тут важный аспект, что если у вас не только приложение, а ес у вас, если есть ещё, то есть это мы про новые проекты проговорили. А если говорить про старые проекты, у которых уже есть веб-сайт, они выпускают приложения для iOS, для Android, выпускают, может быть, для смарт и какие-то модные для, а, часов, для ещё что-то, да. Всё это требует бэкэнда, естественно. И если у вас старый монолит сайт, то, конечно же, многие компании приходят к тому, что нужно нам иметь универсальный API, в котором будет и сайт взаимодействовать, может быть ещё браузерное расширение, может быть приложение. В общем, весь зоопарк он он должен как-то унифицированно взаимодействовать. То есть нам нужно внутренний API. Это вот такой второй аспект. И либо вы используете API, который, естественно, сейчас наиболее популярен, я думаю. А, либо вот новомодный граф от Facebook, как раз из из экосистемы React. В любом случае вам нужно что-то такое иметь. Как совсем с этим выжить? Теперь я рассказываю, а, что-то ориентируюсь и на бэкэндеров, и на фронтэндеров, а, и буду как бы говорить, где что, да? А в конце в самом я дам маленькую памятку. Ну как маленькую, не совсем маленькую, но на один слайд, которая нужна для чего? Если вы фронтендер, берёте эту памятку и просто проверяете вот то решение для бэкэнда, которое я выбрал, оно по этим пунктам насколько хорошо. Может быть, мне стоит пересмотреть другое решение. Если вы бэкэндер, обязательно тоже проверяете и смотрите: \"Вот я строю бэкэнд\". Насколько он по этим пунктам хорош? То есть это будет практическая такая. А первый вариант, давайте вообще не будем, у нас не будет серверов, будем все облака жить, совсем в облаках, то есть будем просто какой-то API там где-то будет, там будем дёргать. К сожалению, такой проект подход глобально не выжил. А это вот два таких ярких представителя stmmob.com и Pars. Парс был закрыт в январе этого года. А, и в том, и другом случае, а компания, которая поглотила проект, она просто инженеров перевела в другой, в более насущные проекты. И по сути, ну, можно сказать, что тут проиграна конкуренция серьёзным облакам типа амазоновских и гугловских. Но тут есть ещё и другие аспекты типа как, а просто API непонятным. Хотелось бы ещё там и хранилище иметь. Ну, то есть, ну, как бы такое узкое решение, оно само не выживает. Также жаловались на ценообразование. Дорого получалось там за какое-то количество вызовов. И на производительность тоже жаловались в плане ПАРС. Но, насколько я помню, там в районе полумиллиона приложений было. То есть он, в принципе, вырос. И я помню конференции Facebook пару лет назад очень с большим с большой шумихой всё это. Ну вот не выжили. Есть аналоги pars.com. Он даже был выпущен в Open Source. Кто-то его там устанавливал, причём даже Amazon его установил. То есть он в Амазоне есть, можно использовать. Ну, в целом мысль такая, что если уж в облака, то то давайте более более как бы надёжные и понятные, что завтра никуда не денутся решения, это Amazon и Google. У них есть некоторые элементы у такогонокэнд подхода. Это вот эти лямда, которые на этой конференции много говорят, в принципе, и ээ сервис для э аутентификации, авторизации когнита. Если вам сильно хочется совсем на бэкэнд, вон там внизу ссылочка в слайдах можете прямо нажать потом. И там много решений как раз всякие специализированные, как раз, чтобы своих бэкконсерлеров не иметь, а писать сразу клиентский код. А, ну, в общем-то, теперь я, в общем, говорю: \"А давайте всё-таки по-серьёзному сами будем делать\". И тут постгз постгрес э растёт. И, э, несмотря на то, что я, конечно, а всячески призываю его использовать, но часть часть слайдов будет чисто про подсчок в углу слоник, а часть будет общая. Я всё-таки доклад стараюсь где-то 50 на50 он будет общий. А, и есть такая штучка постгрест, а, довольно довольно новая, но уже работает в нескольких проектах Production и очень активно развивается. А постгрест - это по сути вот постгрест плюс постгрест - это путь настоящего джедая. Почему? Потому что так вы получаете довольно быстро все всю силу, да, сила позгса. Сейчас мы это раскроем. А так Позго написано Хаскель. Лицензия очень либеральная. Активно развивается вот чатик в Gitter. Там можно получить поддержку. Ясно, что как у всякого нового продукта есть проблемы различные. Некоторые сегодня упомянул, но в целом очень хорошее решение и оно реализует стандартные, ну, по сути, HTP, заголовки и так далее, и так далее. Вот я тут же с места в карьер показал, как можно сделать, ну, там запускаем. У нас есть V1 схема. Это схема, в которой живёт, грубо говоря, версия один нашего API. И мы можем быстренько либо там табличку создать, либо если у нас уже какие-то таблички есть данные, то можем создать просто вьюшку, то есть виртуальную табличку, если для тех, кто не знает, и тут же получим метод с/person, у которого можно там есть параметры, как фильтровать, как делать постраничную навигацию, как сортировки. Можно даже джойнить, то есть объединять с другими таблицами. А и вот четыре метода поддерживаются. геты, они автоматически транслируются в select SQLй, постр паch update, delete в Delete. А всё довольно просто и работает, но сразу возникают вопросы, которые будут как раз включены в памятку. Также вы можете хранимку написать, и, скорее всего, если вы будете использовать постгрество, вы будете хранимки писать. А я знаю, что многие люди говорят, что хранимки - это зло. Я так не считаю. У меня опыт довольно большой, и я использовал разные другие СБД до Постгреса. И хронимки не зло. Не зло. То есть есть какие-то сложности с отладкой, но отладка вообще такая сложная штука. Аа есть дебагеры в принципе для PLPGSQL. Основной язык для хранимок - это PLPGSQL. Он там второй внизу написан. Это аналог PLSQL ораклового. Ну, можете использовать также и другие языки, в том числе там Python, можете вот PV8 - это JavaScript, но такой, который не может общаться с внешним миром. А, то есть у вас получается очень много разных а возможностей, в том числе PL - это язык для аналитики, для статистики, для анализа статистики. А хранимки только пост вызываются и в теле придаём параметры именованные. И пошли теперь вот по этой памятке, которая будет в конце. А-а, первый урок, который мне в нескольких проектах - аэ пришлось выучить, когда вы начинаете строить API, да, всё так очень быстро. У нас была какая-то база данных. Кстати, Погрес - это не обязательно реляционная база данных, там вы можете там исоны хранить. Некоторые так и делают даже в платёжных системах. Аа, то есть как бы no SQL. А, и дальше вы открываете всё это, но, чёрт, возникает много вопросов. по, допустим, по безопасности следующий урок будет. И чтобы всё это, а, как бы, в общем, надо, надо обложиться тестами практически сразу обязательно. И если вы ещё не используете, хотя я думаю большинство используют continuous integration какие-то инструменты, то тут обязательно нужно это сделать и обложить тестами, особенно плохими тестами, чтобы не дай бог ничего не открыть, то, что нельзя открывать наружу, потому что одно дело, вы сделали суперюзеров в базе данных, и ваши пишпишники рубисты это используют. Другое дело, всё это торчит наружу, и можно что-нибудь плохое сделать какой-нибудь хакер, если проект вырастет, рано или поздно придёт. И у меня такие случаи были много-много раз. А недавно, вот, буквально пару дней назад, проводили опрос в Back Secret, э, в коллективном блоге в Твиттере, и я вообще ожидал, что где-то половина будут без continuous inraation, но на самом деле круто. Круто, что всего лишь там меньше четверти, вообще отлично. А если вы вот в первом пункте, в общем, так не надо. Это лузерский подход. В общем, хватит об этом. Как можно просмотреть, поработать с API? Ну вот не все знают, что можно прямо в Фафоксе уже запрос, который был сделан, взять и его просто там поменять. Там есть ADIT resent, есть курlл, понятно. Есть питоновская утилита HTP HT http она консольная, а там просто лучше output, лучше виден Jon ответ. Но главные наши инструменты, они подсвечены жёлтым. Это расшение для хрома Postman. Понимите, кто уже кто уже знает, что это такое Postman. Ну, ну да, почти половина, но меньше половина. А если вы вообще с API работаете, это очень хороший инструмент. Он решает проблемы, ряд проблем. То есть вы можете себе накидать кучу запросов, сохранить их, а сделать их абстрагированными от окружения. То есть у вас есть десервер, тестсервер, prodдакш сервер, там разные хосты, там разные логины, пароли. Всё это можно завести как окружение, выгрузить файлики и дальше с помощью Ньюмана, а который как бы добавка к постману, всё это из консольки вызывать и, соответственно, засунуть вас ваш Cerвер. А урок второй, безопасность. Здесь немножко подробнее, хоть многие и не любят, вообще мало кто любит думать про безопасность, но нужно. А здесь, кстати, не хватает значка позгриса в углу, потому что это явно э позгрисовый слайд. Ну не совсем. А значит так. Если мы говорим, что у нас есть табличка и мы создаём просто так. взяли и создали вьюшку в постгресте, которая selectт звёздочка эта табличка. Мы создали себе проблему безопасности, потому что если у юзера, под которым ходит наш API есть права, то кто кто угодно туда может всё что угодно заинсёртить, включая чужие usеer ID там и так далее. То есть это вообще бардак полнейший. Аа тут нужно с правами реляционной базы, то есть постгса разбираться и давать только права. Допустим, если мы не хотим, чтобы та вставка была, ну, мы вставку не даём. А если вы используете утилиты, а всё-таки, если вы базу данных поднимаете, вам нужно это использовать, утилиты для миграции изменений DDL, то вот, допустим, в Skровать а изменения sketch.org. А, то есть можно верифицировать regessionтест писать. То есть проверяем, что со схемой всё в порядке. И в частности можно привилегии, вот тут такой трюк, если привилегия будет, то случится деление на ноль, он выпадет, скажет ошибка. Ну, то есть такой на коленке написанный трюк, но он он помогает проверить, что не дай бог у юзера не появилась привилегии на эту таблицу. А пишутся тесты и всё это запихивается опять в C и всё это проверяется при каждом комите, как обычно. А с точки зрения на уровне API мы должны проверять, что да, у нас дверь закрыта, то есть API отвечает соответствующим кодом, а либо не авторизован, либо там в случае постгреста чаще всего у вас будет четырёхсотый код, то есть просто плохой плохой запрос, а там уже дальше подробности. И вот в постмене вы пишете тест, он выгружается и дальше нюманом всё автоматически крутится и проверяется. Это нужно делать обязательно. Нужно заранее подумать, где у нас какие двери есть, и они закрыты должны быть. А так у меня не работает переключалка. Алло, вы слышите меня там кто-нибудь? Переключалка не работает. Можете там сами слайды переключать тогда. Сейчас, секунду, секунду. А, да. Пока вопросов нет. Никаких есть, да? О'кей. Спасибо. Как обстоит дела с валидацией того, что приходит с фронтенда в посткрест? Как валидировать данные, прише пришедшие с фронтенда в пострест? Да, хороший вопрос. Я упустил тот факт, что часть этого постгрест берёт на себя. А мы когда засовываем данные, да, то есть это вот либо это фильтр какой-нибудь, допустим, get идёт, да, то а эти данные они в итоге оборачиваются в а в запрос и и постг это берёт на себя и там идёт запрос, который он там превращается в jon внутри там есть e, то есть with, и в итоге, в общем, по сути, вы не должны об этом беспокоиться. Одно из преимуществ использования постгрест - это как раз то, что многие вещи, включая там аутентификацию, авторизацию, они уже решили. И тут вы можете просто проверить, что никаких там SQL injections, SQL инъекций просто невозможно сделать. Вот. И в то же самое, если вы, а, вызываете функцию, вы pay делаете Jon, там то же самое. Ну, он практически он уже форматированный должен быть. То есть, если вы там пытаетесь, не знаю, там строку вместо числа, то у вас просто это не получится. Но дальше постгрест тоже уже всё это приводит. Он знает метаданные, знает какие какие колонки какого типа. Соответственно, всё это приводится и в общем-то есть валидация она автоматическая. А какая ещё вас интересует? По логике сейчас, погодите. валидация логики данных может быть произведена. Ну, я делаю какой-то незаконное для конкретного юзера действия. Вот я как раз об этом здесь рассказываю. Сейчас мне слайды переключат. Именно об этом речь и идёт. Незаконные действия. А так, сначала я немножко расскажу про аутесификацию, да? То есть Postgess основной способ авторизации - это JavaScript Web Tokens. Это сейчас всё более популярный инструмент, да. Это то есть мы мы у нас у нас отсутствуют сессии, у нас выпускается под с цифровой подписью массивчик - PS64 просто заинкодированный э данных о том, что это за пользователь. А в приложении или в джаваскрипте мы это сохраняем. И дальше при каждом вызове передаём заголовок ization, который как постгрест автоматически проверяет, что да, это я подписывал в прошлый раз. Кстати, может подписывать и другой кто-нибудь, ээ, то есть свой, а, можно JWT сервер сделать. И да, это такой-то пользователь, 100% от него пришёл запрос. А дальше, а, вот начнём. Вот три уровня проблем могут быть. Первый уровень проблем насчёт вот этой валидации - это если у вас вообще не какой-то аноним пришёл, который вы даже не знаете, кто у него этот заголовок а отсутствует. Если он будет присутствовать, а постго его не опознает, он скажет просто невалидный токен. Ну, в общем, понятно, да? А если заголовка нет, то это считается анонимым, и тогда его действия в подгресе, в базе будут выполняться по другим пользователям. И ваша задача, чтобы у этого пользователя не было вообще никаких прав, кроме там нескольких. То есть вы делаете хранимки регистрации, логины, там, сброса пароля и этого хватит. А дальше вы можете написать тесты, не дай бог там, чтобы у этого пользователя не было каких-то прав, как я рассказывал на предыдущих слайдах. И таким образом проблема анонимов, она уходит. А так у меня забрали. Да, это первый пункт. Спасибо. Второй пункт - это права на столбцы. А что это такое? Аа если вы делаете селект звёздочка из таблички пользователь, то вы как минимум светите пароль. Хорошо, если они хыши у вас. Я надеюсь, что они у вас в хэширном виде, но и вы светите имейлы, базу имейлов. Такого делать нельзя. То есть если вы даёте другим пользователям смотреть на список пользователей, вам как минимум надо позаботиться о том, чтобы отсечь ээ те столбцы, которые нельзя светить. Это делается очевидным образом. При со при создании этой вьюшки вы не селект звёздочка делаете, да, а перечисляете, какие поля можно читать. А и дальше вы можете в позгасе, в Поссе есть очень давно такая возможность, вы можете, а, дать права, допустим, если вам приспичило табличку пользователя вывесить анониму, пожалуйста, вывешивайте её анониму, и он сможет её читать. Но, допустим, вы можете на какие-то столбцы убрать право читать, как читать. То есть вы можете селект только на некоторые столбцы сделать. Также можно поступать с инсертами, апдейтами. Это очень гибко и можно дать, то есть пользователь не должен иметь права поменять свой айдишник. Очевидно, да? И хотя мы его выводим, но мы не даём права его инсртить и апдейтить. И то есть, ну, права на столбцы помогают нам защитить данные, которые человек не должен иметь право менять. Например, аккаунт премиум проплаченный. Оно вычислилось раньше и и оно выводится ему, но нельзя давать менять. Ну, понятно, да? А и третья вещь, а два си, да, это, э, вот более такая сложная для реализации, но очень важная вещь. нельзя давать, а, менять чужие строчки. То есть, если мы просто дали возможность, а, апдейтить вюшку, то, по сути, любой пользователь по умолчанию он сможет проапдейтить и чужие стчки тоже через этот API. И это беда, конечно. Это ещё одна дверь, которую надо засунуть в автоматические тесты и проверять, что она закрыта. А как её закрыть? Если у вас погрыз самый современный, то используем raw level security. на эту тему есть отдельные статьи, это тема отдельного доклада. А если у вас более старые, то пишем хранимки. Постгрест, э, делает переменную сессии clims там и название, например, там email или ID. И мы знаем, кто именно выполняет эту хранинку и можем проверить. Конечно же, предпочтительный Rollvel Security современный способ. И не забываем тестировать. Ответил на вопрос. Угу. А дальше третий урок, более интересная тема. Я сам терпеть не могу безопасность разбираться, это очень муторно. А производительность, а здесь такой пример типичный. Допустим, у вас есть база пользователей и у вас есть коллекции. А в коллекциях посты коллекция - это, например, ну, возьмём сайт sports.ru, а у него есть там блоги, можно подписываться на них, там появляются какие-то посты. Допустим, у вас там миллион пользователей или там 10 млн пользователей, миллион этих блогов или там микроблогов, неважно. А, и в них тоже там 100 млн уже записей. А, и плюс ещё связи между пользователями и этими коллекциями. Ну вот я четыре таблички здесь отметил, да? Person, post, collection и person to collection. Типичная модель любой social media, social network, это и Twitter, и Instagram, всё под это подпадает. А и стандартная задача, которая стандартная не для, конечно, гигантов, которые сейчас начинают играться и даже уже Instagram начал, а или кто там Twitter, да, они начинают не в хронологическом порядке вам подсовывать новости, а как они как будто они догадались, что вот это вам интереснее. А, но тем не менее, если вы строите в холомагическом порядке, стандартная задача, выдай мне всё самое свежее, самое свежае из моих подписок. А если решать в лоб, вот два, есть два варианта. решение в лоб. А первый вариант он более такой, когда мы боимся джойнить, да? То есть мы сначала выбираем посты, потом зная какие из каких они уже коллекций, ашники коллекции, выбираем коллекции. Дальше, зная, кто там автор, выбираем авторы. Ещё и закшировать, наверное, захочется. А совсем такой простой подход. Второй, он более позл, это типа написать из четырёх таблиц и и дальше всё это переварить. И вот я здесь для интереса Road to JSON привёл. То есть можно nested делать, и погст вернёт вам JSON, в котором будет вложенный JSON с информации о об авторах, о коллекциях. А и а оба запроса плохие, но они плохи в плане производительности, о чём на следующем слайде. Но первый запрос намного хуже. Первый вариант намного хуже, потому что там три запроса, три API вызова. Если, когда вы писали на Ruby PHP питоне, то вы об этом не особо могли беспокоиться. Ну, сделаем три сQ место одного, это неважно. Зато они типа быстрые, короткие, как любят в некоторых СБD. А, но когда вы делаете это через API, представьте, что человек это с другой стороны, у него roundутриптайм может 100-200 мсекунд, и у вас уже вот появляется лишних 600 мсекунд, которые могли быть 200, а теперь 600. И это очень видно. Она неружённым глазом становится. То есть первый вариант вообще нужно отмести сразу. Мы должны стараться всё делать одним запросом, если это возможно, конечно. А, но у этого запроса, то есть, да, первый первый вот здесь подурок - это то, что мы должны в первую очередь думать про сетевую сложность. А второй урок, да, здесь под урок это то, что Да, кстати, знает ли кто-нибудь вот здесь вместо offset, я думаю, все знают, да, что offset не надо использовать. И здесь поджинация она, ну, постраничная навигация, она сделана с помощью и использования предыдущего ID. То есть это тут как бы слайд заложено много всего. И я думаю, что если вы как бы, ну, работаете с реляционными базами, запомните, да, что offset ни в коем случае не надо использовать. А далее, если у вас вот такие объёмы данных, то вы уже стопудово получите проблемы с и со вторым методом тоже, потому что он будет работать секунды, а то и десятки секунд. И вы вырастете и подумаете: \"А что же теперь делать? Пользователь заходит на главную страницу и ждёт несколько секунд. Это уже кошмар. С этим столкнулось много проектов на моей памяти, в том числе несколько моих. И здесь очень выручил известный эксперт по постгресу, проживающий в Австралии, а, Максим Багук. И вот пару лет назад он об этом рассказывал на PGD. Очень рекомендую эту презентацию. Она вообще замечательна во многих смыслах, и я до сих пор периодически к ней обращаюсь. Прямо правда, если с подсом работаете, обязательно изучите. А там вы сможете освоить джидайские техники, а такие как работа с рекурсивными запросами, с массивами, сворачивать, разворачивать строки и так далее. И в том числе вот этот з индексскан - это подход, когда мы избегаем лишних лишнего чтения, очень экономно считываем данные. И в итоге вот эта задача, когда нам нужно 25 самых свежих постов из моих 500 подписок, и там у нас уже каждый день появляется тысячи, тысячи, десятки тысяч постов, как нам их быстро-быстро найти. И по сути здесь SQL становится не декларативным языком, а уже практически алгоритмическим. Здесь приведён этот пример того запроса, который аналог тем двум. А его можно, это реальный запрос для одного из проектов. А его можно увеличить потом на слайдах, там что-то увидеть, но в презентации как раз Максима всё это лучше объясняется. Это тоже на целый час. В общем, этот запрос работает единица миллисекунд на тех же самых данных. Он рекурсивно раскручивает вот эту задачку, получая по одному посту, грубо говоря, из каждой коллекции. формирует ээ набор и дальше идёт, замещая, замещая, пока не хватит, и пока он не поймёт, что всё, мы уже набрали 25 постов, можно выплёвывать. Очень классная штука, советую изучить. Аа то есть, э, вот это вот джедайские техники, как раз я об этом и говорил, что используя постгресты, постгрест, вы получаете, то есть я не удивляюсь, что на парс ээ жаловались на производительность. не удивляюсь, потому что когда там внутри монга и больше думают про то, как бы это всё сделать для пользователя, это производительность начинает страдать. И э погреси у вас тоже может производительность плохая быть, если вы в лоб решаете задачу, но у вас огромное количество инструментов, чтобы это улучшить. То есть вы можете использовать силу. А следующий пункт насчёт масштабируемости. Забываем на две на три части. Первая часть. Понятно, что у нас нет сессий, ээ, restful подход. И этот посткрест можно поставить на большое количество машинок, и он будет спокойно работать. Балансировку настроить нексом или H proxy, и вы сможете таким образом смасштабировать этот уровень. Тут всё достаточно очевидно. А второй уровень - это если нам нужно, допустим, читающую нагрузку смасштабировать, да, вы тоже можете настроить специальные посткрест экземпляры. которые будут обращаться только к словам. И дальше с помощью, опять-таки, так как у нас здесь прозрачно, в отличие от монолитных подходов, когда у вас запрашивается страничка, и вы чёрт его знает, что-то она там меняет в базе, не меняет, да? То есть это стандартно проблема, если у вас есть орэмка. Кстати, обратите внимание, вообще вся эта тема, а она очень похожа на урмки, на самом деле. То есть мы, то есть это не орка в данном случае не object relational mapping, а какой-то такой jonelational mapping. Аа и ещё замечание такое, это, э, стек провалился. Вчера был доклад про C2H5OH, раз уж мы тут про производительность говорим, а это такое расширение для, которое из позгаса тоже быстро наружу может выплёвывать джейсончики. И вы тоже то же самое можете всё делать. Рассказывал разработчик этого решения. И на самом деле ночью мы всё-таки протестировали это его решение в три раза по производительности там на виртуалках обошло постгрест. А, ну оно написано на C++ и очень короткое и не очень универсальное, но вы можете его использовать. Но Постгрест проиграл ему, хоть, ну, написано на Хаскель и и он более универсальный. А, то есть тоже сейчас много таких решений появляется. Это решение, которое я, о котором сегодня рассказывал, оно более такое универсальное и, э, популярность набирает. Так вот, обратно к балансировке. В данном случае, когда вы имеете get, это 100% select, то есть это только читающая транзакция. Поэтому Gксу не сложно настроить конфигурацию, чтобы он 50%, 70% трафика направил на другой хост или там распределил как-то. Всё в руках уже админа, который занимается в данном случае. То кому это всё не нужно, вам хотя бы нужно знать, что вы в будущем сможете это улучшить, можете стартануть с этим проектом и дальше вы сможете смасштабировать. А также, если пользователь, допустим, что-то поменял, а то мы, может, захотим его какое-то время на мастере держать, чтобы вдруг там благи репликации а убрать. Ну, в общем, это отдельная дискуссия. А вопрос, как масштабировать мастер с ходу? Пока никак не масштабировать. А в Постгсе сейчас, а, в погс комммьюнити активно эта тема самая-самая горячая и активно развивается, и можно просто пока подождать, и через какое-то время появится решение. Сейчас там пять команд в мире работают над мультимастер, над кластеризацией и так далее. А есть такая штука сайт USDB. Недавно обсуждали с разработчиками Postgr, что это пока невозможно, потому что как раз сети используется with запрос, а SUSDB не позволяет. Ну и ладно. Возможно, они, кстати, уберут и заработают, и тогда у вас получится бы сможете шардинг делать для своих данных. А так, ну, ещё такой философский аспект. А вся эта шумиха насчёт webscale, когда вы, допустим, вам нужно вскопать поле и что вы предпочтёте? Не, там 100 100 таджиков с лопатами или трактор? А сейчас Постгрис уже приближается к тому, чтобы на одном сервере иметь 1 млн транзакций в секунду. По сути, это такой трактор, который каждый год улучшают, каждый год новая версия, и он реально очень продвинутый. А если же вы ставите решение типа монги, то на одной машине они, во-первых, и хуже, как правило, работают, особенно на вставки и апдейты. И, во-вторых, у них просто нет возможности таких, как у Подгреса. То есть это это не трактор далеко, да? Вы можете добавлять вы можете сказать: \"Да, я могу ещё там 100 таджиков позвать, а, легко, я знаю, где их взять\". Но их нужно кормить, о них нужно беспокоиться, где-то спать нужно и так далее. То же самое, если северами на монге, вам нужно их обслуживать, они выходят из строя, капризничают, конфигурация и так далее. То то же самое. И ваша задача вскопать поле может решаться трактором намного эффективнее и по деньгам, и по времени. И на будущее это может оказаться лучше, чем если вы вот лопатами решаете. А, а представьте себе, если вам нужно научную работу сделать. 100 таджиков звать уже совсем не очень хорошо. То же самое, если вы хотите использовать какие-то продвинутые техники, аналитику какую-то подсе очень много всего есть уже. А другие СБДЛ может вам просто не подойти. Ну, это такое лирическое отступление. А далее осталось совсем немножко. Что не стоит делать внутри? Очевидно, если вы запрашиваете внешний сервер, а вам нужно там письмо отправить или эсэмэску отправить, API какой-то дёрнуть, этого прямо в Постгресе не стоит делать, потому что это непредсказуемое время работы. И бэкэнд Постгреса на мастере удерживать непонятное время не стоит. Стоит пользоваться а методами Listy в позге. Старая-старая штука, уже давно отлаженная. Вы можете просто, а, какой-нибудь вас ваш скрипт на Node js или на Ruby, на чём угодно сделать. Этот демон подпишется на события в постгасе. И дальше хранимка, допустим, сброс пароля, она просто отправит это событие, отправит сообщение в этом событии, и ваш демон подхватит и уже нормально сделает. То есть мы тут возвращаемся к нашим популярным языкам, в том числе и Джаве, и как-то всё-таки используем их здесь. А если вам хочется, чтобы вдруг там в это время нас никто не слушал, а мы события генерили, чёрт побыде, они пропали, то тут нужно, конечно, применять всяких систем очередей. Есть ряд решений. Это такая уже тема довольно изъеженная. Здесь несколько ссылок приведены. Аа и наконец всё. Вот это ва обещанная памятка - это список всего, что мы здесь сегодня обсудили. А все эти пункты, если вы начинаете новый проект или переделываете старый на использование внутреннего IPI, проходитесь по этим пунктам, и будет вам счастье. Спасибо. Готов ответить на вопросы. Ну что, вопросов нет никаких? Ага. Здравствуйте. Спасибо за доклад. Скажите, пожалуйста, вот тот joийн запрос из нескольких таблиц, к нему обратиться через постгрест постгрест. Эээ, таким образом, можно для этого нужно будет ещё объявить функцию, правильно? А, да, на самом деле, да, и нет. То есть если вы хотите весь контроль в своих руках держать, да, вам нужно написать хранимку. И я пока так вот и делаю. Но есть возможность, как и как вот сейчас же модно, это graf quil. Graph quil - это что такое? Вы мне говорите, мне нужны вот данные, все посты ещё, чтобы там информация об авторах была. И сервер, который поддерживает граф Quil. Кстати, для позгса тоже есть такое расширение. А он понимает, что нужно вот заджонить таблицы и всё это выдать. Кстати, прямо вот предсказываю, что с граф по производительности будет столько боли и а плача на стек Overflow, что мама не горюй. Так вот, в постгрест тоже есть возможность заджонить две-три таблицы прямо в запросе. А там есть пример в документации. Вы делаете get с/меthд, который, допустим, посты, и там говорите: \"Мне, пожалуйста, ещё вот подсоедини туда авторов\". Но обязательно должен быть внешний ключ. То есть если внешнего ключа нет, это вообще не будет работать. Спасибо. Вот ещё вопросы? А, да, кстати, слайды, если надо, то, а, подпишитесь или там просто зайдите на мой Twitter, я там сейчас выложу ссылку на пфку. Там же, кстати, и куча новостей про по постгсу. Ещё вопросы? Ага. Вот у меня вопрос про постгрес тоже. Аа как это всё масштабируется? То есть у них есть шарды, репликация, как это увеличивается в стоимости? Как бы, ну, такие сервисы просто обычно на этом аа не акцентируют внимания, но как бы в это всё потом в конце упирается. Спасибо. А вот как раз об этом я только что рассказывал. Я, к сожалению, делал такой очень занудный тон и темп, что, наверное, вы уснули. А я отмотаю слайды и там будут покажу ещё раз. Это как раз про масштабируемость. Вот этот был слайд. Во-первых, я глубоко убеждён, что масштабировать мастер пока большинству из вас не нужно, если вы не работаете Facebook, Яндекс или Mail.ru или типа того. Вот не нужно. А ещё раз, Постгрес уже умеет до миллиона транзакций в секунду делать на одной машине. Чёрт побери. У кого из вас нужно это прямо сейчас? А, во-вторых, шардинг. Тема она уже в 2008 году на Хайлод. Вот на на эти конференции мы привозили ребята из Скайпа, которые решали проблему, как нам сделать в онлайне миллиард пользователей. Они на Постгасе были в то время до покупки Майкрософтом. Они сделали PXY, который используется сейчас в том числе в почте Яндекса. Яндекспочте. PXY вам позволяет делать шардинг в погресе. Это open source проект, но там ограничение всё должно быть на хранимках. как он совместим с постгрест. Надо подумать. Конечно же, вы потеряете здесь вот эту возможность работы get update patch, но хранимки, наверное, сможете использовать. То есть, я думаю, с позгреста вы сможете PX использовать. Сейчас у нас, э, появился сайт USUSDB, который до этого назывался PG. Для того, чтобы шардить, онсный проект, вы можете его скачать, зашарить свои данные, но он поддерживает не все SQL запросы, в частности, он не поддерживает вот эти вот сетии именованные запросы, поэтому постгрест с ним пока не стартанёт, потому что постгрест внутренне использует эти with, то есть он пишет with, оборачивает там разработчики думают, как отказаться от with. Они просто поторопились его использовать. Это, конечно, красиво, но по по ряду причин они, в общем, думают отказаться. Если они от него откажутся, то постгретство заработает и сайdb. А есть подход, когда вы делаете большое количество, ну, микросервисная архитектуры, у вас много разных небольших мастеров, у каждого свой, а, слайв или пара слейвов. Это может даже работать в Амазоне, как у компании Zando. На прошлом Highot Plus+ был отличный доклад от компании Золнда, в которой они как раз об этом рассказывали. Автоматический фловер, мастер падает, всё реплицируется, всё переключается на slave и так далее. То есть у них есть open source инструмент, называется патрони, который как раз э следит за этими вещами и готов работать даже в Амазоне. Э-э, это постгрес. Много-много мастеров, много слайвов. Тоже, по сути, большой кластер получается. Это далеко не все инструменты. Есть пог XC, есть разработки, которые новые сейчас, э, в том числе и Postg Pro. Есть доклады про кластер на опять-таки на HLO. То есть это тема, которая очень активно развивается. Есть BDR - это мультимаете аппликация от Second Pround. То есть, ну, сейчас сейчас вообще зоопарк решений не встроенный, встроенный встроенного кластера. Нет, в полсе, но я думаю, к этому придём в течение пары лет. У меня больше был вопрос про вот который рессервис, который А а ему а это его не заботит, то есть а там как бы не описано, что они используют для масштабирования или смотрите, а вот здесь вот уровень один, много экземпляров постгрест. Я тут даже не стал расписывать. Вы можете просто десяток машинок поставить, на нём поднять постгрест, они все будут ходить в мастер. Смасштабировались. А дальше, чёрт, у нас много селект нагрузок, там 70-80%. Как бы нам дальше облегчить жизнь постгреса мастера, да? Делаем репликацию, появляется слейв или два слой. А хот standby, то есть мы можем, э, они горячие, эти запросы практически без задержки. И ещё 10 машинок с постгрестом делаем, которые только на эти слоевы. Они такие редонли, у нас типа не rest то, а наш домен или rru, а будет restro.domen.com - это запрос. И это может быть даже вы можете даже приложению своему это открыть. Это может быть в другом дата-центре. И приложение, если поймёт, что мастер подох датацентр, оно говорит: \"Userзер, у меня сейчас редонли режим, но мы живём, мы с другим дата-центром работаем\". Это тоже всё возможно. У вас огромная здесь сила, которая уже использовала куча проектов. То есть, ээ, это всё есть. Самый главный вопрос, как мастер смасштабировать, если вы хотите два мастера синхронных иметь, но это вообще, то есть это Facebook, Яндекс, вот и всё. Вам это не нужно, скорее всего. Спасибо. Хотя тоже опять-таки решения есть BDR и так далее, и так далее. То есть всё это развивается, просто они дополнительные. А вы когда говорили про триггеры и проверку прав, вы там упомянули, что какая-то есть сессия, контекст, куда, да, вот эта фигня добавляет какие-то клеймы, да? Это чего такое? А откуда он их берёт? Клеймс - это вот это технологии там постгревеста. Это это когда мы а уже аутентифицировали пользователя, то есть он прошёл проверку, что он логин, пароль там подошли, а или сейчас как модно на эсэмэску пришёл временный пароль, как вот у слаки, да, и мы знаем, что это он. Мы ему выдаём JWT TKEN. В нём это массивчик, на самом деле, который в B64 инкодирован и подписан цифровой подписью. А мы ему выдаём и в нём, как правило, включают. На самом деле, вы сами решите, что включать ID, email, name, всё, что хотите. Вот эти вот штуки, они называются clims. Они записываются автоматически пост крестом в переменные сессионные. И вы можете в хранимках проверять, ээ, если они заданы, мы знаем, что это за человек. Тут возникает проблема, что если вы используете PG баoer, а, то ссинными переменнами могут быть проблемы. То есть, э, по крест лучше пока напрямую к самому пострису подключать, не через PG Bouncer. А вот этот токен J V, да? А JVT, да. JavaScript. Это нужно что-то стороннее ставить. Что? Нужно что-то стороннее ставить, чтобы Нет его умеет выпускать сам постгрест. Постгрест умеет его выпускать. Выйдёте наполнение клеймами. А наполнение клеймами. Это вы определяете хранимочку, которая говорит, что там определяется тип данных, который должен JWT clims заканчиваться, по-моему, тип тип такой свой, там, допустим, user JWT claims. И там говорите, у него есть ID, email, name, например, да, и хранимку, которая возвращает это. Постгвест автоматически, когда видит такую хранимку, он это сконвертирует и выдаст JWT клиенту. Вот как-то так. Если вот хороший вопрос, в одном проекте был такой бадкая ситуация, нужно было upлод видео сделать, а ничего страшного, сделали отдельно микросервис там на рельсах, и он с этими JWT тоже отлично работал. Сейчас огромное количество библиотек для всех языков есть. То есть он тут же он зная секрет, там нужно secретке знать для того, чтобы понять, ээ, можно ли этим данным доверять или нельзя. Расшифровать их может любой, а вот цифровую подпись проверить нужно знать. А, и дальше он просто точно так же проверял этот JWT токе. Он знал, что это такой-то пользователь 100%. Его можно видео можно грузить, сохранять и помечать, что это этот пользователь его загрузил. То есть тут микросервисная архитектура, она с другими сервисами можно интегрировать. Ещё вопросы? Что-то эта страна у вас вообще ни одного вопроса не задавала. Тут, наверное, фронтендеры больше сидят. Да, у нас ещё одна минута. Давайте ещё один последний вопрос. Ну нет, так нет. Спасибо. Yeah."
}