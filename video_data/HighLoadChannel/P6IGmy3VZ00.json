{
  "video_id": "P6IGmy3VZ00",
  "channel": "HighLoadChannel",
  "title": "Держим дизайн системы под контролем, используя изолированное юнит-тестирование / Андрей Коломенский",
  "views": 1851,
  "duration": 2755,
  "published": "2018-01-16T13:08:44-08:00",
  "text": "друзья Всем привет А меня зовут Андрей Коломенский я J коуч А я пишу код уже более 10 лет я работал как над сложными доменным моделями такие как платёжные системы так и над разработкой сложных Legacy кодов когда их приходилось спасать и восстанавливать продуктивность работы над ними У меня к вам вопрос вы пришли Вот на эту лекцию А что вы ожидаете услышать или что опасаетесь не услышать Как делать тестирование Как делать Юни тестирование сложными зависимостями О'кей ещё Ну вообще интересно про практику тестирования потому что покрытие так сказать из опыта 100% го невозможно тестирование того что постоянно варится вот как бы может быть советы На что лучше в первую очередь обратить внимание а правильно понял как добиться большого тестового покрытия вот так Да можно сформулировать Угу А ещё Да как тесты влияют на наш дизайн Окей ко Что делать когда много логики в базе Окей как соблюсти компромисс между дизайном и неза как соб компромисс между дизайном и не дизайном ой Давайте начнём проблема которую я заметил За всё время которое я извиняюсь работаю выглядит следующим образом Хм Окей я могу а окей супер У нас есть график зависимости продуктивности от времени и когда мы начинаем проект или когда мы работаем над этим проектом в наших бизнес-плана в наших ожиданиях Мы всегда думаем о том что мы будем двигаться с постоянной скоростью на самом деле реальность с нами не согласна переключи пожалуйста Да и в реальности я часто замечаю Вот такую картину что мы очень скава в куду самого нача радуется что мы поставляем как программист очень много фич а в конце он жалуется о том что мы поставляем фич мало и в результате где-то вот в этой зоне у нас возникает сильное чувство того что мы хотим всё переписать и сделать заново или провести какой-то крупный рефакторинг вот эта ситуация когда мы хотим выкинуть код меня очень сильно раздражает очень сильно бесит потому что это очень близко ко мнете ванское кокое решение года ходили в продакшн и через полтора года у банка отзывает лицензию Когда у нас почти было всё готово бизнес решает не бросать код и сделать Pivot мы теперь будем не кошельком решением мы будем платёжным агрегатором предметная область очень похожа мы берём деньги от одних пользователей забираем все комиссию отдаём магазином мы выкинули весь наш код потому что мы не смогли сделать вот такой вот Pivot даже на близкую доменную модель даже на близкую по смыслу а предметную область Почему Потому что наш код был слишком жёсткий жёсткость говорит о том что система жити сопротивляется внесению изменений для того чтобы внести изменения мы должны затронуть очень много компонент для того чтобы изменения наши наши бизнес-требования внесло в систему наша система Дай была хрупкой лити лити - это понятие тенденции системы ломаться в самых разных местах при внесении Казалось бы небольших изменений наша система была непереносимость системы которое говорит о том что мы не можем повторно использовать код из одной системы в другой системе точнее можем Но затраты на извлечение будут дороже чем затраты на написание кода с самого начала наша система содержала а ненужной дупликации ненужного повторения и наша система давай содержала избыточную сложность мы когда часто ошибка программистов когда мы делаем всё с самого начала НЕФ догов Production мы делаем за делом на будущее вот у нас было этого очень много а Часть системы мы не понимали Как устроено это показатели качества оти мы не понимали Конкретно что система из себя представляет что она выражает то есть ясность выражения намерений у нас была достаточно низкой и последний параметр viscosity я его вынес отдельно это атрибут качества который говорит о том насколько система сопротивляется применению качественных архитектурных решений в качестве примера допустим тесты проходят час всё Ни о каком tdd речи быть не может всё это система с огромным показателем виско Сити вопрос заключается следующим образом А как мы можем узнать Как должна выглядеть наша система Вот в этой точке в точке максимально высокой продуктивности потому что тот код который мы выкинули он был покрыт тестами мы заботились о его качестве мы Фактори и в результате мы всё равного выкинули почти весь там система биллинга сохранилась ещё какие-то Часть системы Но неважно Нам нужен какой-то инструмент получения обратной связи от системы инструмент или техника которая помогает нам понимать как именно мы должны проектировать нашу систему потому что тех знаний которые у нас есть в главе даже если они есть они их недостаточно для того чтобы конкретный момент знать как вообще в целом наша система должна выглядеть это не они тесты это Unit тесты я буду делать презента поуже основной инструмент получения обратной связи от системы когда мы пишем Юнит тесты мы как минимум можем гарантировать корректность система и когда мы пишем Юнит тесты мы как минимум можем гарантировать какое-то небольшое качество тесто пригодности нашей системы Давайте посмотрим на один тест У нас есть пример в вакууме by product Action мы вызываем это мы покупаем какие-то продукты к этому тесту У меня есть вопросы Но есть один главный что я могу узнать о качестве системы из этого теста практически ничего я могу по перебирать входные параметры я могу добавить больше артов я могу каким-то образом всё это дело проверять примять таких тесто должно быть достаточно много потому что у нас слишком большое количество характеристик продукта слишком большое количество характеристик пользователя и слишком большое количество параметров которые у нас в базе данных и фик завязаны а дизайне системы я не узнаю здесь ничего это причина почему мы выкинули весь код потому что то что мы узнавали из наших тестов не позволяло делать на систе более качественными Давайте предположим Что может делать себя может создавать заказ он может отсылать уведомления он может списывать деньги со счёта он может не знаю начислять процентные бонусы он может внутри себе делать очень много Давайте предположим Что будет если мы попробуем вот этот тест Или точнее Вот тест на этот метод сделать изолированным сделать так чтобы мы тестировали не всё целиком потому что здесь Мы выполняем реально множественную работу а выполнить только вот этот метод ра дать его поведение изолированного скорее всего мы это сделать не сможем потому что системы которые пишутся подобным образом с подобными тестами они не оказывают на дизайн системы такое воздействие чтобы могли написать изолированные тест Даже если мы можем это сделать скорее всего там будет трш Что такое интегрированный тест я сейчас уйду от понятия тест потому что оно сильно расплывчато каждый с этим понимает по-своему интегрированы тест когда мы не можем конкретно показать на точку Почему этот тест упал когда мы видим что это где-то находится у нас ошибка что какой-то компонент из области тестирования унос опал не конкретно одно место тогда этот тест интегрированный фактически это у нас только тест на один метод или на один какой-то а на один участок системы Где находится нетривиальное поведение остальное нетривиальное поведение оно замочной Окей значит мы начинаем с того что у нас есть какой-то анали компонент туда передаются какие-то входные параметры мы это дело засовы серс локатор У нас есть ещё какие-то компоненты мы здесь задаём их поведение Да ещё ещё даже не нужно читать я запарился это делать Это не нужно потому что да здесь оставь можешь прокрутить наза пожалуйста количество зависимостей кото мы видим в изолировано тее явно видим Оно обычно достаточно Огромно Даже если мы можем написать изолированный тест обычно ситуация выглядит следующим образом это первое что я делаю когда факторию системы в правильную сторону Я начинаю распивать зависимости по классом и Явный структор Давай дальше значит вопросов к этому тесту У меня тоже очень много плюс там есть косяки Но это неважно вопрос главный что я узнаю о качестве системы из этого теста я вижу что у меня явно нарушается принцип единственной ответственности здесь уже не отвертеться я вижу что мне этот тест Тяжело писать я вижу что мне этот тест Тяжело читать я вижу что этот тест будет постоянно падать потому что любое изменение у меня будет вноситься в этот класс полная жесть Мне этот тест было тяжело готовить даже для презентации если бы мы писали продакшн код мы бы просто сошли с ума Давай изолированные тесты я использую для того чтобы супер спасибо понимать Как должна быть устроена моя система они дают мне максимально полную обратную связь о моей системе Ура Заработало если интегрированные тесты мне не дают ничего практически ничего они мне может быть дают какую-то базовую корректность базовое понимание что часть моех систем работает корректно на части входных параметров то изолированные тесты позволяют мне сделать так чтобы я полностью видел что происходит мо та степень дискомфорта с которой я пишу изолированные тесты будет соответствовать степени тесто пригодности моей системы как загнивает система у нас прошли все Юнит тесты но отдел обнаружил какой-то дефект мы понимаем что проблема находится на стыке двух компонентов и реша написать Вот этот интеграционный те буду использовать поняти интеграционный У нас есть изолированный тест когда только один компонент тестируется один метод и интегрированный тест Когда у нас есть много методов и мы не знаем Какой конкретно сломался в каждый конкретный момент времени интеграционные тесты функциональные всё опускаем То есть даже тест мы не используем просто изолированный только один компонент интеграционный много мы решаем написать интеграционный тест потому что мы должны проверить реальную работу как конкретно Работает наша система Ну потому что у на вки Баста рекомендую использовать слово баг баг - это у нас мушка которая залетела к нам в серваки и пример Бага в из it разработке - это когда я взял из скапа SQL запрос вставил е в код он не работает хотя там простейший Селект был потому что Skype вместо пробела вставил неразрывный пробел вот когда така нищ происходит это баг А в основном случае я предпочитаю использовать слово дефект гораздо более мощная формулировка фов нет но какая-то команда умудрилась только за счёт того что пришла слово баг на слово дефект увеличить своё качество свой продукт фов нет фов нет так как мы написали интеграционный тест интегрированный извиняюсь неважно есть там интеграция или нет Он оказывает меньше воздействие на дизайн нашей системы мы когда пишем интегрированный тест Можем написать его реализацию по-разному вставить кучу зависимое СВЧ методов ко систе вызовите сервис локатора Лину просто вызовов абсолютно что угодно у нас полная свобода поэтому мы от лёгкой жизни начинаем проектировать систему менее тщательно потому что нам пофиг Как должна как может устроена быть наша система только на нашем собственном чувстве внутреннего как бы внутренней красоты Да вот просто смотрим на систему Думаем а как лучше но Ниго давления привело к тому что тесто пригодность нашей системы понизилась за счёт того что теперь мы не можем написать маленький изолированный тест по крайней мере если даже можно написать то это сделать сложнее В связи с этим у нас возникает больший риск возникновение дефектов потому что тестировать нашу систему становится сложнее у нас остаётся Меньше времени на написание изолированных Юнит тестов качественных маленьких соли Юнит тестов и Мы возвращаемся на круг и в итоге приходим к решению писать только интегрированные тесты потому что изолированные тесты писать сложно В результате мы получаем ситуацию когда на дизайн нашей системы не влияет ничего только мы сами как хотим так её и пишем есть альтернативный вариант та же самая ситуация прошли Юни тест но Нашёлся дефект все эрти они явно показывают ребята коче это отстой пожалуйста Используйте интеграционный тест в нашем случае мы используем понятие интегрированный Что будет если мы напишем маленький изолированный тест мы столкнемся с кучей Проблем Проблем с тем что система мешает нам писать эти маленькие изолированные тесты для того чтобы облегчить себе жизнь для того чтобы просто начать писать тщательно для того чтобы нам не приходилось писать вот такие вот огромные тесты чтобы тесты были маленькими для этого нужно очень сильно постараться сделать систему качественной это ведёт к тому что тест нашай система повышается мы стараемся сделать нашу систему максимально тесто пригодной чтобы нам было легче писать изолированные Юнит тесты в результате с тесто пригодной системой У нас есть больше времени написание маленьких заны тестов и меньше дефектов Это мой Point непрерывно поддерживать систему в качест состоянии возможно только практикуя тест извиняюсь правильно произносить это немножко отличается от того доклада который был вчера я представляю здесь совершенно иную точку зрения Мы обычно сталкиваемся с одной альтернативой нам сложно темы это деем понно им прит ни тесты - это сложная Тема и проще написать интегрированные тесты когда мы просто вызываем огромное количество вызовов либо написать вообще функциональные тесты вообще Юни тесты не писать потому что это сложно это нас не на давит это замедляет разработку Что такое Test dri development это дисциплина дисциплина подразумевает ограничения которые мы на себя накладываем применяя её что это за ограничения это не Red Green refactor это ряд конкретных правил вам запрещается писать больше кода продакшена до тех пор пока у вас не написан падающий тест или за исключением прохождения одного падающего теста Пока увас нет падающего теста вы не можете писать продакшн код и вы не можете писать тот код продакшена который не относится к этому падающему тесту это первое ограничение второе ограничение вам за запрещается писать больше кода чем доста для его падения Любка Кои останавливайтесь писать тест как только он упал даже с ошибкой компиляции и третья ограничение вам запрещается писать больше кода продакшена чем достаточно для прохождения одного падающего Юнит теста Всё верно Это не просто мы пишем тест а потом пишем реализацию не просто Green не просто red red Green Извиняюсь это надстройка над вот этими ограничениями это Test ding Development это вот то что позволяет поддерживать нашу систему в качественном состоянии И поддерживать нам максимально высокую продуктивность на протяжении длительного периода времени я сейчас раскрою эту тему Что такое Legacy код Согласно определению данному Михаилу фезер ers если правильно произношу Legacy код - это Код без тестов всё просто Почему Потому что я в своей практике замечаю прямую зависимость между жду отсутствием тестов и наличием огромнейшее а также наличием интегрированных тестов и примерно такой же зависимостью с проблемой дизайна системы чем у нас меньше маленьких изолированных тестов тем больше проблем с дизайном системы когда тестов Нет это Legacy Мне нравится ещё другой определение которое менее точное но которое отражает действительность это код который страшно изменять есть люди допустим де Томас который говорит я пишу я уже не пишу тесты почти Я и так проектируют пригодную вот но когда я с этой системой Допустим буду работать без тестов Для меня эта система будет leg потому что мне будет страшно носить в неё изменения Роберт Мартин хочет сделать так чтобы в нашей профессии мы давали клятву также как врачи дают клятву Гиппократа становясь врачами я это привожу здесь для того чтобы наглядно продемонстрировать Почему нит тесты как минимум важны для нашей индустрии и как максимум тест ding development как дисциплина важна для нас первое я не буду создавать вредоносный код Это относится не только к вирусам это также относится к коду который создаёт убытки для нашей компании если мы написали код который прис компании убытки это вредоносный код мы мы как программисты клянёмся не создавать вредоносный код код который Я создаю всегда будет моей лучшей работой я не буду отельно допускать чтобы мой код был дефекте как в поведении так и в структуре в поведении понятное дело мы не можем гарантировать его корректность если у нас нет какой-то проверки в структуре если у нас нет маленьких изолированных Юни тестов мы не можем гарантировать что дизайн нашей системы он тесто пригоден и хорош для того чтобы поставлять быстро нам нужно делать маленькие релизы а делать маленькие релизы с достаточным степенем качества без тестов Лично я не могу Да секунду Да но это собственно о самих тестах для того чтобы принципе ре Фактори код нам нужно не бояться его изменять мой старый патерн выглядел следующим образом я вижу место в системе и вижу два способа его э внести изменения в эту систему лёгкий способ Костыль либо сложный способ когда мне нужно арифа Тори причём серьёзно так арифа рить там нужно взять и предметную область немножко поменять вот внутри системы её выражения если у меня нет тестов я предметную область выражение предметною области в системе менять не стану Потому что если я что-то сломаю мне скажут Андрей ты сломал наш код А мне этого не хочется поэтому я выбираю лёгкий способ с Юни тестами у меня такой проблемы нет а практикуют тест девелопмент проблем нет вообще у меня код всегда корректен если там что-то ломается это боль для меня как для профессионала потому что я чувствую что Я где-то облажался причём по крупному у меня дефектов возникновение дефектов Вот лично для меня это прям уже серьёзный вызов часто говорят что СТД development снижает продуктивность или когда или её повышает Когда мы уже долго практикуем на самом деле Он сохраняет продуктивность наш на постоянном уровне как только мы А да вообще супер Наша задача не двигаться быстрее Наша задача двигаться с постоянной скоростью Наша задача сделать так чтобы мы не выбрасывали код и СТД девелопмент позволяет нам это делать если я вижу код другого человека и там нет тестов для меня это проблема Я не могу разобраться Ну могу разобраться что там происходит но мне страшно вносить туда изменения если у нас в команде практикуется парное программирование и полное покрытие Юнит тестами Нам очень легко друг друга подменять и работать над разными системами частями системы проценки немножко не относятся но в принципе да относятся если у нас есть страшно Legacy и мы говорим Это займёт неделю А потом мы откапываем место которое покрыто говнокомп в три очень частое явление с leg кодом и последней я хочу попросить вас проверить Утверждение что позволяет держать вам продуктивность на максимальном уровне на постоянно Я хочу чтобы вы попробовали у себя в продукте найти Часть системы которую вы считаете хорошо спроектированной на котором может быть есть тесты но они интегрированы и попробовать написать на эту часть системы Маленьки кото будете испытывать соответствует степени качества этой системы Попробуйте это сделать Попробуйте написать маленький изолированный тест и это даст вам понимание того что ваша система хорошо спроектирована или плохо спроектирована Если вы поймёте что система спроектирована не очень это Повод задуматься О том чтобы начать применять тест D development простейший пример у нас есть клиент который зависит от сервера сервер контекстно Независимый тестировать его очень легко мы просто берём вызываем методы смотрим на входящий результат тестировать клиент сложнее сейчас он гвоздями связан с сервером и для того чтобы протестировать его Независимо нам нужно их разделить мы посередине должны вставить интерфейс Теперь мы можем тестировать клиент независимо от сервера наверное многие из вас слышали совет программировать на основе интерфейса а не реализации Нони понимали Почему этот совет хорош того почему этот совет хорош если мы хотим писать маленькие изолированные тесты которые помогают нам с проектированием нашей системы мы должны как-то разделять наши компоненты и для того чтобы их разделять нам нужно посередине что-то вставлять в данном случае это интерфейс интерфейс - Это не просто набор методов и не просто набор сигнатур входящих выходящих параметров это недостаточно для нас просто рассматривать интерфейс как даже со строгой типизации набор методов Интерфейс - это также контракт Что такое контракт контракт - это то ожидание которое должно быть удовлетворено клиенту когда он спрашивает что-то у интерфейса допустим интерфейс Пожалуйста верни мне активных пользователей недостаточно просто проверить что уходящем нам нужны именно активные поэтому мы пишем тест в котором Мы спрашиваем интерфейс Пожалуйста дай нам активных пользователей и типа делаем реальную работу потому что нам реальную работу делать Не нужно мы пишем изолированный тест на основании стаба возвращаем какое-то значение пустой массив Окей знат Мы выводим на экран что пользователе нет О пользователе так мы своди допустим пользователя одного если пользователей много мы выводим список таблиц Всё мы написали три теста теперь Наша задача сделать так чтобы контракт выполнялся какой-то реализации если левая сторона сейчас работает то мы начинаем работать на правой Мы реально лезем в базу данных Мы реально что-то достаём и проверяем что мы действительно достаём активных пользователей действуем в соответствии с контрактным интерфейс таким образом если у нас есть левая сторона Где мы конкретно задаём Как ведёт себя наша система и с правой ны стороны мы Конкретно задаём что система действительно исполняет ожидания которые от нас компоненты хотят мы получаем что у нас левая сторона работает правая сторона работает и всё вместе оно работает нам не нужно тестировать клиент и сервер вместе для того чтобы проверить Их корректность достаточно правильно сказать Окей мы правильно спрашиваем мы Правильно обрабатываем мы Правильно действуем мы правильно проверяем то есть ВС контракт исполняется три теста там может быть даже один тест Здесь всё наша система корректно работает этого достаточно вместе с своими друзьями Гра и ещё какая-то туса там была придумали вы в Она проходит все тесты если тестов в системе нету Если она не если код не проходит тесты код простым считаться не может как минимум потому что вы ИС косите вязко системы очень большая Я когда лезу в этот код мне страшно его изменять И это проблема потому что он начнёт загнивает будет падать тесты обязательно условие для того чтобы код считался простым дальше мы можем сконцентрироваться на прояснение наших намерений и устранении дупликации я не помню кто сказал надо вспомнить код должен считаться Как хорошо написанная проза после того как у нас работают все тесты мы можем солиться на том чтобы наш код читался Как хорошо написанная проза и удалить ненужную дупликации в самом конце мы можем уже подумать о том чтобы наша система состояла из меньшего количества элементов Я советую вам добавить этих ребят в друзья в соцсетях в Твиттере в центре кенк основатель экстремального программирование и дисциплина слева jbg это основатель компании Bra Я думаю все вы её знаете и Роберт Мартин авторов сборника Solid и очень крутой чувак подпишитесь на них берите сних приме изучайте то что они пишут их деятельность ссылку на проект ребер и Роберта Мартина я вам сейчас дам берите с них пример Что делать дальше как я уже сказал Я хочу бросить вам вызов Попробуйте взять систему которую вы считаете хорошо спроектированной и Попробуйте написать на неё маленький изолированный Юнит тест просто чтобы мы могли замочить и контролировать поведение кото внутри этого ме происходит высь что вы это сделать не можете и это приведёт вас к тому что нужно с этим Либо что-то делать либо на это забить Если вы будете с этим что-то делать то я советую вам посмотреть на вот эти ресурсы the world Best Intro to Test D development от Джо Рейнс бергера и проект Clean coders от Роберта Мартина Я советую вам пройти вот этот курс это всё платное Но это всё очень качественно я вам крайне рекомендую и дальше уже как пойдёт практикуйте тест Деп проясняет дублирование спасибо да спасибо за доклад у меня такой вопрос наверное я познакомил с тестами Мне понравилось как бы я реально убедился в том то что они выпрямляют Твою архитектуру Вот Но вопрос такой как то есть У меня например то есть у нас например в компании Да там 20 человек вот и как вы То есть как привить это этим грубо двадцати людям писать тесты Потому что некоторые некоторые пишут тесты но они это делают просто они всё замока и всё нормально тесты проходят Но вот как вот именно то есть их приходит за крайне долгое время тратить на то что чтобы они написали это нормально как с этим справляться значит да отвечу у меня есть ответ на этот вопрос В первую очередь cdd - это персональная дисциплина на её использование вам не нужно разрешение менеджера или разрешение команды это вы лично как профессионал выбираете сами практиковать тера девелопмент или нет Если чело вашей команды не хочет практиковать тера девелопмент вы его не заставите это первый поит а второй поит личным примером люди будут видеть что выставляете код с качественным дизайном с меньшим количеством дефектов вы уходите На работу вовремя Приходите на работу может быть чуть позже потому что у вас всё работает всегда у вас нет дефектов у вас нет никаких проблем если мы посмотрим вот на дж регера у него в была проблема в том что он написал Код ушёл на домой коновка Наро из пытался это дело сделать сделать сделать сделать сделать но у него не выходило Test development упа и даже ему спину вылечил это не шутка вот просто насчёт того то что именно личным примером мне конечно може долго сейчас говорю ным примером и вдохновлять да то есть говорить ребята есть тест D development есть вот э видюшки показать им видюшки А я буду в 17 часов по-моему в А7 а17 Проводить мастер-класс по тому как правильно писать по Test dri development это эти именно три закона То есть можно просто на своём примере наглядно показать что такое девелопмент Потому что если мы говорим ребят короче а пишите тесты до реализации тяжело очень тяжело то есть проще на это дело забить вот можно замотивировать тем что ваша зарплата вырастет потому что на западе сейчас везде тест требуется что вырастет ваш профессиональный уровень причём серьёзно вы столкнетесь с теми проблемами которые вы раньше не видели которых Даше не задумались все советы которые нам дают книжки типа солида закон Дек а там comm quy separation всё вот это начнёт приобретать смысл Потому что когда мы вообще тесты не пишем на этом вообще на всё пофиг если пишем интегрированный тест нам тоже на всё пофиг потому что можно ссать всё как угодно вдохновить Спасибо Угу спасибо за доклад Андрей и вопрос такой э пример самый первый был с покупкой Да и ты говорил про то что нужно писать маленькие тесты изолированные Всё верно а там у нас был соответственно контроллер обращение к базе логирование возможно ещё внешние какие-то системы э отдельно мы каждую можем да замокать протестировать но мы должны быть уверены что когда у нас контроллер работает не просто возвращает нам что заказ совершён А что все действия произошли вот и ну маленькими тестами этими мы не покрываем да а да Сейчас Сейчас отвечу Ну то есть на самом деле нет а не важен ответ важна вот эта штука сейчас я отмотал это дело вот что важно Неважно Что мы делаем вообще абсолютно если Мы двигаемся вот по такому циклу Мы видим что у нас в любом случае будет тест на что-то А твой вопрос за заключался в том а Будем ли мы уверены что это работает да или что мы уверены что маленький кусочек каждый работает сам по себе а каждый из них отработал всё ли выполнило что мы ожидали Да это возможно мы не сделали важную часть какой-то работы которую хотели а да то есть это выглядит вот так наверное да Ну почти что Да зависит от того как именно ты пишешь если у тебя есть если ты практикуете просто что-то пишешь да то у тебя в любом случае будут дефекты потому что будешь забывать и забивать на всё сейчас секунду я доведу мысль до конца если у тебя то ты последовательно пишешь тесты Это первый мым поведение что мы ой берм из базы данных такое-то значение если там на то мы выводим что ничего нет Если что-то там появилось то мы водим что что-то есть всё Мы точно уверены что это работает Вообще супер и что мы из базы данных действительно вот этот компонент достаёт если что-то пошло не так вот как раз вот этот пример что-то пошло не так у нас два выхода либо действительно писать маленький тест и прояснить намерения И прояснить вообще структу восходит и написать интегрированный тест то есть дефекты возникают это нормально Это просто практика именно а следования дисциплины То есть ты уже когда пишешь ты уже начинаешь понимать Что окей Я написал Вот эти два теста коллаборации У меня есть нал и не Нал всё в тесте контракта я должен проверить что у меня нал не Нал действительно возвращается и оно складывается ответил на вопрос Ну не знаю просто программист забыл добавить таск на отправление эсэмэски пользователю а интеграционные тесты проходят ни тесты проходят а не до конца функционал реализован Ну это можно мы сейчас не проверяем базовую корректность мы сейчас проверяем что требование удовлетворяются Да просто другое решение нужно для этого ну сверху Обычно я функциональный тест пилю то есть там либо bdd можно практиковать то есть мы задаём спецификацию вообще исполняемую то есть что бизнес-требования выполняются мы этим корректно системы не проверяем для корректности двигая дизай нашего систе в лучшую сторону у нас тест а для того чтобы проверить что требования исполняются вот функциональны тест Самое оно то есть я обычно так делаю понятно да спасибо спасибо за доклад разделяю твоё мнение о тестировании Но наверно есть те одна по марочка разрабатывал продукт с нуля Когда продукт пишется не с нуля или ты приходишь на чужой продукт скорее тестирование начинается сверху вниз с интеграционных идёт как ты сказал изолированных Да есть пирамида тестирования у нас в самом внизу тесты после интеграционные либо интегрированные Неважно как мы сейчас будем называть и в конце UI тесты или тесты к функциональны обычно Да она перевёрнута у нас огромное количество UI тестов интегрированных И вообще липу и уже вопрос Что значит хорошая архитектура спроектированы Спасибо А я это определяю так если я могу на систему написать маленький изолированный ют тест который чётко показывает что делает метод и чётко фиксирует его поведение я понимаю через маленький изолированный тест что происходит система хорошо спроектирована там прямая зависимость мне вообще неважно что написано в продакшн коде абсолютно если у меня есть маленький изолированный тест Я понимаю что там написано мне этого достаточно Это значит что я считаю систе хорошей что бы там в прода коде не было хорошо у тебя 100 ты методов и ты 23000 этих тестов это нехорошо спроектированная система Почему ну человек в голове может держать не больше 0 параметров держать в голове абстракции такого размера мы не можем че Я тебе больше скажу Обычно когда вот именно через изолированные тест мы идём и начинаем это дело практиковать у нас появляется очень много объектов которые содержит только один метод или даже интерфейсов которые содержит только один метод и количество множится помниш четыре правила простого дизайна в самом начале у нас систе проходит все тесты Это значит что наша система полностью тесто пригодна мы концен только на этом если у нас как бы есть некие некая потребность делать количество элементов меньше это самая последняя история Когда у нас уже система Ясно выражает намерение дупликации нет а все тесты проходят идеально То есть я вообще от количество элементов не парюсь мне главное не их количество А чтобы они в голове укладывались Вот для этого мне нужно рефакторинг ВНО решение нашего нашей системы которому принимать к нашей системе если мы ошиблись в этих решениях наш продукт умрёт вот дизайн нашей системы это впе взаимосвязь всех этих элементов как я вот определяю а прямая зависимость То есть если мы практикуем написание маленьких изолированных тестов У нас вот это всё начинает меняться Просто оно начинается дробится оно начинается более становится изолированным более гибки наша система становится То есть это Прямое воздействие на архитектуру то есть можешь проверить это утверждение ты можешь попробовать написать маленький изолированный юнитест не получится и тебе придётся это как раз воздействие на дизайн системы на архитектурное решение Ну то есть это в зависимости от определения можно в принципе знамен поставить То есть это влияет в сторону как разни качества Я ответил на вопрос можешь ещё сформулировать просто вот давай Андрей вот такой вопро думаете целом может увеличить эффективность команды приведу пример Ну контекст вопроса У меня есть программист в команде когда он не тестирует свой код он делает Не много ошибок он делает много опечаток Ну то есть Это не ошибки Это опечатки А когда тестирует свой код он очень долго пишет причём очень долго пишет Не потому что ну что-то не так а потому что он боится принять рение по системы Вот что ты в этом случае посоветуешь и возвращаясь к своему вопросу Ну увеличит ли ТД эффективность команды если увеличить то как А я пишу через девелоп 100% своего времени есть исключительные ситуации когда код Мне нужно выкинуть вот тогда я могу взять на говнокод когда я знаю что пишу когда я нахожусь в какой-то малейшей пени определённости всегда иду через тест Почему Потому что я так максимально продуктивен но у меня просто огромный опыт написания тестов а у человека которого это опыта может не быть он может двигаться медленнее но задача не повышать продуктивность а сохранять её на постоянном уровне То есть если мы тесты не пишем наша система будет деградировать потому что разработчики будут бояться её чистить будут бояться Фактори А если он пишет опечатки Ну как бы ничего страшного ты берётся и Фактори если он может Фактори А без тестов он Фактори не может я лично когда вижу код я либо на него пишу тест и потом только фак то есть мы как раз занимаемся спасением кода либо всё либо я обхожу это дело потому что нафиг нене нужно лезть код который сломается по моей вине не конечно можно дернуть но я не такой вот у нас всё-таки есть Клятва мы не пишем вредоносный код если там будет дефект пользователи будут страдать А мне не хочется а что с программистом сделать Ну ну наверное вопрос как с помощью ну можно с помощью Т каким-то образом сократить время принятия его решений на создание архитектуры Нет лучше не надо тратить Меньше времени на как бы продумывание да А спасибо за доклад у меня такой может быть не очень стандартный вопрос Если у нас код 90% того что делает производит Сай эффекты Нужно ли для него писать Юнит или вообще Есть ли в этом смысл изолированы изолированный тест да то есть основная проблема в ЧМ когда у тебя есть тест кото Дат тест на компонент который Дат он делает под собой комне слишком многого вот интерес в том чтобы вот это что те ко ме у тея было пример более простой допустим у тебя один есть метод он выдаёт на экран Привет Андрей один другой там ну там файл допустим Не на экран другой Хорошая погода сегодня второй метод выдаёт там мамы раму другой файл то есть имеет ли смысл зде э или интеграционные достаточны бывает в таких случаях причём вот это вот 90% кода - это именно вот такие вот методы без параметров которые производит какой-то вот один вот такой фиксированный сайд эффект Ну смотри это получается изолированный тест если там действительно только printf мы взяли протестировали один метод там printf это изолированный тест А если помимо printf он ещё письмо отправляет нене Это чисто вот так вот это изолированный тест неважно он выводит там во внешнюю систему что-то или нет то есть одна точка интеграции всё равно это изолированный тест если она тестирует и конкрет точку интеграции можно назвать тест интеграционным Угу Ну то есть э условно говоря мокать там не знаю stout не stout там вот этот файл смысла нету а как бы просто уже те ни систе на границе систем Да когда мы с внешним миром общаемся Да там может быть даже прослойка интегрированных тестов это как раз тот случай когда интегрированные тесты можно написать мы общаемся там с Active рекордом с Ю там с нфм вот этим допустим я просто О'кей вижу что в printf вывел или нет Вот то есть мне Вот именно вот вот там вот реальную работу нужно уже как бы не протестировать то есть больше в реально Да вот но основную часть системы я стараюсь именно полностью держать под контролем чтобы у меня все зависимости были под контролем тесты контрактов тесты коллабораций угу понятно спасибо Дорогие участники время лекции К сожалению подошло к концу продолжить обсуждение Вы можете в переговорка я сейчас там буду находиться снаружи сходите задавайте вопрос Спасибо вам"
}