{
  "video_id": "lhbyohY18Ic",
  "channel": "HighLoadChannel",
  "title": "Service Mesh на стероидах, часть 2: Zero Deployment Downtime в корпоративных приложениях / А. Ефимов",
  "views": 2049,
  "duration": 2988,
  "published": "2023-04-28T06:10:46-07:00",
  "text": "Да всем привет слышно меня я в эфире on air Ладно поехали значит доводилось если вам доводилось вдруг бывают в славном городе Мадриде что на испанщине наверняка бывает там в галерее Prada Вы видели вот прекрасное произведение искусство которое демонстрирует нам типичный рабочий день системного архитектора в общем все что обычно в жизни у нас происходит а-а ежедневной сценки в общем все здесь как бы что же мы видим на этом прекрасном произведении мы видим самого системного архитектора заработаем и похоже слегка отвлекли его Он слегка озадачен Почему уж так много народа у него смотрит Но вот как бы мы видим прекрасный архитектуры которую он придумал и он думает вот Вот так оно будет оно на самом деле получается вот так примерно на первый день после продакшена ну Такова жизнь Ну и в целом вот как бы взаимодействие с заказчиком Тут видно вот мы тут работаем с людьми кто не знает как называется прекрасное Полотно ну Верно верно называется оно триптих сервис mash корпоративных приложениях и поскольку это триптих соответственно он состоит из трех частей и первая часть этого триптиха повествует нам о том что такое сервис мыши Какие задачи Он решает И что же Он решает Он решает задачи параллельно выкатывания фич Он решает дальше структурирование приложений Он решает дальше работы между различными дата центрами всякие вопросы взаимодействия с интеграциями версия Они прикосновенности и так далее чтобы ознакомиться с этой первой частью всего лишь нужно сесть машину времени вернуться ровно месяц назад в том зале на год вернее В этом зале Я выступаю рассказываю про этот самый сервис корпоративных приложений если занята Машина времени вот пожалуйста есть ссылочка на YouTube Смотрите приходите это интересно вторая часть триптиха ради которого собственно Мы собрались Я немножечко расскажу как именно вся эта штука пользуюсь используется для того чтобы сделать зеро дипломинг даунтайм именно в корпоративных приложениях в интерпрайзах А я из мира телекома Я из мира реально больших приложений больших интерфейсов где количество подписчиков измеряется десятками миллионов то есть в общем-то это немножечко не стартаповый уровень немножко чуть повыше поэтому технология слегка специфические поэтому говорить я буду в общем про параллельное выкатывание фич и как выкатывание фич сделать так чтобы выкатывали не нарушая работоспособность системы Все мы любим Эксперименты на продакшене вот вчера были прекрасные прекрасные докладывают жене Пак прекрасное дело доклад и потом в колорах пообщались Все любят всякие различные Эксперименты на продакшене и мы не любим на продакшене нет в телекоме Эксперименты на продакшене не любят я вам открою секрет это такой такая индустрия в которой стабильность В общем превыше всего превыше фич поэтому что же у нас есть Казалось бы кенере дипломмент что может быть проще всегда выкатывали кенри дипломмент раскатали рядом новую версию приложения пустили на него какую-то часть аудитории посмотрели разработала значит пустили в продакшн и заработала откатили о чем вообще речь Да речь в общем как бы вот о чем чуть сложнее жизнь оказывается Особенно в больших интерфейсах во-первых фич может быть больше одной у нас это бывает не часто но случается приложение он большой это сотни гигабайт памяти это десятки в общем-то не очень-то и выкатишь особенно если у вас не Amazon какой-нибудь а какой-нибудь онс там нет такого запаса мощности нужна именно таргетирование фокус-групп то есть мы выдаем не абстрактным пяти процентам фичу мы выдаем конкретным людям с именами и фамилиями дальше развернуть instance приложение в Телеком индустрии тоже в общем-то не сказать что подвиг Но это событие и просто так вот в один клик Это тоже не делает И главное мы не должны никак повлиять на интеграции потому что у нас обычно десятки там до сотни интеграции все наши разворачивания новых инстансов они должны пройти совершенно незаметно для всех внешних интеграций и вот такая вот подсказочка когда мы выкатываем новую версию приложения обычно мы диплом не более 20 обычно пять процентов сервис изменяется в общем-то не так много и убивать всего слона ради одного маленького бивня не очень-то хочется с диплоить целое приложение не хочется поэтому мы не будем Иди плыть целой пряжей мы будем диплоить только дельты То есть то что изменилось в том и диплом что не изменилось то не диплом и из этого возникает вот Такой сценарий о котором я буду рассказывать на презентации мы выкатываем новую фичу в ней три микросервиса два взаимодействуют по листу два взаимодействия через моя судьба мы должны выкатывать мы должны диплоить только дельты тоже только теми микро сервисы которые изменились но очень важным эти Новые микро сервисы привносят новые контракты и мы вот должны в условиях мутирования контрактов сделать так чтобы система осталась работоспособной и снова возвращаемся к нашему прекрасному произведению и вспоминаем Первое правило архитектора о котором я рассказывал в прошлый раз к разработчику своему нужно быть гуманным разработчику есть чем заняться но они все заняты они знают что делают Им не до наших вот этих вот системных Если мы придем к разработчику и скажем ребята Напишите там и в чеки всякие поставьте флажки Да я хочу сюда они скажут Мы конечно сделаем это когда-нибудь ну вот пожалуйста без этого мы должны сделать так чтобы разработчики ничего не заметили что все вот это вот наши кенри дипломин Zero Down Time для разработчика прошло абсолютно прозрачно абсолютно бесплатно и никаких лифчиков писать ему чтобы не пришлось и немножечко терминологии чтобы ввести как мы любим домена специфический язык вот введём сейчас домена специфический язык этой презентации значит термин первый отличный это наш дистрибутив то что мы диплом он содержит протестированный согласованный набор микросервисов с версиями все контракты там выверены всё прекрасно работает у него есть название CRM в данном случае и версия а следующий термин контракт это собственно спецификация поведения и интерфейсом микросервисов это может быть API формат данных поведение и Обычно когда мы выкатываем новую фичу мы контракт расширяем на нередко мы его и ломаем вот в данном случае мы выкатываем новую мажорное поколение этого самого applicationa и вот видим что Контракт по мессенджу у нас был сломан Мы вводим новое поколение контрактов и опять же вспоминаем Первое правило никто этого не должен заметить всё должно остаться работоспособным и спокойненько переключиться И третье третий важный термин - это наш специфический для компании внутренний термин поколение поколение - это просто счётчик номер установки Вот мы поставили первый раз приложение это поколение номер один поставили поверх фичу пока они номер два или накатили багафикс поколение номер три там поставили новый поколение номер 4 и так далее просто монотонно возрастающей списочек и мы дальше будем оперировать этими номерами поколений Ну и опять же А почему же это не похоже на обычный Rolling update но там ваш в общем-то тоже есть поколение например вот есть два микросервиса мы начинаем выкатывать новую версию приложения каждая Новое поколение это реплика сет в пределах дипломета просто создаётся новая реплика сет А в этом в этом новом репли к сети запускается под Ну как бы Всё достаточно стандартно Вот и взаимодействуют через сервисы вот пожалуйста как бы там всё всё есть поколение сменяют друг друга новые поды стартуют старые поды удаляются как бы где сложность а сложность Вот она в чём что это взаимодействие неуправляемое То есть вы направляете нагрузку с произвольной версии под на произвольную версию кода если у вас меня контракт то этот Контракт будет сломан Если вы подразумеваете что у вас фича в трех микросервах в двух микросервисах вам обязательно нужно чтобы зеленый вызывал зеленый иначе фич у вас новая просто не заработает Поэтому нужно сделать так чтобы этот контракт это выкатывание было управляемым и опять же первое правило чтобы разработчик об этом ничего не знал общая идея мы выкатывая новую версию микросервиса выкатываем Новый дипломинг не реплика сет а новый дипломинг и у него у каждого есть свой сервис сервис и дипломинг в отличие от репли-кассета штука персистентная она не умрет сама собой и она не переключится перед этим самым сервиса стоит некий транспорт это может быть сервис mash это может быть мессен какой-то транспорт маршрутизирует запросы к конкретному поколению и делает он это потому что в реквесте есть соответствующая аннотация аннотация говорят А куда На какой э-э На какое поколение нужно смортизировать запросы значит поколение они как бы живут своей жизни как и в человеческой жизни поколение сменяют друг друга они сменяют друг друга по такому некому конвейеру фича приходит в этот мир в виде кандидата то есть поколение помимо номера есть ещё такая роль как вот есть там дед Отец сын внук то же самое есть в поколениях вот это вот самое роль первая роль - это кандидат когда мы диплоим первый раз нашу фичу она приходит в поколение кандидатов Почему кандидат потому что он может в продакшене пойти мы за диплоили кандидат мы на него пустили тестовую нагрузку покрутили проверили э-э понравилось продакшн не понравилась откатили но это как бы такая кандидат на вступление в жизнь после того как кандидат был проверен он отправляется и становится Active версии Active поколениям это наш обычный продакшн то поколение которое обрабатывает нагрузку то поколение на которое приходит основные продакшн запросы и По мере того как отрабатывает продакшн свое время и это поколение переходит в разряд Legacy это предыдущее поколение оно дорабатывает оставшиеся запросы и оно нужно на случай А Мало ли что и поколение они сменяют друг друга по конвейеру есть две операции есть операция промоуд которая сдвигает все поколения вперед сын становится отцом Отец становится дедом и так далее соответственно кандидат становится Active версией Active версия уходит в Legacy а предыдущая версия она замещается Мы как-то удлинять хвост мы как-то пробовали сказать А если будет несколько Legacy пока не очень не прижилось ни к чему это обычно вот этого достаточно есть обратная операция К сожалению её не бывает в жизни Но вот как бы у нас есть это роллбек когда мы возвращаем назад например не пошла фича вот мы ее вывели в продакшена она вот ну не пошла мы говорим давайте-ка Верните как было мы же любим как бы принять как бы было а вот вот здесь мы говорим как было дёргаем как бы рубильник колесо сансары проворачивается назад как бы и как известно мясорубку можно прокрутить назад как бы опять получится кошка А вот то же самое как и у нас а и для того чтобы это все не хаотично происходило у нас есть такая штука Как таблица поколений она записана в ней записана это такой единый реестр в котором записаны все микросервисы существующие в данный момент дипломин и какие поколения где какие версии микросервисов каких поколениях принимают участие самое главное что Active поколение Оно всегда заполнено видите она вот как бы сплошная Это значит что оно основное то есть продакшене всегда должно быть самое стабильное никаких выкрутасов с продакшеном все остальные поколения - это дельты мы их можем легко сбросить сказать всё это от лукавого оставляем только в продакшн и сбрасываем поколение Production остается нетронутым А все остальные поколения А это дельты И кстати кандидата в общем-то может быть несколько хотя мы и не любим Эксперименты на продакшене но иногда мы любим эксперимент на продакшене поэтому мы можем выкатить несколько поколений несколько кандидатов выбрать тот который нам понравился и его отправить в Production в активное поколение и рассмотрим такой небольшой примерчик значит первый дипломедлинейший когда мы делаем первый дипломинг у нас поколение сразу становится активным это такой вот немножечко исключение из правил мы же любим исключение из правил А теперь приходит новая версия вот в ней вспоминаем наш пример три микросервиса пришли вот эти три новых микросервиса они задиплоились в виде кандидата мы посмотрели сравнили Дельту между текущим А поколением и поколениям которые пришло видим но больше ничего не менялось только три микросервиса вот мы дипломи именно мы записываем таблицу поколений что вот у нас есть 3D дальше выполняем промоуд соответственно теми микро сервиса которые не менялись как были вективе так и остались те которые менялись вытеснились вниз по нашему конвейеру поколений диплом фича еще одну То есть например что-то еще как бы там подкладываем вот у нас как бы конвейер из трех элементов вот есть новый кандидат ввели какой-то новый поведение смотрим работаем И тут хоба баганов продакшене дергаем рубильник поворачиваем врубаем резко заднюю газ в пол и возвращаем все как было самое исходная версия эти единички возвращается предыдущий актив дельты возвращается в кандидат и кандидат вообще предыдущий удаляется вот такие вот эксперименты Но что самое главное Вот все вот эти откаты все эти промоуты это просто логические операции они выглядят вот так вот достаточно тяжело на самом деле они достаточно простые То есть это просто перелей вливание и просто изменения в таблице поколений то есть каких-то дисраптив действий каких-то там тяжелых изменений на продакшене происходит Просто перенастраиваем переразвешиваем ярлыки любим вешать ярлыки а Итого посмотрели мы как поколение сменяют друг друга что же такое технически является поколение А теперь посмотрим А как же сделать так чтобы программист прикладной ничего об этом не знал то есть ему нужно так чтобы потом задеплоил а среда Сама сделала так чтобы нужные на нужные поколения пришли нужные запросы здесь как бы вот этим как раз занимается фреймворк Я сейчас как бы на нем каждый начну рассказывать что что там происходит и главное что это динамический маршрутизируемая среда Мы в каждой точке определяем куда же мы должны идти такой вот у нас фреймворк такие вот квази и в Чите расставляет и там хоп хоп на правильно версию на правильное поколение отправляет запрос и он для этого пользуется аннотированными запросами то есть информация Куда нужно идти она приходит к нам в запросе и вот есть такой основной архитектурный паттерн Я буду рассказывать этот паттерн как он работает для реста как он работает для мессенджинга То есть у нас в центре архитектуры находится транспорт этот транспорт является концентратором сообщений все сообщения приходят в транспорт транспорт потом распределяет сообщение транспорт работает по статический по статической таблице взаимодействия это очень важно то есть момент Перри маршрутизации сообщения он никуда не ходит его заполнили нужной таблицей и он работает только по ней у него нет вот этих вот походов куда бы то ни было отделён Control plain от Data plain сообщение содержат метаинформацию о том какому поколению оно относится а Control plain это как бы наша сердце сервис mash оно управляет транспортом и оно управляет вот этими таблицами взаимодействия Когда происходит движение по конвейеру поколений Когда происходит какой-то дипломмент Мы еще делаем мы перезаливаем транспорт Мы перезаливаем в него новую таблицу и как бы транспортную статические начинает маршрутизировать сообщения между поколениями и того У нас вот в Control planny есть две внутренние таблицы Первое это таблица поколений о которой я рассказывал до этого и отдельно есть для каждого типа транспорта есть специфическая таблица маршрутизации данного транспорта и начнем А вот прежде чем начнем Вот вот если микросервиса несколько Вот примерно так всей этой работы то есть транспорт микросервис транспорт микросервис транспорт микросервис то есть всегда микросервис работает между транспортами именно это дает нам вот это вот изолированность что прикладной девелопер ни о чем не думает он пишет свой микросервис Он даже не знает о том что будет какой-то blue green ему гарантированно что транспорт правильно свяжет его контракты правильно свяжет версии epi правильно свяжет свяжет свяжет свяжет свяжет правильно взаимодействие так вот активное поколение есть всегда Вот потому что это Продакшен это самое основное вот у каждого микросервиса всегда есть активное поколение поколение содержится в запросе каждый запрос содержит информацию микро сервис должен принять целевое поколение из входящего транспорта и передать целевое поколение в исходящий транспорт это обязанность микросервиса но для этого мы микросервисы даем набор свой собственный sdk То есть он пробрасы контексты он знает Какой транспорт у него с Севера какой с юга берёт из этого транспорта за сообщение поколение и пробрасывает его и Если вдруг не Оказывается в запросе поколение значит это этот запрос будет отправлен на активное поколение то есть эта информация нет пропала Она случайно там или не было значит мы как бы всегда в активное поколение отправляемся то есть никогда запрос не будет потерян всегда будет обработчик Вот например микросервис мы диплоили какую-то новую фичу и микро сервис цен не менялся если мы даже вот на зелененькую поколение придем дойдем до микросервиса C транспорт посмотрит А ну не менялся он не содержится в этой фиче Значит мы отправим запрос на активное поколение через транспорт и посмотрим как это сделано врест транспорте вот тут такая виртуальная отсылочка к моему прошлому докладу там очень подробно про все это сейчас В общих чертах значит вот как выглядит взаимодействие тогда здесь микросервисы B и C микросервисы боится взаимодействуют по ресту технически это выглядит вот так то есть каждое поколение это новый дипломинты У каждого есть свой cuberneticsорский сервис и у этого сервиса есть постфикс то есть мы когда диплом микросервис дипломинмент поду или сервис мы к нему в хвостик дописываем имя то есть по сути мы при дипломите переименовываем микросервис мы дописываем хвостик потому что хвостик это имя поколение потому что ну нельзя задеплоить два дипломита с одинаковым именем А вот и взаимодействуют Они через гейтвы у нас используется anway в качестве этого действия является концентратором именно у него есть сервис с именем microservice микро сервис Он принадлежит а не самим дипломентом Все сходится на гейтвей гейтвей раздает всем запросы и вот он по таблице маршрутизации по поколению перенаправляет запрос в нужный сервис нужное поколение и Control Plane скидывает вычисляет таблицу маршрутизации то есть врест транспорте основная таблица таблица маршрутизации как она выглядит Что она делает это просто такая вот статическая табличка которая задает на какой Стрим API нужно пойти в зависимости от входящих параметров запроса и основным входящим параметром запроса является хедр поколение у нас передается в хедере это вот акустики Кедр состоящий из 10 байт то есть мы не тащим там каких-то огромных огромная информация просто просто номер Ну и там есть еще позже расскажу если все три ничего нет значит отправляем на активное поколение для каждого поколения в таблице маршрутизации будет запись может быть даже такая проблема что например микросервис б начинает взаимодействовать в какой-то фиче-кандидате с микросервисом F для этого будет отдельная запись в таблице поколений будет записано что для поколения допустим 3 у нас даунстрим таргетом является Не микросервисом б а микросервис е или F то есть изменение контракта между поколениями оно возможно и если происходит движение по нашему конвейеру то у нас перестраивается таблица поколений она либо Control plain перечисляет и скидывает 7 действиям переключением мгновенное то есть не происходит какой-то задержки дальше Откуда же собственно берутся поколение сообщениях тут есть несколько паттернов во-первых мы не всегда поколение задаем в виде номера Мы можем задавать поколение в виде имени для этого есть специальный хедр значит вариант первый тестировщики они обычно берут браузере плагин втыкают туда поколение и какой-то фич тестирует второй второй hind мы просто юзером который входит в фокус-группу выдаем атрибут что это фокус-группа гейтвей берет живота токен достает оттуда требуется фокус-группа и навешивает допустим Кедр что это фокус-группа идет на поколение кандидатов то есть мы можем конкретно таргетировать конкретному Иванову дать на тестирование конкретную фичу конкретное поколение потом отправить это в продакшн немножечко Мы же все-таки триптих у нас не забываем поэтому мессенги я расскажу поверхностно и я надеюсь что это будет Темой в следующей части стриптиха начнём вот что же происходит с ребитием в ребитием кью паттерн тот же самый паттерн транспорт предположим что у нас есть очередь ордеров и вот микросервисы взаимодействуют через очередь ордеров естественно там есть их счесть и очереди Мы все-таки в репетию Значит у нас есть продюсер У нас есть консилер как бы продюсер посылает сообщения консилмеры потребляет и концентратором здесь является X change messengy всех продюсеров приходят в один хедере тоже есть Федор содержат имя поколение очередь у каждого поколения своя есть поколение есть очередь У каждого свои и маршрутизация происходит посредством бендингов то есть на бензинги идет информация о том какому поколению этот байден там есть правило какому поколению на Какую очередь нужно отправить данный месседж и взаимодействие происходит через таблицу подписок зависит в отличие от листа где таблица может здесь таблица подписок значит что такое таблица подписок а она показывает справа таблица подписок а слева таблица версий таблица поколений значит таблицы подписок показывает какой микросервис является продюсером в Какую очередь И в какую очередь он является консьюмером в зависимости от этого мы вычисляем какие очереди нужно создать Какие бензинги нужно создать и какие правила нужно прописать на бандингах и вот например микросервис е он может легко начать в какой-то фиче отписаться от очереди ордеров А подписаться на очередь юзеров и опять же напоминаю программист об этом не думает Он просто сказал вот верси номер 4 у меня вот такая таблица подписок что с этим делать это моя головная боль это не головная боль у программиста не боли его архитектор вали вот такой вот гуманизм у нас а Кафка тоже В общих чертах значит Кафка она не такая крутая как Rabbit MQ она не содержит внутренних средств маршрутизации поэтому тут мы немножечко наш паттерн транспорт мы немножечко сместили в сторону консилеров Как это работает есть общий топик он один на всех на один на все поколения дальше каждый микросервис продюсер отправляет все свои сообщения все продюсеры шлют все свои сообщения в один топик консьермеры тоже потребляет все сообщения и на своей консистемерской стороне их фильтруют сразу Вы должны задать вопрос перформансом вот задали значит отвечу А если вы потребляете меньше тысячи сообщений в секунду вообще не заметите потребление цпу на фильтрацию вообще А если вы потребляете 10 тысяч сообщений Но там уже будет какое-то ощутимый процент но я думаю что ваша бизнес логика начнет сваливаться Когда вы начнете потреблять на один под 10 тысяч сообщений поэтому скалирование наше все решается достаточно просто Теперь смотрите вот такой интересный хинт и такой интересное такая интересная тема которая относится не только к blugreen у она относится вообще к любому взаимодействию когда у вас идет замещение одной версии микросервиса на другую Когда вы делаете ролинг апдейт тот же самый Как сделать правильно Грей Да он микросервиса и graceful замена микросервиса на новую версию чтобы не потерять существующие сессии не потерять существующие запросы вот предположим У нас есть два микросервиса А и B микросервис а шлет микросервису б запрос на его сервис и в какой-то момент времени микросервис б заменяется на новую версию должен сделать Две версии 2 2 действия Первое он идет на сервис и в iptables таблички удаляет оттуда даунстрим айпишник подаю исключает из таблицы маршрутизации второе он отправляет по 10 сигнал на то чтобы она завершилась и перестал ушла в небытие так вот проблема в том что операция это асинхронная и последовательность не гарантирована нередко Бывает так что мы сперва шлепнули поду и только потом удалили из таблицы маршрутизации нас есть некоторые момент времени когда запросы идут на отсутствующую воду потому что она еще есть а ну и вообще в целом то что мы шлепнули какую-то поду на которой был активный запрос от микросервиса а это в общем-то не очень хорошо потому что нам придется на микросервисе а делать какую-то логику с хэндлингом ошибок с ритаем Мы помним Первое правило как бы Мы помним Чем занимаются прикладные программисты им не дрит Раев поэтому мы должны сделать это У себя и что же мы делаем мы делаем вот такой трюк Мы в поди делаем задержку между сигналом который приходит на поду и сигналом который уходит на процесс на 30 секунд задерживаем и Это значит что как то первым делом у нас отключается сервис как только отключается сервис Это значит что перестают входящие запросы идти а обратные запросы они идут не на айпишник сервиса они идут на айпишне входящие поды поэтому с ними ничего не происходит спокойненько дорабатывают 30 секунд достаточно если ваш у вас вдруг синхронный рез запрос работает дольше 30 секунд то что-то вашей жизни пошло не так и правильно что придет к губернатису кильнёт вашу воду к чертям и не будет ждать какие-то Там сигмы отправит Кел -9 как бы птичка Будь здорова А вот примерно такие дела Ну и подведем немножечко итоги А о чём же была речь то есть делается за счет кеннери обычный как бы самый подход но немножечко сложнее А есть несколько поколений сменяющих друг друга фича это поколение тестировали фичу либо за промоутили ее в Production либо ее откатили может быть несколько фич но в Production пойдет либо только одна поколение диплоиться как дельты в этом самый самый сок Почему мы вообще ввязались вот в эту все в этот весь нелегкий путь для того чтобы сэкономить Железо Железо это деньги деньги Телеком и тоже умеют читать не только в банковской сфере умеют считать деньги Поверьте мне Телеком и тоже не благотворительная организация дальше поколение работают через транспорты то есть микросервис транспорт микросервис транспорт и все шадауны все перегрузки микросервисов делают только через Грейс волж отдам и о чём я совсем не поговорил сегодня это база данных потому что формально база данных может меняться между поколениями микросервисов оставим это на сладкое Ну и всё-таки у нас стриптих как-никак а поэтому третья серия Я надеюсь ты контини что называется фьючерс три о чём Нужно будет поговорить значит кафку и rebite MQ я рассказал в очень общих чертах понятно что может быть много подписчиков и может быть много поставщиков в одну и ту же очередь они могут динамически появляться динамически исчезать А и они могут быть многопоточными и в момент переключения То есть все-таки как ни крути момент переключения это не ноль Это какое-то количество миллисекунд и вот как система ведет себя в эти в это определенное количество миллисекунд чтобы последовательность сообщений не нарушить это очень такая сложная тема на которой нужно поить Отдельно Ну и поколение в базах данных а тоже такое непаханое поле Вот как то так подписывайтесь на этот самый ставьте лайки и этот парень будет следить за вами Всем спасибо Алексей спасибо большое было очень интересно я наверное буду продолжение ждать так же как и сериал Рик и морти Ребят давайте задавайте вопросы у кого есть давайте наверное начнем вот отсюда Здравствуйте спасибо большое за ваш доклад собственно вопрос про базу данных и откаты вы предупредили хорошо второй вопрос про соблюдение контрактов собственно разработчиками то есть одной стороны разработчик знать не должен с другой стороны он должен предоставить таблицу взаимодействия поколений это как работает таблица поколения она вычисляется автоматом разработчик всего лишь описывает для Messenger разработчик описывает этот самый таблицу подписок Какие микросервисы подписаны на какие очереди то есть разработчики таблицы поколений они ничего не знают то есть у разработчиков он протестировал Две версии microservice A и B у них есть версия контракта В1 потом говорит Теперь я хочу чтобы у меня микросервисе взаимодействия или по версии V2 вот он выкатил а версию API V2 понятно что есть политика депретейшен политика то есть нельзя сразу заменить API V1 и piv 2 они обычно сосуществуют Но если я выкатил какую-то фичу новую допустим новая скидка новая скидка введена В два микросервиса то есть меня нужно чтобы эта новая скидка отработала в первом отработала во втором Я просто выпускаю новую версию Application вот в новой версии Application У меня два микросервис новой версии они придут в систему система вычислит Ага вот эти два микросервиса новые и она вычислит она проставит их в таблицу поколений она оставит их в таблице маршрутизации ответил Нет давайте уточним вопрос про старое поколение то есть старые поколения взаимодействия то есть именно таблицы подписок Они уничтожаются они проверяются чтобы где-то не осталось версия 0 да конечно то есть они после этого последовательно вытесняют как только поколение реально вот может старое оно же побывала в продакшене она уже на пенсии посидела оно вытесняется на физически удаляется с сервера и оно физически удаляется со всех таблиц То есть все подписки исчезают то есть оно как бы перестаёт существовать не только Legacy исчезает ещё и версия подписки которая с ним пришла конечно ну конечно естественно исчезают я вот я вот видел молодой человек на первом ряду успел первый поднять руку но я вас всех тоже вижу Спасибо за доклад У меня вопрос такой вот то есть Первое Это не связано с самим сервисом взаимодействия и так далее он связан с карьере с организацией дипломмента то есть по сути дела получается такое распределенный Монолит Ну потому что по факту вы как бы делаете релиз трейн То есть это обязательно какая-то согласованная версия какого-то количества микросервисов вот в данном случае как бы это такой трейдов выбран специально То есть почему Например не катить точно также например по сервис на да то есть как классическая как бы микросервисном подходе когда сервис разработчик делает какой-то там есть бэкворт компотибилити-полисе какой-нибудь он его выкатывает продакшн тестируется там как-то тоже скорее чем дипломом там либо откатывается либо накатывается заново Вот почему спрашиваю потому что кажется чем больше как бы хотим Ну как бы говорили строение да то есть когда запихиваются фичи там большие требуют там какие скажем там параллельно большое количество сервисов тем как бы сложнее процедуры отката больнее становится как бы должен становится бы потому что рисков Что может пойти не так больше ну и в том числе например там откаты баз данных не Были рассмотрены но я так понял полагаю что в роллбеки вот ну по моей практике именно вот минимизация там изменений в базе там это один из таких больших там плюсов именно того что каждый микро сервис имеет свою базу его можно купить отдельно вне зависимости от других микросервисов Да спасибо за вопрос вообще как бы слово Монолит больше оскорбления наверное нельзя придумать для человека Сталкер и разговор между этим самым профессором и забыл короче Хорошо обидеть человека это тоже большое большое искусство между профессорами Вот так вот Действительно это такой как бы трейдов и это огромные были холевары у нас внутри по поводу того распределенный ли это Монолит не распределенный ли это Монолит на самом деле Вот я сейчас проводил рассказывал презентации про один Application вот один Application это не весь Production Application of у нас обычный штук 50 Поэтому вся вот это вот все что я рассказал ее нужно примерно помножить на 50 вопрекейшн входит микросервисов в среднем 79 и так далее То есть мы сделали такой трейдов потому что как ни крути не знаю может это особенность Телеком бизнеса но на здесь стабильность она поставлена во главу угла Это конечно не гражданская авиация но она поставлена угла Все вариативность нужно проверить все что может только быть оказаться на продакшене оно все должно быть Поэтому если мы будем тестировать выкатку каждого микросервиса у нас затраты на тестирование будет раз 50 больше чем затраты на девелопмент поэтому мы сделали такой трейдов вот мы с одной стороны поставили весь продакшн 200 микросервисов с другой стороны поставили один микросервис и вот построить такой график эффективности и поэтому графику эффективности мы сказали что выкатывать мы на самом деле будем Вот такими чанками по примерно 7 10 микросервисов они сто процентов протестированы у них сто процентов согласованы контракты и вот их мы будем двигать по таблице поколений но при этом может быть несколько на разные плите Что может быть могут быть разные фичи и там какой-то Application может уйти в Legacy какой-то является фичей то есть это как бы такой некая там на наш взгляд золотая середина между совсем там монолитом не стало будет помятым но и совсем там микросервис вот как-то так вот там далеко Господи как ты не любишь Монолит свет Спасибо огромное за доклад очень интересно действительно много ощутилось привычной более какой-то про база данных услышал может быть попрошу от вас просто маленький тизер там Костыль и озарение просто откатку в данном случае вот и второй вопрос это про кафку про Почему получается что вы немножко противоречие концепции что девелопер ничего там не делает не знает принципе про вот эти все схемы получается что стороны приложения разгребаете одну очередь Вот почему не используется допустим суффиксы какие-то топиком и так далее а да Значит действительно Я противоречит слегка Да но Тут нужно такой небольшой сделать такой лирическое отступление что вот у нас Мега сервисы они пишутся на базе sdk то есть у нас внутри компании есть свой платформенный sdk это платформа на sdk дает набор библиотек и вот это этот набор библиотек его вот наша команда дает платформенная то есть разработчик пишет прикладной код он действительно об этом не думает он получает библиотеку которая сортирует сообщение от нас почему мы не сделали несколько очередей на самом деле такой отчасти тизер следующей части потому что очень сложно в этом случае обеспечить последовательность правильную последовательность сообщений Потому что если у тебя есть две очереди и ты переключаешься с одной на другую У тебя есть хвостик сообщение которое нужно потребить и тебе нужно получается первое потребитель хвостик потом переключиться сюда Да это у тебя получится что немножечко голова забегает за хвост ты потребил более новые сообщения а потом потребляешь более старые сообщения То есть вот обеспечение правильности последовательности потребления сообщений это тема такая сложная И именно поэтому в кафке мы отказались мы естественно начали с этого мы попробовали сделать несколько очередей не пошло поняли что ну невозможно последовательность сообщений отработать вот по поводу тизера Ага по поводу баз данных как в том мультике попробуем по поводу секретного ингредиента на самом деле никакого секретного ингредиента нет отката нет потому что там могут образоваться бизнес-данные Если вы накатили новую версию вы сформировали какой-то новый формат формат базы и туда пошли бизнес данная это бизнес данные поэтому у вас есть два макро подхода макро подход номер один это восстановление из бэкапа извините но как бы Либо вы его делаете заранее потом резко переключаетесь Либо вы просто восстанавливаетесь из полного бэкапа второй макроподход называется Форвард кампатилити То есть когда вы выкатываете изменения в новой версии микросервиса вы должны гарантировать Что старая версия микросервиса будет работать с этим данным с этими данными как это делать но есть общие подходы не писать звездочку селектах и там не менять формат колонки а дублировать колонку то есть вообще паттерны общие Север Боль это здесь нет для баз данных вот такого изящного чтобы девелопер вот вообще ни о чем не думал Но нет для баз данных там база данных это будет уже четвертая серия по поводу кстати 4 серии Если вы не знали вот прекрасный босха на самом деле эти створки закрываются и там другая картина потому поэтому в нём на самом деле пять частей друзья у нас осталось времена один маленький вопросик Давайте вот очень давно хочет остальные Ничего страшного Мы его никуда не отпустим он останется в зоне для обсуждения Почему Спасибо за доклад отличный юмор подачи иллюстрации очень интересно слушать меня такой вопрос их два Ну и на них ответить можно очень быстро Значит один вопрос том что я как юзер так пошел к вам и мне нужно определить какое поколение Мне необходимо дать Как определяется это на каждый запрос либо это идет на определенное время и через какое время мне может длиться новая группа Да это у вас было смотрите отвечаю проблема с аналитикой как отыгрывают поколений если альянсен что кому-то из них там сейчас стал очень плохо если автоматически отключение поколения этих чтобы мы не делали этого вручную так да значит первая часть откуда берется поколение значит вариант номер один его просто проставляют просто вот берешь плагин браузер и проставляешь поколение этим обычно пользуются Вот тестировщики люди которые знают что делают вторая вторая второй способ это поколение каким-то образом оно проставляется для конкретного человека то есть есть айденте провайдер воеденте провайдеры просто проставляется атрибут что вот этот человек тестировщик там это человек фокус-группа то есть у нас обычно вот есть фокус-группа на фокус-группах она вот все проходит и включается фокус-группу у него в животе токене приходит атрибут гейтвей наш он видит этот атрибут и он говорит о фокус-группа значит поколение кандидата то есть Оно просто статическое определение поколения на каждый запрос на каждый запрос сохранится на каждый вопрос Да еще нет она не то что на каждый запрос поколение у нас проставляется в щедр поэтому по сути она проставляется один раз на веб-сессию понял после этого она уже просто федере там туда-сюда мотается А какой из-за этого у вас идет для того чтобы всю ту механику которая с поколениями идет обеспечить то есть какая за это идет стоимость стоимость по сути Здесь идет нулевая потому что вот как бы паттер паттер вот этот вот чудесный паттерн транспорта то есть основа этого паттерна то есть микросервисе в любом случае взаимодействие сервис никто не отменял суть поколений в том что таблица статически проливается в каждый транспорт она может быть Вот такенной но там таблица поколения на она как бы есть всегда в сервис мешает таблица таблица маршрутизации в кафке в ребите в ребети вернее это просто статический байндинги то есть раунд трипа куда-то о том Ой у меня поколение А куда нужно идти его нет то есть мы все вычисляем статические Вот пришло поколение там происходит вся эта математика вычисляются таблицы они проливаются вниз на систему то есть Control Plane Data Plane Data Planet статика Control plain динамика всё пролили статически всё связалось и всё начинаете ехать"
}