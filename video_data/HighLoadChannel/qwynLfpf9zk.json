{
  "video_id": "qwynLfpf9zk",
  "channel": "HighLoadChannel",
  "title": "О чём я говорю, когда говорю о тестировании корректности работы компилятора / Сергей Бронников",
  "views": 619,
  "duration": 2514,
  "published": "2023-10-06T07:14:46-07:00",
  "text": "Спасибо что пришли на мой доклад Меня зовут Сергей и я вам сегодня Попробую рассказать о том как тестируют компиляторы план моего доклада следующий я сначала расскажу небольшое введение где подведу расскажу о тех проблемах с которыми мы столкнулись и которые мы решаем теми способами о которых расскажу в докладе а есть Я буду рассказывать про разные подходы которые мы попробовали и в плане я пометил все эти подходы звездочками чтобы можно было оценить сложность каждого подхода последний подход он кажется наиболее сложный но на мой взгляд он наиболее интересный поехали Все началось с базы данных Тарантул над которой мы работаем это платформа для вычислений и что важно для нашего доклада это то что бизнес логика вторым то ли описывается с помощью языка и в качестве runtime для языкового мы используем собственный форк Что такое ложит ложит Это среда исполнения версии 5.1 ложит также включает себя трассирующий жидкомпилятор и что еще важно то что ложит работает гораздо быстрее чем другие реализации лоа Если сравнивать по производительности с другими реализациями лоа то мультипликаторы примерно следующие Это от 2 до 4 раз без жидкомпиляции и от двух до 100 раз со включенной жидкомпиляции тут Нужно отметить что мультипликатор 100 получается далеко не всегда а только в случае использования математики или синтетики а Кот ложит открыт под свободной лицензии mit немножко про пользователей уважит на самом деле ложит это достаточно такая нишевая технология но тем не менее она используется в продуктах крупных компаний Это телекомы агрегаторы рекламных сетей базы данных антифрот и даже текстовый редактор как например не увидим теперь проблемам а на самом деле уважит это очень хорошая технология Но это достаточно сложная технология и она требует очень аккуратного дотошного тестирования и вот с этим есть некоторые проблемы одна из проблем заключается в том что оажита нет собственного набора тестов вторая проблема заключается в том что автор ложита основной автор Майк пол добавляя новые изменения вложить не прикладывает к этим изменениям тесты которые покрывают эти изменения и третья проблема заключается в том что несмотря на наши усилия по тестированию Тарантула и форколажита Несмотря на все это мы к нам иногда с эксплуатации приходят неприятные баги вложите вот один из примеров такого Бага в Лоо есть функция которая называется to Number она конвертирует строку в число и если мы сконвертируем вот эту строку в число то получим -0 если мы сконвертируем эту строку то получим 0 уже без знака что некорректно этот баг был заведен в бактерии ложета на что мои пол ответил спасибо Я исправил Спустя год спустя два года появляется тот же самый бак если мы конвертируем минус 0 то мы получаем 0 Make Pro отвечает Спасибо я опять исправил еще один пример Бага у него чуть более сложные репродюсеры Можете даже не вчитываться в код Я просто прокомментирую если у нас производится какая-то манипуляция над строками Да в частности поиск по строки в строке то в какой-то момент ложит возвращает неправильную позицию Начало этой строки в строке этот бак был тоже исправлен Мы очень много сил в тарантуле прикладываем к тестированию ложета чтобы как можно меньше багов попадала в публичные версии Тарантула это и регрессионные тесты из-за референсной реализации Это testud лоахарнес от Франсуа пера это наши собственные тесты для ложит который мы сами разрабатываем мы регулярно весь набор регрессивных тестов запускаем на новых изменениях и учитывая все Вот наши усилия у нас покрытие кода примерно 78 процентов настройки и 67 процентов для веток не то что очень большие результаты Но на самом деле за всем этим стоит большая работа еще чтобы как-то зарегистрировать тестирование стандартное тестирование Я хотел бы обратить Ваше внимание на такой доклад который сделал Антон солдатов в 2018 году на хэллоуиде он очень системный рассказал о том как они тестируют свой форт в компании Apple в общем советую вам просмотру Если вы интересуетесь Темой из всего этого я могу сделать вывод что стандартного тестирования недостаточно И если мы попробуем рассмотреть стандартные подходы к тестированию вообще систем и ложит в частности то я бы их поделил на два все тесты на две категории первая категории это тесты на основе примеров это так называемый замкл БСТ Это можно сказать тестирование известного мы заранее каждый раз знаем Какие данные будут переданы в программу мы заранее знаем что ожидать от программы если мы передадим конкретные данные если вам знаком паттерн Range эктосерт то это тесты как раз которые используют этот паттерн все тесты для ложета написаны как раз с использованием такого подхода вторая категория тестов это рандомизированное тестирование это так скажем тестирование неизвестного когда мы заранее не знаем Какие данные попадут в программу этот подход идеально подходит для тестирования компиляторов дальше я в ходе доклада проиллюстрирую это есть некоторые научные работы дальше я подробнее пора это расскажу которые описывают рандомизированное тестирование для референции реализации о но к сожалению особенно на успеха они в этом не достигли и есть файзер для референсной реализации лоа который тоже не сказать что очень много багов нашел далее своим докладе Я буду рассказывать конкретно про рандомизированное тестирование если говорить про файзинг и попробовать писать небольшую упрощенной схемы то выглядит все примерно так у нас есть генератор входных данных которые каждый раз генерирует новые данные далее мы Передаем их в программу потом проверяем выполнение некоторых вариантов для этой программы и в случае если инварианты нарушаются то скорее всего был найден какой-то баг если более детально смотреть на схему то все выглядит следующим образом у нас есть словарь это список ключевых слов которые могут иметь специальное значение для программы у нас есть корпус который обычно составляется из входных данных при передаче которые в программу программа будет вести себя корректно все это мы Передаем мутационный движок который на каждой итерации мутирует данные далее мы все это Передаем в программу анализируем результаты проверяем Передаем обратную связь обратно в мутационный движок проверяем что у нас выполняются инварианты то есть мы используем так называемые тестовые оракулы которые позволяют нам понять программы ведет себя корректно или некорректно в качестве тестовых оракулов мы можем использовать какие-то сторонние инструменты как например СМТ решатель да санитайзеры Или какие-то логические проверки и в результате всех этих манипуляций Мы в какой-то момент должны найти баги немножко по результата исследования которые я нашел по этой теме все они касаются именно референсной реализации то есть каких-то научных исследований для анализированного тестирования к сожалению не нашел все вот эти три работы Они пытались тестировать референсную реализацию и только в Первый из них был найден один минорный бак который заключался в том что неправильно приводились Неправильно приводился тип у каких-то данных теперь рассмотрим те подходы про которые я хочу вам рассказать первый подход заключается в том что мы будем использовать неструктурированный файтинг В чем заключается принцип этого подхода У нас есть входные данные это может быть например текст из корпуса или случайные байты у нас мутационный движок мутирует данные на уровне байтов То есть он может быть вставить случайные байты или удалить какие-то и в таком виде Он каждый раз мутирует данные У нас есть тестовый оракула которая как раз будет проверять корректно ведет себя программа не происходит ли каких-то аномалий и в качестве тестовых оракулов мы можем использовать как санитайзеры это Одесса не тойзер и другие мы можем измерять потребление памяти чтобы отслеживать какие-то аномалии при работе с памятью например утечки памяти мы можем измерять время чтобы отслеживать зацикливание в программах или какие-то проблемы с производительностью если рассмотреть популярные файзинг движки то сейчас самый популярным является вот три инструмента первый это FL + Plus Fork популярного файзера American fuzzylop второе это фас И третье или Фазер в своем докладе я буду в основном говорить про Лев файзер потому что именно эту библиотеку мы используем для фазинг тестирования что мы сделали для того чтобы реализовать это подход делал уже там мы написали файзер с помощью библиотеки или файзер и луасиапиай далее составили Корпус из который состоял из регрессионных тестов для ложета и составили словарь на основе грамматики Опять один к слову точно такой же подход используется для тестирования референсной реализации по креолу про который я говорил раньше вот как выглядит Премьер тех входных данных которым можем получить из этого фазера то есть файзер сгенерировал нам Файлик с набором байт если передать вот этот Файлик вложить то ложит который может принимать как лук от так и байт-код не может разобрать входные данные и на этом он завершает свое выполнение И падает такой бак был уже заведен бактерии и автор лажита закрыл его Как неприемлемый из этого можно сделать вывод что такие баги нам не сильно интересны и лучше их избегать для того чтобы их избегать можно использовать опцию он яски которые позволяют использовать только символы во время мутаций вот так выглядит пример случайной программы которая получается в ходе нескольких последовательных мутаций то есть Это вроде еще программа влажная Ну она структуру свою потеряла и возможно уже синтаксический некорректная теперь о плюсах и минусах этого подхода абсолютный плюс этого подхода заключается в том что достаточно дешево можно этот Фазер реализовать буквально в течение получаса или часа можно достичь достаточно высокого покрытия если мы аккуратно составили словарь и корпус для нашего фазера еще один из плюсов заключается в том что из-за того что у нас каждый раз с большой вероятностью будут получаться некорректные с точки зрения синтаксиса программы то мы очень хорошо негативно протестируем наш синтаксический анализатор ещё один плюс заключается в том что из-за своей простоты файтинг файзер может достигать очень высокой скорости тестирования у меня это было 261 тысяча запусков в секунду и один из минусов заключается в том что мы не можем с помощью вот этого подхода достаточно глубоко погрузиться в ложит То есть например триггерить работу компилятора поэтому мы перейдем к следующему подходу он называется синтаксический файтинг и смысл его заключается в следующем У нас есть входные данные и в качестве выходных данных мы используем входные данные из корпуса или случайно синтаксическое дерево далее мы используем мутации по грамматике Это позволяет нам генерировать такие входные данные которые будут соответствовать синтаксису ло и в качестве тестовых оракулов мы используем все те же Tesla Как из предыдущего подхода немножко про успешные реализация которая использует такой подход это файзер на самом деле очень популярный сейсмит который активно используется для тестирования хищных компиляторов в основном это jcc и seland из проекта лвм с помощью такого фазера был найден около 300 проблем реальных проблем чистных компилятор и очень похожи по дизайну это файзер с помощью которого тоже получилось найти около 200 разных проблем Что нужно сделать чтобы реализовать такой подход делала уже там мы взяли лифазер и лоси API добавили в него библиотеку липортабов мутатор которая позволяет описать структуру тех данных которые мы переходим передавать программу формате протобов вот мы описали грамматику Опять один в формате протобув написали те реализатор который принимает на вход в структуру протобов и стерилизует ее в конкретную программу в качестве примера проиллюстрирую структуру протопов которые мы получили в ходе тестирования не надо в это вчитываться а вот из такой структуры протобов мы можем сгенерировать вот такую случайную программу немножко про нюансы стерилизатора протобов которые нужно иметь ввиду в ходе реализации первый заключается в том что нужно учитывать семантику языка Потому что Грамматика позволяет нам учитывать только синтаксис но нужно учитывать семантику чтобы так скажем глубже забраться вложить и не дать ему отсеять входные данные на этапе анализа программы вот одни из проблем с которым мы столкнулись у нас начали появляться арифметические проблемы над строками или арифметические операции над таблицами Или например начали появляться не существующие методы которые мы пытались вызывать ещё один нюанс который нужно учитывать это зацикливание в программах то есть во время стерилизации нужно учитывать эти моменты чтобы у нас не получилось рекурсивных вызовов функций или бесконечных циклов или циклов с большим количеством итераций теперь о плюсах и минусах этого подхода это в противоположность предыдущим подходу позитивное тестирование синтаксического анализатора потому что большинстве случаев мы будем тестировать корректные с точки зрения синтаксиса программы это гораздо большее разнообразие синтаксических корректных программ Но с другой стороны это затратно по времени реализации мы реализовали такой файзер силами одного студента примерно за один месяц его работы в летней школе тарантул и один из минусов заключается в том что у лепробов мутатор достаточно примитивные мутации используются Поэтому если хочется что-то сложнее использовать то придется это реализовать самостоятельно перейдем к следующему подходу это семантический файтинг и принцип его заключает следующим если мы попробуем сравнить синтаксические мутации семантическими то если упрощенно объяснять то синтаксические мутации А не мутирует то как вот вы выглядит семантический мутации меняют то что именно код делает первая публикация по этой теме была 2014 году и содержит на себя около 4 сотен ссылок принцип этого подходит заключается следующем У нас есть входные данные в качестве которых выступают случайные синтаксические корректные программы мутатор изменяет программу без изменения семантики программы в качестве тестового оракула у нас выступают уже знакомые нам санитайзеры Мы измеряем потребление памяти время выполнения и дополнительно ко всем этим тестам оракулам мы можем использовать динамические проверки из корпуса немножко про успешной реализации вот самая наверное любимая это реализация файзера который один студент в качестве дипломные работы реализовал для живота скрипта с помощью него был найден большое количество багов и два других примера тоже использовали файтинг для живых скрипта что мы сделали чтобы реализовать этот подход для ложе там Мы также взяли лифазер который позволяет интегрировать в свой движок кастомный мутаторы мы интегрировали функцию для реализации кастомных мутаций с языком lua и использовали специальный модуль который принимает на вход программу далее преобразует синтаксическое дерево накладывает какие-то случайные мутации по синтаксическому дереву и стерилизует и обратно в как могут выглядеть примеры мутаций к примеру У нас есть логическое выражение для этого логического выражения мы можем добавить двойное отрицание которое вроде бы как изменит программу Но с другой стороны семантику ее не поменяет мы можем для какого-то случайного выражения в программе обернуть ее функцию которая будет возвращать результат выполнения этого выражения или мы можем например обернуть случайное выражение цикл с одной итерацией которая будет вычислять это выражение или как вариант мы можем случайное место программы вставить функцию которая запускает сборку мусора независимо от того В какой момент времени мы бы вызвали сборку мусора программа должна себя вести корректно немножко о плюсах и минусах такой подход позволяет еще больше разнообразить входные данные которые мы Передаем вложить с помощью этого подхода Можно более фокусно тестировать то есть мы можем использовать именно такие мутации которые будут мутировать нужные нам части программы а этот подход позволяет использовать логические проверки из корпуса что еще более усложняет тестовая оракула что играет там только на пользу нужно иметь ввиду что компилятор он штука штука достаточно хитрая и некоторые вещи в программе он может оптимизировать к примеру он может некоторое выражение не вычислять если он понимает что условия уже не срабатывает или наоборот срабатывает и еще один из минусов который отметил он заключается в том что с таким подходом очень существенно снижается скорость фазинга у меня получилось примерно 500 запусков в секунду перейдем к следующему подходу Я обозвал его сравнить или фадинг первая публикация по этой теме была в 98 году и содержит на себя уже порядка 500 ссылок В чем заключается принцип у нас есть генератор со случайными систематически корректными программами и в качестве тестового оракула у нас выступает другая или более простая реализация такой же программы рассмотрим это на схеме вот наш есть генератор случайных программ который генерирует нам Случайный локкот этот ход мы Передаем в три разные программы в первом случае это уложит с выключенными включенными оптимизациями во втором случае ложится с выключенными оптимизациями и в третьем случае это референсная реализация далее мы запускаем эти программы в трех во всех трех случаях получаем результаты и пытаемся результаты выполнения сравнить Если где-то результат у нас расходятся то это выглядит Какая какая-то Аномалия и возможно в одной из реализации есть баг про успешные реализации одна из свежих статей описывает файзер для языка JavaScript с помощью которого был найден 32 Бага этот файзер использует сравнительное тестирование еще один пример не из области компиляторов он используется для проверки библиотек криптографической библиотек Он позволяет сравнивать криптографические примитивы с помощью сравнительного тестирования и с помощью такого подхода был найдено 160 багов что я считаю достаточно хорошим результатом это escolancer не буду на этом останавливаться подробнее проект неже это на самом деле не конкретный проект по тестированию какой-то одной программы это движок для сравнительного тестирования и проект Deep Explorer который позволяет с помощью сравнительного тестирования сравнивать модели машинного обучения что мы сделали чтобы реализовать этот подход для ложета Мы также использовали эквалайзер и лоси Далее в качестве тестовых оракулов мы использовали референцию реализацию ложится выключенной оптимизациями санитайзеры знакомые нам потребление памяти и время выполнения плюсы и минусы этого подхода один из плюсов это достаточно простота реализации теста еще один из плюсов заключается в том что можем найти детали проблема в деталях реализации за счет того что разные реализации программы были разработаны абсолютно разными группами разработчиков и одни могли более аккуратно подойти к реализации программы как например в случае референции реализации а в другом случае уже не так аккуратно а подход сравнительного тестирования не всегда применим то есть например если у вас используется достаточно редкий язык да и компилятор для него и нет другого похожего компилятора или интерпретатора который реализует этот язык тогда он сравниваться не с чем и приходится использовать другие подходы и еще один минус который бы хотел отметить это ложный положительный срабатывание когда мы сравнили результаты одна программа ведет выдает вроде бы неправильный результат но мы повлияет на это не можем Да например разработчики не считают это багом и нам придется эта программа скорее всего выкинуть из списка программ с которыми Мы хотим сравниваться и наконец мой любимый подход это тестирование оптимизации В чем заключается его принцип у нас есть входные данные это которые мы получаем с помощью генератора семантически корректных программ мы во время выполнения программы экспортируем байт-код и промежуточное представление этой программы в случае с включенными оптимизациями и в случае запуска компилятора без оптимизации далее Мы берем этот байт-код и промежуточное представление и транслируем его логические формулы а дальше Мы берем первую форму и вторую и с помощью SMT решателя сравним эти две формулы и проверяем их эквивалентность то есть какие бы оптимизации мы не наложили на программу Да корректность выполнения этой программы не должна измениться в качестве тестовых оракулов мы сделали используем здесь знакомые нам уже санитайзеры время выполнения потребления памяти и смещатель про который я уже немножко рассказал на самом деле я не нашел статью которая полно описывает этот подход Ну вот статья Мне кажется может претендовать на первенство потому что она описывает достаточно близкие идеи такой подход широко используется для тестирования компиляторов один из успешных проектов это проекты Life и Life 2 которые используются для тестирования компилятора силанк из проекта лвм с помощью него был найдено Порядка 70 багов тут я хотел бы отметить что авторы которые реализовали сейсмит файзер про который я уже рассказывал они нашли большое количество багов а потом они заметили что большое количество багов которые они нашли находится в одной конкретной оптимизации она называется инстакомбайн и далее они попробовали найти способ с которым они могли бы более фокусно тестировать конкретные эту оптимизацию и вот из этой идеи родился проект который потом трансформировался в Life 2 такой же похожий проект есть для GTC у него не такие масштабы его реализует всего один человек и был найден только один бак я про него попозже расскажу а идея такого же фазинга есть для жидкомпилятора поэтому для компилятора языка описания контрата контрактов солидете и проекта который позволяет проверить корректность языка запросов и сказали запросов до и после оптимизации вот один из примеров Бага который был найден в gcc тут Важно отметить что на момент подготовки презентации этот баг все еще не был исправлен он находится в открытом состоянии бакте GTC в чем он заключается если у нас программа содержит такую функцию которая Принимает два числа далее мы над этими числами проводим битвы операции и если мы попробуем запустить эту программу и передавать ей на вход разные числа то в первый дух случаях программа будет вести корректно и будет выдавать корректный результат А вот в третьем случае результат будет некорректным что мы сделали чтобы реализовать этот подход для ложета мы использовали уложить с выключенными оптимизациями и скручены оптимизациями на максимальном уровне оптимизации далее транслировали промежуточные представления конвертировали в обоих случаях в СМТ формулу и передали все это на вход smt-решателю в нашем случае это был Z3 Хотя он не единственный smt-решатель а немножко расскажу о том в каком месте вложить являются оптимизации на вход LG Принимает два вида входных данных это ua программа или байтпод все это передается в лексические анализатор а синтаксический анализатор далее поступает в bitcoint интерпретатор и вот вся вот эта вот штуковина называется виртуальной машины если мы обнаруживаем горячие участки кода то мы начинаем запись трассы далее мы проводим оптимизации промежуточного представления и транслируем уже в ассемблер для исполнения вот эта часть называется жидкомпилятором вот в местах где начинают работать байт-код фронтенд и бюдкомпиляторе у нас как раз случается оптимизация есть еще несущественные части вложите в нашем случае это встроенная библиотеки нам больше всего интересно библиотека которая позволяет влиять на настройки компиляции сейчас подробнее расскажу это встроенная библиотека позволяет включать оптимизации включать их полностью или более точечно более фокусно влиять на оптимизация которая делает компилятор например мы можем выбрать один конкретный уровень оптимизации можем выключить оптимизацию в качестве примера которая выкидывает мертвый кот можем сделать компиляцию Боря агрессивной и компиляция будет начинать срабатывать даже если цикл содержит одну итерацию чтобы Чуть более подробно объяснить что такое СМТ решатель я выписал определение из Вики не уверен что она будет вам очень понятным поэтому я проиллюстрирую это на примере вот есть такая Задачка Да наверное многие из вас с ними сталкивались нужно найти значение треугольничка для того чтобы все эти уравнения выполнялись чтобы решить этот набор уравнений мы будем использовать интерфейс и поэтому к нашему SMT решателю Мы в виде скрипта опишем наш набор уравнений и попробуем запустить Это скрипт СМТ решатель скажет что решение найдено об этом говорит слово сад и даже нам скажет При каких именно значениях этот набор уравнений будет выполняться плюсы и минусы этого подхода определенный плюс в том что он математически строгий ещё один плюс заключается в том что если мы знаем что какая-то за оптимизация у нас наиболее важная то мы можем более фокусно тестировать конкретно эту оптимизацию еще один плюс И один из минусов заключается в том что во время трансляции промежуточного представления логическую формула нам нужно делать это максимально аккуратно чтобы соблюсти семантику и О выводах я могу резюмировать что фазинг это достаточно сложная область потому что нужно учитывать и знать большое количество деталей файтинг может очень хорошо дополнять стандартные тесты А В некоторых случаях как например в последнем подходе и даже заменять и я хотел бы отметить что файтинг это абсолютная автоматически позволяет выполнять полностью автоматическое тестирование то есть без участия человека человек нужно в основном во время анализа результатов и то вот эту стадию тоже можно частично автоматизировать Спасибо за ваше внимание буду рад выслушать ваши вопросы Серёжа Спасибо тебе большое друзья во-первых я хочу для наших уважаемых онлайн зрителей напомнить что у нас есть чат зала его можно найти по названию по идентификатору и через 20-22 подчеркивание H4 и в этом чате можно и нужно задавать свои вопросы а вообще у нас есть традиции на конференции Мы за вопросы за самые лучшие вопросы которые выберет наш спикер уважаемый дарим подарки и спикер тоже дарит подарки и даже если у нас будет Вопрос из онлайна мы найдем тебя Уважаемый участник конференции который задает вопрос онлайн и подарок тебе настигнет собственно друзья предлагаю вопросы ну Привет Спасибо за доклад мне хотелось вернуться Когда у вас компилятор упал на некорректных бинарных данных вопрос почему автор языка считает это ну неправильным тестом это же ведь может быть ошибка безопасности если он по-моему там скором свалился там такая история когда завели вот этот баг мой пол посмотрел на этот баг потом пошел в документацию к ложиту у него там есть список часто задаваемых вопросов положит ум добавил туда запись что недоверенный байт-код не надо передавать ложит потому что он может упасть а потом закрыл бак сославшись на вот эту Вот запись в документации то есть в том что ну он не считает нужным проверять эти данные были переданы так скажем оформит байт-код данные поэтому получается эти данные нужно отсекать до того как вы их подаете в компилятор Да Нам нужно каким-то образом избегать вот этой проблемы во время файтинга или не вообще не Используйте подход вот я обошел это с помощью специальной опции для альфайзеры Угу спасибо удобно когда ты Господь и Бог своей технологии Правда же документацию поправил так делать не надо Все отлично друзья Сереж А Я знаю точно знаю что у тебя есть секрет который ты как бы заранее приготовил и который потом наши слушатели наши Уважаемые участники могут использовать Он же у тебя есть правда ты думаешь мы можем уже показать Ну почему бы нет У меня есть набор слайдов которые я отложил на потом и если у нас осталось время то я могу их продемонстрировать это Я подготовил список багов которые мы нашли с помощью во время тестирования первый баг про первый бак Я уже рассказывал это как раз который заключается в том что если мы Передаем Просто набор байтов то ложит падает второй заключается в том что мы не первые были которые нашли с помощью файзинга этот баг То есть он существовал и было известен заранее но с помощью файзинга мы нашли еще один репродюсер который приводил к этому БАГУ и еще один бак который как раз Недавно мы оформили в бактерии ложит Вот пока авторы никак не отреагировал наш разработчик даже приложил возможный фикс для этого Бага но пока никакой реакции не последовало и Я хотел бы еще проиллюстрировать последний подход который я про который рассказывал это подход СНТ решателями Как можно случае ложета от транслировать промежуточное представление и проверить эквивалентность форму с помощью smt-решателя вот есть у нас программа НЛО она достаточно примитивная она нужна нам только для иллюстрации подхода У нас есть функция которая называется helload в этой функции что примечательным у нас есть переменная Bad и в цикле Мы каждый раз этой переменной присыпаем одно и то же значение мы экспортируем промежуточное предоставление изложита для этой программе в случае когда у нас выключены полностью оптимизации это опция о 0 и во втором случае с включенными с максимальным уровнем оптимизации О3 мы получаем вот такой вывод и во втором случае мы получаем вот такой вот вывод слой для случая с включенной оптимизацией я наверное не буду комментировать вот этот вывод чтобы нам не вдаваться так скажем в детали и мы попробуем сразу транслировать полученный промежуточное представление формула если мы будем транслировать под логическую формулу тот есть три главных правила Первое у нас код должен быть в форме СССР это сингл кстати касаемо Это форма которую использует компиляторы то есть код программы перед тем как выполнять они переводят вот в эту форму то есть Первое это ssa Форма то промежуточное представление которое мы получили из компилятора она уже в форме ssr нам делать ничего не нужно второе это встраивание функций То есть как выглядит программа Да повторяющие участки кода мы пытаемся оформить функции с тем чтобы не дублировать код вот когда мы транслируем код программы логическую форму нам нужно развернуть все эти функции и вместо вызова функций вставить их тело и Третье правило это раскручивание циклов тут есть нюансы потому что мы раскручивать циклы можем до определенных до определенного количества итераций то есть примеру в нашем примере было три итерации в цикле да три это на самом деле магическое число потому что именно на третьей итерации начинается запись трассы и начинает работать компилятор раскручивание циклов это становление цикла n раз то есть не обязательно количество итераций тому количеству на которое мы решили раскрутить цикл и мы получаем вот такую вот такой вот код который описан в формате smtlip которые понимают наибольшее количество СМТ решателей мы объявляем две переменные разворачиваем цикл и во втором случае когда у нас выключена оптимизация вернее включена оптимизация получается такой вывод и далее мы Передаем это SMT solder проверяем что в первом и втором случае у нас результаты в которых результаты которые у нас лежат в переменных Б3 и B2 должны быть одинаковыми мы Передаем этот код в СМТ solver в СНТ соловера говорят сад из чего можем сделать вывод что формула эквивалента Слушай ну прям это мини доклад со звездочкой повышенной сложности отлично друзья Ваши аплодисменты Я думаю что так как у нас один из одного то тот прекрасный человек то сумел задать вопрос достаточно сложному докладу и получает наши прекрасные подарочки Сереж тебе спасибо за отличную разминку для ума Мы тебя благодарим от лица программного конференции от программного комитета от лица конференции тебе тоже наш маленький памятный приз Спасибо друзья Спасибо большое встречаемся в этом зале на следующем докладе Через 18 минут спасибо"
}