{
  "video_id": "PTr2xHr7nug",
  "channel": "HighLoadChannel",
  "title": "Эволюция и мифы CQRS / Андрей Цветцих (Тинькофф)",
  "views": 1205,
  "duration": 2925,
  "published": "2024-10-29T02:56:29-07:00",
  "text": "Андрей цвет СХ из команды теньков который нам сегодня расскажет про эволюцию и мифы cqrs Встречайте под Ваши аплодисменты Да привет Спасибо за представление Меня зовут Андрей я работаю в теньков бизнес где мы делаем сервисы для предпринимателей ишни и так далее а говорить мы сегодня будем про secs вот мы поговорим про что это подход что это такое дальше посмотрим развитие на уровне кода на уровне архитектуры на уровне хранилищ и поговорим про мифы пожалуй моя любимая часть потому что мифов вокруг очень много Итак поехали У меня есть чуть больше 30 минут чтобы доказать вам следующее c это просто secs подходит для любого стека примеры кода будут на си шарпе но я думаю вы поймёте сможете это применить на своей работе да решает широкий спектр проблем и sec подходит для любой предметной области Вы можете писать страхование не знаю медицину ВС что угодно sec вам подойдёт это как раз тот инструмент который сейчас применяется недостаточно широко и поэтому я перед вами стою и рассказываю я надеюсь что после этого рассказа вы начнёте применять его в своих проектах хорошо что такое вообще cqs это термин ввёл г по определению просто это commy responsibility segregation то есть разделение ответственности между некими командами и quy так давайте разбираться что это такое команда и quy Ну достаточно просто То есть quy - это то что читает данные команд - то что меняют данные мы говорим говорить про Web про backend соответственно то что читает данные - это Get запросы и всё остальное Post Put Delete pch Это всё что меняет данные на бэнде вот и всё хорошо какую проблему мы вообще решаем так вот CS - это паттерн который решает проблемы с чтением по крайней мере изначально он был именно так описан то есть у нас есть приложения которые много пишут и много читают но часто нагрузка смещена в какую-то одну область и чаще это больше чтения например мы любим котиков мы любим читать новости про котиков мы любим смотреть Весёлые картинки про котиков А ещё больше весёлые видео при этом новости картинки статьи видосы загружаются один раз а потом миллион раз просматриваются и вот как раз sec - это паттерн Который изначально был описан для того чтобы решить вот эту проблему с неоднородностью что один раз Мы что-то записали и потом много-много много раз разные пользователи это читают хорошо О ЧМ мы сегодня план доклада мы поговорим про подход на уровне кода дальше посмотрим Поможет ли и как именно подходи этот подход поможет при росте нагрузки на ваш сервис дальше посмотрим на то как этот подход работает на уровне архитектуры вашего приложения и разделения хранилищ и наконец моё любимое опять же разберём мифы потому что мифов вокруг этого подхода очень много поехали эволюция кода так здесь мы рассмотрим простой вариант как обрабатывается Запрос к вашему Кэн То есть у вас приходит какой-то Get запрос либо пост запрос он попадает в endpoint контроллера из контроллера вызывается некоторый Application сес Application се ну какой-нибудь Order сес он через модель читает данные из базы вот прочитали данные что-то с ними сделали обработали записали в базу вернули результат вот такой очень простой Фло хорошо Каким образом вот этот Application уровень будет реализован есть два популярных варианта Первый назовём его горизонтальный классический это на уровне сервисов когда для каждого для каждой сущности вашей предметной области создаётся отдельный класс сервис и он обрабатывает все запросы связаные с ним Ну например рр сервис обрабатывает все запросы с заказами payment с платежами юзер про пользователя там не знаю продукт про товар и так далее хорошо и вертикальный также он известен как handler также как подход основный накал слайса это когда под каждую бизнес операцию мы создаём отдельный обработчик для этой бизнес операции Давайте смотреть ещё раз подробнее Так что такое горизонтальный способ То есть когда у вас на каждую сущность создаётся свой класс свой сервис например орр сервис и каждый публичный метод этого сервиса - это какая-то бизнес операция например создание заказа например получение списка заказов текущего пользователя и так далее хорошо Каким образом это будет реализовано то есть у вас будет некий компонент у которого будут сервисы внутри сервиса будут все операции связаны с с этой сущностью То есть у вас будет Order US prod и так далее и они все будут находиться в одном компоненте Application Services хорошо вертикальный подход здесь подразумевается что для каждой бизнес операции мы создам пару это класс quy либо команда и соответствующий обработчик в обработчике будет всего один метод handle обработает данные команду либо данные quy при этом все Леры независимые друг про друга Они ничего не знают а при этом структура папок у вас будет более сложная так надеюсь тут хорошо видно да а то есть на Верхнем уровне у вас будет агрегат сущность заказ потом команды и на каждую бизнес операцию у вас будет там Папочка в папочке как раз команда и хендлер и обработчик и quy соответственно тоже а Папочка на каждую бизнес операцию Там тоже будет quy и quy handler Также будут общие какие-то папки с д Тошка утилитами и так далее но это уже не столь важно Хорошо как перети классического варианта xqs V1 Нам просто надо взять и распилить Application сес при этом для каждого публичного метода для каждой бизнес операции мы создаём пару команда либо quy и соответствующий обработчик handler при этом бо мы ничего не меняем на уровне хранилища то есть мы работаем с той же базой данных с теми же самыми моделями и так далее хорошо Ещё раз взяли наш сервис и распилили каждый публичный метод каждую бизнес операцию на пару команда и Hand либо quy handler вот и всё и уже в этом самом простом случае мы получим много преимуществ во-первых Независимый хендлер будет проще поддерживать у независимых хендлеров будет меньше зависимости в Конструктор прокиды и более интересный это когда такой подход разделение бизнес операций на независимые обработчики он визуализировать связи между самими бизнес и можно будет добавлять общую логику на все запросы сразу нуно Давайте по порядку Итак хелес проще поддерживать Ну тут на самом деле всё очень просто самый большой хендлер который я писал около 500 строк кода обычно сильно меньше а для бизнесов по обработке заказов там сотни тысячи строк кода - это норма соответственно вот поддерживать такие сервисы тяжело а маленькие независимые хендлера проще то есть их проще подход плюсы получить от подхода не на этапе написания А на этапе поддержки Почему ещё Потому что если ус большой сервис операции будут при этом у них есть общая Логика валидации есть какая-то логика которую нужно выполнить после создания заказа после обновления заказа и вот внутри большого сервиса вся эта логика может быть перемешай хендлера ничего такого нету вся логика которая относится к одной бизнес операции находится в одном месте дальше влер меньше зависимостей Ну тут тоже всё просто То есть у нас в сервис приходят Все зависимости которые нужны для всех бизнес операций их может быть много а в Лере ВС очень просто он получает только которые нужны ему Поэтому больше пяти зависимостей в хендлер редкость а для сервиса 10 и больше это норма Вот пример сервиса тут можно не всматриваться какие именно зависимости их просто много Ну прям 1011 там вот после рефакторинга После перехода на хендлер мы получили всего три зависимости то есть ничего лишнего мы не получаем переходим к более интересным вещам Итак зависимости между операциями становятся явными об этом почему-то никогда не говорят когда говорят прику на уровне кода Говорят вы сейчас возьмёте распилить ваш бизнесов сервис и всё у вас будет отлично не совсем так а и более того вот в секу среде есть такой Спор можно ли вызывать одну команду из обработчика другого То есть можно вызвать одну бизнес операцию из другой А в случаи с сервисами такого спора нет вот и в общем случае у нас же бывает когда между двумя бизнес операциями какая-то общая логика и мы её хотим переиспользовать Вот давайте разбираться как это делать А в случае сервисов как одна бизнес операция может вызываться из другой Ну вот пер мето Del и он вызывает другой метод Delete by ID А здесь одна бизнес операция вызывает другую то есть Delete by ID - это тоже бизнес операция плохо это или нет ну не всегда плохо Вот мы же хотим переиспользовать логику но это не очевидно в случае сиреци не перепутаешь то есть у нас чтобы вызвать напрямую хендлер мы вводим мы бросаем команду и вот такая вот получается запись она очевидная но она какая-то кривая и так делать не хочется более того когда мы одну бизнес операцию с другой вызываем Ну нам не часто надо переиспользовать код Кроме того А что делать с Ротко ошибок А что делать с транзакциями Ну в общем непонятно Давайте как-нибудь получше попробуем обрабатывать общую логику из разных бизнес операций здесь надо понимать что опять же общая логика бывает разная Если э логика предметной области переместить её в домен то есть какой-нибудь расчёт тотала у заказа если это одинаковая подгрузка данных Используйте Пантер спецификация Если вы используете сервисы там такой проблемы нет вообще взяли общую логику поместили в приватный метод и всё А в случае мы так как используем Разные классы независимые для хендлеров мы будем использовать либо наследование либо композицию соответственно либо базовый класс либо какой-то отдельный сервис А давайте рассмотрим такой пример у нас есть несколько отчётов построить отдельный отчёт это отдельная бизнес операция при этом выбор данных - это общая операция потом эти данные там форматируется и выводятся в нужном формате Вот соответственно вот куда положить этот общий выбор данных для нескольких отелей отчётов вариант он это просто создаём базовый хендлер базовый класс и туда эту логику выносим дата и всё хорошо А если надо добавить например третий обработчик отчёта Ну добавляем ещё наследника и всё но тут начинаются проблема если нам нужно будет пошарить общую логику между вторым и третьим хендлеров и так далее а втором эта логика не нужна наследовать мы можем только от одного базового класса поэтому мы можем вынести э логику в отдельный сервис то есть перети от наследования к композиции вот здесь такой проблемы нет мы в зависимости можем добавить намдо соответственно мы можем вводить больший уровень Там абстракции и всё хорошо мы получили что получили мы получили и два хендлера РС используется из этих хендлеров но он находится у нас на Application уровне помните Мы из контроллера могли вызывать там хендлер вот а теперь мы получается сервис можем вынести Извините можем вызвать это неверно Почему пото что доже из хлев чтобы сделать такое неправильное использование невозможным мы Application уровень должны разделить на части То есть он получится должен стать инкапсулированный то есть вот сервис должен быть недоступен снаружи для вызова хендлеров Ну вша это делается через в других на другом стеке тоже думаю там есть возможность инкапсулировать данные внутри вашего компонента пакета как о там не называется вот и из контроллера теперь можем вызывать только хендлера вот то есть мы сделали неправильное использование Вот это вызов этого невозможен так по операциям Я надеюсь вы убедились что sec сделать зависимости между бизнес операциями явными общую логику можно вынести либо в базовый класс либо в Новый сервис зависит от того что вам лучше а не надо ругаться на наследование если у вас базовая логика между там двумя обработчика В данном случае вынесите в базовый класс никаких проблем не будет Вот и хорошая новость это бывает нечасто то есть большинство бизнес операций действительно независимые Но если у вас появляются связи между ними Вы теперь знаете что с этим делать и смотрим дальше общая Логика для всех операций сразу что это такое Это то что называется Cross cutting concern это логирование транзакции безопасность логи метрики А и так далее хорошо а здесь Мы также будем рассматривать Pine что это такое А это паттерн декоратор Когда можем несколько обработчиков таких декораторов навесить друг на друга ну самое простое - это стримы то есть какой-то фа файл Стрим и читая данные стрима что ещё мы можем делать Мы можем читать буферизированный и пайла нам погоняет Web Framework - это pipeline CP называется midle http клиент - это тоже pipel в котором есть там сериализация те же самые логи метрики и так далее современ тоже па в это называется Господи да исп называется вот но в других есть тоже самое то есть вот везде паланы и мы можем тоже делать свой Пап вот хорошо Что сделать чтобы внет свой пала для то есть мы добавляем унификацию для обрат команд будеть просто и в этом слу сможем нать Т самый бывает препроцессор это какая-то логика до основной операции постпроцессор логика после основной операции и beh то есть классический декоратор Когда мы можем что-то добавить до и что-то добавить после хорошо Как это реализовать То есть у нас есть маркер интерфейс А request который возвращает Рен Вот и просто requ handler у которы есть метод Один handle который получает requ а возвращает ренс вот и всё хорошо и посмотрим например декоратора Вот как раз есть Ling behav то есть декоратор который получает запрос вот рест и может какую-то логику добавить до обработки запроса Может после него может вообще заменить его и возвращать какой-то другой результат респонс то есть вот таким образом мы мы добавляем декораторы чем такой подход удобен во-первых из такого декоратора мы можем вызывать Di мы можем легко там добавить асинхронность будем испытывать проб сладко мани чем какая-нибудь кода генерации и так далее И это работает на уровне приложения а не веб фреймворка Я говорю что в веб фреймворке уже есть этот самый пайплайн но он будет работать на уровне Веба на уровне там а запроса Квеста респонс именно веб запроса А это работает на уровне ваших де сериализовать а вот д тошик и хорошо когда использовать pipeline Когда разработчики такой инструмент получает они думают ну сейчас куда-нибудь как в коряча этот пайплайн и сразу У меня всё станет хорошо а так вот так делать не надо поэтому Сначала я вставил слайд некогда его использовать когда его использовать не надо так вот его не надо использовать для стандартных вещей которые даёт фреймворк например аутентификация авторизация это обработка ошибок это управление транзакциями логи метрики трейс вот это вот всё короче если вы pipeline не используете это нормально Скорее всего он вам и не понадобится когда же тогда использовать вот если хорошо понимаете зачем тогда Используйте например его можно использовать если у какого-то например брокера нет готового пайплайф ещё что-то вы используете и вот там вы берёте и заменя пайплайн от фреймворка своим кастомным пайплайн либо если у вас какая-то общая обработка на уровне логики но я такого пока не встречал мы делали например пайплайн для аутентификации авторизации но он вот такой был Пограничный случай его можно было сделать на уровне веб фреймворка либо на уровне вот уже Application логики мы сделали на уровне Application логики почему Ну потому что удобнее было работать с стерилизованный д Тошка вот и всё но его можно было сделать и на уровне Web Framework То есть это вот такой не могу сказать что всегда так надо делать хорошо Давайте подводить итоги sec V1 Из плюсов Я надеюсь убедил вас что хендлер будут меньше их будет проще поддерживать там будет меньше зависимостей вы получите общую логику между бизнес операциями вы увидите явно и сможете переиспользовать и вы сможете легко добавить pipeline при необходимости но скорее всего вам это и не понадобится Из минусов можно отметить что будет больше структурного кода то есть больше классов папок и так далее То есть структура компонента Application будет сложнее нуно Это небольшой минус это вот то та небольшая цена которую вам придётся заплатить чтобы получить плюс этого подхода И когда же вообще надо использовать а Используйте если у Вас бизнес операции Я много раз это сегодня говорил Так вот если ваши IP методы - это какие-то бизнес операции создание заказа например тогда Используйте А если это вот просто админка где крут где много-много сущностей над которыми однотипные операции работа с базой по сути вот Здесь secs вам не поможет вы наоборот будете испытывать проблемы из-за того что куча куча вот этих маленьких однотипных операций для которых много надо кода писать хорошо теперь посмотрим как sec поможет при росте нагрузки на ваш сервис То есть у вас всё хорошо сервис вы запустили он растёт постепенно больше данных больше пользователей Что делать чтобы вы успевали обрабатывать большее количество запросов ну самое простое вертикальное масштабирование накинули там памяти ядер всё стало хорошо даче можем оптимизировать запросы к базе индекс добавлять нормализацию делать добавлять и так далее Вот Но в какой-то момент мы придём к тому что нам нужно горизонтальное масштабирование то есть мы ставим балансер за балансера несколько исов энда который использует общий кэш и общую базу в таком режиме можно жить Достаточно долго Но тогда вы начнёте упираться в базу потому что её не так легко масштабировать Что же делать часто используют в этом случае репликацию мы делаем Марс репликацию и мы можем читать данные с асинхронной метрики Уде Синенькая там это синхронная ээ реплика серии асинхронный вот что что при этом то есть мы пишем на мастер А читаем со слева Таким образом мы разгрузили базу данных вот ну тут можно ещё отдельно сказать что что делать чтение для записи Ну давайте для простоты если нам нужно записать данные Мы сначала прочитали их с мастера мы получили последнюю актуальную версию и потом а записали опять же на мастер хорошо какие изменения в коде нам понадобится для того чтобы это поддержать то есть на уровне базы данных мы настроили репликацию то есть дела синхронные реплика асинхронные реплики А в коде что нам нужно во-первых у нас появится две строки подключения одна на запись вторая На чтение далее а все операции Нам нужно будет разделить на две части те которые пишут данные и те которые читают соответственно те которые читают мы назовём queries а те которые пишут мы назовём commands и мы получили secs а для чтения из базы ну здесь немножко даной специфики А нам понадобится некий контекст для того чтобы данные читать Вот там не будет возможности сохранить изменения Save changes Вот И мы этот вот там request read db Contex мы его будем использовать только в операциях чтения только в кри хендлера вот ну и соответственно Вот там ещё такая штука аткин это мы отключаем трекинг изменений то есть э orm ничего не знает про эти объекты он их не запоминает соответственно это работает очень быстро всё хорошо для записи в базу у нас будет другой контекст для работы то есть это контекст Урма там будет метод Safe chang чтобы сохранить изменения он будет использовать строчку подключение на мастер для записи вот в принципе всё и его мы использовать соответственно в в кон хендлера когда мы сохраняем изменения вот и что мы получили А мы за очень небольшой объём работы получили то что хотели то есть мы теперь можем писать на мастер а читать реплики причём что интересно мы это заранее не планировали то есть говорят преждевременная оптимизация зло Так мы это в начале не планировали мы это получили как приятный бонус а почему а потому что самая большая работа здесь это внутри вашего приложения разделить все операции на те которые пишут и на те которые читают А мы это сделали в самом начале вот из минусов такого подхода надо отметить что Вы получили конечно говорят что там можно до 10 миллисекунд довести вот лак синхронизации То есть как это сделать можно пройти на поса Вот но скорее всего это у вас будет дольше более того иногда реплики будут отставать про это надо помнить хорошо В данном случае мы уже всё что могли из кода выли пора переходить к изменению на уровне архитектуры и на уровне хранилища А давайте посмотрим что нужно изменить на уровне хранилища и архитектуры проблема репликации она полностью не решает Вот чтени почему Потому что при репликации мы реплицируемый поиск для этого лучше использовать специальное хранилище э вот И для этого мы можем выбрать специальное хранилище то есть Мон элак ещё что-то вот поэтому мы вводим такое понятие как Рит модели и архитектура у нас будет следующая у нас будут колеры которые пишут данные в базу У нас есть quy которые читают данные специальной базы специальной модели и у нас есть механизм синхронизации вот эти вот базы db идб через механизм событий что же такое Ридель Ридель - это в общем случае всё что обновляется асинхронность это материал viw в основной базе это какие-то денормализация денормализация обновлять вот также это может быть специализированное хранилище эластик Мон всё что угодно Итак самый интересный момент как обновлять Рит модель то есть вот мы взяли зани в Бау зали транзакцию А вот как модель обновлять самый простой вариант это обновлять её синхронно то есть мы взяли создали заказ сохранили данные в базу и дальше мы посчитали модель и сохранили е вот в специализированное хранилище например в кш вот каго подхода плю вопервых это быстро иреть организаци хранилища вам не понадобится Я уже сказал это часто используется при обновлении кэша Почему Потому что Что произойдёт если вот мы данные в базу сохранили А в кэш нет то есть не получилось то есть редко но иногда такое бывает Ну в кэше мы какие-то временные данные храним через какое-то время он протухнет мы сходим в базу и прочитаем актуальные данные вот из минусов А это негативно влияет на время отклика при записи То есть Вам нужно не только данные в базу сохранить А ещё и посчитать Вот эту вот Рид модель а обновить кэш и так далее и нужно думать Как обрабатывать ошибки при обновлении самой модели Вот и второй вариант - это асинхронно то есть Рит модель обновляется синхронно здесь мы сначала записали данные в базу закатили транзакцию потом отправили сообщени в очередь и комер очереди он читает сообщения обновляет Т модель и всё что мы получили в этом случае Из плюсов Мы решили проб задержкой при запи даное записа данные в базу что заказ создан потом бросили сообщение что заказ создан и ВС и вернули результат и такой подход намного лучше масштабируется из минусов что мы получили мы получили то теперь нельзя просто сохранить данные в базу и получить результат это похоже Кстати на Да который мы использовали при репликации сложного ния здесь мы получили уже там распределенную систему соответственно вам нужно думать про что когда у вас получаются очереди нужно думать про Какая у вас гарантия доставка там least например вам нужно думать Как обрабатывать ошибки а приходят ли ваши сообщения в правильном порядке Ну обычно Нет а как сделать дупликации на коню и так далее вот это вот всё вам нужно думать Вот и моё любимое переходим к мифам sec хорошо миф номер звучит см образом может менять состояние даже писать логи Как вы думаете Это миф или неправда по Кто считает что это правда на самом деле это миф конечно в мы не меняем основную модель мы е Только читаем правда вот соответст может он может писать логи собирать метрики обновлять кэши Вот это всё делать Можно но что такое обновление кэша посмотрели в кэше данных нет сходили в базу прочитали записали в кэш вернули результат Вот то есть основную модель мы не поменяли не меняли Ну значит всё хорошо хорошо миф номер два Так quy может читать только Рит модель То есть это тоже миф А почему потому что опять же quy Они читают основную модель они её мо они не могут её менять а читать могут То есть это про то что не нужно создавать Рит модель если у вас нет проблем с производительностью если у вас всё хорошо Не надо эту Рит модель создавать почему Ну это сложно вот то есть ещ раз на схемки Давайте посмотрим То есть если вы из хендлера обращаетесь к доменной модели к базе данных на запись к всё хорошо Так и надо делать Нет проблем с производительностью ради Бога читайте основную модель возвращайте результат миф номер можно ли читать модель То есть это асинхронно обновляю и так далее Кто считает что так делать можно это Миф это не Миф это правда Почему Потому что если команда мы читаем Ридель что происходит Мы читаем Не самые свежие данные потому что мы же говорили что там будет там будет лаг по обновлению этой самой Т модели и так далее Потому я не могу сказать что никогда так не делайте Ну так делать Можно но просто Помните о последствиях Если вы так делаете Что Вы можете получить не самые последние данные и тоже самое на схем То есть если вы изх обращаетесь как раз так делать не т дела помните про последствия и пункт номер четыре Вот мой любимый вообще он звучит так что команды не могут возвращать значения вообще кто считает что команда может вернуть значение опять же Давайте о почти весь зал молодцы Так я видел в общем такие реализации когда команды возвращать значение не могут но очень хочется а значит сначала создаются адини операции Он пробрасывается в диспетчер Ну ко диспетчер команду команда ничего не возвращает но потом этот диник операции бросается в квери возвращается результат Ну Бред конечно но такое видел а давайте разберёмся Почему так вообще операции бывают синхронные и асинхронные что такое синхронная операция например платёж это когда вы обработали результаты сразу его получили результат обработки например Моя жена как-то по рынку ходила купила фруктов А через месяц шла Потому же рынку и говорит вот Дорогая ты покупала У меня тут персики а платёж не прошёл Плати деньги Слушай месяц назад было вот что то есть вот здесь Вам нужен результат сразу правда то есть потому что я рассчитался и ушёл и больше сюда никогда не вернусь вот есть асинхронные операции когда мы взяли не обрабатывая то есть мы получили команду Мы её не обрабатывали и Просто сразу закинули в очередь ничего не делая То есть если у нас здесь результат Да нет конечно мы же ничего не делали Максимум что мы можем тут вернуть - это некоторый айдини операции вот ваш запрос зарегистрирован с таким дишни Вы можете потом сходить в какой-то IP проверите результат Либо мы вам сами пришлём там email там КАД websocket либо Ну что угодно со статусом это асинхронная операция когда мы сразу не обрабатываем какое-то действие вот нашу команду а только закидываем в очередь Из плюсов такой подход Отлично масштабируется просто вот превосходно но мы не знаем сразу вот он был у нас обработан или нет И вот как раз поэтому возник этот миф кн сам про это говорил что он написал Вот именно этот вариант максимально такой масштабируемый он не везде работает Не всем он нужен хорошо и что выбрать Ну то есть мы это немножечко уже поговорили соответственно синхронно это когда результат операции нужен сразу и тогда команда возвращает значение и асинхронный это когда результат операции сразу недоступен вот тогда это асинхронная операция Вот и тогда команда значение не возвращает Вот и ещё раз про мифы Давайте обсудим то есть мы получили что по мифам что ри не может менять состояние даже логи миф Вот можно менять там писать логии менять кэш и так далее дальше что может читать только Рит модул нет можно читать миную модель Е менять нельзя читать можно сонно то что команда не может читать Рит модель - это правда но опять же добавлю помните про последствия если вы так делаете вы получите просто не самые свежие данные Ну и моя любимая команды команды могут возвращать значение более того иногда это нужно вот если у вас синхронная операция по сути коман Вполне себе должна возвращать результат И что бы мне хотелось чтобы вы вынесли вообще из этого доклада что CS - это просто это просто когда только команда может менять основную модель доменную Акри Может её только читать Вот и всё и чтобы внедрить sec в вашем проекте вам опять же нужно найти там Application уровень а найти там сервисы и распилить эти сервисы на независимые хендлер для каждой бизнес операции вам нужно создать пару команду и обработчик хендлер ну и либо quy и тоже обработчики хендлер вот и всё и вы уже на уровне кода получите много-много плюсов А давайте Понемногу закругляться О чём поговорили во-первых secs позволяет писать легко поддерживаемый код вы все плюсы получите на этапе написания А на этапе поддержки вот этого кода Когда вы все бизнес операции друг от друга отделили дальше secs позволяет легко добавить чтение с реплики за счёт чего а за счёт того что мы в самом начале разделили все бизнес операции на те которые пишут а не те которые читают и в данном случае добавление чтения с реплики нет таких проблем дальше чтение масштабируется через добавление Рит моделей Вот Но в этом случае Вы получите все сложности распределённых систем Вот и запись бывает синхронной бывает асинхронной вот мы тоже с вами поговорили это как раз про случай когда команда возвращает не значение или нет Вот если у вас операция синхронная возвращайте результат сразу если она по сути асинхронная Ну либо она тяжёлая Вам бы хотелось её сразу выполнить Но она очень тяжёлая вы не можете тогда сейчас например а моделируется такой синхронный вариант Когда вы отправили запрос на самом деле-то в фоне у вас он обрабатывается и потом по сокету вы получаете ответ то есть операция по сути асинхронная но пока вы не получили ответ пользователь ка какой-нибудь там спиннер и ещё что-нибудь ему показываете Вот хорошо И что же делать дальше а Попробуйте подход на каком-нибудь ПД проекте вот уверен что вам понравится дальше Вы можете взять и перевести часть вашего реального проекта на sec просто посмотрите как это будет выглядеть вот на одном проек вя Возьмите какой-нибудь кусок какой модуль щего проекта и переть его на secs вы увидите что поменяется опять же хотя бы начните с уровня кода Потому что если у вас там большая нагрузка Вы наверняка и так уже задумываетесь как бы перейти на отдельное хранилище Вот и если вы начинаете Новый сервис начинайте сразу скус и тогда вы сразу получите все его плюсы так и материалы по теме здесь а будут скорее ссылки на какие-то доклады мне понравился доклад грега Янга пом dec of ddd sourcing вот по-моему D он его рассказывал дальше Макс аршинов на донесе делал хороший доклад про быстро растворимое проектирование мой брат Денис Вот у него был доклад на ДОТ нете на девять способов улучшить вашу архитектуру при помощи vertical SL и secs Я сегодня разобрал только там четыре основных преимущества на уровне кода там более глубокий анализ Но именно на уровне кода мы сегодня с вами поговорили и на развити на уровне кода и на уровне архитектуры и прока вот также можно почитать материа бо про что это такое по сути это всё одно и тоже только сделал акцент на уровне хранилища там а Бор он сделал акцент на уровне именно вот обработки на уровне кода То есть он как раз сделал бику медиатор там можно настраивать этот за да Я не слышал чтобы кто-то использовал среди стов Но по крайней мере попробовать можно это как раз тот редкий случай когда что-то хорошее перетащили на jav а не наоборот вот и можно ещё посмотреть материалы Сашин на практике вот там у него есть статья Вот на этом У меня всё спасибо за внимание и рад буду ответить на ваши вопросы Я уже вижу вопро Да за вопрос у нас будут призы поэтому у нас да у нас будет опять как в предыдущем докладе два приза сейчас немножко нужно времени мы подготовим микрофон Вот пока я расскажу про призы у нас будет целых два приза один от нашего партнёра газпромнефти и второй приз у нас будет Лично от Андрея вот поэтому Да так Мы готовы Ну тогда предлагаю сразу прямо начать с этого конца и будем плавно идти всех виу СБО бое зала вот как-то читал про cqrs что там делали два трака то есть если хотим писать Ну то есть исполнять команду Это пишется в один сервис если читать то есть quy - Это из другого сервиса здесь Я как понял Один сервис который умеет благодаря хендлера делать и то и то правильно а и которые можно масштабировать там при отказах Так давайте уточню То есть вы имеете в виду следующее что у нас есть один микросервис который обрабатывает все команды да то есть туда ит все попут запросы Да и есть другой сервис который обрабатывает Get запросы дада да А так тоже делать Можно вопрос что вам нужно масштабировать Можно ли так делать Да можно то есть классический микросервисной подход он подразумевает что у вас один сервис Он отвечает за до чтение для запись Можно ли переходить вот ко второму варианту как правило можно если у вас чтение допустим на сильно-сильно там на порядков больше чем записи то есть так делать можно если посмотреть статью на амазоне то есть этот слайд К сожалению убрал вот да статья Amazon она как раз про это то есть там как раз делается независимые сервисы не только на уровне хранилища они разносятся но ещё и бкд разносятся отдельно на чтение отдельно на запись то есть так делать Можно когда так нужно делать Но как правило если у вас нагрузка на чтение вот сильно сильно больше чем на запись М хорошо спасибо Вот ещё вопрос по поводу синхронной и асинхронной записи То есть когда приходит Команда А хендлер может сам обновить э нуй мол он всегда делает и либо он синхронно обновляет read Model либо кидает в брокер сообщения То есть какие есть кейсы использования Когда можно выбрать один или второй вариант там в зависимости от нагрузок или бизнес логики или чего Ну смотрите из моего опыта Это скорее вот я говорил про кэш То есть если у вас Т модель - это кэш например ну можетли быш модель Ну может что бы и нет так делать можно во всех остальных случаях обычно используют очередь ну очередь Не обязательно прям брокер может быть это может быть очередь например в базе данных тоже бывает Вот то есть всё-таки чаще Рит модель обновляют асинхронно вот ну то есть какие-то в простых случаях луча кэша да то есть это то с чего можно начать Вот ну как правило переходит больше ко второму варианту когда отдельная Ридель там нормализованная через брокер обрабатывается Спасибо и последний Маленький вопрос на Я прошу прощение давайте мы передадим микрофон а потом в дискуссионной зоне вы продолжите потому что у нас очень много желающих Я думаю сейчас будет три вопрос с этой стороны Да вот у тебя прямо рядом человек стоит потом перейдём в другую сторону если у нас тоже есть вопросы вижу есть Спасибо Да Андрей Спасибо за доклад Роман скажите вот насколько я за помнил один из слайдов был о том что в пайплайн нельзя применять валидацию либо кэширование А как сказать не то что нельзя можно тут как сказать валидация каширования - это то что вы делаете как правило на нескольких уровнях То есть можно ли это встраивать в pipeline Можно я говорил про допусти что я говорил про то что нельзя стандартные методы использовать То есть это всякие логи метрики трейс Там и так далее про валидацию и каширование А в принципе можно но смотрите и не пересекаете это например с вашим веб фреймворков он тоже умеет делать валидацию он тоже умеет делать каширование то есть если вам нужно какое-то специальное каширование его можно встретить его можно встроить в пайплайн Ну мы используем fluent validation библиотеку для пайплайн Ну опять же можно так делать Я не говорю что там прямо нельзя так делать можно то есть нормальный подход То есть тут скорее вам нужно принять решение будете ли вы это делать в пайплайн либо это вы будете делать как раз на алике уровне уже напрямую в хендлер то есть и тот и другой вариант работоспособный хорошо спасибо последний ряд там вот четвёртое место я пока напомню э большая просьба оценивать доклад делиться отзывом и делиться какими-то комментариями чтобы Андрей потом мог там тоже как-то свои доклады улучшать спасибо спасибо за доклад Вопрос такой вот у нас как вы рассказали Согласно паттерну secs у нас либо есть команды либо есть qu запросы то есть на чтени А есть у нас такая ситуация что требуется отдать данные но при этом записать в базу информацию о том что данные были отданы Ну когда они были отданы То есть какой-то как След оставить Ну понятно То есть такой аудит вот дадада Ну это если вы отдаёте данные это ри это Get запрос но при этом вы пишете в аудит что вот такой-то человек тогда-то вот эти данные смотрел это аудит это логи это не относится к основной модели то есть всё нормально это кри но другое дело что Да Вам их нужно будет где-то дополнительно сохранять но это не часть основной модели будет Угу Ну то есть понятно что получается этот аудит будет куда-то не в основную модель писаться а в другую он будет писаться не Ну опять же это может быть даже та же самая база но просто оно будет писаться в квери оно будет писаться В отдельной там табличке это может быть отдельное вообще хранилище и так далее То есть оно не этот короче это точно не будет основная модель то есть опять же sec вот это просто вот основная модель меняется значит это команда основная модель не меняется Это логи аудит обновление кэша это ри они всё это могут делать спасибо спасибо за вопрос давай теперь перейдём в эту часть зала чтобы у нас был паритет я напомню что у онлайн участников тоже есть возможность задавать вопрос я если будет возможность его зачитаю либо потом Андрей может ответить вам просто в чате Добрый день Андрей Спасибо за доклад такой вопрос был Application сес я пилю его на хендлера Ну как чаще бывает один метод один хендлер Теперь у меня появляется дублирование Да ну в двух обработчика один и тот же код если я не иду не в наследование а Иду в композицию тогда я снова выделяю сервис и тогда получается и хендлер и сервис и с ответственностью как решать с точки зрения архитектуры Где чья ответственность хендлер должен быть тонкий хендлер должен быть толстый куда я должен добавить логику handler или в сервис Да смотрите отличный вопрос А ну во-первых такое бывает нечасто то есть всё-таки большая часть операций она у вас будет независимая То есть у Вас если у вас куча операций и у них у всех одна и та же общая логика Но это будет выглядеть подозрительно То есть как прави вки таки бизнес операции более независимые А как здесь разделяется ответственность то есть а точка входа в бизнес операцию - это хендлер А в сервис но вот такой вот Application сервис Да который инкапсулированный уровня он будет вызываться Вот из этих вот хендлеров туда какая-то логика подгрузки одинаково выбирается ещё что-то то есть как как правило из нашего опыта допустим это Например главная страница А на главной странице Ну я уже сказал что я работаю в бизнесе Да мы показываем главную страницу там например для ните Налоговой операции То есть например надо заплатить налоги взносы выставить декларацию и так далее и для таких событий надо посмотреть текущую дату вот на текущую дату Сколько надо заплатить на текущую дату статус операции Он просрочено не просрочено вот и это делается из разных мест вот в данном случае как раз получение такого статуса на дату оно может вызываться из разных бизнес операций вот и это вот та часть которую мы вынесли Тай но это не независимая бизне операция она может из раз ме вызываться из разных хендлеров но на не независимые то есть ну тут как сказать вы это сами увидите когда начнёте распиливать вы увидите что у вас вот эти вот сервисы они будут маленькие они они не будут друг друга вызывать вот он так остаётся один да то есть вот это как раз вот смысл Вот вот мы мы вот эти вот сервисы мы убираем дублирую логику чтобы можно было из разных там хендлеров потом вызывать это это кажется страшно программист любят фантазировать Нет просто часто думаю что вот у меня тамле будут и сервисы вот в том-то дело что их во-первых не будет много вовторых эти сервис они будут маленькие тонкие с ними не будет проблем с их поддержкой вот так спасибо Вот туда вопрос очень давно рука поднята Спасибо за доклад вй работе не S qrs больше использую а просто такой классический паттерн команда Угу И вот собственно на опыте вытекает Следующий вопрос Если очень нужно и хочется и хочется и нужно логи трассировка и самое больное - это транзакции как куда на практическом опыте внедрять интерсек тором в на уровне глобального пайплайн если этих команд много они могут вызывать друг друга Ну что делать понял Ну из моего опыта во-первых не надо делать транзакцию в пайплайн Почему во-первых это неявно Ну тут можно побыть капитаном очевидностью Да что там явно лучше неявно Вот и так далее А в чём ту другая проблема Если вы делаете вот этот transac Вы весь обработчик заворачивали транзакцию открыли транзакцию потом весь обработчик потом её заколисуючий вам нужна в самом конце Вот для этого лучше использовать как раз урм толстый трекер и тогда у вас в самом конце будет короткая транзакция которую вы вызываете явно То есть у вас не будет сетевых запросов под транзакцией вот поэтому с транзакциями лучше работать явно Если у вас есть какая-то общая логика опять же там вы её убираете в в этот в Application сервис который вызываете из хендлера вот ну то есть про транзакции вот так с ними надо работать явно если какая-то общая логика там что-то меняется Ну посмотрите Возможно это не Алика Возможно стоит убрать в какой-нибудь Если я правильно понял вытеснены образом Ну да да то есть транзакцию котем в конце явным образом Вот это спасибо И второй вопрос попроще Мы напилили очень много хендлеров quy всё это за всё прекрасно моно репозиторий или как собственно распиливать эти микросервисы И поддерживать там dependence Hell Ну то есть есть какие-то рекомендации Ну как сказать здесь мы всегда работаем в рамках одного сервиса то есть всё что я говорил это всё относится к одному микросервис там монолиту макросе вису там нанос то есть это всё внутри одного сервиса Если вы их захотите потом как-то поделить например вот как здесь был вопрос отделить все ри в один сервис А все команды в другой либо как-то по-другому распилить А на уровне кода это пилите без проблем то всё что говорят Вот давайте мы там распилили микросервис на уровне кода он гибкий это делится на уровне хранилища делить будет больно Потому что если у вас там 10000 гиб база данных Вот её просто так взять и разделить на часть не получится а с кодом проблем у вас не будет хорошо у нас есть ещё один вопрос но я воспользуюсь А что если что делать если у нас такая большая база данных потому что это вот мой кейс миллиард транзакций Да ну тут что сказать К сожалению нет никакого простого такого лёгкого способа кото эту проблему позволит решить из моего опыта делают если допустим надо добавить ноде или как-то поменять старую Ну во-первых Рит модель Нельзя терять ничего не будет работать то есть бэкапы Нужны во-вторых Что делать если нам нужно построить новую Рит модель например мы делаем фоновый процесс который пачками вычитывать данные Из основной базы это Рит модель строит когда Рит модель вся построена мы можем данные переключать Ну то есть мы добавили для новой Рит модели событие мы его пишем в очередь то есть для новых данных у нас модель строится А чтобы её построить для всех старых данных мы запускаем но процесс который это делает вариант номер один вариант номер два а Вам нужно будет смириться что допустим ваши ГТ запросы quy они будут менять Рит модель то есть мы сходили в получили quy quy идёт в Рит модель там есть данные для моего заказа если данные Нет она сама идёт в доменную модель читает данные обновляет Рид модели возвещает результат но тут вам надо смириться что ваши квери будут опять же основную модель они не меняют но Рит модель Они меняют То есть это вот такое обновление при запросе данных насколько это вам подойдёт Тае тоже видел я понял два отличных варианта в принципе хорошо и у нас время на последний вопрос пожалуйста Спасибо за доклад сергейс кажется частично вот только что на мой вопрос ответили но тем не менее Вот ситуация у нас есть Мы записали его в модель врай базу данные успешно посчитали модель записали туда и дальше Вот какая судьба данных изы они вот нуж для или Ну что с ними дальше делать Ну если мы всё читаем из рай базы то эти данные как будто бы они нам уже не очень сильно нужны Не понял Мы зачем нам нужна вй база после того как мы успешно посчитали и записали во в базу понятно во-первых не все данные идут в ремодель во-вторых Ридель у вас прад источник Правды это вки модель то есть не то чтобы эту модель можно терять обычно терять нельзя Ничего работать не будет но источник Правды это у вас вс-таки в модель вот поэтому Нужна ли она Да нужна вот если вы какие-то проблемы найдёте в ри модели Вы можете перестроить по в модели но опять же если у вас база большая это будет не быстро но потенциально такая возможность будет то есть опять же у вас в модели наверняка Будет какой-нибудь аудит история что поменялось Почему помесь вот мы терять можем ични Правды АТ модель - это вот как раз оптимизированное для чтения хранилища которое нам позволяет быстро отдавать данные там для поиска там полнотекстового поиска и так далее Спасибо Андрей у нас теперь выбор лучших вопросов Можешь сам решить Какой подарок ты подаришь от себя так хорошо значит мне понравился последний вопрос ваш что делать сй моделью и понравился вопрос Вот про ваш про про хендлера и про сервисы Спасибо тогда давай я вручу и А мы пока тебе вручим подарок от э от нас конференции А если это вам спасибо большое спасибо"
}