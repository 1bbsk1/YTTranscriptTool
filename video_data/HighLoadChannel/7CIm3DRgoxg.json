{
  "video_id": "7CIm3DRgoxg",
  "channel": "HighLoadChannel",
  "title": "Функциональное программирование в браузере / Никита Прокопов",
  "views": 2063,
  "duration": 2988,
  "published": "2017-07-29T00:22:45-07:00",
  "text": "всем доброе утро я вижу что зал уже практически полное это очень радует потому что вчера в этом зале в какие-то моменты даже не всем хватало места меня слышно нормально меня зовут миша башкиров сегодня я буду вести эту секцию и давайте начнем с нескольких объявлений во-первых сегодня не будет blitz of так же как и вчера к сожалению но вот так вот и в 17:30 мы начнем так же как и вчера круглый стол сегодня круглый стол будет посвящен frontend сообществом и вести его будет вадим макеев в этом зале так что обязательно не расходитесь я думаю что это будет очень интересно хочется немножко сказать про тематике залов потому что мы постарались когда делали программу немножко разделить соответственно сделать так чтобы доклады в одном зале были посвящены одной теме в другом зале немножко другой теме чтобы не было такого чтобы как бы люди разрывались соответственно в первом зале будут доклады которые посвящены в основном созданием в приложении например созданием десктопных приложений созданием мобильных приложений и созданием приложений которые работают и там и там одновременно и соответственно там будут доклады например ребят которые работают в медузе мне кажется это будет очень интересно послушать но и в принципе будет много других интересных докладов так что обязательно если вам хочется послушать про клады именно про разработку в приложении то идите в тот зал а в нашем зале будут совершенно разные прикладные доклады например про безопасность про отладку про тестирования и про сборку проектов соответственно оставайтесь с нами тоже ну и сейчас давайте я представлю 1 докладчика это некий никита прокопов он веб-разработчик из новосибирска он в последнее время очень сильно увлекается темой функционального программирования его доклад как раз посвящены этой теме всем привет очень приятно что вы пришли с утра на мой доклад да меня зовут никита прокопов я буду рассказывать про функционального программирования на самом деле я не в призах но как бы я веб-разработчик но не front-end разработчик в основном дает только недавно начал увлекаться фронтэнда и вот то в чем я разобрался со сна про это будет доклада сейчас он даже появиться на экране надеюсь вот ну пока он не появился у меня такой вопрос делать доклад называется функционально программирование в браузере кто нибудь знает что такое монада можете поднять руки что команада а я вас потом спрошу да у нас будет легкая версия функционального программирования с небольшим таким видением и как бы ну без подробности на самом деле вот но в основном как она применяется для веб-программирования значит смотрите доцентами программирование браузере было павла слова браузер здесь почти случайно потому что ну так получилось что я занимаюсь браузеров на самом деле доклад про программирование интерфейсов вообще и на любых устройствах то есть но посыл такой что на самом деле это фейсы более-менее устроены одинаково везде нет вот они устроены более-менее одинаково подхода везде одинаковые никто них не умеет нормально строить это всегда сложно боль и так далее естественно доклад про то как немножко эту боль упростить вот и стен в принципе он такой архитектурный какие-то названия будут звучать но подходы они универсальны для всех на свете вот так вот про то как к ну в общем по постановка проблемы до что мы хотим сделать мы хотим научиться строить сложный интерфейс если такой интерфейс на котором на экране одновременно происходит но несколько параллельных каких-то историй да то есть несколько областей у каждой из которых свое опыта поведения своя какая-то логика и так далее вот то есть ну в принципе бывают наверное будет сложный интерфейс в принципе даже вот это можно назвать интерфейсом сложно в чем подвох да вроде бы все умеют делать подвох в том что мы хотим не просто сделать интерфейс мы хотим сделать его адекватным то есть адекватным с человеческой точки зрения и когда мы начинаем это делать мы понимаем что подход а.п. подход разделяй и властвуй когда нас есть независимой компоненты со своим состоянием он работает не очень потому что в адекватном интерфейсе вещи компоненты их внешний вид определяется не только внутренним состоянием да то есть и поговорит вот у нас есть объект у него и состоянии он выглядит так как рук каково его состояния это немножко не так на самом деле в интерфейсе вещи должны менять свой внешний вид зависимости от истории взаимодействий в зависимости от контекста которые их окружают да то есть чем больше там вещей на экране какие-то штуки должны прятаться появляться и так далее в общем все происходит очень сложный и чем но больше компонентов тем больше протаскивается вот этих вот неочевидных взаимосвязи тем больше одни части интерфейса влияют на другие части интерфейса и растет сложность то есть сложность здесь опять же растет но мне кажется в программировании сложность вообще в интерфейсах давно уже нет проблемы по производительности до более менее это достаточно легко делается вот на сложность именно управление информации то есть мы делаем большой интерфейс у нас просто много всего и чтобы это все вместе слаженно красиво работала нам нужно держать в голове держать в коде огромное количество этих взаимосвязей тонкости нюансов и них очень легко запутаться соответственно мы конечно это все они здесь не все официально решит в рецепта не предложу но отдельный это можно назвать приемом что ли или ну да подходом который может эту проблему немножко облегчить сделайте решение проще в контексте разработки интерфейс собственно подход стоит том что мы берем идеи функционал программирования смотрим как их засунуть в front-end вообще как бы до теперь но вот небольшой ликбез что такое функции программирование естественно как бы четкого определения функционал программирования нет туда пихают все что угодно все что так или иначе относится к тем или иным языкам мы нас это не очень интересует нас интересуют сами подходы подходы вполне конкретные вот функции высшего порядка и замыкания есть java скрипте про них ничего рассказывать и там всегда так писать и вообще но как бы этому не стриму главу угла вот а вот следующие четыре пункта мы про них час поговорим потом вас 33 следующих мы не поговорим до рик девственно чистой функции основной пиво новых функций на программирование функции значит функций туда функцию сюда есть понятие чистой функции это такие функции которые не меняют никаких глобальных состояний не производит никаких побочных эффектов процессе своего исполнения то есть они не пишут в сеть не пишут на экран не меняют состоянии каких-то объектов они принимают аргументы и возвращает результат и не делать ничего постороннего красота таких функций собственно в том что их можно вызывать как угодно сколько угодно раз в параллель там и так далее и ничего при этом не испортить но они просто вернут но худшее что может быть вы просто зря вызвали функцию да ничего страшно то есть нечистой функции каждый раз когда вы вызываете у вас есть какое какая-то какой-то эффект который она производит и лишний эффект может быть проблемой да если эффекта нет или лишний эффект не является проблема типа там логирование да в принципе такую функцию можно вызывать сколько угодно раз вот смежное понятие здесь чистой функции ссылочная прозрачность функций это функции которые при заданном наборе аргументов всегда возвращает одно и то же то есть функции которые не зависят от контекста не зависит от набора глобальных каких-то настроек не подглядывает глобальное состояние они только анализируют свои аргументы и выдают какой-то результат соответственно ну как бы краеугольный камень которому функциональная парадигма как бы склоняет нас рекомендует сводить весь наш код это срочно прозрачной чистой функция то есть такие функции которые смотрят на свои аргументы делают вычислением возвращает результат не производит никаких сайт сайт эффектов вот такие функции много какие у них бонус их можно зафиксировать например их мы легко тестировать до то есть функцию срочно прозрачную можно легко протестировать просто передав аргументы посмотрев на результат мы знаем что в процессе этого не испортится некое глобальное состояние мы знаем что для этого не нужно создавать никакое глобальное состояние то есть но это идеальный объект для unit-тест а вот и как бы мудрость функциональное программирование то что они там пропагандируют так или иначе то что большая часть программы может быть сведена вот к таким такого рода функции как только она сведена ну ты такой код проще писать проще понимать и проще тестировать да то есть это то к чему нужно стремиться дать направление в котором можно улучшать свой код у нас будут более конкретный пример это просто объясняю что это такое вот там да я как бы не чисто естественно к side effect и есть это работа с сетью это печать еще что то такие вещи локализуются их очень мало они очень локализованы и если вы построите программу таким образом что большая часть вашей логике это чистой функции вам будет легко и за тестировать потом вы к ней подключаете грязные эти сайт эффекты и все классно работать там что большая часть вас уже протестируем так следующий было аспект функционально программировать которым посмотрим в разделении функции данных да то есть ввп мы привыкли что данные нужно соединять с функциями это сомнительная догма ее почему-то как бы в пвп всех учиться управишься я с ней согласна вот и на самом деле это доме довольно сомнительное дело в том что программа они всегда как правило про данная программа принимая данные возвращает данные да и данные они как бы ну и во-первых имеет большую значимость во вторых они существует дольше чем программа один и тот же набор данных может пережить много разных версий программ так далее с данными можно делать много классных вещей их можно сохранять их можно пересылать по сети и и так далее вот и худшее что объектно-ориентированное программирование сделала вообще с программированием это то что она спрятала данные внутри оболочек который не прозрачная объект эта оболочка с какие то какие то данные там есть но вы должны работать с ними и с помощью объектов вот на самом деле ну в идеале данные должны лежать наружу их должно быть видно они должны быть но желательно представлена каким-то стандартными структурами данных типа списков и словарей там ну и собственно базовых каких-то типов вот и код просто занимается тем что трансформировать данным принимает данных таком формате возвращает какие-то другие данные это ну собственно хорошо разделяет его мух от котлет то есть данные потом можно написать другой код который работа с теми же данными про производители библиотеки не подумала вашему спейси но вы видите в каком виде лежат данные вы дописали свою функцию которую делать то что нужно и так далее реализовали данные вы обновили код не испортив данные так далее вот на живую это все очень здорово очень удобно мы тоже посмотрим как это применяется 3 аспекта социальное программирование ему табель нас тимут обильность это но свойства объектов не изменялся до мне там даже рекомендовали использовать неизменяемые но как бы по-английски и мид ability и мне кажется ему toppers просто доходчиво объясняет врача я говорю вот конкретно что ми цвету смотрите есть в языках программирования как правило классический пример ему табельного объекта это строка до строку нельзя поменять in place на месте нельзя взять строку измените значение можно создать новую строку из предыдущей которая там плюс еще какая-то строка it курсы счет символ или куст новый кусочек строки взять от существующей строки но при этом исходная строка остается валидным объектом тот кто держал на нее ссылку он видит все еще исходную строку вот но кроме естественно языков си си плюс плюс но там как бы ребята специально они любят когда тяжело вот на в нормальных языках строки вот именно так работает вот и модельность собственно это речь о том что точно также можно работать с структурами данных со списками и словарями множествами очередями и так далее то есть все вот эти структуры могут быть ему табельный что такое ему табельный список да например это список который нельзя добавить элемент но и удалить нельзя то есть все что можно и там оперироваться по нему и можно создать новый список который содержит те же элементы + 1 допустим вот но при этом старый остается валидным вот так таком же ключе можно сделать словари их ну мой об этапе шмапы можно сделать множество может делать очереди что году вот и это это классный прием то есть есть языки в которых и мутабельные структуры данных и to buy дефолт по умолчанию это приводит к тому что код оберегается от целого класса ошибок типа того что там я забыл в каком порядке человек тут поменял до или я меняю объект а оказывается кто-то на него там еще смотрит и он видит не полностью сменил на сцене и так далее вот изначально это все очень классно вписывается многопоточную среду когда такие объекты естественно легко же шарить между потоками не нужно никого синхронизации вот но взгляд на поточных они тоже очень существенно упрощают и делают код ну надежнее и проще для понимания вот для и как бы речь о том что существует реализации мутабельных структур данных которые еще и эффективно да то есть на наивный подход копировать то есть у вас есть список нужно добавить элемент вы копируете список и добавлять еще время она естественно дорогая есть реализация называется pure системной структуры данных они они приемлемы одно разумно эффективные то есть они медленные но не существенно медленнее чем обычной структуры данных но при этом имеет вот это классное свойства что объект не портится когда вы с ним что-то делать вы создаете новый объект вот и здесь видно пример что мы добавили в массив еще один элемент и по памяти они чуть чуть только разрослись для но при этом оба объекта и старый новый вполне полноценные объекты которые можно работать вот это свойство нам очень пригодится и наконец четвертый и последний аспект официально программирования это ленивость ленивость это такой подход когда вы вам нужно что-то посчитать но функция которая это считает возвращает вам не само значение не результат рецепт для вычисления результат то есть возвращает функцию которая вам результат принципе посчитает вот танцевальные парадигме это способ оптимизации работаю с коллекциями это способ представляет бесконечные коллекции типа того что она можно представить список всех натуральных чисел например который ты берешь из него 5 значений он вычисляет первые пять ты берешь еще 10 он вычисляет еще 10 но пока ты не взял они там не существует вот она и так далее вот но как бы в некоторые зэки эта штука встроена некоторых языках этаж ну как правило ее можно использовать она должна короче нам это тоже каком-то смысле про годится но как подход вот она есть и она тоже пришлось у самих языков наконец ликбез закончен и сейчас мои чувства посмотрим как это все применяется для функциональное программирования то есть так официально о куда для web programmer я то есть что со всем этим делать уехали дом короче что такое веб-приложение с переходим к и приложение это приложение это как правило это одно большое такое дерево дом объектов а на мутабельные но там она медленно 10 6 раз про это говорили что она медленно и оно большое а на мутабельные она хуже всего что собственно ваше приложение занимается тем что со всех сторон в карлсоном в ужасном порядке берет его и меняет вот это собственно это самый страшный сон специального программиста когда есть огромный сложный мутабельные объект которые непонятно кто в каком порядке меняет они такие в кошмарах видят по ночам вот собственно что мы можем с этим сделать чтобы упростить эту штуку можно взять дом как бы на 1 эта мысль функций на программиста что что можно сделать развивайте сделаем объекты мутабельным классно просто чтобы чтобы не путаться да окей о нам это бен и зимой сделали там мутабельные тогда наше приложение собственно сводится к тому что приложение эта функция которая переводит один дом в другой вот у нас было какое-то там дерево и мы вызываем с одном дерево собственно наше приложение возвращает новое там дерево вот из этого уже можно получить бонусы например бонус для тестирования как я уже говорил чисто уже говорил и по тестировать в нашем случае мы допустим хотим протестировать какой-то аспектов юнит-тесты до приложение мы хотим процитировать какой-то аспект примеру мы хотим проверить что при нажатии там на какую-то кнопку скрывается окошко мы создаем дом который в котором эта кошка показано вызываем нашу функцию которая является нашим приложением смотрим что в результате которой она вернула окошко уже нет вот здесь кайф ты бы в том что нам не нужно предварительно запускать там среду с браузером еще что-то не нужно так ли кивать наше приложение до нужного состояния мы сразу создаем его нужном состоянии вызываем мы смотрим то есть это на классическом понимании юнит-тесты конкретный маленький кусочек функционала тестируется да и поскольку функция чистая поскольку объект дом не глобальный и муторный мы можем это делать там в 10 потоков параллельно 10 там разных тестов в общем но все бонусы unit тестов их объяснять но есть подвох естественно естественно есть подвох то есть приложение имеет несколько состояний если у нас допустим тут 7 состоянии да нам нужно написать семь собственно вот этих вот вот этих вот стрелок перехода одиссей на семь квадрат характер зависимости квадратичной то есть каждое состояние переходит в каждой в реальности не каждая в каждое но все равно стрелок больше чем линейное количество и собственно это то где кроется сложность да у нас есть миллион состоянии нам нужно перевести в другой миллион состояний нам нужно написать функцию которая скрывает окошко но перед этим нам нужно понять а в каком состоянии находится объект а есть ли уже окошко показано а может быть мы там пришли туда так что она показывала на в другом месте авито гарри количество я немного из каждого из них нам нужно писать функции которой от окошка скрывает и наоборот мы добавляем новое состояние нам нужно там из него во все остальные варианты как-то переходить в общем это именно та то место где кроется сложности из которой служат сложности с которыми вы хотели бы побороться если бы смогли как мы можем это сделать тушки ну блин он здесь очень розовый конечно хотя красный на самом деле что вас ждет можем ввести model t то есть давайте данные нашего приложения представим в виде модели собственно дерева в виде дома и собственно наше приложение занимается тем что модель рендерит дом здесь опять же это одна функция которой из модели рисует там взяли другую модель смысле другое состояние моделей нарисовали другой дом собственно и если мы такой функции написали вот эта вертикальная стрелка эта функция рендеринга да то есть мы взяли состоянии перевели его в состоянии юзер интерфейса мы взяли состоянии предметной области перевели и состояния дизер интерфейса вот из этой схемы собственно как собрать полное приложение нам нужно научиться между моделями переходить это собственно бизнес-логика нашего приложения и нам нужно научиться один дом переводить другой водкой здесь в том что нижнюю стрелку можно сделать один раз и назвать эту библиотекой это то как работает вершил дом то как работает 3 окт вот верхняя стрелка она от отдано на откуп нам и собственно функции рендеры gold отдана на откуп нам вот упрощает ли это приложение принципе да но как бы получается что если у нас есть n состоянии нам нужно написать н разных функций рендеринга но опять же переходов между моделями осталось столько же собственно вопрос там выиграли мой ли мы здесь что-нибудь я утверждаю что потому что модель как правило устроена гораздо проще чем устроен юзер интерфейс там гораздо меньше деталей там гораздо меньше краевых случаев типа того что если в списке 0 объектов то нужно рисовать совсем другое вот модели просто 0 объекту вот и так далее ответственно вот эти переходы их гораздо проще написать и они гораздо логичнее рендеринга стало существенно меньше то есть формально на схеме стало больше компонентов на каждый из них во-первых занимаются своим делом во-вторых он очень существенно проще устроитесь на практике получается что пора костью мы выигрываем в сложности они проигрывают несмотря на то что стрелка стало больше вот до этого момента я так это как устроен ряд да то есть я здесь ничего нового не рассказал это про устройство реактор но как бы если посмотреть на социальное строчки точки зрения там и во-первых имеем здесь и мутабельных дом уже в реакцию я вот не не тоже не уверен и мы табельный ли он в реакции или нет на самом деле но он как бы эффективные мутабельные да вы создаете и каждый раз новый и вы не знаете что с ним происходит вы про него забываете то есть в реальности вы его не втирать его каждый раз создаете ногу это но он эффективно и матабеле можно считать вот здесь есть чистая функция рендеринга то есть функций рендеринга должна быть чисто не должна никакой гадости делать потому что react сам решает когда я как и вызывать вы не имеете никакого контроля соответственно у них в требованиях написано что в рендеринге ничего не делаете пожалуйста кроме рендеринг вот то есть ну вот получается что как бы сам react по себе он построен уже на двух функциональных парадигмах да и собственно счет этого выигрывает существенно вот но мы на этом не остановимся то есть мы сейчас начинаем относительно хардкорность тов мы собственно хотим функционально остальные концепции официально программирования даже до конца первое что мы делаем мы делаем модель ему той веры до в самом деле как бы ну сейчас все и мутабельным сделаем на самом деле во первых модель какие мы это нам бонусы дает смотрите приложение но у и мутабельных объектов есть такое классное свойства что по ним очень легко понять изменились они или нет а именно вы не можете взять большое разве считают обильно дерева и что-то в глубине поменять да если вы это делаете вы заходите в глубину создание меняете но не меняете создаете новый объект и все аккуратно связано сверху перепаковки войти в итоге вашим все большое дерево она как бы уже новое то ссылка поменялось на самом деле она по большей части на следует структуру старого дерева но на самом деле оно все равно как бы новой то есть это немножко больше геморроя на изменение на глубокие заменив структуре но зато на этапе рендеринга вы легко можете сразу сказать новый это объект или нет соответственно но у дерева дом дерево от дерева компонентов она зависит не от всей модели целиком от каких-то кусочков мы можем легко просто сравнив ссылки на вот на модель на структуру да иногда мы можем легко сказать поменялись ли данные внутри да то есть мы там смотрим на ноги если ссылка тоже самое значит footer можно не менять footer значит но если функция мы знаем что функция чисто исходные данные не поменялись значит результат рендеринга будет такой же вот соответственно мы можем это это делать это на собственной ленивый рендерингом рендерим только то что нам интересно и тоже не интересно оставляем в покое потому что там опять же потому что функции ссылочного прозрачной мы за кэшированных результат мы уже вызывали рэндами гранж и нет смысла вызывать его второй раз если мы точно знаем что результат будет такой вот эта оптимизация при акте называется shyp компонент апдейт она по умолчанию выключено потому что рик не может ничего гарантировать и она типов типа предназначена для ручного управления если вы точно можете сами это вот такой свойства гарантировать если мы сделаем модель им от обильной мы можем ее включить по умолчанию везде и соответственно все полных сделать полностью ленивая ну и revo рендеринга но просто потому что операция проверки изменилось модель нет очень дешевый если она ему табельный и второй бонус который мы получаем эта история модели соответственно она она симмут обильная мы пишем вот эту вот функцию стрелку до из одной модели в другую при этом старые остается валидная да то есть оно не портится соответственно мы можем просто все предыдущие моделях хранить как я уже говорил и мутабельные структуры эффективно шарят между собой структуру то есть если вы храните историю модели как она эволюционировала от одного шага к другому это все вместе будет занимает ну разумное какое-то место то есть это не там не 5 умножить на размер модели а существенно меньше да то есть но там хороший получается выигрыш потому что каждый шаг это но небольшое изменение и они просто автоматически шарят структуру между собой вот такая вот штука так да да да да да да да это 28 котором получаем если делаем модель ему татами дальше теперь давайте посмотрим как бы как это все выглядит в живом приложение но в собственно в архитектуре приложения да это все были кусочки как это в целом выглядит схема такая мы держим ссылку на одну текущую модель и историю предыдущих моделей мы пишем функцию рендеринга которая там чистая слышно прозрачный и так далее которые рисует нам дом многом виртуальный матабеле так далее и модели мутабельные до соответственно что мы делаем и что мы из этого получаем но мы получаем очень простую реализацию онду виду да то есть вот эти мы просто выбираем любую из предыдущих моделей и говорим теперь рисую ее да и вызываем рендеринг их о прессуется нам нам рисуется предыдущее состояние для этого ну не нужно писать почти никакого кода если мы сразу строили приложение таком ключе нам никакого кода не нужно писать там ну просто нужно пробежать список и выбрать значению модели вот мы можем добавить спекулятивную модель то есть эта штука которая как бы как бы выглядела модель если бы мы что-нибудь сделали то есть допустим мы делаем куда превьюшку до какой-то диалог настроек мы в нем поменяли настройки но еще не применили их и мы хотим чтобы фоне у нас нарисовалась как это будет выглядеть мы собственно можем эти настройки применить к текущей модели но не заменяйте значения до то есть эта модель она но вот у нас просто где-то в в воздухе существует но мы ее пока не съесть не ставим как текущую но мы можем ее уже тренда льда рендеринга все равно откуда пришла модель из истории текущая или и будущее какая то мы можем от рендерить и пользователь увидит как это будет выглядеть без ну про собственно без применения результатов он отказался мы это выкидываем он согласился но окей мы переключаем и так далее вот у меня есть пример векторного редактора 6 запущу vidiq как как это может работать на примере векторного редактора да то есть вот это вот это предыдущее состояние модели на них на ховере собственно рисуется как выглядел выглядела сцена в тот или иной момент времени дальше вот когда рисуется прямоугольник это на самом деле вот та самая спекулятивная модель то есть пока я не отпустил мышку это эта модель не существует но она рисуется как будто с на основании текущей сцена вычисляется там типа как бы выглядела сцена если бы в этом месте нарисовали прямоугольник до но как правило я мышку еще куда-то тащу 100 сцена выбрасывается вычисляется новые так далее кайф здесь как бы в том что функций рендеринга реально 1 то есть на все вот эти опции на рисование on дурь иду на превьюшке истории всегда ровно одна функция рендеринга которая ничего об этом не знаю до этого это очень классно ну плюс реализации on thurs эту там там буквально десять строчек можно делать ещё более классные вещи то есть дополните это все можно запросами по истории то смотрите у нас как я уже говорил это все данные до модель это данные там нет особо некого поведения поведение навешано отдельной сбоку вот но поскольку это данные что мы можем делать данную можем делать запросы по данным соответственно можем взять историю делать по ней какие запросы например мы можем там посмотреть как менялась форма туфель и мы можем сделать превью того как менялась форма туфелек да вот еще у меня еще один vidiq чтобы было понятно о чем я говорю это вектор это редактор прототипирование atomic а я тоже по этой архитектуре построен вот у них есть слайдер показывающий историю на этот мир тоже самое что я показывал теперь смотрите они выбирают два компонента и смотрят историю но только этих компонентов да то есть по сути это они фильтруют историю достают из нее конкретный объект и держит его в текущую сцену то есть вся сцена не откатывается но но история конкретного объекта откатывается вот но такую можно штуку сделать да и как бы красота всей этой штуки ну все это схему вся эта архитектура она в том что не нужно в том что это все очень классно разложено по полочкам центре у нас этот механизм управления моделями и он ничего не знает в окружающем мире вот с другой стороны у нас есть функция рендеринга которая ничего не знает опять же ни о ком другом она знает только что ей можно передать модель откуда модель пришла чё это за модель и в глубоко все равно у нас есть там синхронизации с сервером допустим которые опять же но там какими-то своими путями вычисляет как поменять модель пушат какую-то модель пушки это событие скачивать события неважно рендерингу при этом все равно серверу все равно на то что есть рендеринг модель может работать на сервере без рендеринга то есть кусок нижней можно просто откусить можно левый кусок откусите это будет офлайн-режим да но с правом я там local storage типа каширование vocal столь же и так далее все это друг о друге ничего не знаю это все это прекрасно разнесено и друг от друга от курса но это такое вот на достаточно хорошая для с архитектурной точки зрения свойства которому если мы со стремится вот надо еще как вы невесть хардкор есть ещё несколько примеров то есть вот я про сервер sing начал говорить как можно с ебут обильными моделями сделать сервер send интересный то есть вот это пример архитектуры когда у нас многопользовательский редактор то есть редактор в котором несколько пользователей одновременно работать над одним документом типа гугл докс до или на гугл докс типом вот здесь у нас есть и went sour sing то есть вот эта лента это типа события соответственно модель это свёртка событий всех произошедших событий и она разделена на два кусочка два кусочка это собственно подтвержденные сервером события и локальные события когда пользователь что-то делает у нас все это добавляется в локальный лог справа и рисуется немедленно да то есть это приложение то что ты делаешь сразу показывается на экране ну естественно пользователь это ожидается и так и должно работать классно но это событие про которой еще никто не знает из тех нужно синхронизировать сервером соответственно отдельные параллельно ко всему тому что сверху нарисована происходит сервер сент нужно событий отправляется на сервер сервер подтверждает и присылает обратной только он прислал их обратно мы правую часть выкидываем но добавляем события в левую часть соответственно событие приходят из правого кусочка в левой здесь нам важно свойства что мы можем с любого snapshot во-первых snapshot у нас старой модели не испортился и что мы можем с этого состоянии проиграть событий и вычислить новую модель да то есть здесь опять же не должно быть никаких побочных эффектов не должно быть никаких мутаций вот мы имеем значение мы применяем нем какую-то функцию получаем новые значения вот такой парадигме это работает вот но опять же красота здесь в том что серверную часть можно откусить мы вышли в офлайн но все все прекрасно работает дальше серверная часть может по той же архитектуре пушить события других юзеров это работает точно так же они добавляются сразу вправо в левый лоб и так далее это все будет работать только если вот это все такое нему табельное классное и чистая потому что сколько раз вот эти вот перечисления было делается мы не можем предсказать вот наконец самая хардкорная штука наверное на сегодня это дебаггер с путешествием во времени то есть опять же events are щенка архитектура мы мы делаем такой трюк все внешние события которые происходят с нашим приложением юзер повозить мышкой юзер нажал кнопку сработал таймер пришел я к запрос или еще что-то мы записываем в лоб то есть мы ничего с ними делаем и только записываем их лог пропускаем через одно и то же место давно через ну какую-то ленту в котором мы все это записано и только после этого мы передаем их приложения то есть приложение по факту начинается вот начиная с этого велосипеда и так далее вот пока этого не произошло но смысле до верхней части никакой логики нет это просто ну запись то есть по сути что мы делаем мы записываем реплей сессии происходящих вот и кнопка иф здесь в том что мы во первых этот реплей можем как взять как данные и послать по сети да то есть пользователь работал работал работал у него что-то сломалось он нажимает кнопку и нам приходит вся сессия начиная сначала чем там дело куда нажимал вот и мы можем и воспроизвести у себя на самая классная штука в том что мы можем вот лет нижняя часть она может быть любой да то есть мы можем запустить тот же реплей на любой версии приложения собственно это и не нужно для того чтобы можно было сделать допустим отладку вас есть техподдержка вам пришел баг в виде такого реплея вы думаете что поправили бак запускаете с исправленным кодом тот же самый реплей и смотрите произошла ли проблема в том же месте или нет вот то есть здесь мы разделили наше приложение то есть наши функции да мы делили их от данных которые сверху и соответственно мы можем таким образом сами функций менять в любой момент вот мы на это даже можем более то мы можем это сделать на живом приложение то есть надо же останавливать это не нужно можно сделать взять редактор который по мере исправления кода просто запускает новый год в в среде до исходные данные остаются прежними вся нижняя чепуха каждый раз выбрасывается вычисляется за на вот здесь опять же есть у меня vidiq это димка из языка в которой но именно это и происходит с права увидите сессию где чувак рисуют пятиугольники вот потом ему надоело он нажал паузу он может посмотреть историю данному это уже три раза видели сегодня вот у вас посмотреть историю что происходило в самый кайф что-то он остановился в каком-то месте да и вот здесь у него код программы который работал он сейчас пойдет и начнет его менять и справа будет показываться как в эта программа выглядела если бы там размер пятиугольников был сразу другой до изначально либо как бы она выглядела если бы там другое количество сторон было у пятиугольник ну вот как то так ну вот то есть он на живой программе собственно записанную сессию пири-пири проигрывает это можно сделать вот это работающая штука ну так и наши в режиме демки по крайней мере она работает вот если вы не делайте никаких вот страшных мутабельных вещей и вы четко контролируете где вас данные где функции как они применяются как они же где что меняет желательно место где что-то меняется что было одно но и тогда вот на такие штуки можно сделать так и последняя часть доклада это собственно ингредиенты которые вам нужны чтобы такие архитектуры собирать я думаю более менее понятно но все равно всякий случай перечислю то есть естественно нужен виртуальный дом какой-то чтобы вы могли и не думать о том как от рендерить модель чтобы вы могли из любого места взять и позвать вот эту функцию рендеринга независимо от того откуда пришла модель для этого нужен виртуальный дом до соответственно эта у нас react это у нас virtual дом ну и как бы я не знаю там есть какие то еще поделки и так далее вот это из из большого вот потом вам нужны матабеле структуры данных для чистых функций ничего не нужно для мутабельных структур данных нужна библиотека это у нас соответственно ними не забыл gs это java script версия дальше море джесс это версия из языка кожи с криптона побыстрее но она там типа нечистый java-script да использование java script и раме вот и собственно языке java script клуже скрипт л вот это скрипт это такая вот реализация моделей которая выглядит как база данных запросами так далее но это все равно ему табельное моделька вот отдельно право кожи скрипте немножко по пиарю это собственно другой язык который компилируется java-script у него он достаточно взрослый уже сейчас у них там есть соус лапы у них есть оптимизация google кожи комбайнером у них есть интер об использовании аджарской библиотека все такое вот это классный язык в нем встроенный пирсе стены и структуры данных которые могут лучше чем лимита был джеймс доработают который из которого это все украли и вообще как бы вся вот эта история про которой рассказывала она на самом деле но зародилась из кто же в скрип такой системы то есть там вот эти все штуки придумали там сделали фреймворке которые но собственно позволяют такие штуки писать и так далее но react придумали как бы не там то как совместить реакции мутабельные моделями собственно придумали там вот я туда это все растет вот есть язык это язык который изначально строился под подобную архитектуру он изначально строки чистый и вы там даже если захотите не напакостить и но зато в нем как бы можно вот вот этот вот редактор сделать на уровне языка да то есть поскольку вы на уровне языка знаете что ваша программа ограничена и чисто и функциональная вы можете делать вот такие вещи которые будут работать на любой программе ну естественно более там грязных языках нужно поприседать чтобы это добиться а здесь вот это дается бесплатно вот но у него практически он как бы более экспериментальные на самом деле кожа скрипт на нем есть промышленные проекты но собственно вот набор проектов это сделано по подобной архитектуре get prismatic это такое раз с reader у них интерфейс моно это по сути страничке клики там но перехода между тониками до такой типичный веб-сайт но тем ни менее сделаны по такой штуки а дальше circles это continues integrations это чуть более интерактивный интерфейс то есть там билды это все переключение на то есть это все синглах вечер плетей шанс вот при курсор это средство прототипирования многопользовательская тоесть это графический редактор браузере и атоме к его это опять же тоже графический редактор но он чуть повзрослели помощнее то можно дизайна веб страничек from полноценные дело здесь просто диаграмм вот первые три сделаны на коже скрипте с реактором последняя сделано на java script и имеют угол г.с. да и у меня есть еще небольшое заключение про то что да короче социальное программирование проникла в обычно программирование уже давно функции первого порядка есть почти везде и мутабельные структуры данных так или иначе скоро придут вот она довольно классно мер житься с вершил домом и этим самым sweet showdown да и я думаю что это более или менее будущее того как будет выглядеть интерфейс и поэтому пока не поздно там смотрите и пробуйте и и так далее вот у меня все вопросы некит спасибо за доклад и я на самом деле читал статью да это приехал а у меня вопрос про и он вообще вот радует этот язык а есть ли какие-то реальные примеры baby но вообще можно ли его веб как-то использовать и если реальные примеры вот так прайс приложение такого как вы можно внедрять вот еще гланда к вопрос как можно внедрить функциональное программирование в enterprise прийти к руководству и сказать ребят это крутая тема давайте использовать на как объяснить да про язык я не знаю ни одного примера то есть у них есть библиотека для работы с ними изначально он был для рисования на канвасе не говори так далее сейчас у них есть работа с виртуальным домом через вирджил дом и mercury вот на нем можно делать сайты у них есть примеры но приложение на нем не делают насколько я понимаю он еще экспериментальные вот если бы и знал кино примера я бы обязательно назвал вот то есть в этом в этом смысле я даже не буду обещать что у них все получится я не знаю получится или нет покажет сколько уже получилось вот как внедрять в enterprise на фиг его знает как бы ну надо как-то убеждать показывать примеры там проектов успешных и так далее то есть вот все эти ребята которых я здесь перечислил да я еще несколько примеров говоря не привел у них как правило есть статьи как мы как как мы делали интерфейс вот какая у нас архитектура и как у нас все классно учусь они все в один голос говорят да это классно этого прощает и бла-бла-бла но это вот со стороны убеждения как здесь у таких штук ну как правило только условие успеха успеха но их мало как бы ну вот не знаю как только ждать спасибо за доклад у меня два вопроса первый что все-таки с монадами и 2 не очень почувствовал личная как все вышесказанное противоречит л.п. все то что вы говорили скорее больше похоже на подход к построению какие-то подходы к работе с данными в приложений что в принципе не противоречит опыта немножко другое наверное или я чего-то не понял да на с монадами ничего я не знаю она не в хостеле вот это такая была замануха проект противоречит в.п. на самом деле как бы у меня не было понято показать что это именно противоречие ства п я сильно об этом не думал то есть как бы в моей практике от а.п. ничего хорошего я не видел как бы то есть я не вижу в чем его бонус но я вижу в чем бонус разделения функции данных до как минимум в том что вы можете данные си реализовать стандартно не нужно писать для этого какие-то функции и так далее можете пересылать по сети и можете писать ну как бы взяв данный написать какую функцию которая с ними работает которая вообще к тому откуда они пришли и как они хранятся не имеет отношение вот в.п. это как правило как правило в.п. если мы делаем ему табельное апа да то есть но так не делают обычно есть объекты у него есть методы которые сами этот объект и меняют и это вот как раз неприятно то есть они портят существующий объект так делать не надо вот этого тэгу плохие стороны есть спасибо друзья у нас осталось совсем чуть-чуть времени для ваших вопросов сколько 323 но в любом случае вы всегда можете подойти к никите в кулуарах а сейчас давайте еще парочку последних вопросов потому что лари вчера был доклад от бориса к бубновского может вы слышали он просто рассказывал о быстром рендеринге и там он указал что virtual дом достаточно такая ну штука не быстрая и влияет на производительность что вы об этом думаете вообще добра я слушал доклад на самом деле как бы я здесь не защищают именно виртуальный дом то есть здесь важно что что нам важно и то что мы можем в любой момент взять модель от рендерить и независимо от того как она туда пришла да вот если это свойство можно получить без вертова виртуального дома зашибись как бы классно вот единственное чем мне нравится виртуальный дом наверное это тем что можно на нем писать дюне теста я не знаю как в реакции вообще распространено или нет но в принципе мне нравится концепция того что можно за рендерить дерево но никуда его не применить и сделать по нему теста типа проверить какая у него структура но никуда его не как бы не сложить вот как бы если ты делаешь библиотеку которое требует чтобы было обязательно глобальное дерево которое она испортит если ты вызовешь вот такой как бы начинаются проблемы пока ты можешь любой модели создатель но никуда я не применять пока ты можешь любую модель от рендерить вот она дает кучу классных свойств которые но я как бы не готов пожертвовать ради того чтобы получить быстрый рендеринг как бы ну да можно сделать рендер быстрый но как-бы вроде-бы react сейчас достаточно быстро для того чтобы делать там 60 fps на мобилках и как бы куда вам больше да это это как бы старая штука там типа и мобильная структуры данных медленней и медленней но кот получается разумным как бы вас не взрывается голова и вы гораздо меньше багов делайте вот и ну это трейдов как бы то есть каких-то местах надо будет выкинуть описать руками но в большинстве мест в 90 процентов кода может выглядеть так может использовать виртуальный дом и быть достаточно быстрым и это можно сделать силами там одного человека можно написать большое приложение за месяц очень такое но это гораздо важнее спасибо 654 у вас презентации был слайд с перечеркнутым телефончиком и вы очень ловко вот так протиснулись а можете рассказать об ограничениях применения данной архитектуры по памяти по производительности до мобильный телефончик волтер черт это типа такая метафора что на мобильниках не любят веб-приложения любят нативные приложения вот то есть это не то что их нельзя сделать да этот тип одни любят вот ограничение ну наверно там как бы это все генерит какое-то какую-то нагрузку на garbage collector то есть опять же надо вчера докладе говоришь это виртуальный дом лишняя пара менять занята garbage collector трудиться и так далее вот это в принципе верно ну я не знаю как вы но я не могу сказать насколько это критично принципиально для новых приложений может быть да может быть не откажете узнай здесь это приложение на у нас есть еще в принципе возможность задать парочку вопросов так что если у вас еще есть вопросы то прошу окей нет вопросов спасибо никита большое мне кажется мне кажется у тебя была очень классная презентация с множеством интересных картинок необычных подходов к объяснению спасибо"
}