{
  "video_id": "K7ffVRGVWR0",
  "channel": "HighLoadChannel",
  "title": "Поиск паттернов (Data Mining: Pattern Discovery) / Константин Игнатов (Qrator Labs)",
  "views": 1051,
  "duration": 2828,
  "published": "2018-08-16T04:38:01-07:00",
  "text": "ну что такое паттерн паттерну это какая-то некоторые повторяющиеся структур данных что то такое повторяющийся ваших данных что представляет какой-то интерес интересы ну обычно это значит что этот паттерн достаточно часто встречается либо это значит что есть какие-то другие критерии например там стоимость этих паттернов должна удовлетворять какому-то значению быть больше или там меньше чего нибудь ну конкретно что это значит мы сейчас не можем нормально объяснить но чуть попозже я думаю вы поймете ну вот давайте на каких-то примерах такой самый классический пример ритейлер рейтинговая сеть или магазин может иметь желание размещать товары которые покупают одновременно то есть за один поход магазин в одном чеке рядом друг с другом чтобы люди могли их сразу взять подобрать или наоборот растягивать их в цепочку по всему всему всему магазину чтобы люди приходили и проходили все возможные вообще места собирали все что им не нужно ну и в любом случае может быть интересно собрать все чеки и посмотреть что чаще всего покупают вместе отсюда известная байка про то что вот там памперса и и пиво неожиданно для всех как казалось часто покупают вместе хотя вот вроде категория абсолютно разные даже не суть почему и там много пытались это по-разному объяснять но неважно другой пример ну например есть страничка и веб-аналитик может быть заинтересован в том чтобы узнать какие места в этой страничке чаще всего посещают подарки чаще всего кликают пользователя при этом про и минивен интересует последовательность действий а какие-то промежуточные там движения мыши какие то может быть даже оставленные комментарии выделенный текстом это может быть их не интере мне интересно несмотря на то что записано в логах соответственно имеется большая зная записи логов подобных перемещений из них нужно эти такие основные вехи часто встречающиеся паттерн и последовательности на оля отлично ну или честно часто встречающиеся значит подпоследовательности в на таких страничкам ну или например у нас вообще есть вот прям сугубо набор строк и нас интересует в нем некоторые так нас интересует в нем некоторые наиболее часто встречающиеся по строчке ну давайте чуть более формальным опишем что имеется ввиду то есть вот у нас есть например набор множеств и нам нужно найти такие множество которые являются под множествами у многих из этих из этих множеств то есть пример такие например из списке чеков в чеках есть товары или это может быть какие-то списке бинарных флагов нам нужно ввести найти наиболее часто встречающееся в месте бинарные флаги другой пример это могут быть подстроки собственно говоря причем это не стоит пользу путать задачкой найти наиболее общие наиболее длинную подстроку среди к строк то есть наши строчка может не обязательно быть во всех поттеров просто должны достаточно во всех исходных данных просто должна достаточно часто встречаться или например под последовательности то есть ну последовательность от строк отличается тем что строку мы не можем порвать подпоследовательность может разрываться на низ кусочков все там промежуточный может происходить вне паттерна другие примеры это например графы большой граф может быть в котором нужно найти что то это может быть такой граф какую модель днк или модель в в паутины или наоборот может быть относительно небольшое количество небольших графов но большое количество там примеси пользователь визуализированы гк огров и нам нужно определить что похожего есть в этих сессиях ну существуют и другие примеры это можно и автоматически сгенерированы изображение рассматривать и временные ряды но тут речь идет именно о том что что то сгенерировано автоматически без особого шума и речь идет о том чтобы мы 0 вот где вы выводу строго по инструкции работает и мы пытаемся определить собственно discovery того что как что в этой инструкции написано что записано в алгоритме ну давайте рассмотрим пример такой вот с очень простой с паттернами под множествами то есть nude нас дана табличка такая в ней например есть элементы справа это последовательность мину например что может быть записано в чеках до номера товаров в чеке она за наименование товаров один чаще всего приходится в данным с данным алгоритмами проставить самостоятельно но с новым случае с чеком это могут быть например номера чеков то есть слева в колонке номера чеков справа в колонке список товаров которые в этом чеки были ну попробуем найти паттерны которые встречаются хотя бы 2 раза то есть в бою строго больше одного первое что мы сделаем в этом алгоритмы мы перевернем эту табличку то есть если у нас было сначала слева номера чеков то теперь у нас слева номера или на наименование товаров а справа все эти чеки в которых эти товары были и в принципе это уже начало нашего ответа то есть паттерны длины 1 здесь уже нас устраивают и вас единственное нам нужно удалить паттерн c потому что он встретился только один раз ну и вот первая часть кусочек от этого совершенно тривиально получено но дальше мы можем сделать сэлфи jojen этой табличке то есть по сути перебрать все комбинации посчитать пересечение множеств в каждой строчке это таблицах и получить паттерн ее длины 2 то есть два элемента 2 товара который чаще всего пока часто достаточно часто покупают вместе аналогично соединяю первые и последние элементы дело сел в join можем получить подобной длину 30 патронов длины 4 в данном дату с эти просто нет такой игрушечный datasette на думаю в принципе какое-то общее представление должно появиться о том как это все работает формально мы решили задачку то есть вот мы не можем перечислить все паттерны и написать сколько раз они встретились но это немножечко избыточный варя избыточный такой ответ если присмотреться и мы об этом ещё потом поговорим если визуализировать то что мы сейчас сделали то можно записать все паттерны которые мы нашли и все чеки в которых они встретились вот в такое дерево ну и соответственно можно перечислить работать с этим мы берем дальше но главное что мы здесь какое наблюдение есть мы старались максимально избегать лишних действий это такой ключ который мы будем сейчас через какой-то время еще рассматривать и разворачивать соответственно вот если записать ответ то тоже визуально тут он будет примерно такой я хочу показать что если например поддержку у нас было бы три да то есть выше то нам нужно было бы обойти только пять узлов всего и при этом три паттерна были бы в ответе то есть намного сильнее намного меньше нужно было бы проделать работу для того чтобы получить ответ из по сути мы перечисляли все возможные паттерны пока не остались только заведомо red китай заведомо не интересны для нас и вот о перечислении нужно наверное немножко поговорить то есть давайте еще более простую задачку рассмотрим значит такую ситуацию есть поиск паттернов подмножеств четыре базовых элемента abcd вообще какие возможны паттерны в этой задаче мы поскольку это подмножество поскольку конечно количеством базовых элементов мы вообще все можем перечислить вот они все для того чтобы это сделать ну проще их сортировать по алфавиту но абсолютно в принципе это непринципиально но тем не менее если это сделал то результат можно визуализировать виде такого дерева и благодаря сортировки мы можем построить дереву паттернов в котором каждый поэтом встречается ровно один раз и не смотря на то что паттернов есть podbot паттерны может быть супер паттерн и мы имеем у нас нас интересует только один родитель везде ну вот просто благодаря сортировки мы можем убрать лишние связи сортировка по алфавиту базовых вот этих элементов возможно естественно не всегда но мы можем всегда придумать какое-то правило по которому скажем вот эти элементы должны теперь это вот этими чуть посложнее предположим что у нас не множество а подпоследовательности ну на самом деле со строчками будет примерно то же самое то же самое четыре базовых элемента какие возможны паттерн и ну здесь ответ то что их в 300 бесконечно много но это счетное множество и больше того вот если перечислять примерно вот таким вот образом то мы даже можем сказать сколько патронов находится на каждой такой строчки несмотря на то что строчек в принципе бесконечно много ну и здесь нужно отметить что в принципе упорядоченными паттернов com вроде бы как не особо помогло но на самом деле в будущем все таки это даст о себе знать опять же если это визуализировать ну примерно вот так выглядит то есть первый этап почти любого алгоритма поиска патронов это порядочек pattern и придумать способ поповым подобно вот дерево бывает очень большие трудные пространству паттернов в которыми трудно что-то придумать но чаще всего все таки что то да можно но иногда они начинают разрастаться слишком экспоненциальное тогда в конце доклада я таких вещах немножко еще поговорю ну вообще нужно иметь ввиду что все-таки данных у нас конечное множество и поэтому в чисто формально конечно всегда у нас будет конечно и пространству паттернов хотя на самом деле оно может быть очень очень большое но множество можно рассматривать кстати говоря как был на связанные графы без повторяющихся узлов и эту идею очень легко распространить на графы уже не полна связаны тоже без повтори без повторяющихся узлов ну и понятное дело что чуть постепенно усложняя модель можно получать все больше и больше и разрастание этого дерева и дает именно пространство то есть здесь между паттернами можно определить расстояние и для него будет выполняться правило треугольника что мы начать вообще делаем в этом во всех этих факторах во всех этих алгоритмов то есть так или иначе мы занимаемся обходом дерево дерево паттернов они все алгоритмы отличаются друг от друга только тем как конкретно мы это делаем в каком направлении в глубину в ширину когда мы читаем данные какие мы дополнительные данные храним в узлах дерево ну то есть например в примере который мы рассматривали это вот был дерево подмножеств вы его видели каждый уровень был описан по сути отдельной табличкой join самой собой этой табличке давал нам следующий уровень то есть вот так вот мы его обходили ну и по сути это разновидность обхода дерева в ширину просто немножко такая слишком слишком в ширину что ли при этом тот пример который мы рассматриваем и да мы прочитали там табличку только один раз в узлах то есть при помощи вот этой вспомогательной таблицы хранились так называемые проекции данных то есть то есть только то что относится к этому паттерну ну и размер вспомогательной таблички в продвижении вниз принципе уменьшается от уровня к уровню потому что все меньше и меньше остается элемент давайте рассмотрим основные проблемы что ли сложности с которыми приходится сталкиваться при разработке алгоритмов при их реализации через какие преграды вовсе приходится пробираться ну вот первое будет при сложность такая даже просто перечислять паттерны может быть сложно дорого и долго вот я нарисовал раньше вам дерево сразу но совсем не факт что мы его сразу вот имеем в руках готовым сна может быть нужно прям с шаг за шагом мы идти по пространству патентов особенно если мы это делаем в отрыве от данных и при этом приходится каждый раз там считает вообще если этот паттерн в данных нет сколько раз он там встречаются и даже если представить что вот все эти процедуры нам даются за о от 1 все равно им приходится сгенерировать огромное количество патронов который совсем не факсу даже в памяти у нас могут влезть мы представим например что базовых элементов то что у нас было раньше abcd 4 штучки для пуска их 100 штук насколько потенциальных паттернов длины 2 а сколько всего всего 20 то есть ну прямо совсем плохо а если не с множествами работать с последовательностями или со строками естественно на практике это нужно как-то оптимизировать и вот прям очень медленно показывают анимация что вы понимали что это очень тяжелая процедура принципе можно что делать можно посещать только те узлы которые соответствуют паттерном который хотя бы потенциально мол могут быть для нас могут присутствовать в данных на а еще лучше чтобы они хотя бы потенциально были интересными для нас мутном часто встречающимися соответственно всего этого есть либо эвристики либо четкие определения как это сделать ну во вторых можно попробовать не генерировать паттерны и вообще вот эти просто придумать такую хитрую структуру данных чуть-чуть мы на него взглянем которое занимается этим за нас ну и в любом случае чисто формально мы обходим пространство данных мы обводим пространство паттерну в целиком просто ну грубо говоря можно сказать что какие-то элементы мы проходим муза нулевое время в чисто формально можно всегда сказать что конечно мы проходим одно из одной из возможных решений это проблема как раз такая структура которая называется fp дерево у нас нет особо времени разбираться как конкретно она устроена но алгоритмы которые построены на ее на ее применение то это в основном и тфп гроф и префикс пан так называемые позволяют не проходили генерировать эти паттерны и они хранят вот там подобную структуру в каждом углу возле сообщает соответственно на верхнем уровне вот для нашей задачи это будет прямо на вот ровно такой узел и дальше очень быстро из-за этой структуре за этого узла из этой структуры можно получить в такую же структуру для всех под вершин который находится ниже в этом график ну что будет например если у нас все паттерны и одинаковые да то есть вот есть один большой паттерну в данном случае быть например там 10 элементов в ответе тогда будет слишком много избыточных данных с этого другая такая проблема и мы с ней уже даже столкнулись в пример которые рассматривали а именно если вот посмотреть на например на паттерном беды е но мы видим что у него поддержка 2 но мы сразу можем из этой уже из этой информации сказать что б д б а б д е встречались тоже минимум два раза каждый это значит что в принципе ну тоже самое жажда это значит что в принципе если мы уберем все кроме вот длинных этих паттернов то что подсвечено жёлтым то мы не потеряем никакой информации то есть просто мы договоримся что ну вот если есть длинный паттерн мы это будем убирать ну и а если мы будем убирать то что подсвечена жирным да то мы потеряем часть информации но мы не потеряем ту информацию что это эти патроны для нас интересно то есть тут уже простой вопрос нужны они нам или нет соответственно в первом случае когда мы убираем паттерны с совпадающими аккаунтами это называется закрытый паттерны а когда мы убираем все это называются максимальные батырами ну с другая проблема с примером который мы рассматривали состоять потому что нам дан да с одной стороны нам не нужна и сканировать все данные с другой стороны по большому счету мы их поместили все в память и какое-то время с ними в общем-то работали дауда уменьшается размер потребляемой памяти свою от уровня к уровню но все равно он довольно большой возникает вопрос можно ли как-нибудь уменьшить эту потребление ответ что ну да можно например можно вместо того чтобы хранить список тех чеков которые в которых этот паттерн был список чеков в которых вы не было ход такой нетривиально немножко но он позволяет сделать интересную вещь он позволяет нам вместо пересечения множеств вниз когда мы идем считать объединение это в частности можно реализовать эвристическим можно реализовать при помощи вероятностного алгоритмы эпсилон-дельта аппроксимации то есть хранить очень небольшое скетч данных которые как раз будут и рассказываем описывать то что нам нужно только нужно иметь ввиду что в случае с эпсилон-дельта аппроксимации нужно быть очень аккуратным потому что дельта это вероятно это вероятность того что мы ошибёмся в этом алгоритме и ну она будет присутствует в каждом узле по сути это нужно их будет перемножать то есть нам не не так чтобы уж сильно мы сэкономим память потому что нужно будет выделить хоть и конечное количество памяти но довольно большое и с другой стороны нужно будет поддерживать каким-то образом поддер объединение этих множеств каким-то образом поддерживать случай когда мы обрабатываем малое количество множество к нам нужно посчитать сколько хоть элементов в небольшом множеством но следующая проблема состоит в том что мы когда обходим данные ну как бы все алгоритмы как правило описываются рекурсивно и с рекурсии они то существует ряд проблем и главным образом в том что если муж мы например за asked жалели recore рекурсивно обход всего дерева каким-то образом там и с ней ничего не можем сделать но поэтому нам приходится иногда задумывается о том можем ли мы как-нибудь что то с этим сделать ну очевидно решением привести и курсе в стек стык потом можно привык превратить например вообще в очередь задач и эту очередь задач потом можно что-то с не делать например отменяет задачи по мере необходимости ну то есть то что я здесь называю модифицировать так то есть нам потребуются некоторые дополнительные средства в них мы сейчас немножко поговорим ну вот что такое что здесь подразумевается под стеком начинаем мы с того что в стеке находится изначальная задачка это задачку мы выполнили вытащили и поместили 4 новые задачки в стык обойти посчитать вот эти паттерны потом мы вытаскиваем один из одну из этих задач например а остаются bcd по-прежнему в стеке и вместо них мы кладем вместо а мы положим еще четыре задачки потом то же самое там вместо еще 1 минус 1 плюс 2 задачки да и в конце останется в последний ряд уже новые задачки не будут появляться но тем ни менее какие-то задачи могут быть все еще решаться и довольно тяжело на последнем вот этом ряду включаю какое-то сканирование исходных данных которые мы вообще говоря хотим избегать в том числе потому что можно нужно модифицировать какой-то процесс работы алгоритма так чтобы уменьшить количество узлов в общем-то я хочу еще показать наглядно что для чего нужна в общем-то модифицировать так вот эту картинку я вот уже показывал что есть проблемы с большим количеством паттернов на если у верне если паттерн 1 но он длинный то есть мы причинили рование во-первых если мы не не генерировать закрыты потому мы сгенерируем в данном случае в 2 в 10 патронов никто не сможет переварить просто никакой человек все-таки задачи обычно решается для того чтобы человек какой-то посмотрел и шут сказал по этому поводу с другой стороны но это просто очень тяжело поэтому мы можем обратить внимание на тот факт что в тот самый момент как только мы увидели bc в паттерне a pc если б c&a бойца имеют одинаковую поддержку ну или там максимально неважно то в принципе все что находится ниже дерево под bc нам у нас уже не интересует все эти задачи если они были за соски джиган и мы можем отменить или можем их ну там не задание выполнять то есть тоже самое справедливо для cd для следующего элемента и вообще говоря для всех остальных паттернов и ну если у нас есть один паттерн поэтому очень часто мы в результате хотим и сделал так что вы если у нас есть один потому мы хотим вот прямо напрямую его пройдя в глубину найти все остальное не делать поэтому существует эвристику упорядочивать элементы не по алфавиту или дома бы как а по оценке некоторые их чистоты независимой давайте поговорим еще о том как что мы можем в принцип какие ограничения на гора накладывать на паттерна который нас есть ну естественно ограничение это поддержка то есть сколько раз должен встретиться паттерн в наших данных но мы можем принципе добавить любое другое ограничение например что у паттерну должно соответствовать определенную стоимость us товаром это понятна идея да что каждый товар имеет стоимости там и может быть заинтересованы только в паттернах которые суммарно имеет стоимость на меньше чего-нибудь или в которых есть максимальный товар мы с максимальной скоростью больше чего-нибудь или минимальной стоимостью мы с чего-нибудь но вообще говоря мы можем работать с некоторой функцией факторы в принципе просто принимает на вход данные и паттерн и отвечает нам берем мы ее или не берем берем этот узел мы берем и здесь вопрос сколько такой если мы знаем значение этой функции для длинного паттерна ну например для pc можем ли мы что-нибудь сказать о бу еще более длинным паттерна типа abcd ну если можем то все остальное абсолютно такое же да то есть вот например пример где как раз стоимость пакетов я указываю ну и мы хотим найти вот паттерн и там больше 6 я написал здесь что мы пройдем часть часть этого дерева не все и значительную часть в данном случае примерно половину мы можем игнорировать потому что как только мы дошли вот в данном случае на 2 уровня но там кроме одного паттерна дальше мы можем ничего не делать наш мы видим что любое увеличение этого значения каунта стоимости будет уже выше нашего условия соответственно мы еще больше можем сокращать дерево если у нас есть дополнительные условия с нашей стороны и заранее их использовать при обходе этого дерева ну конечно гораздо быстрее чем если мы сначала найдем все возможные паттерн и а потом из этих паттернов и удалим те что не соответствует нашим критериям но и в то что я рассказал это по поводу сортировки паттернах этого некоторые такая в листика да то есть некоторый способ как что можно сделать для того чтобы чуть там побыстрее работать и вот про эвристики я бы хотела немножко поговорить потому что это все таки то что все что я сейчас описал он довольно просто когда мы сталкиваемся с данными на практике приходится подумывать каких-то очень странных вещах и вдруг может оказаться что пространство так просто не обойти и еще что-нибудь еще что-нибудь ну и надо надо искать какие бывают основные эвристики ну 1 эвристики касается набор вести касается данных во первых можно если мы работаем со строками то вместо строк мы можем их таки не zero вать и работать с ними как с последовательностями то есть у нас увеличивается алфавит но количество возможных паттернов уменьшается то есть если мы грубо говоря знаем что вот там есть здесь я работаю с строчками user agent of но если на знаем что ну там слова mozilla будет встречаться очень часто так а зачем нам каждый раз находить этот паттерн зачем нам каждый раз находить ipad строчку вместо этого можем сразу таки не zero вате потом если нам нужно все-таки патроны типы строк склеить их проверить что они там не прерываются и так далее аналогично для последовательности если у нас есть последовательности и в них малое количество элементов а при этом может быть они и дальше сами довольно таки длинные то мы можем вместо того чтобы взаймы работать с последовательностью напрямую работа с ними как с множествами о последовательности потом еще одним сканированием данных восстановить ну или то же самое по большому счету с представлениями последовательности виде графов переходов потому что это позволяет избегать не то что избегать гораздо легче работать со случаями когда есть много повторений да да если весь какой-то элемент в последовательности он там часто повторяется и нас не особо может быть интересует 10 раз он повторился 20100 ну или даже может быть интересует но это немножко другая история просто мы тогда должны в модели данных это представить другой другой обрести к касается выбора упорядочению выбора при котором выброс способа которым мы упорядочиваем паттерн и то есть иногда проще всего это сделать по популярности но если мы работаем с русским языком дату но мне нужно ничего сканировать для того чтобы сказать что с большой вероятностью буква й будут идти после буквы о несмотря на чтобы алфавита не в обратном порядке блюда из игроков потому но посмотрите на клавиатуру на другой стороны принципе нагулялись у нас есть какой-то каталог товаров да и какие товары могут входить в разные элементы этого каталога или если у нас есть набор символов и этих символов и там про символ можно сказать что он альфа numeric что он числовое что это число или что это они число а например просто символы от 0 до 127 там что-нибудь то в принципе нас могут интересовать паттерна включающие либо все эти категории либо их некоторые обобщения это нужно для того чтобы это эти обобщения правильно грамотно построить нам придется сесть и подумать о том как лучше это сделать заранее прежде чем запускать алгоритм но это все равно будет его листиком потому что никаких гарантий того что это будет работать даже для конкретного случая мы представить не можем ну и интересно еще нюанс в туристическом обходе дерево что ещё можно сделать можно вместо того чтобы эта ситуация что у нас есть в данных какой-то паттерн колоссальный длины вот просто очень очень очень длинный и может даже не один но тем ни менее нам их нужно найти все что я говорил раньше в этом случае какие бы там оптимизации мы не пытались сделать работать не будет ну просто просто потому что если в тупую даже не очень в тупую проходить по всему дереву ну к сожалению в рано или поздно мы упремся в какой-нибудь ограниченный ресурс поэтому приходится вот прорываться из этих ограничений оставляя ошметки может быть каких то данных них не совсем правильные ответы ну например как например мы можем взять и попробовать попасть в глубину дерево как можно быстрее для этого мы можем взять и от сэмплировать данные и в сэмпле данных есть у нас часто встречающийся поэтому-то он и в сэмпле данных будет скорее всего часто встречаются часто встречаться но все-таки скорее всего не факт поэтому все-таки то эвристик а имея этот паттерн можно его разложить на пад паторны ну то есть мы понимаем как это устроено и этим под паттерн им потом можно использовать для того чтобы из них составить паттерн в другом порядке или поискать рядом с ними паттерны и попал попробовать попасть другую часть дерева до в каком-то смысле этот подход должен вам напоминать если вы знакомы с генетическими алгоритмами то есть очень такой подход когда мы просто пытаемся найти вы прям вот насколько можно глубоко то что нужно но если паттерн длинный часто встречается это будет работать ну в конце немножко я бы хотел поговорить о том что есть в open source то есть какие средства можно использовать для того чтобы попробовать что-то поделать руками посмотреть ну если вы знакомы со spark то там есть две функции соответственно тигров и в префикс пан который прям по большому счету выполняют ровным счетом то что мы описывали префикс пан граф мы не рассматривали но в принципе вода не находит именно все патроны вспомни закрыты насколько помню если вас интересует попробуйте это посмотреть сгу и то есть века java приложения которое в котором это реализовано чем там чуть побольше вариантов паттернов ну если вы работаете с языком программирования are the у вас есть модуль и rus совершаете на вкус который реализует очень много в том числе поиск закрытых паттернов поиск максимальных и так далее есть его некоторый порт в python ну проблемы с тем и с другим общем-то в том что внутри этих алгоритмов трудном залезть то есть приходе если вам нужно что-то вот реализовать какие-то из тех ограничениях которых я говорил то придется посидеть и скорее всего либо переписать всю целиком либо взять исходный код что туда добавить не так просто пробросить свои условия прекращения обхода дерева еще я хотел бы отметить блин программу тоже у нее сгу и абрам это больше такая вещь ориентированная на процессы то есть в поиск не просто патронов такой некоторый поиск некоторые бизнес-логики из бизнес логов скажем так ну тем не менее там есть много интересных штук просто посмотреть поскольку там и сгу это все можно увидеть визуально поиграться если же говорить о его основной модели до который там работает у они используются там используется в основном сети петри и их реализация есть в python пакете поэтому cx который как раз позволяет работать с сетями петри при помощи степи ты просто можно описать довольно интересные паттерн и включая практически все что угодно то есть зависит от а только вошла в воображении и того насколько хитро вы сможете обойти пространство попер на ну и также последние две библиотеки которые часто приходится применять на практике это едва и гипер скан в них есть соответственно во возможность проверить паттерн на то что он находится не брат проверить ни один поттер против одной строке поверит сразу много паттернов против либо 1 либо даже многих строк сразу там в скиппер гипер сказано это чуть побыстрее реализованный но там при этом реализованы кубики определённого рода но тем не менее если вы реализуете своими силами поиск паттернов вполне возможно что с этими задачками вам придется столкнуться с этими библиотеками ну или чем-нибудь из-за этого перечисленного на самом деле не только из-за этого вам придётся столкнуться так на этом у меня все если есть какие то вопросы у нас есть 5-10 минут домой много спасибо большое очень какой момент при обходе дерево ну все строится на том что от вас скотт был такое замечательное показывает в строении эвристик эвристические алгоритмы то есть а вдруг у нас если цена больше шести или там еще какие-то условия но у чем собственно формируемое может быть есть какие-то алгоритмы которые позволяют допустим но не знаю там какой-то кэширование там какие-то под деревьев и прочего что то что позволяет нам быстро дойти допустим отсюда до суда или там пройти вот дерево к что-то стандартное что можно применить более широким там каким-то алгоритмы хотя бы даже на примере этих вот срок ну и честно говоря не очень понял вопрос верного имеете ввиду можно ли не использовать в листики но при этом как-то обходить быстрее с универсальный holistic не бывает ну то есть реально для каждого для вашего типа данных скорее всего вы даже сами знаете эти эвристики да и или вы можете их очень легко интуитивно понять как только попробуйте набросать на бумажке вот этот построение этого дерева но какого-то универсального совета который будет работать для всех возможных типов данных со всей во всех возможных условиях конечно очень трудно вреда представить себе такое спасибо за доклад вопрос достаточно простой сколько три вопроса сколько сколько у вас было данных максимум который вы использовали при таком подходе то есть именно размер возможно там количестве строк или байт затем какой какая длина была максимальных паттернов которые вы находили и количество которое но было разумно которые уже непосредственно человек смотрел оценивал спасибо ну смотрите мы используем это для задач раза разных немножко задачка но в основном например у нас есть все-таки набор строк и при помощи тут оптимизации там мы с ними работаем по этому в то что касается длины по терну мы все таки стараемся при помощи разумного выбор модели или разумного и просто определения того как работы толкин и не делать их слишком длинными просто в этом для нас нет смысла что касается количества всего данных ну я думаю что это порядок несколько гигабайт несколько сканирования несколько гигабайт вот во всем вошел и сел все остальное в общем то решается именно тем чтобы выбрать правильно модель чтобы все таки не просто не создать по себе проблем заранее ну и опять же количество патронов мы тоже регулируется через выбор просто-напросто значение нужно отметить что это это очень интересный вопрос про количество паттернов он интереснее чем предыдущие два из тех трех чтобы задали самые интересные как раз про количество патронов потому что он поднимает вопрос что такое интересный паттерны и паттерн интересный мы не можем ответить на то что такое интересным паттерн если не поговорим о том а зачем мы их ищем как только мы говорим много то мы их ищем для того чтобы продавать больше товаров но нам она у нас становится интересно нам нужно значит потом эти паттерны будет сгруппировать по ценовым категориям один одно условие тут мы можем сделать такое количество патронов чтобы в каждом из там нсн кластеров которые кто-то либо нам скажет либо кажется нам на разумными появился разумное количество патронов либо нас могут быть условия не знаю сколько что сервер должен выдерживать вот просто определенную нагрузку ну и и мы должны будем уложиться просто в новое то это ограничение по пасибо за доклад очень интересно вопрос следующий вопрос следующий насколько я понял я знаю про эти алгоритмы они все алгоритмы и номере если у вас какие-то оптимизации и используйте когда данных очень много и они не помещаются памяти там используем жесткого диска тоже как только используя жесткий диск таких алгоритмов насколько я помню производительность падает очень быстро значит что касается in memory ну нужно отметить что не обязательно скажем так то есть до производительность падает но в принципе эти алгоритмы не определены так что вот обязательно все должно быть памяти из когда мы говорим например вот попова доклад да и вот его разновидности ну не что нам не мешает делать иметь вот эту временную в табличку записанный на диск то есть это все равно будет просто несколько раз сканирования всех этих данных с диска и там именно вот этим этим количеством моим из этого конечно мы будем понимать сколько времени будет работать алгоритм сколько он у нас вызвали займет ресурсов и и а в данном случае друг другие подходы составляет например в том чтобы мы делали сэмплирование данных искали паттерны в нем ну это немножко более сложный вопрос потому что там очень легко пропустить очень и тяну для нас интересные паттерны и то есть можно если мы возьмем сэмпл данных которые помещаются в памяти то мы вполне можем может так оказаться что мы просто пропустили интересных паттерн и поэтому он там приходится делать интересную штуку а именно уменьшать поддержку уменьшать какие-то критерии интересности для нас и там определяется специальный так называемый border который позволяет нам это border это некоторых характеристика для ответа вот мы по сэмплу нашли ответ и это и из тех данных которые мест в ответе то есть сколько раз встретился каждый из паттернов мы можем например получить информацию о том сколько находится можем в общем очень грубо говоря мы можем понять потеряли ли мы данные или нет вот что для и для этого нам нужно будет сделать только два обхода данных первый раз причем сэмплирования второй раз полный но там проблема в том что если за второй подход данных мы обнаружили что мы не решили задачку то есть мы выходим за этот border и могут существовать паттерн и произвольной длины которые мы не нашли там ничего с этим не можем сделать крым как вы попробовать запускать этот алгоритм еще раз ну и существуют разные другие вещи они просто более такие сложные больше подойдут времени на обсуждение спасибо хорошо образ спасибо большое за доклад можно вопрос по поводу обобщения мы рассматривали только ситуацию когда на множестве элементарном виде но строгая равенство неравенства можно ли попробовать в общину ситуацию когда есть некая функция подобен например подгузником и пиво ведь наверное часто еще покупает коктейль отвертка и подгузники и вот в каком то смысле это можно считать одним паттерны в каком-то двумя разными вот если есть некая соотношение подобие между элементами но не строго равенство можно ли как-то обобщить упомянутой методы эвристики спасибо ну смотрите здесь можно на мой взгляд работать в двух направлениях первое в том чтобы применить ту эвристику которая говорил то есть мы классифицируем все элементы которые у нас есть в разные категории видео выбираем те категории которые важнее других важнее значит они будут идти перед ними вот в этом дереве и соответственно мы тогда будем находить такие паттерны ну и никаких проблем в этом нет 2 вторая часть вопроса наверное состоит в том что если мы находим паттерны которые в каком-то смысле похожи друг на друга нам хотим ли мы их объединить или хотим мы их оставить их по отдельности ну это тоже очень сильно зависит от конкретной задачи можно ли это применить на уровне обхода дерева заранее ну пожалуй что только если применять вот эту эвристику на мой взгляд так хотя может быть можно придумать и если попробовать спускаться вниз здесь если мы можем можете вот эту функцию подобие до определять и определить именно так чтобы добавляет четвертый элемент к трем имеющимся в паттерны мы могли что-то сказать про эту функцию подруга либо что оно гарантированно увеличится либо что наговорите равана уменьшится ну и соответственно если у вас условии что она должна быть меньше заданного числа и оно гарантированно увеличится то все работает но есть наоборот тоже в остальных случаях но нет не так все гладко ну например в принципе должен можно придумать истории например даже если мы не обязательно можем отбросить кусок дерева до чтобы вот просто не обходить совсем тем не менее мы можем его просто пометить как обойдена и и поместите как бы рим все паттерны которые внутри внизу там находятся в ответ ну то есть плохое решение потому что мы получаем балл на выходе получится очень очень много паттернов нужно делать при доброму пост обработку какую-то но тем ни менее может быть это все равно будет работать быстрее чем сгенерирует вообще все просматривать все и потому что то еще сотню делать ну давайте еще один в принципе 45 минут только что сначала и последний тогда да у меня такой вопрос каким вот больше бизнесами над сценарием подходит вот то чтобы подходить рассказывали о болгарии то есть это либо поиск я так понимаю наиболее длинному паттерна либо поиск наиболее часто встречаем шился патрона фиксированной длины вот какие-то примеры вот таких вот задач что именно вот нужно чаще всего искать этих паттернов то есть я такая-то задача это в общем то достаточно противоположные то есть найти то или найти вот это да задачи абсолютно разные но у них есть определённые общие черты да что мы находим в самом делаем примерно одно и то же соответственно ну а не в разных областях встречаются и мы разные требовали возникают ну то есть длинный максимально какой-то очень длинный паттерн мы можем выходить в днк например можем искать в при просто часто встречающийся паттерна ну вот да в анализе продуктов может быть в панковских транзакциях анализов в анализа сессий данных наоборот и редко редко встречающиеся паттерны тоже иногда нужно выходить то есть они должны с одной стороны встречается достаточно часто с другой стороны достаточно редко это как раз надо такую разновидность поиска провода мошенничество от лазеров это списываю в наборе в графе банковских транзакций такое может быть например так и могут быть применен применение может быть очень много то есть основные я в общем-то перечислил они иногда очень неожиданно всплывают просто если у вас есть какая-то задачка катает который подразумевает что нужно найти что-то интересное такой в строках просто подумайте может быть это нужно завести сначала задачу поиска паттернов там что-то сделать с этим потом вопрос нужно ли использовать паттерна когда мы не знаем чем мы ищем нет нужны значимы ищем и пытаться понять чем мы ищем а потом уже решать чем мы будем применять искать патроны или там рекомендательные системы запускать или что то еще спасибо большое"
}