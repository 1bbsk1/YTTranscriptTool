{
  "video_id": "BstzvS2xd5U",
  "channel": "HighLoadChannel",
  "title": "Как сделать ваш JavaScript быстрее / Роман Дворнов (Авито)",
  "views": 4277,
  "duration": 2713,
  "published": "2017-04-22T14:48:19-07:00",
  "text": "Всем привет сегодняшняя тема про JavaScript Как делать его быстрее но определённом ключе котором попозже расскажу Вот ещё раз представлюсь Меня зовут Роман Да я занимаюсь фронт дом всё что с этим связано и больше степени то что касается и вот есть некоторые проекты вроде для которые Ну консольные инструменты по сути для ноды кото работат на ноде которые делают что СС и вот собственно говоря работа над всякими инструментами вещами Я получал знани какой-то опыт как вообще всё это ускорять и делать быстрее немножко водно на самом деле когда мы говорим прон производительно во ронде коне понима много апек Вт на итоговое время как Уно ВС быстро работает и конечно же не всегда причино является JavaScript но мы доклад как раз таки в таком ключе построил что мы точно знаем что у нас проблема два скриптом И что же в этом случае нам делать И вот как раз таки вопрос Как же сделать JavaScript быстрее вероятно вы думали что я вам смогу за 30 минут там 40 минут расказать как это делается к сожалению это невозможно потому что Тема очень обширна поэтому скажу что на самом деле простого Ответа нет каждый случай уникален по-своему и код даже похожий сделан практикам которые скажем так вот описываются во многих местах может на самом деле работать по-прежнему медленно потому что вы внесли какое-то изменение которое всё в принципе меняет это может быть несколько строк можеть даже неко символов ещё до сих пор нестабильно потому что JavaScript движки ещё эволюционируют А у них добавляются новые возможности что-то ломается периодически Так что это такое большое большое тема Я лишь Пройдусь по ключевым каким-то моментам и как бы постараюсь направить вас на на верном Пу на верный путь если смотреть вообще на производительность жава скрипта то самое главное что нужно знать - это как работат Jap JavaScript движки внутри что там происходит и определять те места где у нас реально есть проблемы и собственно говоря концентрироваться на них поговорим мы о заблуждениях которые часто можно встретить о том что у нас появляется новые в два скрипте и как это влияет на нашу производительность в итоге также о том что на JavaScript на его производитель могут влиять какие-то Внешние факторы и также как собственно говоря заглядывать под капот и чтото можно найти начнём с заблуждений называю секцию мифы и легенды потому что на самом деле происходит такая ситуация что кто-то где-то что-то прочитал или от кого-то услышал что что-то быстрее что-то медленнее и собственно говоря с этим начинает жить и использовать в своём коде или там переписывать свой код сразу же там с одного на другое потому что кто-то сказал что так быстрее и чаще всего эти представления эти знания они оказываются неверны и вот посмотрим на примере одной статьи которая когда готовился она одна из первых по какому-то запросу называется Четыре оптимизации жава скрипта которую вы должны знать она не очень свежая где-то ей 2 года но тем не менее достаточно типичный случай и вот что же там а ну как раз-таки побуду немножко в роли А до ведущего известной передачи будем разрешать В общем мифы Вот первый совет который есть в статье что Property быстрее свеча Ну что пишет автор что вот слева у нас есть свич который собственно говоря проверяет некоторые значения и в зависимости от того что она принимает чает одно или другое значение это медленно потому что нужно сравнивать переменно с куче значений строк В данном случае быстрее сделать объект и возвращать через Property собственно говоря ответ нужный это работает по идее быстрее но если сделать простейший тест это гипотезы то можно увидеть автор не прилагал теста на самом деле он просто заявил и всё то можно увидеть что по факту swch оказывается в 10 раз быстрее в данном случае но здесь цифры не так важны не важно особо даже браузер потому что они похожим образом работат важно именно некоторая вот разница между двумя результатами И что же в этом случае можно сказать что с всегда быстрее поте Ну на самом деле не всегда в данном случае да потому что такой был случай но в общем случае когда у допустим не оптимизируется вообще как бы JavaScript движки работают обычно в двух режимах они код интерпретируют то есть у нас же JavaScript интерпретируемый но тем не менее многи код JavaScript можно оптимизировать в более быструю форму собственно это называется процесс компиляции который происходит в процессе выполнения и тогда код работает гораздо быстрее так вот когда swch оптимизируется то он может быть Работать быстрее чем какие-то другие аналогичные конструкции и в данном случае кра время обс те чтоп пропу оптимизировать практически невозможно и вот чтобы подтвердить то что именно здесь дело в оптимизации я сделал специально поменял функции таким образом чтобы они не оптимизировали JavaScript движки вернее их оптимизатор кода они не любят в общем такие конструкции типа TR Они не умеют оптимизировать такие функции поэтому я вставил такую конструкцию которая ничего не делает Она фактически просто мешает оптимизатор сработать и оптимизировать код это актуально как минимум для других браузеров скоре других движков тоже актуально Вполне может быть и вот я запустил тест снова можно увидеть что Ну в принципе про практически не поменялось может о считать что это погрешность А можно видеть как свич у нас во время взлетело буквально там больше чем в 15 раз Это говорит о том что как раз таки вот без оптимизации свич работает очень медленно Да может работать медленно а если он оптимизируется то работат го быстрее тоже самое Property А здесь можно сделать выводы такие что опять же повторюсь Switch оптимизируется Да он работает быстрее Но если у вас есть допустим другой код функции которая находится рядом со счм он может по помешать допустим оптимизации всех функции и в итоге свич будет не оптимизирован поэтому здесь нужно смотреть в каждом случае отдельно и нельзя говорить что swich всегда быстрее будет а также есть определённые вещи которые мешают например оптимизировать в каких-то конкретных реализациях например раньше вот V8 не оптимизировать свечи них там больше чем 128 веток соотвественно кейсов то есть об этих вещах нужно знать поэтому смотреть каждый случай отдельно перейдём ко второму мифу for И я очень часто слышал эту историю что нужно использовать он будет гораздо быстрее и вот что пишет автор печатка на самом деле вмч который перера суе лю прибирает цепочку прототипов в этом случае получается как бы не очень быстро если мы добавим вот типичный ситуацию пате добавляем по идее в этом случае нам нужны только собственные ключи и Казалось бы это должно работать быстрее Но мы же добавили новый код и новая проверка по идее наоборот должно быть медленнее чем предыдущий вариант а а вот как бы с Здесь мы получаем собственные ключи объекта и потом Ири же не смотрит цепочку про значит он работает гораздо быстрее ище этот ко должен быть самым быстрым но делаем опять же тест автор не приложил никаких цифр и никаких тестов можно увидеть что он заблуждается немножко быстрее чем а вот с дополнительным условием работает значительно быстрее то есть в три раза чем другие результаты Почему потому что нужно перебирать доста много перебирать собственные ключи и цепочку прототипов и это сложно как-то оптимизировать стоит таких конструкций избегать тем не менее Если вы используете hone Property то э оптимизатор то есть JavaScript движок он по сути видит что здесь используется знакомый паттерн нам нужны только собственные ключи и поэтому он уже избегает проверки прототипов и можно увидеть что это приводит значительному приросту А вот object Case почему же он работает Не так быстро Да object тоже перебирает собственные ключи но при этом он генерирует новый массив вот временный массив который создаётся на него выделяется память А после того как мы переберёмся ненужным его нужно собрать ч коллектором соответственно ещё временно ч коллектор в общем получается Поэтому всё это гораздо медленней и опять же я проверил без оптимизации то есть запретил фактически оптимизировать этом функция можно видеть что время кейсов рын незначительно а вот п выросла чуть больше чем вче раза 4 с по раза То есть можно веть Что именно в данном случае скорость обусловлена опять же оптимизация Jap движка если знать то что он умеет оптимизировать каких случаях можно добиться соответственно какого-то прироста значительного вывод здесь опять же такие же что в общем случае достаточно ВМ там углубляться что если есть возможность приходит один и тот же самый объект функции то там может произойти оптимизация если объекты приходят совершенно разные то как бы оптимизировать не будет например будет медленный случай работать Нея на то что добавляет лишний код он фактически заставляет даёт возможность лучше оптимизировать собственно отрабатывает может и быстрее но по сути создаёт мусор и это приводит к тому что ВС В итоге получается медле ещё один из таких достаточно частых Советов и заблуждений это циклы наверно Наверняка вы все с этим сталкивались слышали читали вот есть у нас фор обычный совершенно фор и как бы ну как-то он не очень-то быстрый наверное И что здесь можно улучшить Ну можно например L например не проверять каждый раз может сохранить какую-то переменную фактически широва значение и у нас получится что меньше будет обращения к свойств должен по идее быть быстрее более быстрый вариант самый быстрый вариант это коне ить то есть Сначала взять длину и как бы просто менять счётчик и получается что должен быть самым быстрым и Вот пример теста здесь он достаточно простой собственно здесь оба случая проверяются ипу То есть он там медленнее там какие-то непонятные там 1 миллисекунду Ну на самом деле если посмотреть внимательнее и попробовать по запускать тест несколько раз то можно увидеть что на самом деле Slow loop который вот for является А обычно на самом деле быстрее чем Fast loop то есть while в большинстве случаев В современных браузерах э также здесь очень были маленькие временные интервалы то есть в районе там а нескольких миллисекунд и в этом случае очень велика влияние погрешности то есть там шаг влево шаг вправо уже цифры сильно скачут и вообще в принципе тест неверный Потому что если мы посмотрим как он устроен это просто некоторый плоский код который выполняется по сути один раз и нужно знать опять же про JavaScript движки что они не оптимизируют кот сразу потому что это дорого и неэффективно А кот оптимизируется только тогда когда мы собрали некоторую информацию о нём и он выполнялся не один раз здесь выполняется множество раз только тело цикла и по идее оно могло бы быть оптимизировано то есть циклы независимо от того что какой вокруг них тело циклов може может оптимизировать если он выполняется достаточно много раз в данном случае здесь пустые пустое тело в обоих в обоих случаях поэтому оптимизировать здесь нечего и по сути здесь сравниваются вот эти две конструкции то есть в одном случае это будет декремент в другом случае инкремент сравнени с некоторым значением Ну как бы простые конструкции мы сравниваем что-то непонятное сложно оценить вообще производительность этих циклов А ну поменяем немножко тест таким образом что мы весь этот код который проверяет два случая вынесем в отдельную функцию и выполним этот тест три раза что же мы получим в итоге мы получим что у нас первый раз примерно та же самая картина то есть 3 миллисекунды против двух А вот после идёт какая-то странная ситуация всё меняется наоборот на самом деле это всё объяснимо так как первый раз выполняется код он не оптимизирован он не не не разоре но после первого исполнения на Втором уже вернее вызове код уже оптимизируется и выполняется оптимизированная версия и ситуация меняется на противоположную то есть for становится гораздо быстрее в принципе ива становится быстрее но незначительно То есть он всё равно проигрывает фору а в общем здесь опять же то же самое заключение что код оптимизируется по мере разогрева э если функция достаточно простая она будет оптимизирована где-то на второй третий раз вызова и собственно говоря когда оптимизируется код он в общем сильно меняет картину Всё может применяться за снок на голову Вот и возникает вопрос как же всё-таки быстрее вот допустим использовать for или while Ну для этого я немножко поменял тест чтобы он был более репрезентативный добавил полезную нагрузку сделал так чтобы было больше тера чтобы можно было Ну меньше было влияния погрешности и в общем нужно писать вообще тесты таким образом чтобы не дай Бог оптимизатор не выкинул код Например если функции будет выполняться цикл который ничего не делает то скорее всего оптимизатор Просто выре этот цикл потому что он ну не имеет никакого сайд эффекта и в итоге мы будем выполнять мерить вернее выполнение пустой функции Что понятно будет очень быстро и будем думать что цикл быстрый собственно я померил с этими новыми изменениями у меня получись при Вот такая картина то есть с оптимизацией Мы видим что р и зашивали собственно говоря то что предлагал автор и собственно Wi немножко медлен и закованный и можно видеть что на самом деле э разница между Каширова или не Каширова длину не как бы небольшая и в общем нет смысла вообще Каширова значение то есть оптимизаторы обычно видят этот паттерн и они сами каширу например длину массива вместо вас этого делать можно не делать также без оптимизации можно увидеть что все циклы в принципе увеличиваются там в три-четыре раза а то есть соответственно здесь больше играет роль именно оптимизация самих циклов если код достаточно простой Ну в общем те же самые выводы А что на самом деле while быстрее for - это миф из прошлого э нужно всё проверять смотреть На тестах и гораздо важнее как вы пишете цикл Если вы пишите как-то необычным образом то скорее всего ваш код не будет оптимизирован а жа движком и он будет работать медленнее и соответственно цикл Может там в три-четыре раза оказаться медленней потому что не распознан паттерн Если вы пишете обычный р там даже сравнивать с длиной то он будет работать быстрее даже без каширования подводим итоги этого расследования можно сказать там разрушения этих всех легенд Да что всегда нужно гипо подтверждать тестами то есть не голословно говорить что одно быстрее другого а именно делать тест который показывает так или иначе то есть Это правильно или неправильно и код на самом деле обычно работает не совсем так как нам кажется вот там был пример с и так вот казалось были больше кода но работат быстрее чем без того же самого пропор потому что внутри происходит трансформация которая сделают его быстрее также всегда нужно оть знания потому что информация устаревает и вот эти вот вещи которые там про Wi про for in Это всё из тех времён когда у нас ещё был е6 то есть это Достаточно давно и тогда большинство движков они были правда интерпретатора и не оптимизировали код собственно говоря скачок вот это вот рост скорости исполнения жава скрипта обусловлен тем что они научились оптимизировать видеть во сколько раз там ускоряется код если происходит какая-то такая оптимизация Ну и как бы Когда вы пишете ч марки это известный наверное тезис что кро мало если они пишутся без знания как вообще работат Ja скрипты JavaScript Вешки и допустим как они там убирают код как они оптимизируют и так далее поэтому стоит на самом деле быть очень бдительными внимательными проверять и разбираться Почему что-то работает так или иначе если таких объяснений Нет я просто говорят что это работа быстрее это медленнее потому что мне так кажется то этому верить не стоит и первым источником Правды является скорее блоги разработчиков браузеров движков потому что они больше в теме потому что они этим занимаются Ну и соотвественно говоря статьи могут устаревать и многие тезисы которые были актуальные и правильные например когда-то они сегодня уже могут быть потерять сил как бы соответственно ситуация может быть другой говорим про у на Ja развивается семимильными шагами каждый год уже выпускаются новые версии языка появляются новые конструкции они очень такие удобные классные но почему-то когда говорят скрипте и всё новом Что появляется в нём всегда говорит про удобство и как компа том что А как же это быст Как это работает ще быстро или нет коне же производите браузеров они стараются как можно быстрее поддержать ту или иную фичу При этом они Они не гарантируют что это будет работать быстро они только позволяют это использовать и по сути на самом деле часто они делают первую имплементация которая просто работает как-то хотя бы проходило тесты и не падало там не Крэша при этом оптимизация производительности этих вещей они не делают при этом новые конструкции могут также влиять и на другой код То есть например у вас был какой-то код э написан там на S3 или на S5 и он работал быстро и вы решили использовать какие-то конструкции из S6 и это может быть очень иметь негативный результат потому что а новые конструкции ещё не оптимизируются А когда оптимизатор встречает что-то неизвестное он соответственно и весь остальной код тоже может не оптимизировать В итоге может быть печальный последствие вот несколько примеров у нас появилась такие замечательные вещи как и const и появилась такая мода что везде вместо варте писать Одно или другое вообще не думаю как бы что это на что-то влияет то есть для многих это одно и тоже как просто LED область видимости и так более правильно наверное в то же время до сих пор в V8 есть проблема что там Let Con работает два раза медленнее в основных движках всё хорошо там работа быстро то есть одинаково свар Ну вот V8 такая проблема сколько я слышал была такая история что вообще была проблема внедрить в const V8 потому что там это изначально архитектурно не было заложено поэтому они кое-как туда ВКР и вот сейчас мы видим результат что это не работает Быстро ещё один момент тоже относительно такая вот миф относительно кон что кон - это какая-то такая Константа и собственно там оптимизатор подставляет значение которые мы указали на все нужные места и всё должно работать быстрее тоже по сути де перемен просто значение нельзя менять Ича обычно переменно по идее этот факт то что это Константа нельзя менять Могут могут использовать чтобы оптимизировать примеру V8 этого не умеет пока что на данный момент об этом тоже нужно знать и когда-то давно года два назад я писа писал полифил для промисов для того чтобы он был максимально компактны Мне нужно был этот именно фактор и после того как я написал я решил сравнить насколько же медленнее этот полифил он же написан в джаваскрипт чем а нативная реализация А я написал несколько тестов Ну там такие простые тесты там их было больше Здесь всего лишь парочку что мы в цикле сдаём определённое количество промисов с пустой функции то есть мы не нам не нужны здесь по идее функции reject во втором случае мы просто сохраняем ссылки на res reject чтобы собственно говоря они передавались эту функцию и явно создавались и запустил в браузерах и увидел совершенно странную картину что нативная реализация промисов оказалось в несколько раз медленнее чем полифил то есть JavaScript который по идее должен работать Ну должно быть наоборот Причём здесь не даже не в один-два раза как бы а там в пять раз разница была это было 2 года назад что же поменялось на сегодня я запустил буквально вчера ещё раз эти тесты и вот получил такую картину что в большинстве браузеров по-прежнему нативная реализация э отличается то есть в худшую сторону да то есть она медленнее А причём там где-то два где-то в три раза и только в принципе в иджи ээ всё наоборот то есть нативная реализация быстрее чем полифил здесь на самом деле цифры не так важны они запускаются на разных машинах здесь больше важно именно в рамках одного браузера э как вот отличаются цифры отношение этих цифр так вот на самом деле реализация промисов она не является самые быстрое есть более быстрые и там автор пишет про оптимизацию которую там делал там какие-то очень безбашенные вещи кстати стоит почитать по этому поводу и вот на удивление что реализация промисов нативна она до сих пор медленнее чем допустим ВОХ браузерах ино при этом нужно помнить что промес ае практически все ipi новые которые появляются в браузерах например А также такие вещи как он вей которая построена по сути поверх промисов поэтому они уже как бы ну немножко медленнее получаются Ну хотя с другой стороны если Однажды эти промес всё-таки нативные ускорят то это в принципе повлияет сразу ускорит всё Всё вокруг как будет наверно здорово и вот когда я разбирался ещё с промеса Я думал как бы ну раз пошла такая пьянка может быть её немножко по оптимизировать что-нибудь Вот И там использовались замыкания я решил что Ну у функции как бы должно быть быстрее вот и собственно говоря попробовал использовать ба вместо замыканий и на моё удивление появился такой вот момент что замыкание против function Bind что же получилось Мне казалось что в моём представлении что B гораздо дешевле чем делать замыкание То есть это каких-то отношениях но когда запустил в браузерах то оказалось знаете то есть бан там в два раза медленней чем замыкание при этом только на тот момент в три раза оказалось быстрее что как бы я ожидал в принципе увидеть у всех то есть в итоге я сделал реализацию на бандах потом это всё дела Кати потому что получается что я замедлил полифил а что же это было 2 года назад что же поменялось сегодня можно увидеть что в Хроме ба наконец-таки стал быстрее он стал быстрее в три раза чем замыкание фаерфоксе по-прежнему замыкание быстрее выжи в принципе тоже самое осталось правда стало пропорции несколько другой но не суть Ну в сафри в принципе тоже ба оказывается чуть медленней Ну собственно говоря Теперь вы знаете что бан всё ещё медленней чем замыкание в большинстве Ну в ряде движков То есть в принципе разделились пока что и как бы не везде он оптимизируется на самом деле ещ достигается его скорость В некоторых случаях за сч того что оптимизируется код таким образом чтобы просто работа он переписывается там не создаётся даже сам по себе несколько слов ещё про трансляцию у нас всё-таки появляются фичи языка как бы в браузерах они уже в принципе везде доступны но тем не менее не во всех браузерах которые мы поддерживаем Да многие делают распи например переводит из 6 там или там 2015 16 при этом код написанный на е6 становится модифицируется какой-то другой код и в этом случае мы меньше влияем на результат то есть на то как он выполняется его производительность здесь нужно отметить что транспирация может иметь два эффекта собственно положительный эффект Когда при переписыванию кода из е6 S5 этот распай может на самом деле оптимизировать код то есть используя статический анализ то есть понимая что у нас происходит делать код более компактным и простым соответственно быстрее будет работать в движках но тем не менее бывают случаи и могут быть такие случаи когда сгенерированный код наоборот приводит к тому что всё становится работать медленнее В таких случаях нужно определять те точки где реально проблема то есть которая работа медленнее всего и не бежать за моды и переписать их все 6 на S5 или S3 соответственно как бы как можно проще может коту получится гораздо больше но при этом будет работать быстрее и у вас будет контроль над тем как он работает подводим итоги Я надеюсь в принципе примеров может быть гораздо больше новые не всегда работает Быстро должно быть пройти определённое время прежде чем новые конструкции попадут в различные часть оптимизатора и он начнёт хорошо эффективно их оптимизировать и собственно это начнёт работать быстро всё новое нужно прежде чем начинать использовать Если для вас критичная скорость нужно протестировать посмотреть для ваших реальных кейсах насколько вам это подходит И готовы ли вы там пожертвовать скоростью либо всё-таки стоит подождать также обязательно нужно читать блоги разработчиков движков и браузеров они пишут про то как они меняют оптимизаторы движки и улучшают их производительность не за счёт того что они быстрее работать начинают Они просто начинают генерировать более оптимальный код и постоянно добавляют новые оптимизации вот ну и собственно S53 Они до сих пор актуальны и особо критичные вещи нужно стоит писать всё-таки на них а не гнаться за моды писать на всём новом А про то как влияет на JavaScript что-то внешнее то есть беда она может прийти оттуда откуда её не ждёшь совершенно Вы можете вять совершенно идеальный код с точки зрения производительности он может быть работать крайне быстро но тем не менее Если вы прогоните по тестам у вас получаются цифры какие-то не совсем те что вы ожидали А почему так происходит потому что у нас есть внешний API Да JavaScript Конечно работает не в вакууме он взаимодействует с внешними системами под системами это такие вещи как например таймеры дом файлы системы и сеть напри таймеры не являются частью жава скрипта это внешние API использую системные таймеры дом Понятно Я думаю файлы системы тоже и так далее Всё это не часть jav скрипта это некоторые API биндинг и отдельные подсистемы но тем не менее время выполнения этих вещей то есть каких-то внешних методов или подсистем оно плюсую к джаваскрипт поэтому вы можете видеть что Функция может быть очень простой При этом она может работать очень медленно за счёт того что как раз-таки у вас есть внешнее влияние А вот пример с дом достаточно типичный случай э Когда например некоторая функция меняет э два свойства то есть некоторые стили у элементы при этом читает эти как бы какие-то значения для того чтобы записать свойства из другого элемента да и с точки зрения д скрипта здесь Ну что здесь Всё достаточно просто ну Обращаемся к свойствам делаем присвоение делаем какти наци строк Ну по сути дела здесь ничего такого сверхъестественного однако Это будет работать очень медленно Почему Потому что для второго чтения из дом нам придётся произвести полный пересчёт леау обычно потому что первой строчке мы поменяли дом их может зависеть от того что от того изменения которые мы внесли А поэтому фактически вы обращаетесь к свойству и ничего такого не делаете но по сути это биндинг который приводит определённым триггером в Дом который регит там пересчёт йу уже другие подсистемы там и прочие вещи и соответственно это всё влияет на то что обращение к свойству у вас будет работать крайне медленно Хотя фактически оно Ничем не отличается от других а Поэтому лучше сделать такую вещь что сначала прочитать всё из дома а потом туда записать в этом случае нам не Придётся делать пересчёт Лаута потому что мы то есть не считаем значения от которых зависит которы на которые влияет те изменения которые мы вносим завтра будет доклад отрисовать за 16 миллисекунд по-моему называ писаны такие подобные кейсы Так что приходите послушайте как бы подытоживая могу сказать что время выполнения краски внешних API прибавляется javas и поэтому нужно понимать Почему произошло почему так медленно работает таная часть что там делается и вот это частая ошибка что считаю что например там многие вещи которые вызываются из jav скрипта является его частью на самом деле это всё не так Ну и не нужно забывать про побочные эффекты то есть сайт эффекты например там пересчёт лейауты который произошёл или ещё какие-то вещи Например если вы читаете файл из файл системы то у вас Может просто случиться ожидание пока файл будет освобождён пока это не произойдёт у вас не будет выполняться даже JavaScript он ставится на паузу а ещё один очень важный момент про который все забывают Ну не все как бы многие забывают это память очень важный Аспект потому что оно в принципе сопряжено со скоростью жава скрипта не меньше чем в принципе скорость выполнения самого жава скрипта вот простой пример у нас есть некоторый цикл в котором мы наполняем массив некоторыми элементами то есть мы вызываем определённое количество пуш и здесь какая проблема нужно понимать как работают массивы на Нижнем уровне массивы всегда хранятся одним фрагментом памяти и соответственно когда мы создали пустой массив Мы ещё не знаем Сколько нужно нам будет памяти поэтому там выделяется Совсем немножко когда мы начинаем растить массив то по мере роста и когда не хватает фрагмента который мы выделили изначально выделяется новый фрагмент памяти туда копируются старые данные А старый фрагмент освобождается фактически превращается в мусор это называется релокация и соно по мере роста у вас может работать здесь сделать такой код например он работает медленно вы думаете а здесь фор наверное Медленный или пуш наверное медленный на самом деле ни то ни другое А дело в том что вы влияете на перераспределение памяти перемещение памяти достаточно много И поэтому это работает Не так быстро как хотелось бы поэтому совет общий здесь бывает подобного рода что если мы создаём массив мы знаем во длину конечную то желательно её указать в этом случае скорее всего движок выделит ровно столько памяти Сколько нужно для вот этого массива В итоге когда мы будем потом заполнять его какими-то значениями у нас уже не будет выделяться новых фрагментов не будет копирования и всё может работать гораздо быстрее Может потому что всё зависит на самом деле от разных ситуаций там собирается статистика и прочие вещи и соответственно может проти произойти такая оптимизация может не произойти а но в общем случае происходит чаще всего у вас всё будет хорошо э ещё можно э делать такие вещи используется во-первых структура данных которая соно редко используется во фронтенде например там односвязные двусвязные списки либо например такие вещи которые тоже обделены вниманием это типизированные массивы которые фактически выделяют столько памяти сколько вы сказали то есть они не меняют длину они не динамические но могут значительно вам ускорить производительность я подробнее рассказывал о применении того и другого в докладе про парсинг CSS есть вот ссылочка ну я думаю Бут слайды Посмотрите Ну или на гуглите е момент что память с памятью сопряжено это как бы всем известны ГБ колектор Да сборка мусора И ГБ колектор может всё испортить и вот простой пример наверное из моей жизни Вот буквально недавний э случай когда есть некоторые тест который проверяет скорость парсинга э CSS и там есть две операции он сначала парсит из строки вст а потом из собирает обратно строку и вот каждая операция по отдельности она занимает там 26 миллисекунд а все вместе почему-то 144 миллисекунды как бы странная математика непонятно что происходит но э-э если запустить например Note JS с флагом Trace gc то в этом случае будет отслеживаться время когда срабатывает GB коллектор и можно увидеть что разброс достаточно получается большой вот есть есть несколько запусков как бы Run это номер запуска и собственно время сколько оно получалось где-то в среднем получается 40 там 60 миллисекунд то есть примерно достаточно быстро всё происходит но можно увидеть что некоторое время и нада подскакивает там за 130 150 бывает 200 250 и так далее И вот перед этим есть несколько строчек Таких страшных написано это как раз таки срабатывание гч коллектора там также ещё пишется обычно сколько не знаю тут поместилось Нет ещё обычно там иногда пишутся Сколько времени на это потратила и это как раз-таки занимает в районе там 70-80 про времени соответственно для того чтобы это не происходило нужно стараться выделять меньше памяти меньше мусорить и тогда у вас будет В принципе меньше срабатывать ч коллектора В итоге у вас время будет гораздо быстрее то есть здесь и важно то что у вас код один и тот же то есть запуски делают одно и тоже совершенно при этом время отличается в разы лект вино ещё момент что если Вы давно читали про ч коллекторы то лучше стоит почитать про них побольше сегодня потому что они эволюционируют и до серьёзно каждый там движок идт он свою сторону как бы что-то делает какие-то улучшения Ну практически сейчас во всех есть такая вещь как молодая там старая память а то есть те есть два буфера куда складывается создаваемые объекты то есть выделяемая память есть инкрементальная сборка мусора если раньше у нас пока работат наш JavaScript не срабатывал ч колектор то сейчас он может сработать в произвольный момент это сделано для того чтобы собирать не сразу большой фрагмент то большое количество мусора А собирать понемножку в мере работы как раз таки вот здесь вот ме между раном как вообще в принципе это весь код синхронный то есть там нет никаких отдельных вызовов можно увидеть что срабатывает просто в произвольной момент никакой системы Нет просто когда переполняется какие-то буферы либо что-то посчитал ч коллектор что ему нужно сработать ещё работает очень много над тем чтобы сделать параллельна сборку мусора соответствено пока выполняется ваш JavaScript и он наполняет молодую Память то есть горячие объекты только создаются в этот момент Колек собирает из старой памяти Пока туда ничего не пишется получается так что экономится время на сборку мусора то есть в двух потоках происходит операции этого не было раньше это сейчас есть другие браузеры другие движки скоре всего тоже подтянутся то есть там Всё достаточно сложно и это тоже влияет как бы именно работа с памятью влияет очень сильно на вате крипта пам потребляем ВС работат быстрее меньше выделяется памяти релокации происходит меньше мусора всё работат быстрее что срабатывает реже Ну и собственно говоря понимая как это всё работает можно понять Вообще причины и объяснить почему у вас здесь код один и тот же работат по-разному что на него Влияет немножко про то как вообще что у нас есть под капотом и как заглядывать невозможно ускорять Ja понимания на предыдущих слайдах Вы видели что мы написали код который по идее должен работать медленнее но он работает быстрее что же происходит нужно как бы понимать и видеть вне что там сделал оптимизатор И для этого нужно ещё разобраться счастью матчасть достаточно сложная местами есть вот писаны некоторые термины которые встречаются часто в оптимизации вообще описании работы JavaScript движков если вы что-то не знаете то стоит про это почитать на гуглить это н клас или там ещё называется Shape это моно морфизм полиморфизм и Мегамозг лайвы кэш функции удаление мёртвого кода нринг и прочие вещи а хорошее начало будет почитать блог Вячеслава Егорова наш соотечественник он работал над V8 сейчас работает над VM виртуальной машино Дарта у него есть блок где он хорошо Очень с комиксами рассказывает как всё это работает там можно разобраться и как бы получить такою вот вводную как как вообще оптимизируется JavaScript также выступал и выступает с докладами нужно их налить посмотреть рассказывать причём по-русски Так что я очень рекомендую поиз учать там больше про внутренности и технические детали также важным Я уже говорю что читать стоит блоге браузеров потому что они сейчас помимо того что мы запили там новую фичу никому не нужно они е пишут про то как работают jav движки Как работат колектор как они улучшают производительность за счёт чего они улучшают То есть как работать именно внутри и соответственно это источник ещё для новостей и для тем там очень всё хардкорно на самом деле нужно найти статьи почитать общем не забывайте заглядывать в других местах это вя уровень и разбираться в таких вещах которые Казалось бы Нафига не нужны фронтенде тем не менее без этих понимание Очень сложно будет разобраться в том что вообще делает движок Собственно как работат процессор память Какие структуры данных как вообще представляются вот последние массивы строки на Нижнем уровне то есть в низкоуровневых языках типа например или там наров инструкции процес или строка там всё последовательность нулей единиц там числа вот тем не менее это собираются какие-то абстракции которыми мы пользуемся а ну и самый важный момент То есть как узнать что на самом деле происходит у вас под капотом почему-то Медленно или почему это быстро стоит смотреть внутренние представления то есть во что превращается вас тот JavaScript который вы написали для этого нужно запускать ваш какой-то тестовый скрипт на ноде или там даже по-моему Хрома тоже есть такая вещь с определенными флагами здесь их очень много они есть по-моему даже на сайте Вячеслава Егорова В общем эти флажки которые просят собственно говоря V8 сохранять всякие вещи например там де оптимизации и прочие штуки и сохранять это всё дело и вообще скомпилированный код сохранять то что он оптимизирует собственно говоря там получается В итоге два фали эти два файлика отправляются какой-нибудь инструмен тоже самый Вячеслав Егоров он написал специальный вьювер для того чтобы эти файлы просматривать они в принципе текстовые эти файлы но читать их невозможно потому что там очень много всякого страшного добра и в общем этот интерфейс он выглядит примерно так слева у нас появляется список функций которые оптимизировали либо де оптимизировали справа показано собственно говоря код и некоторое внутренние представления но здесь в данном случае все функции красные это значит что они все были оптимизированы а выбра функцию можем посмотреть какой код как бы что же у нас за проблема как раз здесь вот можно видеть с таким очень бледным серым на здесь не знаю видно нет написан наш реальный код А вот между этими строчками нашего реального кода уже написано какие-то специальные инструкции как раз то самое внутреннее представление очень похожее на ass то есть там мы делаем по сути например обращение к свойству но там проверяется какие-то делаются проверки какие-то делаются инструкции выполняются дополнительные и вот в данном случае Например у нас есть проблема на функция оптимизировали той инструкции где это произошло мотреть детали з не видно но там на самом деле написано что причина bce Это говорит о том что вот этим вызовом Мы вышли за пределы строки это привело к тому что выход за строки Это плохо у нас функция вся целиком взяла и оптимизировали если вы Вите такую проблему Пойте что здесь нужно бы проверить длину наверно к чему Обращаемся начинает работать гораздо быстрее без такого инструмента без таких знаний вы не так можете не понять не разобраться в чём у вас вообще проблема в коде то есть профайлер там или дебаггер вам этого не скажут в заключение в целом то что я рассказал это на самом деле по верхам Я понимаю Потому что Тема очень большая обширная Но я надеюсь вас убедил что разбираться в Jap движках стоит это важно и нужно копать без производительный код невозможно и эта тема очень объёмная поэтому невозможно пере взять и вот сегодня нужно оптимизировать код и в зале начали быстро оптимизировать В общем нужно Понемногу ться Этой темой читать статьи блоги там всякие доклады и потихоньку погружаться тогда ког придёт ваш Звёздный час оптимизировать уже будете знать куда смотреть тема сложная большая но тем не менее это стоит вот некоторые вещи которые получилось добиться там за последний год я тенью csso - это оптимизатор CSS и вот вот можно видеть график как бы изменени производительности на одном и том же тесте по версиям да то есть буквально там меньше чем за год он ускорился там в больше чем в 10 раз стал одним из самых быстрых оптимизатора CSS другой пример тоже как бы из мира CSS инструментов как бы там это уже парсер CSS начиналось всё с гонзалеса который вот был в цсо э можно увидеть чего получилось добиться то есть вместо 175 миллисекунд получилось 7 миллисекунд это тест пост CSS и собственно говоря разница в десятки раз там получается я подробнее рассказываю вообще о способах оптимизации конкретных решениях опять же в докладе Вот про CSS perform int и в общем я думаю здесь очевидно что опять же это получилось не потому что там это всё я взял переписал код это многократно оптимизация заглядывая внутренне представления прочие прочие вещи попытка понять объяснить почему происходит оптимизация В итоге вот можно в принципе вот Как разогнать ВС зависит от конкретного случая не всегда это возможно поэтому ищите объяснение Почему что-то работает быстро или медленно как вобще работает и тогда вы сами сможете ответить на вопрос как же сделать Васт пому ВиДи поменять на этом всё спасибо"
}