{
  "video_id": "g8gzl6GjZFY",
  "channel": "HighLoadChannel",
  "title": "Как построить OMS с помощью Temporal: опыт от нуля до десятков тысяч заказов в день/Евгений Конечный",
  "views": 1079,
  "duration": 2843,
  "published": "2024-10-29T03:07:37-07:00",
  "text": "Меня зовут Женя я сегодня хочу поговорить с вами про такую штуку как temporal и рассказать как мы своей помощью строили Order Management System А давайте сначала я скажу кто я такой А я сейчас руковожу кастомер разработкой ум tore ум TC - это такой узбекский стартап по доставке готовой еды и доставки продуктов из магазинов последние 7 лет я пишу на го поэтому все приме кода которые я буду показывать будут на го последние 4 года я занимаюсь тем Я работал в Delivery Club немножко поработал в Яндекс еде и пытался запустить свой собственный тех стартап поэтому ум tore - Это мой такой четвёртый большой фудтех проект а последние 3 года я руковожу командами и последние 10 месяцев я пытаюсь правильно выговорить слово temporal или temporal кстати говоря ко мне пришли разработчики temporal и сказали что правильно ты говорить temporal но фишка нашей команды говорить тел типа это такая фича Поэтому я буду пытаться произносить temporal А о чём буду рассказывать я поговорю о некоторых ключевых идеях и концепциях temporal плюс расскажу как Мы строили Order Management System с его помощью С какими проблемами Я столкнулся дам несколько советов плюс покажу какие у нас были инциденты Ну топ три инцидента а покажу какие у нас метрики для работы с БД потому что БД - это одно из самых узких мест при использовании temporal А ну и наверное всё далее о чём я не буду Говори Я не буду сравнивать temporal с кон А я не буду рассказывать про какие-то низко уровневую архитектуру temporal там говорить про матче про history про frontend вот я этого не затронул плюс Я немножко потрогаю модель акторов но я не буду сравнивать её реализацию и углубляться куда-то в неё дальше а погнали Давайте сначала определимся Что такое Order Management System это некая платформа это может быть один сервис Или это может быть группа сервисов или вообще группа доменов которая такая Ключевая для яком проекта то есть у нас есть пользователь он хочет создать заказ заказ надо подвигать по статусам надо по заказу надо на него назначить курьера надо заказ доставить надо с заказа списать деньги надо вернуть деньги Если с заказом что-то пошло не так надо собрать продуктовые метрики операционные метрики надо взаимо рассчитаться с рестораном и надо ещё суппорту дать какие-то инструменты для работы Вот и у нас всё это так как мы узбекский стартап у нас пока это всё А заложено внутри ОМС То есть это Всё лежит там а перед нами стал такой выбор так как мы начали писать код в январе А в апреле у нас уже должен был быть первый релиз типа хотим ли мы писать свою собственную МС или мы хотим посмотреть либо на какие-то готовые решения либо представить себе заказ в виде какого-то бизнес-процесса и просто оркестри его вот и последний способ он возможен То есть можно взять например какую-нибудь команду Как делали в Delivery Club Я смотрю на Надира чтобы он оценил шутку но он не оценивает А комун ну или комун или з позволяет описывать с помощью bpm диаграммы бизнес-процесс и оркестри вот таким образом есть ещё декларативные способы описания бизнес-процессов например так делает кондак от netflix но а мне кажется самым современным подходом Ну который сейчас есть и которым как мне кажется надо пользоваться это является описание бизнес-процесса как кода который был реализован в cadence и вышел Ну из компании uber вышел в несколько компаний впоследствии как раз-таки превратился в temporal и Давайте начнём с temporal а так у меня тут украли вопрос ведущий спросил Кто использовал Temp проде Давайте тогда пропустим эту часть смотрите А если взять и загуглить что такое temporal то temporal - это надёжная распределённая масштабируемая платформа для оркестрация рабочих процессов что как бы ну довольно непонятно что это значит Поэтому сначала хочется разобраться что такое рабочий процесс А Максим фатеев это один из фанде Temp даёт такое определение что рабочий процесс - Это некая отказоустойчивые программа которая выполняет задачи и реагирует на все ну на внешние события включая таймеры и тайм-ауты при этом отказа устойчива значит что эта программа гарантированно исполнится То есть она устойчива к перезапуска к сбоям зон доступности к сбоям сервера Ну то есть ко всему тому что с ней может произойти она гарантированно исполнится при этом а workflow of temporal - это некая функция можно сказать первого порядка которая принимает какой-то аргумент и стартует э запуск рабочего процесса при этом сам рабочий процесс описывается кодом То есть у нас есть активити это те задачи которые мы хотим выполнить кстати активити обычно имеет зависимости но не имеет состояния а само рабочий процесс не имеет зависимостей но имеет состояние вот в Activity обычно оборачиваются все блокирующие операции там походы в другие микросервисы а запросы в БД это какое должно быть Идо патентное действие вот далее У нас есть сигналы Сигнал - это способ коммуникации между рабочим процессом и внешним миром То есть это внешний мир может что-то передать нам через сигнал Ну надеюсь что такое таймеры и тайм-ауты объяснять не надо так вот а первая идея temporal заключается в том что мы просто пишем код то есть вот есть бизнес-процесс создания заказа мы берём и описываем его так как бы мы это ти ну как как мы это представляем в виде действий то есть мы сначала хотим получить пользователя проверить что пользователь активен получить его корзину получить вендора далее там не знаю создать платёж применить промокод сделать что-то ещё и всё это мы просто пишем кодом а temporal гарантирует нам что если у нас произойдёт перезапуск или по каким-то причинам исполнение прервётся то л восстановит а его состояние Это возможно благодаря такой реализации А это не самый популярный термин то есть Его редко где встретишь Но это называется модель исполнения с сохранением состояния если её попытаться описать то это выглядит Таким образом у нас есть рабочий процесс и он разделяется на код который мы написали и на его ну типа состояние или исполнение так вот исполнение находится на сервере а наш код находится Ну как бы на наших воркера и они не находятся вместе то есть мы постоянно синхронизирует получает некие команды от сервера типа продолжая выполнять активити продолжаю выполнять что в тебе находится или Остановись я переместил Work Ну workflow на другой процесс при этом каждая вот э команды которую мы получаем от сервера мы записываем в виде ивента в историю событий и записываем её назад в А И вот сама вот эта механика сохранения состояния она описывается Ну вот есть такое механика вот это восстановление это локального состояния то есть workflow получает состояние а рабочего процесса в виде истории событий и прогоняет его типа вот эта команда была исполнена в этой истории событий получила такой ответ поэтому её не надо исполнять таким образом реплей доходит до конца истории событий понимает что у нас ещё есть код И в этот момент продолжает исполнение Таким образом он каждый раз восстанавливает своё состояние Ну это такой как будто бы инсорсинг а последний момент это тоже одна из концепций л называется инверсия исполнения То есть temporal - это не чёрный ящик куда мы пиха код в каком-то виде и он его выполняет нет А у нас есть наши воркеры которые мы пишем на одном из а sdk то есть это может быть sdk для питона для Go для PHP для тайп скрипта А мы можем написать наш код запустить worker отдельно И подключиться к платформе temporal это может быть наша собственная платформа temporal А например её Подняли там наши devops - это Self Host от реализации или мы можем подключиться к облаку вот и получается что мы как разработчики отвечаем за воркеры а там команды Иры отвечает за КСТ temporal которые масштабируется отдельно а воркеры масштабируется отдельно а Прежде чем перейти КМС хочется проговорить а немножко вспомнить модель акторов и вот модель акторов заключается в том что Всё вокруг является акторами которые все существуют одновременно и параллельно То есть это модель которая описывает параллельные вычисления так вот актор он обладает каким-то состоянием он реагирует на входящие сообщения создавая либо N других акторов либо отправляя N сообщений другим акторам либо изменяя обработку этого ну поведение как он обрабатывает своё сообщение workflow в temporal делают примерно тоже самое поэтому можно провести такую аналогию что workflow ну как актор то есть workflow обладает поведением workflow может общаться с другими workflow workflow может создавать другие workflow и workflow может изменять поведение а при этом в temporal реализована одно направленная отправка сообщений через сигналы Сигнал - это некий который можно получить например Здесь приведён код Ну грубо говоря отмены заказа очень упрощенный то есть мы отправляем некий сигнал и выставляем при этом тот кто отправил сигнал обычно не знает примени это изменение или нет или вообще никто не ждал этот сигнал Поэтому в есть несколько реализаций синхронной отправки сообщений например через апдейт хеле апдейт хендлер - это сравнительно новая механика но она позволяет узнать о том Правильно ли примени к процессу какое-то Вот мы сейчас активно начинаем их использовать в нашем коде следующее Как можно реализовывать это есть два паттерна Это сигнал сигнал паттерн это Например Когда в workflow отправляется сигнал и этот workflow отправляет сигнал в ответ таким образом раньше пытались контролировать что этот workflow применил изменения которые мы в него направили то есть там заказ выставил в тот статус который мы хотели выставить Или Сигнал qu это примерно тоже самое но вместо отправки сообщения можно получить а-а Ну типа запросить его состояние через quy и таким образом работает подтверждение далее workflow умеет А во-первых создавать само себя или какое-то другое workflow после себя через continue S New это нужно во-первых потому что у workflow есть ограничение в 20.000 событий в истории событий А ну и во-вторых как бы когда мы хотим продолжить а один workflow другим Аа далее можно создавать дочерний workflow и при этом ну дочерний workflow выглядит примерно Вот так мы создаём workflow который отковырять через механику benden это некая parent polic то есть что если родитель этого workflow закроется то workflow можно закрыть Таким образом мы получаем что а workflow внутри temporal взаимодействует друг с другом а при этом не нужно делать каких-то ещё дополнительных ручек ещё чего-то то есть temporal представляет сам собой такой способ коммуникации А давайте я теперь расскажу сначала Почему мы его вообще выбрали То есть перед нами стоял выбор нам нужно было за 2 месяца внедрить какой-то ОМС написать процессинг ещё что-то А я написал спайку в которой допустил все ошибки которые можно допустить при работе с temporal но при этом когда мы это потрогай потестить мы сделали слота анализ и у нас получились следующие преимущества когда мы сравнивали между своим велосипедом А И temporal то есть Первое - это то что это опенсорс ий продукт который написан Наго и который можно просчитать самому То есть мы там регулярно изучаем как написано СДК чуть реже смотрим в код а основной но такое тоже было при этом temporal дал нам возможность сразу писать бизнес логику то есть нам не надо было думать о том что там надо поднять очередь написать какую-то службу таймеров придумать как мы работаем с кранами ещё с чем-то нет мы просто всели и начали писать рабочие процессы при этом так как workflow представлен в виде функции первого порядка её супе удобно тестировать и дебажить то есть просто мы запускаем локально workflow и там работает дебаггер это очень круто при этом на старте у нас было много вопросов мы пришли к разработчикам temporal и они на все них ответили То есть это тоже очень подкупила плюс temporal используется у больших игроков То есть он есть у netflix есть группа компаний Я не знаю как это правильно называется Y brands который активно Ну то есть один из самых больших пользователей temporal ну и плюс у нас был аргумент что это стильно модно молодёжно так как мы сможем хайри новых разработчиков на эту технологию В общем мы сделали такой выбор Ну первый наш выбор что мы используем temporal далее У нас встают вопросы а а как мы будем Ну типа как мы организуем персистентное хранение потому что для temporal это нужно будет ли у нас visibility storage Нужно ли нам какой-то Анти корапшн слой или Ну как мы будем мониторить Трейси и какие у нас будут воркеры И сейчас я попытаюсь ответить на все эти вопросы а вообще ра умеет работать с пятью видами хранилищ тут нету пятой картинки Пятая - это SQ я решил не вставлять её так вот эластик он в основном используется для индексации рабочих процессов это нужно чтобы потом осуществлять поиск по ним А mysql мы не рассматривали и вот выбор у нас стоял на самом деле между пог и кассандрой при этом по дефолту разработчики temporal рекомендуют использовать кассандру так её легче скели но мы взяли пос потому что мы побоялись использовать кассандру так как у нас никто в команде не обладал экспертизой в кассандре а взяли постс Потому что кажется мы не упирались пока в лимиты и так далее при этом что нужно учесть а тел работает только с мастером то есть нельзя писать в Мастер а читать из реплик нет только в Мастер А у temporal очень такой нагруженный паттерн использования то есть его называют fright Heavy он очень много пишет БД вот это то что надо учитывать при выборе и смотреть на свою собственную нагрузку А вот мы взяли pog взяли ластик дальше у нас стал выбор а хотим ли мы какой-то HTTP сервер и спойлер хотим а то есть никто напрямую сервисы не взаимодействуют друг с другом через там sdk temporal то есть у нас есть некий http слой в котором на сделаны ручки для создания заказа все админские ручки и ручки колков ну там платёжный колк колк там смене статусу ресторана и так далее а при этом мы подняли ещё temporal UI UI позволяет удобно менеджери сами workflow то есть там посмотреть почему там была такая-то история событий в каком состоянии находится текущий workflow и плюс там можно тить и Мить то есть убивать поднимать заново далее вопрос про мониторинг тут тут у нас особо не было не то что выбора а у нас уже был запущен datadog поэтому мы просто взяли datadog и с ним отлично интегрируется то есть мы используем трейсинг профайлинг логи и всё прочее в дата доге И никаких проблем при интеграции не было А ну и последний вопрос он самый тяжёлый - это воркеры а сначала я собрал всех наших продуктов и мы нарисовали такую сложную bpm схему где мы описали все процессы от создания заказа процессинга заказа и ну каждую роль в общем-то получилась такая Огромная схема что она никогда бы в жизни не влезла на этот слайд поэтому я выделил слены и вот эти слены и есть наши воркеры то есть у нас есть самое короткоживущие механизм компенсации То есть когда мы попытались создать заказ и у нас что-то не получилось нам надо вернуть например пользователю промокод и нужно чтобы это произошло гарантированно вот в компенсации ещё вшитой которые происходят если по каким-то причинам чекаут сорвался дальше у нас запускает тся процессинг процессинг - это самое жирное по Activity workflow там ну вот всё движение по статусам всё взаимодействие с рестораном и так далее и ещё из-за экономии вот ресурсов на разработку мы сшили процессинг заказа с процессинговый я допускал вот лучше так не делать вот и дальше у нас от процессинга от почковый несколько Фло например процессинг логистического заказа от него от почковый и дальше у нас есть некий такой Костыль в виде пост процессинга он предназначен для того чтобы если по каким-то причинам нам надо отменить заказ Когда уже заказ достиг финального состояния то мы используем постпроцессор и вот ОС на данный момент у нас выглядит Таким образом какой-то он такой Давайте пойдём дальше сейчас я попробую дать сам себе совет сам себе советы а перед стартом разработки Ну и во время разработки что нужно учесть и вот первое ТО чего Я не сделал И то о чём я потом пожалел и сделал в конце это надо написать свою обёртку на temporal первое там должен быть лоер потому что temporal использует специальный логгер который учитывает находится ли он в реплей моде или нет Аа и его надо адаптировать просто под свой логгер чтобы также читать влоги дальше хочется реализовать метрики А по дефолту если мы используем промити SAP то там работает библиотека от убера который называется ли и вот мы используем её но просто надо её объявить и за конфигурировать трейсинг то надо пробросить все поля которые нужны для трейсинг я писал свой proof of Concept я подумал Ну мне показалось что правильно что у заказов должна быть какая-то своя база данных Ну типа у нас процессинг заказов Вот они лежат в базе данных но ко мне довольно долго приходило осознание того что мы можем хранить заказы в самом temporal то есть заказ лежит прямо в состоянии workflow а отдельной базы данных для активных заказов её не существует Но при этом persist по заказам всё равно требуется и мы не хотим пускать клиентскую нагрузку в temporal чтобы они бесконечно дёргали кри поэтому мы сливаем через шину событий заказы в историю заказов Куда направляется клиентский трафик а для всяких взаиморасчёты прикольно потому что не надо постоянно переживать о том что в базе данных что-то изменилось и надо синхронизировать состояние с другой стороны это очень трудно объяснить людям вокруг которые приходят к тебе и просят подменить какое-то Полюшко в заказе Ну такое невозможно потому что у нас нету инструментов для этого А следующий момент - это разобраться слингом Аа Например у нас есть процессинг заказа где мы постоянно опрашиваем партнёра на предмет изменений и это надо делать часто для того чтобы это делать часто temporal рекомендует использовать высокочастотные активити там можно написать абсолютно любой код Просто периодически надо показывать что это активити ещё живо а такой способ например для опроса статусов у партнёра самый правильный но Я использовал естественно неправильный то есть есть вариант низкочастотных активити через rety polic таким образом но я вообще использовал такой подход когда мы просто пишем цикл и опрашиваем заказ пока он не достигнет нужного состояния такой подход подходит но он создаёт большое количество активити в истории событий и излишне нагружает ОМС а последний момент Это довольно странно для того что мы делаем оркестрация И вот как будто бы тем предназначен для того чтобы обрабатывать ошибки но надо предусмотреть такой вот полный отказ системы Бывает такая ситуация когда мы доставили заказ списали деньги но можем напечатать чек вот и очень странно если после 10 попыток напечатания чека мы пытаемся отменить заказ так как сорвалось вот бывает такая ситуация когда типа отменить нельзя продолжить поставьте запятую такое происходит например система фискализации в Узбекистане как-то лежало несколько дней Вот И там у нас травила несколько часов и всё остановилось отменили заказы неправильно А дальше может быть какая-то ошибка в исходных данных и Например у нас было что мы пытались напечатать чек с пробелом в в ННН и получали четырёх сотую ошибку такие ну как бы повторы они Бессмысленны Ну и последнее в какой-то момент система фискализации начала нам отдавать тестовые чеки А что тоже приходилось их руками перебивать Поэтому нужно сразу предусматривать всё равно какую-то политику обработки и вот кажется я сейчас сделаю бесконечные попытки отправки и всё заработает Ну Однажды оно восстановится но это тоже не совсем работает потому что в Temp это активити зависает А ну workflow зависает в этом активити и Аа его даже нельзя нормально Отменить то есть это workflow можно только затерти внутри ЮА вот далее должна быть какая-то возможность редактировать исходные данные сейчас у нас это сделано через сигналы довольно топорно но она должна её нужно предусматривать и ну как бы а нужна кнопка которая вручную повторяет активити Если всё сломалось и нам надо вернуться откатиться Ну перепечатать чек если он в тестовом режиме Ну и потом мы хотим знать что заказ перешёл в Fail State то есть мы хотим эскалировать это в сарт чтобы кто-то пришёл починил руками Ну и нельзя сразу завершать workflow Для нас это было актуально потому что Саппорт постоянно ошибался в причинах отмены заказа и нам приходилось потом исправлять биллинг поэтому мы не сразу отменяем workflow выставляем причину и потом можно эту причину отредактировать пока ещё workflow не завершено Аа Следующее о чём Надо подумать - это ошибки недетерминированный плохо а скорее всего ну то есть это происходит когда Аа workflow перезапустил идёт в реплей моде и то что написано в нашем коде уже не соответствует тому что написано в истории событий в этот момент он понимает что они сходится типа код недетерминированный и он падает Вот это очень опасно потому что даже если мы откатить а наш воркер то у нас будут новые заказы которые вероятно дошли до вот этого момента недетерминированный Термини нами Они и это требует Вот таких ручных манипуляций и обычно мы это вообще исправляли через terminate То есть просто убивали те workflow и теряли заказы поэтому важно сразу на старте разработки предусмотреть а Как не допустить такого поведения Первое - это делать версии а версии в temporal пишется примерно таким образом а важно понимать что версия создаёт некий маркер в истории событий которым помечается все события и версии мы помечает кода а при этом а сразу если у нас длительный workflow например наши длятся несколько дней и 40 дней там в случае пост процессинга 45 А то требуется какой-то менеджмент версии то есть надо понимать что вот эта версия устарела её надо удалить иначе код превращается в Лапшу то есть регулярно приходится чистить версии дальше а надо использовать linter есть Work Check он показывает все не детерминированные штуки а и использование реплей тестов помогает регресси workflow релей тесты - это мы заходим в UI temporal скачиваем json с историей событий подкладываем её Вот в такой код и Гарантируем себе что изменения в коде не сломает старый workflow при этом тут тоже требуется какой-то процесс по актуализации регулярных Ну регулярно этих реплей тестов так как у нас тоже была ситуация когда все реплей тесты устарели на несколько месяцев и они не покрывали код который был написан недавно ну то есть новые версии кода А следующий момент надо использовать сайд эффекты например мы таким образом делаем идентификацию заказа Ну то есть генерируем Order ID Аа Это позволяет всякие там рандомы или юид а закрывать то есть создаётся отдельный отдельное событие в истории событий в котором закоротило нее - это использование правильных конструкций Наго я тут не буду останавливаться Тут надо просто знать что все недетерминированный штуки а и всё то что аа выпадет в момент реплея это надо предусматривать то есть на Go - это такие конструкции на другом языке они могут быть какими-то другими обычно Они все написа в документации здесь написаны все мои советы ещё бы я сюда добавил что надо подумать над спецификацией то есть специфик Вити специфична специфик запуск workflow так чтобы потом поэтому можно было сгенерить код и делать общение между workflow менее безболезненно А теперь перейдём к проду Аа прод Давайте Вот это наша БД она маленькая скромная у ней всего шесть ядер Ну то есть это виртуалка на которой запущен отдельный инс поса для а temporal там 24 ядра памяти 24 гига памяти шесть ядер при этом вот там есть всплеск в начале который видно это мы снимали бэкап а бд не утилизируется то есть как бы по ЦП нагрузки какой-то значимой нет а наш head in fre говорит что она пока смешная но при этом если посмотреть на нагрузку ночью если что в Узбекистане ночью доставка еды не работают курьеры спят рестораны закрыты нашим приложением про тоже никто не пользе при этом он греет воздух То есть у него там достигает 100 запросов в секунду 70 транзакций в секунду То есть он прямо фигачит что-то днём на пике вот этот скриншот помоему сделал был в августе или в июле л на пике Когда у нас активно идут заказы вот он уже в этот момент разгоняется он там достигает 1800 запросов в секунду почти 700 транзакций в секунду при этом сравнивая с каким-то своим велосипедом Мне кажется что у меня была бы там ну пара запросов в секунду ну пара акций то есть этого было в десятки раз меньше вот поэтому Temp очень активно утилизирует БД и если посмотреть топ запросов за сутки они примерно выглядят все таким образом то есть есть сотни тысяч запросов Но суммарно их время исполнения обычно не превышает 10 секунд То есть там нет каких-то жирных запросов которые кладут систему ещё что-то то есть мы видим большой запас для работы с погром а но всё-таки чтобы понять что типа когда у нас закончится постгрес мы проводили стресс-тест Вот и temporal предлагает два варианта стресс тестов а такими вариантами пользуются сами разработчики Temp rol первый называется сценарий кролика как известно кролики любят размножаться как и рабочие процессы вот и он делает запускает рутовые workflow потом запускает а большое количество дочерних workflow каждый из которых запускает ещё большее количество дочерних workflow и в какой-то момент такая скачкообразно либо BD либо кластера тел А мы такой тест не проводим мы проводим что-то близкое ко второму тесту это называется сценарий реактора а тут предполагается а долговременная запуск рабочих процессов которые выполняется параллельно и обладает большим количеством активити а чтобы вот вот это сделать temporal предлагает какой-то набор утилит их есть я нашёл их три штуки может быть их больше может быть у кого-то есть самописный а при этом разработчики temporal slak рекомендуют именно использовать первую которая называется omos omos представляет собой такой генератор нагрузки где есть некий сценарий которому можно на вход подать Какое количество активи ему надо выполнить Какое количество сигналов он должен обработать Какое количество дочерних workflow он должен Запустить вот и таким образом можно нагрузить свой Клар temporal мы эту штуку форкнуть как библиотеку и дописали Ну немножко модифицировать сценарий под себя добавили Sleep Activity которые ждут среднее время ожидания наших активити так далее насколько у нас подскакивает transition per Second и вот все прочие метрики А и получили какой-то результат поняли что мы пока не ограничены и непол не погром на данный момент То есть у нас есть большой запас на то чтобы двигаться дальше А я очень хотел вставить какую-то картинку и я решил что вставлю вот эту А я прикидывал на своём ноутбуке просто какая у меня будет ёмкость по заказам типа сколько заказов я смогу запросить на своём ноутбуке А написал как раз с помощью omos такую утилиту и у меня получилось что вот минуту я выдерживаю на нову с помощью temporal Light temporal Light - это такой бинарник в который вшита SK по-моему вшит эластик и ещё что-то ну то есть это весь temporal в одном бинаре вот я его запустил в Memory режиме и прогнал на наших синтетических workflow и якобы Вот у меня 660 заказов прежде чем начинается какая-то деградация вот и это может быть дало бы мне 36.000 заказов на ноутбуке но это неправда как бы Но таким образом можно делать какие-то прикидки и оценивать как бы какой Лар temporal какие будут метрики сколько он выдержит заказов в час в день и так далее А бонус Я сейчас расскажу про инциденты которые у меня были на проде которые мне запомнились больше всего и вот это был первый инцидент а онне запомнился потому что он первый так вот а как-то раз я захожу в UI temporal и начинаю кликать Рандомный workflow и они мне отдают пятисотый ошибки А некоторые открываются вот оказа в temporal есть такая штука которая называется СШ кэш который кэширует исполнение рабочего процесса на своей стороне и делает его доступным Вот и если workflow был за кашированный событий И падал А так вот наши девопс 20 минут назад оказывается переключили PG baner в transac Mode а temporal использует prepay statement и в итоге это всё развалилось потому что мы это не протестировали и не объявили что они так сделают было очень плохо поправили добавили мониторинг А дальше это уже после коммерческого запуска у нас начался рост по заказам и а приходит такое сообщение и мы смотрим Наш замечательный мониторинг видим что процессинг вообще остановился у нас пик заказов а при этом есть такая маленькая струйка заказов которые продолжают работать вообще непонятно что происходит Мы смотрим метрики базы данных база данных курит Она не нагружена с ней всё в порядке мы смотрим метрики temporal он тоже не нагружен Вот но где-то что-то не работает оказалось что мы запустили а PG баунсер пользователя тел для поса который был со стандартным количеством коннекто и мы упёрлись в коннекты то есть в 24 коннекта а потюленить количество коннекто выкрутились уже на большей нагрузке но за пределы рити он не выходит а разработчики temporal мне тоже сказали что у них когда они тестирует стоит около Ну 100 коннекто и стоит вот поэтому мы пока оставили так и последний инцидент это инцидент без жертв а потому что ну в общем-то каждый день примерно в одно и то же время А Приходила такая ну типа Арт из дата дога что пришёл Киллер и убил наш воркер который отвечает за процессинг А так как тем устойчив к перезапуск то кажется что всё нормально но типа потом разберусь В итоге я разбирался значительно дольше чем это того вре было но я успел сделать там continous профайлинг посмотрел как типа течёт память вроде не течёт потом мне посоветовали раздели worker на Activity worker то есть Work который запускает Activity и workflow worker который отвечает только за workflow проблема была в workflow кере а и потом я открыл документацию и на первой странице документации было написано как раз-таки про стики кэш дефолтное значение стики кэша - это 10.000 он каширу ет на себе 10.000 workflow это сделано для улучшения производительности так вот а каждый закоротить какое-то количество ресурсов на там историю событий ещё на что-то то есть вот он висит в этом состоянии и получилось так что у нас превысил лимит который мы выделили на этот под с воркеров нужное количество памяти и всё работает память не течёт А у меня на этом всё как бы что я хотел сказать с этим докладом что л подходит для стартапов Он подходит чтобы организовывать на НМ процессинг и при этом это достаточно устойчивое стабильно потому что все проблемы которые у нас были были связаны в основно вот с этими двумя руками а Наверное у меня всё пожалуйста оставьте мне фидбек вот Здесь где-то есть - код А да и готов ответить на вопросы на которые смогу Спасибо И у нас есть первый вопрос здесь по центру Ого же спасибо за доклад у меня такой вопрос Если заглянуть в будущее и например через 5 лет когда вы расши не знаю сколько у вас 20 команд или п команд вас будет наме 20 команд 40 команд насколько больно будет синхронизироваться вместе сл делить зону ответственности насколько это решение подходит В общем для больших компаний Слушай мне кажется что оно подходит потому что оно используется в больших компаниях Я например консультировался с ребятами из Яндекса которые подняли они на НМ делат всякие билды пому в Яндекс и мы с ни обсуждали как раз дали очень большое количество Советов поэтому для больших компаний оно подходит и для больших команд кажется тоже Вот но на Горизонт 5 лет через 5 лет сзм Скор я не мо Надеюсь что он будет большой там будет много команд Но ответить не смогу мне кажется что тел потянет Спасибо Следующий вопрос да спасибо за доклад такой вопрос было упоминание что Касандра и проще скели смрат ши во да Ну вот я знаю что есть какие-то хитрые механики Как можно разделить запросы на чтение запись за пределами Темпо например поднять какой-то хитрый роутер ещё что-то то есть это можно сделать на уровне инф Я пока не задавался этим вопросом потому что у меня не болит на Кандры пото пови Кох э ВН при этом у меня у самого она не появилась на данный момент вот поэтому мы пока планируем на самом деле в ближайшее время если мы начнём убираться в постгрес то сначала поливать его вертикально вот тогда ещё один вопрос собственно говоря просмотр в сторону Кассандры а какие-то механизмы переезда поддерживаются вообще стандартные А если честно Вот давайте так это пока моя фантазия но я бы просто так как на самом деле такая довольно стот штука Я бы поднял просто ещё один пор И постепенно бы начал туда перекатывать заказы заро их где-то на момент создания то есть в каком мл мы создаём заказ То есть мне не надо у меня нету каких-то там важных данных То есть это там лежат только активные заказы Вот и поэтому мне не надо думать о том как мигрировать старый workflow из старого кластера в новый поэтому я бы не стал этим заниматься просто но возможно ребята из инф сказали нет мы будем делать совсем по-другому да спасибо спасибо Вот у нас есть вопрос Привет Спасибо за доклад У меня вопрос Удалось ли потрогать shing в temporal О нет нет вообще не трогал даже никак не смогу прокомментировать и тогда ещё один вопрос Когда наступает время делать новую версию Work а да когда задача приходит но когда мы понимаем что у нас в workflow мы не добавляем что-то в конец а когда у нас меняется какая-то бизнес логика в середине Ну то есть то есть мы понимаем что нам надо здесь вызвать другой активити А у нас здесь поменялись какие-то возвращаемые значения вот в этот момент мы добавляем новую версию то есть мы же если касается вопроса именно версионирование внутри workflow тут Важно отметить что А мы не создаём новые версии workflow мы создаём версии внутри то есть мы версионирование Нет не буду ты сказал а довольно подробно рассказал у меня был вопрос про версионирование но его оставим про мониторинг ты слабо остановился Я как приверженец команды э там есть такая тема у нас бизнес-процесс что ты смеёшься визуализировать Что там на сборке заказа у тебя начинают копиться заказы и ты это видишь это можно мониторить То есть ты не технические метрики смотришь а именно бизнесов метрики вот в Temp что-нибудь подобно есть смотри во-первых там действительно нет никакой визуализации её только если делать кастомно Ну или может быть есть какие-то решения со стороны которые это делают а у нас есть audit мы можем посмотреть в аут влоге когда зависает конкретный но какую-то статистику собрать тоже нельзя при этом мы используем Ну можно делать метрики внутри рабочего процесса и поэтому у меня там натыкается и операционные метрики когда я хочу посмотреть что у меня заказ перестал проходить из этого статуса в этот то есть я каждую смену статуса заказа её треку отдельной метрикой и плюс запоминаю время в которое оно перешло Ну типа чтобы по по баке тамм это раскидать То есть у меня там гистограмма какая-то построена вот и это кастомные метрики то есть из коробки такого нет то есть есть только метрики самых воркеров и метрики кластера Temp Понятно В команде Вот это из коробки есть Ну всё да слышно да Жень Спасибо за доклад дополню немножко Надира в частности Вот про про тот самый vpm смотри если у нас заказ допустим Ну там отменяется резко Ага и мы идём к каким-то там служба поддержка единое окно они хо хотят менить заказ Они вообще могут работать с workflow сами Аа да Ну как раз-таки мы индексирует вот типа у нас есть список заказов список заказов с проблемами можно зайти в заказ и там есть как раз-таки действия мы их сейчас вот активно переводим на апдейт хендлер Но раньше там просто была кнопка которая на самом деле Ну типа дёргалась сигнал workflow то есть там отменить заказ отменить заказ с какой-то причиной перег нери чек вот вот это всё у нас было в виде Ну в админке кастомной вывели куда-то просто да да то есть это как раз эке вот он отвечает чтобы это всё можно было получить чтобы можно было найти Ну то есть у на равно заказ Да и можно найти заказ по номеру телефона клиента или по адресу или ещё почему-то мы это всё индексирует можно да такой е вопросик небольшой смотрели ли в будущее но бесконечный Фло А да смотрели но решили что нет у меня у нас план на самом деле Другой у нас план создать некие рутовые workflow которые будут запускать количество ограниченное количество так скажем не знаю как это правильно назвать сак то есть каких-то короткоживущий бизнес-процессов которые на самом деле будут длиться мало а вот эта рутовые workflow будет длиться как раз-таки 45 дней но оно будет заниматься только тем что будет а взаимодействовать с дочерними то есть запускать отправлять туда какие-то сигналы и гасить если это требуется вот мы ценим всё в эту сторону но мы ещё на этапе так скажем какого-то rfc который у нас описан Но не реализован Но бесконечных Фло не будет вообще нет я тут немножко про другое Вот как раз если понадобится условно необходимость в неком бесконечном бизнес-процессе вот рассматривали возможность сделать как раз таки бесконечный Фло который Ну не ляжет мёртвым грузом а потом при реплее положит всю систему пока он всю свою историю сделает там как раз-таки вот это там же получается что бесконечно вот и не может быть может быть только New S Ну вот мы можем Ну не то что перезапустить мы можем запустить ещё одно workflow когда мы дойдём до какого-то лимита и вот Temp предлагает такое решение и он просто схлопнется историю событий на чём остановилось предыдущий workflow и будет просить уже новое то есть Оно будет само себя пересоздать вот я так понимаю концепцию но я сам этого использовал ещё ну то есть мне пока это не требуется но такая механика есть всё спасибо как раз спасибо супер вот у нас есть вопрос Я правильно понял что вы цепляется к посу для того чтобы выкачивать оттуда событи Ну чтобы как-то собирать ордера из событий не совсем получается что у нас есть И вот взаимодействи только с temporal а temporal в качестве persistant Stage имеет pog под собой но мы не знаем ничего о том что pog существует То есть получается что вот запускается функция которая отвечает за процессинг заказа ей на вход подаётся какой-то набор данных и вот из них собирается заказ до того момента где остановился и когда мы вызываем quy quy - это такой callback внутри workflow то мы получаем актуальное состояние заказа на данный момент если этого заказа нет в кэше то он выполняет функцию ещё раз доходит до какого-то и отдаёт её но при этом сам Temp он вообще хранит по-моему он их как-то кодирует через прото И вообще как бы из БД постгрес данных так просто не достать Там они все закодированы и лежат по разным по огромной куче таблиц Ну а вы говорили что как-то собираете то есть что вам нужно иметь какую-то базу ордеров А да но это уже находится за пределам МС мы просто у нас есть некий топик куда мы скидываем при изменении статуса заказа вот целиком модель заказа Да её кто-то забирает то есть её забирает биллинг её забирает история заказа её забирают ещё какие-то сервисы которым нужны заказы вот чтобы они не приходили в МС за заказом Ну то есть это такая а условно синхронная штука Спасибо Угу спасибо Вот у нас есть вопрос в заднем ряду Угу Дмитрий виттех это itv.ru спасибо большое за доклад особенно было интересно слушать потому что мы делаем ровно то же самое ну почти в Один в один разница только в том что мы не стартап а переписываем текущий Монолит но абсолютно то же самое используем А у меня вопрос вот в продолжении а а если всё-таки бизнесу надо изменить Вот эту вот цифр А она у вас там находится не в вашем хранилище А в темпом хранилище что же вы делаете Как оно влияет на заказ-то Ну вот мы делаем такие ужасные вещи мы отправляем сигналы То есть у нас есть Прямо действительно моменты в которых мы можем повторить какие-то действия отредактировать А вот действительно у нас был момент когда контент завёл вендора с пробелом и ни одном моменте не сработала никакая валидация потому что для нас была просто строкой Вот и пришлось тогда руками перебивать чеки Вот и если там 20 чеков руками можно перебить то 1000 чеков уже нельзя Вот и поэтому мы встроили механизмы типа вот здесь происходит реген чека и цифры эти исправляются в момент отправки реген чека вот сейчас Это дикие костыли Вот лучше предусматривать решение более такое платформенной Когда можно сразу по кнопке и исправить большое количество заказов Вот у меня это сделано питон скриптами Понятно А ещё в продолжении вот предыдущего вопроса Да вот молодого человека а вот думали ли вы если завтра появится система которой нужно Здесь и сейчас получить текущее состояние заказа А у вас по сути его нету оно только в истории как вы планируете это делать собирать историю а ну вообще на самом деле Да ну то есть в большинстве систем где я работал обычно так и делали То есть никто не запрашивал прямо актуально состояние Ну то есть его получали откуда-то например ну в Деливери когда мы делали то же самое у нас а была кавка Мы в кафку скидывали целиком модель заказа и те кому нужен был заказ в каком-то виде они приходили в историю заказов забирали его оттуда и поэтому как бы этот подход он для меня Ок он у меня не вызывает вопросов Но если кому-то нужно прям вот супер вот Без миллисекунды ожидания то Пускай приходит через ручку админскую и там можно получить заказ но я буду всеми силами отбиваться и пытаться меня убедить что это нужно сделать плюс у меня есть ряд разработчиков которые предлагают мне каждый день всё-таки закидывать и в постгрес заодно заказ вот чтобы как раз решайте подобные задачи но мы там у нас есть решение пока не делать так спасибо большое но такие а это будет постоянно вертеться в голове Спасибо есть ли у нас ещё вопрос Да у нас есть последний на сегодня вопрос Что будет происходить или Какие действия предпринимать если Temp упирается в какие-то лимиты по памяти или по ядрам и просто не хватает Ну ресурсов чтобы дополнительные Work или активити выполнялись Ну мы Слим отдельно воркеры но вот ворке мы пока не опираемся никак то есть у нас стоит по дефолту везде пока три пода запущенными и как бы такого что мы Ура по памяти или по цпу такого вообще не происходит Вот там как бы как раз-таки один из инцидентов был в то что лись по памяти Вот и мы просто посчитали сколько ему нужно и действительно как бы всё совпало Work эффективно вытесняются всё работает Окей в случае кластера Temp Мы тоже не упирается и на стресс-тест мы не заметили того что он сильно разбух и начал употреблять больше ресурсов то есть такого что мы взяли уронили МПО у нас не произошло на Ну мы не тести именно до того момента пока у нас грох что-то вот поэтому у нас есть какой-то x 10 по запасу Ну тогда дополнительный вопрос а в случае если всё-таки упирается А у нас у нас есть хороший Ну во-первых сам temporal он йл он хорошо горизонтально скели то есть его можно запускать Ну то есть у нас там history каки всякие там эти матче они запущены по-моему в трёх инстанса их можно запустить в большем количестве инстан сов плюс все всё то на что мы запущено там есть возможность это ещ и вертикально по скели то есть там он не потребляет большого количества ресурсов Ну вот представим такой мир где всё-таки у нас мы упёрлись есть ли какие-то воркфлоу какие-то приоритетность выполнени в случае что если вдруг тел поймёт то что ему не хватает памяти чтобы он приоритетные делал я наверное не отвечу на этот вопрос мне кажется что нет я такого не встречал в документации вот ну именно приоритетности Work Я не видел по исполнению там Косов и чего-то ещё там нету по-моему спасибо Ну что ж Давайте поблагодарим нашего спикера за этот за его прекрасный доклад Спасибо и вам спасибо за ваши вопросы а мы выберем лучший А мне на самом деле понравились вопросы От молодого человека от в очках в очках который Ну прости тебя слишком хорошо знаешь Ну что ж ещё раз спасибо вам за ваше внимание Спасибо спикеру за его доклад Угу Это был последний доклад сегодня Поэтому я приглашаю всех на закрытие конференции в конгресс зал и до новых встреч на новых хайлоу дах Всем спасибо"
}