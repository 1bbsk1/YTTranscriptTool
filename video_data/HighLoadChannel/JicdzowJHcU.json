{
  "video_id": "JicdzowJHcU",
  "channel": "HighLoadChannel",
  "title": "Как строить больше ML-пулов на MapReduce, а дежурить меньше / Илария Белова, Никита Путинцев(Яндекс)",
  "views": 535,
  "duration": 1911,
  "published": "2023-01-19T07:01:38-08:00",
  "text": "ладно поехали так услышали меня зовут никита работа в яндексе 6 лет 4 года занимаюсь инфраструктурой подготовки полов для машин обучения в отделе качества рекламы и ларек сожалению придти не смогла поэтому рассказывать буду я окей сначала посмотрим как у нас работает реклама я тут нарисовал какую-то предельно простую схему в общем есть пользователь он приходит на страницу это замечает рекламный движок и показывают ему баннер конечно про пластиковые окна пользователь по нему кликают и дальше рекламный движок должен все это залакировать блогер уитон этого распределенное хранилище после того как он заблокировал отрабатывает некоторые граф задача на мой продюсер фильм потому что много данных и в результате этого графа работает и логров у нас получается полую для машинного обучения прогнозатор и до обучаются на этих плах эдип ловится в движок чтобы участвовать там в ранжировании давайте взглянем на грамм задач нам придется поближе вот и увидим что он на самом деле довольно сложный ну тут схематично нарисована но просто много узлов много to suck почему так во первых у нас есть очень много разных источников данных ведь чем больше мы наденем разных вещей тем лучше у нас будут модели и больше мы в итоге заработаем денег во вторых разные источники данных работают с разной скоростью поэтому мы вынуждены делать пл и имеющие разный трейдов между скоростью их поставки и полнотой то есть некоторые модели имеют мало печей ну быстро обучается эдип ловится они которые ждут подольше но виде плавится по поезде и последняя причина данных очень много через этот граф протягивается примерно 25 to buy the трафика в сутки и все хранить невозможным поэтому могу для разных задач хранить разные сэмплу этого трафика и этого мало у нас есть команда m-elle разработчиков которые хотят эту систему улучшать а как они улучшают они придумывают новые фичи новую модель новую задачу и под неё не конечно же хотят постоянно добавить в graph новый пол и собственно если в этом месте инфраструктуры или заниматься то она начнет рано или поздно разваливаться ну мы солярий в свое время прочувствовали это на себе и решили накалить такой сервис который мы назвали логос он собственно этим графин отправляет кажется у нас получилось довольно хорошо потому что до того как мы напилили сервис в графе было всего примерно 50 задач и два дежурных занимались все свое рабочее время тем чтобы этот граф не разваливался сейчас у нас в графе порядка 300 мы при deus процессов один дежурный занимается этим графом и тратят не все рабочее время ну и также появляется 12 новых процессов неделю ты все это постоянно растет из довольно большой скоростью ok конечно же это все реализовано на инфраструктуре яндекса но окажутся идея не довольно универсальны и вы сможете их применить у себя про всё рассказать мы не успеем так как время на доклад ограничено поэтому будем рассказывать про фреймворк описания задач про их тестирования и про мониторинге за кадром останутся менеджмент железо continuous integration continuous delivery и документация графа но при этом можно будет в конце позадавать вопросы окей фреймворк вот у нас приходит такое мысль разработчика говорит что ему нужен новый пол но и у него есть некоторые требование он хочет взять всех показывают хочет взять их клики слепить их вместе добавить туда пару новых печей и сделать так чтобы эта штука регулярно рассчитывалась чтобы он мог со своей моделью экспериментировать вот он приходит к нам и первым делом мы попросим его продумать структуру задача что он будет брать на вход как часто ему надо будет запускаться что будет на выходе на вход обычно люди берут сырые данные это логе разных сервисов например логику то есть система которая показывает баннера что такое эти логе это некоторые схематизировать и таблицы которые хранятся в распределенной файловой системе она у нас войти называются эти таблицы появляются бать чаями по пять тридцать минут часу и так далее ну и каждую бочку лежит в отдельный таблицу который как best префикс с типом таблицы и таймс то название в логосе все эти таблицы описаны в виде кода вот тут описание виде кода для логос кликами описания для логос показами давайте немножко посмотрим на писание для логос кликами новый которых видно что это какой-то instance класса лог у него есть аргумент locations это только определяет как лобному придете лежит тут видно сразу что он почасовой ну и путь это его префикс сложив эти два знания можно понять что например табличка за час дня за сегодняшнее число будет лежать вот по такому пути под пунктом 3 тут метка что лог внешне то есть не логоса устроят ну про это в принципе думать не надо наверное для себя надо вынести что сюда можно еще воткнуть разными эту информацию в частности мы сюда выкладываем всякие настройки мониторингах ну что мы видим у нас logs кликами почасовой vox показываем почасовой и видимо task будет работать так он будет запускаться каждый час дожидаться кликов и показов для этого часа а потом строить числовой бочках одно вакула теперь можно объявить выходной пул тоже в коде и видим что объявления аналогично абсолютно потому что было для логов но и в принципе регулярные пул это то же самое что локон их называем блогами настало время писать сам task как пишется task это некоторый класс за наследование от базового и надо реализовать в основном два метода снизу метод ран туда пишется бизнес-логика сверху метод dependencies тут описываются зависимости тоска что в этом методе лежит в нем лежит два слова река input и output и внутри словарик of лежат т.д. и каждому того соответствует конкретный тип зависимости давайте посмотрим на входы ну нам нужно взять часть криков час показов и тут видна зависимость называется сингл тайбл dependency ну это такая зависимость которая говорит что если то запущен для часа дня то и лог тоже надо взять 1 и 2 часа дня а вот тут и описывается аналогично зависимость называется под dependency зачем этот метод нужен ну во-первых он позволяет нам понять какие таблицы нужны будут в ране и во-вторых scheduler по нему понимает как именно запускать task теперь можно написать код вот так примерно разработчик может реализовать слой task тут приведет приведен пример реализации новой quelle это такой сквер подобный язык который умеет выполняться нам а придется ну так же мы там просто на питоне можно реализовать еще можно на плюсах давайте сверху вниз посмотрим сначала тут достает клиент давай quelle а на что тут надо обратить внимание этот клиент достается из контейнера который передается на вход подсветку не видно может у меня переключилась нет нет все это вот теперь видны а да все отлично продолжай спасибо окей первой строчкой пользователь достает клиент тут надо обратить внимание что клиент достается из контейнера который приходит на вход метода зачем это надо ну во первых в тестах мы можем это все как-то замок ать во вторых в продакшене мы можем все эти клиенты настроить правильными дефолтные настройками но также мы протягиваем операцию чтоб потом железо мониторить ну и пользователю внутри тоска нельзя ходить ему придется не через наш клиент и мы это проверяем дальше sql запрос ну тут вставляем в таблицу лёрн какие-то колонки из джойана таблиц показов и кликов но что тут надо обратить внимание конкретных таблицы тут нету не должны быть поставлены через форматирование в строке вот это форматированный форматирование в строки и она подставляет пути до конкретных таблиц которые получаются из аргументов метода ран то есть хард ходит нельзя ну это опять же позволяет писать тесты 1 и 2 позволяет запускать всю эту штуку в изолированном окружении ну то есть фреймворк может просто все префикс нуть изолированном окружении всех запустить ну и последний клиент через закреплен запрос выполняется окей task написали и теперь его надо добавить граф граф это по сути просто список активных task-ов вот его юзер добавил и после этого ася и всех подхватит и выкатит теперь можно поговорить про тестирование начнем с историей вот этот пользователь который только что добавил новый task через неделю пришел и говорит ну мне еще надо туда добавить одну фичу кидает pull request мы его смотрим кажется что всем норм он говорит да зашибись эту же все проверил мы это катя у него модельки обучаются и потом в продакшене падают деньги начинается разбирательство в итоге там все смотрят когда кто-то катил находит этот task и смотрит оказывается что он помимо того что добавил просто новую фичу он еще вот тут константу поменял на другую ну типа случайно как такого избежать конечно же писать тесты но писать тесты на мой придется довольно сложно потому что пользователи будут негодовать почему ну во первых они будут говорить что это все будет долго работать и мы не будем этим пользоваться мы тут обычно предлагаем по центрировать входы на что они отвечают что у них такие сложные тоски что по сын пировать хорошо не получится надо так на полных данных set- запускать кроме того вообще-то надо модели катить они теста писать и в div ах ничего не понятно ими никто не пользуется все будет плохо ну и соответственно из таких вопросов к системе появляются некоторые требования во-первых тесты нам упредил задачи должны быть однотипными почему чтобы они были хорошо задокументированы и пользователь мог очень легко разобраться не собирать никаких граблей просто его написать но вторых входные данные должны легко генерироваться примерно по той же причине differ для тестов ну почему de fer потому что мы вот изменение кода 10 дефо им как меняется выхлоп тоска зефир для тестов должен работать должен показывать только то на что надо обратить внимание должен быть написан как можно более качественно даже так чтобы пользователи хотели не только для тестирования но и просто для разработки пользоваться и тест должен работать достаточно быстро у нас тут написано до 10 минут и конечно обычные юниты они там должны за две-три секунды отрабатывать но это юнит поверх нам придется и 10 минут это сильно фильма быстрее чем отваживался в продакшене ну все равно мы стараемся за вот эти 10 минут не выходить окей мы наделили уговорили пользователи написать тест как он это будет делать у нас вот он придет слой task и ему понадобится реализовать метод который называется samplers что это такое это такой словарик из тега зависимости в некоторую функцию которая будет фильтровать про данную табличку и получать из нее маленькую табличку которая будет использоваться в тесте вот тут задан сэмплер для кликов и дальше задан сэмплер для показов что можно сказать про эти темпера вообще во первых стоит в 99 процентах случаев использовать какие-то стандартные универсальные сэмплеры но опять же чтобы пользователь не собирал грабли для нас это фильтрующий сэмплер который по какому-то были в условиях фильтруют таблицу и сэмплер который берет 1 строк из таблицы желательно чтобы сэмплеры не зависели друг от друга потому что сам процесс сэмплирования долгие если сенсоры независимо его можно запускать параллельно желательно чтобы они были детерминированными не детерминированность вносят дополнительную степень свободы и приходится ее почем зря потом либо жить лучше сделать это детерминированным ну и дым контентными чтобы можно было запустить сэмплер на сэмпле и проверить что он все еще актуален также может у пользователя появится искушение за хардкоре в сэмплер какие то едишь ники потому что не для него наиболее удобными удобные так лучше не делать потому что не получится перезапустить тест на новых данных ok наш юзер на писался ампер и теперь пишет тест вот так выглядит колтер давайте его почитаем импорт и нам не интересно в этой строчке пользователь инстанцирует свой таз тут фиксирует дату за которую он будет сэмплер дальше у нас есть такая fix турка чего она делает она поднимает на локальной машине ким определюсь кластеров маленький привозят все необходимые данные и собственно запускает паз и скачивает у тоска то что то что получится на выходе и сам тест он работает в двух режимах на самом деле в 3 но тут 2 во-первых режим центрирования и во-вторых непосредственно режим самого теста в котором будет происходить них окей теперь пользователь сэмплер уют запускает тест режиме сэмплирования ждет и получает вот такой файлик ну что делал тест он запустил вот эти сэмплеры на продал их табличках сгенерил в маленькие таблички и загрузил их на какое-то какое-то хранилища и вернул нам файлик саидыч никами табличек в этом хранилище если будете делать нечто подобное то стоит обращать на внимание внимание на размеры сэмплов потому что если не будут слишком здоровы все будет медленно работать также стоит давать пользователю возможность перекомпилировать по частям потому что не факт что он все сразу с первого с первой попытки удачно pace and let окей вот мы по simply равале теперь надо это все за канонизировать что такое канонизация это мы запускаем наш тест для которого мы верим что написано нормально и запоминаем его выхлоп вот смену за так работает режим канонизацию опять же получаем некоторый конфи джек в котором эта информация про выхлоп тоска на что тут надо обращать внимание чтобы размер выхлопа тоскане был 0 если размер на любой получается так примерно не работает но еще мы делаем такой трюк мы храним хэш если хэш выхлопа тоска равен кашу канона мы пропускаем это от дефа чтобы сэкономить время на прогоне тестов по kei пользователь все это напилил и теперь он может с этим начать работать как он будет с этим работать во первых он придет свой task и поменяет код но вот как он хотел дальше он запускает тест и тест так как вот изменился по сравнению с тем что было за канонизирована он покажет div div это собственно как работает дик он сравнивает табличку которой он запомнил от старой ревизии и дефо и каждую строчку этой таблички со строчкой в новой ревизии и тут видно что добавилась новая колонка fpd но также поменялся поменялось другая колонка пользователь этого замечает и ну соответственно правит свой бак какие рекомендации можно дать для написания di ferro во-первых желательно чтобы в диффе было сводная статистика чтобы пользователь мог быстро оценить о чем вообще ему дальше смотреть в подробном дефект но мы указываем в ней типа общее число строчек строчки которые не поменялись которые поменялись и какую-то похожую статистику по отдельным колонкам также когда div и официальной строчки нужно выводить ключ этой строчкой чтобы можно было в пройденной tipo de божик ну и также надо пилить differ и для сложных типов потому что пользователь они рано или поздно будут если для них не будет адекватного div они не захотят пользоваться вашей системой помимо этого у нас еще есть div по атрибутам атрибута это некоторая мета информации на табличке чего в них есть во первых там есть div схемы таблички тут видно тоже чтоб колонка добавилось во вторых медив им сортировку число строк атрибуты юзера и некоторые технические атрибуты которые влияют на работу например там конфиге сжатие ну и тут тоже советуем если будете что-то такое дело de fer для сложных атрибутов написать о у нас на самом деле все-все-все тоски которые есть они таким тестом обложены и помимо того что юзеры допускают меньше багов когда правит своей тоски есть еще некоторые положительные стороны во первых мы можем все это рефакторинг они боятся разломать во вторых можем как-то спокойно обновлять сам фреймворк обновлять библиотеки переезжать на новые источники данных кроме того ну вот в эту текстуру можем втыкать свой набор тестов которые могут проверять антипа тарный запуск кода в не транзакции использование каких-то левых клиентов создания мусорных таблиц нестабильность по твоим зоне и многое другое ok теперь поговорим про мониторинге еще одна история пользователь за к метил вот эти правки ушел через неделю пришел и говорит что у него ничего не стараются мы ему говорим что у нас как бы alert и все зеленые он говорит ничего не знаю мы начинаем разбираться и смотрим что он криво поставил пороги на свой task пороги срабатывания мониторинга ну и он возмущается говорит что их виноват естественно не он вот чтобы такого не происходило нам надо сделать удобные мониторинге какие к ним требования во-первых из требования со стороны дежурного дежурный должен быстро узнавать о проблемах поставки и не должен как бы тонуть под красными лампочками условно у нас басков много если все загорится он не будет понимать чеченец пользователю нужно придумать какой-то способ чтобы он как можно более точно мог задавать пороге особо не заморачиваясь при этом такие поехали попытка номер 1 вот у нас есть некоторый граф круги это боги прямоугольники это тоски он как-то работает ну и нам нужно на него настроить мониторинге ну самый простой способ мы просто пройдемся по каждому логу и зафиксируем время на которое он должен примерно отставать вот эти там на часы на 2 отстают эти уже внутри на 6 например этот на 8 ну и дальше поднимем мониторинг который будет смотреть найти логе если они отстают больше чем на указанное время и плюс 30 процентов он будет загораться и заведем соответствующий дашборд ну тут лампочки для каждого отдельного logo ну вот все нормально завели пошли спать утром просыпаемся и короче горит больше половины до сбор да еще че-нить непонятно куда бежать и вот это все давайте это как-то исправлять самое простое что можно сделать это начать указывать конкретные таблицы которых не хватает вот этот пример уже стало получше ну еще надо это как-то по сортировать например мы можем по сортировать по времени когда загорелись мониторинге и тут уже понятно что тот который загорелся раньше всех наверное его надо чинить в первую очередь ну стало получше но можно ли сделать еще лучше давайте перекрасим мониторинге у нас тут есть один недостаток нас как бы сам лак может гореть по двум причинам во-первых он сломался самый не работает а во-вторых просто исходники из которых он должен построиться их нет и как бы сам сам тулак работает а вот исходников нет и по сути чинить надо их на него можно внимание в целом и не обращать ну давайте придумаем культ алгоритм который позволит нам это сделать ну и получается довольно простая штука мы просто будем обходить все листы этого графа до корня и смотреть есть ли текущей лог если его нету смотреть его родителей если их нету смотреть и так далее так пока мы не найдем лак у которого есть все предки он не строится мы ничего зажигать не будем ну давайте зафиксируем какую не дату и пойдем снизу вверх вот сейчас ночью 6 марта смотрим на мир 2 3 его типа нес оранжевый смотрим на его родители их тоже нет поднимаемся выше лак кликовые его нет но он уже внешних значит виновата какая-то внешняя система значит лампочку надо зажечь ну и для примера вторая дата опять lenovo k3 его нет 41 есть лед блога 2 нет вот для верного 2 уже все есть поэтому красим вот 1 табличку для него и даже горд уже получается примерно вот такой сильно удобнее ok осталась последняя проблема вот эти все пародии которые я тут нарисовал их как бы выставляет пользователь и пользователь может ошибаться ну и ну например вот тут стоит наверх блок два дела и 6 часов допустим юзер поставила 10 часов и получится что как бы мониторинг навернулась 2 нем не горит а юзер все равно приходится жалуется мы ему говорим про кривые пороге он говорит что ну как получилось так и поставил что с этим можно сделать давайте подумаем в чем тут проблема проблема тут такая чтобы оценить время отстаивания своего logo надо как бы проделать много работы надо так на него посмотреть понять какие у него предки насколько они должны отставать прибавить еще в уме какую-то константу и и получится как бы твое время итоговое отставание пользователи это делать ленятся и такой подход не работает пороге все время кривые но пользователю на самом деле гораздо проще оценить время работы паска которые он пишет ну потому что когда он пишет тоску нагоняет на природе и вообще примерно у него есть какое-то представление сколько он должен вообще работать ну и давайте попробуем на такую систему перейти для внешних логов мы сами там разберемся насколько они отстают и какие-то правильные пороге подберем дальше юзер задаст пороги для своих task-ов и дальше мы промежуточные пороге уже вычислим по графу ну это довольно легко просто но для каждого тоска смотрим все его входу и берем из них максимум прибавляем к нему время работы тоска ok и в итоге у нас получился такой хороший мониторинг в котором легко понятно что чинить с одной стороны с другой стороны пользователя легко его настроить ну ладно рассказал про тесты рассказал про мониторинге но кроме того у нас есть еще система для мониторинга потребления ресурсов система для документация графа приемка и еще многое другое задавайте вопросы нужно вот в телеграме посылкой тоже задавать так до пасибо давайте похлопаем так и скит вопрос есть сразу поднимаете руки можно будет задать так поехали вставай сейчас тебе подбежит к нему с микрофоном вот у нас только-только начала мы еще разминаемся тренируемся спасибо за доклад вопрос такой вот эти тесты они запускаются на каких-то фиксированных данный штатив построить потом были это какие-то разные данные тесты да ну у нас есть систему себя которых на каждый коммент запускает но данные на которых запустили мы теста и фиксированы и рынка где хранятся данные фиксированные они у нас есть специальный сторож распределенный которые позволяют какие-то бинарные файлики хранить вот они в него записываются но пользователь как бы у нас тоски час поправиться когда пользователь приходят и правит task ему очень часто надо обновить эти данные потому что ну как бы прошло там три недели таблички входные поменялись и поэтому в итоге получается что данные постоянно обновляется то есть он их обновляет вносят правки перри канонизируют и заливается на это есть это зона ответственности пользователя и того кто написал тест скажем так есть пользователь который бизнес-логику пишут и чтобы тесты соответствовали бизнес-логики это его зона ответственности есть slim и которые поддерживаем этот граф и там есть иногда приходится обновлять делать какие-то переезды с одних источников данных на другие там с одной схемы логов на другую там и так далее и вот в этом случае мы обновляем входные данные спасибо давайте раз его на руках я сюда хорошо вижу спасибо за доклад вопрос такой я правильно понимаю что в ваша система умеет работать только с боковыми данными или в real time оно тоже может но здесь прямо на это только пробач попробовать ну кажется подход в реал тайме особо отличаться не будет на самом деле именно для тестов но диатез тогда я тут заметил что тут ничего вообще про backend на самом деле не было то есть ну backend как-то все писать умеют более-менее там кучу upon собственных решений типа я флауи так далее но в этих upon собственных штуках вообще ничего никогда нет протесты и про менеджмент и мы хотели именно про это рассказать и можно i'm a real-time систему это тоже перенести спасибо еще вопрос а если в онлайне кто-то на осмотре тоже пишите есть чатик есть форма куда можно все писать задавать есть чате в телеграме зал ахиллес туда можно скидывать какие-то вопросы давайте тоже немножко поспрашиваю расскажи про валер ты если что ты валяться вот в процессе ночью например ну был красивый дашборд дашборде же люди не висят целыми днями да короче на самом деле вот этот дашборд это только один из мониторингов основных мониторингов 2 вот первое это вот этот дашборд потому что когда ты на него смотришь понятен весь стоит всей системы то есть сразу понятно что работает а что нет но как бы бывает так ну проблемы сама она начинается до того как этот дашборд загорается и желательно ее как-то раньше забиты cтать поэтому у нас еще есть один мониторинг который просто кидает alert при падении их самих task-ов прям сразу же вот как только то скупал он кидает alert ну если этот день дежурный смотрит и скорее всего чинит более-менее сразу внесу это но что дежурный с утра это разогревает он то есть alert приходят куда-то в чат да там на почту и потом вернуть чтобы человек открывает дашборд и смотрят что полетело флирте валерки сразу мгновенно работает там сразу написано ошибка что как упала и он даже дашборд может не смотреть он просто читают ошибку или менее понятно что делать и со стороны сервисом мы стараемся новый как бы есть некоторые ошибки которые происходят из-за бизнес-логики есть ошибки инфраструктурные там так транзакция протухла и вот это все и как бы мы стараемся чтобы вот таких инфраструктурных ошибок было как можно меньше чтобы было как можно меньше пол использовать его чтобы дежурный если он пришел alert значит это какая-то реальной проблемой он не реагировал классический белок с тобой озера были все кнопки кроме кнопки остановить production какие ладно еще какие то вопросы так кладбища то еще метка вопрос родился в начале ты показывал какой-то объект лагами кликклак шоу лакс это что за формат это какой-то внутренний формат я лечу я там будет 600 какой-нибудь не знаю xml блюдо конец это что-то такое с еще раньше да да вот эти вот far одну это питон почему питон потому что джейсоне там как бы проблемы с off to comply там пользователю все-таки охоты когда он это будет все настраивать чтобы была какая-то хорошая удобная поддержка или но и плюс это все покрыто тестами и сделано виде библиотеки"
}