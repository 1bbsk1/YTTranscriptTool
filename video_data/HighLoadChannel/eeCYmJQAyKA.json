{
  "video_id": "eeCYmJQAyKA",
  "channel": "HighLoadChannel",
  "title": "Как нейронные сети графике помогали / Евгений Туманов (NVIDIA)",
  "views": 2068,
  "duration": 2977,
  "published": "2019-05-14T15:02:56-07:00",
  "text": "здравствуйте да меня зовут евгений туманах я работают и пленник инженером в компании nvidia я буду рассказывать о применении машин ленин гаити клининга в графике я понимаю что наверное здесь собравшихся тех кому интересно именно эта область наверное ну не очень много вот поэтому я во-первых я постараюсь дать какую-то такую общую идею которую вы возможно сможете переложить где-то в своей области в свои густые во вторых моя сегодня цель одна из это показать показать каким еще может быть машинное обучение что все не заканчивается на нлп на компьютер vision на рекомендательных системах там на задачах поиска и так далее и что нужно и можно искать новые применения вот ну и в конце концов я постараюсь рассказывать как то все интересно чтобы вы не заскучали может быть чем-то вдохновитесь мой план на сегодня такой сначала я проведу такой краткий интерактивность вами обзор некоторых задач которые графики решаются с помощью машинного обучения после этого я вот предложу эту идею которую считаю важный и полезный вот ну и после мы разберем конкретный кейс как она может быть применено в определенные задачи конкретно это будет касаться рендеринга облаков до тех самых облаков которые вы видите на небе вот ну и потом мы у нас будет стандартная часть с вопросами на которые я постараюсь ответить и так обучение с учителем графики значит смотрите сейчас мы разберём две группы задач вот желтую и красную наша цель будет как бы понять в чем принципиальное различие вот сейчас мы это пытаемся сделать так интерактивно значит смотрите разберем первую задачу вот последний там несколько лет очень много стих появляется статей где исследователи предлагают какие-то новые пути к генерации красивые анимации дело в том что для художников это часто дорого делать если заменить это это было бы всем очень выгодно ну и давайте рассмотрим вот такую задачу этот проект был в инвизе где то год назад мы занимались лицевой анимации персонажей в играх то есть у вас есть какая то голова героя в игре вот у вас есть на входе аудио дорожка с его речью вот и ваша задача это как-то двигать это лицо вы хотите чтоб каждая точка на его лице как-то двигалась но у вас прежде интересует губы конечно потому что это самый такой сложный момент в анимации это делать как я сказал дорого представьте художнику сколько нужно времени вот и вот давайте вместе подумаем какой как нам подойти к этой задаче как как сделать datasette для этой задачи вот есть идеи у кого идите давайте сейчас вам принесут микрофон вот для начала определить какие звуки гласные соответственно на гласные звуки рот должен открываться но согласно закрываться вот самый простого горит ну это как то эта стрижка простоту то есть в играх вы хотите побольше качество какие есть еще идеи можно посадить много людей читать разные тексты записывать их их лица так для сна каким-то образом сопоставить те буквы которые они произносятся собственно с их мимикой да это хорошая идея значит практически так мы и делали только единственное что вы когда ну что-то рисуете в игре вам нужно ну вы не видел показываете вы показываете какую-то 3d модель который состоит из точек да и вам нужно чтобы собрать дата сайт вам нужно как-то понять какие то как двигались какие-то конкретные точки на лице ну и собственно мы так и делали мы там поль актеров в просили их читать с разными там интонациями какие-то тексты мы снимали их на очень хорошие камеры с разных углов после чего мы восстанавливали как бы 3d модель их лиц на каждом кадре вот и после этого мы прогнозировали значит вот по звуку мы пытались спрогнозировать положение значит точек на его лице давайте разберем следующую задачу постобработка on train долевых изображений давайте поставим задачу так вот у вас есть движок игры который может видеть изображение допустим там ну он может в разных это делать но вот вы хотите устроить чтобы было так вы хотите рендерить скажем в разрешении там 1000 на 500 пикселей игроку показывать 2000 на тысячу изображение чтобы оно было таким более в более высоком разрешении более красивым вот и вот вас есть вот его мы это рассмотрим для конкретной игры как собрать dtc для этой задачи вот новый вопрос к вам есть идеи это кажется проще задачи ну давайте дайте точно также срендерить сначала картинку на большом разрешении потом соответственно понизит разрешение попытаться найти соответствие обучить как-то систему из из умеешь но разрешения делать даже не подашь да ну замечательно так хорошая идея так и надо делать третья задача слоу моушен интерполяция кадров но всем понятно да то есть у вас есть какое-то видео и вы хотите сетью дописывать какие-то фреймы посередине вы хотите интерполировать кадры но и тут я наверно спрашивать не буду идея очевидны а вы там можете снимать в реальной жизни какие-то видео с большим количеством кадров как бы убирать какие-то промежуточные пытаться прогнозировать сетью то что вы убрали вот про генерацию многие рации материалов мы не будем сильно останавливаться но суть ее такая что там вы снимаете грубо говоря какой-нибудь кусок дерева стан там под таким углом освещение под таким и вам хочется интерполировать как оно будет выглядеть при разных под разными углами освещение это вот что касается желтой группы задач значит красная группа задачи я утверждаю что принципиально иная вот значит про рендеринг сложных объектов например облаков но говорят поговорим как бы всю оставшуюся часть доклады вот а вторую в час мы с вами значит опишем вот смотрите физическая симуляция воды и дым что о чем речь ну допустим что у вас есть какой-то бассейн в котором есть какие-то твердые объекты и вы хоть они там как то двигаются и вы хотите предсказывать как передвигается ну как как движутся частицы жидкости у вас допустим именно такое представление какие-то партиклы в бассейне и вы хотите там вот вас есть в момент времени t вы хотите т плюс дельта т получить положение всех частиц и вот вы допустим решаете там эту задачу как то там от точки ну вот для каждого партикла вы хотите вызовет нам нейронную сеть и получить ответ где она будет на следующем кадре есть идея как решать такую задачу навье-стокса ну значит правильно да жидкость подчиняется значит уравнений навье-стокса для того чтобы нам получить правдоподобно физически корректную симуляцию воды нам нужно хочешь не хочешь а решить уравнение навье-стокса или какое-то к нему приближение как это делать ну делать каким-то вычислителем способом за там за 50 лет последних скажем так ну там даже точно придумали много там способов из алгоритмов ph повышен выезд fluid и так далее для томатов позишн действует внутри используется метод гаусса и зейделя которые как это делает скажем так и значит в чем суть красных задач она состоит в следующем ее отличие от желтой группы задач в желтой группе задач учителем для вашего алгоритма выступает что-то вот как бы свыше то есть либо прям что-то что вы записываетесь реальной жизни как в случае с лицами либо что-то вот из движка там вы там на рендере картинки в даунс сэмпле ли так далее а в красной группе задач учителем выступает какой-то алгоритм из вычислительной математики какой-то метод значит из вот этого скажем так тематического разделения которые я провел вот растет той те которые я хотел до вас донести значит если у вас есть какая то вы действительно сложная задача которого вы решаете ну вот вот видите у себя в работе вы решаете каким-то вот вычислительным методом которым вот вас в университете научили вы его делаете вы делаете это долго упорно тяжело вот и вы хотите как-то ускориться вам вы может быть готовы чуть-чуть потерять в качестве но был очень хотите ускориться тогда найдите самое время затратное место где вот дольше всего ваш код работает посмотрите на эту строчку что то она наверное выдает какой-то ответ и вы пытаетесь про спрогнозировать этот то что она дает с помощью нейронной сети или любого алгоритма машинного обучения это вот такая общая методология это вот как бы такой рецепт как еще можно найти применение для вот для машинного обучения это вот на самом деле главный мой посыл наверное к сегодня дальше мы перейдем конкретному кейсу ну вот идея она такая я понимаю что вы сейчас наверное сидите и думаете о чем я вообще должен таким заниматься чтобы мне эта идея была полезна мой общий ответ на этот вопрос состоит следующем ну используйте вашу креативность посмотрите на свою работу и вдруг найдёте а так сам для семья я занимаюсь графикой дайме я не так хорошо знакомы с разными другими областями но я могу себе представить что можно придумать наверное если вы в какой не будете академической среде если вы занимаетесь прям физико-химии точно найдете что-нибудь подобное всего робототехникой занимаетесь тоже наверное найдете если вы не знаю решаете какой-нибудь сложно физическое уравнение где-то у себя на производстве там я не знаю может быть какое уравнение теплопроводности вещественными подобно не знаю use и креативить вот ну теперь от этой главной идее чтобы оно было наглядно ясно мы рассмотрим конкретный кейс этим проектом мы занимались и найди где-то полгода назад давайте придем к постановке проблемы значит проблема ставится так вам нужно нарисовать физически корректным облака вот-вот просто облака которая представлена как плотность капелек жидкости в пространстве вообще в жизни облака это и вот это как раз взвесить капелек жидкости воды вот и этот объект очень сложно физически его нельзя представить как какой-то твердый твердый предмет на которую вы быстром смогли наложить текстуру и как-то его рендерить так не получится в связи с тем что он очень сложно физически почему потому что вот вас капельки воды они они практически не поглощают свет они его период рожают они делают это они за тропна то есть если вы как бы если мы посмотрим на капельку воды да вот допустим вот у меня висит капелька воды я на нее смотрю и вот у меня есть солнышко за этой капелькой воды и если вектор из моего глаза и вектор и солнышко на накоплю будут параллельны то будет наблюдаться огромный пик интенсивности света с этим явлением ну вот этим объясняется одно один физический феномен которую все в жизни видели вот если вы смотреть за наблюдали за небу и смотрели на облака в солнечную погоду то вы наверняка наблюдали такую яркую границу одну из что одна из границ очень яркого облака она прямо такая там белое практически это связано как раз с тем что вот вы смотрите на эту границу облака и на тех вот вектор как бы вашего взгляда и вектор от этой границы к солнцу они практически параллельно вот значит еще раз говорю облака сложный физический объект его сложно рисовать рендерить это требует очень много времени если пользоваться классическим алгоритмом а классическом алгоритме мы поговорим чуть позже вот сейчас же скажу что в реальности это может занимать там действительно много часов это зависит конечно от параметров ну вот это может занимать и дни вот и понятно что это не может нас устраивать почему потому что представьте себя художником вы рисуете какой-нибудь фильм спецэффект вот вы нарисовали облачко вас какая-то сложная сцена у вас в этой сцене может быть разное освещения да и вы с этим хотите совсем играться вы там нарисовать такую топологию облачка вам не нравится вы хотите перерисовать тут же получить ответ и вам очень важно чтобы ваш как бы чтобы от от от от вашего одного какого-то изменения параметров вы как можно быстрее получили ответ вот это вот скажем пуст он вот такая проблема нужно ускорить нужно ускорить этот процесс теперь передем к классическому решению этой проблемы вообще для того чтобы решить эту проблему вам фактически требуется решить вот такое вот сложное уравнение не пугайтесь она он она конечно суровая но давайте так сказать поймем какой-то физический его смысл значит для того чтобы понять его физический смысл давайте понаблюдаем за жизнью лучика выпущенного из камеры очень просмотрим наиболее интересный случай когда лучик значит выпускается из камерой протекает облака вот он пересекается с облаком есть какая-то точка входа в это облако есть какая-то точка выхода из этого опыта если мы посмотрим на последней терм уравнению 2 термо уравнение то он связан со следующим эффектом что у вас есть свет который приходит от солнце попадает на вот эту точку выхода и по вот этому вектору который выпущен из камеры он приходит в камеру при этом он затухает то есть интенсивность как то теряется за счет того что он проходит через толщу облака есть 1 сложенный интегральный терм этом уравнении которого физический смысл следующий вот смотрите вот у просмотрим отрезок внутри облако внутри облака вот на этом луче то есть от точки входа до точки выхода значит это ты это интегрирование ведется как раз по вот этому отрезку и для каждой точки на этом отрезке мы считаем так называемый вот смысл интеграла 1 и the indirect flight называется опосредованное освещение в точке за счет чего она появляется за счет того что а когда создан когда солнце светит в облака но доходит лучики до камеры и до капелек и капли начинают его по-разному период рожать этот свет и соответственно вашу точку приходит огромное количество опосредованных лучей от окружающих капелек вот интеграл 1 это интеграл по сфере которая окружает в точку на значит на вашем луче вот вы должны вот его посчитать с помощью монте-карло интегрирования в классическому горит и какое каков каков классический алгоритм ну вот вредно ли те картинку который состоит из пикселей вы выпускаете луч который значит идет как бы из центра камеры в пиксели идет дальше значит пересекаете его с облаком находите точку входа находите точку выхода считаете сначала последний терм уровней его легко считать вам нужна ну просто пересчитан пересечь соединить соус соедини солнышком это легко читается и дальше вы начинаете important сэмплинг точек на внутренней части надо на отрезке который внутри опыт значит для каждого сэмпла на этом отрезке вы начинаете монте-карло оценку вот этого интеграла и 1 значит как считать монте-карло оценку и один мы разбирать нибудь почему потому что это сложно нужно рассказывать много проекта что при part in сэмплинг и так далее это не так важно на самом деле потому что недостаточно будет сказать что это самая долгая часть во всем алгоритме и самое сложное вот вам вот нужно получить оценку и 1 значит из главной идеей и постановки значит ну вот описание классического алгоритма следует рецепт как применить нейронные сети к этой задаче что нужно сделать ну как я сказал самое тяжёлое это посчитать монте-карло цен а что она дает но она даёт какое-то число которое означает опосредованное освещение в точке значит что нам нужно предсказывать нам нужно предсказывать именно то что выдает этот строчкой монте-карло оценку освещение в точке значит со входом скажем так определились с выходом простите с выходом то что вот мы хотим предсказывать определились теперь нужно понять что с со входом из чего из какой информации мы можем извлечь эту из какой информации будет ясно какой значит от какого каково вид какова величина его следовало значит свет от в точке значит очевидно так как я сказал что это свет который при отражается от многих капелек воды которые окружают . значит из этого следует что ну очевидно топология от плотности вокруг точки должна на это сильно влиять и действительно она влияет также влияет естественно этом направление на источник и направления на камеру потому что это связано с тем направление на камеру потому что как я сказал капли при отражают свет не не и за троп значит как как нам сконструировать вход в нейронную сеть ну нам нужно прежде всего описать в локальную плотность как это сделать сделать это можно очень много как мы сделали так значит ну вообще я не сказал но мы ориентировались на статью значит disney который вы можете найти вот на этом сайте отвезут значит многие идеи мы почерпнули оттуда значит как представить локально плотность вокруг точки значит давайте сделаем так возьмем сначала зафиксируем констант достаточно маленькую пусть это будет длина свободного пробега в этом облаке это достаточно небольшое число ну можно брать какие-то доли от него но это неважно значит взяли константу теперь давайте нарисуем вокруг точки над нашим отрезке сетку какого-то фиксированного фиксированного размера прямоугольную вот такой объемный значит в центре этого кубика будет наша . значит сетка допустим 5 на 5 на 9 шаг этой сетки вот эта маленькая константа которую мы зафиксировали в узлах этой сетки мы будем измерять плотность облака теперь давайте увеличим константу в два раза нарисуем сетку побольше значит сделаем тоже самое будем измерять плотности в узлах сетки так сделаем несколько раз мы это делали десять раз тогда после этой процедуры вы получите 10 лет так 10 таких тендеров в котором каждым будет храниться плотность облака как каждый из этих тендеров будет охватывать все большую и большую окрестность вокруг точки до знаете почему представление такое а правда правда потому что как бы мы хотим максимально подробно описывать как бы маленькую область и чем чем мы дальше тем менее подробно мы хотим описанием вот кажется такое описание нам дает это значит ведь значит с выходом сети определились со входом сити определились теперь что нам нужно сделать ну нам нужно понять как обучать значит ну давайте сделаем это так давайте на генерим 100 разных облаков с разной топологии будем применять алгоритм 1 докупаем просто их green dress будем применять для этого алгоритм 1 и будем за алгоритмом 1 записывает что он что он получает той самой строчке где он осуществляет монте-карло интегрирования также будем записывать фичи которые при этом значит соответствует точке значит получим дата сайт на котором можно обучаться теперь что обучать значит архитектура сети которую мы используем архитектура сети для этой задачи кажется является но не самым ключевым моментом поэтому если вы ничего не поймете не переживайте это не самое важное что я хотел было сегодня донести но все же значит такую архитектуру мы использовали вот смотрите для каждой точке мы имеем 10 тендеров каждый из этих тендеров по счетам на все на более масштабной сетке значит каждый из этих тендеров попадает в соответствующий блок вот который вы видите на слайде сначала тензор попадает в 1 fully connected слой обычный falcon этот слой после этого выход из первого фулика никто слоя попадает во второй fully connect слой у которого нету активации и сумму потому что вот новых улик объекты слой без активации спроса-предложения матрицу вот вот вот этому приумножению на матрицу мы добавляем выход с предыдущего президио блока и только потом применяем активацию вот вот такую архитектуру мы использовали вот соответственно я думаю что должно быть понятно что вот вы берете точку посчитали эти значения плотности на каждый сеточек положили значит эти тендеры в соответствующей видел бог и собственно можете проводить интернете нейронной сети значит идём дальше ну мы всё это сделали и убедились в том чтоб мы получаем картинки облаков замечательно значит ну первое наблюдение первое наблюдение понятно что мы получили то что хотели в том смысле что наша вызов нейронной сети если его сравнивается монте-карло оценкой то нейронная сеть работает быстрее чем manta горация поэтому как бы уже уже хорошо значит но есть еще одно наблюдение за результатом обучения значит это сходимость по количеству сэмплов о чем речь очень смотрите вот когда вы арендуете картинку давайте нарежем ее на маленькие тайлы тайлы это какие-то такие квадратики из пикселей 16 на 16 будем смотреть как бы рассматривать один тайл изображение без ограничений общности значит когда вы рисуете этот этот файл вам нужно на каждый пиксель выпустить лучше с камеры при чем как бы все это делают не выпускают ни один луч а много зачем ну выпускает много лучей из одного как бы соответствующие одному пикселю но делают в нем немножко добавляет немножко маленького такого шума к этим кучам чтобы они были чуть-чуть разные это эти лучи называются antialiasing а вы ими и изобретены а не для того чтобы понизить шум в итоговом изображении значит вы выпускаете на каждый пиксель сколько-то antialiasing овых лучей потом вы на внутри на внутренней части луча из камеры в облаке вы на отрезке рендерить и сколько то значит н сэмплов значит вот этих точек в которые вы хотите ну либо проводить монте-карло оценку либо для них вызывать эти вот и еще есть сэмплы который соответствует соединению так скажем с источниками света откуда они берутся когда вы ну вот соединяете точку всегда там с источником света скажем солнцем это сделать легко потому что солнце это просто такие падающие параллельно друг другу на землю лучи с неба например это гораздо более сложный источник света потому что небо представляется виде бесконечно удаленной сферы у которой есть функция цвета по направлению то есть джим если вектор смотрит прямо вертикально в небо над а цвет вот прям самый синий потом он там как-то светлеет внизу сферы обычно делают ну какой-нибудь нейтральный свет в духе там коричневым как бы имитирующий зим вот и соответственно когда вы соединяете их значит точку с небом чтобы понять сколько в нее света приходит вам всегда нужно вам всегда нужно выпускать несколько лучей чтобы получить как бы ответ сходящиеся к правительству потому что вы не можете только один выпустить вам нужно как бы побольше выпустить чтобы более хорошую оценку получить вот поэтому в общем вам на на как бы на весь pipeline брендинга нужно вот вот столько скажем так сэмплов и что мы заметили когда обучили нейронную сеть это то что для сети сесть выучивает гораздо гораздо более усредненное скажем так решение и поэтому если мы зафиксируем количество сэмплов то мы увидим что классический алгоритм сходится вот там левую левому ряду колонки картинок а сеть выучиваются к правому это не значит что когда научится что оригинальный метод плов вообще нет это значит что мы просто быстрее сходимся то есть когда мы увеличим количество сэмплов то оригинальный метод все будет будет ближе ближе ближе к к тому что получаемые вот ну и такой главный главный наш результат это конечно то что мы хотели это повышение скорости рендеринга ну и вот вы видите что для там бот для wot для какого-то конкретного облака в конкретном разрешение из с параметрами сэмплов мы видим что картинки полученные за счет сети и за счет классического метода практически идентичны но при этом правую картинку для меня да и для вас мы получаем 800 раз быстрее ну в общем получили то чего хотели вот теперь я немножко расскажу про реализацию того как мы все это делали значит есть такая программа для 3d моделирования которая называется блендер она у консоль сна и в которой реализован алгоритм 1 мы не писали алгоритм 1 сами мы использовали блендер для этого то есть мы проводили обучение в блендере записывая за алгоритмом один все что нам нужно и также мы как бы и скажем так production мы тоже делали в блендере то есть мы обучили сеть в тендер flow потом перенесли из в си плюс плюс с помощью тендер рты уже тендер rt сеть мы интегрировали в блендер потому что его код открыто и так далее вот ну и соответственно так как мы все это делали для блендера у нас есть ну как бы все фишки блендера которые есть у него они как бы есть в нашем решении то есть это значит что вы можете арендовать какие угодно сцены вы можете сделать много облаков и так далее все у облака там в нашем решении задаются следующим образом вы как бы дефо не делайте кубик которого в котором вы внутри определяете функцию плотности грубо говоря таким специфическим для 3 темп программ способом не будем на этом останавливаться вот вы можете это делать так же вот мы провели некоторую оптимизацию этого значит процесса в том смысле что мы копируем плотность есть если пользователь хочет одно и то же облака нарисовать одну в куче разных сетапов сцены то там при разном освещении с разными каким-то объектами на сцене чтобы ему но не пересчитывать постоянно этот тэн за плотности облака вот предлагаю вам посмотреть наши дома видео я очень надеюсь что она запустится так так извините что смотрелось плоские проблемы еще помещение так хорошо бы вернуться отлично вот но кажется про проект я рассказал ну и напоследок а как бы вот и нас вот своего доклада я хотел повторить эту мысль что еще раз что вот главное что я хотел сегодня донести это то что если вы видите своей работе чтобы что-то долго усердно считаете каким-то каким-то специфическим вычислительным алгоритмам и вас это не устраивает попробуйте приложить идею которую я вам сегодня сказал как-то найти в нем самое тяжелое место заменить его на нейронную сеть и может быть вам это поможет вот-вот на наверное на этом у меня сегодня все дальше будет опрос спасибо большое за доклад очень действительно интересно просто немножко в науке работал у меня вопрос вот какой то есть помимо изображения на ваш взгляд вот ваши алгоритмы они могут позволить посчитать массу воды в облаке то есть вот с этой стороны если зайти да потому что если говорить про оригинальные методы они создали подразумевают до разбиения на частички и там изначально это есть а ваших алгоритмах можно пересчитать на массу масса облака да то есть масса воды которая заключена в облаке так ну а какой вход ну то есть как она задана ну это уже второй вопрос дается спрашивает да то есть нет прямой до пока не можете ответить но смотрите но у нас наша плотность облака просто задается как бы функции от x y z в каком-то кубики вот причем ну мы в финале мы осуществляем ну как бы мы изначально предпочитаем плотность ну во всем кубики вот кладем ее в какой-то массив и уже вот с этим массивом скажем так оперируем то есть у вас изначально по большому счету масса дано но у нас скажем тогда у нас с каким коэффициент в заду но ладно да по сути ну да я скорее ну вот так задачи например если вы видите облака на небе то есть и видите его изображение можно ли используя ваши алгоритм посчитать количество воды в конкретном облаке которые мы можем заснять на небе ну кажется это совершенно другая задача возможно да но тем не менее ну ладно то есть может вопрос не не совсем как я не теми но но но как бы это интересно действительно для того чтобы на него ответить нужно подумать не не 30 секунд хорошо спасибо спасибо за доклад скажите а вы не пробовали в вашу идею такую довольно перспективное прикладывает чему-то гораздо более простому не знаю там научить мы сортировать массив или искать максимальный элемент в нем нет мы не пробовали вот конкретно сейчас лично я занимаюсь вот симуляции жидкости я делаю решая скажем так правление навье-стокса но такие алгоритмические задачи скажем до из компьютер сайнс я честно говоря я не ну и я не про ним не думал не над каким проектом в этой область то есть речь идет скорее про оптимизацию каких-то вычислительных лагов размера там вычислительной математики на этом чего-то довольно приближенного спасибо спасибо за доклад как известно облака могут быть разных типов разных видов до разные типы облаков перистые множество их типов вы когда формировали тренировочную выборку вы на какого-то типа облаках тренировались правильно я сейчас подробно отлично этот вопрос спасибо смотрите да действительно как правильно вы отметили облака бывают разные облака бывают перистые такие или прям надутые тучки плотные вот это скажем так значит означает что скажем просто порядок вот этой плотности он разный чем больше плотности вот она такой буре густое the blood и вот и для того чтобы ваше решение работала на всех облаках сразу нужно сделать следующий трюк значит как я упоминал в докладе у облаков есть такое понятие мин flipas мин 3 пас длина свободного пробега до такая физическая величина которой зависит от плотности там есть формула пересчета скажем так как пересчитать мин крипас зная значит плотность вот и значит вы нами in free пас завязываете вот измерение вашей плотности то есть ну вот эти сеточки и как бы делает такой трюк вы в итоге получаете но решение для всех облаков вот и соответственно учились да мы учились на разных плотностей ну мы там нагини релиз примерно ну мы создали такую функцию которая при разном грубо говоря рэндом сидя дает разную форму там и ноги не riley 100 облаков до поры дарили их там вот в каком-то адекватном разрешение и кругу вариантом для всех для них то мы записали но мы это делали на классе и ну по-моему это занимало порядка там одного дня максим спасибо за доклад этот а ваш облака тают штата юта благ оживают умеют таять то есть если допустим какие-то процессы перемешивание на границе правильно было катают у них есть реальные цикл ну то есть это реальный цикл жизни опыт к этому еще может рассеется смотрите наша задача касалось того момента когда у вас вот фиксированный момент времени у вас задано плотность и вы в этот момент хотите его нарисовать почему вы говорите это физическая симуляция того чтобы должно происходить с облаком то есть этого наш метод никак не касается то есть по-хорошему для того чтобы вам сделать вот то что вы предлагаете вам нужно отдельный алгоритм который двигает как бы облака в зависимости там от ветра еще чего то и потом для каждого вот этого кадра когда вы из вашей физической симуляции получили как бы тензор плотностей тогда вы уже можете применять этот метод чтобы получить картинку вот у меня такой вопрос а насколько это реально интегрировать в real time решение то есть почему это не использует вообще все очень впечатляющие результаты прям вау смотрите это решение достаточно быстрая но на ней риэлтор далеко не real-time то есть шесть минут это не кирилл тает в чем разница просто далёко ну real-time это было бы если бы мы один фрейм и рисовали скажем там за 16 миллисекунд да и тогда тогда это был бы ад ну то есть вы могли перерисовывать на каждом я имею ввиду что использование машин леоненко но более ска скорострельных задачах которые само собой должны уложиться в некий fps я смотрите если вы ваш вопрос значит почему это не достаточно быстро для real-time а то ответ такой там нового изотов во-первых из-за того что вам нужно очень много лучей выпускать тем не менее вторая причина это то что вам нужно постоянно лазить в массив с плотностью потому что но я сказал что но стендор в 10 каждая сеточка это 5 там на 5 там я не помню на на 7 допустим вот и у вас на каждый лучик у вас еще там несколько сэмплов и вам нужно для каждого из них собирать фичи в общем это скажем так не совсем предстоит а me feel the вот я ответил ч в теории это возможно использовать там это же тоже там есть какие-то традиции от ратные задачи где можно интегрировать машин я им не ну да я верю в то что ни есть да какие то другие то что есть вопросы за счет что наверно все хорошо спасибо за доклад со хотел поинтересоваться каким образом пришли к такой архитектуре найра сети и пробовали какие-то еще другие дамы пробовали какие-то еще другие в частности там конверсионный и fuli коннектор вот и на самом деле ну как бы даже fully connected может выучить более-менее правдоподобный результат ну то есть если рассматривать r-квадрат до в метрику там прогнозирование этого значит не direct light а то скажем наша финальная нейронная сеть отличалась вот там fully connected в r-квадрат там ну порядка там увлекает это там полная скажем на 10 15 процентов меньше да то есть как я сказал это не самое ключевое место почему такое но вообще отчасти потому что вот в том то есть те которые я упоминал применяли именно такую архитектуру вот кажется почему и ответил и собственно про качество это же ответил таких вот еще вопрос и если вопросов больше нет то есть а есть как собственно обучали модель то есть у вас он есть картинка оригинал да и картинка которую вы получили на выходе его получается по пиксельных сравнивая или не-не-не-не-не-не-не смотрите еще раз мы у нас data set состоит из вот измерений плотности на сет очках которые окружают точку ответ который мы хотим это это manta карла эстимейт indirect fly то в этой точке это флот да и соответственно вы учитесь папа вот этим значит измерением плотности выдавать и этот флот вот соответственно как бы когда мы обучались мы там использовали немножко модифицированные простая мысль и но не мысля ну там с одним каком логарифмический ну неважно и мы приближали как бы то что то что выдает монте-карло интегрирования свои сети вот потому что картинка только по одной точке когда получается но тут нет понимаете в финальную картинку дает вклад не только интеллект flight данное 2 терм уравнения которой я сказал как-то я говорил вот поэтому как бы в картинках это не не работает скажите пожалуйста вот такой вопрос если опять же применительно каким-то другим задачи математического моделирования делали в какую-то оценку насколько у вас отличаются решение честным численным методом численным методом которые да там применяется в этой области и вашей и моей моделью спасибо ну конечно когда мы смотрим на вот мы как раз и получаем собственно то как расходятся вычислительный метод и наш метод значит на самом деле ответ на ваш вопрос такой когда вы используете вычислительный метод да каждый вычислительный метод имеет свое значит ну свой какой-то параметр который удлиняет время его работы при этом делает качество больше соответственно как бы тут важно чем сравнивать да то есть как мы делали мы когда проводили монте-карло оценку в обучении да мы ее просто делали не там с невероятно большим количеством ну в общем мы очень сильно делали мощным вот параметр который делает очень качественно это но как бы такое качество на предсказании света в одной точке она не требуется потому что в финале все равно усреднить и по точкам на отрезке и поэтому то есть у нас там r-квадрат был например 06 r-квадрат метрика и ну то есть это как бы наверное если там подумаете сравните с какими-то другими запусках задачи вы скажете о наверное это плохо но это неплохо потому что финале вы все равно получаете усреднение за много за много сэмплов и поэтому как бы все все сходится и когда ну то есть вот то то те параметры которые скажем так удлиняют время работы мы такого интегрирования вот в нашем обучении и в как бы значит в оригинальном подходе когда вы его просто считаете они очень сильно отличаются да то есть когда люди рисуют помощи алгоритма один облака они вот эту монте-карло интегрирования делают очень небрежно то есть там выпускается грубо говоря там один но я не рассказал о том как это происходит но в общем там очень слабая монте-карло оценка используется когда вы считаете для одной точке но простая что имел ввиду то есть понятно что в задачах томат рендерить облака да как бы не но погрешность не критично если считать какую-то математическую модель применительно к скажем так другим задачам это может быть очень критично ну да конечно но как бы тут при понимаете тут тут нельзя сказать что вот ну вот я показал применение такой очень общей идеей даты и то есть все будет очень сильно зависеть от задачи до тот r-квадрат который получил приучили мы в для этой задачи на он может быть совсем быть никого не устраивает в другой задачи и тут тут очень много ну как бы подробности до которых ну который именно скажем специфичны для задачи и в общем на этот вопрос нельзя ответить без задач и вот как то так"
}