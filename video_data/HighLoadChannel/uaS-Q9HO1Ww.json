{
  "video_id": "uaS-Q9HO1Ww",
  "channel": "HighLoadChannel",
  "title": "HighLoad для начинающих / Дмитрий Обухов (Mail.RU)",
  "views": 2901,
  "duration": 2139,
  "published": "2017-04-10T06:15:26-07:00",
  "text": "чтобы как бы начать с того чтобы рассказать людям что такое highload надо определиться с того что такое термин да ну каждый раз когда мы что-то начинаем объяснять мы определяемся в терминах да то есть давайте попробуем определиться что такое хайло вы ну то есть эта конференция это все понимает а то что эта конференция это всем понятно ну и соответственно дальше пытаемся как бы разгадать этот термин ну соответственно начинаем с естественно с прямого перевода в эта высокая нагрузка ну вот есть еще такое мнение что понятия хай вот в общем-то не существует это ну люди рассматривают вообще как бы ситуацию следующим образом либо у нас сервер справляется с нагрузкой и тогда одну говорить о том что нагрузка высокая в общем то смысла не имеет либо соответственно у нас сервер эта нагрузка не справляется и тогда говорить о том что у нас как бы очень крутой сервер смысла не имеет ну поэтому как бы есть такая можно попробовать определиться что такое высокая нагрузка год соответственно такую цифру я выписалась к кипения хватит нам там 53 миллиарда запросов в секунду как бы не понятно да ну это как бы средний спаун а сейчас столько запросов секунду делают это а и семьи но если говорить подходить более реалистично то надо определиться в каких-то цифрах да ну и сказать что вот например один запрос секунду у нас вот как бы на эта нагрузка явно типа не хайло да или нет ну вот любой сервер вроде справиться даже с одним запросом секунду но например если он перекодирует видеоролики то тут опять может наступить highload ну и соответственно я определяю высокую нагрузку как собственно нагрузка с которой железо не справляется по какой-то причине ну вот такой вот ослик вот соответственно когда у нас происходит высокая нагрузка и вообще начинают вести речь isla de когда мы как достигаем каких-то технических ограничений то есть у нас там кончается что-нибудь антипу память там вот здесь хранились вы вынес в отдельный пункт а потому что это как обычно для веб-серверов хранилище это какой-то внешний элемент а вот и соответственно ну и дополнительно как трудности показал соответственно с чем мы сталкиваемся сейчас уже менеджеры перестали раньше вот ну лет пять-семь назад когда менеджеры покупаю там вам новый сервер там а вы потом через какое то время говорить нам этого нового сервер не хватает нам надо побольше мы даже сдавали такой глупый вопрос сейчас как-то не уже подросли перестали задавать то есть они говорили мы вам купили самые крутые компьютеры на свете там а вы его как-то умудрились тормознуть вот сейчас они такие вопросы не задают но вопрос не до использования железо это в общем то самый основной вопрос то есть если вернуться вот предыдущему слайду что средний процессору на сейчас там 53 миллиарды операций в секунду делает то как объяснить людям почему тормозит очень сложно ну и трудности масштабирования все эти как бы проблемы которые происходят с высокой нагрузкой они сводятся к одному термину архитектурные проблемы нашем проекте вот ну и соответственно для иллюстрации как бы мы рассмотрим вот типичный веб-сервер написано неважно на чем ну соответственно на пир летом на питоне на руки ну вот мы берем например стандартный какой-нибудь фреймворк делаем веб-сервер то мы запишем там форум там доску объявлений и так далее ну и соответственно вот задача одного цикла этого сервера сводится вот перечисленным пунктам запросы сети читается парсится отправляются запросов в базу данных и соответственно формируется ответ это отправляется клиент если говорить о традиционной реализации апать например там ну или другие варианты там фа си джей это неважно в общем то все это сводится к тому что на одну сессию выделяется один процесс ну или 130 стоит одно и то же опять не работает ну и соответственно начались разговора хайло to highlight это вот как я определил это нагрузка с которой не справляется железо да то что вот в этой архитектуре лили могут сделать они могут увеличить число процессов на один цикл число процессов или трейдов которые работают либо как бы масштабировать уже по серверам то есть вводить в строй сервера ну вот и если мы мы рассматривали один как бы сервер одну страничку одного сервера вот который был проблемной и это это как бы здесь реально измерение это сама которая часто звучит вот мы взяли одну из страничек проблемного сервера и стали ее осматривать значит у нас получилось так что примерно на 100 запросов в секунду наступать highload вот и соответственно ну первое что сделали это увеличили число процессов в работе то есть там было восемь процесса сделали этот 20 потом 30 и так далее ну и где-то все вроде помогло ну это самое на 150 запросов секунду опять начались проблемы вот и что делать значит тут вот в этот момент к вам сразу прибегают всякие менеджеры начинают говорить я тут сходил на highload нам рассказали про мега какую-то там крутую технологии мы сейчас купи все перепишет да ну тут их сразу останавливают люди которые говорят мы над этим три года работали переписывать нам на тоже тревога что делать добавлять второй сервер это тоже как бы не всегда просто ну и соответственно лечение любой болезни начинается с того что мы пытаемся поставить диагноз для начала хотя бы измерить температуру а потом уже как бы сделать какие-то выводы мне вот эта штука не работает вот если ты снаут мы провели одну страничку взяли вот веб-сервера который тормозит и которая была довольно популярна и провели измерения поучили ну такие вот рпц что запросы сети читаются вот там 15000 в секунду парсится 150 и в секунду ну и так далее вы видите эти цифры вот и соответственно здесь я научился в латексе формулы короче выводить это очень круто вот и соответственно если мы вот эти цифры все на них смотрим у нас получается какие-то ужасные быстродействия в каждой нашей части нашего сервера в целом но вот весь и мы их начинаем друг другом складывать то получается расчетная производительность нашего сервера вот этого простого которое взяли деле фреймворк на коленке как бы из кидали вот 6000 bs но тут менеджер продолжает бегать тут у нас проблемы на 150 что это что делать ну и соответственно начинаем смотреть над над на то что мать и benchmark что мы сделали ну мы как бы видим что если хранилище придвинуть к серверу максимально близко еще клиента прямо посадить за сервер то вроде бы становится хорошо вот ну если вот резиной ситуации то у нас мы работали над сервером несколько лет вот в этой парадигме программировали а и соответственно и и сейчас менять очень сложно и но при этом как бы вот все части видим что все части нашего сервера работают с достаточно производительностью которые еще на несколько лет вперед должно хватить вот если мы посмотрим а ну мы так то есть стоит уже начать смотреть не на бенчмарки она profile то есть на то сколько времени занимает сколько какой процесс вот и соответственно войти в мире все идут по такому пути что они открывают какие-то эти закономерности и эти майки закономерностям всегда есть в реальность жизни какая-то аналогия вот 100 слоёв здесь нашему серверу построил вот такую аналогию и работает соборным магазинам то есть вот если вы приходите в обувной магазин а толку но т.к. может быть кто заходил к вам на вас сразу набрасывается один менеджер до который вот с вами бегает туда-сюда то есть вы приходите смотрите так вот эту обувь не подходит не подходит там он вам может бегать на склад принести и так далее вот если вот список вот этот слева и справа сравнить они очень похожи вот и соответственно если вернуться к серверу то вот если мы это перейдем от бенчмарков профайлу и каждое время от каждого пункта выпишем то у нас получится в одну те же цифры что на предыдущем слайде просто единица на x там как бы получиться вот такие циферки что мы ждали запросов данных от пользователя там 70 микросекунд и parcel и проект запрос допустим 6 микросекунд это цифры как бы реально они просто округлены там до круглых вот соответственно и того что у нас получается когда мы уже на результаты профайлинга посмотрим получается что код наш выполнялся 17 микросекунд а чего нибудь ждали там ответа база данных ответа сети выполняли ждали 106 однако секунд примерно ну и соответственно тут на возникает какой-то дисбаланс у человека в голове цамо что наш код выполняется на десять процентов времени и как бы при этом все тормозит нагрузка 30 там ничего делать не надо ну и соответственно ну тогда когда это все проходили вот написали такую потрясающую программу которая имитирует соответственно высокую нагрузку эта программа ничего не делает кроме слипов то есть на месте каждого действия в нас slip но такое же время микросекунд как вот была замерена если кстати сказать о реализацию slip то в линуксе где-то начинать ядра 26 ослепляя реализован реальным usb лением процесса то есть до ядра 26 там еще можно было как бы предъявить претензии к реализации у slip ну сейчас вот это действительно реальная модель вашего веб-сервера вот и значит что получилось вот этот вот код это замечательная программа она получается спокойно очень грузит процессор это на 15 процентов как при этом ничего не делает ну и соответственно когда мы запускаем вот таких маркеров а примерно столько же сколько у нас worker of pop черта получаем ту же сам нагрузку на хвосте те же там 20-30 единиц вот upgrade вот и целостность и вернуться к нашему серверу ну вот это я уже много рассказал каждая отдельная часть имеет большой производительностью что же нам делать ну и соответственно как бы раз каждый кирпичик у нас удовлетворяет нам нас по скорости то нам надо просто взять и пересобрать эти кирпичики в каком-то другом варианте просто взять и реорганизовать код ну вот так соответственно ну и тут мы как бы переходим к событий на ориентированного программирования то есть это нас начинаем читать что у нас происходит в мире как что люди думали по этому поводу и натыкаемся вот на такие вещи очень хорошее высказывание рекомендую над ним подумать то есть компьютеры это конечно автомат вот соответственно когда компьютеры реализует парадигму трендов он сводит все все равно xy конечному автомату простой вам имитирует эти тренды и поэтому вот ну и соответственно есть умные люди говорят что нужно избавляться от родов надо от них избавляться ну еще заодно и от процессов вот ну и соответственно если мы вернемся к магазину то очевидно что если в магазин обуви придет сразу там 100 покупателей то никаких мониторов не хватит и надо будет что-то как бы реорганизовывать и в реальной жизни люди давно справились задача высокой нагрузке магазине они просто продуктовый магазин устроен совсем по другому то есть всех клиентов ставим в очереди и продаётся обслуживает всех без простое ну и надеюсь это аналогия всем понятно вот ну и соответственно войти мере вот этот продуктовый магазин он как бы представляет из себя машину события так называем машину событие то же самое соответственно исполнитель заявляет о готовности выполнить задачу который мог дать приходите там обучить свободная касса вот и соответственно как только попади подходит его сразу начинают обслуживать а если вдруг попать или что-то нужно подождать то его ставят другую очередь ожидающих там чего-нибудь например все все кто вот своего были со склада они все стоят и ждут и в порядке очереди ну вот войти мере это соответственно получается реализация продуктовых магазина она сводится к тому что исполнитель подписывается на то что он выполнить задачу то есть регистрирует call back выполнение задачи это собственно вызов call back a и ожидание это соответственно возврат машине событий управления чем возврат искал бег а вот и соответственно если мы возьмем еще не весь сервера просто для эксперимента перестроим вот этот вот веб-сервер который у нас проблемный на вот эту парадигму то получится что нам придется заменить следующие вещи в этом сервере это собственно интерфейс с веб-сервером интерфейс база данных интерфейс с сетевыми какими-то вещами если они есть вот и соответственно что мы увидим мы увидим что производительность нашего сервера выросла как минимум в 10 раз вот такой реорганизации ну вот это вот странички если мы среднего время ответа тоже возросло но общая производительность выросла более здесь сразу при этом одного процессора хватает для того чтобы обслуживать более здесь сразу большую нагрузку чем она до этого было вот но вот проблемы которые приходится решать это собственно поскольку мы меняем парадигму программирования приходится соответственно думать о сохранении контекста между call беками там выделения и так далее и соответственно что затронута изменить изменениями я уже сказал а соответственно самое критичное что во всех проектах бизнес-логику обычно строят около базы данных то есть выбрали данные там этот самый что-то посчитали именно вот на стадии или прямо внутри базы данных считают или рядом с выборками и поэтому все вот эти вот условия там что-то типа если клиент предпочитает зеленый цвет это вот его направить если краснота сюда они все около базы данных находятся и поэтому переписывать все запросы в базу данных накал бекки это практически его потому что 90 процентов проекта будет переписана ну поскольку нам это не подходит то нужно что сделать нужно попытаться соединить плюс и обувного магазина и плюсы продуктового магазина а в продуктовом магазине менеджер не простаивают в нашем случае менеджер это процессор вот пытаемся соединить и плюсы ну вот как если вот вы смотрели на эту потрясающую программу со слепыми там то почему она тормозило я как бы не коснулся можно сейчас немножко рассказать планировщик процессов в операционной системе это вещи очень тяжелая во первых при каждом переключении процесса происходит переключение контекста очень тяжелого то есть процесс изолируются друг от друга и так далее во вторых этот планировщик помимо всего прочего он очень пытается синхронизировать вот эти переключения с частотой 1000 герц то есть ещё вот здесь как бы проблемы есть по скорости и соответственно если мы возьмем плюсы от того что мы имеем планировщик и соединим их с плюсами вот event машины то как бы мы соединим продуктовый магазин с магазином обувным и для этого под пишем свой планировщик ну вот эти планировщики и люди часто называют слайдерами где-то называют гринд рядами во многих языках есть на это позже коснусь то есть основной api сводится к тому что процесс можно создать и из процесса можно передать управление планировщику а прервать процесс не может потому что не вытесняющая многозадачность ну вот то есть мы отказываемся от всех плюшек от рациона процессор что она системы в году быстродействия вот и теперь значит если мы интегрируем планировщик с машина событие то получим примерно такую структуру кода на каждое вот где был у нас call back там что мы чьими ждали получится вот такая структура события то есть мы подписываемся на события сам и засыпаем в этом цепляем текущий процесс события будет и процесс продолжать таким образом программа становится обратно такого же линейного вида как она и была то есть типа запросили в базу данных сравнили результаты с каким-то эталоном и пошли по веткам или влево или вправо вот то есть вернулись мы почти традиционного веду программу ну и соответственно что у нас получается в веб-сервере веб-сервер нам пришлось добавить машин событий пришлось добавить файбер и то есть библиотеку файтеров и переписали все интерфейсы которые у нас что-то где-то на которых мы ждали и ждали как правило вот на интерфейсах с веб-сервером с базой данных из сети если она есть вот ну и того получается что и все это вот это переписывание вот в такой парадигме сводится к тому что мы пишем ветер над база данных wrapper над веб-сервером европе рн от сетевыми обращениями и всего вот ну в общем проекте получается можно свести к переписыванию 5 процентов кода и получить профит вот есть говорите о библиотеках на языках то соответственно вот на перле просто прекрасная библиотека кора 1 вот собственно реализуют концепцию fider а вот это вот легкая планировщика плюс any event это соответственно машина ну на питоне файбер и twisted сидишь так и называется библиотека если посмотрите она пока по 5 вот соответственно наконец успеха p55 по моим появился оператора и лт и вот ну и соответственно эти все парадигмы они становятся доступны и на и паковал программистом ну единственно что пока еще в конкурсе я проектов не нашел проектов реализующий фейдеры ну и соответственно что дальше дальше мы когда мы открыли для себя эту технологию сразу побежали типа да давайте мы все что у нас тормозило думаю переписывать такой породить ну и доходило до смешного люди там как бы начинают уже простые циклы for ее от одного до десяти переписывает в асинхронном в форме то есть в каждом цикле передавать управление планировщику типа бог с ним что мы один запрос от пользователя обрабатываем допустим 5 секунд но зато мы можем есть использовать или в секунду обработать но в целом как бы существует целые фреймворке которые вот под эту парадигму программирования написаны вот например на джесс но джинсы то как будут изначально асинхронный веб-фреймворк то есть они изначально думали вот именно оба утилизации одного процессора по максимуму но единственное что вот когда к ним несколько лет назад пришел человек предложил патч которого от реализует парадигму фейдеров легковесных процессов они от нее отказались но последнее время вот недавно буквально где-то дня дней пять может назад была новость о том что сейчас сам язык вот javascript добавляют операторы и лт и на этом операторе youth то есть на картинах по сути дела реализовать файбер уже очень просто и я думаю что но джесс рано или поздно вы как бы это как этой парадигме придет ну вот и наш тарантул соответственно сейчас скажу пару слов тарантул это представляет сейчас вот полноценный application servers которые вот полностью реализован или и реализует предоставляет пользователю вот эту парадигму программирования то есть файбер и и and machine соответственно плюс на борту имеет неплохую базу данных сейчас вот как бы она вы уже в двух ипостасях то есть база данных памяти база данных на диске ну и соответственно как бы имеется серия библиотека которые реализуют не блокирующий соки ты диск там кто-то сервер очереди ну можно самим писать уже чем хочется вот ну общие недостатки этого подхода когда мы то есть начинаем этот подход везде внедрять это выясняется что на традиционных языках программирования а этот подход позволяет утилизировать в общем-то только один процессор а когда у нас нагрузка растет рано или поздно приходится к масштабированию и поцелуй паха станут все равно ну и соответственно как бы люди очень много думали над этим делом и вот уже очень давно существует языке эрланд которые все эти проблемы в себя как бы себе решает он имеет очень хороший масштабирование по полу по хостам но как бы очень большой порог вхождения то есть очень трудно объяснить программистом что вот на вот что в языке программирования нет понятия переменная например вот ну вот недавно появился гол более низкий порог вхождения потому что он него соответственно парадигма программирования более традиционно там есть те же самые перемены и так далее можно попытаться посмотреть вот ну и соответственно вот мы на вот этой парадигме программирования написали в свое время крупнейший бака для яндекс такси до него сейчас примерно вот такая нагрузка где-то 20 тысяч водителей постоянно шлют координаты там один миллион заявок но как бы общее количество информации трафика большое вот проект реализован просто на перловых скриптах там кора плюс any event и множество вот очередей вот на этих клиентов перед менеджерами ставим очередях вот на таран то ли вот с помощью тарантул лезвием очереди ну и хранилище большим большое дисковое хранилище на по за грехи ну вот соответственно этот проект реализует у нас мобильное приложение клиента водитель обеспечена и так далее все это как бы болтается всего на двух серверах hetzner один из них резервный вот вот такая штука ну соответственно если кто захочет попробовать можете поставить и за повтором ну и вот когда мы эту технологию как бы освоили да все поняли что мы очень крутые программисты и соответственно это у меня было 2 часть доклада я сейчас верна тоже расскажу в есть еще немножко времени про база данных вот когда мы оставим когда мы научились хорошо использовать процессор то рано или поздно мы дойдем до холодов базе данных но обычно вот таким простым в проектом загрузить базу данных до того чтобы начать говорить о хай воде это ну как бы сложно скорее всего бывает от неумения или там но не понимание что такое база данных вот с этой сумме вот вторая часть доклада про база данных вот у нас случился highload с базой д с базой данных то есть базу данных не справляется по скорости ну и соответственно что делать и тут опять начинают менеджеры бегать и говорить мы сейчас там купим крутой оракал там или еще чего-нибудь или там самое мы сходили на highload нам предложили вот но и опять и как бы лечить больного надо с того чтобы начать смотреть что у него болит вот и соответственно но здесь мне немножко времени маловато это сама такой как бы вопрос был в аудиторию что представляет из себя любая база dataset у каждого человека должен в голове быть уложена тот изначально и понятие да вот кто-нибудь может сказать что такое база данных вообще ну в моем как бы определение база данных это просто массив записи каких-то то есть принципе все базы данных в сводится к этому определению ну или несколько массивов записи то есть и говорить о базе данных с несколькими таблицами да ну и соответственно около этих массивов данных просто у вас любой базе данных существует средство ускорения поиска по масел то есть вот если говорить философский что же такое база данных то это вот сводится вот к такому простому определение и все вот ну и соответственно если мы говорим что база данных у нас это просто массив то соответственно какие виды поиска по массиву ну это понятно да существует либо простое сканирование либо взять ее из индексы индексы как правило как правило яндекс и сводятся к логарифмической сложности но иногда некоторые вот например хэш яндекс может может свестись к сложности от единички ну в целом как бы это вот если рассмотреть какую-то простую операцию там типа выбираем юзеров и роли из двух массивов и делаем joint а вот если вы подумаете за базу данных как бы вы это делали да вот каждый человека до пишет запросам как бы просто думать базу данных ему как-то это сделать на самом деле начать думать то получается вот примерно вот такой алгоритм то есть выбирает сперва из первый этап из первого массива потом сопоставляем элементом 2 и фильтруем ну вот сложность для случая двух массивов я написал мне не работает эта штука а ну вот как оптимизировать выборку из двух табличек ну то есть мы можем попытаться предсказать в какой таблички у нас данных меньше чтобы меньше сопоставлять ну и соответственно какие-то вещи есть из индекса иногда можно взять быстрее чем логарифмическая зависимость на об этом сказал и и в общем то все и соответственно вопрос как оптимизировать вот этот результат а еще один есть путь из 1 нормализация когда мы строим индекс например сразу по двум табличка муки нормализоваться это сведение по сути дела все к одной таблички вот но если мы вот увеличим число join of в нашем примере то получим как бы вообще задачу которая по сложности предсказать очень сложно и вот соответственно тут такой вот риторический вопрос кто может ответить почему популярной базы новой стоит немного времени поэтому не буду долго спрошу ну вот есть такие версии да почему не работает здесь меня вот есть версия что базы новый сквозь более быстрые да ну соответственно если вы вчера ходили на доклад под грязовцем то они вам показали что под grease быстрее манга тебе в 10 раз есть еще какие-то версии есть еще версия что но и сколь базы позволяет хранить вот слабо структурирована данные там всякие xml джейсон и прочее но опять же если вы ходили на по сгрыз как бы или вот просто смотрели то шторой массивы и структуры появились подгрести много-много лет назад есть еще как бы разговора шарден где репликации ну или решение для паз гарриса тоже существуют и соответственно вот как бы если мы вот разговаривали о массивах то есть мнение что может быть новый skype лучше построить план вопроса но как правило в но вскоре вообще нет понятия join что еще кто-нибудь может предложить почему но вскоре популярна и вот моя версия ответа а ну если мы вернемся моя версия ответа она растет из вот собственно моего определения что такое база данных базы данных это массива записи плюс индекса да и соответственно моя версия ответа она она не работает появишься ответа вот такая то есть базы данных популярны но сколь потому что они не умеют же и соответственно это у нас заставляет программистом начинает помнить вообще о том что же такое база данных и что происходит в базе данных когда он делает запрос к ней и соответственно в будущем положительно влияет на архитектуру приложения а ну и соответственно wars как разработчик таранто должен на нем что-то в этом контексте сказать тарантул это не базу данных это не работает это апликэйшен сервер базы данных на борту то есть как бы база данных в моем восприятии в торонто ли это как одна из плюшек вот которую мы получаем использовать парадигму того программирования которым рассказал первой части доклада ну и в высоконагруженных проектах join не нужны немножко только здравствуйте спасибо за доклад вопрос по яндекс такси а почему вы допустим не взяли тот же рнк или гол а предпочли первым просто а разве потому что мы как бы д-р лонган нужно дорасти у вас есть масса опыт программирования на допустим pearly php питание и так далее то есть если взять и начать делать проект на эрланге вам нужно уволить своих программистов которые умеют вот это и нанять тех которые были ресурсы да конечно да ну то есть условно говоря и если бы я прожил жизнь по-другому я бы начал с другого языка до изучения а так вот так как получилось но реально получается что на традиционных языках программирования эту парадигму вполне можно использовать просто масштабируем и уже по изолированным процессом они и не получаем такого удобства как в ирландии лего когда все в одном процессе очень такой вопрос в догонку как бы не возникает соблазн а ну не то чтобы переписать но попробовать по крайней мере сделать тарантул на гол ну и то это будет уже другой проект а так конечно кто то рано или поздно напишет базу данных на гол мало того я насколько знаю разработчик этого memcache а занимается тем что он переписывает memcache на голову на каком языке все-таки начать писать проект новый но вот когда мы говорим если с точки зрения бизнеса то надо начинать проект на том языке на каток которого лучше всего знаете есть а если есть вы говорить с точки зрения идеального вообще как бы случая то конечно надо использовать и языки которые вот под вот эта задача более заточены то есть вот berlanti голову это стоит посмотреть и начать на них проект мы очень знаем хорошо 1 поэтому как бы все равно новые проекты начинаю на перле"
}