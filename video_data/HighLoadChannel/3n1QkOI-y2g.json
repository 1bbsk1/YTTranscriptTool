{
  "video_id": "3n1QkOI-y2g",
  "channel": "HighLoadChannel",
  "title": "Go Map Internals / Егор Гришечко (Uber)",
  "views": 6919,
  "duration": 2000,
  "published": "2023-01-19T05:55:16-08:00",
  "text": "всем привет меня зовут игорь я работаю в компании uber и сегодня я хочу вам рассказать про такую чудесную штуку как год и гомер и их unter null и и почему я хочу про них рассказать потому что в процессе подготовки к собес в большие корпорации у меня развился какой-то стокгольмский синдром я очень люблю как бы их изучать и странной любовью вообще люблю концерт структур данных и в какой-то момент я понял что материала набралось достаточно много и гаи теории из этого всего было неплохо собрать доклад соответственно я собрал доклад и здравствуйте приступим сразу хочу сказать что все сегодня сказанное является моим персональными мнением и никак не относится к моему текущему работодателю поэтому я сегодня выступает и частное лицо но вот штука в которой я штука которую я имею отношение в которой я участвую мне свой подкаст про музыку в котором я как бы соавтор мы рассуждаем про музыку если вам будет интересно приходить и подписывайтесь подписывайтесь комментарии вот это все приступим о чем очень и поговорим мы поговорим немножечко про теорию мы поговорим непосредственно врагов и мы поговорим про такую хари важную тему как sing me почему на холивар ну я в свое время писал очень много на к папочке и у нас столько копий было сломано об этот sing me по вы просто не представляете так вот сразу хочу сказать не будет плясок санса ремонт я не хардкорный программист я не очень хорошо считаю вот эти все смещения в уме и так далее мне конечно был never ский курс но вот вчера но мне приходится все это на бумажке считать и так далее и тому подобное поэтому если вам будет интересно посчитать смещение в коне все есть вы сами все посчитайте все поймете но цель доклада это грубо он такой он более обзорные потому что добрая половина его будет теоретическое чтобы собрать как бы общую картину у папы так вот приступим начнем с теории сегодняшний теория будет теория на пальцах потому что я решил не рассказывать всего сухими академическими терминами и решил все рассказать например из супермаркета а если точнее на примере списка цены представим что у нас есть какой-то список цен чтобы рока ли стоит столько-то картоха стоит столько-то арбуз стоит столько-то и соответственно когда нам что то нужно узнать какую-то цену мы просто ищем по этому листу как бы грубо говоря еще как по индексу этапом карту х 40 рублей мы знаем что картошка стоит 40 рублей важной частью этого прайс-листа является то что у нас не может быть дуплицировать их элементов то есть брокколи не может стоить 150 и 40 рублей ну невозможно такое они будут отличаться у них будут разные идеи по сути у них будут разные ключи так вот вот этот прайс-лист это и есть hash мапо или хэш таблица remap или в разных языках это называется по-разному но суть в том что эта структура данных которая хранит ключ значения и вот эти ключ на этим у нас уникального ключа хранится какое-то значение и при этом грубо говоря если ключ повторяется то у нас просто значение будет перезаписано так вот давайте представим что мы ищем арбуз в этом списке затронем такую важную тему как сложность я понимаю что сложно я понимаю что универ был давно но на самом деле не все так тяжело как кажется так вот сложность поиска в прайс-листе если мы идем от первого до последнего она от n или в нашем случае о трех почему потому что у нас три элемента да иногда если мы ищем допустим брокколи мы сразу вернем значение но сложность такая штука что она считается чаще всего по самому худшему случаю и лучшем случае у нас будет арбуз так вот сложность поиска от этого листа когда мы идем просто перебором она у нас от трех давайте перенесем этот лист вход мы же программисты и мы получим что-то вот такое страшное то есть у нас есть двойной массив слайс слайс of стрингов в котором мы храним брокколи и 150 рублей картоху и 40 рублей арбуз и 220 рублей а потом когда нам нужно найти арбуз мы просто идём по всем овощам ищем арбуз и печатаем цен не очень удобно сложностью aten как я уже сказал прошу случае арбуза вы понимаете мы пройдем по всем элементам но мы не верим в чудеса но у нас есть компьютеры вами что давайте помечтаем бы помощники который выполняет одну простую функцию когда мы ему говорим что арбуз сколько стоит арбуз он нам говорит цену и мы программисты давайте это более в проход превратим что грубо говоря мы ему даем арбуз а нам такие в ответ иди по индексу 20 и вообще просто вот на тебе арбуз и на выход 2 честно замечательно и вот представим что у нас есть какой-то такой помощник и давайте преобразуем вот этот наш страшный код на выходе что-то уже получится более приятно ему жизнь нам этот индекс известен а теперь подумаем а нужны ли нам ключи по сути если нам яндекс из нужен мы зачем нам двойной массив и вы будете правы мы в принципе если нам известен индекс мы можем хранить только значения так вот этот помощник существует этот помощник называется хэш-функции то есть грубо говоря вот эта штука которую мы даем на фото арбуз она выход получаем 2 это математически концепт он реализован в коде называется хэш-функции его значения его как бы цель преобразовывать какой то я до сих пор помню кусок определение там байтовые какой-то входной поток have buy the вы выходной поток фиксированные фиксированной длины и так далее на давайте просто какие-то входные значения преобразовывать в циферки при причем преображалась в цирк в циферки все время одинаково то есть как бы вы арбуз не передавали всегда будет два при одной хэш-функцию с разных функций могут возвращать разные цифры но если у нас одна хэш-функция она на один ключ всегда выдает одно и то же значение если кому-то не нравится моя аналогия вот пожалуйста картиночку которую я занял с википедии то есть у нас на вход именно фамилии мы прогоняем их через хэш-функцию получаем какие-то значения причем заметьте иногда люди могут давать нам дубликат сша и как это разрешается мы поговорим с вами немножко дальше почему это важно потому что до этого я обмолвился что в dictionary лишь table или в мире в этой нашей с и структуре данных может быть включен аппликатор так вот мы знаем что у нас есть такой чудесный помочь их как выглядел бы код в котором мы его за использовали а мы просто бы вызывали эту функцию передавали и новых на вход арбуз получали бы число и отображали а как бы мы ее реализовали ну вот вот вам моя не идеальная хэш-функция вы конечно можешь меня кинуть камнем сказать что она крючок не реализовывает но в моем таком весьма простом представлении это очень простая но хэш-функция потому что у нас есть какие-то элементы на вход у нас возвращается какие-то индексы народ более-менее для нашего частного случая будет работать да конечно если у вас там будут другие значения она сломается но это отдельная история так вот мы вот этот код написали им полюбовались и вот для примера перед тем как прийти более приятным вещам я вспомнил что хотел вам показать кусок из какой-то учебника прочитанного мной еще в универе этом раз криптографией помою разбирался ищущим а я вот нашел вот этот с очей ван функцию там был гигантское к это математическое обоснование я до сих пор не знаете она значит я знаю что вот эту функцию бы что-то на вход передаем она выход получаем ты который примерно в то время на выход они все все время будут одинаковые для одного и того же ключе так вот опять смотрим на наш приезд и код и преобразуем его в стандартном лигу все вот мы шли очень очень и очень и очень и очень и очень долгим путем по сути реализовали вот эту нашу хэш могу об этом все взяли и переписали на стандартный мир и мне кажется самое время подумать а из чего она на самом деле состоит и вот насколько она похожа на то что вы нарисовали в первой части доклада давайте приступим к объяснению на пальцах мэп состоят из трех частей нестандартным гост мэк и вообще структура данных других языках все то же самое она состоит структура данных состоит из хэш-функции мы с вами уже поговорили что это и массива массив это групп это просто реальный массив или слайд в go в котором хранятся значение то есть давайте представим что мы хотим положить арбузик мы берем вот этот хэш от арбуза и просто кладем в этот массив значений то есть там у нас будет допустим массив стрингов или массив фунтов или массив чего угодно но кроме массива есть очень важная третьей части это третья часть называется адресация почему это важно потому что как я уже сказал иногда могут возникать коллизии иногда на вход два разных ключа могут давать одно значение то есть допустим арбуз и это полон дыня или по моего какой-то фрукт дает нам на выход один и тот же индекс да и вообще у нас харьков хэш-функция плохая она дает как бы очень два ключа допустимо на 1 и 2 или на любое значение всегда 2 возвращает то есть у нас могут возникать коллизии и это нам как-то надо решать существует два популярных способа разрешения коллизий первый из них называется открытой адресации то есть когда мы видим что коллизия возникла мы просто делаем + 1 + 1 + 1 + n + 1 до 1 свободной ячейки маленький штрих к этой адресации что в этом случае мы еще начинаем хранить ключ потому что ну сами представьте потом мы придем за по майло мы начнём проверять мы увидим что мы лежит лежит арбуз нам нужно будет искать то есть чем суть открытой адресации если ячейка занята мы просто ищем другую первую свободную тут на самом деле я насколько понимаю самую главная проблема в том что это все потом как-то надо фрагментировать и чисто в теории но представьте у нас может сложность какая-то очень плохая опять получится потому что ну опять ключ будет один выпадать мы просто элемент за элементом за элементом за элементом будем класть и все будет ужасно кому не нравится мое объяснение пожалуйста я опять занял картиночку сути pedi то есть как я уже сказал если у нас включится поддаются случается коллизия приоткрытой адресацию мы просто начинаем элементы вкладывать дальше то есть вот в данном примере у нас в джона и у сандры совпали значения и они просто вели глистов друг за другом при этом заметьте что тед должен был лечь ячейку 153 но он лег 154 потому что там легла sandra то есть на самом деле это вот главная проблема открытая адресации штамм начинаются пляски с бубном вокруг этих значений потому что ну как бы мы их просто укладываем и там иногда может все достаточно весело перемешиваться по крайней мере из популярных языков которые я смотрел я открыт и адресацию не увидел ну я насколько знаю если вы знаете какой-то такой промышленный язык в котором хэш-таблицы сделано через открытую адресацию ну скажите мне пожалуйста мне будет очень интересно вот вторая более давайте скажем попсовая реализация называется ци почечная в чем я суть в том что у нас в этом мостили по сути хранятся как головы и на связанные списки крюк ключей значение то есть вот нашем примере с арбузом и памела или ты не у нас ячейка 2 будет хранить связанный список исключать значение и то есть и когда мы будем искать допустим для дыни мы посчитаем ее индексы просто дальше пойдем по листу пища этот ключ я допустим знаю что jagwire какой-то версии они даже там не ринггит лист клали а после определенного размера она все превращалось в дерево чтобы было искать удобно и так далее и тому подобное но тут уже оптимизацию это дело история но и почечная адресация это когда мы в массиве храним голову списка и просто ищем по этому списку опять же занятая картиночка с википедии там ссылочки внутри очень советуют мощную википедию там вот тоже очень хороших примеры на бинарную структуру данных и обычно википедию то есть тот же самый пример у нас совпадают джон и сандра у нас как вы видите выстраивается связанный список и у нас стоит лежит ted лежит в своем все же собственно связанном списке соответственно хэш таблица состоит из каш функции массива адресации и я немножко слукавил на самом деле есть еще подпункт 3 1 который называется перестройка массива каждое хэш-таблицы есть такая штука которая называется лот фактор это достаточно просто вот у нас есть количество элементов допустим я не знаю 10 и есть количество ячеек в массиве допустим 4 то есть у нас 4 linked листа с указателем массив на четыре элемента в каждой ячейке лежит голова linked листа в которой хранится какое-то количество значений лот фактор это по сути количество элементов поделить на количество ячеек и в определённый момент когда у нас лот фактор достигает какой-то границы у нас начинается перестройка этого массива то есть мы его расширяем и зачем это все делать для того что будто пытаемся достигнуть оптимальности то есть если мы запрашиваем ключ мы не хотим еще полчаса искать потом по связанному списку мы хотим просто прийти как можно быстрее найти и отдать потому что map это же быстро вот и чисто теоретически сложность поиска по мапе это от единицы то есть мы предполагаем что это вот прям константной а величина то есть мы не бегаем по списку то есть это очень очень быстро на самом деле не все так просто как я уже много раз вам показывал в худшем случае мы все еще можем пробежать по всему массиву по всем значениям но существует такое понятие как амортизированная сложность и поэтому считается что вот это по сути амортизированная сложность переводится как переводится как иногда худшем случае это будет о от n но все закрывают глаза поэтому это будет от единицы так вот давайте теперь посмотрим на год до версии 118 почему до версии 118 м что этот доклад я делал феврале 2022 года так вот но я все ещё допускаю что не все сразу бегом перед перескочили на generique так вот давайте посмотрим что мама стандартная гош на это по сути 1 generic потому что она может стринги она может в энгри она может что угодно давайте немножечко за копаемся внутрь пасхою посмотрим на исходный код который лежит у нас в гору с rsi runtime и он все время там лежит рядах понимаю будет лежать да и скончания века и что есть мапо мапо и то есть структура которая называется hb но не header мэр которая в себе содержит достаточно большое количество полей из которых нас интересует по сути 3-х шноль это штука которая отвечает за солирование a shame api то есть каждый раз когда вы создаете могу и что-то делаете каждый рама по внутри себя содержит уникальный х ну и не уникальную соль поэтому не таким образом достигает большего распределения ключей и лишь грубо говоря когда вы два значения хранить одинаковых значений храните в разных мафах хэш у них в итоге получится разный потому что там внутри грубо говоря происходит сортирования входе сейчас покажу и два массива почитав как я уже сказала горной map и сделанные через и почечную адресацию есть новые bucket и есть старые bucket и все хорошо откуда же берутся гиппо возникает следующий вопрос из там нет никакой магии есть какие-то баки ты они инсеев все дела но мы же как-то можем хранить там string in и nsstring а типа берутся на самом деле из 2 штуки которая называется n-type структура типа i'm toy то есть когда вы на самом деле вызываете namapi поиск но чтение из нее вы вызываете функцию который вы передаете три аргумента м type то есть тип map и саму маму указательного могу и ваш ключ при этом когда вы хотите два элемента вы просто вызывает другую функцию влюблюсь вы знаете мапо можно запросить что до стране какой-то ключи верни если ты ключ найден поверни ок если не на один вернее там бог будет falls это просто другая функция которая названа 2 если вы пишете вы вызываете мы по саян причем обратите вы в нее не передаете в белье почему мне не передаете в илью я чуть попозже покажу и когда вызывает гибель это соответственно давайте матерей соответственно prime это еще одна структура в которой описывается куча всяких служебных элементов но больше всех нас волнуют 3 это хочу как я уже сказал наша вот эта волшебная хэш-функция это ключ у которого есть какой-то тип элементу которого есть тип что такой тип это мета-тег для компилятора в котором много всего происходит но суть в том что когда вы определяете могу допустим типа string and вы определяете ich mir у которой есть type который содержит внутри ключ который указывает на тип string элемент указывают на тип int там какой-то шар и из-под type это me to keep компилятора причем забавная штука что у этой у той поесть эквол который позволяет нам сами значения как бы когда пришел в гараже такой уникальный уникальный у нас нету базовых типов у нас нет базового обжиг как джори так далее ну вот у нас есть тайна на котором определенный кол джарвис тоже там иголку всего и в dota и то есть и получила я как бы ничего не говорю но все языки в каких-то общих местах они перекликаются потому что но оставим это за скобками так вот давайте перейдем к домам чего мы начнем а начнём мы с очень простого начнём мы с того что вам покажу что все действительно лежит в также runtime давайте посмотрим на структуру и cmos как я уже сказал у нас есть каунт который хранит количество элементов у нас вот есть вот эти баки ты нас там есть куча дополнительных льдов про который можно отдельно разговаривать это там мама вообще очень большое существо и про него можно очень долго разговаривать поэтому сейчас мы будем в общих чертах как я уже сказал есть hash и есть bucket и причем bucket и и танца их pointer который в свою очередь ссылается на структуру которая является лидером для батя то есть какое-то прямое описание прямому описание bucket of ходе вы не найдете сейчас вы поймете почему буквально через пару минут то есть вот у нас этим м стандартный вот у нас есть вот в чем стандартный вот у нас описан какой-то хэдер баки то давайте посмотрим теперь на more my time как я уже сказал вот он написан у него есть ключ у него есть элемент у него описан фишер буквально секунду при этом нас еще бывают такие очень интересные сатой поют которые я до конца не используются в других структурах поэтому вы если там посмотрим еще на что то оно может быть очень похоже вот хэш-функция где у нас хранится хэш-функция хэш-функция у нас которая то есть у нас есть и тьма и если вы обратите внимание на воде у нас не грех и шла не хранится почему она не хранится потому что он лежит в map т.п. мама тайпе вот эта функция h шар где она у нас присваивается она у нас присваивается в отдельном вообще файле котором на вход у нас приходит тип и для типа у нас клуб опять switch гигантский происходит много всяких интересных там преобразований допустим для структуры там очень интересная штука происходит потому что для структуры рекурсивно идется по фил дам от них там считается хэш и так далее и тому подобное вот и когда у нас компьютер создает map и он непосредственно создает у нас просто фишер этот хэш их потом там этой мафия 3 слова этот хэш а потом мать и присваивается так вот это в общих чертах давайте теперь посмотрим на сайт и на pride сразу скажу что я показываю оптимизированную версию то есть угла есть много много много много много много много много всяких файликов вот допустим мэр fest все ряду в нем хранятся штуки для винта 32 для int32 и так далее я же хочу вам показать есть как это джина я рик версия я же хочу показать очень быструю версию для стринги так вот представим что у нас есть какая-то мапо допустим вот такая а и мы в этом апу допустим делаем что-то вот так и в этот момент у нас произойдет 1 вызовется вот этот метод то есть у нас там есть отдельный метод int который я непосредственно инициализирует maple у нас вызовется этот метод ему на вход передается маз мамонт в котором есть string и перри передастся непосредственных фейдеры передастся ключ дальше у нас провериться что map и не пустая если у нас есть рейсер у нас включится проверка рейсер а а дальше моя на самом деле любимая такая штука это такое знаете проверка на то что у нас skunk anansie соблюден без блоков то есть когда мы пишем в mcu мы меняем флаги через axor и когда новые чтение приходит мы ожидаем что как бы флаги не изменены если влаги изменены мы бросаем ошибку что concorde move move right то есть это такой очень примитивный механизм без луков как защититься от к конкурент записи при этом упасть всем показать и так далее так вот вот у нас есть вот этот наш ключ мы от него взяли хэш установили флаги если у нас баки баки той пустые создали новые bucket и а дальше происходит все очень интересно потому что если у нас мама должна вырасти мы начинаем ее выращивать еду и грубо говоря потом возвращаемся на эту метку которую мы там много всего дела то есть если у нас мама должна вырасти на зависть и она начнет расти далее у нас просто там чудесный и пересчет смещения про то куда положить элемент что с ним делать и так далее суть в том что в конце у нас возвращается просто адрес то есть я не зря сказал что я не буду сейчас объяснять все смещения потому что у как вы видите и заметьте bucket и это сугубо ansa их механизм о лежит в памяти он посчитано в сетах и не трогай до структур которая определяет то есть все лежит в памяти все лежит на в сетах и просто как бы внутри map и считается смещение в памяти что же происходит когда мы пишем а у нас просто считается длиннющие адрес памяти и возвращается как я уже сказал у нас убираются локи то есть по сути когда мы вызываем эту функцию у нас получается что-то вот такое какой-то адрес памяти равно 2 по сути вот ответственно это ответ на про почему вас они у нас в с ign у нас нету ни какой то белье теперь давайте посмотрим на рид то же самое рейс то же самое проверка на нем проверка на чтение очень много оптимизации на то что bucket у нас сейчас сейчас на то что у нас bucket один поиск по мба китам пересчет значений допустим если у нас не нашлось значений у нас возвращается специальная константа который называется зира вылью тоже очень интересно и в конце у нас опять же возвращается просто элемент то есть по сути в тот момент когда мы возвращаем какое-то значение из map и то есть допустим мы хотим там что-то выбрать вот такое у нас получится что-то образца вот такого то есть мы напрямую читаем из памяти мы напрямую пишем в память только вот это наша мапо это такой узнайте чудес интересный чудесный чудесный синтаксический сахар сверху который от нас все прячет и мы считаем что мы пользуемся таким классным она все классно и но она все нации во все на смещение и вот будьте осторожны с этим пару слов от google в 118 я доклад это делал 2000 выбранных февраля 2022 года в 118 вообще никак не отличается от того что был 1 118 видимо они считают что все хорошо и ничего менять надо немного которые другие языки других языках все то же самое то есть в код ли не у нас есть какой-то array у нас считаются индексы у нас смещается как бы значение помещается данной аварий тоже самое в гору вовсе шар peppers у нас прям есть n 3 там единственно более такой более сишарп код считаются индексы присваивается значение удаляется значение но смысл есть тот же самое что у нас есть какой-то underline массив мы в него вкладываем и все так получается когда я смотрел на питон я обратил внимание что ну питона гош тут явно имеют общего потому что я насколько понимаю стандартная библиотека насколько я видел питон напишу написано no se и там вот местами все очень похожи те же самые структуры вызовы там куча и указателей и так далее про язык который не надо говорить с крабиком я не буду говорить но там файл мапри на 6000 срок он будет интересно посмотрите буквально две минуты про sing me по когда я работал представим что вам нужно сделать свет sitemap что два пути 1 выпишите в обертку над папой в которой вставляете лог начинаете локон лак лак unlock локон лак лак unlock обязательно где-то что-то теряете вот у меня в практике была ситуация когда товара вызвал лог а потом еще раз вызывал долг и вызвал белок в проекте то есть это первый подход который более наглядный которая хорошо работает а есть второй подход который называется sing me так вот всегда был холивара потому что мы его когда я писал вообще мы поставим писали эти матки а потом кто-то сказал давайте может sind mit на чем использовать мы очень долго хлева реле я вот с тех пор помню что когда нужно использовать sing-sing мэтт надо использовать прямо написано вас когда вас много гуру кен читает или пишет и какие-то сайты ключей а если грубо говоря можно свести когда нужно использовать синклит можно свести к двум понятиям первое бисмарк эти если вы упираете стандартной могу побить маркетинг мая посмотрите на это а второе когда вам нужен кошек и то есть вам нужно положить ключики постоянных читателей с разных гору then do sing me будет быстрее почему он будет но в случае кошек а почему он будет быстрее а потому что там две части первая из них ему табель на автора из них мутабельные то есть когда вы че то и механизм достаточно интересной то есть сначала значение у на складе складываются в мут обильную часть то есть они складываются с луком складываются складываются складываются и каждый раз когда мы читаем из map и у нас вот это вот обильная часть мы смотрим сколько раз мне не исходили и в тот момент когда у нас какой-то год мы порог превышаем когда у нас число вот этих походов в грязную часть превышает длину грязно части мы грязную часть просто переписываем в чистую и затираем грязную часть и предполагаем что все следующие походы должны приходить чистую часть которая ему табельное без луков и которые прекрасно работает так вот почему все говорят что она хорошо работает для кэша но представьте потом 5 значений сложили а потом начинаете ходить в определенный момент у нас гора грязной а часть положится в чистую и у нас он плакал и структура по сути из нее будет считаться будет все хорошо но если вы потом начнете опять писать грязную часть что произойдет мы возьмем чистую переложим грязную опять ногой бьем гряда мы переложим в чистую то есть по коду вы можете обратить внимание что sin cmos очень хорошо работает если вас там ключи непересекающиеся или допустим вы записали много много много читаете так далее или допустим записали одну часть ключей читаете только из нее опишите только другую и если же вы и пишите и читаете у вас постоянно вот это грязный выйдет в чистую перекладываться и это не очень хорошо будет по производительности и последний на такой интересный момент что когда мы удаляем и если значение лежат чистой части там просто есть такой специальный сам стоун могильный камень который просто ставится говорить тут нет значений несмотря на то что мы как бы и сами you the ball структур не можем удалять мы там чуть-чуть можем модифицировать ставим сам стоны и говорим что мы как бы удалили но мы не удалим вот это просто интересный факт на этом все большое спасибо за внимание"
}