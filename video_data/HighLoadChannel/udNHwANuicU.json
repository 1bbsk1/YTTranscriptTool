{
  "video_id": "udNHwANuicU",
  "channel": "HighLoadChannel",
  "title": "Состояние Состояния / Алексей Охрименко (IPONWEB)",
  "views": 1047,
  "duration": 3403,
  "published": "2018-08-16T04:33:06-07:00",
  "text": "и для начала давайте сделаем такую небольшую викторину обычно докладчик сам представляется а мне лень на самом деле ну пусть это слайд писать текст давайте сделаем по-другому давайте вы мне расскажите кто я давайте сделаем такой небольшой ход конем давайте просто громко выкрикиваете не бойтесь давайте ассоциации человек какие хорошо перфомансы на каждом докладе так замечательно еще ассоциации как 5 минут кангу лиара давиду подкаст супер еще какие ассоциации все блин как-то какой-то front in der ну ладно спасибо окей хорошо так ладно давайте на самом деле свободная цена время еще также дополнительно делаю ну помимо пятиминутки angular оппонента что front in der и выступает часто с докладами еще у меня есть некоторые подкасты и организуем angular митапа в москве поэтому обязательно приходите скоро тоже очень будет новый в конце и там будет ссылка на это все поэтому не стесняйтесь добавляйтесь и приходите сам я работаю в компании по web кто вообще понимает так давайте прежде чем я буду просить вас поднимать руки давайте поднимите руки те кто руки поднимать не будет по каким-либо причинам я вас обманул все равно подняли так что все у вас вы не сможете их не поднимать окей ты рассмотрите давайте так кто пропал мет знает вообще какие ребята так а кто был ну вот в нашей собственно говоря будки ну скажем так на стенде да вон были пару людей остальные я это сейчас почти я вам рассказываю но и обязуетесь просто сходить потом дайте банально так все все согласие обязуются поднимите руку если обещаете дайте сучки я пока все руки не увижу в зале я как бы могу и не продолжать доклад поэтому я вас шантажируешь как бы у меня тут все карты в рукавах ну ладно окей хорошо никто не сколько людей пообещали пойти смотрите очень вкратце alpine white компания которая занимается на рынке рекламы rtb и занимается скажем так вот основными технологическими стеками и там мы работаем там я работаю frontend программистом и компания довольно успешно в этом рынке рекламы и r тебе маленький спойлер в конце будет ссылка на все ссылки поэтому если что-то интересно увидеть и можете не доставать телефон также примеры кода они будут доступны в конце поэтому если сейчас вдруг что-то там не разберете вас будет возможность просто скачать исходники и непосредственно с ними познакомиться так смотрите и для начала у меня для вас объявления очень классная буквально вчера прочитал вот буквально вчера в газете написали смотрите британские ученые доказали что девяносто девять и девять процент frontend программистов симулирует архитектуру фронтэнда то есть в этом зале есть 2-3 человека кто не симулирует архитектуру кто действительно и занимается остальным к сожалению приходится тяжело смотрите все на самом деле очень серьезно понимаете то есть тема для меня лично очень больная потому что архитектура во front-end такой вопрос а ты как бы frontend а я еще архитектура вы с ума сошли еще архитектора скажите нужного фронтэнда какие смотрите а проблема вот лично в том то что когда начинаешь с кем-то общаться технология б лучше всех окей а сколько технологии ты знаешь и человек такой я знаю только технологию бы и все и очень грустный у него печаль депрессия на самом деле поймите что нельзя сделать выбор из одного варианта но это не выбор фактически понимаете когда у вас есть ровно один вариант и говорят выбирая понимаете ну не работает так выбор именно и архитектура за для меня лично я архитектура главная и основная камень преткновения главный плюс это выбор я на самом деле понимаю почему это происходит во front-end и про чтобы фронтэнда не все так тривиально да смотрите то есть у нас есть очень множество разных факторов я не буду сейчас всех подробно перечислять да я просто вкратце перечислить трупы нескольких нас есть проблемы с рейтингом у нас есть проблемы с тем как работать с данными источник разными источниками данными как их абстрагировать как с ними работать у нас есть разнообразные memory & performance еще у нас их намного больше чем в других любых средах абсолютно на есть один архитектурный фактор а потом я особо хочу поговорить и это состояние то есть состояние архи нашего приложения очень важно и вот сейчас у вас может возникнуть вопрос а что вот это вот состояние блин в докладе два раза состоянии состояния может все оптимизация какая-то компания вышла состояние называется нет состоянии это очень важная архитектурная деталь смотрите сейчас чтобы продемонстрировать что такое состояние а я вам визуально покажу что это я покажу небольшой ролик смотрите я не смог найти русскую озвучку поэтому в качестве озвучки буду я то здесь учитель которая нужна то после работы очень устала и вот она пришла домой и начинаем у как я давно не писала свои вещички ой столько всего написала опубликовать а нет зовут ну вот смотрите вот то что вот то что сейчас была потеряна и то есть состояние вот кто с этим же сталкивался кто ребята терял данные так вы понимаете да ну вот кто-то уже даже знает и так что надо скопировать прежде чем отправлять понимаете и вот то что было потеряно и то есть состояние состояние при в приложении фран тренерского это именно та та работа которую вы проделали вы или допустим какие-то другие пользователи и вы получили ту же эту работу но это именно есть работа именно то что вы делаете поэтому состоянии безумно важно смотрите в этом отличие бэг-энда и фронтэнда вот есть за либо kinder а вот как вот мы долго вы что здесь забыли вообще я напоминаю это frontend доклад на всякий случай просто вы мало ли может ожидать этот баг не смотрите в этом и отличие главное бэг-энда от фронтона пошли на бренде состоянии это очень плохо почти нити потерн то есть чем больше у вас состояния вашим бэкон ходе тем хуже понимаете в идеале бэкон должен быть стать вас максимально то есть чем меньше состоянии тем меньше вы храните тем лучше ваш код тем лучше ваше приложения во front-end и наоборот в идеале состояние должно храниться бесконечно то есть в идеале ваше приложение вы должны его запустить и оно должно работать ну вот пока не закроют поэтому стоит менеджеры то есть менеджер по управлению состоянием это целая отдельная тема во front-end и работают они с помощью разных архитектурных паттернов некоторые из них пришли из бэг-энда некоторые из фронтэнда и я вам собственно говоря них расскажу но в начале есть такой вопрос а почему не хранить состояние внутри компонентов а вот есть компания ребята вот кто хранит состояние внутри компонентов там есть люди просто ну как бы банально прям в компоненте состоянии да вот есть честные люди молодцы что руки подняли сейчас я объясню почему вы неправы и зря руки подняли смотрите нет идея в чем почему не хранить в состоянии в компонентах во первых у нас есть такая вещь как роутер кто во front-end не использует роутер есть такие люди у кого приложения без роутера какие ладно давайте так у кого было хоть раз в жизни что он писал frontend приложения без роутера да вот так честнее молодцы замечательно зря потому что смотрите в чем проблема проблема очень простая мы приходим к номеру на какую-то страницу в роутере у нас есть там компонент у него есть состояние мы проделали какую-то работу мы уходим на другой road этот компонент удаляется по что все роутеры по-хорошему должны удалять компоненты просто из соображений оптимизации памяти производительности на франкен зенит безграничной памяти и когда мы возвращаемся мы теряем это состояние поэтому в самом компоненте хранить состоянии не очень хорошая идея вы завязаны на этот компонент вам придется где-то компонент хранить в памяти чтобы не дай бог не потерять эти данные поэтому без роутера ни в коем случае не нельзя жить а вторая проблема когда мы просто в компонентах это прогресс его не пробраться не props of да понимаете знакомые я думаю react программистом до термин да и вот есть пару как программиста кто понимает смотрите в чем проблема у нас юань это иерархическая структура дерева обыкновенная и смотрите и вот у нас есть главный рутовый элемент и нам надо в таргет элемент пробросить необходимые какие-то данные вот мы пропитываем прокидываем то есть мы покинули по иерархии необходимые нам данные все вроде бы хорошо проблема в том что вот этот компонент посередине он начинает знать о тех данных которые ему вообще не нужны но не нужны этому компоненту эти данные понимаете поэтому просто обойтись иерархической структурой компонентов и просто пробрасывать данные туда-сюда мы к сожалению не можем поэтому этот вариант не подходит теперь давайте рассмотрим пример сначала простого приложения на одном из подходов подход скажем так ну вот очень простое приложение как видите я был классным дизайнерам как говорится навыки у меня на лицо смотрите у нас есть очень классное очень сложно и приложение состоятельного из списка и другого списка и вот мы из одного списка в другой список перед перекладываем элементы то есть из списка я могу нажать кнопку это элемент перейдет в другой список то есть ну такое довольно сложное приложение давайте посмотрим как его сделать смотрите пример у меня будут на angular но если кому-то не посчастливилось работать на чем-то другом не стесняйтесь подходить и я либо вам расскажу как это применить к примеру в реакции ли вы или могу отдельно вам просто сделать кодовые дымке если много людей допустим захотят то что все эти подходы которые подхожу они абсолютно универсальный они подходят как для angular а как для react а как для вы они подходят для всех фреймворков просто они по-разному могут применяться допустим скажем так в том или ином фромборке и тип первый подход это подход со сервисами подход сервисами 1 этот подход придумал мешках every это так папа angular а отец его кто непосредственно создал сам angular то есть он автор его непосредственно и сейчас он главный архитектор angular и какой-то хорошей позиции занимает в куклу он придумал такую концепцию сервисов что это подразумевает вот у нас есть эротическое дерева и мы хотим избавиться что вот этот средний компонент мы не знала на этих данных которые мы не нужны им что они придумали давайте создадим параллельную структуру которая будет доступна везде то есть любому элементу в дереве да то есть любой компонент внутри дерева может получить доступ к этому объекту объектом называем сервис ok и этот сервис мы будем туда ложить все данные и оттуда забирать все данные которые нам необходимы то есть фактически мы создали какой то объект и туда перенесли коммуникацию именно взаимодействие какое-то да с нашим компоненты благодаря чему этот компонент посередине наконец-то стал свободен свободен наконец-то от этой каторги и хранения и передачи данных теперь это все на сервисе и теперь давайте посмотрим на непосредственно код нашего приложения смотрите у нас код приложения вот такой вот он довольно простой то есть у нас есть два списка список и другой список здесь ничего такого нет смотрите сам список у нас компонент непосредственно это умный компонент напоминаю у него есть доступ к сервисам какой-то части бизнес-логики то есть он знает о бизнес-логики что мы добавляем и удаляем что-то из списков все данные мы храним в двух сервисах я сейчас о них подробнее расскажу и компонент наш взаимодействует с этим сервисом очень просто он берет из одного сервиса удаляет элемент когда мы нажали кнопку add и хотим с одного списка перенести в другой он удаляет не из компонентов или еще откуда то он удаляет из сервиса этот элемент и потом добавляет и тот же элемент в другой сервис то есть здесь я думаю архитектурно все просто теперь давайте посмотрим на сам сервис сейчас конструктор я пока спрячу я чуть подробнее про него расскажу смотрите то есть у нас вот есть наш список мы можем удалять элемент добавлять элемент и соответственно как только мы добавляем и удаляем или удаляем из массива обыкновенного ну то есть здесь никакого руки cnc другой сервис работает абсолютно также то есть у него есть a dream of то есть здесь ничего такого нет но как только мы это запустим сейчас поверьте на слово я к сожалению не смогу запустить давайте верну вот эту картинку одну секунду я просто чтобы продемонстрировать что вы понимали в чем проблема теперь смотрите вот мы сделали приложение она работает мы нажали на кнопку у нас перенеслось все замечательно но потом приходит бизнес да есть другое слово для этого карьеру приходит бизнес и горит слушайте так давайте улучшим наше приложение давайте данные брать сервера до них арт котики это в нашем приложении делать запрос на ищите типе а сохранять примеру запоминать список друзей которых мы добавили во второй список запоминайте где-то в local storage где-то локально да то есть мы берем вот этот адрес сохраняем в local store g а лист сам запрашиваем сервером так вот как только мы это сделаем у нас произойдет страшная вещь из за того что у нас появилось два источника данных и за то что мы не добавили после у нас появится такая вещь что после того как мы сделаем очистить и запрос элемент 1 про дублируется верхнем списке сейчас давайте продемонстрируем почему это произойдет то есть у нас есть мы загружаем в одном сервисе мы загружаем элементы сокол сторож это произойдет моментально он доступен сразу и знать изначально вот список который у нас есть у нас есть конструктор он симулирует как бы некий запрос на чипе не обращайте внимание это просто как стыдно и дальше через задержку там какую-то 2 секунды к примеру да у нас сервера отвечал у нас подгрузится этот список у нас получается что у нас рассинхронизация произошла понимаете мы делали вроде бы понимаете и вот я в первый раз когда столкнулся с этой проблемой я кое-что для себя осознал я каждый раз делал какие-то логичные решения то есть у меня есть два списка я для каждого вынес данные из компонентов в сервис я делал как как мне казалось какие-то разумные вещи да понимаете но место вот этого вместо стены до которую я ожидал я выкладывал кирпичики кирпичик за кирпичиком я делал вроде бы разумные вещи я получил вот это ну то есть что то такое ну красивая конечно но неожиданно и понимаете это не было запланированно мной а это проблема в том то что нельзя делать просто обычные решение логичные все получит смотрите вот есть небольшая секунд диаграмма на ней просто визуально видно почему это происходит сначала user делает некий некое действие он открывает наше приложение потом наши applications она получает это сообщение она начинает открываться и она обращается к двум источником данным сервиса который делает запрос на и т.п. и сервис ухлопал сторож и впоследствии они синхронно приходят и они записывают данные скажем так в одно и то же состояние то есть несмотря на то что я разнес это состояние в 2 разных места с точки зрения нашего приложения это одно и то же состояние то есть это просто список каких-то элементов он просто разбросан по двум участкам кода понимаете и с такими проблемами вы будете сталкиваться постоянно абсолютно то есть это пример он очень гипертрофированный он очень простой с этой проблемой вы будете сталкиваться всегда смотрите давайте попробуем посмотреть что можно для этого сделать вот что можно сделать чтоб как-то это упростить первый подход сиквест secures то есть x стенд ну как аббревиатура которая переводится как команд вере separation то есть разделение на команды и запроса оси qrs команд в ресивер gi и шин ресурсы гришин это непосредственно имплементация то есть 1 аббревиатура подход 2 это непосредственное и имплементация вектором майора это человек который впервые применил данный подход и в дальнейшем он распался причем на самом деле в бэг-энде это чаще всего встречается кто слышал про events are sing вот соответственно sick sick вес теперь с чаще всего применяется именно с этим подходом то есть когда мы делаем обзор sing но очень часто это применяем и этот подход мы можем применить его фронтэнда давайте посмотрим смотрите сама концепция безумно простая наш код мы должны делить на 2 на 2 типа скажем так код который делает к вере запросы команды и точнее запук вере и запросы и код который делает команды то есть мы просто разделяем наш код мы не пишем просто 11 класс мы его делим и давайте теперь посмотрим как мы можем подойти к этой дымки и решить нашу проблему сейчас секундочку откроем у нас есть пример непосредственно кодом на котором мы это и увидим так вот у нас есть наше приложение но у нас теперь появились сервисы отдельные то есть пример у нас появился сервис для чтения то есть это сервис который делает клэри к примеру он делает к вере для одного списка и делает клэри для другого списка и он учитывает эту проблему публикации состояния то есть он проверяет что когда мы делаем запрос в для нашего списка 1 он его элементы зависят от элементов второго списка то есть мы не можем в первом списке показать элементы которые мы перенесли во второй то есть мы должны отфильтровать их и опять же мы это все делаем в каире клэри обращаются к так называемую сторону сервису то есть какому-то сервису который занимается непосредственной работой с каким-то хранилищем данных не важно что это http local storage то есть какие-то любая хранилище данных у нас здесь то есть если посмотреть вот это хранилище данных у нас хранить наши данные непосредственно и непосредственно загружается данные именно в сторону а если мы хотим сделать какую-то запись у нас есть отдельный сервис для записи то есть мы у нас есть определенные команды которые мы вызываем и эти команды добавляют и удаляют элементы но доступ это сервис для записи опять же имеет только 100 роджер то есть он может записать сохранить что-то в сторож непосредственно да то есть он может непосредственно только записывать то есть мы разделяем явно чтение и запись мы это можем делать в рамках одного файла можем разделять это на файлом то здесь несколько подходов как мы можем это делать и последствия покажу еще один пример команд мере separation но сейчас если посмотреть на этот пример то у нас все отработает сейчас если мы посмотрим на листы ада лист то мы увидим что у нас есть наш запись и чтение и то есть когда мы добавляем мы обращаемся к сервису для записи и записываем что-то вот я не буду сейчас запускать код пример кода но поверьте на слово что все будет работать как только мы это сделаем все начнет работать одна из причин почему это происходит когда мы просто разделяем на к вере до команды на чтение и на запись то мы получаем некую такую структуру то есть у нас наше приложение к примеру открывается и теперь у нас появляется две команды после запуска одна команда на загрузку данных сервера другая из local сторожа и все это уходит в запись то есть мы записываем после того как мы сделали эти запросы мы записываем эти данные в сторож ок вырежи делаются запросы из 100 раджа то есть каждый раз когда сторож меняется у нас наши к вере по-разному отвечают то есть мы благодаря этому обновляем данные но при этом кавере всегда берут источник данных из одного нужного места у нас нет публикации вот этого состояния мы благодаря тому что разделили чтение и запись мы структурировали наш код благодаря этому кот стал читабельны проще и на самом деле если вы работаете с обсирал паттерном вот этот подход он очень интересен обязательно с ним познакомьтесь теперь смотрите следующий ридак кто воодушевлен ридак сам да есть люди у как воодушевленных до совсем не по душе блины еще раз как вы души в мире дак сам ну как то так вот ну ладно окей деда ридак здесь средах давайте ну ладно окей хорошо значит тогда мы будем подробнее рассказывать смотрите ридак один абрамов соответственно сразу предупреждаю что если выбрали ридак то обязан вы обязаны слушаться дама бубен абрама то есть ни в коем случае нельзя его сушиться просто подход очень простой смотрите вот кто незнаком я хочу вас немножко с ним познакомить ядро всего редакция это какие-то действия экшены они генерируются разными ситуациями по разным причинам камеру я ну самое просто и понятно это user действие user нажал на кнопку тизер что-то сделал и вот у нас появилась действия дальше это действие попадает в створ то есть есть некие единых единое хранилище данных по умолчанию 100 всего один на все приложения то есть вот здесь уже есть подсказка как редакции к примеру решают проблемы с дублированием состояния соответственно здесь у нас есть 1 star дальше этот стороны ничего не делать церкви нам с экшеном делаю три юзера то есть есть один режиссер на все ридак с приложение еще объясню смотрите у нас есть ровно одна функция которая проверяет что если actions of pale когда если это тот же этот экшен который мы ожидаем то на это действие по под под гнетом этого действия начинают создавать новое состояние то есть у вашего приложения было состояние а оно пришло перешло в состояние б вы можете спросить у режиссеров же много на самом деле все те режиссеры которые мы делаем они просто ну и есть композиция просто композиция функций то есть на самом деле режиссер всего один вопрос превращаете его в одну функцию смотрите дальше как только у нас поменялось состояние нашего приложения star говорит сучки ребята у меня состояние изменилось после чего компоненты войны и компоненты которые на это подписаны они начинают изменяться то есть у нас изменяется наш юань теперь смотрите есть один маленький нюанс о котором но обычно редко раскинул редко хотят рассказывать сразу я хочу вам рассказать сразу сейчас смотрите все режиссеры синхронные то есть если вы звали какое-то действие вы обязаны тут же поменять состоянии то но здесь может вопросу погодите а как же с этим outside интервал а я ax как же я без ayxta а для этого есть side effect менеджера то есть у нас есть какие-то сайт эффекты это некая метафора то есть некая сущность которая сидит внутри нашего старого скажем так и слушая такшина и как только к примеру пришел action а не происходит ничего то есть мы не делаем ничего мы создаём эффект который реагирует мы не создаем режиссер мы создаем side effect единственная цель side effect of это наплодить других экшенов то есть к примеру если мы делаем ищите пи запрос мы платим action который говорит мы начинаем а че тебе запрос мы делаем учить и запрос мы закончили чтить и запрос то есть мы целы за 1 экшена мы генерируем целых три и задать задача это side effect менеджеров вот и соответственно дальше эти экшены уже попадают опять стар и какие-то режисеры конкретные уже синхронно обрабатывает эти действия смотрите side effect менеджеры есть много и лично я рекомендую так победить и давайте спрошу кто ридак saga is пор пользуется не пользуйтесь пользуйтесь ридак сообщил честно ну попробуйте ребята бросить и бросьте этот ридак сагу ну честно не пожалеете вот я давайте поливаем обязательно после я просто очень хочу всех переубедить вот кто насади обязательно подходить я всех вас хочу переубедить на ридак сапфира углу пересесть на третьем но эта тема холиваров извиняюсь я просто вы очень хотелось пахали варить смотрите или dax вот сейчас мы просмотрим другую нюанс как редакторе shahid именно дублирование состояния когда у нас есть два состояния которые должны как-то переплетаться да вот это вот проблему с двумя списками и двумя разными источниками данных давайте вот рассмотрим именно этот конкретный пример сейчас то есть мы side effect менеджеры рассматривать сейчас не будем и сейчас я открою куда вы база у меня есть пример опять же ридак см и будем использовать ван gullari но вы можете использовать его даже в реакции там он тоже работает поэтому как бы смотрите соответственно у нас есть здесь более упрощенная версия на как без side effect of без она более простая то есть мы ожидаем в но мы пишем режиссер в котором мы ожидаем некие действия если у нас пришло действие от то есть нажали на кнопку это иногда переместить элемент из одного списка в другой то мы генерируем новое состояние для нашего приложения в котором в одном списке у нас стало на один элемент больше да здесь мы просто из экшена вытаскиваем пайлот это пилот это просто некое состояние до этого экшена то есть никакие данные которые я также передает здесь не более ни больше ни меньше а в другом списке у нас мы отфильтровываем этот элемент мы создаем новый список без этого элемента да то есть у нас здесь имеют абсолютно данные когда мы удаляем мы делаем все ровно наоборот то есть здесь очень просто то есть режиссер очень простой соответственно action режиссера все очень просто а как это использовать непосредственно используется это очень и очень просто у нас есть наш компонент этот компонент умные то есть у нас есть список компонент и другой список так вот как непосредственно ридак срезает эту проблему когда у нас есть два дублирующих состояний и надо их как-то ну чтобы все это хорошо вместе работала они рекомендуют непосредственно данном абрамов и другие ребята рекомендуют делать такой подход умный компонент должен то есть вы не должны в режиссерах в side effect менеджера где-то решать эти проблемы по хорошему вы должны решать эти проблемы в умном компоненте то есть как советует изначально то есть ваш умный компонент он должен подписаться на наши айтемы и как только они изменятся здесь angular используя дизайн паттерна все рабу то есть это просто подписывается здесь мы подписываемся на изменения после того как мы на них подписались как только мы у нас изменили наши айтемы мы отфильтровываем те айтемы которые у нас есть в другом списке то есть мы просто из одного списка отфильтровываем элементы в другом списке здесь нечего делать мы делаем это непосредственно в компонентах smart компоненте плеере чему мы с ридак сам тоже решаем эту проблему давайте посмотрим визуально как это происходит то есть смотрите за счет чего то есть как только у нас наши открылась наше приложение наш stor понял что наше приложение открылась там есть определенный action я здесь написал up on a но на самом деле там другой action происходит окей наше приложение открылась после чего мы на это среагировали и мы side effect менеджером начали непосредственно загружать данные мы загружаем данные для списка а загружаем для списка б делается этом большим количеством экшенов да я сейчас не буду их все перечислять то есть это бегемот loading and lot допустим для каждого из списков и после всего когда все у нас это непосредственно загрузилась то у нас star сообщает компонентом каждый раз о том что надо переставать тот или иной компонент делается это в умных компонентах после чего каждый из этих компонентов перерисовывается и фильтрация непосредственно происходит уже внутри умного компонента то есть вот эту конкретную проблему ридак совершают вот непосредственно там в смарт компоненте деле другой vobix так как mop x5 один человек ладно киева на я извиняюсь что спросил я на самом деле могу быть очень классная сейчас расскажу в чем в чем его суть и написал его mafell в straight он ножкам так его имплементацию непосредственно есть какие-то дополнения к нему еще что то но вот главные man тренеры главный идеолог это вот собственно вам идея очень простая мы создаем некую конструкцию вроде сервисов то есть это как и сервис иван gullari это некая конструкция но она называется там в сторе то есть такой naming convention больше принято называть их стороны непосредственно в их много маленьких он не один глобальный их очень много маленьких то есть мы также делаем как с ангулярным мы создаем в нужных местах где нам надо мы создаем непосредственно на 6 и на 6 каждый из этих элементов они делятся на обсе рубл то есть какое-то свойство мы помечаем декоратором обсе робу к примеру а какое то действие какие-то методы мы помечаем экшен и теперь такой вопрос кто же знал эту картинку какая ассоциация вот кто кто-то говорит очень похожи на не в разделе про angular в другом вот паттерн и secures да и на самом деле вот в этом ну просто я не знаю просто какая-то классная суть мобы кс то что они имплементировать coming вере separation причем делает это структурирована то есть мы бы как не просто так они на самом деле еще имплементировать come un cuore separation то есть фактически благодаря этому они получают вот некие бонусы которые мы видели но мой bags непосредственно делает от немножко по-другому давайте попробую показать гуляли мы можем подключить есть библиотека им говорим об x поэтому мы тоже можем хорошо очень работать см x так и давайте посмотрим то есть мы вон gullari все равно называем это сервисами но по хорошим можно называть это стороны это как бы в принципе одно и то же на самом деле здесь смотрите что происходит соответственно у нас экшены помечаются декоратором экшн да вот а когда мы карьеру получаем айтемы да мы делаем свойства гитар и помечаем его компьютер то есть мы получаем декоратором компьютеры дополнительный декоратор то есть как мы выкса решает вот эту проблемы дублирующего состоянии смотрите здесь мы в конструкторе с помощью dependency injection injection а inject м внутрь другой estore то есть как мы бы говорит делать если у вас есть зависимые то есть у вас состояние одного стороны зависит от другого вы просто передаёте его как параметр то есть вы компонуете сторой между собой мы передаем другой стол и что здесь происходит как только мы его сюда передали мы запрашиваем эти данные и потом как только мы передали этот stor вместо того чтобы просто вернуть айтемы мы отфильтровываем текущей айтемы в соответствии с состоянием другого stora но обязательно нужно не забыть декоратор компьютер почему потому что это декларирует что это свойство она вычисляемые то есть она не просто так она зависит еще до дополнительных факторов и она вычислять каждый раз то и за ним на внимательно следить и мы бы кс благодаря этому решают вот эту проблему то есть нам вот этот подход он очень подход похож на подход сервисами сервиса сами по себе очень простые поэтому мы bags тоже очень простой способ генерации и работы с вашим состоянием вашего приложения но у них плюс том что они дополнительно реализуют common каире separation хотите вы этого или нет buy дизайн просто они это делают и непосредственно и исправление дублирования состояния происходят именно здесь пересмотрите как это происходит то есть у нас когда происходят какие-то экшены у нас на 6 понимают что нужно проверить дамы когда добавили удалили элементы надо проверить что что-то произошло к примеру загрузка прыгнул то есть нам надо загрузится до изначально происходит загрузка после чего обновляется свойства и обновляется к примеру компьютер свойство нашего списка да и это свойство она уже зависит от другого stora то есть благодаря этому мы по ним нешто кей надо передать именно отфильтрованные данные внутри наших компонентов и уже лист компоненты и второй лист компонента лис компоненты адалис компания они оба начинают понимать что надо здесь обновится и здесь обновится и они получают именно нужные данные теперь другой подход 10 вот этот подход очень классная на самом деле очень люблю и мне очень жаль что во фронте не очень мало людей нем знают на самом деле на бэг-энде тоже подход вот я не выговорю с первого раза извиняюсь 3 2 рейнс коук с другими ленинска ук кто знает его есть один человек а теперь такой вопрос кто знает дизайн которого висел это автор познакомитесь вот это автор design pattern не виси и он принес мир не только вот эту красоту он привез еще другую 10 10 это немножко такой своеобразный подход смотрите вот с ридак сам сервисами и впрочем и другими вещами что мы всегда делали мы создавали кучу файлов создавали кремль средах сам или сервисе мы создаем контроллер view model s редактор что мы делаем мы создаем action rides her side effect менеджер еще что то мы постоянно создаём кучу разных файлов чтобы добавить одно свойство данный экран у нас создать кучу кучу файлов каждый из которых будет как-то с этим работать 10 делает абсолютно по-другому смотрите вместо того чтобы размазывать вертикально вот эта функция на он говорит давайте размажем горизонтально подчас не запоминайте эту картинку вот посмотрите просто не и прочувствуйте а сейчас я покажу код чтобы уже не просто прочувствоваться а понять давайте откроем 10 смотрите во первых произошла одна вещь у нас больше нету необходимости создавать два умных компонента у меня один умный компонент и это классная вещь на самом деле подойдет не только для ангулярным для реактора очень классно вы можете уменьшить количество умных компонентов вашем приложении смотрите что происходит если посмотреть то у нас появилась такая вещь как контекст я сейчас не буду его открывать давайте откроем сначала непосредственно вот наше приложение теперь смотрите у нас два абсолютно одинаковых списка то есть он у меня есть об лист и другой еще лист но у них есть один nickeynick некоторые это это способ фон gullari получить ссылку на компонент и не удивляйтесь если вы в первый раз видите angular смотрите у них разные имена то есть добавление и удаление теперь давайте посмотрим на сам компонент что он из себя представляет компонент вообще безумно тупой здесь нет ничего кроме с кроме свойств и событий то есть компонент тупой стал здесь больше нет никакой бизнес луки даже упоминания про бизнес логика смотрите следующие что происходит и когда у нас происходит какой-то экшен мы просто выбрасываем события то есть у нас абсолютно то пиши компонент в реакции это просто был бы тупой компонент функция какая простая смотрите как это работает а вот для того чтобы это заработало нам нужен контекст что из себя представляет контекст контекст этап некая абстракция которая работает не так как мы ожидаем яркий пример это смотрите на им работника да у нас появилась какой-то бизнес приложения еще смотрите небольшой of the pitt есть приложение на им работника мы вместо того чтобы создавать класс и чар класс работник и распихивать функционал между этими двумя классами а потом пытаться как-то все это скрестить нос как это лапша получает сюда бульон куриный мы вместо этого берем и создаем просто два маленьких объекта и чара работник и создаем класс который называется найм работе да то есть это не прекращая контекста это от rim off то есть как глагол фактически то есть мы целое действие какую-то бизнес action какой-то бизнес логика выносим в абстракцию то есть мы абстрагируемся объекты а взаимодействия с этими объектами то есть как только мы вот наш контекст создали в этом контексте у нас есть разные элементы у нас есть ссылки на эти компоненты мы их получаем чуть дальше дальше мы запрашиваем необходимые нами данные то здесь мы идем непосредственно как бы в бэг-энд заданными да здесь у нас вот симулируется с помощью обсирал delay мы симулируем запрос заданными и здесь же мы фильтруем потому что мы одновременно идем и за теми и за теми данными необходимые для работы вот этой части бизнес-логики теперь дальше что происходит дальше когда у нас происходит инициализация то есть когда мы инициализируем наши компоненты мы передаем ссылки которые мы получили ранее на компоненты а дальше что мы делаем вот мы получили ссылки на компоненты а дальше мы подписываемся на события то есть один винт леснар фактически до из дома к примеру и передаем пропсы сами вручную в компонент то есть вот этот класс занимается непосредственной передачи всей необходимой информации чтобы эти компоненты перестали быть как бы глупыми а стали своего рода умными то есть мы перейдем всю необходимую контекстную информацию при этом сами компоненты очень простые остаются после чего у нас здесь есть все необходимые методы и мы подписываемся соответственно пример если у нас произошло какое-то действие в нашем первом списке мы вызываем метод добавить если во втором списке там вызываем метод делает в этом же контексте все происходит здесь же смотрите то есть к примеру когда мы хотим добавить элемент что мы делаем мы просто из одного списка удаляем в другой добавляем потом сохраняем данные и когда удаляем элемент тоже делаем некую логику удаляем ее ум на то есть нам надо не просто удалить нам надо проверить что если у нас в первом списке у нас нет уже это этому тогда его перенести и и так далее и тому подобное это здесь некая дополнительная логика которая занимается проверкой вот этой публикации состояния дублирование и ну и вспомогательные методы чтоб сохранить и загрузить их local storage и пересмотрите все это работает если запущу мы получим полноценно это уже приложение но стало на 2 smart компонентом меньше памяти то есть если не видно разницы зачем на 2 smart компонента больше понимаете то есть смотрите схематично это происходит так что нас появляется некий некий контекст который уже непосредственно начинают работать и соответственно все что происходит в этих контекста связано с конкретной этой бизнес логикой благодаря этому мы можем лучше управлять состоянием то есть мы можем это состояние сама по себе как то лучше контролировать мало того это очень расширяемая то есть мы можем взять к примеру и добавить 3 список к примеру в каком то приложение то есть мы просто можем взять добавить просто еще один элемент нашу базовых библиотеку перенести то есть мы можем очень хорошо наследовать бизнес-логику то есть мы можем в разных проектах кастомизировать и и наследовать ну благодаря этому делать очень много интересных вещей поэтому здесь я и очень классная вещь ну а теперь про мой любимый дизайн паттерн это самый лучший дизайн паттерн вообще на свете сделала просто самый скромный человек на свете придумал да я думаю вы все его знак тот кто узнает этого человека до остальные видимо не то голову не поднимали ok ok не смотрите на самом деле несмотря на то что я говорю что это классный дизайн паттерн это ничего более как смесь инверсия то здесь я не изобрел никакого rocket санса я этот паттерн дел в для определенных вещей то есть у меня были определенные конкретные бизнес задачи бизнес задачи были очень простые то есть не было два recommend a требования номер один чтобы можно было очень быстро заменять view то есть смотрите у кого есть проблема в компании что сейчас у вас там допустим angular бюджета потом react сейчас все вую хотя да вот если так то кто-то завтра еще чего-нибудь захотят реакторе л и еще что то то есть view слой постоянно постоянно меняется и вот это вот гонка она убивает и мне поставили конкретно такую задачу что можно было view слой поменять очень быстро react angular canvas в нативная куда-то от рендерить то есть очень очень быстро подменять условий и это делается с благодаря дизайн патрону малевич кстати все догадались почему малевич хочешь четыре элемента да и смотрите view слой безумно прост и это номер один то есть в ее слой делает минимальное количество работы второе то что передача данных происходит джейсоном то есть грубо говоря мы никогда не передаем функции и колба кими перейдём непосредственно какие-то данные между с тором контроллером if you модели и view давайте посмотрим просто как это работает то есть что происходит малевич так давайте посмотрим на вот этом компоненте смотрите первое что у нас происходит у нас энтони цитируется наш компонент то есть вот у нас компонент стартует и как только он стартует у него есть ссылка на к свой контроллер как только компонент инициализируется он вызывает какой-то метод к примеру опыт то есть мы открыли наш компонент мы начали работу что происходит непосредственно в контроллер давайте откроем контроллер вот непосредственно в контроллере как только мы вызываем метод open мы начинаем обращаться к спору то есть контроллер имеет доступ только кастора он говорит слушает загрузи нам данные изначально вот при изначальная загрузка макиле приходим в листок мы вызываем метод лут и т.п. и здесь я сейчас не загружаю что-то синхронно но это все может происходить абсолютно синхронно то есть здесь у нас может быть скромная передача после чего мы обращаемся к view модели то есть мы можем синхронно можем асинхронно то есть когда угодно мы обращаемся в любой удобный для вас момент времени нас здесь ссылка есть у стороны только на view модели и она вызывает метод апдейт то есть она передает данные на горит суши у нас данные обновились обновить то есть перерисуйте что-то произойди и вот view model это самая толстая самая сложная часть что здесь происходит не обращайте внимание на красной линии пока что это просто typescript и здесь 100 пинга меня проблема смотрите что происходит этот view model иметь доступ непосредственно к нашему view в you do в данном случае выступает непосредственный компонент который нам нужно отрисовать что здесь происходит смотрите view model ее главная цель из полностью сформировать представление то есть форме джейсона к примеру у нас на юар есть кнопка мы должны создать объект для этой кнопки то есть должен в джейсоне считать объект если в кнопки есть текст мы должны в этот же сон положить текст если кнопка выключена у нас должен появиться в джейсоне атрибут дизай болт у которой будет стоять true то есть мы должны полностью дублировать нашу life for me ricoh а то есть мы полностью да должны его продублировать и всю бизнес-логику которая необходима для прорисовки uiaa мы должны сделать здесь то есть к примеру здесь создание айтемов да то есть какое-то непосредственно количество атомов примеру вот name да то есть у нас на его у нас есть надпись и кнопка то есть у нас есть батон тексты у нас есть батон текст нам надо отрисовать кнопку мы здесь четко говорим какой текст у нас должен быть после чего непосредственно уже в компоненте мы вызываем метод апдейт и этот метод обновляет непосредственно уже нужным для данного текущего слоя то есть для angular а мы просто передаём список шаблон перерисовывается до для react и то же самое то есть мы просто передаем туда в пропсы данные и у нас перерисовывается наш ряд компонент то есть поэтому мы наш наших земель становится очень простым то есть у нас нет необходимости какую-то как-то генерировать какой-то сложный чем эль какой-то логики писать какие-то ф-л statement и тринарный операторы и прочие в шаблонах то есть мы всю логику которая необходима чтобы отрисовать сформировать наш юань мы все делаем во вью модели благодаря этому благодаря тому что мы ничего почти не делаем во вью кроме просто отрисовки банально это тоже благодаря этому view очень маленький очень простой и очень компактный сейчас если мы посмотрим на некую схему то мы увидим что у нас благодаря тому что этот квадрат взаимодействие происходит всегда в одном направлении то есть здесь тоже есть однонаправленность как в редакции да как flags то есть здесь у нас контроллер сообщает то какие-то необходимые данные для споров то здесь у нас есть два stora к примеру два состояния что происходит у нас в модель подписывается на оба stora то есть у нас вот исправление вот этой проблемы с дублированием состояния она происходит во view model а то есть если у нас есть два состояния 2 stora два источника данных мы разруливаете эти типы эту проблему во вью модели то есть мы передаем туда данные его view уже что-то меняем после чего view уже обновляет какой-то войны и каким-либо способом и уайтом с помощью дома канваса или как угодно это происходит но смотрите вот эта особенность она характерна не только для малевича но и на самом деле для виверн то есть мы обычно видим патенты можем спроектировать таким же подходом в принципе то есть единство что в обмен не принято все переносить абсолютного view model но если мы перенесём то мы получим что-то наподобие малевича и вот смотрите я сейчас рассказал очень коротко на самом деле про архитектуру ну скажем так еле затронул было у меня всего лишь один пример я не объяснял подробно почему важно разделять на умны или глупые компоненты я надеюсь что вы это понимаете я очень много чего не покрыл на самом деле архитектура это сложный вопрос безусловно но я надеюсь что сейчас у вас есть намного более более больший выбор что сейчас когда вы будете выбирать каким стать менеджером писать ваше приложение или когда вы столкнетесь той или иной проблемой вы будете понимать почему вы с ней столкнулись и каким подходом вы ее сможете решить всем спасибо добрый день с пасибо за доклад и его вопросу в чем вот вы рассказали про вот в сеть архитектуры и хотелось бы услышать плюсы и минусы каждого каких случаях нужно использовать тот или другой и каким вы пользуетесь вы когда разработаете спасибо да смотрите на самом деле я хотел включить непосредственно в слайде эти плюсы и минусы на их довольно много и они занимают довольно много времени для описания поэтому я их включу ссылки на все ссылках я подробнее распишу прям список будет подробный плюсах и минусах но вкратце если вы не знаете какой из этих подходов выбрать выбирайте редактуре dax а есть два основных плюса первое это огромные комьюнити то есть очень много разных from work of очень много разных подходов да ты прям как как-то принятая система дано принято многими то есть пример react angular тоже пиши твои то есть очень много кто использует именно редакции поэтому вы всегда вам легко будет найти помощь второе это огромное количество документации видеокурсов это тоже немаловажный фактор поэтому это вам облегчит жизнь то есть если вы не знал сомневаетесь выбирайте редакторе да кстати стоит выбирать если у вас очень разрозненно очень большая команда за счет то что редакции имеет много вот этих вот маленьких элементов то есть многие жалуются то есть редакции это много маленьких элементов каждый из которых надо еще по файлу создатель на тяжело но муторно но благодаря этой муторной работе тяжелее просто создать бардака то есть богатому что вы знаете что вот в риге siri одно должно быть там в экшене от друга и в общем крейсере третье side effect менеджеры 4 то есть у вас все в разделе но что должно чем заниматься вам будет сложнее сделать что-то не так 10 подход я бы рекомендовал к примеру когда у вас есть один проект и он очень много кастомизировать то есть вас есть базовый проект базовая кодовая база новые и нужно к тонизировать очень хорошо в разных ситуациях до примеру то есть есть другой проект почти такой же но тон по-другому себя ведет кнопка вызывает не так но и вот какие то такую вот логику наследования вот для этого бы я бы использовал odyssey малевич я использовал конкретно для двух целей первое это опять же чтобы быстро подменять view слой второе то что в малевич очень классно можно сделать свой кэширования то есть если вам на фронте нди нужно сделать кэш то вы вы можете использовать малевич он очень хорошо потому что скоро хранят вот это состояние с бэг-энда непосредственно в том же виде в котором они его получили то что обновленное состоянии то есть какое-то изменение происходит во вью модели по горячему если вы снова делаете запрос и данные вообще не поменялись на бы candy вы просто эти делаете но сравнение да ну деп деп не deep как компресс он после чего вы видите что данные полностью не поменялись можно ничего не триггерит то есть не вызывает метод апдейт убью модели по горячему у вас ноль изменили его я просто из-за того что данные не поменялись то есть можно делать много таких хитрых оптимизации secures я бы советовал если вы с ингуля рам примеру сейчас хотите как-то быстро навести порядок то есть это очень классный подход если он на быстро вот сейчас навести порядок мобы кс посоветовал бы если вы просто устали от редакции то есть ну вот просто устали создавать эти экшены его просто уже руки отваливаются потому что smap x вы можете получить хороший структурированный код потому что у них разделена к вере и и команды вот благодаря тому что у них такой хорошего структуре на я кот но при этом в нет столько бойлер play то он намного меньшим об x то есть там намного меньше файлов намного меньше вот каких то вот телодвижений необходимо сделать при этом вы получаете в принципе хорошая структурированный код вот по крайней мере как-то так еще вопросы последнего просто что время заканчивается спасибо за так он 1 раз спасибо за доклад вопрос поводу наличия не совсем увидел место в котором собственно эти два списка реагировали они они и агрегируются во вью модели я в коде просто возможно это не показал и на диаграмме тоже на диаграмме то извиняюсь но я просто возможное и криво нарисовал я тут извиняюсь но агрегируется и исправляется вот это вот проблема с двумя состояниями во вью модели то есть он берет оба и текстура и так как у нас состояние одного скоро зависит от другого то есть состояние одно списка зависит от другого во вью модели мы делаем эту фильтрацию просто в методе апдейт во view model a то есть это вот то место где в малевича решается эта проблема получается что принципиальное отличие от 10 в том что у нас есть вот эта четко изоляция view от собственного у модели от модели да но смотрите вот малевич сам он довольно далёк от 10 в том плане что здесь я вы поймите у них есть главная идея под 10 то есть малевич что я клепал ну как бы извините ну придумал идея главная идея не была как бы надо были задачи идеи не было были задачей а вот и задачи сходил аудио есть классный подход его называют как новой жизни у p10 то есть не просто так это на самом деле классная вещь в чем идеи idea логично то что вы занимаетесь абстракции да вы наследуете не объекты какие то вы наследуете логику пошли юзер стори на вашу бизнес-логику то есть вы абстрагируйтесь процесса не объекты вашей системе а процесс абстрагируйтесь по горячему вы наследование применяйте на процессы горячему природная сотрудника вы можете выкинуть пример вот пример я проводил с моим сотрудника бумажки коллируя чара и заменить им ли там экранов компании в которой не этой чара нанимать може тимлид то есть вы понимаете что как это можно примерить и смутило в этом паттерне потому что получается что вот этот контекст может превратиться в лапшу если выбрать слишком крупную единицу от этого бизнес-процесса да согласен да здесь к сожалению да здесь я почему не советую начинающим 10 никогда по что здесь надо сначала архитектурно все-таки продумать систему к сожалению здесь я не позволяет то есть редакции в этом плане проще то есть но как бы там четкие и понятные шаги 10 к сожалению классный очень классный но к сожалению не идеальны всего так и занять сейчас к сожалению на вопросов времени нет давайте я вот выйду и кто хочет задать вопросы я вот сейчас буквально через минуту выйду и вы можете подойти и задать вопросы спасибо еще раз"
}