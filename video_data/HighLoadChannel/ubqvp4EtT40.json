{
  "video_id": "ubqvp4EtT40",
  "channel": "HighLoadChannel",
  "title": "Как мы разработали ядро реестра национальной доменной зоны / Алексей Костюченко (beCloud)",
  "views": 98,
  "duration": 2136,
  "published": "2024-10-29T02:48:13-07:00",
  "text": "Алексей Костюченко как мы разработали ядро реестра национальной доменной зоны Всем привет Меня зовут Алексей как уже сказали и я сегодня Вам расскажу как мы разрабатывали реестр национальной доменной зоны by доклад будет именно об этом группа у нас разработки занимается в основном внутренними проектами и они по большей части связаны с биллинговая на вопрос Кто сколько и кому должен заплатить есть и другие проекты это Например как раз реестр национальной доменной зоны дальше я его буду называть реестр чтобы было немножко покороче и проще выговаривать это публичный проект для нас он статусный э хотя у него тоже присутствует тоже биллинговая составляющая и для начала немножечко расскажу о компании в которой мы работаем то чем занимается компания занимаемся мы ээ в основном провайдер в основном интернет звонки это как раз тот биллинг который мы считаем есть ещё хостинг и всё что с ним связано и облака мы являемся Ну имеем свой самый крупный в Беларуси цот реестр национально доно зоны немножечко выбивается из этого всего потому что по большому счёту денег на нём сильно не заработаешь это некий статусный проект который повешен на компанию для того чтобы она обеспечивала зону и в совокупности зоной бел есть даже та нас происходит благотворительный аукцион на котором мы продаём домены которые забыли оплатить они соответственно удалены из зоны и по итогам этого аукциона победитель оплачивает сумму сразу в детский дом просто проверяет есть ли такой платёж и соответственно меняет владельца доменов Ну и немножечко об истории доменной зоны с мы постепенно создали зону бел при этом это ВС было до нас Мы зоной начали заниматься только с 2022 года и мы были регистратором на самом деле у нас в Белоруси пять регистраторов включая нас это шесть которые продают домены есть технический администратор которым мы сейчас стали в Беларуси технический администратор зо он как раз таки отвечает за работу ядра всё это добро реестр национально наной зоны работает на протоколе на определённом протокол он уникальный для каждой страны у нас он называется xml регист регистра протокол коротко мы его называем xrp мы его не писали он к нам пришёл готовый мы просто реализовали сервер который его выполняет предназначен этот протокол для того чтобы регистраторы соответственно Их клиенты покупали э обнуляем так обновляли обновляли информации о доменах полностью взаимодействовали с реестром э в целом протокол работает на основе пакетов в котором содержится xml э и есть ещё четыре первых байта которые содержат длину пакета э в формате НН То есть когда байты лежат в обратном порядке протокол был создан на основе международного протокола EP extensible provisioning прокол вот эта схема ядра нашего она достаточно простая и Типовая У нас есть два два две ключевые точки это л tcp серверов это те самые xrp мы их называем сервера которые обеспечивают выполнение протокола и есть кластер базы данных по SQL который содержит в себе всю информацию о реестре доступ к данной системе э имеют только сопутствующие сервисы и аттестованные регистраторы как я говорил их у нас шесть штук логирование в данном проекте является достаточно критичным и поэтому мы его э организовывали в две точки то есть основу явля основные логи мы ложим в базу данных но и каждый из tcp серверов ложит эти логи себе в циклические файлы которые перезаписывает быть использованы во-первых при спорах в суде а во-вторых при ежемесячном биллинге по которому надо оплачивать домены на первом этапе естественно мы реализовали сервис который выполнял просто функции протокола ирвис слушал стандартном Порту для xrp протокола 9988 ждал клиента как только клиент приходил сервис запускал отдельную рутину и дальше взаимодействие с конкретным клиентом происходило в этой рутине Я позже немножко Подробнее об этом расскажу вместе с кодом который мы реализовывали на первом этапе опять-таки чтение из открытого сокета который в сессию было организовано сразу всего пакета это идеальная сессия я вам покажу как она работала То есть вот к нам пришёл клиент и мы получили соединение с клиентом первым делом сервер ему отвечает точнее шлёт запрос где представляется и указывает свою версию и текущее время в формате UTC дальше идт запрос от клиента как правило это запрос на авторизацию если авторизация пройдена то клиент или регистратор начинает управлять управлять э тем участком домен реестра который ему доступен он может либо получить оттуда информацию которая ему нужна либо э создать какие-то новые объекты создать домен отредактировать его делегировать и что-то ещё сделать всё что как бы умеет делать протокол после того как клиент закончил свою сессию закончил работать с реестром он может сделать запрос на окончание авторизованного он может разорвать соединение Но это идеальная сессия не всегда всё происходит именно так это изначальный вариант читателя пакета что од килобайта хватит всем Ну точнее 1 килобайта должно хватить для любого входного пакета Ну естественно это было неправдой но какое-то время это всё работало и в принципе даже проходило тесты мы параллельно написали несколько клиентов в том числе и один из клиентов был тоже написан на го Именно его мы использовали для того чтобы проводить нагрузочное тестирование сервер проходил нагрузочное тестирование с помою мы смогли немножечко оптимизировать запросы к базе данных и ускорить всю работу сервера и вот у нас сервер есть мы его локально полностью протестировали он работает тесты проходит и мы Обращаемся к тем регистратора нашим белорусским с просьбой о том что Надо протестировать новую версию ядра которая ну Скоро начнёт работать и вы перейдёте на неё в принципе все откликнулись и на первом этапе естественно было созданы соединения Там кроме того что просто организовать доступ ещ был применено шифрование которое тоже вносила некую лепту свою в Надёжность и скорость соединений когда появились удалённые клиенты мы обнаружили достаточно большую большое количество ошибок которое у нас посыпалось при взаимодействии с клиентами они как правило не проходили валидацию пакет должен проходить валидацию Это проверка соответствия протокола и самое первое что происходит при валидации мы проверяем длину пакета который пришёл и сравниваем его эту длину с тем что указано было в первых четырёх байтах этого пакета если оно не совпадает всё как бы понятно что есть ошибка и мы отвечаем ошибкой клиенту и в результате появившихся сетевых задержек у нас как раз-таки происходили Эти ошибки То есть когда мы читаем полностью всё что лежит в сокете иногда происходят ситуации когда в сокете ещё лежит не весь пакет А на момент чтения пакета Мы ещё не знаем его общую длину Поэтому собственно Эти ошибки происходили поэтому Ну как бы вот такая убогая версия читателя была доработана и мы начали читать уже немножечко по-другому Сейчас я расскажу как в данном коде на слайде есть серьёзная ошибка которую мы обсудим опять-таки немножко позже я думаю многие из вас уже сами смогли её найти или найдут там ближайшие пару минут Ну честно говоря я сам её сразу не обнаружил и Для этого мне понадобилось достаточно много времени чтобы разобраться с этой ситуацией на слайде функция запускает читатель пакетов в отдельном потоке ограничивает его время действия в виде таймаута мы использовали контекст для того чтобы ограничить время на чтение пакета из сокета примерно так работал реестр когда мы его запустили тоже все тесты были пройдены сетевые проблемы были исправлены сетевые проблемы в прочем заключались не только в коде но ещё и первоначально там были проблемы именно в сетях которые резали длинные пакеты Ну это какой-то нюанс момент который на самом деле практически с каждым из регистраторов мы отрабатывали а сам момент передачи реестра он у нас происходил в январе 2022 года была такая бессонная ночь в течение которой мы это делали и он достаточно серьёзно контролировал предыдущим техническим регистратором он Нам очень сильно помог ребята из хостера нам сильно помогли и их критика была конструктивно раздражительной так первое время приходилось дописывать функционал и та версия которая работала она периодически обновлялась соответственно Мы полностью всю оперативную память защищали которую под себя забирал сервер поэтому некую утечку память сразу обнаружить не удалось Тем более что на тесте она вообще никак не проявляла себя а вот на проде получилась примерно такая картина здесь период в 4 месяца и за этот период сервис набрал в себя порядка гигабайта это ну конкретно это 870 МБ вроде цифра Небольшая но когда долго работает это на самом деле критично сразу коне получилось эмулировать эту же ситуацию на тесте сейчас она в общем-то смотрится просто и прозрачно Но тогда не сразу понял что происходило Итак давайте посмотрим К сожалению на прод мы не выкладывали первоначально профилировщик точнее приложение вместе с профилировщик поэтому пришлось добавить профилировщик перезапустить опять обнулить память и после этого начать расследование Через несколько дней стало заметно А куда же у нас девается память как вы видите у нас есть некие горутины которые зависли и они забрали порядка 33 МБ Ну и та самая функция Get xml которую я уже показывал это виновник того что произошло вот эта функция уже на скриншоте именно профилировщик здесь мы видим что как раз-таки мы когда формируем канал и проблема именно в том что канал формируем Не буферизованный потому что после этого мы канал передаём в функцию которая читает из сокета и когда она начинает читать у неё на это уходит некоторое время если таймаут происходит раньше то конкретно эта функция она завершается И тем самым затирает буфер куда можно было ложить сам пакет который к нам прил А в канале буфера нету соответственно рутина ей некуда положить пакет она зависает и кушает какую-то память это происходило нечасто то есть в большинстве своём Понятно Что обработка и получение пакета точнее получение пакета из сокета занимает намного меньше времени чем мы выделяли на контекст с таум но тем не менее такое происходит происходит поэтому идт утечка памяти простейшим решением в этой ситуации видится просто создание канала с буфером хотя бы в единицу Таким образом мы добавляем буфер го рутина которая вычитывает Сбрасывает В этот буфер пакет и умирает Ну канал тоже уже никому не нужен потому что никто из него не читает таким образом утечки не будет но естественно не ВС так просто было реализовано хотелось немножко шире рассказать поэтому Давайте я вам расскажу что у нас получилось в итоге В итоге получилось примерно следующее на уровне запуска серра мы запуска наш контекст пустой контекст который мы создавали только на уровне Get xml Это связано с тем что есть достаточно правильный и стандартный подход когда контекст строится в приложении в виде дерева и на основе первоначально созданного пустого контекста мы создаём более сложные контекст контекст с отменой контекст тайма аутом и так далее И если у нас на каком-то из уровней происходит сбой то контекст как веточка обламывается и приложение завершает все дочерние контексты и очищает память который контекст под себя запросил Поэтому вот здесь мы запускаем контекст будем передавать ВС глубже и глубже в приложение здесь у нас цикл как раз таки который слушает тот самый порт tcp и на этом порту Мы ждём следующего клиента как только он пришёл первым делом мы создаём соединение и отвечаем нашему клиенту запросом который содержит в себе время и версию как я уже Говори после чего запускаем функцию соединением и передаём туда и соединение и наш контекст это как раз-таки функция которая управляет соединением Мы видим что в ней происходит преобразование нашего контекста на основе переданного нам пустого контекста мы создаём контекст с отменой контекст с отменой нужен для того чтобы если у нас завершается соединение мы тут могли всё завершить и обломать ветку контекста и дальше этот же контекст уже передаём в обработчик запросов на уровне обработчика запросов мы естественно контролируем состояние соединения нашего и в цикле запрашиваем следующий пакет который к нам пришёл на вход этим занимается как раз-таки функция Get xml в которую мы тоже передаём контекст уже с отменой и соединение вот так теперь выглядит функция Get xml та самая виновница всего этого той самой утечки памяти Теперь мы делаем первым делом Dead на соединение то есть чтение может завершиться по определённому моменту времени далее мы создам кана ноже токо Нате то есть на этом уровне э CH buf канал который мы создаём он будет только на чтение э Тут есть такой тоже классический стандартный подход который ээ не сразу был применён то есть ээ есть владелец канала в данном случае это функция read package э который ээ отвечает полностью за канал он его создаёт он в него пишет и он же его закрывает ээ эта функция Get xml только читает из этого канала дальше у нас в этой же функции Изменений нет Почти то есть есть стандартная конструкция xml ой Select которая ждёт одно из событий первое событие - это завершение времени выделенного на чтение пакета это то что мы создавали ранее через контекст а второе событие - это как раз таки приход того самого той самой структуры которая будет содержать у нас пакет и признак его Удачного чтения из из сокета что у нас делает владелец канала Естественно он первым делом создаёт канал после чего запускает го рутину в которой запрашивает первые четыре байта из сокета после чего вычисляет длину всего пакета и и читает все остальные байты которые остались До конца пакета То есть вы читая первые четыре вычитывать этот пакет до конца и сравниваем его длину с тем что нам пришло соответственно Если всё хорошо мы отправляем назад наш пакет и говорим о том Ну и дальше происходит некая бизнес логика обработки этого xml если нет то мы отправляем ошибку и у нас происходит обработка уже ошибки теперь посмотрим внимательно что у нас происходит в методе который поно читает из сокета вообще почему именно потно то есть Почему прит тени эспе для самый простой и читабельный в реализации способ надёжный способ чтения Дело в том что для реестра нам намного важнее было Надёжность его работы чем скорость работы если здесь читать одним запросом то естественно это будет быстрее но скорость чиния по байту скажем так нивелируется дальнейшая обработкам там запросом запросами в базу данных и так далее То есть по сравнению с остальной обработкой это мелочь которую мы решили не рассматривать предварительно созданный Dead у нас может сработать на уровне Connection и чаще всего если у нас происходит какой-то замедление получения пакета в сот то именно это функция срабатывает ще Ну потому что она во-первых содержит немножко нару на секунд более раннее время но во-вторых ээ наверное всё-таки чаще обращается к этой функции чем Хотя это на самом деле два разных потока которые могут сработать и одновременно то есть на самом деле обе ошибки могут произойти при этом э они будут грамотно обработаны то есть проблем не возникнет либо это обработает по итогу ошибка либо та я имею в виду контекст с завершением по времени здесь мы как раз акцентируем внимание на Con Я извиняюсь рассказал немножко ранее теперь вернёмся немножко назад Дело в том что всё-таки мы решили использовать буферизованный канал И это тоже оправдано Дело в том что коно здесь у нас буферизованный канал он будет работать примерно так же как не буферизованный Почему я сейчас объясню потому что как бы хотелось по умолчанию понимать что вот буферизованный значит есть буфер некий через который пройдут данные и потом уйдут дальше да Но в данном случае есть нюанс именно языка го когда если канал уже создан и первым в него приходит читатель пакетов то этот читатель блокируется пока в канале не появятся данные Но кроме того что блокируется читатель Ещё сам канал записывает в себя указатель на тот буфер в который надо записать данные и когда приходит после этого писатель к этому каналу и бросает ему данные которые вычитал то эти данные сразу автоматически без буфера канала попадают к читателю таким образом у нас нет задержки никакой Вот то есть разниц в данном конкретном случае между применением не буферизованный канала и буфере зоно по скорости не должно быть никакой примерно так у нас э стал ээ выглядеть срез который мы через профилировщик э анализировали во время нагрузки то есть небольшая память э отъедается на обработчик обработчике запросов потому что параллельно идёт множество запросов и вот тут конкретно по мегабайта обработчики забрали после того как нагрузка спала Всё у нас как бы линейной и никаких всплесков по памяти нет Последний раз наверное в районе года назад перезагружать этот сервис и уже утечки никакой не происходит порядка 20-30 МБ оперативной памяти постоянно Ну и е небольшой нюанс у нас этот проект не является таким Вот нагрузочный потому что реальная нагрузка которая к нам приходит она как правило не превышает 200 запросов в секунду С этим достаточно легко справляется несколько серверов которые обрабатывают протокол Ну и нет никакой необходимости расширять количество серверов которые работают по этому направлению Вот теперь хотелось бы ещё раз немножечко э-э вернуться и рассказать те тезисы которые вот я для себя конкретно усвоил и может быть повторюсь чтобы вы э прониклись этим го рутина которая ответственна за создание других го рутин также ответственна за их завершение по возможности надо разрешать создавать записывать и закрывать канал только владельцу канала и использование подобных принципов э и паттернов при разработке в команде позволяет избежать но множество ошибок Ну делайте не так как мы делайте лучше нас всё спасибо за внимание Я бы хотел ещё может какие-то вопросы услышать так я наверно зря нал Да коллеги Будьте добры вопросы Мне кажется что совсем не весь материал который мы ОТС матри в процессе подготовки попал в в результате в доклад поэтому я уверен что есть что спросить Да подскажите пожалуйста вот я так и не понял В чём преимущество по батово чтения то есть что Вы получили в результате по Бато чтения и от каких проблем избавились вот этот момент совсем непонятен смотрите на самом деле очень хороший вопрос потому что уже есть мысли что всё-таки надо увеличить тот буфер который мы читаем и просто вчить мы должны забрать сразу но по байтовой чтение оно позволило нам в таком упрощённой схеме контролировать сам процесс и немножечко наверное замедлить и анализировать то что происходит потому что у нас достаточно много логов и мы смотрим на каком этапе у нас происходит сбой в данном случае то есть иногда грешили на сетевые ошибки иногда вот на чтение из сокета Спасибо большое за доклад Я может быть немножко не совсем в контексте самого проекта А мне бы хотелось такой вопрос задать вот вы когда работаете с запросами сильно завязывается на структуру самого самих данных в запросе А мне интересно этот контракт где-то описан где-то зафиксирован чтобы гарантировать что в таком виде данные приходят именно со стороны клиента нету риск что Клин в какой-то момент просто потеряется прол Если вы про xrp то да естественно он описан там описание протокола занимает Порядка 70 страниц и больше 20 команд с разными условиями выполнения там есть некоторые статусы для доменов которые можно менять это всё как бы завязано из на закате сво Республики Беларусь и какие-то международные практики и естественно каждому регистратору который к нам обращается который хочет стать регистратором Мы открываем этот протокол в лом открытый то есть мы не публикуем этот протокол он является неким локальным белорусским протоколом и э работаем по нему только с теми кто прошёл аттестацию эти регистраторы Все получили протокол написали свои клиенты которые у них работают по этому протоколу мы не отдаём своих клиентов Мы ждём того что у них есть свои разработчики которые его реализуют и последующим они работают с нами Именно по этому протоколу который Достаточно чётко описан Добрый день в моей практике встречалась такая занятная Атака через СС когда клиент шлёт нам по байту Ну мы с удовольствием по байту вот прямо как вы вычитывает Но к этому байту добавляется Огого сколько падинский В каком месте у вас здесь включается шифрование на самом деле шифрование включается на уровне доступа к системе то есть там очень ограниченный доступ это ээ вопрос наверное больше к нашим безопасника безопасника то есть э доступ к реестру имеют только вот ээ очень ограниченное количество участников этого процесса Если я правильно понял я понимаю специфику проблемы Но это с некоторой точки зрения административные меры которые не спасает от такой вот техническое возможности Угу То есть вы имеете в виду что если пошла атака от регистратора само собо Я не готов исключить такие вещи они бывают Да бывают то есть ну на первом этапе естественно идёт валидация соответствия протоколу кроме проверки вот этой длины соответствия всего пакета там достаточно много уровней проверки валидации то есть и структура должна совпасть и данные какие-то должны совпадать Да и если как минимум xml не будет прочитан Ну нагрузка Наверное она будет да Но если она пойдёт Мы через безопасни отключим регистратора соответствующего как минимум Есть возможно атестации то есть такой ну жёсткий конечно подход но в целом пока как бы вот мозгов хватает только на это так есть ли у нас ещё вопросы Да да Давайте Сначала вы а потом вы Спасибо Спасибо Алексей Михаил домклик у меня короткий вопрос на самом деле А почему го ну как-то было время когда попробовал и так затянуло очень сильно затянуло честно говоря он такой лёгкий заход был что потом не смог оторваться Я думаю это такая частая история сго да это правда так пожалуйста Привет Меня зовут Денис компания Сбербанк Технологии вопрос возможно на который вы не сможете ответить Ну из-за не знаю каких какого-то так сказать nda А как определяется то является ли скажем так регистратор валидный это на уровня акси ж делается верно или и если делается то это возможно какая-нибудь проверка пошу сертификат проверка по синки или почему-то я на самом деле смогу ответить на вопрос Дело в том что во-первых он проверяется на уровне шифратора то есть дальше шифратора не регистраторы не проходят То есть у каждого из них есть свой ключ который он может использовать для того чтобы подключиться после чего у них есть некие параметры авторизации да то есть ну типа логин пароль допустим поэтому тоже начинается сессия вот ответил на вопрос или не совсем да то есть хотел просто резюмировать то есть авторизация регистратор проводится на стороне самого сервера Да xrp сервер проверяет не в данном случае просто распределяет нагрузку Ну ничего более так хорошо спасибо есть е вопрос Я так за этим слежу что чу задать послед Да здравствуйте Меня зовут Алексей У меня скорее не вопрос о комментарий У меня как раз вчера тоже был доклад про видеостриминговые вного Таких данных вот рекомендую посмотреть там во-первых нужно поставить буфер стандартный из Go А дальше использовать и как бы Go сделает всё за вас то что вы вот написали эту функцию делает за вас и как бы я там тоже комментирую что сеть действительно может отдать разный размер сообщения как бы в зависимости от скорости это решается вот на уровне Ну спасибо большое доступ к докладу Посмотрите так есть ли у нас ещё вопросы а тогда я дам свой комментарий и задам свой вопрос Мой комментарий такой когда я работал и строил ВПН а чтение по байтовые у нас был специальный дебаг режим в котором мы включали по байтовой чтение из сетевого буфера потому что из того На каком месте и в какой момент происходит ошибка при чтении очередного байта можно было извлечь массу полезной информа при отладке протокола Это был комментарий А теперь вопрос раз Вы ждёте что регистратор своими силами реализует клиента вашего протокола предоставляете ли вы ему песочницу для отладки Да конечно отлично то есть в той же зоне где у нас работает прод у нас работает тест для регистраторов они более того постоянно тестируют там так спасибо если вопросов больше нет то настало время выбрать лучший вопрос слушайте Ну наверное был первый вопрос самый каверзный потому что я именно его боялся Ну тут не совсем оптимальное решение с точки зрение чтение по байтам Да оно как бы вот надёжное и позволяет нам анализировать то что происходит но при этом у меня уже давно закрались мысли о том что ну надо наверное увеличивать скорость и тогда будет Ну я не знаю ну быстрее работать Хотя ещ раз по скорости проблем вообще Нет То есть Ну только атева люди имеют доступ с ними прямой контакт всегда есть если у кого-то возникает проблема на меня выходит и мы взаимодействуем но при этом Да есть такая проблемка Спасибо вам большое за вопрос Спасибо я прошу автора лучшего вопроса выйти на сцену мы вручим ему подарок и вручим подарок Алексею Спасибо боль так всем спасибо"
}