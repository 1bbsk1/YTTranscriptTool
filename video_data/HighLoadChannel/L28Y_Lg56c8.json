{
  "video_id": "L28Y_Lg56c8",
  "channel": "HighLoadChannel",
  "title": "Работаем с транзакциями в БД правильно / Сергей Новиков (Real Time Technologies)",
  "views": 9689,
  "duration": 3077,
  "published": "2020-04-27T13:25:21-07:00",
  "text": "я backend разработчик уже больше десяти лет при этом уже десятый год я работаю с базами данных по сброс но до этого естественно работалось москва или так далее и уже последние несколько лет образом я работаю в том числе и как детей то есть я смогу посмотреть на эти процессы с разных точек зрения и как разработчик как а как администратора соответственно со временем наловил большое количество багов и появилось некоторое понимание вот почему они возникают и как правильно и как неправильно но просто рассказать как правильно было бы не очень корректно если мне рассказать почему поэтому я решил пойти от обратного собрать все проблемы которые наловил за эти годы и рот разобраться почему они собственно возникают здесь пара оговорок первое это по архитектуре вашего кода может быть код очень хороший красивый там слоистый модульный все по фаулер у бывает код больше похожие на спагетти естественно что проблема чаще возникает во втором ходе но в принципе мои рекомендации они будут а местная для любого проекта потому что проблема эти всеобщее 2 оговорка непосредственно по базам то есть я буду давать примерно под гарсе но в принципе это все касается наверно любой реляционные с транзакциями и даже не только рисунки итак первое что хочется обсудить это зависание транзакций то есть давайте попробуем сначала разобраться а что это вообще такое и что такое зависшая транзакция ну я могу дать такое условное определение что зависшая транзакция или долгая транзакция это та транзакция который работает достаточно долго чтобы у вас начались проблемы если у вас проблем нет то в принципе пусть она и дальше работает и на самом деле проблема не рано или поздно все равно возникают просто среди разработчиков например мало кто знает о том что это происходит с тем более мало кто разбирается почему и как это все affected первая проблема это то что у вас начинает тратятся места на диске если у вас долгая открытой транзакцией висит то у вас начинают опухать таблицы и индексы в некоторых случаях журнал вал это конечно плохо с точки зрения производительности потому что плод таблиц он начинает влиять на скорость чтения и других операций ну вот как пример приведу у нас на одном проекте был случай когда но фактически транзакции работал двое суток при этом продукт был достаточно нагружен и на одной из наиболее употребимых таблиц там дошло до того что на дно строку полезных данных получалось 250 струг мусора накладные расходы на чтение одной строки выросли многократно что еще здесь неприятно то что когда у вас место это потратиться его не всегда легко вернуть обратно то есть если журнал он схлопнется по итогу то вот с фрагментацией таблиц и индексов придется отдельно повозиться обычно of the vacuum их это место не вернет вторая проблема то что увеличивается количество блокировок увеличивается окно для возникновения всяких неприятных ситуаций связанных с блокировками особенно опасно если у вас транзакция заблокировала что-то потом другие в это уткнулись тоже заблокировались и так далее каскадно и в принципе так можно вообще съесть весь свой полк соединение потому что обычно пол соединение он меньше паула worker of и все это может привести к тому что у вас просто будет полный отказ системы потому что маркеры пытаются соединиться с базой сделать какие-то запросы а все соединения заняты зависшими транзакциями это я тоже в практике ловил ее когда это происходит почти каждый день особенно по ночам ничего приятного в этом нет кроме того у вас возрастает риск блоков ну тут надо говорится что в принципе да блоки могут появиться от того что вы добавили транзакцию там где раньше не было то есть кот без транзакций может работать и вы добавили транзакций у вас начались друг get lucky но если у вас эти транзакции еще и долго висят то в принципе этот риск еще больше увеличиваться потому что увеличивается временное окно почему собственно возникает самая частая причина это вызвало сторонних сервисов например вы открыли транзакцию что-то заблокировали а потом полезли в редис или полезли в какой стороне веб-сервис и этот сервис зависает вместе с ним зависает ваша транзакция естественно чего хорошего в этом нет что можно попробовать можно во первых попробовать вынести эти вызовы из код блока транзакций потому что на самом деле зачастую это вообще не требует никаких серьезных переделок то есть он может быть логически не связан с этой транзакций можно попробовать пересмотреть логику работы с базой то есть если у вас есть транзакция может быть она вообще здесь не нужно как пример некоторые используют транзакции для того чтобы заблокировать какой-нибудь там task в очереди отправить его во внешней сервис для обработки а потом после обработки его удалить из базы но в принципе же блокировки можно делать не только с помощью транзакций можно в рыбе сохранить флаг блокировки или можно у этого тоска завести поле статус обновлять его также то что он в работе находится можно разные кейсы по придумать на этот счет или же можно пересмотреть границы самой транзакции то есть вынести из него какие-то запросы которые можно сделать отдельно если у вас с кодом ничего нельзя сделать то есть вот он написанного так и должен работать вот так можно попробовать хотя бы сделать побег поменьше более из всего этого ну вот позвольте например есть такая настройка на idol in transaction состоянии то есть это тайм-аут на то время которое соединение находится в транзакции в простое когда она достигает порогового значения транзакция просто отстреливается можете поставить такой тайм-аут и в принципе он на продакшене нелишней будет по принципу но все равно она не работает так пусть хотя бы умирает побыстрее другая причина зависания это вот уже блокировки которые мы обсудили здесь конечно на уровне кода обычного мало что можно сделать но можно попробовать во первых можно попытаться убрать лишние блокировки наиболее часто это локти apple когда вам нужно всего пару записей там заблокировать в таблице или for апдейт без указания таблицы когда вы делаете запрос и там несколько таблиц фигурирует в join ах если вы пишете просто for апдейт то все связанные таблицы будут заблокированы на самом деле то можно указать конкретные таблички чтобы они заблокировали себя таким образом месте количества лишних блокировок можно попробовать понизить уровень этих блокировок но это конечно легко сказать на практике это редко получается но к примеру если у вас есть эксклюзивные блокировки иногда их можно поменять наша разблокировки то есть тот же for апдейт можно иногда поменять наш фарш и ну это же такой немножко капитанский совет не делайте тоже чего вам не надо делать всякие у и рынке особенно самописные они очень любят делать кучу лишних запросов кучу лишних join of если будут особо усердствовать то могут даже и блокировок нахватать вот но в принципе борьба с неправильными блокировками это на тему отдельного доклада поэтому здесь не будем заострять внимание а вот что касается кода то здесь есть частая проблема то то что я встречал даже не на одном может даже не на двух проектах я уже все не помню это когда у вас есть ручное управление завершением транзакции то есть вот как в примере вот здесь казалось бы простой метод там на четыре строчки как он может не работать мы представим себе ситуацию которая часто видел к нам приходит новый разработчик допустим вася и чтобы влиться в проект ему дают простенькую задачу суть задача такого если первый запрос у нас ничего не вернул то второй запрос можно и не делать увася радостный на энтузиазме находит нужный метод и модифицирует его примерно таким образом и добавляет нам выход из методов и вот здесь у нас получилось зависшая транзакция потому что вася не сказал никомед не rollback перед этим на черном и если с этим ничего не сделать то скорее всего это транзакции так и будет висеть до конца работы приложений скорее всего от просто отвалится по итогу и все данные будут потеряны может показаться что это вот бага конкретного программиста но я такие баги очень часто видел и у опытных людей кроме того есть более тяжелый вариант этой ситуации более трудно уловимый так скажем это исключение у вас в принципе особенно в запутанном коде может всегда вылететь с исключение в самом неожиданном месте и вы вылетаете соответственно из этого метода и и точно так же получается зависшая транзакцию чтобы все это обработать нам придется код переписать уже примерно таким образом да кстати это php если кто не понял я только доллары убрал чтобы никого не смущать ты здесь мы во-первых все засовываем в огромный трой кетч обязательно везде делаем rollback то есть простая задача по факту выливается достаточно громоздкий код причем вот так надо писать везде собственно антипатр здесь в том что мы пытаемся вот руками обработать все эти неудобные ситуации это что фактически когда мы пишем бегин то мы сами себя потом заставляем где-то написать еще к металле rollback и это очень легко пропустить но в принципе есть способ автоматизировать этот процесс представим что у нас есть некий класс транзакций у него в конструкторе есть бегин в деструкторы есть rollback мы тогда сможем переписать код примерно таким образом мы создаем объект транзакции у нас стартую транзакция в базе данных в конце мы этому объекту говорим commit и он завершает транзакцию в базе при этом если что-то пошло не так если вы вылетели из метода там вас исключение ли еще что то у вас срабатывает тут же деструктор и транзакцию откатывает и в принципе это мы так получаем нужную нам логику на без всяких костылей здесь конечно можно заметить что не всегда же нужно rollback сказать иногда нужно кормить сказать ну комитета уже извините такая вещь которую надо руками писать конечно хорошо если у вас есть всякие аннотации в языке или какой-то метапрограммирование но если его нет то commit придется писать руками по поводу еще языков небольшая оговорочка потому что папа это с ним все понятно но где это работает та же самую фишку с инструкторами можно провернуть в питоне все + + и в принципе даже в джаве там нет деструктор в привычном понимании но там есть строева за ресурсы с который в принципе делает как раз то что нам нужно хотя java это отдельный разговор у них там все по-своему вруби деструкторов не ты там я сходу как-то не нашел какой-то workaround надо уже смотреть то есть конкретно по вашей ситуации где это сработает а где нет так дальше поговорим о вложенных транзакциях эта ситуация она в принципе нормально она возникает рано или поздно в любом проекте то есть у вас есть метод который работает с транзакцией его вызывает другой метод который тоже хочет работать с транзакции напрямую в субботу нельзя дважды сказать бегин она на это ругается и хотя на самом деле есть механизма для управления вложенными транзакциями в базе но про них мало кто знает почему то когда про них не знают начинают это все пострелять в приложении из того что я видел пестрели обычно сводится либо к какому-то флагу тому что мы уже транзакций и тогда бегин не вызывается повторно либо даже чаще видел счетчик вложенности то есть чем больше мы говорим бегин тем больше у нас накручивается счетчик потом соответственно при комментах rnb как он откручивается а фактически команды в базу данных идут только когда счетчик равен нулю в принципе неважно вот как вы это делаете эмуляции она как правило к этому сводится и разработчики думают что они таким образом немножко обманывают базу данных то что она и перестает ругаться на несвоевременной команды это на самом деле наш следующий антипатр потому что во первых счетчики могут сбиться особенно если вы это совместить из первой проблемы с забытым ромбиком они могут сбиться и могут сильно сбиться как пример в одном проекте у меня был маленький хороший демон он делал очень простую работу он вычитывал пакеты и забитым киу и сохранял их базу данных читал и сохранял больше ничего не делал поскольку там было несколько таблиц в этой работе связанную то там было транзакция и там были во первых счетчики вложенности а во-вторых естественно забыты rollback в результате этот счетчик не просто сбился он у меня уходил в бесконечность и для база все это выглядело как одна огромная транзакция который никогда бы уже не завершилась соответственно приходилось ее либо убивать в базе либо убивать самого демона самое обидное что данный при этом терялись наглухо потому что мы их из рыбе то вы читали уже пометили как прочитанное все их не выбить и нет ни в базе нет неприятная вещь не делайте так вторая проблема счетчиков более скажем так глубокое то что на самом деле никакой вложенные транзакцию вас базе данных нет давайте посмотрим на простых примерах всегда ли это работает вот у нас есть две транзакций обе у нас прошли успешно тут все работает как ни странно еще раз 2 транзакции на теперь обе отвалились мы обеим сказали рубик и тут тоже все работает потому что мы откатываемся изменения ничего у нас базе не сохранил все хорошо третья ситуация внутренняя транзакция отработала но внешне мы откатываемся тоже все в порядке потому что но мы сейчас не говорим об автономных транзакциях и мы считаем что если у нас есть внешний транзакция то все ее эффекты должны быть откачан и в том числе и то что было закончено в промежутке а вот здесь у нас проблема здесь мы хотим сказать rollback внутренней транзакции при этом закомитить внешнюю но в базы данных это ничего про внутренний транзакции не знает то есть вы в коде можете вызвать rollback для внутренней транзакции но для базы данных никакого эффекта от этого не будет и она естественно за комитет все что вы там понаписали то есть мы получаем в базе данных не то состояние которое вы хотели причем вот что любопытно сам по себе этот метод срубе команду сработает но вот если его обернуть уже внешней транзакции тогда он работать перестаёт та же проблема у нас с обработкой ошибок то есть когда происходит ошибка запроса транзакции переходят в аборт от состояния и все последующие запросы не принимаются все данные которые вы до этого успели записать они все теряются и соответственно если у вас произойдет ошибка запроса и вы эмулирует ложные транзакции на уровне приложения то все равно у вас вся транзакция внешне она вся сломается и все данные будут потеряны то есть у вас нет возможности обработать эту ошибку как-то локальном поэтому так или иначе приходим к тому что влажной транзакции надо делать на уровне база данных и база данных нам такой механизм предоставляет называется он своих point и для тех кто не в курсе суть довольно проста мы создаем точки восстановления возможно несколько и к ним мы можем откатываться когда мы считаем что все хорошо мы их отпускаем релизом это аналог операции commit и вот таким образом вы в принципе можете гибко управлять теми изменениями которые у вас в итоге попадут в базу данных в том числе можно откатывать некоторые ошибки но большинство наверно таких некритичных ошибок можно откатывать и пробовать заново и так далее но здесь есть пара нюансов во-первых это все конечно не бесплатно с их поинты для базы данных операций достаточно тяжелая то есть они работают принципиально иначе нежели обычные транзакции поэтому если вы начнете на нагруженном проекте массово используется и в point и там где их раньше не было то это может очень сильно вас ударить он собственно прошлогоднее падение амазона тому хороший пример второй момент связанности в поинтами нюанс так скажем использование то что можно косы фонд откатиться много раз обычно транзакции вы откатываете один раз и все она закончилась с и пойнту можно откатиться много раз и это может дать некоторые неожиданные эффекты ну вот вспомним тот класс транзакций которые мы обсудили с rubick-ом деструкторы предположим что мы его переписали так чтобы он и с их поинтами тоже управлял в автоматическом режиме чтобы нам не приходилось над этим задумываться и посмотрим вот на такой вот метод если это обычная транзакции это все работает мы откатили первый запрос второй запрос уже в авто к митр режиме у нас все хорошо но если это саиф point to объект транзакции остается активным и в ненужный момент то есть в конце метода у него сработает деструкторы повторно будет вызван rollback и в этом случае вы потеряете результаты 2 запроса тоже ну это не самая страшная вещь то есть здесь можно много чего сделать можно просто убить этот объект транзакции вместо вызова метода rollback чтобы уже сразу отработал деструктора либо просто не делать запросов после ролл bk варианта решения разные просто про этот нюанс надо помнить дальше пойдем по обработке ошибок это вообще больная тема сама по себе не хуже транзакции но вместе они иногда дают просто потрясающие баги и прежде всего была такая раньше холивар на я тема популярна и что делать выкидывать исключение ли возвращать флаг успешности ну мне все-таки кажется что в 2019 году уже надо было отходить от старых практик тем более что для базы данных вот этот подход с возвратом более во флакон особенно неуместен вам надо обязательно проверять что все запросы отработали что все данные у вас сохранились на самом деле если у вас транзакция этого это пропустить это вас потом вообще все запросы работать не будут вот и что еще важно нужно всегда точно понимать причину падения ну вот не знаю как других языках в php например если у вас есть исключение то там это как-то попроще там все тем данные есть понимать причину очень важна для того чтобы ваш бизнес логика правильно работала потому что без этого могут быть всякие веселые эффекты вот пожалуйста пример из практики это практически скопировал как было здесь вообще все прекрасно то есть во первых мы проверяем то что запрос 1 не упал просто возвратом но здесь хотя проверяется во вторых этот код никак не рассчитан на транзакции то есть если у нас это все в транзакции то второй запрос тоже не отработает ну и в третьих конечно сама идея о том что если у нас первый запрос упал с ошибкой нам надо сделать почистить на мою табличку это конечно хорошая идея но как ни странно бизнес-логика там была именно такая то есть первый запрос мог упасть по вполне конкретной причине и в этом случае действительно надо было делать трон кейт проблема естественно в том что никак не проверялась почему этот первый запрос упал и однажды естественно что-то пошло не так первый запросу полно по совершенно левой причине я уже не помню по какой то ли там соединения моргнула то ли еще что то в результате при этом соединение осталось работоспособным результате второй запрос внезапно выполнился в середине дня и в середине дня у аналитиков куда то пропала вся агрегирования статистика собственно причина в том что мы не проверяли почему первый запрос упал как это можно проверить во-первых поиску или стоит коду причем это делать надо обязательно то есть просто анализировать текст ошибки неправильно если вы не знаете что за искали сетку от первую очередь надо от него отталкиваться но его не всегда хватает то есть например вы пишете в табличку у вас там есть парочка уникальных ключей у вас срабатывает уникальный ключ и наверное хотите знать какую именно сработал и здесь пригодится вот явно какая-то система в том как вы именуете constraint и в базе данных и как вы минуете исключением хранимых процедурах то есть не должны быть какие-то случайные строки вы должны четко определить и задавать в коде вообще в подписи на уровне протокола реализовано передача например имени constraint а отдельным полем то есть чтобы приложение не приходилось как-то из текста ошибки это constraint вычленять но конечные драйвера не не все это реализуют в php например нет такого отдельного поля с именем constraint а поэтому придется анализировать текст ошибки и искать там нужные нам стручки выглядеть это может примерно так вызываем хранимую процедуру регистрации пользователя передаем какие-то параметры и определяем две ошибки которые мы хотим перехватить одна связана с уникальным ключом на email другая это исключение которое у вас сбрасывает хранимая процедура данном случае что сэм скотт протух и надо создать новый и вы создаете соответствующие исключение выбрасывайте их здесь очень важно что вот эти классные исключения которые вы используйте чтобы они отличались от какого-то обычно вот это близ exception которого выбрасываете в случае ошибки базы данных чтобы вы могли отделить мух от котлет потому что не все ошибки базы данных вообще имеет смысл ловить и как-то обрабатывать но об этом чуть ниже окей вот вы сделали эти классы хотите их ловить с помощью траки но что если все это работает в транзакции мы это не всегда можем знать поэтому нам придется завести собственную транзакцию и обязательно откатить ее в случае если что-то пошло не так чтобы наше соединение вернулась в рабочее состояние то есть как только вы ловите предусмотрено ошибку первым делом вы откатываете транзакцию после этого уже можете делать какую-то специфическую обработку таким образом вот можно обрабатывать так скажем бизнес ошибки связанные с ограничениями и исключениями в храним koch другие ошибки в бизнес логики обрабатывать особо нет смысла но кое-что можно попробовать попытаться вылечить на уровне драйвера собственно что можно сделать на уровне драйвера как правило можно только попытаться передать или запросить каких случаях это стоит делать если у вас бой подключение вы делаете reconnect и на новом уже соединение запрашиваете тот же запрос при условии что вы уверены что у вас не было commit а потому что может быть ситуация когда база на самом деле успела закомитить все изменения но не успела вам об этом сказать в результате когда вы переподключите си попытайтесь сделать запрос заново у вас будет 2 лишний запрос я не думаю что они у всех здесь абсолютно этом патент на можно смело пытаться повторять до блоки и ошибки сериализации ну в принципе даже можно по усердствовать там 1 510 попытаться повторить если вам очень хочется хотя конечно если так часто падает то здесь уже надо что то делать прошивки сериализации я вкратце упомяну просто мне все наверно в курсе в по сгрызть есть разные уровни изоляции транзакций и на дефолтном уровне с которым большинство работает ошибок сериализации не бывает но а те кто работает с не дефолтным уровнем они уже про них я думаю знает поэтому здесь тоже не будем заострять внимание и самое важное что вот все это работает только если у вас нет никакой транзакций данный момент открытой если она есть драйвер не должен пытаться ничего обработать на месте он должен бросить это исключение выше и так далее почему потому что ну давайте посмотрим следующий пример этот самый наглядный будет у нас есть транзакция и в ней три запроса и на втором запросе нас отваливается и соединение мы перри подключаемся едем дальше что фактически происходит у вас был было одно соединение с транзакцией вы там успели даже сделать insert потом вы его потеряли транзакцию потеряли inserto в базе уже нет выбери подключились едете дальше делайте апдейты делить запросы причем в нам соединение уже никакой транзакций конечно же нет то есть по факту вы получаете частично законченную транзакцию да еще вдобавок с потерей изолированности процесса после реконнекта поэтому в общем случае не пытайтесь вот при открытой транзакцией как-то обработать эти ошибки ничего хорошего из этого не будет ну кстати так в качестве развлечения можете попробовать откатывать до блоки с помощью своих поинтов на самом деле я пробовал и это работает если у вас есть слив point который создан до того как были взяты конфликтующие блокировки то можно каким образом откатить d-блок и не теряя транзакции попробуют повторить заново этот запрос может сработать может не сработать тут зависит от того как у вас код написан ну конечно на практике все равно в продакшене этого делать не стоит так ну и далее последний блок на сегодня это что касается выбора сервера главное что здесь хочется сказать я тоже считают антипатр нам не пытайтесь ничего определять на уровне драйвера автоматически на самом деле ничего хорошего в этом нет почему ну вот рельса кстати недавно сделали такую забавную фишку что если у вас get запрос http то запрос надо отправлять на реплику а если там посадили ты так далее то надо на мастер отправлять но это все таки достаточно спорное решение поскольку i get запрос может вызывать какую-то записи например если вы ведете аудит доступа какому-то документу вот но большинство так не оригинальнее счет большинство просто анализировать текст запроса иногда даже просто первое слово в этом запросе и в простейших случаях это работает давайте посмотрим наши простейшие случаи здесь все замечательно и понятна эта запись как оно есть здесь уже не очень понятно что это может быть и пишущий запрос может быть и читающий чтобы это понять вам надо будет целиком разбирать синтаксический весь запрос здесь у нас вроде бы сказали select но что там на самом деле выполняется в не знаем потому что это хранимая процедура и вряд ли ваш драйвер по названию хранимой процедуры догадается пишущая на или читающая ну и на закуску совсем простой запрос вычитываем владельцы депозита флаг завершенности казалось бы да поднимите руки кто уверен что это пишущий запрос никто не кто-то верит опять же возгласе есть такая малоизвестное мало используемая фишка как вычисляемые поля и например поле комплит здесь не обязательно должно быть реальным полем в таблице это может быть вычисляемое поле для которого вызывается хранимая процедура и она вполне может вызвать запись поэтому здесь вот по тексту запроса что-то пытаться определить даже вот казалось бы в таких простейших случаях это очень плохой вариант лучше если вы конкретно вот вашем приложении скажите что на мастере а что на реплики ну примерно таким образом прямо заводите методы которые обращаются к нужному вам сервису я здесь намеренно не использовал словари ты в right поскольку реплики могут различаться по своему назначению могут быть быстрой lte пышной реплики могут быть медленные аналитические реплики ну и здесь естественно речь не идет о конкретном сервере речь идет о сервисе то есть за одним и тем же методом может скрываться там десяток реплик просто с одним и тем же назначением вот что делать если вам надо прочитать только что записанные данные такая вещь часто встречается например вы создали депозит и тут же хотите посчитать сумму всех созданных депозитов или некоторые до сих пор так достают айди только что вставленной записи сначала пишут а потом вы выясняет что же они там ставили хотя в полисе есть замечательный конструктор тюнинг для этого прежде всего если у вас есть реальное чтение с реплики то вам надо обязательно использовать синхронную репликацию в режиме рима у теплой это режим в котором данные видны на реплики сразу после того как вы их заметили на мастере то есть вот в ту же миллисекунду если вы запросите данные с реплики они уже там будут видны противном случае они могут просто не успеть доехать до реплики не успеть про и грации вы их на реплики не увидите и кстати это не всегда можно будет понять то есть как вы будете проверять сумму депозитов есть тому же этот депозит на реплики или нет но есть еще один нюанс связаный с транзакциями естественно мы же про транзакции говорим если у вас на мастере открытая транзакция реплика эти данные не видит потому что они еще не закончены они уже могут быть на ней они могут доехать до реплики но при запросах все равно вы их там не увидите это кстати еще один кейс когда у вас простое добавление транзакции внезапно ломает весь код соответственно что здесь придется делать придется перенаправлять запросы на мастер то есть если у нас есть на мастере открытая транзакция и мы обращаемся к реплики то фактически это реплика должна перенаправить свой запрос на масть не сама репликами виду на уровне кода это должно быть организовано здесь важной оговоркой речь сейчас именно о транзакциях на уровне транзакциях на мастере транзакции на репликах это отдельная тема сейчас их не будем серьезно рассматривать вот именно если на мастер у вас есть транзакции она не readonly у скорее всего на не readonly потому что смысл такой создавать на мастере в этом случае вам нужно проверять и перенаправлять запросы на мастера что касается транзакций на репликах они имеют право на существование могут быть разные из кейса когда они нужны и здесь уже надо смотреть конкретно если же вы умудрились открыть транзакцию и на мастере и на реплики то здесь я честно говоря не знаю как ваш драйвер будет выкручиваться надо уже смотреть конкретно как вы дошли до жизни такой и куда все таки отправлять запрос сожалению какой-то альтернативы отправим перенаправления запросы на мастер я не нашел в случае если речь идет об изменениях в подгрести вообще есть снимки транзакций вы можете открыть транзакцию экспортировать снимок импортировать его в другую транзакцию так что они обе будут видеть одинаковое состояния данных но это не работает с изменениями то есть если какая транзакция что-то записала еще не закончилось то эти изменения вы в другой транзакции в любом случае не увидите да и между серверами разными это тоже насколько я понял не работает так ну давайте подведем итоги прежде всего мы добавили транзакцию что это может сломать как ни странно здесь плюс и транзакции они фактически и создают новые риски мы добавляем этом or насти у нас перестает работать то что раньше работала это ошибки ретро и reconnect и в некоторых случаях вложенной транзакции добавили изолированности перестали видеть данные которые были до этого записанные раньше успешно читались сохранили состоянии это включает себя и блокировки который начинает проводить где блоком и например если вы используете какие-то кастомные настройки запросов то эти настройки начинают эффект эти последующие запросы тоже и также всегда сохраняется риск того что вы откатить это что считали сохраненным опять же простейший пример вы записали в табличку новую запись получили айди и тут же отправили этот айди в другой микро сервис через какую сказку или рыбе think you после чего у вас откатывается транзакция все записи в базе данных нет а другой микро сервис уже знает что она есть и будет у вас и и запрашивать поэтому пока транзакция работает никакие данные получены вашим приложением считать надежными нельзя их надо держать внутри этого же блока кода и не выпускать наружу если же у вас есть вот такие вот попытки что-то отправить другую микро сервис того что можно попробовать сделать можно попробовать используйте какой-то внутренний буфер для изменений то есть складывать туда изменения но не слышать эти этот буфер наружу отправлять только тогда когда вы уверены что транзакция закончилась или можно вообще перейти на логическую репликацию и в принципе разделить это об записи данных и этапы их рассылки этих изменений на другие стороны так и все-таки как же надо правильно простенькие советы принципе из того что я уже рассказал понятно что все все эти проблемы они взаимосвязаны то есть вы не можете решить какую-то одну проблему не решим ещё несколько то есть вы можете но это будет не так эффективна и скорее всего вы наверное не решите до конца поэтому управление соединениями управления транзакциями обработка ошибок это все взаимосвязаны и вещи используйте транзакции с умом во первых не бойтесь то есть у кого-то может быть возникло впечатление что я призываю отказаться от транзакции ни в коем случае если вы не используете допустим храним кита и вам нужен acid для групповых операций транзакция не безальтернативно и их надо будет использовать но надо это делать аккуратно понимая все эти риски и даже если вы примените все мои рекомендации будете думать что у вас теперь все безопасно и все продумано это не повод распихивать транзакции в каждый метод ничего хорошего от этого у вас не будет переходите на храним ки кто еще этого не сделал я вот очень всегда агитирую это решает массу проблем в том числе и с транзакциями с безопасностью и производительностью из инкапсуляции логике серьезно вот многие боятся но когда попробуют их потом с ушами не оторвать от этих храним ок и что еще важно расслаивать и логику реально расслаивается то есть как обычно делается говорится вот у нас классы отвечающие для за работу с базой данных это у нас слой datasource а вот классы отвечающие за работу с бизнес логикой и так мы росла или нашу логику при этом начинаешь смотреть эту логику а там из бизнес-логики идут обращение к базе данных на каждой строчке то есть фактически эти два слоя не все равно работает в перемешку по-хорошему стоит как-то вот локализовывать эти обращения со слоя на слой и делать количество вот этих переходов между слоями стремящемся к единице то есть вы говорите на уровне бизнес-логики вы примерно поняли что вам нужно от базы данных формируйте такой мета запрос спускаете его ниже и там он уже крутится может делать 10 запросов 20 но только когда все это отработает тогда вы уже поднимаете результаты наверх с краниками кстати это тоже наиболее удобно делать так ну собственно все commit ваши вопросы вопросы вот та вот спасибо за доклад вопрос вам кажется это хорошей идеей вызывайте ролл бы транзакции под инструктору ведь как известно деструктор классах ну конкретно в php называется garbage collector то есть пока все ссылки не исчезнут на перемены этой транзакции это не будет вызван да естественно здесь конечно следить за тем чтобы у вас таких лишних ссылок не было то есть то что я показывал пример с кодом это только в рамках одного метода и вы в рамках этого метода не делайте дополнительных ссылок на бег транзакции если вы с этим аккуратно работаете то у вас деструктор в любом случае по выходу будет вызван все это не проблема ну то есть это безопасно только для когда вы работает в обычном режиме что там пришел запрос и папа умер процесс если я работаю там долгосрочных вырежем их типа там react php и что-нибудь это как-то не применимы уже мне почему все применимости не обязательно умирать может точно так же спокойно за завершить работу методы вывернуться там наверх и деструктор опять же будет вызвать там же нет какого-то накопительного garbage collector а точнее он есть но он не для этого он для циклических ссылок а для обычных объектов у которых счетчик ссылок равен 0 и он сразу отрабатывает хорошо еще второй вопрос я не понял как транзакций выполняется между серверами там мастер злых между серверами они никак не выполняются имеется ввиду что вы на мастере открыли транзакцию и пока она не закончена то данные которые там вы сделали изменения они нигде больше кроме этой транзакции видны не будут вот чем смысл вы при этом можете открыть и транзакцию на реплики и так далее но это никак не повлияет и вообще он просто от себя скажу что на ли она не очень хорошо так расширять интерфейс базы данных там делать 2 отдельные методы там твоих мастер не прошли делал один интерфейс и просто подсовывать разные инстанции классов с разным соединением к разным вас но вы это будете везде в коде делать просто не очень удобно ну через конструктор там дпс injection там да окей dependency injection хорошо я просто говорил потому что у вас вот метод каире slave допустим которые показывал сейчас давайте промотаем вот он то фактически он должен знать о том в каком состоянии мастер то есть это не так чтобы просто получаете объект соединения его передаете в качестве параметра и на нем выполняется сразу запрос не тут все похитрее вас внутри метода должна быть логика определяющая а не надо ли этот запрос отдать на мастер получает его от инстанция вот этого дтп из у него из какой-то стоит еще к тому же но в любом случае это дата бы здесь имеется ввиду не конкретно сидни не да это правильный вопрос это рассматривать как пол соединение понятно спасибо здравствуйте база доклад хотел спросить про хранимые процедуры то есть если хранимые процедуры она автоматически транзакции за сильно точно выдается будет хорошо использую и второй вопрос как бы вы посоветовали вот есть проект там самый тяжёлый уровень изоляции транзакций серьёзен как вот поступиться и поместил какие способы точно надо понижать теоретически если просто хорошо работает то можно его и оставить там же как бы ничего страшного если вы его используете мет если у вас нет лишних ошибок сериализации от этого то я не вижу больших проблем и наши потерять эту страну там где блоков много и так далее далекий это вообще отдельная тема и локи могут вас могут быть и на рядками это тоже то есть можно решать лучше решать просто другим способом если вы используете сериале забыл то вы вообще можете его вызвать в режиме дай бог памяти ритон le plus different как-то так и у вас с самого начала все конфликты сериализации будут исключены и у вас точно эта транзакция отработает причем в нужном вам режиме надежно то есть это может очень сильно упростить и логику приложение потому что все-таки в рядками то там приходится бороться с эффектами чтение и так далее of сериала и забыл такой проблемы уже нету спасибо еще говорить по хранимым процедурам они вызываются в транзакции каждое да но не факт что это полностью избавит ваш код от транзакции то есть вполне нормально когда вы используете храним какие транзакции в приложений тоже вот добрый день спасибо за доклад где такой вопрос был метод который в транзакции делает примут apline между мастером и словом такого про что будет станцию если в этот момент своих отстаёт вот здесь до или где ну да этот момент ну вот я как раз про это говорил чуть выше о том что если отстаёт то данные вы не увидите и на тогда нам делать что синхронная было репликации если мы topline противном случае скорее всего вы их там не увидите потому что там задержка в приложения очень маленькая будет между запросами не понятно что данный мы видим что будет с транзакцию на мастера так не понял вопрос давайте еще раз а смотрите вы пишете на мастер и делаете синхронную репликацию в этот момент реплика отстаёт но нам секунд на 80 бывает при синхронной репликации она не будет отставать спасибо за доклад интересно вы в деструкторы я как-то отлавливаете ситуацию когда транзакция действительно зависла но не по вине д блока или чего-то вот сервер сам за пресса у вас не справился с запросом или не пришло состоянии коннекта что связь оборвалась то есть он висит запроса я понял но смотрите протокол сам pascal совы ван асинхронный полностью но драйвера конечно они почти все синхронно и поэтому когда вы дергаете там какой-то запрос из приложения то он и будет висеть пока он не получит ответа и соответственно у вас приложение дальше не продвинется если вы дергаете уже rollback значит у вас есть как бы освобожденное соединение с которой вы можете работать нет это все понятно просто вас же на первом слайде было при зависании транзакции у нас пухнут индексы и все остальное бывают такие моменты не знаю в паз трассе как точно бывает ли нет но когда запрос повисает ну вот он по не по объективным причинам кода или логике повис он повис именно вот там вот на сервере и мы может быть не хватает ресурсов мог быть чего-то еще дорожает лет деструктор такие ситуации то есть может быть какой-нибудь по таймеру вы летаете или ну что-то такое как то решается не в этом случае у вас будет висеть приложения то есть если она одна поточная php например то все это будет висеть пока у вас запрос не вернет хоть что то все это будет висеть и приложение будет висеть и транзакция будет висеть ответил надеюсь что добрый день я сзади вас с другой стороны здравствуйте здрасте спасибо за доклад интересует вопрос спроса и в paint и смотрите вы сказали что есть риск когда у нас результат тур голубь этом может несколько раз обратиться к одному сайт поинту а может произойти такая ситуация когда мы перескочим через один например у нас мы хотим откатиться на 3 что-то пошло не так мы откатились на номер один такие риски в этом есть что может пойти не так безопасно ли это смотрите во первых тот класс который у вас работает с транзакциями с их понтами он должен естественно учитывать возможное неправильный порядок деструкторов то есть если у вас сначала вызовется там более ранние е деструктора для баранины более раннего с их пойнта то последующие уже не должны вызываться потому что когда вы откатываетесь касаев поинту или же вы его релизе тя то все последующие с их пунктов базе уничтожаются то есть их уже можно не дергать после этого я ответил да вы ответили еще тогда один вопрос вы сказали что саиф payne в принципе сам по себе процедура достаточно дорогостоящего в таком случае с базы данных что произойдет в каком таком ну вот если мы откатились у нас rollback порядок поменялся а последующие все транзакции после point на базе будут уничтожены нет ли риска того чтобы а за просто намертво зависит нет там я думаю такого риска нет если у вас все нормально работает проблем с их поинтов просто в том что механизм сам реализован по сложнее чем обычные транзакции обычно этом на счетчиках и простых операциях сравнения с их поинты я не разбирался на скорее всем что-то в районе стыка потому что там надо хранить несколько вариантов даже одной строки поэтому это все так медленно работает но работают они нормально то есть они отлаженные не должно быть каких-то таких внезапных эффектов я по крайней мере не встречал спасибо дальше последний вопрос здесь такой вопрос привели пример что молодой разработчик новый да может быть даже неопытный пытается нам решить задачу первую и косячит что будет если он будет это делать не в том примере простом а например уже в сложных примеров где логика вас деструкторов где-то еще сложнее там больше или меньше накосячит ну как вам сказать если здесь надо сказать commit передали черном то он накосячит любом случае ну по крайне мере вы вот этой фишкой с деструктора my вы просто снимаете себя диска долгого зависания это уже дорогого стоит понимаете а так ты накосячить можно везде по всякому я не помогу вам заранее сказать какого какой сложности должно быть спагетти чтобы в нем сильно накосячить именно к тому клоню что помни то что здесь рассказано она немножко еще больше усложняет может быть она быстрее помогает решить конкретную проблему но почему не пойти путем например давайте читайте отдельно опишите один пуская транзакции отвечает за запись они за чтения иначе ну что это такое за транзакции которая ждет пока там все соберу и потом вы но в принципе я об этом говорил ближе к концу что лучше всю логику база данных и и как-то выделять инкапсулировать чтобы она в принципе было отдельно от всей остальной логике это может быть класс в котором есть методы которые выполняют вот какие-то бизнес действия и в этих методах идет работа с транзакциями с запросами и больше ничего а бизнес-логика просто обращается к этому сверху либо то же самое в общем то с хранимыми процедурами спасибо большое добрый день а можно еще вопрос нет к сожалению вопросы можно но снаружи зала потому что у нас сейчас уже идет перемена мест спасибо большое за доклад это наша благодарность вам вам в ответ нужно выбрать лучший вопрос так лучший вопрос честно говоря их было так много я ну вот пожалуй первый год запомнил что молодой человек спрашивал подходите"
}