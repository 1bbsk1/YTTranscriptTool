{
  "video_id": "c4_5rqvmDFU",
  "channel": "HighLoadChannel",
  "title": "Как устроены базы данных / Илья Космодемьянский (Data Egret)",
  "views": 41341,
  "duration": 3177,
  "published": "2018-01-16T13:34:04-08:00",
  "text": "здравствуйте дорогие друзья меня зовут лекс деревенский как только что было сказано и я вам сегодня буду рассказывать про то как устроены база данных ну на самом деле я не могу сказать что это будет прямо таки отборные потроха базы данных потому что у нас всего примерно 50 минут или что-нить около того тут скорее будет все таки как заявлено на этом слайде он изначально делался для хайло junior но потому что народ интересовался его решили поставить сюда я буду рассказывать про базы данных так скажем от самого начала и немножко заглубляя в кое-какие подробности которые мне кажется считаются такими важными на самом деле этот доклад родился не от хорошей жизни он родился того что даже не то что начинающие разработчики очень даже такие крутые и продвинутые товарищи они иногда не знают каких-то вещей поскольку ну не знаю муж день в университете учились тех пор давно забыли где то что то уже на практике применяли а в какие-то теоретические вещи просто не заглублять потому что ну как бы зачем и так работает мы на кнопку нажали сквозь погнали все работает но тем ни менее полезно какие-то такие штуки иногда освежить вот этим освежение мы в том числе сейчас и займемся и так для чего вообще нужен этот доклад хранение и обработка данных это мишель critical задача вообще для всех кто работает с какими бы то ни было компьютерными системами то есть даже если у вас последние 30 лет есть какой-нибудь там блог в интернете на текстовых файлах как у некоторых создателей баз данных бывает все равно на самом деле эта база данных этот самый текстовый файлик только очень простенькая во вторых все пытаются изобрести базу данных как вот николай тот сказал перед тем как мы начинали до 20 лет назад написал свою базу данных только не знал что это она и в принципе как бы это тренд в мире очень развит все стараются так сделать во вторых для работы с данными базы данных это страшно удобная штука по какой по простой причине что многие базы данных это очень старые технологии они разрабатываются там последние полвека там в 70-х годах уже были базы данных которые вполне себе там работали по схожим принципам что они работают сейчас эти штуки они очень хорошо и продуманно написаны и соответственно берем разные языки программирования идем к общему удобному интерфейсу обработки данных и становится хорошо мы таким образом можем стандартизованным обрабатывать данные не боясь того что они будут обработаны как-то по-другому при этом полезно помнить что языки программирования меняются да там вчера был второй питон сегодня 3 питон завтра все побежали писать на гол после завтра еще но чем на другом и у вас есть кусок кода который написан на каком-то языке программирования эмулирует фактически какую-то работу по манипуляции с данными которые по идее должна делать база данных а вы не знаете что дальше с этим делать в большинстве баз данных интерфейс очень консервативны если мы возьмем там postgres oracle то в общем то с некоторым бубном вы можете работать даже с очень старыми версиями из новых языков программирования ну и как бы и хорошо и здорово но задача на самом деле не самая простая потому что если мы начнем закапываться в глубины того как нам не побить данные как нам быстро производительна и главное чтобы потом можно было доверять тому что получилось обрабатывать данные то ну сложно сложно это дело потому что если вы попробуете там не знаю написать какой свой простенькой percent на хранилища все просто будет только первые 15 минут потом начнутся там блокировки всякие такие вещи и уже все остальное будет очень сильно разрастаться и самое главное в какой-то момент вы поймете что он зачем я все это делал а ну вот об этом в общих чертах мы и будем говорить итак есть различные уровни работы с данными есть свой доступа к данным которые нам удобно использовать в наших языков программирования или там руками в общей коми таким образом есть свои хранение и это отдельный слой потому что обычно хранить данные удобно другими способами нежели чем использовать ну эффективно по памяти выравнивать складывать на диск с такими данными просто неудобно работать нам потом руками да это вот к вопросу о пресловутом схема лес-то схемок это удобно для хранения на неудобно для доступа и есть еще такой железный совсем слой и этот железный слой он на самом деле как бы это ток где данные лежат и они там организованы еще третьим способом потому что диски это вообще как бы под операционной системой общаются только через драйвер это все сложная штука и мы на самом деле не очень будем туда вникать для слоя доступа к данным есть некоторые требования которых мы заинтересованы чтобы было удобно работать во первых нам нужна какая-то универсальная чтобы мы смогли из любой технологии туда ходить и запрашивать данные нам нужно оптимальность этого запроса да то есть метод доступа должен быть такой чтобы хорошо и удобно доставать данные из базы и нам нужен параллелизм потому что сейчас как бы ну все сканируются до кучи серверов все одновременно идут базу за одними и теми же данными ну как бы процессоров много поэтому надо делать так чтобы максимально получаете все сливки с того что мы можем крепко провели лица то есть быстрее данные обрабатывать таким способом для своих ранения важно чтобы опять же сохранялся по-прежнему параллелизм вот этот который у нас изначально сохранялся до чтобы все данные были там не побиты параллельного доступа не перезаписаны не перетер ты без там каких-то там мусорных данных внутри и в то же время они должны быть надежно сохранены и надежно воспроизведены да то есть если мы что-то записали в базу данных мы должны быть уверены что мы оттуда и то получим взад если кто работал со старыми базами данных типа там foxpro там вот этих вот старых вещей ну часто там появляются какие совершенно битые данные если кто-то работал с новыми базами данных типа манга тебе кассандра и прочих вот этих ну а невозможно сталкивались с теми же проблемами как во времена foxpro а может просто не замечали потому что данных было уже очень многое заметить было сложно для железа на самом деле важно что мы надежно записали но это как бы такое допущение да то есть мы все-таки рассказывай рассказывай здесь будем мам теоретических компьютер строительстве ных вещах в нашей модели если что-то попало на диск мы считаем что там все хорошо как там заменить во время диск фредди это сегодня для нас забота админов да то есть мы не будем туда сильно много погружаться ну и насколько эффективно это организованным и этого практически вообще касаться не будем чтобы решать эти проблемы есть некоторые подходы которые очень похожи у разных хранилищ данных у новых баз данных у классических баз данных и прежде всего это для того чтобы сделать универсальность и оптимальный доступ к данным обеспечить это какой-то язык запросов но в большинстве случаев это ice queen почему мы подискутируем на эту тему может быть немножко дальше по докладу но сейчас просто я замечу что обратите внимание на тенденцию сначала был sql долго и достаточно время ну как сначала были времена и доску или но тем не менее долгое время господства ускорить потом стали появляться такие клевые льюс тораджи которые дескать работают без сквере гораздо лучше сейчас мы наблюдаем тенденцию что многие этики и вылез тораджи которые основном делались для того чтобы из любимого языка программирования было проще заданными ходить да потому что из quelle не очень хорошо вяжется с любимым языком программирования он высокоуровневый декларативный а у нас там объект или что-то в этом роде поэтому имелась такая идея что es que el как бы нам не нужен но большинство этих технологии они сейчас на самом деле какой-то язык запросов свой придумывают то есть там в гипер найти очень развитый язык запросов свой собственный кто-то использует lua даже те кто раньше использовал у а я делают какие-то свои реализации сковиля да то есть сейчас тенденция такая sql опять возвращается потому что какой-то удобный человека читаемый язык работы со множествами он все равно нужен плюс к тому по-прежнему все таки удобно табличное представление в той или иной степени во многих базах данных по-прежнему имеются таблички и это далеко не просто так потому что таким образом легче оптимизировать запросы то есть вся математика вокруг оптимизация на вокруг это самое реляционной алгебры и когда у нас есть иска или табличка это делать гораздо гораздо проще дальше в следующем слое идет такое понятие как серии сериализация когда у нас есть парень параллелизм когда есть конкурентный доступ нам нужно обеспечить чтобы как-то это на процессор на диск приезжала более-менее в каком-то предсказуемом порядке и для этого нам нужны алгоритма сериализации которые реализуются вот в этом самом слое хранение опять же если у нас что-то пошло не так если база данных упала нам нужно ее быстро поднять я думаю вот скажите кто считает что можно написать стопроцентно надежно отказоустойчивые хранилище ну значит вы уже наверно знаете тогда что в принципе база данных она как бы надежно работает только тогда если есть механизм как ее быстро поднять когда она упала до этого нужно восстановление потому что что ни делай где-нибудь будет слабое звено и очень большие накладные расходы на синхронизацию да то есть мы можем сделать сотню копий на сотни серверов в результате там не знаю сгорит питание сгорит какой-то коммутатор и будет плохо и больно в результате для железа на самом деле важно чтобы база данных было хорошо интегрирована с операционной системой работал производительно вызывало правильные syscall и поддерживала все фишки ядра по быстрой работе с данными но на самом деле это не совсем тема нашего сегодняшнего разговора поэтому мы будем в основном говорить про вот эти два слоя а железо оставим для следующих скажем так серий потому что и так довольно объемно получится итак свой хранения начнем с него потому что он как бы как он устроен это очень хорошо помогает понять что же на более высоких сваях почему эти свои устроен это колени и не иначе свои хранения обеспечивает параллелизм эффективности параллелизм эффективность другими словами это конкурентный доступ то есть когда мы пытаемся получить плюшки от параллелизм они обе неизбежно возникает проблема конкурентного доступа мы одновременно ходим за одним ресурсам этот ресурс может записаться не так побиться при записи и черное что еще может при этом получится вторая проблема это внезапный сбой когда у нас обеспечивается надежность это означает что мы не максимально обеспечили катастрофу устойчивые решение хотя это тоже важный момент катастрофы устойчивое решения но важно что мы умеем быстро взять и восстановиться в случае чего и так конкурентный доступ о чем это все вообще здесь вы видите код на несуществующем языке программирования как человек занимающийся базами данных при том как два скорее не как разработчик я обязан какой-нибудь очень плохой код писать поэтому я стесняюсь и написал на несуществующем языке у нас есть банковский аккаунт очень простая вещь счет в банке всем понятно когда я говорю тома там целостность внешние ключи все дела все как-то хмыкает и говорят о мы на уровне кода проверяем на самом деле как только заговор заговоришь там вот а давайте вот примерно вашей зарплате да вот вам переводит зарплату она не пришла к о том почему то сразу понятнее становится не знаю почему сразу такой блеск глазах интерес к теме внешних ключей constrain там вот у нас есть банковский счет у него есть там баланс тысячи рублей но валюта рубли не важно что и есть две функции как они устроены внутри нам сейчас не важна эти функции переводят с этого самого аккаунта on на какие-то другие банковские счета 100 рублей и 200 рублей внимание вопрос сколько денег окажется в результате на балансе счета учета а кто считает что окажется 900 рублей никто кто считает что окажется 800 рублей а кто 4 700 вот и вот здесь вот начинается те самые наши проблемы с конкурентным доступом к данным потому что язык у меня выдуманный совершенно непонятно как он реализован одновременно и исполняются эти функции как они устроены внутри мы наверное считаем что это самая операция она не это не элементарное действие надо проверить баланс проверить куда переводится там найти капюшоном на контроле один на контроле 2 вот это вот все дела это не элементарные операции они занимают какое-то время поэтому нам важен порядок исполнения элементарных операций внутренних прочитали значения какой сейчас у нас на балансе записали на другой баланс важен вопрос когда мы читали этот баланс поскольку если мы это будем делать одновременно у нас возникнет конфликт и обе функции пробуем там примерно параллельно выполняющихся прочитали одно и то же значение баланса перевели куда-то деньги записали каждое свое и это целое семейство конфликтов может возникнуть в результате которых у нас может оказаться на балансе 700 рублей 200 рублей 800 рублей 700 рублей как оно и должно быть или же вообще что-то по бьется скажут что все на балансе на у или на балансе там что-то еще там неверный unicode символ такие вещи к сожалению бывают если с не должны учением относиться как с этим бороться мы будем беседовать в теории все просто но на практике но мы просто можем их там выполнить одну за другой все будет хорошо на практике на самом деле проблема потому что этих операций может быть очень много вот если помните был несколько лет назад история когда сбербанка упала колы processing карточек остановился они выкладывали там совета просили в общественности что им там делать там фигурировала сколько у них логов база данных писала то есть там можно составить себе примерно впечатление о том сколько там было транзакций то есть это огромные огромные конкурентные проблемы выполнять их строго последовательно к тому же это не очень хорошая идея по той простой причине что ну операции много и мы от параллелизма никак не выиграю в такой ситуации можно конечно разбивать их по каким-то группам чтобы они не конфликтовали друг с другом такие подходы тоже есть но они не очень классические для современных баз данных знаете в немецких правилах дорожного движения есть одна интересная история если дорога сужается то правила предписывают доехать до конца и только после этого перестраиваться по одному а соседняя машина должна пропускать соответственно то есть все тут столько друг за другом перестраиваются вот такой знак об этом говорит вот это в принципе такой живой пример все реализации возможны когда очень долго приучали общественность потому что правила нужно соблюдать я думаю что все кто ездит на машине по москве в принципе понимают насколько утопична эта картина нам вот в принципе нам нужно то же самое сделать с данными которым мы от наших клиентов пишем на диск и в нашем воздано и хранилище как улучшить ситуацию ну во-первых операции должны быть как бы независимыми друг от друг а то есть чисто теоретически каким-то контролируемым образом операция должна знать что происходит снаружи неё не может быть такого что как только одна операция что-то изменило результат сразу стал видим там другой должны быть какие-то правила эта вещь называется изолированность транзакций то есть в самом простейшем случае транзакции вообще не знают что происходит соседней это такие действия сами в себе то есть в пределах этой функции никакого взаимодействия наружу нету пока она не закончилась операция происходит по принципу все или ничего то есть либо у нас вся операция произошло и тогда ее результат записался либо если что-то пошло не так мы как-то должны уметь вернуть статус кво и такая операция таким образом должна быть восстановим а а если она восстановила и изолирована то на самом деле она атомарная ну то есть как бы это такая элементарная операция которая совершенно как результат и неделим она не может пройти наполовину она только целиком или только целиком не проходит и нужен механизм как проверить что все на самом деле произошло правильно вот я вас спрашивал сколько денег на балансе почему-то все сказали 700 а потому что мы все знаем что есть арифметика здравый смысл и уголовный кодекс который следит за банками с бухгалтерами что по ней не сделали чего-нибудь вот такого вот в принципе как бы вот консистентной уголовный кодекс это одна из частных версий консистентной sti если мы говорим о базах данных там гораздо больше там внешние ключи constraint и все вот эти вот дела действие с данными которые обладают операция с данными который обладает такими свойствами от омар ность консистентной изолированность и durability эта транзакция это определение aside транзакции есть разное определение для транзакций но принципе как бы в классических базах данных это очень важное и нужное определение d здесь стоит за durability и это та самая модель по которой я говорю если мы данные уже записали на диск то они там лежат эти данные на диске они никуда не денутся на самом деле это не так на самом деле данный нужно бэкапить с данными чего только не нужно делать но для нашей модели когда мы рассматриваем как это устроено это неважно как обеспечить вот эти самые свойства чтобы они выполнялись и чтобы вся обработка данных в базе данных у нас было транзакционному беспечнее то можно как это ни печально в общем то только с помощью блокировок есть 3 на самом деле основных подхода к шуту лингу транзакций так называемые пессимистические scheduler и ну scheduler это такая штука который обеспечивает реализацию да чтоб транзакция выполнялось правильно есть пессимистичные оптимистичные гибридные и основанные на порядок очень и там с темпа происходящей транзакции ну упорядочили темп темпа все знают да то есть мы смотрим время одной транзакции время другой транзакции кто первый встал того и тапки на самом деле для большинства серьезных систем это подход имеет кучу проблем по той простой причине что но для начала время на сервере может идти назад может скакать может идти неправильно и мы приедем есть разные методы усовершенствовать это но чисто как один единственный метод синхронизации транзакций эта штука не работает есть еще векторные часы вам порта в час и наверняка слышали где-то такие термины у них тоже есть свои ограничения есть оптимистические подходы которые подразумевают что нас не будет конфликтов типа того что я писал с банковским счетом но в реальной жизни они не очень-то же успешно работают хотя есть реализации которые помогают какие-то операции проводить с помощью оптимистичных вариантов ну как люди работающие с базами данных мы на самом деле всегда пессимисты да то есть мы ожидаем что программисты напишет плохой код поставщик поставит плохое железо марь иванна выдернет из розетки сервер когда будет мыть пол ну всякие вот такие вещи чего так и может не быть поэтому мы любим пессимистичные scheduling транзакцией а именно с помощью блокировок и это в общем то единственный гарантированный способ обеспечить целостность базы данных есть соответствующие теоремы их можно доказать и как бы продемонстрировать это нужны в принципе эффективный алгоритм и взятие снятие блокировок по той простой причине что если мы будем просто блочить все что нам нужно скорее всего мы придем к очень тупой версии когда мы тупо выполняем операции строго последовательно а как мы уже знаем это не эффективно с точки зрения утилизации параллелизма современных циpкa современных количеств серверов и так далее здесь небольшое лирическое отступление которое поможет нам понять что же будет происходить дальше это так называемая семантикой бранта был такой французский математик в первой половине двадцатого века которых эти изобрел рекурсию если я не ошибаюсь он придумал транзакция еще в до компьютерные времена обозначать следующим способом с от слов скидывали расписания и расписание транзакции она записывается таким вот образом есть операции может быть рид буковка r может быть w от слова райт запись еще бывает б от свой бегин c от слова коммент и тому подобные вещи тут что удобно у нас есть для одной транзакции до циферка 1 это другой транзакции то есть нас одна транзакция просто читает данные из exo из какого-то ресурса да то есть какое-то поле в табличке например решить в этом роде 2 транзакция его записывает видимо этой транзакции вот уже читает видимо делают какую-то математику на основе этих двух чтениях со и записывают что-то в y очень удобно мы можем посмотреть соответственно и транзакции состоят из элементарных таких действий чтение и запись и чтение и запись и тогда мы можем соответственно составить итоговое расписание проверить его если в нем конфликты с помощью всякой хитрой математики и таким образом гарантирует что у нас все будет хорошо и целостно ну давайте ехать дальше для чего нам это все было нужно один из основополагающих алгоритмов в современных базах данных и так называемые двухфазное блокирование или тупил для простоты почему двухфазная было подмечено что для оптимизации блокировок взятие снятие блокировок в базе данных удобно сделать это в два присеста сначала мы выставляем блокировки на все транзакции которые на все ресурсы которые нужно прочитать или записать там узко по транзакции которая на данный момент есть базе данных только после того как мы все выставили мы начинаем их снимать это позволяет более эффективно schedule и транзакций чтобы они не ждали как это работает на практике вот эти линеечки обозначают транзакции тут у нас их три это время их исполнения вы видите что вот операция записи в первой транзакции ресурса x она имеет не нулевое время то есть она вот здесь вот началась и вот здесь вот она закончилась то есть вот транзакция так вот пишет упрошу запись это занимает какое-то время пока диск повернется пока страничке туда вы уйдут и так далее и когда начинается у нас вообще в этой нашей модели нет никаких транзакций поэтому он учу она началась пошла запись она пишется но 2 транзакция она должна прочитать x и эта транзакция не может взять блокировку на чтение к запуску по той простой причине что x в этот момент пишется другой транзакций и линия становится пунктирной это означает что транзакция ждет блокировки которая выставила вот это вот транзакция как только транзакции занимается какими-то еще другими вещами и так далее как только у нас транзакция взяла все блокировки которые были нужны для того чтобы она выполнил пуша еще нужно буксировка на y и блокировка назад после того как эта блокировка была взята только с этого момента она может начать отпускать блокировки в этот момент разблокируется следующая транзакция которая соответственно уже тоже выполняется до конца то есть идея вот такая это повышает эффективность транзакции позволяет одни и те же операции выстраивать как бы в параллель только так чтобы элементарные операции блокировались ждали да то есть и столько они конфликтуют только если есть конфликт и иначе бы нам пришлось бы это вытягивать и делать фактически эти операции одну за другой вот этот алгоритм называется духовное блокирование рекомендую вот это вот книгу ну в слайдах вы увидите что это будет доступна вот сыновей кум это такой фундаментальный учебник по теории транзакций на самом деле весь мой сегодняшний доклад он про рассказ каких-то вещей про общее понимание этих вещей как только вы хотите в это заглубиться очень советую вот эту книгу или те две книги которые я советовал в качестве домашнего задания которые опубликованы на сайте конференции что плохо в двухфазном блокирование почему нельзя так просто решить всю проблему со всеми базами данных с помощью одного простого волшебного алгоритма во-первых с такими блокировками неизбежно возникают до блоки когда непонятно курица или яйцо у нас одной транзакции нужен ресурс x другой y они а блокируют а дальше им нужно крест-накрест те же самые ресурсы и непонятно кто должен 1 отпускать блокировку для этого в базах данных являются имеются специальные системы контроля дед log off и так называемого отстрела году локов то есть 2 нельзя разрешить каким-то мирным способом потолок можно разрешить только откатом одной из транзакций когда одну из транзакций мы просто отменяем обычно математика внутри детекции без звуков это граф де доков где на вершинах у нас обозначены транзакции найди и стрелочки между ними обозначают какая какую ждет какая ждет блокировки от какой и на этом графике выделяются небольшие под графы от одной из этих вершин смотрится например если одну транзакцию ждет очень большое количество транзакций большой под граф-то эту транзакцию там прибивают ну там есть разные подходы мы не будем на них концентрироваться потому что кому интересно можете почитать статьи на тему док detection там есть много разные красивые математике второй момент это медленно никто не хочет ждать блокировки если у нас есть такие транзакции которые как бы занимают ресурс надолго кто работая с базами данных знает что такое бывает когда много у т.п. транзакции одна длинная какой-то отчет считает вот она за него какой-то ресурс и все остальные там вынуждены ждать вот чтобы этого не было на самом деле придумали некоторое усовершенствование о которых пойдет речь на следующем слайде но в принципе за то таким образом цивилизация обеспечивается то есть без двухфазного блокирование никакой сериализации то есть надо придумывать как улучшает двухфазное блокирование чтобы меньше ждать чтобы сократить время на ожидание и в любой современные базе данных на самом деле двухфазное блокирование это главный способ обеспечения целостности даже если и сериализации даже если мы говорим о фиксе он и база данных но в принципе тут со звездочкой надо сказать что бывают такие конфликты которые указаны блокированием решить нельзя и тогда такая транзакция просто откатывается то есть обычно в базой данных реализован механизм когда по таймауту база данных ждет некоторое время если длинная транзакция ждет блокировки слишком долго она просто и убивает а то есть когда база данных понимает что нельзя никак разрешить этот конфликт но это более редкая ситуация на самом деле алгоритм со следующего слайда он помогает решить некоторые из этих конфликтов то есть versio нирования данных она не только для того чтобы ускорить а еще и для того чтобы решить некоторые разновидности конфликтов которые могут возникнуть интуитивно все понятно да что такое мульти вершин конкуренции как control если мы заблокировали какой-то ресурс мы можем посмотреть в его предыдущую версию начать с ней работать если например эта блокировка была такая что-то транзакция который блокировал а не изменило ничего на этом ресурсе то мы можем продолжить исполнения транзакции откуда надо если соответственно было изменения и появилась новая версия более свежие этих данных наша транзакция будет вынужден их еще раз перечитать в любом случае это обычно быстрее чем долго ждать блокировку если помните старые мастерской сервер если помните старые версии дебюту страшное дело если там пошла пошла много блокировок дальше началось эскалация блокировок работает плохо и с этим жить тяжело все современные базы данных в той или иной степени version ники да то есть сейчас там оракул postgres мой сиквел они все version ники в честном видя дебету немножко оригинальный на эту тему там как бы имеется свой механизм там хранят только одну предыдущую версию кому интересно можете после доклада спросите расскажу как не будем что называется заглубляться в недра дебюту тем более что я сильно сомневаюсь что много прямо с ней работают что такое би си си в теории и вот здесь вы видите расписание которое я рисовал до этого которое несколько более сложная здесь у нас во первых транзакций больше у нас их три штуки у нас больше ресурсов у нас есть еще z и у нас есть два к metadata есть оба транзакции заказа заканчивается коми там только в конце вот дано такое расписание с ним разбираетесь и тут в принципе как говорят таких случаях математики я вот это уде очень люблю то напал доски форму вот он говорят люблю легко заметить на ну вот я вам расскажу что на самом деле тут легко заметить одну штуку и я думаю что в качестве домашнего задания можно попробовать понять почему это легко заметить это не так и как она на самом деле но я вам подскажу это расписание никогда не реализуется по той простой причине что мешает вот это вот операция будет конфликт и будет d-блок возможно даже будет блок если не будет доступна предыдущая версия вот этого игрока на вот этом этапе то есть если здесь будет доступна предыдущая версия и мире кто трансакция нормально там совершенно завершится никаких проблем не будет если это версии игрека не будет то эти операции будут конфликтовать как это устроено как это работает диаграмма более-менее такая же как с двухфазным блокированием это разновидность version на ваши dallinga транзакции да то есть это все равно алгоритм двухфазного блокирования только мульти version эй и мы что здесь видим здесь добавляется еще такая фишка как нижний индекс нолик нолик единичка да это номер версии до 0 это первая версия единичка это более свежая версия соответственно когда мы пошли исполнять вот эту транзакцию у нас имеется чтение x а сам и изначальной версии дальше мы начинаем записывать y какой-то там другой версии потому что он как то там был изменен дальше в этой транзакции которая началась раньше чем мы начали записывать y и следовательно на ее начала видно предыдущую версию до сих пор видно предыдущие версию поскольку это еще не завершилась мы можем взять y 0 версии и спокойно начать с ним работать и поскольку эта транзакция заканчивается раньше мы перезаписываем эту версию и вот эта штука у нас будет перечитывать y и дальше соответственно выполняться в этой транзакции будет нормальная работа а это транзакций просто нормально завершится если вы попробуйте представить себе что у нас здесь нет предыдущих версий то вы увидите здесь сразу начнутся такие длинные пунктиры когда нужно будет почитать этот y здесь не начнется сплошная линия будет пунктир потому что вот эта штука будет ждать вот этой пока она завершится и соответственно вот этой расписание у нас разведётся в ширину и у нас все будет сильно медленней вот в этом большой плюс того что мульти version ность она на самом деле быстрее чем блокировка они просто маркетинговая фича ряда баз данных а что если в момент исполнения такой транзакции которые явно имеет там не нулевую длительность произойдет сбой например там развалится жесткий диск под базой данных или там соответственно выдернут провода из сервера шлют в этом роде на самом деле мы готовы к этому потому что транзакция выполняется так мы сразу как бы базе данных перешли к абстрактной базе данных контактная база данных устроены каким образом у нее есть какой-то объем памяти который обобществление жду разными процессами или трендами в которых обрабатываются клиентские подключения у у этого самого атрида есть какой-то свой объем памяти куда приходит искали запрос в этом объеме памяти этот искали запрос или запрос на ком другом языке при компиляции интерпретируется перестраивается каким-то образом и дальше он идет за данными которые ему нужно прочитать и изменить эти данные на самом деле на диске лежат специальным образом и здесь как бы мы так вот заглядываем глубже в своих ранений они лежат фиксированными кусками страничками там в подгрести это 8 кей может ли можно разного размера использовать в разных базах данных по разному вот но эта страничка она очень удобно чем что в ней лежит куча разных данных то есть но фактически там бюджет apple или по-русски кортежа когда у вас есть там вот табличка в ней строчки вот эта строчка упакованы в этих самых страничка в больших и если нужны какие-то данные для этого запроса из одной из страничек он просто поднимает эту страничку себе в память и все квартиры все thread'ы все процессы база данных будут иметь к ней доступ если нужно много то он поднимет несколько они будут там за кашированные то удобно производитель на память быстрее чем диски все дела соответственно если нужно поменять хотя бы одну запись хотя бы в одной страничке вся страничка будет помечена как так называемая грязная да то есть это делается для чего потому что так удобнее вот мы рисовали на этом схеме x и y такие ресурсы вот здесь они у нас странички на самом деле база данных умеет блокировать там и на более гранулярный уровне умеет блокировать там единичную запись ну сейчас мы рассуждаем о таких более теоретических вещах не о тонкостях такой глубокой реализация соответственно страничка помечена как грязная и у нас возникает проблема проблема заключается в том что теперь у нас слепок вот эту память этих страничек он отличается от того которой на диске если мы сейчас упадем в память не персистенция мы потеряем соответственно вот эту информацию о грязных страничках соответственно нам нужно сделать следующую операцию нам нужно где-то на бумажке записать какие изменения мы про делали чтобы когда мы поднимемся прочитать эту бумажку и соответственно используя информацию на этой бумажке восстановить страничку до того состояния в которой мы ее привели вот этим самым апдейтом поэтому прежде чем ответа транзакция вернется снова клиенту у нас происходит запись и так называемый в айдахо блок та самая бумажка которая позволяет быстро записывать запись в лог последовательно нам не надо искать куда нам там вставить в огромный data file это дело мы записали в блок информацию о странички и соответственно дальше мы вернули управление все хорошо если мы в какой-то момент упали мы читаем назад в райт hotlog и используя информацию о этих изменениях мы можем вот эти чистые страничке докатить до уровня вот этих вот грязных и у нас база данных снова новая это позволяет нам произвести вот то самое восстановление которое нам нужно было обеспечить исходя из проблем хранения данных которые мы обсуждали она такой схеме с квадратиками и позволяет нам соответственно восстановиться на самую последнюю транзакцию на самое последнее действие которое произошло перед тем как марь иванна вытащила сервер из розетки этот алгоритм в принципе в современном виде сделан достаточно давно то есть такая фундаментальная статья по его устройству говорит называется арей с медным про способы восстановления в реляционных базах данных взялось четвертом году опубликовано было маха нам и с тех пор в принципе теория никак особо не добавилось в это hotbox тех пор остался в red hat богом собственно говоря они все используют концепцию страничек концепцию записи изменений в лоб и лук будет по-разному называться в разных местах располагаться у морской ли он внутри на тебе у под gresso это отдельная директория которая наконец-то стала называться волн место по гаек слога версии 10 уроков это называется ряду лаги дебюту это называется волк и в принципе везде всего более-менее одинаково чтобы можно было восстановиться мы используем вол теперь важный момент еще состоит в том что было бы все это очень непроизводительно если бы он просто от начала времен писали бы этот волн бы рос и так далее мы потом очень бы долго накатывали эти изменения базу данных поэтому вот в последней инкарнации этого алгоритма имеются идея так называемых чек-поинтов периодически базы данных выполняет синхронизацию грязных страниц на диск и нам когда мы будем останавливаться можно просто только дойти до предыдущего чекпоинта все остальное уже как бы синхронизированным это так сказать замечаем до какого момента мы восстановили знаете как в компьютерной игре там люди когда и проходят они сохраняются периодически или там как пожилые люди в городе работают периодически сохраняют открывают закрывают чтобы не дай бог не пропало никуда база данных это умеет все делать внутри себя она так устроена соответственно помимо всего прочего это немножко ускоряет процесс потому что ну рано или поздно эти странички должны попасть на диск то то есть периодически надо все-таки скидывать теперь что касается доступа к данным вот эти вот самые страничке они конечно хорошее но нам нужно в каком-то более человека читаемом виде эти данные к себе получите страничке читать неудобно да там по битам это все делать это как бы ну такая вещь может кто-то любит я не очень люблю если честно хотя по количеству киева или сторож я считаю что глядя на это я считаю что многие любят и того что мы делаем мы придумаем способ доступа к этим данным как нам перейти в человека читаемый вид от низкоуровневого доступа к страничкам вот у нас есть странички на диске относящиеся к табличке такой та-а-ак таблички такой-то б это там самый простейший вариант и вот эти вот данные на диске они ничего не знают ни про какой какой таблички они относятся ничего про это знает наш оптимизатор наш экзекутор то есть тот engine в базе данных которые исполняет наш язык за про наш запрос написано нашем языке запросов ну например если мы будем традиционные вскоре рассматривать то обычно вот такая штука будет называться план запроса и например с помощью последовательного sequence of скана мы будем брать странички из таблица и из таблицы б иногда синхронно иногда по очереди зависимости от реализации и дальше накладывать на них например joint какое-то пересечение из них искать потому условию которую мы хотим и дальше с тем reasons этом который у нас был мы будем делать что-нибудь еще что мы хотим сделать там сортировать я не знаю там какие-то агрегатные функции накладывают много чего можно сделать потом мы его вернем клиенту чем это удобно но представьте себе альтернативу да вы из как он спит он а вы учитываете все это дело к себе в приложении эти таблички могут быть на самом деле огромными условия join a может исключать там 90 процентов этих данных они дальше больше будут не нужны вытаскивайте в память там соответственно ходите по ним циклами джо unity сортируйте все это дело возвращаете здесь на самом деле на каждом из этих этапов планировщик может решить как сделать выгоднее да он может например выбрать метод joy надо join и бывают просто наивные лупами можно профилировать одну таблицу присоединить к ней другую можно смешивать их и в зависимости от этого например не делать fullscreen шел сканда то есть не читайте всю табличку если вы будете делать вопреки еще не скорее всего вам придется делать целиком здесь все как бы придумано до вас и здесь на самом деле гораздо эффективнее происходит итог es que el и реляционная модель они удобны для оптимизации удобны для человека читаемого представления поэтому без языка запросов никуда на то есть смерти склеили как технологии предрекают долгие годы а как бы дедушка всегда живее всех живых и это во многом потому что на реляционной модели и с помощью es que el а проще всего производить вот эти самые оптимизации выбирать алгоритмы джойана разбираться как выгоднее достать данные хранить данные при этом все равно удобней страничками да то есть есть объектные базы данных есть графа вы и базы данных есть документ ориентированные база данных в основном это все ниши вы не универсальные продукты которые используются для каких-то своих целей потому что но просто там тупо поставить на нее там огромный объем транзакций чтобы они в универсальном виде работали это не не особо проходит до то есть scheduling транзакции которые мы рассматривали здесь на объектах выглядит гораздо сложнее у нас фактически каждая транзакция собой представляет путь по графу граф может быть очень большой для нахождения конфликтов нам нужно заниматься всякой очень тяжелой математикой на графах поэтому там проблемы с этим делом возникают поэтому не случайно столько лет господствуют вот базы данных с страничной моделью и поэтому вот оно происходит так как происходит хорошо ли это или плохо просто этот метод доказал очень большую эффективность ну и без транзакции не как на самом деле не знаю насколько я донес мысль это не донес я на всякий случай сформулирую отдельно что транзакции вопреки расхожему мнению это не способ замедлить до то есть часто считаются транзакций такой синтаксис шуга в базах данных ускорили которые просто все портит и бибикает но смысле то что замедляет на потому что там ждем блокировок можно было без них обойтись и так далее на самом деле транзакции это способ ускорения это позволяет параллельно обрабатывать больше данных без конфликтов чтоб они ни бились чтобы у нас соответственно получалось так что данные выполнялись не строго встык одна за другой операции а соответственно параллельно и можно было как бы эффективнее расходовать вычислительные ресурсы эффективнее использовать время ну и как говорил конструктор tupolev когда его обвиняли в том что он какой-то модель у кого-нибудь стянул самолета он говорил все самолеты красивые поэтому потому что так одинаково устроены чтоб летать им нужно иметь крылья и фюзеляж там хвост все базы данных на самом деле либо устроены одинаково до той или иной степени там если мы посмотрим на основные старые базу данных либо на самом деле туда идут да то есть стандартный путь появления современного новой сковиля появился на ось quelle без транзакции без блокировок без всего абсолютно не похож ни на какую база данных постепенно что мы наблюдаем постепенно там появляются блокировки постепенно там появляется какая-то схема постепенно появляется язык запросов его оптимизация что-нибудь в этом роде в некоторых даже скоро наверное появится параллелизм и это будет конечно большая победа сил разума вот на самом деле если мы посмотрим на развитие mais quel мы искали там версии 3 очень сильно отличался по дизайну внутри то есть была такая идея что мы сделаем базу данных которые ни на что не похоже чтобы она была легковес не проще легче веселей если мы посмотрим на сейчас современные там на перка на сервер на современную мария дебин на моей сколь 8 мы видим что они в значительной степени придут перенимают так сказать теоретические основы и сейчас они гораздо больше похоже на классические база данных по своему устройству вот на этом у меня более менее все если будут вопросы задавайте их я думаю что у нас есть еще на это тоска минут очень много времени давайте поблагодарим или он был очень облаке фундаментальный доклад по базам данных и у нас есть время там на на несколько вопросов что аудитория сообразить что можно задавать я думаю очень очень крутая тема честная половину вот что услышал только треть понял поднимаем руки задаем вопросы ну пока он пока аудитория думать и скажи а вот будущее в чем то есть вот мы сейчас все теоретические основы мат аппарат ну то есть я математика так понимаешь разработано два века назад для для баз данных ну и да и нет на самом деле математика она разработана ну эта математическая логика да то есть она разработана конечно очень давно но в принципе все вот эти вот работа не многие из них шли между 70 и my 90-ми годами то есть вот классическая теория транзакций она сложилась в это время сейчас если я правильно понимаю я здесь могу немножко ошибаться потому что я не теоретик я практик я работаю с базами данных а не занимаюсь теоретическим компьютер сэнсом мы кстати вот на конференции пдд и летом решили вытащить компьютер санте став чтобы они рассказали практикам что будет происходить и посмотрим получится это или нет но по моим ощущениям сейчас 2 есть направление основных люди пытаются много и успешно работает над распределенными транзакциями там не все так просто там тоже есть классические алгоритмы как ездить излагал но эти распределенные транзакции плохо работают это очень трудоемки и ресурсоемкие протокола поэтому пытаются разрабатывать распределенные транзакции без тяжелых протоколов и другой вариант уходят в всякие онтологии в вещи про то как взять большой массив данных и из них вытащить информацию без вот такого структурирования но здесь я как бы не совсем компетентен повыше это уже не совсем к базам данных относится спасибо да и а привет я вот здесь по серединке прям до приезда у есть пара вопросов первое вот и показывал модельки с транзакциями я правильно понимаю что в теории база данных использовать наш самый модель импорта тамар ность линии рисуем асти все вот это то есть ну скажем так lampard если не ошибаюсь одна из авторов всей этой теории если имеешь ввиду ламповые часы и я скорее сам а вот модель в конкурсе который используется да мне в принципе это одно из основополагающих работ но понял и второй вопрос такой более предметно это же в продолжение вопроса про будущее последние годы говорят довольно много prohor дуэт возникшему memory и вопрос связи с этим делать ли что-то разработчики современных баз данных насколько я знаю большинство коммерческих баз данных имеют рандиан дел и которые на эту тему естественно работают я много видел достаточно усилий на эту тему но как бы надо понимать что в базах данных от теоретических изысканий до внедрения этого практику проходит очень много времени по той простой причине что теория это хорошо на самом деле в банках стоят базы данных да и если пропадут деньги как бы про теорию никто слушать не будет посмотрим что из этого получится на самом деле пока что я не испытываю очень большого энтузиазма хотя это конечно хорошо от того что появятся какие-то более быстрые способы доступа к данным более быстрые способы стерилизации да то есть если мы говорим о транзакционный память и основная идея это то что мы тоже самое сможем делать быстрее если мы сможем это делать быстрее все равно придется делать какую-то обвязку поддерживать этот стороны базы данных и так далее ну хорошо я могу провести аналогию с современными источниками да то есть современные ssd-диски быстрые крутые они очень сильно упростили жизни базис там и программистам потому что очень здорово все ускорили при этом они не стали убийцами баз данных и не оправдали надежд на то что там еще составим ssd и нам не потребуется добывание потребуются база данных то есть они просто сместили 0 в другое измерение да илья здравствуйте я сделал да у меня вопрос который вы не завтра ну по теме которого не затронули в лекции ну то есть они должны были то есть мы интересно ваше отношение к такой вещи как хранимой процедуры как вы относитесь к тому что есть какая-то логика на основе языка базы данных до которое что-то делать с данными скажем так смотря как использовать да то есть можно хорошо и плохо использовать разные вещи в принципе идея делать операции с данными близко к данным это правильная идея да если мы меньше ходим до базы и эффективней используем возможность es que el а вот это вот возможности манипулирования множеством это хорошо другой вопрос что в базе данных можно засунуть такую логику от которых база данных станет плохо да ты например в под греси у нас интерпретируемый язык ppg sql и если мы делаем там какие то такие именно действия с данными по селекции лета по селекции села из одного курсора вернули обработали как-то эти данные это хорошо и удобно мы сильно сокращаем там хождение до базы это работает эффективно и понятный код получается пашу язык простой а если мы например туда засунем какой-нибудь математику вычисления чего нет на графах путем хождение циклами по каким-нибудь массивом это станет очень неэффективно надо то есть просто этот ток этого не для этого предназначена поэтому как бы я люблю все делать к нему в процедурах если как бы мне чуть надо сделать но тут надо всегда смотреть чтобы не перекладывают какие-то там серьезные вычислительные задачи туда так еще вопросы уважаемые слушатели вопросы так понимаю больше у нас а публично никто не осмеливается или спрашивать видим у всех там все развалилось а у нас есть еще один вопрос еще один вопрос передать просто микрофон в этом рядом сидите уже забрали idoc миг не слышно надрага лиц и я поэтому нужно в микрофон и вот есть какие-то бесплатные база данных есть оракул допустим зачем платить за oracal если можно взять бесплатный баз данных я тоже не понимаю зачем платить за вакуум я ее я за то что платили за по сгрыз отлично но маленький комментарии состоит в том что урока лотта высокотехнологичные база данных и для ряда задач она на самом деле хорошо предназначена дальше надо понять если у вас эта задача на то есть если сейчас уже mastercard переводит свои дата-центре на под грез потому что как бы работает их устраивает надо смотреть просто какой круг задач остался от оракула от там необходимости 200 тысячи транзакций на одном инстансе я в секунду рандомных апдейтов далеко не у всех такие задачи с огромным диапазоном задачи справляются бесплатные базы данных спасибо давайте еще раз или поблагодарим спасибо если у кого-то остались в вопросах можно задать уже в них холла более крупного эксперта по базам данных чем илья сложно представить поэтому если у вас есть вопросы я очень рекомендую до него дойти"
}