{
  "video_id": "8bdD-DqgQ1g",
  "channel": "HighLoadChannel",
  "title": "Расширение возможностей отладчика GDB при помощи Python / Михаил Ельхимов (VK, Tarantool)",
  "views": 69,
  "duration": 2977,
  "published": "2024-10-29T03:00:42-07:00",
  "text": "зовут Меня Екимов Михаил компания вкх работаю в группе в команде Тарантул и занимаюсь разбором проблем заказчиков А конкретней проблем таких которые приводят к падению и генерации корки значит для анализа этой корки мы используем отчик гдб Я надеюсь он всем хоть Как хоть как-то знаком Значит тут есть некоторые сложности Значит во-первых у нас тарантуле есть некоторые сущности с которыми неудобно работать если использовать только базовый функционал и как правило с такими сущностями работать при разборе корки Приходится постоянно и вторая такая большая проблема Не всегда наш заказчик соображениям может нам предоставить собственно корку Поэтому нам приходится отлаживать удалённо чужими руками Ну в общем тоже удобства не добавляет значит Поэтому Ну всё в общем идёт к тому что нам нужно максимально всё упрощать чтобы команд было меньше чтобы команды были проще набирать их было быстрее минимизировать В общем возможные ошибки предоставляет воши Ну в данном случае как из названия следовало это будет сделано на питоне значит и собственно вот в этом докладе я и расскажу о том как мы себе упрощали жизнь Значит у нас есть два расширения одно это такое общего назначения скажем так такое обще таран второе касается интегрирована внутрь Тарантула Значит сразу скажу что в этом докладе не будет каких-то там выдержек питоне хоть Несмотря на то что питон присутствует в названии тут скорее будут такие моменты всякие которые именно относятся к вот этой связке гдб питон какие-то особенности какие-то приго всем которые там будут потом предоставлены в принципе там куча есть примеров просто стандартно даже документации как Что пишется значит Ну начнём с первого расширения вот таким образом оно загружается После этого мы становимся счастливыми обладателями вот такого набора команд дополнительных первые пара команд это касаются я сес быстренько по ним прогусь потом более подробно касается мечка де кодировки вторая пара для упрощения работы со списками который очень широко в тарантуле используется и последняя пара для упрощения работы с вайберами по всем командам можно в гдб посмотреть Ну как это и принято в гдб если её предвари словом ключевым словом то можно посмотреть подсказку собственно это делает заходить немножко очень просто просто соответствующий клас это как это питоне она автоматом сюда вот приходит потом мы её можем видеть Так значит что у нас такое такой бинарный формат представления данных последовательности полей каждое поле Там какого-то своего типа ну как это обычно бывает там есть некий такой джентльменский набор Эх стандартных типов там бун инты флоты там строчки пустое вот плюс есть возможность расширить какими-то своими типами собственно проблема основная здесь ну как бы главная его проблема проистекает из его бинарной природы как бы посмотреть их сложит Вот пример вывода какой-то вот переменной которая место чипак она конечно прекрасна во всех отношениях но только единственное что плохо читается значит что мы сделали ну мы добавили команду ТТ МП в этом расширении Значит все команды с префиксом ТТ она умеет все вот эти базовые типы джентльменский джентльменский набор плюс некоторый набор Ну это все тарату расширения на данный момент вот там в скобках они перечислены она их тоже умеет значит и сделана интеграция с командой команда стандартная команда гдб сделана с ней интеграция Т се в скобочках написано частично я объясню более подробно ть чуть Даше на СМ сде в м заключается э чарим Вот теперь выхлоп выглядит гораздо более понятно Это если что та же самая строка тот же самый это не подлог значит по реализации собственно Ну поскольку Это новая команда Был использован механизм для создания новой команды способ расширения э ну как бы кастомизация э распечатки какого-то какого-то значения как правило э это делается Ну как бы вот этот вот принтер пишется Он такой типа специфичный ну то есть он специфичен для какого-то типа и э вот с этим Здесь э проблема если мы рассматриваем медпак потому что меж Pack который сделан в тарантуле так как он сделан он не имеет какого-то специального типа отдельного он это просто строка Ну в смысле Чар звёздочка это не как это натер а просто последовательность байт поэтому классический подход такой вот что мы написали принтер и он будет нам каждый раз включаться Когда нужно не подходит потому что он просто не знает когда нужно включаться поэтому мы тут особо не мудрствование он всё время Находится в таком в спящем состоянии неактивированном и поэтому как бы обычная команда Print ничего про него не знает Он никак не вызывается всё нормально команда вот эта ту которую мы добавили это ТМП это такая обточка Тоненькая над принтом Она сначала этот принтер сталкивает потом вызывает Принт тут он уже знает теперь что вот это вот меч Пак то есть мы ему говорим что товарищ Если увидишь строку Знай это меч Пак Давай её нормально печатай а не так как ты там обычно делаешь Вот а потом после этого засыпаем опять Ну собственно вот это вот всё делается да как я сказал чтобы там случайно потом мы строку опять не когда мы дадим ему строку чтобы он её не напечатал А сам вот этот принтер он работает так ну короче мы знаем там что мы как мы сейчас к строкам относимся поэтому мы там аккуратно это всё делаем внутри этого принтера нету Путаница со строками что строки он умеет показывать если там встречаются внутри строки Так и что я собственно Так это с этим принтером уцепился Вы можете меня спросить а я отвечу потому что ну в гдб у него есть как бы такой встроенный механизм который позволяет красиво вывести такие структурированные данные если у нас там есть какая-то не просто там может быть даже какая-то она там есть вложено какая-то в ней Внутри там какая-то ещё структура или там массив Ну вот в общем какая-то такая сложная штука есть Ну вот этот встроенный механизм в гдб Он позволяет вывести это в красивом виде даже там опциями понастроили насколько это будет красиво Вот и вот з Вот как раз пример вот этого вывода где мы там вот вот на всё на отдельных строчечку отно с отступами там всё прямо максимально наглядно собственно Вот это из-за этого я за него и уцепился что не хотелось бы изобретать ещё такой же велосипед когда есть такой удобный быстрый и со всех сторон просто приятный поэтому хотелось его использовать Ну вот собственно поэтому поэтому мы так и сделали тал значит Тарантул - это база данных плюс сервер приложений А tle - это как бы единица данных это типа такой рекорд базы данных с точки зрения как бы данных что это такое Это просто меч Пак обвешанный какими-то метаданными поэтому значит Ну это но здесь как бы есть принципиальный момент что в тарантули - это отдельная структура это то есть отдельный Тип и поэтому для него мы можем сделать прямо по-честному этот ти принтер который будет работать при вызове принта он будет всегда знать что печатать и как бы будет правильным образом его показывать А как раз внутри внутри вот этого принтера мы используем тот же самый механизм про который я только что написал Вот с этими усыпления пробуждениями там все потому что внутри мы знаем что вот одно из полей этого принтера тала это как раз вот эти меки мы его знаем что это Мек говорим Ну всё давай там активируем де активируем всё работает остальные все поля Ну как бы обычно показываются просто и всё за исключением одного тут один момент отмечен это показывает формат тала это есть такой бинарный ещё форматик внутри поля которой показывает Там в котором закодирован Такой формат тала там всякие смещения Ну в общем это Не суть важно просто он тоже такой кастомизированный и поэтому он здесь про отдельно я про него сказал значит по поводу того что задействовано были какие средства Ну вот в принципе те же самые Command Прити printer та же самая история что и с меч паком списки значит в тарантуле очень широко используются списки всевозможные э значит и значит списки эти какие это во-первых абстрактные списки написанные на си А по способу организации собственно самого вот этого самой вот этой последовательности это интрузивные списки То есть как бы у на не нода и внутри не элемент а наоборот элемент внутри него нода Ну и собственно хранится как бы получается указатель Вот на этот Якорь некий внутри то есть нода Она присутствует внутри элемента его я и называю якорем как бы за него и зацепляется как бы вот эти все элементы друг за друга потом смещение якоря соответственно х Эмен может быть ком если мы рассматриваем конкретный список то там конечно всё одинаковое это одинаковые элементы с одинаковым смещением вот такие как вот тут показаны красивые рубашечка это если требуется более скучный формат вот Ну так можно это как бы считаем однонаправленный список так я его показал просто коротенько проблемы Значит со списком проблем много тут вот прямо и для них отдельный слайд даже выделен значит Ну во-первых вот всю Вот эту вот красивую историю с рубашками внутри гдб мы видим Вот так мы не видим никаких рубашек У нас вот просто какой-то набор вешалок непонятных что на них висит мы вообще не понимаем и поэтому как бы первая проблема она связана вообще с тем чтобы как посмотреть-то собственно что там то есть у нас есть какой-то просто грубо говоря водит звёздочка А что там значит и вот это вот задачу посмотреть элемент мы как бы здесь удобно разбить на три этапа как бы три шага первый мы должны сначала выяснить Ну это я сейчас описываю базовый подход В смысле если я использую только базовый функционал гдб без расширения значит Сначала мы должны выяснить что ж за тип элементов там хранится выполняется это действие методом пристального вглядываясь для примера вот мы нашли допустим что вот у нас есть э то есть мы должны найти какой тип храним и по какому полю в этом типе ээ вот эта интрузивные список значит Ну вот в примере это Fiber Link вот в таком формате я пишу Вот fibber - это соответственно тип Ну структура да А через квадрато Вот это это поле значит второе мы вот это вот вот это вот такое удобно написанное должны перевести это сколько В сколько смещаться В байтах Ну вот самый короткий способ который приходит в голову это вот такой вот мы набираем команду прин обычную - это прин Я просто чтобы не задать ту и получаем вот такое смещение и третья которая почему-то первая Ну ладно Будем считать что это третья всё-таки уже Мы руками приводим его вот вот такой вот не замысловатой командой очень просто набираете невозможно в не ошибиться мы вот это вот красненьким помечены да вот эти вот как бы изменяемые поля задействованы в данном примере на самом деле тоже это такая в другом случае другая будет это первая проблема вот я сейчас э прошу как бы отдельно скажу вот эти три этапа Мы про них запомним три шага вот этих вот которые мы делаем потому что я на них потом сошлись Когда мы будем перейдём к уже к к тому как стало вторая проблема неудобно итерироваться итерироваться это в смысле что вот мы вот у нас есть список Мы хотим начать его смотреть вот не весь сразу вылить А вот ну потихоньку по одному элементу хотим смотреть такая прогулка по списку Вот это команда которая вот как раз смотрит следующий элемент Вот вот там красненьким выделено Next это мы должны добавить чтобы посмотреть следующий элемент если мы хотим посмотреть ещё следующий элемент мы должны добавить ещё раз Next следующую команду и так далее после там десятка команд это монстру строку Ну к тому же постоянно добавлять тоже не очень удобно и нет возможности поиска вообще никакого ну ни элемента ни какого-то подмножества ничего никаких возможной Ну вернее Так у нас есть первые два у нас Мы можем смотреть хоть и неудобные элементы и мы можем итерироваться хоть неудобно есть из этого сдует неудобно что просто я поэтому нет возможности легче про это сказать К тому же место на слайде закончилось значит что мы сделали мы сделали значит две команды первая из них это ли Ну я там кратко это показывается она как как она там вызывается е Значит она поддерживает два вида списка внутри ви с и это односвязная очередь ну это в общем не так суть важно просто вот что они два есть два разных значит интеграция присутствует с командой прин то есть уже должны понимать тогда что значит принтер для неё написан значит присут дан В некоторых случаях оно не работает про эти некоторые случаи я подробно потом остановлюсь Как именно работает механизм авто определения и когда он не работает ну сейчас пока просто вот такой обзорно значит какие опции поддерживаются мы можем явно указать прямо тип данных это вот как раз нужно для тех случаев когда Ниш могла определить э потом мы можем м показывать только какое-то подмножество выборку из всего списка так потом можем фильтрацию как бы в ортогональном направлении сделать когда мы выдаём элемент у нас там может быть Вот тот же самый файбер который в примере присутствовал там такая на пол экрана может особенно если её выдувать в очень там презентабельно формате где там на каждой строчке отдельное поле такая простыня на пол на весь экран вообще выведется А там может и Ну неинтересно всю Вот эту вот мишуру смотреть хочется что-нибудь Там сосредоточиться на чем-нибудь одном и как бы вот есть есть возможность задать что мне показывайте только вот это вот не надо мне вот это ваше всё и можно задать направление обхода Ну разумеется это только для двусвязного списка работает вторая да е важный момент не поддерживаются вложенные спис есть у на есть внутри него Ну в смысле у нас есть список из элементов внутри этого элемента есть ещ какой-то список вот он не будет прямо вот разворачиваться Вот вот вот в такую То есть это покажется прямо как ну стандартно базовым базовым так сказать Прити принтером покажется вот эта нода которая там в случае двусвязного списка покажет что вот указатель на следующий такой-то указатель предыдущий такой-то А в случае там какой-нибудь очереди вот этой односвязной она вообще скажет следующая такая вот и всё как бы не будет ничего Ну это как бы не то чтобы очень прям принципиальный момент Но всё равно это как бы усложняет а на практике это не особо нужно то есть если нужно когда-то посмотреть какой-то вот там внутренний Ну просто проще его прямо и посмотреть Так теперь вторая команда специальная отдельная команда сделана для того чтобы вот делать итерацию по спискам она Ну это короче тот же самый лист только что называется вид сбоку это просто он выдаёт тот же самый результат просто порциями по одному элементу все опции которые были про лист они подходят И сюда тоже то есть мы можем итерироваться только там например по какому-то под множеству Ну или вообще там как-то задать так чтобы только один элемент оставался так с начал тогда добавлю ещё что единственная опция которая у него уникальна - это вот начать прогулку заново Ну иногда надо бывает что это заново бывает полезно А самое главное Вот оно шло здесь вторым пунктом это удобная прогулка удобное здесь в том смысле что ну как бы нам не нужно нужно сделать минимум действий для того чтобы посмотреть следующий элемент нам нужно нажать клавишу Enter тогда выполнится по правилам гдб предыдущая команда Ну если команда соответствующем образом написано и вот это лист Вок написан Так что он в этом случае просто будет следующие элементы выдавать и такой сравнительный слайд я тут вот зачёркнуто это то как было та коне для наглядности значит просмотр элементов Вот сейчас как раз я напомню про те три шага про которые я говорил что вот про которые я просил запомнить значит вот эти две команды которые не зачёркнутые нижние значит Первая команда это не так что было три стало две Ну как бы не сильно там улучшили А это просто два разных варианта Ну два разных случая скажем так первый случай - это удачный это тогда когда у нас сработало автоопределение Вот и перечёркнутые цифры 1 2 3 Это значит что нам не нужно делать ни один из шагов мы просто указываем список И всё И он нам его печатает Ни там вообще больше ничего не делаем второй случай - это такой неудачный это когда автоопределение не сработало ещё раз я когда оно не срабатывает скажу вот буквально по-моему на следующем слайде там будет подробно разобрано В общем В каких случаях оно может не сработать здесь мы задаём явно вот это вот мину E fiberlink это вот как раз мы явно задаём говорим вот такой там элемент лежит вот по такому смещению и вот здесь вот в скобочках зачёркнуто только 2 и3 вот сост первый шаг это вот тот самый шаг который про который я говорил что методом пристального вглядываюсь команда но главное е бы преимущество конечно состоит не в том что она стала в два раза Короче это просто для условно говоря этого случая это ну основное не в этом основное в том что для того чтобы если здесь написал бы просмотр пяти элементов последовательно то разница была бы более очевидна потому что предыдущая команда надо было бы всё время дописывать дописывать дописывать А эту просто один раз ввели а потом просто топчим на Enter и всё и он выдаёт вот эти все элементы ну плюс Конечно мы здесь можем какие-то добавить опции там если мы хотим как-то допустим сузить нашу выборку и поиск теперь есть поиск тут нет перечёркнут разных варианта вот показал задаётся опции Вот предикат и в предикат мы пишем в Дика используется тот же самый синтаксис который используется ВБ в брейкпоинт Ну conditional брейкпоинты вот то есть мы можем здесь дать некое условие которое проверяется на соответствие три вот этих вот красных слова - это холдеры Они сделаны по тому же принципу по которым там переменные в gdb делаются только здесь вот они вот эти вот заняты это entry Index item значит entry - это собственно уже приведённый элемент тип элемент то есть с ним я могу работать как будто Вот это в данном случае это Фабер вот я с ним работаю как с фай бем То есть у фабера есть например поле fid это его идентификатор Я вот говорю что вот оно должно быть 101 то есть по идее Вот первый вот этот элемент если такой Фабер есть он должен выдать один элемент Ну либо вообще ни одного Если такого фабера нет следующий индекс - это ну порядковый номер в списке соответственно вот этот вот вот э вот вторая команда она там первые пять напечатает а последнее - это it ам - это вот этот Якорь вот этот самый который даже не надо приводить к типу ну этот скорее он для общности что ли добавлен Не то чтобы он прям такой вот прямо в нём необходимость была Ну например можно придумать что вот я знаю что у меня в списке хранятся где-нибудь в регионах я там выделял там элементы где-то Я говорю а вот вот хочу выдать чтобы в списке только те элементы которые в регионе в таком Ну я знаю там допустим по памяти где он сидит и вот могу например с помощью этого айма задать такое условие я могу это и с помощью entry задать но если у меня Не сработает автоопределение триде работать не будет а этим будет работать всегда поэтому Ну вот такой юзкейс например так реализация Значит м вообще что умеет видеть для начала Что умеет видеть гдб от этого пойдём Какие возможности вообще у нас есть вот два вывода два я сделаю два принта и вот красненьким выделено что когда я печатаю например когда я печатаю указатель прошу мне вывести он в угловых скобочках в конце вот Красном выделено печатает имя переменной То есть он вот напечатал вот этот engin не потому что я сказал Напечатай мне адрес engin и он пишет там если бы даже я просто напечатал вот этот адрес он бы его там ВС равно напечатал Он хранит мапу у себя глобальных переменных статических переменных и даже ещё ну как бы развивая вот эту тему во второй команде он может если он хранит адрес какой-то переменной которая там сложная у него поля есть и я говорю а дай мне вот это поле он понимает что вот где-то есть перемен он со смещением может показать То есть он может Вот вот Main Cord например вот я печатаю такую штуку C the life Ну нету такой переменный которые соответствуют там какой-нибудь глобальной переменной который ссылается вот на кор пт и Life но есть Корд ПТ допустим и тогда он у него есть некий диапазон смещений при которых он может это определить и тогда он этот показывает в таком виде он говорит Вот это переменная такая-то со смещением таким-то вот что это такое Вот это смещение это обратный переход в человекочитаемый У нас есть вообще в кодовой базе соста две мапы обе мапы как бы содержат Ну первая мапа это как раз онат вот такая переменная в м хра вот такие тип есть по всем перем какое-то количество перемен мы смотрим Вот это переменно мы осуществляем вот этот шаг один который я когда-то упоминал метод пристального выглядывая во весь код Ну не во весь код а в те местах где используются вот эти листы и вычисляем для такой переменной вот такой тип хранится для такой вот такой Составляем такую мапу и Точно такую же мапу ну похожему принципу вот для вот этого второго случая когда мы берм у нас есть в структуре какое-то поле мы знаем что это лист и мы знаем что в этот лист все вот такие такую же тоже штуку создаём после этого Как работает определение данных значит там есть три варианта Первый самый такой бы ну как удачный В каком-то смысле если это сработает Когда мы это именно работает то есть это сработает даже в команде прин если если оно сработает оно будет работать Даже там то есть мы вот говорим нача и вот если копт есть указатель такой В смысле Ну разворачивается в то она как бы печатается тут такой момент раз мы печатаем то используется Print а Print работает так вот это всё выражение оно сначала парси вот GB это вот одна из функций нох кото доступ расширени и превращает это ВС в gdb вот это вот сложная Сложная вот эта вот структура копт стрелочка там ала что-то оно всё пропадает У нас есть просто значение в этот момент и наш код Вот это кастомизация наша он начинает работать вот именно с этого значения у него он не знает ничего про вот эту выражение ко P Life он может выцепить только то что в пря хранится а там просто хранится условно говоря что это за лист непонятно вот если на него есть ссылка вот Ну в данном случае это будет Main c там п 112 вот тогда он тогда он вычислит Main c - это такая глобальная переменная а Корд ПТ - это указатель просто и вот он может указывать на какой-то другой Корд вот в данном случае если он указывает на это то всё хорошо он его распознает второй случай - это когда мы используем тут наш код начинает работать чуть раньше он начинает работать когда у нас есть ещ ВС Вот это выражение и поэтому у нас есть больше информации мы можем из него Прямо выцепить даже если на него нету ссылки какой-то мы просто смотрим кор ПТ знаем Какой это Тип и вот мы так и получаем Вот это выражение и если уже всё это не сработало Ну тогда явно указа самые это Прити принтер Прити принтер используется вот для этих двух типов листов один один и тот же там только вот питоне и генератор подставляет там Единственное чем они различаются как достаётся следующее значение следующее следующее поэтому там используется просто питоне генератор там один там другой а вся остальная вот эта вот машинерия она вся та же самая поэтому один Прити принтер и этот же принтер для прогулки и чтобы всё вот это вот дело работало нормально и умело и так и так оно конфигурируется таким глобальным состоянием глобальное состояние это сделано прмо через переменные вот этого переменные Класс вот этого Прити принтера Так теперь файберы Значит файберы у нас независимые рутины независимые в том смысле что значит во-первых это они могут прерываться во-вторых управление с них может передаваться в произвольном этим произвольным образом не там нет такого что например только на ту из которой был вызван А вообще на любую у каждой из них есть свой стек Ну платформы у нас поддерживается две и онова это две команды первая такая информативная работает Аналогично этим потоком командам inf fibers просто выдаёт некой са по всем фарам которые есть вторая про стек вызовов Значит у нас проблема такая что вот у нас корка случилась мы смотрим и мы видим стек только того фабера на котором она случилось Ну в принципе этого в большинстве случаев Может достаточно но иногда надо тоже посмотреть то сложно нереально В общем в в какой-то версии могу немножко ошибаться вот очень давно Появилась возможность кастомизировать этодин Вот и команда умеет это делать Она переключает на СТК и дальше после этого работают Вот как и с фреймами тоже вот Аналогично если переключить на ой не фреймами а с единственное тут Большая разница у потока управления не передаётся регистры не меняются Вот именно меняется только неко такое внутреннее состояние которое потом влияет на размотка стека и вот это IP который используется Фрей фильт там упомянут это он нужен для того чтобы там механизм так размотке устроен что начало всё равно начинается с текущего состояния а там в текущем состоянии Ну регистры они как бы соответствуют текущему фай беру они такого как Кому мы можем посмотреть они уже начинают и первый фрейм нам выдаётся на основе этих регистров он явно не тот и мы его отсекаем вот этим фрейм фильтром теперь Т Аналогично активируем счастливые обладатели вот такого набора команд значит и можно л посмотреть по-любому значит первые там пару команд описывают состояние Первая команда LG Arch она описывает некое такое статическое состояние собственно нам понять А что с чем мы имеем Ну что у нас за вообще вот система это такая здесь некоторые значимые для нас флаги то есть ну они не меняются это вот такой статическое состояние Это просто как бы второй динамической это собственно состояние вот этой виртуальной машины сейчас Ну вот тоже это там оно из трёх составных стоит тоже не буду здесь На них особо там долго останавливаться Да здесь упомяну только что вот это jit в названии оно не надо про него ничего специфичного про него не будет оно здесь нужно просто для того чтобы показать что конкретно Какая реализация лу машины у нас используется в файбер всё дто ничего тут в этом как бы в расширении нету житово специфического значит там есть объекты уло машине и часто довольно они складываются в такие специальные слоты контейнеры Вот это T value он занимает 8 байт если объект в него помещается его Он может хранить прямо в нём Inline Если нет то указателем на какой-то внешний объект значит вот это команда есть lgt которая позволяет посмотреть что там в нём лежит и вот например варианты пусто Булин число строка и таблица и вот красненьким отмечены как раз те случаи вот эти два последних они не помещаются в нём и красненький Вот это адресок это вот действительно где он действительно хранится этот объект значит для вот этих двух видов для строки для таблиц есть отдельные команды которые позволяют поподробнее про него посмотреть что ж там вот про строку можем Ну тут не сильно много подробностей но вот зато про таблицу подробностей гораздо больше гостевой стек значит байд вот когда выполняется он всегда выполняется в рамках какой-то рутины Ну не какой-то одной Ну разных но вот если уж выполняется то это значит что мы находимся в рамках какой-то вот рутины у каждой у каждой рутины лу есть свой стек который как бы состоит из слотов и команда вызовов астек данных там есть слоты с данными вот которы которыми на предыдущих слайдах смотрели Там строки таблицы ВС такое числа есть ещё специальные слоты фреймы по ним вот Гля Это выбрал самый простой выхлоп просто чтобы он поместился Обычно он гораздо больше И там есть вот этих вот этих может быть несколько фреймов и поним последня Значит у нас есть Garbage колектор в жите там используется Mark алгоритм который ещё К тому же итеративный позволяет посмотреть такую общую статистику где там кто Находится на каком на каком этих На каких стадиях объектах этого ну как бы так немного не хватает хотелось бы вот но этого сейчас ещё нет но вот что находится в в процессе реализации значит во-первых такой виртуальный прогон полного цикла сборщика Это позволяет Ну если мы вот прогнали но у нас тем не менее всё равно осталось много объектов Ну какое-то подозрение что что-то утекает где-то здесь вообще вот всё Мы вторгаясь предположение только что Ну поскольку у нас нету другой информации Ну мы пользуемся хотя бы этим пытаемся точнее мы хотим сделать так чтобы мы могли этим воспользоваться Значит потом нужна более деталь статистика не только просто сколько их там штук А какие именно по типам всё вот это даже и по размерам даже Для более сложных типов он там размеры таблиц длина строк всё это и такую предоставить возможность чтобы по любому объекту находить А откуда же он кто на него держит ссылку вот эту до корня В общем в совокупности всё вот это рассчитываем мы что в каких-то случаях при утечки возможно даст подсказку куда ткнуть Ну подсказать этому допустим заказчику А посмотрите-ка у вас там что-то вот вот там-то вот ссылки те которые использованы здесь список вопросов которые ну здесь Вопросы больше такие кулуарно формата Поэтому если Ну сейчас Сейчас вряд ли будете задавать А вот что-то по докладу если с удовольствием отвечу Давайте же поблагодарим докладчика за его прекрасный доклад и как уже было сказано вот вопросы для возможных дискуссий Но если у вас есть не кулуарный вопросы то докладчик ваш и ваши вопросы поднимайте руки к вам принесут микрофон вот у нас есть Первые вопросы да Привет Большое спасибо за доклад там в части когда ты говорил про списки ты сказал что вы как бы дополнительно строите мапу из адресов списков их тип Откуда вы берте информацию это как бы информация специфична для она не автоматом делается это вот прямо Мы садимся и хардко её всё вы хардко вот вот эта мапа она Да ну то есть там есть конечно желание автоматизировать но оно такое прям там чревато такими трудозатратами что пока это всё вот вот в таком режиме находится опять же если Ну это не настолько критично в том смысле что если мы допустим у нас появился какой-то лист и мы его не отразили Вот в этой мапе в внутри То есть у нас в коде он появился Ну мы забыли Там про него Ну ничего тогда он просто не будет определяться и всё ну как бы он ничего не порушив ничего Потом когда-нибудь добавим поднят спасибо спасибо Следующий вопрос вот у нас в центре Спасибо за доклад Миш У меня вопрос про ТТ вок там где у тебя обход по списку тебе приходится где-то хранить текущее положение правильно да Для этого использованы какие-то внутренние вот средства расширения гдб то есть Каким образом текущее место прикапывать потому что потому что вот когда их несколько Next Next Next Next Первая же идея что давай Next прикопать нет гдб ничего не используется просто питоне состояние такое Ну то есть мы как бы просто скажем так если прямо в детали у нас же всё это делается Вот этим Прити принтером А у Прити принтера есть такая ну как его функция которая этих чинов выдаёт и мы можем как бы помнить просто Что у нас текущий Вот такой-то и каждый раз И что мы находимся в режиме прогулки именно а не выдачи всего и когда мы говорим типа ну давай нам дальше он говорит А я в режиме прогулки Ну тогда тебе один вот дам я знаю где я нахожусь и как бы его его и даю и как бы сдвигаются на следующий в следующий раз я опять ей говорю давай Она говорит ну на тебе вот этот вот то есть это ничего гдш не используется это просто ну в питоне как бы питоне состояние Спасибо большое за доклад у меня такой вопрос расширение гдб не рассчитаны только на конкретную версию продукта или есть закладки на структур для разных версий то есть есть Като какая-то поддержка версия Нет ну как бы он такой глобальный на всё там есть отдельные моменты когда вот эти происходили там изменения чувствительные для этих заст СТК то это нужно отдельно там как бы обрабатывать Отдельно Ну Быть готовым к этому и там к этому Мы готовы Ну то есть там например какое-то поле появилось или какие-то поменялись поля мы можем посмотреть Если у нас есть такие поля Ну мы знаем что вот вот есть такая проблема в тех местах где мы именно закладываем на какие-то конкретные поля вот нам важны они в тех местах мы аккуратно стараемся типа сначала спросить если оно есть то так если его нет то мы понимаем что значит вот там используем некое своё тайное знание и то есть она работает на все это как бы не привязано к версии оно как бы такое то есть соломки подложили да Ну да СБО спасибо если у вас ещё есть вопросы поднимайте руку первый ряд да спасибо за доклад думали ли вы о том чтобы например не писать плагины а прям гдб и был ли бы какой-нибудь от этого Профит типа больше можно было бы глубже в объекты залазить что-нибудь такое затрудняюсь сказать Ну как бы вот в моменте пока когда писали у меня ни разу не возникало ощущения такого что блин было бы проще написать там всё всё заново Ну всю систему ну нет такого не было я как бы больше это расширял вот этот функционал пытался то есть нет каких-то ограничений со стороны вот этих плагинов питонов ских Нет ну ограничения есть то есть гдб предоставляет некоторые IP и иногда его ну как бы так тесновато с ним но может быть это просто было не настолько критично что прям вот во Ну что-то что-то ну прям такое базовое можно было сделать этого хватало то есть не нужно было прям там как бы чтобы ещё чуть-чуть улучшить надо прям ещё упа аться вот поэтому в этом смысле Ну мы остановились где-то Ну что позволяет то позволяет может быть конечно не весь потенциал реализован То есть я тут не могу сказать что я там настолько тут всё прямо постиг Дао вот этого гдб что всё точно ничего лучше сделать невозможно Ну по крайней мере в тех в тех объёмах которые нам нужно Ну вполне Мне хватает Спасибо Спасибо ещё вопросы вот у нас вопрос Привет Спасибо за доклад и у меня такой вопрос Вот вы после принта получаете всю эту красивую все эти красивые данные А что вы дальше с ними делаете ну смотрим на них и что-то Делаем какие-то выводы ну то есть мы Для чего мы смотрим Что например в данный момент там находилось Ну там не знаю стек У нас есть какой-то вызовов мы смотрим а у нас упало что-то чего вот оно упало смотрим например думаем Может у нас указатель нулевой не смотрим не нулевой А что же там тогда хранится такой например чтобы ну мы там понимаем что где-то вот там внутри что-то произошло ну выдаём смотрим и как бы Делаем какие-то выводы ну то есть это уже такая ручная работа в смысле Спасибо И ещё вопрос А я правильно понимаю что информацию о типах Вы всю хардко будете внутри этого расширения или вы доступа ете которые вот про мапы про которые А ну вообще о типах структур Там и так далее Потому что ну там видимо какую-то часть гдб вы цепляет из тиба анфо а со своей стороны вы как это может быть я не уверен что понял до конца вопрос Мы храним вот Хард кодим мы вот что-то относящееся к типам это вот только вот эти две мапы Ну то есть в гдб есть система типов Мы можем по лью да можем понять какого оно типа но в случае листа как бы этого недостаточно потому что это абстрактная штука нам нужно как бы или я не в ту сторону пошёл Ну я понимаю нет ну лист понятно там а вот саму информацию о самом типе Вы из гдб берёте да то есть не вы не не доступа ете ни до какой информации Кроме того что вам выдаёт гдб или вы как-то или вы как-то её со вы просто так обронили фразу что мы собираем там мы анализируем кодо базу и кодо базу вы анализирует когда это когда пишем вот этот вот расширение а то есть ну то есть мы это мы делаем для того чтобы А а как вы Как вы потом ээ Ну вы поменяли что-то или Ну вот вам надо вам надо синхронизировать тут есть такой тредо да то есть мы да Нам нужно следить за за синком между исходниками Ну между исходным кодом и вот этим расширением Да вы думаете что-то как-то может улучшить можно в этом плане Ну вот я как раз про это говорил что хотелось бы это автоматизировать но как бы попытки как бы на ску решить эту задачу они как бы привели к тому что ну как осознанию того что ну это довольно-таки там чревато такими дополнительными сложностями и Ну пока это находится вот в таком в стадии ручного ручной синхронизации Ну то есть хотелось бы Да хотелось бы сделать это автоматически но пока не получается В каком направлении вы хотя бы думаете позволю себе в этом месте прервать эту дискуссию чтобы здесь была некоторая интрига но предлагаю продолжить её в кулуарах А сейчас я предлагаю поблагодарить спикера за его прекрасный доклад Спасибо А мы же со спикером нет нет не надо убегать ещё рано А мы же со спикером Хотим поблагодарить вас за ваше внимание и за ваши вопросы и нам необходимо выбрать Лучшие из них так не напом так сейчас я вот молодой человек вопрос Какой задали сечас нарга Ну вот мне вот этот вопрос как раз первый был да поднимите руку чтобы вас могли найти хелперы и принести вам подарок ваш вопрос и у нас есть ещё один вопрос который мы хотим выбрать второй вопрос про эти про общие печать про обю поднимите пожалуйста руку что Серёга нет про поддержку всех версий что версия поддерживается всех рение Благодарю вас всех за то что пришли благодарим нашего докладчика за его за его доклад вас за ваши вопросы"
}