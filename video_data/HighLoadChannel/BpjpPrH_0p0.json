{
  "video_id": "BpjpPrH_0p0",
  "channel": "HighLoadChannel",
  "title": "vert.x против классической многопоточности в JVM / Владимир Красильщик (Независимый эксперт)",
  "views": 2992,
  "duration": 2571,
  "published": "2020-04-27T12:22:01-07:00",
  "text": "всем привет добрый день здравствуйте . просто рад вас видеть владимир красильщик я прагматичный java программист из города санкт-петербурга более 15 лет профессионально разрабатываю программное обеспечение в разных предметных областях в разных компаниях обычно я рассказываю про java и про тема которые как-то связаны с джавой давайте немножечко познакомимся немножко поднимаем руки скажите пожалуйста есть ли в зале совершенно случайно программиста полный зал рук отлично вы пользуетесь многопоточность you на каждодневной основе кто пользуется многопоточность you from пишите многопоточной программой фантастически а java программиста есть те кто пишет на всевозможные ох абалденно и вы тоже пользуетесь многопоточности джавида очень много людей значит примерно три четверти людей пользуются многопоточности джори и наверно больше 50 процентов конкор настя классно это будет горячий доклад тогда вы наверно знаете об очевидных плюсов java.com карен si nu первый плюс это то что стандарт стандарт это хорошо во вторых за много лет существования java can can see правда работает мы про это знаем и действительно работает на всех платформах под которой есть ну уже все баги нашлись вот и начиная с java 15 есть появился потрясающие у нас пакет java itil конкуренты там есть классная высокоуровневые примитивы и вроде очень приятный такой api но у java.com карте есть некоторые минусы во первых чтобы программировать на примете вах вот такого рода все-таки нужно обладать высокой квалификации это довольно сложная тема почему эта тема сложная потому что обычная ситуация такая никак в этом зале обычно люди очень мало занимаются своей работе java конкуренты в основном разрабатывает enterprise в котором все вопросы многопоточности вынесены в фреймворке которыми мы пользуемся вот а во вторых начать даже пакет новый с классными примитивами даже им пользоваться довольно сложно опять же это говорить просто о том что люди мало занимаются именно непосредственно кодирование многопоточных приложи и мы в основном все-таки пилим кровавый enterprise и есть некоторые стандартные проблемы про которые вы наверняка знаете ну дидло кирилла и блоки до 2 потока либо затыкаются и ничего не делают не приносит пользы либо бешено молотит процессор и этом тоже не приносит никакой пользы второе это то что наш хороший код которым протестировали в девелопменте в state женге в тестинге который хорошо работал с точки зрения производительности попадает на продакшен там другое окружение там другие сервера операционки так далее и вся вот эта синхронизация становится горячее нас там появляется проблема производительности мы конечно решаем у нас есть приоритеты нас есть тонны все но мы сталкиваемся с тем что некоторые потоки голодают происходит инверсия приоритетов и вообще говоря есть проблема того что потоки java если их специально не делать честными они не честны кто понимает что такое честность справедливость в потоках я скажу для тех кто не поднял руку идея в том что тот вообще в жизни кто первый встал того и тапки вот java can can set не так вот и это нормально теперь вот реально проблема с которой невозможно смириться это то что многопоточный кот очень сложно рефакторинг нельзя просто так взять один объект стать другой объект и агрегировать composer овать в какой то есть ты можешь перенести во время перемещения методов какие то значит защищенные секция и код работает совершенно по другому то есть теряется вообще говоря о у п в этот момент полностью ты просто оказываешься каким то ну не знаю ну в общем руки опускаются ну и так как я сказал на самом деле многопоточный код по-настоящему тестирует столько вроде это очень сложно для java программистов поэтому есть альтернативы альтернатива разного характера если он artego которые предлагают нам решение на языковом уровне на уровне смены парадигмы на уровне вообще говоря откупа типа вот вам типа железо давайте мы с вами вы с вами там на уровне железо решайте давайте работать с памятью как с транзакциями базе данных вот значит есть всякие подходы которые связаны с тем что ну принципе давайте короче говоря работают не с настоящими потоками с такими будем сами эмулировать потоки внутри не то чтобы совсем зеленые потоки будем в какой-то момент и в программе морозить состоянии потоков восстанавливать с нами это нам позволит не не сталкиваться с проблемами того что потоки управляются на самом деле операционка ниже вот но есть теория который нам говорит о вот коммуницируя щих процессах древние стары и есть модель актара фактор моду actor мотал это очень простая модель в ней есть актеры действующие лица у них есть состояние этих актеров когда они хотят пообщаться с друг с другом они просто шлют друг другу письмо на почтовый ящик который с ним ассоциирован . принципе больше там ничего нету ну там еще актеры могут поражать других актеров как в жизни но это принципе все теперь если мы посмотрим на спецификацию джалла memory module это вот такая вот книжка и еще много много книжек которые объясняют что там написано и людей которые зарабатывать на этом деньги ездят на конференции есть vertex не то чтобы он единственный кто реализовывает java модель actor модель джаве здесь другие варианты но есть vertex у него и в его айпи такой подобен actor модели то есть на нем можно строить модель акторов он позволяет забыть про все что связано с синхронизацией и пакетом java itil конкурент он полиглот ный то есть он изначально задумывался с ним чтобы любочка который пишет под живым на любом языке мог взять его open поддерживается большинство живем совместим их языков языков он прям создан для хайло да я покажу чуть позже почему и он реактивный давайте поговорим про реактор но нет другой что такое реактор кто знает очень что такой реактор реактор отлично рассказываю знают примерно чуть меньше десяти процентов поэтому рассказываю реакторы такой подход программирования с одной стороны у нас есть программа строится так есть каналы по каналам приходит события все мы можем на события приходящий по каждому каналу написать обработчики и такса быть этих событий все дальше когда к нам приходит события определенного типа мы с моим а нет ли у нас обработчика соответствующего типа если он есть мы берем события наберем обработчик и передаем в единственное существующим нашем приложении ну не совсем ну будем гореть так прикладной поток который называется иван клуб event клуб это поток он вечно живой он никогда не меняет своих состояний берет кндр берет события обрабатывает и дальше ждет следующих январе следующего события все vertex реализован подход который называется мульти реактор имеется ввиду что что у нас несколько event лупов это значит что мы можем быстрее обрабатывать потоки обрабатывать события и это значит что мы можем утилизировать все ядра той машину на который бежит в vertex в отличие от 1 по точной модели которая например утилизируется в но джейси да вот же с куда не посади да вот вот именно конкретно этот процесс будет утилизировать одно ядро нехорошо мы хотим хай лот вот where такси можно делать хай лот верность каком-то смысле похож на но джесс и был инспирированы джессом соответственно что такое vertex vertex это штука во первых получается с левой стороны то что уметь захватывать события по различным каналам справа это наши обработчики событий упакованы е.в. внешне что называется vertical вот и пачка иван клуппов и теперь значит почему можно не использовать синхронизацию или чего нам почему нам можно забыть о java you tell конкурент потому что vertex предоставляет очень четкую гарантию обработчики из одного и того же вертикала всегда будут обрабатываться в одном и том же потоке . это значит что мы ничего не шарим нам не нужно защищать наше состояние мы спокойно пользуемся обычными списками отличными мамами обычными объектами у нас нету гонок таким образом основные понятия секса следующее у нас есть актеры в vertex ли они называется верте кроме версии коммуницируют друг с другом посредством передачи сообщений по к нему коммуникационной шине которая называется в and bass значит давайте покажу кусочки кода который потом уже увидим в программе значит как мы получаем сообщение верности мы говорим vertex значит давай мне твою коммуникационную шину я хочу подписаться на события которое будут приходить по очереди с названием топик ним в тот момент когда события приходит дергай меня пожалуйста за вот этот вложенный хендлер и есть возможность в конце обработки этого сообщения ответить тому кто это сообщение послал при помощи метода реплей обращаю внимание что методы все которые здесь есть они не блокирующие и асинхронно это значит что мы асинхронно в не блокирующим режиме подписываемся на очередь в асинхронном режиме к нам приходит callback который нас дергать за вот это место логан фойе так далее и точно так же в асинхронном режиме мы отвечаем тому кто там прислал сообщение потоки не блокируются как мы посылаем сообщением vertex давай мне твой коммуникационную шину хочу послать сообщение на очередь с именем топик ним и когда тот чувак получит мое сообщение и ответит мне там реплей дерни меня пожалуйста за вот такой хендлер все происходит асинхронно вне блокирующим режиме третья часть это как создать отложенную задачу есть такой код вот vertex создай просто таймер и запустить некоторые задачи через некоторое время на самом деле никакого таймера смысле потока здесь не не создается там работает магия нити теперь я хочу показать вам несколько классических задач на многопоточность мы посмотрим как это решается в стандартные джаве ну как вариант и посмотрим как это решается в верх такси и начну я с классической задачи производителей и потребителей вот вкратце у нас есть грубо говоря производители булок нас есть те кто кушают булки вот мы бы хотели производить булки кушать булки и мы хотели бы минимизировать время которое простаивать оба оба потока до соответственно для этих целей мы помещаем между пекарем и тех тем кто кушает эти булки буфер да таким образом пытаясь как бы нивелировать то что скажем так производства булок может занимать больше времени чем поедание буллок и наоборот вот давайте откроем коду значит первое решение стандартная как вида на задних рядах до попробуем вот так сделать принтер мод не очень мне нравится смотрите фактически мы запускаем в обычным в обычной джаве два потока тот поток который будет производить булки и придать вот значит вся магия заключается в чем мы это делаем в бесконечном цикле вот в качестве буфера мы используем стандартный классный примитив из модного пакета связано блокирующего вот магия очередь вручается в том что если поток который потребляет булки приходят в этом ничего нет поток засыпает аналогично с другой стороны производитель бутылок по ним когда он приходит в очередь и там нету свободного места он тоже засыпает что мы сделаем мы запустим два потока потом и жестко вырубим нашу наше приложение через 10 секунд соберем какую-то метрику да вот допустим без секунд подождем это 10 секунд уже давно как должна была закончиться вот посмотрим на некоторую статистику значит вот за 10 секунд в данном режиме нам удалось потребить 433 булки и произвести вот столько-то но это ни о чем не говорит в абсолютных значениях эти запилим этот об и посмотрим на решение на wear такси собственно программы на вертексы выглядит следующим образом давайте создадим vertex в этом в этом месте создается просто instance нашего вверх vertex а в которой можно позже за деплоить те акторы или те вертел и которые мы бы хотели чтобы участвую в нашей системе мы производим три актера это собственно потребитель буллок производитель и вот тот самый буфер значит но производители и потребители давайте посмотрим на производить на потребителей потребитель собственно говоря делает очень просто он ждет булок который будет приходить на очередь consumption после этого он будет эмулировать поедание булки крутясь в в таком живом цикле некоторое время после этого отвечать и пауки я типа съел можно следующим производитель делает примерно то же самое значит он отсылает сообщение уже на другую очередь обратите внимание вот и ждет пока от ему поступит ответ о том что можно производить следующую букву в этом случае он значит scheduled следующие производства булки через некоторое случайное время вот и поэтому самое интересно что у нас здесь происходит это сам буфер который принимает сообщение со дна очереди и отправляет другую и регулирует собственно буфер самостоятельно при помощи обычного связанного списка обратите внимание никаких импорт of пакета con carne тут нету собственно он получает булку если значит если можно переправляет выдачи если нет сохраняет во внутреннюю во внутреннюю внутри очередь все все очень просто давайте запустим все то же самое мы вырубаем через 10 секунд этот процесс и смотрим на статистику пока процесс бежит что у нас здесь происходит размер буфера пять элементов бежим и 10 секунд время для поедания булки в среднем в два раза больше чем время производства но с тем чтобы как раз имитировать этот процесс заполнения буфера смотрим на статистику значит 482 на 486 против 433 39в в случае обычного обычных потоков значит вот это конечно не является официально каким-то замерами производительность я и не собирался делать каких-то замеров все сильно замешаны о том что за железо собственно параметры вот эти все размеры буфер и так далее в этом случае все подбирается очень индивидуально под конкретную целевую систему массового обслуживания да вот но конкретно в этом случае vertex показывает чуть чуть лучшие результаты следующая задача которых хочу показать я очень хочу показать точно так же классическая эта задача о читателях и писателях до представим себе базу данных в нее кто-то ходит читать кто-то хочет входит писать ну и соответственно если кто-то хочет писать нужно сделать что нужно дождаться пока все читатели уйдут из базы дальше испортить данные при этом других писателей не писать не пропускать чтобы не испортить данные как-то совсем ужасно да вот поэтому это здесь указано что это приоритет писателя вот наши замечательные классный джаве есть прям готовый примитив которые бери использую как называется примитив для такой решить такую задачу да и тори драть лог вот прямо специально прям все при для нас значит решение здесь очень простое запускаем несколько читателей запускаем несколько писателей при помощи каунта онлайн чем их одновременно стартуем далее мы им всем передаем ри драть лак собственно они его берут давайте читать или это собственно берет ту часть которой озарит отвечает пытается взять если не получается здесь он замораживается потом отмораживает и идет начнет читать данные писатель соответственно делать то же самое но с той частью ритуала к которой за запись отвечает пытается взять если не получается то замораживать вот все давайте запустим это дело все то же самое 10 секунд это дело будет работать параметры у нас вот такие значит читатели у нас в четыре раза больше писателей время записи примерно в 4 раза в среднем в 4 раза больше чем чтение то логично в среднем потому что на самом деле в программе она такой случайное на этот вот максимум который мы будем получать из случайного генератора значит результаты у нас такие примерно 300 к двумстам ну то есть вот это соотношение один к 16 примерно выдержан а потому что у нас четыре раза больше читателей и запись среднем занимает 4 она примерно вот 116 и есть получается зафиксируем этот результат вот разберем теперь решения на вер такси собственно мы создаём систему vertex а диплом туда дипломе туда читателей диплом туда писатели и диплом туда не что что будет их координировать некий медиатор как выглядит читатель собственно читатель это просто vertical vertical в java реализуется посредством значит расширение базового класса абстрактного abstract апстрак vertical вот он здесь значит собственно что делает что читатель что писатель они пытаются оба послать на некоторую очередь который называется access пьем послать запрос типа я хочу почитать или я хочу пописать если запрос на запросам приходит положительный ответ их дёргают за вот этот хендлер в котором они имитируют бурную деятельность какое то время после чего отправляет на ту же очередь запрос о том что окей мы поработали отпусти лог все это происходит в асинхронном не блокирующим режиме поэтому здесь в общем то самое интересное то посмотреть на наш медиатор который в общем то но фактически это реализация не блокирующего ретро от волка что почему нас внутри обычный список дальше мы получаем запрос на захват того либо иного лог а если мы его можем выдать мы словно наше внутреннее состояние можем выдать мы отвечаем запрашивающее муки и возьми на запись либо возьми на чтение если не можем то мы ставим запрос в очередь ожидании когда кто-то сообщает нам о том что мы можем отпустить тот или иной лак мы вынимаем из очереди ожиданий те кто к нам пришли за за захватом локона чтении либо на запись вот и делаем им реплей таким образом они получают свои хендлеры разрешения то чтобы захватить лук и так далее никаких блокировок давайте запустим результаты у нас примерно такие чуть чуть меньше чем ну поменьше чем в этом самом в предыдущем случае но приблизительно такой же рытье сохраняется примерно вот этот 116 вот значит что интересно интересно что я вот упоминал про справедливость несправедливость есть мы вернёмся к решению к решению через классическую многопоточность я здесь собственно за использовал справедливость да типа мы говорим штуки и давайте так поток то первое приходит за тапком этот его получит вот как вы думаете если поменять на рендер 30 локи этот режим справедливого на несправедливый изменится ли каким-то образом существенным статистика кто считает что изменится если мы берем на не справедливый режим a меньше 0 10 процентов об аде кто знает по дефолту какой режим работает если указывать скажите falls а отлично это правда давайте запустим здесь с пол сам и посмотрим сейчас я запилю вот это дело пин значит 28 на 175 значит так у нас на счету будет он как раз не частный запускаем смотрите вот наш результат и это было в прошлый раз с честным режимом это вот нечестным ну в общем я бы сказал что я не вижу здесь принципиальной разницы но эксперимент возможно не совсем честный возможного нужно держать дольше или или или или совсем-совсем долго поэтому крайне рекомендуется на целевых системах проверять что на самом деле сработает а имея в виду что нужно ли нам вообще справедливость или нет как мне кажется она не помешает следующей задаче которая хочу показать такую же классическую это обеду щи и философы значит наверное знаете но для тех кто не знает начну нас есть 5 н н философов вот они иногда едят иногда они пьют вот проблема в том что им положили не по две палочки а только по одной с каждой стороны то есть сколько палочка столько философов есть можно разумеется только двумя палочками вот поэтому если они все такие умные что сначала возьмут правую полочку потом попробуют взять левую они все заблокируются да вот есть масса решение этой задачи мы возьмем самое простое заключается в том что палочки нужно брать в их скажем так сначала нужно брать например палочку с наименьшим порядковым номером а затем с наибольшим таким образом нас все вот этих пяти от 1 до 4 философ возьму сначала допустим право потом левую последний возьмет наоборот и это как раз поможет нам не попасть блок в этого решение есть очевидный минус они там короче говоря ближе к последнему философу они всегда больше едят по времени вот поэтому есть другие решения через посредника и так далее там официант приходит их сам там как-то менеджер вот смотрим на решение на классической джаве вот мы создаем столько получив сколько философов палочка это просто центр and lock который наши волосы будут брать и отпускать по мере использования опять же countdown lodge нам поможет одновременно стартовать всех философов ну чтобы правда это было более-менее честно и мы создаем столько философ столько палочек философ это просто поток который философ он получает свой там номер он поднимает какую палочками надо брать первое какую 2 чтобы все это дело вообще говоря работала вот и дальше он просто пытается взять лук на 1 палочки если не получается он блокируется если получается дальше берет лог на 2 палочки если не получается блокируется если получается уйдет дальше есть какое-то случайное время вот ну и отпускает палочки чтобы кто-то еще поел достаточно прямолинейно это решение запустим посмотрим что пока бежит посмотрим на параметры собственным бежим 10 секунд у нас 5 философов мы едим и пьём одинаковое число времени в среднем вот что у нас тут получилось значит общее время у нас получилось 15 секунд то есть мы бежали 10 секунд если бы они все ели постоянно это было бы 50 секунд на пятерых ну в общем в среднем они ели там получается в среднем 33 секунды каждый более подробно статистика выглядит так значит от 0 до 4 время растет как я и сказал ну более-менее растет последний есть самое большое время но это особенность вот этого алгоритма так зафиксируем это решение было потом с чем сравнить и посмотрим на решение наверх такси вот но для реализации на вирт exe мы отойдем от классической actor модели вот сломаем вообще полностью концепцию возьмем концепцию которая как бы родная для vertex концепция называется общие данные короче говоря мимо концепция actor модели в которой мы общаемся внутри системы только посредством передачи мутабельных сообщений where так скрученного такая штука которая позволяет обмениваться данными между вертикалями не посылая сообщения по event басу берешь что-нибудь и там такое например мы воспользуемся примитивом который называется лог вот ещё там есть счетчики и и просто и просто map и общем значит этот примите флаг он называется как лог выглядит как лак но это не лог что такое лог значит мы говорим vertex мы бы хотели типа захватить вот такой вот по именованный объект лог волокна ему вот вызов детлок асинхронный не блокирующий where так смотрит взял ли кто-нибудь этот объект или нет если не взял нам говорят ok хорошо объект война задергивать за hinder внутри дальше мы проверяем мы действительно взяли лоб или нам просто его не выдали им и мы упали по таймауту вот если все нормально то типа мы что-то делаем вай фай ты нет мы все это делаем вот и освобождаем блок при этом еще раз это никакие не локи никаких блокировок не происходит мы запрашиваем асинхронно захват какого-то объекта нова синхронно его разрешают взять либо не разрешаю взять мы падаем по таймауту и собственно решение на vertex мы построим практически как классическое решение создаём систему vertex а диплом туда несколько философов философ этот это такой vertical унаследован от абстрактного вертикалом дальше что мы собственно делаем вот здесь мы пытаемся сначала взять лак на 1 палочки если как бы мы это просто асинхронный запрос поток уходит выполнять какие-то задачки когда этот лог освобождается нас дергают за внутренне хендлер вот за этот мы понимаем что первый локонами взят убеждаемся в этом при помощи метода со xid не секрет если все хорошо мы пытаемся взять вот этот второй лог опять же синхронно мне блокирующим режиме если все получилось дальше мы спокойно идеем случайное время и отпускаем локи в этом случае палочки это просто про стринги которые каким-то образом ассоциированы с объектами на которые приходят запросы взять либо отпустить допустим это решение результаты у нас такие общее время еды 16 секунд против против значит 15 405 против 16 где-то пол секундочки да там примерно попыток поесть в верх такси мы сделали 663 здесь чуть поменьше попыток вот ну и статистика в решении vertex распределяется примерно также то есть минимально в для для философов с минимальными порядковыми номерами и максимально с философами для философ с максимальным порядком номерами еще раз это не является как бы официальным сравнение производительности это просто частный случай когда привод таких условиях до вот таких условиях на вот этой машине с 8 ядрами в этом случае создается кратные двум играм кратно двум количество винт лупов то есть 16 это работает вот так соответственно решение о том что же на самом деле работает быстрее нужно смотреть конкретно целевой тачки с конкретными параметр этой системы массового обслуживания которая на самом деле решается буду подводить итоги значит стандартный java есть плюсы и минусы и проблемы это правда стандарт он правда работает есть стандартные проблемы с большинством мы знаем как бороться значит если у нас есть соответствующая квалификация значит есть альтернативные подходы через парадигмы другие парадигмы программирования другие языки через транзакционный software транзак шинами марина через значит коммуницируешь ее процессы к рутины в файбер и так далее и есть модель акторов actor модал проще java memory module вообще actor модель простая поэтому принципе не требует какой-то очень высокой квалификации чтобы посадить людей писать кровавый enterprise есть масса реализацией для actor модуль vertex одна из них по моему мнению веток со есть определенные плюсы это встроенная полиглот ность это реактивность и изначальный дизайн для хайло да почему потому что наш ивент лупы включаются пашут загружают я до 100 процентов теоретически если у нас носите сто процентов нагрузки найдутся задача не будут все лишены по дизайну мы посмотрели что на вер такси короче при помощи actor модели реализованы через vectors можно решать традиционные классические задачи на многопоточности классические задачи на многопоточность в принципе тождественны боевым задачам многопоточность я считаю что мы таким же макаром можем решать и боевые задачи на многопоточность перейдя в другую парадигма фактор моду выбирая vertex или что то другое и в конечном итоге если мы говорим как вот я у меня есть задача я хочу ее решите как мне кажется есть два фактора которые будут определять как мы пойдем стандартным путем java конкор нэнси или actor модели так далее это собственно квалификация инженеров которые у нас есть в доступе собственно говоря своя и коллег да и в конечном итоге то производитель который мы получаем при помощи этого решения да то есть производительность реальные цифры на наших системах целевых на нашем железе или виртуалка хэл virtual как под виртуалками они покажут нам какое решение в конечном итоге нам нужно применять у меня все спасибо большое за внимание проект который сегодня вам показал выложен на гитхабе можно туда прийти скачать поиграться пахали варить найти ошибки которые там наверняка есть вот и прислать мне обратную связь на контакты которые я вам оставляю большое спасибо если есть вопросы я готов отвечать здесь спасибо за доклад еще раз хочу напомнить что как задаем вопрос встаем и громко их микрофон чтобы на запись вас было слышать все пожалуйста ваши вопросы чем собственно vertex лучше других систем аналогичных например аки чем он хуже чем лучше чем есть какие есть особенности у него на рынке систем которые реализуют actor модель есть несколько крупных игроков vertex а k project реактор там но джесс так далее вот я считаю что явно лучшего фреймворка на этом рынке нет каждый подберет подбирает его под себя во первых то что ему ближе по а по идеологии там скала не скала до хочу я туда влезать или не хочу второе это то в принципе с чем он впервые столкнулся и на что отреагировала душа сердце вот из каких-то объективных факторов могу привести что ну а к это скорее java скала вот наверх и xi api можно писать на большем количестве языков под живем и если команда настроена на пригодность и тимлид поддерживает эту полиглот ность в команде the vertex это это это это выбор вот теперь vertex это не только собственно не совсем реализация actor модели но там целая эко-система которая построена вокруг собственно как иваки вот если говорим про производительность в каком-то там 18 2008 году были попытки их сравнивать в там vertex немножко порвал всех вот но там такие были на самом деле странный показатели например вертекс зао порвал инете хотя сам на нем построен поэтому честно говоря то есть нужно строить именно тот benchmark которая будет работать у вас и по-честному по-честному сравнивать ну надеюсь ответил столько вопросов посмотри когда хватит самый первый что с работами с базы данных из факторов вечная проблема с передачи туда здесь какой-то еще не гордится значит vertex точнее компании сейчас уже получается eclipse foundation занимается непосредственно корм этого vertex а есть сообщество которое пилит всевозможные интеграции для вертексы для випов том числе для баз данных есть пачка готовых как бы коннекторов к базам данных которые ну там типа типа там для манги ты можешь писать код в го синхронном режиме of a нормальный пацан просто нормальные базы до я не знаю что такое нормально базы данных в нем он в коме манги манга вполне себе нормальная базы данных используется продакшене в крупных компаниях в том числе в знаменитых вот значит принципе вообще если нужно просто любую базу данных у тебя есть джитибиси и ты можешь работать с базой данных не из event лупа а создавать рабочие потоки на которых нет жестких ограничений а то что они не могут выполнять задачи больше двух секунд и так далее да то есть и собственно подход такой ты берешь маркер квартир сред в нем делаешь вот то что там нужна база данных подход поход полет на луну и так далее возвращаешься и с результатом в в and look вот вот твои данные это общий подход rovapo что есть типизация могу ли я на уровне компиляции проверять что у меня фактор не передали это сообщение которое хочет получить с типом как поле тут значит если мы говорим про сообщение которые ходят по event басу собственно vertex идет с предопределённым набором типов которые правильно передавать но это типа массива байт jison и вообще топит джейсон потому что он типа хорош вот если хочется типы собственно подход стандартные ты пишешь кодек для того типа который нужен и кодек будет ругаться если приходит какая-то фигня но это уже на этапе исполнения только то есть на этапе компиляции не как надёжно что мне дано ничего не послал да но и соответствующий вопрос как все это тестировать комьюнити принципе предлагает тесты значит тестовый фреймворк который как бы именно может тестировать асинхронный асинхронный а пик вот по идее значит собственно надо смотреть такое тестирование мы говорим если мы говорим про скорее всего ты спрашиваешь про вы спрашиваете про интеграционное тестирование вот ну то есть да он развёрнут ты его бомбишь и так далее uni тестами там наверно ничего тестировать там все довольно просто вот то есть в принципе большовой большой разницы на самом деле с какой-то другой java программой использующий spring или что-то в этом роде в общем то нету то есть и там и там поднимая допустим понимается spring контекст ли вы здесь поднимется вверх так система iliaca система вот в принципе на этом уровне так спасибо спасибо обошли немножко стороной такую вещь как кластер который уже да да пасибо ну намеренно не включил многие другие возможности vertex а потому что это не совсем как эта реклама тут тулы а скорее про то что типа ребята есть варианты вот можно прокачаться в java конкор нанси классно решать задачи у нас просто есть другие варианты может быть вам подойдет что-то другой например an actor модель и например vertex если мы говорим про фишки vertex они там ну есть много классных штук например значит то что подход который мы написали принципе его можно при помощи конфигурации запустить на низких живем это делается просто через конфигурацию vertex изначально задумывался о том что вы можно каждый из вертик вот можно запустить в кластер нам режиме там есть такой кластер менеджер о которой пользуется какой-то из известных систем менеджмента кластеров например hotel костыли джей groups и так далее принципе это плага был штука можно использовать что угодно то есть для распределенных систем он тоже подходит но я на холоде хотел сконцентрироваться на халат фишках поэтому да спасибо что озвучили это"
}