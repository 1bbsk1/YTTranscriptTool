{
  "video_id": "Xr_SNd9LIng",
  "channel": "HighLoadChannel",
  "title": "ID-баттл: UUID vs автоинкремент / Валентин Удальцов",
  "views": 5301,
  "duration": 3194,
  "published": "2023-10-06T07:16:54-07:00",
  "text": "Всем привет как слышно так а кликера нет Ну так ты сказал без ноутбука и без кликера А ты же без ноутбука да нос кликером Спасибо большое кажется его уже не сниму ладно так Всех приветствую Меня зовут Валентин Я работаю в компании happing PHP разработчикам и Тим ли дом А еще я автор двух каналов это Пых и PHP Point на которых я рассказываю кому в PHP жить хорошо Сегодня у нас с вами стандартная такая старый добрый холивар про то как лучше идентифицировать ваши сущности и строки в БД мы будем выбирать между двумя технологиями это виды и автоинкременменты план на ближайшие полчаса следующие мы с вами попробуем сделать что-то типа баттла то есть я сначала представлю участников автоинкременты и некоторые версии видов мы с вами выберем Да чтобы им использовать и потом у нас будет несколько раундов в рамках которого будем выбирать победителя потом будет суммарный зачёт значит автоинкременты но я думаю все знают что это такое как правило правда инкременты говорят в контексте базы данных но я подумал что чтобы более равноценно сравнивать с видами Можно попробовать так поиграться и немножко абстрагировать ну так просто мысленно эксперимент Вот например можно такой контракт объявить по приколу да э то есть у нас автоинкремент начинает с единицы каждый следующее значение возвращает на плюс один больше и мы можем его вырезать именно такой контракт можно написать с вами контрактный тест Ну там ещё какие-то методы будут там что-то про персистентность ещё про что-то Ну вообще смысл сколько раз вызвали э такое число и получили и мы можем его имплементировать даже вынужденном случае каким-то инкрементом Можем имплементировать попробовать файлом Я вот здесь что-то набросал там с э блокировками ещё с чем-то попробовал вроде работает но это я так просто поиграться Ну естественно каким-нибудь позагдом а и что мы видим что во всех этих реализациях есть одно общее для того чтобы поддерживать автоинкремент Нам нужен некоторый кусочек стейта который мы будем где-то хранить и запоминать то есть нужен некий такой Центральный элемент который будет все это организовать мы не можем автоинкремент поддерживать просто на пустом воздухе нужен вот этот стейт но я думаю Здесь вам все знакомо теперь я вам хочу представить Universal это универсально уникальная идентификаторы Я думаю все тоже знают что это такое перед тем как пускаться глубже Давайте а-а подумаем Как правильно их называть я слышал разные названия Вот Но мне больше всего нравится вид это как-то и коротко и не очень язык ломает Вот Но в принципе я посмотрел разные доклады и наших э-э коллег э-э российских и зарубежных и все говорят по-разному и вроде как не удалось нагуглить какой-то душной статьи про то как правильно Так что Называйте как хотите юиды у нас регламентируется rfc 4122 но перед этим еще хотел обратить внимание на слово universaly я обратил внимание что на русской Википедии юиды переводится как универсальный уникальный идентификатор Но universaly это наречие а не прилагательное То есть он универсально уникальный а не универсальный и уникальный Мне кажется это важно действительно ЮИТ его в качестве суррогатного ключа очень часто использовать удобно но прямо универсальным я бы его не назвал но какие-нибудь там паспорта удобнее идентифицировать например по серии номеру э подписчиков рассылки по имейлу и так далее А вот то что он универсально но уникальный означает что он повсеместно уникальный глобально уникальный с немножко другой оттенок вот я решил немножко потушить в этом месте а значит теперь про стандарт рфц 4122 Я думаю вы все видели эту форму и вид это просто очень большое число а именно 16:32значная шестнадцатеричное число То есть получается на каждые из 32 позиции у нас может быть один символов шестнадцатеричного алфавита поэтому 16:32 то же самое что 2^128 поэтому едет весит 128 бит и А что нужно Здесь знать что в юиде всегда зафиксировано Два А Два символа скажем так это вот здесь об куда им показывать о Вот один это вот здесь эта версия Да там у нас 4 старших биты используются Ну то есть весь символ и два старших бита если мы говорим именно про рфц это вариант Ну подробнее про это не будем просто вывод делаем такой что в виде мы можем заполнить из наших 128 бит все кроме этих 6 бит то есть 122 у нас остается и как именно мы их заполняем регламентирует версии и вот здесь интересный момент да Вы наверное думали что версии всего пять Но на самом деле сейчас существует уже восемь версий плюс два специальных вида А вот эти дополнительные три они объявлены в драфтовом стандарте одним интересным человеком который решил исправить некоторые нелогичности и мы сейчас с вами их рассмотрим Вот Ну а все остальные 5 они написаны про них написано Википедии они регламентируются стандартом rfc 4122 вот этот черновик уже Существует несколько лет и последняя версия не так давно была добавлена у нее срок годности это апрель 23 года я надеюсь что наконец-то ее примут но все ее виды которые там объявлены они достаточно стабильные и мы например их используем уже несколько лет несколько это два давайте рассмотрим по группам все виды Значит у нас есть специальные виды это ну и да то есть забитый нулями его удобно использовать как Ну лобже и удобно там иногда в тестах текстурах забивать сущности вот этим скажем так константным литеральным видом и в новом стандарте ещё предложен Максим и Аналогично он забитками эти ребята у нас не попадут в нашу Баттл потому что ну это просто литералы А вот дальше интересно Значит у нас есть группа Time Base видов то есть видов которые содержат метку времени соответственно как они устроены Вот именно uid версии 1 это самая классика Time Base видов он первый идет в стандарте у него внутри него используется метка времени но необычная unix который мы все привыкли А григорианское время оно весит больше там что-то по-моему 60 бит но прикол в том что она записана не как хотелось бы Ну как-никак логично было от начала до конца Вот в эти биты всей вставить оно разбито время на таймс Темп на три э-э раздела и эти разделы все записаны в обратной последовательности поэтому едет версия 1 не сортируемый то есть он не монотонно возрастает У нас вот получается видите идёт лоу тайм То есть как бы конец метки времени середина а потом начало но ещё идёт Рандомные компонентов в конце А ну плюс вариант да вот эти два бита помню соответственно Это для того для того чтобы если вы одновременно сгенерировали все таки в одном миллисекунду у вас еще было рандомная компонент который вы гарантировала его уникальность и в конце нотайди это нота Дима его макбука потому что я на нем сгенерировал этот вид а здесь пожалуй все Обратите внимание что во всех видах на котором будем смотреть у нас есть вот здесь число это версия и чуть позже будет доклад Петра мезина обязательно него приходите и вам задание квест у него там будут юиды в слайдах Я знаю потому что член Пока я отсматривал в доклад и вы там посмотрите какая там версия вот потом ему скажете я думаю будет приятно следующая версия вида - Это шестая это уже вот из этого альтернативного стандарта что предложил автор он говорит Давайте мы исправим ошибку и до версии 1 сделаем его просто сортируем им мы возьмём Ту же самую эгрегорианскую метку времени но запишем её по-нормальному там от начала до конца и тогда можно будет без проблем сортировать всё остальное То же самое но Отойди Рандомные компоненты Здесь вы можете увидеть циферку 6 Вот а еще он пошел дальше и говорит А давайте мы вообще этот григорианское время это какая-то туфта что это вообще такое Зачем нам Мы привыкли всех unix unix Times Temple Давайте мы его запишем он еще и весит меньше То есть он займет всего у нас несколько актетов в начале а всё остальное фиг с ним с этим not ID на кой нужен Давайте его забьём просто рандомным числом у нас тогда получится во-первых вид который сортируется во-вторых в нём очень большая случайная компонента соответственно а он ну хорошо выполняет Требования по уникальности Мы закончили с тайм-бейски видами для нашего Батла Мы оттуда возьмем версию 1 как классику и версию 7 как самый продвинутый Time Base twit следующий Рандомный Я думаю вы здесь все прекрасно знаете вид версии 4 у нас зафиксирован битс версии это 4 все остальное забито рандомом все очень просто его обязательно берем в Баттл Потому что его используют все следующий виды соответственно есть версии 3 мы с вами берём namespace некоторые формате вид и некоторую строку берём от них Хеш и заполняем все наши свободные биты получившимся хешом в случае версии 3 от md5 то есть мы берём как раз md5 есть 128 бит записываем uid а потом фиксируем те шесть бит которые нам нужно по стандарту И вот так будет выглядеть примерно функция на PHP она чистая потому что эта функция полностью детерминированная иногда это очень удобно То есть вы передаете ей на EMS какую-то строку и получаете uid всегда одинаковый для такой же комбинации да то есть чисто детерминированная функция Ну и здесь примерно написано как это под капотом выглядит то есть используем хэш в бане и зашиваем дальше один поэтому смысла использовать а ute версии 3 потому что sha1 это более правильно алгоритм хеширования в котором меньше коллизии он тоже сломан но он не так тривиально ломается sh1 подлиннее поэтому он обрезается до 128 бит и потом остальные биты забиваются по стандарту В общем это наши хешбэйс и виды Мы из них на Баттл берём только пятую версию потому что третью вообще нет смысла использовать У нас остался восьмая Я сказал что их восемь но я решил здесь сделать маленькую хитрость и не рассказывать вам а-а Про что этот вид мы с вами обсудим это либо после доклада Либо вы погуглите потом вот чтобы пробудить дополнительный интерес к обновлённой версии стандарта Итак мы с вами рассмотрели всех участников да Теперь давайте переходить к Батлу напомню кого мы вынесли в турнир у нас с вами идёт автоинтермент как же без него у нас идёт версия 1 это классика таймбейсти вид версии 4 Рандомный все знают хорошо и версии 5 - это ж один мы будем проводить несколько раундов вы все их видите справа Ой по-моему там не видно последнюю треугольничек Ну ладно там как раз результаты Батла но я Вам их расскажу может быть он появится потом неважно И мы будем каждому идентификатору выставлять балл от 0 до 2 То есть у нас будет трехбальная система начинаем значит нас сортируемость да первый критерий довольно важный автоинкремент здесь заслуженно получается один балл тут очевидно автоинкременты все сортируемые потому что это строго э-э возрастающая монотонная функция один не сортируемый мы с вами обсудили там метка времени наоборот записано И вот я взял для для сформировал вид версия 1 у него все первые символы в разнобой идут потому что он не сортируемый Хмм и соответственно а по нему сортировать неудобно ют версии 7 исправляет эту ошибку я уже рассказал Да и он сортируем он получает 1 балл у нас ют версии 4 Рандом очевидно Не сортируется каждое значение уникально там может быть все что угодно едет версии 5 тоже не сортируемый потому что используют хеш-функцию Хеш функция не обязана также быть сортируем как её параметры тут тоже получается Рандом тоже ноль баллов У нас прошёл Первый раунд переходим к следующему не подбираемость да но все мы знаем что если у нас допустим User ID мы свой Знаем мы можем теоретически отправить какой-нибудь запросец идентификатором плюс один минус один и попытаться добыть такую информацию Ну если авторизация выстроена корректна это никак не поможет Но всё-таки это свойство имеет смысл рассмотреть В общем мартинкремент здесь получает ноль баллов Он легко подбираемый и версия один получается один балл потому что подобрать его трудно да вот здесь я сгенерировал в цикле четыре подряд виды версии один То есть там по времени разница минимальная но смотрите у нас вот здесь Большая разница идет вот тут вот потому что это как раз конец времени и там метка времени меняется и здесь рандомная компонента тоже Поэтому предугадать следующий вид довольно трудно а если бы разница между ними была по генерации там час то это вообще бессмысленная затея поэтому один балл ute версии 7 Аналогично один баллс там всё то же самое заметки времени трудно что-то подобрать и отверстие 4 получает 2 балла Потому что если он например сгенерирован ещё и на криптографический вот этой крутой случайной величине то Ну там вообще без шансов Да а но здесь хочу заметить что по стандарту можно использовать как рандомное значение так и псевдо рандомное но в целом не стоит Мне кажется вообще про виды говорить в контексте безопасности потому что они не обеспечивают Случайность они обеспечивают уникальность Это не имеет ничего общего именно со случайностью поэтому это свойство приятно но оно не обязательно Ну и есть версии 5 тоже довольно Ну трудно подобрать потому что это результат Хеш функции она необратимая поэтому мы Конечно можем знать если бы мы знали юзернеймспейс мы могли бы по-другому email получить его идентификатор Но это еще надо знать что именно таким образом ют версии 5 там для User ID так генерируется в общем следующий раунд у нас прошел так дальше содержательность что я под этим называю хранит ли наш идентификатор какой-то дополнительную информацию Но это всегда приятно автоинкремент ничего не хранит единственное если у нас есть два значения то есть одно меньше другого мы понимаем что наверное оно было сгенерировано раньше Но насколько раньше на одну миллисекунду или на год неизвестно поэтому никакой информации он не предоставляет и версия один хранит метку времени мы её Элементарно можем извлечь то же самое с видом версии 7 Они получают по одному баллу и ведь версии 4 ничего не хранит Ну разве что уникальный некоторые токи но вряд ли это э в контексте этого раунда полезно и версии 5 тоже ничего не хранит потому что Хеш это необратимая функция поэтому ничего обратно извлечь не сможем еще Кстати uid версии 1 хранит но дойди Вот это да Но не всегда его используют реальные mac-адрес как правило его фейковые доставят чтобы ну невозможно было вычислить машину на которой был сгенерирован идентификатор следующий раунд это читабельность думаю многие из вас Его ждут до автоинкремент здесь заслуженно получает 2 балла потому что ничто так не читаемо как числа нелегко запоминаем И даже если там будет там не знаю миллион это всё равно можно представить как телефон и запомнить или хотя бы выписать на бумажку И юиды даже если схитрить и сконвертировать их в b62 это b64 минус без плюсы и равно всё равно это довольно длинная строка с кучей символов и запомните её нереально её можно только куда-то скопировать вставить и надо ведь вести какой-то задачу вставить ещё куда-то запомнить в уме это невозможно поэтому как бы её и не старались они там получили все по ноль баллов следующую у нас а раунд это манёвренность но такое немножко придумал такую историю что я здесь имею в виду смотрите авто инкремент вот он просто идет последовательности Все мы ничего с ней сделать не можем мы не можем ее не подвинуть не вставить значение между можем Вот только если у нас выпал один идентификатор Ну пожалуйста здесь четверку можно вставить но в целом как-то Это модерировать невозможно У идов наоборот всё отлично во-первых они все взаимозаменяемые То есть если у нас с вами в базе данных есть полег можем встать и любой версии нас никто не будет проверять это там допустим поле колонка для первого и там и вставили Пятая нет такого не будет во-вторых Мы можем вставлять значения между потому что еды любой версии они могут быть сгенерированы как бы в любом месте и не париться и более того Мы даже можем если у нас есть табличка с автоинкрементами мы можем всю её перевести в юида разных версий Ну там за счёт например хеширования или за счёт добавления к метке времени То есть у нас здесь довольно Ну вот я назвал это манёвренность да У нас есть пространство для каких-то возможностей и если что-то там пошло не так Или надо что-то куда-то добавить это всегда несложно поэтому здесь виды все получают по одному баллу автоинкремент ничего не получает и очень важное свойство для тех кто пишет какие-то распределенные системы это коррелирование сущности по ID Я здесь вас отправляю к докладу мауры сервеентии это итальянский такой разработчик по-моему итальянский а-а значит он рассказывает крутой доклад он на примере амазона рассказывает Почему агрегата корзина не существует на бэкенте это всё не так происходит у нас есть отдельно маркетинг где там формируется цены точнее маркетинг где формируется описание sales где формируется цены и так далее То есть во взрослых распределённых системах нет такого что всё хранится в одном месте и стоит не докомпозировано это очень крутой доклад по этой композиции стоит И когда вы э хотите допустим вашу сущность распилить кусочки стоит отправить в разные микросервисы или разные модули вам будет очень удобно Если вы сможете один раз генерировать один идентификатор и назначить его для всех этих модулей и тогда у вас не явно допустим ваш юзер у которого есть аутентификация профиль рассылка там аватарка все эти сущности в разных модулях с низкой связностью между собой будут иметь идентификатор и таким образом не явно будут совпадать и можно поэтому идентификатору получить всю информацию из разных подсистем автоинкремент нам Элементарно Это позволяет да то есть мы генерируем на фронте или там на контроллере куда изначально приходят запрос один идентификатор и с ним отправляем команды во все наши подсистемы с автоинкрементом так не получится потому что в разных таблицах автоинкремент может находиться на разных позициях между мы не можем вставлять заранее значение резервировать тоже поэтому здесь и однозначно Выборы это и все Они получают по одному потому что не важно какая там версия Ну что ж и мы с вами подходим мы с вами Подходим к финальному разделу но такое ощущение что у меня здесь не обновленная версия слайдов почему-то попала пам пам Давайте посмотрим все равно графики есть Это уже хорошо В любом случае ссылка на доклад будет значит что я здесь делал конечно на всех интересует как ведут себя виды в базах данных Да как какие у нас получается графики на вставку на чтение какие у нас проблемы с индексами соответственно я написал проект В обновленной версии презентации там есть ссылка на него и он лежит на гитхабе соответственно там вы можете посмотреть как устроен этот бенчмарк суть такая я в цикле генерирую по 200.000 идентификаторов в случае с автоинкрементами Я просто Вставляю 200.000 строк с дефолтами А И засекаю вот этот мульти insert какое время будет вставляться да то есть вот я в цикле прохожу И там по 200.000 каждый раз оставляю а соответственно у нас получается с вами что для каждого из сотни тысяч У нас есть из сотен тысяч У нас есть точка там внизу числа в тысячах идут то есть 200 тысяч 600 тысяч ну просто часть еще убрано и мы с вами засекаем время вот этой вставки и база у нас растет таблица Да потому что мы добавляем добавляем добавляем по 100 тысяч и там доходит до 20 миллионов у нас табличка и смотрим как у нас меняется график времени вставки и вот смотрите что мы здесь наблюдаем мы наблюдаем с вами что ЮИТ версии а-а 4,5 они действительно их время вставки со временем увеличивается с количеством строк то есть чем больше таблица тем тяжелей вставляется версии 7 Ну речь идёт про пост 15 сейчас в частности они абсолютно одинаковые сортаменты то есть никакого роста на скорости вставки вообще не наблюдается Ну там маленький есть на самом деле если это все увеличить Но на этом масштабе Да это у нас вот здесь вот 2000 это миллисекунд Вот то есть у нас ну там вообще все На полу лежит все эти графики То есть получается что Time Base виды они абсолютно эквивалентны по скорости вставки с автоинкрементом нет никакого смысла их не выбирать по этому критерию следующий график я померил скорость чтения То есть я а когда вот во время вставки я запомина я брал тысячу рандомных юдов или автоинкрементов из тех что я уже вставил и делал запрос Селект in и вот эту тысячу вставлял и Мерил Сколько времени Это займёт запрос Да и каждый итерацию то же самое то есть это всё бенчмарк он как бы за раз делается и несколько параметров мерять здесь у меня конечно есть шум какой-то Да я делал это на макбуке Возможно там какие-то системные процессы шумели поэтому есть пики но мы здесь с вами видим что а ЮИТ версии 4.5 проигрывают немножко да то есть они видимо из-за того что они вообще рандомно хаотично ложатся в индекс их чуть-чуть дольше искать вот а все таймбейсты Австрии инкременты они все опять лежат на полу ну и здесь можно обратить внимание в самом начале есть пик это из-за того что наверное при первом запросе там и индекс прогревается или что-то такое происходит И следующий слайд а коллеги А вы не могли попробовать перезагрузить презентацию в браузере просто F5 нажать потому что там должна быть обновлённая версия и там прям слайды которые больше хотелось показать А я пока расскажу как я Мерил ещё один параметр метрику это размер индекса да то есть вот это всё это первичный ключ было бы ещё интересно померить Как растёт индекс со временем вот ну и там на графике Можно будет увидеть что индекс растет линейно во всех случаях Я немножко этом был удивлен Возможно это какая-то специфика хранения постгрыса именно индексов Да но вроде бы он тоже должен для первичного Ключа если правильно помню использовать B3 Вот но там на графике будет видно что таймс юиды они ложатся чуть-чуть легче потому что они сортируются сортируемые соответственно в битри они более компактно укладываются то есть там всегда есть компоненты которые Ну плюс-минус фиксированная и дальше уже хвост он пушится меняется О отлично хорошо что это сработало Спасибо большое Вот это обновлённая версия последнего часа а значит это мы видели да вот смотрите проект в котором эти все бенчмарки выложены на github То есть вы можете сюда перейти и посмотреть как это всё было сделано ещё раз скорость вставки графики все те же самые получается по скорости вставки мы выставляем баллы автоэнкременты и версии 1 версии 7 А по одному балу Да потому что они у нас хорошо себя ведут лежат на полу и версии 4.5 получает 0 баллов скорость чтения я выставил тоже соответственно Time Base videm of Tiny там один балл версии 4 версии 5 0 баллов И вот размер индекса графика как себя ведет да то есть автоинкремент у нас самый крутой потому что здесь вообще прям линия прямая идет то есть индекс увеличивается равномерно линейно а Time Base you еды Ну вот там правда что-то случилось версии 1 наверное Дело в том что он всё-таки А у нас менее а-а он не сортируемый и там в конце что-то Intex поплыл в сторону увеличения но едет версии 7 такая же прямая только немножко с другим наклоном и версии 4 версии 5 они занимают всё больше и больше места постепенно потому что они Рандомные они сильно разбросаны соответственно они в индексе хаотично наполняют наш B3 вот ну и здесь я поставил а всем по одному баллу потому что в целом везде вопрос линейный Ну разные угол наклона я здесь не вижу никакой не экспоненты ничего такого Поэтому я решил что вполне нормально Всем поставить Ой это предыдущий слайд всем поставить по одному баллу потому что все линейно растут просто с разной скоростью дальше Конечно хотелось бы бенчмарке еще сделать для майски или db2 и всех прочих баз но я решил что будет прикольно если вы законтриптите в этот проект он публично он сейчас открыт на гитаре и поможет составить бенчмарк для остальных баз данных то есть там просто в докере достаточно добавить ещё одну базу имплементировать интерфейсик парочку и всё у нас получится бенчмарк для других баз данных потом запускаете Бенч и он складывает данные и там ещё XL которые автоматически из этих цифр подсасывает числа и строит график вот так что если кому-то интересно Welcome Я буду рад от reviews вот такой я хитрый Ну и что же Давайте подведем результаты было бы обидно да если бы этот слайд не подгрузился значит у нас с вами победитель Это вид версии 7 напомню Да это ЮИТ в который зашита unix метка времени в нормальной последовательности он сортируемый в нем большая рандомная компонентов в конце то есть это по сути uid версии 4 и версия 1 лучше из них вместе вид версия 1 у нас на втором месте потому что по сути он отстал только по параметру сортируемости Да но он достаточно критичный то есть довольно удобно по виду сортировать э Когда вы там не знаю выборки какие-то делать ещё что-то есть версия 1 не обладает таким свойством Австрии инкремент на шестом месте он проиграл по разным пунктам Ну таким более логическим Да но выиграл по всем связанным с оптимизацией и версии 4 версии 5 Они в самые у нас попки оказались потому что а-а они и не очень оптимальны в базе себя ведут и мы по функционалу тоже например метку времени не содержит ни сортируемые Но что я хочу сказать вид версии 4 хорошо выбирать если вот вам прям нужен Рандом Рандом Рандом честный Да и вы можете там криптографическую какую-то функцию использовать которая прямо вот на этом на кристалле всё честно генерирует настоящие Рандомные числа и версии 5 удобно использовать там где А где где вы например хотите загрузить сущность и сгенерировать её идентификатор на базе какого-то поля То есть вы берёте фиксируете на импспейс в константе а потом например э на второй параметр Если речь про каких-нибудь юзеров передаёте email И вы получаете для всегда для тех же юзеров с таким же мейлом такой же идентификатор поскольку функция детерминированная мы так импортируем большие структуры компании Это позволяет мне делать лука в базу данных и не проверять А если там юзер какой у него идентификатор по имейлу Да не надо подсматривать мы можем просто сделать inserved и не париться либо Обновили либо добавили а идентификатор поскольку имейл тот же самый он одинаковый вот поэтому есть версии 5 у нее есть uscase но надо смотреть Да на производительность потому что она не очень хорошая из-за того что он не сортируемый не монотонно возрастает Вот такие у нас результаты победитель ют версии 7 здесь логичный вопрос возникает как этим пользоваться откуда брать значит для PHP есть библиотека рэмзит она поддерживает все восемь версий есть симфони уит библиотека там New ID а просто ЮИТ там по-моему там точно поддерживается шестая версия по-моему Седьмая не уверен насчёт восьмой Вот То есть в принципе это всё отлично поддерживается на уровне нашего языка а в базе в базе вообще всё равно Да ну если она поддерживает вид Как пост говорит то хорошо она Хранит его в байдере использует 128 бит если у нас майские Да придётся сохранить там в виде строки в Марии диби вроде уже что-то есть лидов в общем эту информацию вы сможете подчеркнуть когда поможете мне собрать бенчмарки для остальных баз данных вот так что Используйте их версии 7 Прикольная штука у него куча полезных свойств Ну и на этом мы с вами заканчиваем Вы можете оценить мой доклад по qr-коду сверху по qr-коду снизу Вы можете открыть эту презентацию вебе и все внимательно просмотреть покликать ссылки Так что прошу Большое спасибо за внимание Спасибо я начну с вопроса из чата что насчет определенных систем генерация идей Какие плюсы минусы метрики из данного доклада были бы у flake То есть это вот всякие идентификаторы которые Твиттер делает если я плохо прочитал а что насчет распределенных систем генерация D А ну да что-то я слышал про вот эти flake Snow flake Flag Да это по-моему Twitter что-то из этого делал а-а Ну они на самом деле обладают разной комбинации вот этих свойств они появились параллельно или может быть раньше чем вот появился Вот это обновлённый драйв для юдов а соответственно там из них часть тоже сортируемая потому что держит метку времени часть из них короче визуально это вот я вам показывал трюк с Бейс 62 То есть вы берёте это кекс число и переводите просто в другую разрядность получаете число с кучей букв разных но просто короче какие-то из них покороче но по-моему там нету такого идентификатора который в совокупности там э каким-то обладает свойствами которые не обладают вот эти три новых предложенных вида поэтому это всё так или иначе ложиться сюда но еидам пользоваться удобнее потому что его все знают все поддерживают в космосе пожалуйста нативное поле А вот snowflake его придется ворчаре скорее всего хранить потому что Ну возможно там совместим с явидами можно конвертировать туда-сюда но на мой взгляд вот как бы это более надежный вариант и виды все знают все используют во многих системах есть наверное Надеюсь ответил на вопрос да Если не ответил то допишите там уточняющий вопрос пока Валентин отвечает на вопросы в зале я Напоминаю тебе или говорю если об этом не знаешь у нас подарок за лучший вопрос автору лучшего вопроса поэтому Старайся в голове запоминать Я всегда это говорю спикер но они обычно сразу бывает вот я тебе напоминаю пожалуйста Выбирай лучший вопрос поднимайте руки и к вам подбегут с микрофоном Добрый день У меня Я хочу немного побороться за интригмент А давайте два комментария первый комментарий как повлияет на э вот этот вот рейтинг а идентификаторов то что автоинтри менты зачастую можно кешировать О чём говорю о том что можно выставить допустим в базе данных допустим в 100 и уже на уровне приложения запрашивать значение sequence только раз в 100 вставок скажем так это фича встроенная в кибернейт я сам же Вист я не покопешник как PHP Поддерживает ли ормы либо там другие библиотеки подобные оптимизацию не знаю это вот первый вопрос во-первых Спасибо что зашли на PHP трек это очень приятно увидеть в аудитории что касается вопроса Впервые слышу честно про такую технику интересный подход Вот Но я здесь замерял вот в своих бенчмарках Только время которое БД тратит да то есть я не замерял саму генерацию безусловно то что их надо сгенерировать и так далее Я думаю что это просто еще один раунд которого здесь нет и возможно там и автоинкременту добавится один балл Судя по тому что вы рассказываете Вот Но я как бы этот вопрос не изучал но Так звучит убедительно потому что юиды ну там смысл кэшировать Там вся Смысл в том что мы их генерируем сразу вот так что думаю что да это немножко подняло бы в инкремент турнирной таблице так Александр Да спасибо Я хотел бы как раз инкременту убавить как раз бальчика на самом деле когда мы говорим экспериментах есть вторая проблема нужен какой-то Центральный координированный источник выдачи этих аишников и это автоматически приводит нас к такой ситуации что если мы хотим расшартироваться например по базам данным или по решениям то приходится генерировать сиквенсы либо пасетом отмерять и указывать там свои идентификаторы либо что-то изобретать и в этом плане вот версия седьмой как раз получает дополнительный Плюс потому что мы можем Теперь его генерировать любой точке мира и не ходить в центральное какое-то систему которая нам этот авторемонт выдаст ещё я автокременты накинул Минус 100 что он имеет свои пределы даже если у вас там это 64 он всё равно имеет свои пределы и на современных мощных э-э там можно что делать можно получать метрики компании а сколько у него было заказов А сколько у него было клиентов А сколько у нее изменилось там за неделю эти величины и автоинкремент прям получать от меня наверное минус по-моему Саша очень хочет подарок от меня Я просто взял я еще хочу добавить безусловно вот этот все раунды не полные Да здесь можно было бы много напридумывать ещё каких-то я думаю ещё было бы корректно расставить веса для каждого раунда Потому что некоторые свойства но не равнозначные и не очень правильно в общую таблицу складывать это всё с одинаковым весом и дальше вес кстати один из итогов который наверное стоит проговорить что А как мы видим все технологии так или иначе хороши и дальше нужно её скейт смотреть где-то хэшбэкст хорош где-то автоинкремент нормально потому что нам всё равно какой-то там будет идентификатор мы никаких на нём Надежде не налагаем и там например вот как Саша говорит записи будет если немного то пусть там будет автоинтермент вот А если у нас распределённая система то у нас даже выбора нету и какие-то свойства они имеют гигантский вес для нас например коррелирования сущности там или вот возможность децентрализации выдачей видов а-а поэтому в зависимости от ситуации веса в каждом раунде должны быть разные вот Ну это такая ремар как моему собственному докладу но здесь не было задачи прямо так усложнять Спасибо Саша то что сказал Да ну единственное там минус будет что визуально это всё будет не очень прикольно выглядеть Еще минус то что тебя не слышно с трансляции сейчас значит Саша рассказывает что в маске или есть функция которая позволяет охранять хранить ей Ты просто в баннере и есть функции которые конвертируют строк туда и обратно да А если мы говорим о том что нам хочется это ещё и красиво видеть то легко создается виртуальная колонка в мускуле и она имеет читабельное представление но при этом отдельно не хранится виртуальной колонки это как способ работать нам людям легко с теми данным которые база данных хранит эффективно в бане 16 Круто Спасибо Давайте дадим возможность задать вопросы другим людям а я вот как раз в пику предыдущему спикеру заступился немножко за автоинкремент что меня всегда смущало в ю-видах это внесение некоторой скажем так неопределенности в систему как таковую то есть по большому счету за счет рандомности части генерации у нас строго говоря нет стопроцентной уверенности в том что у нас в какой-то момент все-таки не будут где-то два одинаковых вида и вот это лично меня всегда смущало но тут дальше Надо смотреть по тому как часто генерируются но там как бы вероятность настолько с большим запасом что это очень трудно достичь Это понятно что у нас с запасом но понимаете да то есть речь именно о том что у нас вносится вероятностный момент Да вообще говоря в детдоминированной системы Вот это очень сильно смущает психологический такой момент может быть даже ну вот мы пользуемся У нас конечно не какой-то такой контрмер хороший Потому что у нас небольшая система Вот Но я так тоже читал про это и а Хмм я ни разу не видел даже чтобы вот на такую проблему прямо в реально на практике пришли и э с ней столкнулись вот ну соглашусь что да такой момент есть но можно вот вот просто игнорировать его и всё будет хорошо здесь знаете как всегда cos benfi анализ Да строго говоря вообще в любом вопросе в программировании есть какая-то неопределённость и никогда не понятно мы сейчас одно выберем подход а потом нам рефакторить придётся или нет ну то есть и этот он там такая вероятность хорошая заложена что Вот его можно первым отбросить и решать другие вещи все детерминированные куда меньше и нужно прямо серьёзной какие-то штуки решить Так что вот так Да я хотел в пику опять предыдущему у нас замечательно тут же Баттл был Давайте добавим немножко начала при такой ни одной триллионной что у вас два одинаковых вида Ну берегите его просто и все просто на ставке в сад ломаетесь на уникальном ключе и перегенерировать как бы второй раз это уже триллион умножить на триллион Да там не получится ничего с этим да Но кроме ситуации когда мы используем inservedate вот мы в проекте Как часто этим пользуемся там это как бы не явно произойдёт и никак не Отложишь Да так что ну здесь есть тоже Контр такой маленький Аргумент на Это история но всё-таки вопрос э к вам скорее А как так и не прозвучало ответа А когда лучше использовать автоинт и обычно эти А когда лучше потому что я в своей практике видел такие классные вещи которые есть справочник станции метро там Ну и вместо айтишника там йоиды и Три кота там открываешь любую таблицу классно и читаешь что это такой такой не влезает даже если тебя три монитора очень широких Ну то есть как бы Возможно есть какие-то Хотя по рекомендации или что-то такое Ну вот я могу рассказать про наш опыт там вот в хэппинг последних лет Мы учимся мы не можем похвастаться какая-то микросервис архитектур но у нас Монолит в котором всё Мы стараемся делать по модулям и следить за связанностью соответственно Мы учимся докомпозировать стейт чтобы когда-то в будущем возможно раскидать это всё по микросервисам и нам очень важно Вот возможность коррелировать сущности по эдишнику вот прямо это ну это выходит Очень красиво Очень прикольно никаких внешних включений надо Да вот не явные внешние ключ в виде того что просто идентификатор совпадает поэтому мы ценим её виды и мы почти всегда мы по умолчанию их используем В девяносто девяти процентов случаев но у нас есть например какой-нибудь evenstore там такой самописный там ивенты идут подряд и вот там используется автоинкремент потому что ну просто там и в каких-то других еще аудит логах еще где-то используется автоинкремент потому что ну просто свойства и до там нам не потребовались по каким-то причинам вот плюс автоинкремент как я показал всегда можно сконвертировать вид если потребуется это как-то Ну понятно Это не очень всегда легко там всё но всё равно теоретически можно вот в обратную сторону сложнее Хотя тоже можно но если есть внешние связи уже сложно будет короче просто для юита Да чтобы сконвертировать и завтра эксперимент вид можно написать такую функцию Когда инкременту будет давать всегда один и тот же вид конкретного типа и можно так всё как бы перенести туда в обратную сторону так тяжело а Короче я бы сказал так что Судя по нашим бенчмарку такому Ну довольно примитивного с одинаковыми весами в целом а можно использовать и версии 7 по умолчанию использовать там какой-нибудь условный вид версии 5 только в случаях если вот как мы пытаемся оптимизировать большие импорты и не делать лукап по имейлу Ну а в случаях где ни одной свойств вида не нужно нужно например хорошая Там запоминаемость читаемость можно использовать автоинкремент потому что он вот мне кажется знаете вот все бенчмарки в конце которые были они показывают что между версии 7 автоинкрементом нету критической разности по производительности поэтому остаётся единственный а-а аргумент в пользу автоинкремента - это то что его легко запомнить ну плюс вот соображения которые здесь высказали до этого э-э А во всех остальных случаях я по умолчанию использовал V7 Ну вот мы это дальше моя субъективное мнение началось Да ну вот как-то так так еще вопросы так можно сразу Вопрос Раз два три Здравствуйте спасибо за доклад хотел уточнить не увидел сортировки графика по сортировке кто из них выиграл там 1 7 и второй вопрос Когда мы говорим о едах и автоинтриментах это суррогатные ключи А по поводу бизнес ключей Я помню у меня был холивар с одним коллегой что суррогатной причине не нужны есть бизнес значение и якобы Используйте его в качестве поиска конкретной записи Вот вы на этом не сделали Какое у вас всё расскажу во-первых про сортируемся по-моему довольно много рассказал как раз про каждый день У нас был первый же раунд про сортировки ещё раз повторю Да у нас есть версии 1 Не сортируемый потому что метка времени наоборот записано там условно грубо говоря секунды в начале а год в середине а-а Ну ют версии 6 исправит ошибкой от версии 7 идет дальше и делать вообще нормальный вид где юник зашит соответственно он сортируемый вот хорошо адекватно сортирована в tinment Child насортируем V4 V5 нет потому что они один Случайный другой основан на хеш- на хеш-функции соответственно там никого сортировки речи не идёт вот поэтому V7 в этом плане не проигрывает автоинкременту вот отлично замена А следующий вопрос про суррогатный не суррогатные ключи здесь мне кажется всё упирается в то что он вот например да мы будем хранить с вами в качестве там каких-нибудь юзеров э-э первичного ключа в качестве возьмём e-mail и он может вот такое быть Вот такое он не сортируемый у него куча там проблем и э-э Ну с точки зрения там построения индекса по нему и так далее а поэтому в этом случае если нужно именно использовать вот какой-то такое поле из предметной области но при этом хочется хоть чуть-чуть помочь БДМ то можно взять как раз её опять Вот мы так делаем для наших респондентов у нас система отвечает за ну там опросы и потом всякие метрики строят и вот мы берем просто вид версии 5 от email с фиксированным спейсом получаем юи то есть мы как бы автоматически нормализуем наш email к одному формату известному нам юиду добавлены Профит от этого это то что мы можем коррелировать другие сущности в нашей системе Поэтому идентификатору с этим респондентом соответственно мы здесь как бы убиваем Ну полтора зайца Славно то есть мы э используем яиц что нам привычно и удобно в базе данных особенно там Да есть у нас пост какой-то А во-вторых мы э как бы используем ключ из предметной области который Ну как бы нативный e-mail да он там действительно является первичным ключом но при этом приводим его в формацию рогатного и э-э и мы можем теоретически наш репозиторий так написать что мы будем передавать в качестве идентификатора email но под ка в его реализации будем просто брать от него uid версии 5 не получаете вид и уже как бы на уровне деталей реализации использовать Юнит в качестве первичного ключа то есть вот так можно обойти этот вопрос поэтому есть версии 5 у нас присутствовал в наших раундах Потому что его не стоит игнорировать Это прикольная штука в определенных сценариях Вот Но к сожалению он проигрывает по характеристикам по бенчмаркам в БД Так что вот такой мой ответ да вот молодой человек еще или у нас всё уже или нет ещё время есть И главное Помнишь да то что он будет выбрать автора лучшего вопроса да я помню всё я тебе напоминаю ещё раз да продолжаем приз получится Как вы можете объяснить автоинкерментом и автоинкремент вы какой брали нумерик или там in8 который как int 8 же он занимает в два раза меньше чем место чем ЮИТ 16 да я брал я брал обычный int не Big int Вот Но в принципе я даже получается фору Дал какой-то еще дополнительное ингредиенту разницу С каким ей там и в каком бенчмарке где скорость вставки смотрел или что или скорость там не бенчмарк там был размер индекса в зависимости от количества записей я вот бы очень удивлён в моих тоже оно в два раза меньше занимало Потому что я когда-то оптимизацию в BD проводил из юитов в интерьер конвертил потому что там было миллиардная таблица и очень много юитов было очень много индексов и в разыгрываются всё это на тот момент шевелилось вот а может быть в 15 версии что-то исправили что-то оптимизировали Я не знаю опыта 12 версия Да может быть еще я хотел провести более чистый бенчмарк там условно взять какой-нибудь Яндекс Клауд Ну чтобы не было Ну вот меньше каких-то внешнего шума как у меня на макбуке Ну мало ли что я вообще конечно всё выключил перед тем как запустить по максимуму но очевидно я не могу выключить совсем всё Вот э-э Но к сожалению не успел Поэтому меня немножко такой грязный тест но всё равно он общую динамику показывает здесь я не думаю что будут кардинальное отличие э-э так глубоко я не выяснял Почему именно в XV версии Вот Но поскольку проект публичный на гитхабе то в принципе можно это всё взять поднять попробовать Э там в докер добавить другие по версии постгалюса по сравнивать ради интереса вот у меня всё время будет я тоже сам что-нибудь из этого сделаю потом на канале пых выложу результаты вот так что можно поэкспериментировать вот прям Четкого ответа на вопрос нет Да я тоже ожидал что автоинкремент будет еще ниже по размеру индекс это было бы Логично собственно еще один вопросик такой более холиварный на самом деле А почему не добавить бы в этот Баттл например юлит и рассматривать его вместе с тем же ну в противовес например видов у него есть тоже преимущество по сравнению с тем же уит Ну да это просто вопрос про то что можно расширить доклад добавить другие технологии вот но и просто сюда не вошло Я знаю про такое идентификатор Да но я пояснил до этого что Юнит это всё-таки такая вот прям классика незыблема для меня Я помню что улит он по-моему обратно его можно сконвертировать вид и там обратно да То есть можно охранять и он подойдёт больше для распределённых как раз таки систем когда мы генерируем соответственно в разных местах Ну например в разных городах или распределённые там системе А чем виды тоже подходят для распределённых систем Зачем улит в принципе лучше у этого мы исключаем даже вот эту вот ситуацию в том что у нас юриды между между разными DC например совпадут так в виде это тоже вполне особенно в седьмом То есть у нас там Юникс таймс Темп он занимает несколько бит а потом Рандомные компоненты гигантская просто в отличие от V1 там вполне тоже я в нем очень уверен я думаю что улит он примерно так же и генерирует на самом деле как V7 но Согласие это можно рассмотреть повнимательнее изучить просто это было вне сколпа этого доклада А типа Да я в курсе про такой идентификатор Давайте ещё один вопрос вот молодой человек руку тянет будем заканчивать Добрый день Меня зовут Иван А я бы хотел немножко про про персональные данные если мы начинаем использовать бизнес какие-то да индификаторы Как email нас могут попросить просто их удалить И мы потеряем это уникальность например ut5 да нас от этого спасает мы не должны его чистить вот а второй момент мы все понимаем что номер телефона email это не такая привязанная сущность к использованию которую можно изменить или удалить пользователь отказался от номера телефона а потом этот номер телефона дали другому пользователю и не получится ли Так что пользователь новый зайдёт у нас использует в пятой версии получат все данные грубо говоря предыдущего Да здесь надо безусловно это всё учитывать просто Ну вот так совпало что в нашей предметной области там эти респонденты они генерируются на момент исследования и нам это неважно абсолютно То есть у нас вот сейчас нам прислали структуру компании которую мы исследуем в которой правовые исследования и вот это актуальная информация и она действует только исследования поэтому у нас это работает глобально хранить юзеров поют 5 там ну email наверное еще куда ни шло потому что он вряд ли переходит от пользователя к пользователю вероятность низкая а вот с телефонами да это уже было бы не очень правильно делать Ну да тут как всегда нужно оценивать всякие побочки которые могут возникнуть Спасибо за комментарии Итак давай сложный выбор много вопросов было да Выбирай одного обижай остальных Да так так так так так так так так так слушай ну а Саш уже получал нет Саша выступал как спикер это я знаю Да он видишь не хочет получать приз не хочет хорошо и он не вопрос задавала дополнял доклад но я бы наверное мне очень польстило что джавист зашел к нам в трек он по правде уже ушел всё отлично Вот я бы ему вручил к сожалению он не ушел и тебе благодарность от нас как организатору Спасибо тебе за твой контент видишь Сколько вопросов было вообще мне кажется сейчас тебя там ещё дальше будет мучить Вот и набирайся"
}