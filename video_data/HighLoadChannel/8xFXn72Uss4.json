{
  "video_id": "8xFXn72Uss4",
  "channel": "HighLoadChannel",
  "title": "Как спроектировать решение для tagging search и не ошибиться / Александр Токарев (DataArt)",
  "views": 1104,
  "duration": 2152,
  "published": "2019-06-03T08:59:51-07:00",
  "text": "сегодня мы поговорим о такой простой 1 ищи как поиск по тегам фацетный поиск и все около того мы обсудим вообще что такое теги какие они представляют нам вызовы в части баз данных как выглядит типовые архитектуры как самих приложений так и моделей данных и как с помощью фацетные навигации структурировать по ним и вообще как бы поиск информации я расскажу вам что получилось у нас в процессе изучения этой темы собственно приведем какие-то общие выводы и я с удовольствием отвечу на ваш вопрос . после конференции я скину тестовые наборы данных и все вот вещи которые мы будем проверять смотреть их все можно будет прогнать на своих базах данных и так что такое теги нг но собственно как бы те ging это просто некое слово она присваивается к любому тэги раму объекту она выбирается в основном неформально и задается либо создателем либо тем кто просмотрю информации если она задается тему то просматривать информацию это называется фолькса нами а слова фолк народ соответственно если она задается вот как в этом случае как бы и создателям и набор тегов ограничено это называется таксономия самом деле как у вас устроен пользовательский интерфейс это очень сильная определяет архитектуру вашего приложения то есть классическим примером навигации по тегам является instagram там все очень прямолинейная щелкнули по тегу все просто поехали более сложным примером навигации является stack overflow где есть подобие никого облако тегов соответственно где из конкретного тега мы можем провалиться уже в список ты гяру им их объектов и получить в правом углу некое подобие фацетный навигации статистикой и далее можно уже сделать drill-down до самого конкретного объекта есть более сложная форма навигации и часто строят на тэгах часто строить не на тэгах это процентная навигация когда группа тегов объединяются фацеты причем фацет и между собой они объединяются в рамках н да и соответственно в не есть теги который группируется и тут уже налагается условия он какие достоинства вообще как бы решение на базе тегов что во первых лет теги они отражают словарь пользователя и это позволяет строить некую внутреннюю аналитику все что построено на тэгах она очень гибкая потому что сам пользователь добавляет теги создает и они позволяют очень многомерно описывать наши объекты на самом деле все недостатки тегов они абсолютно логичным образом вытекают из их плюсов то есть теги можно не правильно написать можно использовать множественные формы слов можно используется составные слова более того теги можно присваивать неоднозначно они могут быть настолько персонализированные что только тот кто их присвоил вообще понимает о чем это ну и собственно довольно важная проблема для тегов это синонимы и так это всё создает нам вызовы какие то вызовы это вызовы производительности это вызовы сложности запросов это неконтролируемый рост база данных и необходимость какой-то дополнительный в ее maintenance а на самом деле любой разработчик своей жизни должен сделать три вещи он должен написать хеллоу ворлд посадить дерево и конечно же должен написать свой трейдинг search поэтому мы сейчас обсудим как сделать его адекватным и быстрым как бы чтобы обсуждать адекватность чего-то всегда должна быть модель попытаемся вывести модели зрелости преимущество техника стоит в том что он на самом деле когда его начните сделать его невозможно не сделать он получится но в начале он будет очень нелепым и вот как нельзя более лучше подходит эта картинка под описание поэтому именно на основе пингвинов мы попытаемся построить некую модели зрелости и так архитектурные паттерны в целом их можно разделить на 2 группы когда у нас решение по трейдингу находится в реляционной базе данных мы общаемся как бы для получения неким и скверам и у нас есть некие таблички по которым все раскидано либо решение на базе полнотекстовых серверов причем неважно где этот полнотекстовые сервер находится либо в базе данных либо снаружи и есть некая общая сущность документ соответственно обычно все начинают с базы данных потом ходит полнотекстовом поиску так тестовые данные первое за что я сел когда стал готовиться к этому доклады по дому сосны пишу классный генератор но потом я понял что во-первых теги будут ненастоящими будет не настоящее распределение получится полная ерунда поэтому я использовал stack overflow у него есть прекраснейший интерфейс прекрасной 5 для выгрузки данных я настоятельно рекомендую всем им пользоваться для проверки любых вашими почести вообще каких-то выводов пал трендов в информационных технологий и так мы будем извлекать сущности посты теги и привязку поставка так мы возьмем данные за 2 года у это 43 миллиона постов 8 миллионов тегов соответственно будет около тридцати тысяч уникальных тегов и по ограничением stackoverflow я заметил что максимальное количество тегов на один пост это 5 и максимальная длина ты гайд 30 любое обсуждение производительности она бессмысленна без обсуждения железа но я взял такую маленькую скромный виртуальную машинку 4 ядра 4 гигабайта памяти всего и один гигабайт на шарик пул города и так собственно тот самый интерфейс тот самый stackoverflow что он предоставляет на самом деле он выдает 22 таблицы вот все это прямо наверх форме видно пол ключевым слушайте можно просто писать нормальные человеческие ускорили все будет замечательно работать то есть единственный проблема стоит в том что по выгрузке каждых 100 тысяч записей придется вводить captcha но в принципе это не самое сложное как бы помните я говорил про синонимы вот когда я смотрел что же есть у stack overflow я обнаружила табличку так синоним и вот например они решают так вот все sharp da isev шарф собственно то есть даже они с этой проблемы столкнулись и так типовые модели данных чего все начинают все начинают классической де нормализованные модели у нас есть теги у нас есть документы есть табличка привязки на самом деле очень очень очень быстро вы столкнётесь с тем что она перестанет работать и тогда перейдете к следующей модели когда у нас есть документ и есть список тегов документов и без всяких справочных табличек на самом деле через некоторое время и эта модель станет все равно будет много join of и тут уже начинаются игры с и нюансами субд и начинают использоваться встроенные типы данных сложные да это массивы в том или ином виде в чем состоят нюансы массивов как только у нас появляется некая зависимость от b до то надо понимать что в каждой базе данных они устроены по-разному посмотрим на них как они устроены в подписи иракли собственно создаем ворот ли некий так создаем массив тегов и говорим массив ты будешь у нас в таблица но есть некий синтаксический сахар наличие которого уже намекает о том что что то не то очень много буков если мы посмотрим структуру табличек до список их-то мы и в принципе ничего не увидим нет никаких данных если мы потом список индексов мы увидим что на самом деле табличка есть ее просто не видно стандартными способами ты на самом деле ворот ли все встроенные типы данных это на самом деле самые обыкновенные реляционные таблицы но это дает нам нити плюс мы можем построить на них индекса потому что в подписи есть джейн яндексе ворд ли джон индексов нет именно в для встроенных типов данных как устроено это в пол эгриси есть табличка в ней тоже есть массив добавляем какие данные в этот массив дальше начинает сам интересным возьмем и вычислим в каком файле типа сброса находится наша данная табличка вот берем и в этот файлик смотрим вот он размер страницы по адреса 8 килобайт а вот на самом деле наши данные то по тегам то который мы записали то есть на самом деле в пастбище сложные типы данных они сделаны очень часто они действительно лежат в одном и том же блоки ну как всегда дьявол кроется в деталях если почитать документацию по толстую и выкинуть всякую шелуху то окажется то что если у вас и данных больше чем 2 килобайта они точно так же как и ворот ли утекут в отдельную толсто блицу но я слабо сам не верю что тегов будет больше чем на 2 килобайта в какой-либо сущности и наконец и четвертое решение да то есть это когда у нас есть данные которые находятся в формате удобно для полна тексту поиска это либо какой нибудь джейсон либо например формате stack overflow соответственно как бы это вот первой версии который мы рассматриваем и будем рассматривать когда полнотекстовый поиск у нас находится в суде и так с точки зрения вставки то есть очевидно что реляционная модель с точки зрения вставки что вставить все теги и stack overflow за четыре года все теги все посты занимает одна тысяча секунд соответственно ожидаемый что полнотекстовый модель заняла ровно в два раза больше но тут видно есть некий выборов по сложным типам данных это какой-то странный косяк оракла то есть я не знаю почему то есть на самом деле я думаю для остальных баз данных в соотношение примерно такую реляционные в два раза быстрее чем полнотекстовая что касается объем с объемом все очень интересно если посмотреть кто на самом деле 1 миллион от то есть восемь миллионов тэгов они занимают 1 и 2 гигабайта плюс-минус и там и там то есть разница между моделями хранения она видна только в соотношении индексов и данных и такой маленький объем говорит о том что на самом деле и то есть очень хороший повод подумать об in memory решениях если за четыре года как бы все помещается в гигабайт рассмотрим типовые сценария который у нас есть при работе с тренингами из фаз этими вещами с отец самая простая вещь это просто поиск по ящику вытаскивание всех тегов то есть очень простые запросы по факту как бы просто join необходимых таблиц и мы даем айдишник что тут важно понимать что для тех вещей где у нас есть в явном виде реляционные таблицы мы высоко вытаскивай столько же строк сколько у нас тегов для сложных типов данных и для полнотекстовым и вытаскивать всегда одну строчку чаще всего она разбирается на стороне сервера ну потому что как бы в этом как раз весь прочитай как бы соответственно поиск по одному тегу и вытаскиваем тегов тут уже видно что полна тексты поиск он в среднем в два раза быстрее реляционной модели данных потому что большая часть времени уходит на join и ну вот собственно пример поиска по этим самым тегом вот уже обратите внимание на сколько б объем не стал запрос то есть чем больше у нас появляется тегов тем большая дальше как бы становится sql соответственно с точки зрения полнотекстовых серверов да то есть насколько красиво и эстетично это все выглядит то есть мы просто пишем джейсон текст контент и angular джесс и все замечательные находим вот собственно как бы по графику видно что зависимость она примерно сохраняется то есть фред среднем полнотекстовый поиск он быстрее реляционной иди нормализованной модели где-то около в два раза самом деле как бы самая сложная вещь она начинает тогда когда тегов больше одного то есть происходит неконтролируемые увеличение запроса и соответственно все это очень не удобно для кода генерация куча джойана в кучу всего даже иди нормализованным модель данных уже перестает спасать возможно у вас в команде случайно забрел человек который знает что такое иску или и не верит в р.м. тогда он породит вот такой запрос который на первый взгляд будет абсолютно непонятен но он решает проблему увеличение количества джонов но и он очень удобен для куда генерации когда мы меняем каунт в соответствии от количество тегов и добавляем секций нормальных оптимизаторов это очень серьезный дает скачок производительностью сеем реляционная модель данных можно раскачать как бы в два-три раза за счет такого трюка нормализованы модель применяется точно такой же подход но вся красота она как бы как я говорил с полнотекстовых решениях то есть мы просто пишем java script in deine hand and потому что and это просто зарезервированные слова полнотекстовые языка запросов и сразу же видим радикальный скачок по скорости то есть насколько деградирует реляционные прочие модели пол сравнению с полнотекстовым поиском ну и последний типовой сценарий это облако тегов собственно облако тегов да это просто полный cold на самом деле его ускорим конечно же никто не считает его всегда кэширует и наращивать инкрементальный ну вот просто интересно было сравнить его же можно описать тремя способами на всех модель cut выкинуть табличку документы на штаны не нужно или в случае с полна текстами моделями данных нам придется конечно же распарсить наш текст смотрите у нас загружены данные из stackoverflow с 2008 по 2012 год как вы думаете как определилась а тройка языков программирования есть какие нить и версии но вот первые три места кто-нибудь угадает ну вот практически до но есть нюанс на первом месте сишарп на втором месте java и на третьем месте печь пиф собственно с точки зрения скорость этот результат вполне предсказуемых полнотекстовый поиск в среднем в 2 раза медленнее собственно если все это свести в некую таблицу да то получается примерно следующее что полнотекстовые модели даже в сервере баз данных она ощутимо быстрее проще понять единственное что и в чем ее проблема эта маленькая скорость вставки соответственно и то есть если же не хочется зависимости от базы данных или не хочется притаскивать полнотекстовые средства то конечно же лучше де нормализованная модель потому что она такая очень независимая итак наш случай нас есть замечательный enterprise у нас есть такой некое клиентское приложение там 10 тысяч запросов в секунду есть вот классической архитектуры для энтерпрайзе на самом деле есть слот балансир есть какие-то апликэйшен и которые считают бизнес-логику в само собой memory кластер и висит oracle и его резервный копит до таггарт собственно наш заказчик он и сначала отказался от полнотекстового сервера не хотел усложнять инфраструктуру поэтому мы сразу шли на решение что будем делать фацетные поиски теги и все это будем делать с у б.д. какие наши данные собственно все те же сущий посты и теги привязка значит за два года у нас примерно 3 миллиона триггерных объектов 42 миллиона тегов около 100 тысяч уникальных тегов и где-то 15 тигров на объекте максимально длина тега 50 то есть по факту мы в четыре раза больше stack overflow на как бы при такой же ситуации с точки зрения архитектуры у нас микро сервисной архитектура нас есть порядка 40 микро сервисов есть некий tracking service который отвечает за вставку который отвечает за поиск его его потребляют различные bpm системы you войну и другие сервисы то есть от других сервисов на него приходит где-то три тысячи запросов в секунду а отрываясь 7000 именно из-за фацетный навигация я к сожалению не могу показать вам настоящий интерфейс поэтому я сделал вот этот шедевр в пензе вот то есть это последняя версия как бы текущие того что есть сейчас я расскажу отчего мы к ней пришли что мы можем то есть мы к любому поиску можем добавлять некий темплейты это набор тегов который применяется обязательно к поиску мы можем взять абсолютно любой так вот там часто взят name и выбрать его сделать уточнить результат по полнотекстовый поиск мы можем выбрать какой пользователь последних меня мы можем 2010 и внизу секция not мы можем сказать что в данном поиске нет такого так именно не значения t года а вот нет купонов конечно же это все снабжена фацетный навигации слева и само собой какая штатная навигация биспинга и так как все начиналось вначале у нас появился тренинг и нам сказали нужно как в инстаграме ну потому что просто понятно пользователям это нравится и мы учим умной мы сразу же пошли с модели с полнотекстовым поиском в базе данных oracle мы сделали такой замечательный джей сонечку нас были просто простые т.е. все было хорошо однако через некоторое время пользователи поняли что в тегах начался творится бардак ну потому что как я уже сказал тут так много проблема я их перечисляла и пользователя лишили что теги надо типизировать надо добавить тип тега у нас было самый свежий тогда уроков 12 1 но к сожалению выяснилось то что в нем индексы про джейсона работали хаотично поэтому время запроса скатился до 1 2 секунды и это взывала некую недовольство поэтому что было сделано мы вынесли поле тип тегов в отдельную табличку чтобы он не мешала работе джейсон индексов и собственно снова стала все хорошо через некоторое время возможности опять стало не хватать потому что приложение росло то есть мы помаленьку приходили к тому пользовательскому интерфейсу разработчики попросили нас а сделайте нам view где есть раз паршин и итоге мы будем классные запросы писать сами на самом деле оракал он подхватывает полна тексту индексы даже к из-за распашную джейсону но подхватывает примерно 80 процентах запрос стала одну секунду ну в принципе для энтерпрайзе это достаточно как мы решили эту проблему да никак мы не стали ее решать мы решили что надо просто переделать юань как на самом деле когда пользователь фацет нам поиски выбирает свои нужные объекты для поиск как только они у него появились и за одну секунду ему этого достаточно он их видит а вот эти циферки которые отнимают больше всего времени то есть всю кишку фацет двигаться мы просто ешь считаем асинхронно и то есть она занимала тогда примерно три секунды и пользователь просто не видел что что-то делается значит в какой то момент времени у нас начались странные проблемы у нас внезапно упала производительной вставки где-то процент на 20 и в абсолютно произвольные моменты временем стала наблюдаться деградация поиска где-то на 40 процентов мы подумали что с этим надо что-то делать и решили разобраться знаете что мы обнаружили мы обнаружили что на наших таблицах ты king появились а полнотекстовых не платит свои функциональные ориентированные индексы и функционально ориентированный bitmap индекса кто-то выпрашивал прямо в индексах значение из джейсон и конкретных тегов мы прошлись по наш команде обнаружили что на данной системы поиска группы пиарщиков собирает в луки ри кучу-кучу отчетов определяя поведение пользователей ну в данном случае как бы было принято самое очевидное решение что отчеты надо убирать потому что две секунды на запрос неприемлем поэтому взяли сделали деталь job и собственно прекраснейшим образом унесли все это в хранилище жизни она очень сложная и пользователем очень понравилось на самом деле тегирование ну их очень волновал вопрос кто же убрал наши теги и так у нас появилось историю суть в том что 20 процентов тегов по эта история оказалась не активно это привело к появлению полей valid from очевидно вылету собственного опять скатились к одной секунде но в принципе как бы это все разруливать но пользователям очень нравилось тегирования они подумали что стенах можно делать пор что в тегах можно использовать те самые not in теги ну собственно надо понять кто испортил теги и конечно же когда тегов много беспроцентной навигацию уже не как надо быстро по всему этому облаку ориентироваться ну и соответственно раз данных много нужен пейджинг ну соответственно мы получили время запросу около четырех секунд это было ну вообще никак соответственно оставалось очень мало времени до релизе надо было принимать вертикальное решение что мы сделали мы взяли старую добрую ненормализованную модель сложили в нее только текущее значение собственного то найдеш ник объекта и вот значение нашего так мы убрали весь парсинг джейсона мы убрали все раковые индексы по джейсону мы успели переписать в юшку и запросы на стороне джавы которые использовали все тонкости и фичей наши знания полнотекстовые индексом так как времени на кндр не хватало мы сделали эту де нормализацию через триггер соответственно передохнули время свернулась 0 5 секунд стало все хорошо мы пересмотрели наши решение и на самом деле подумали да и ладно нормально выпилили триггера оставили java и проанализировали те теги по которым на самом деле чаще всего происходит полнотекстовый поиск их 2 это имя объекта на удивление и его описание и собственно взяли построить только по ним полна тексту индекс в отличие от jason полнотекстовых индексов просто полна текст в яндексе ворд ли работает там есть такой механизм индекс комбайн который позволяет адекватно использовать одновременно запроса кто то есть в одном запросе два абсолютно разных типы индексов ну собственно как бы это нам дало еще некий профит почему я так говорю про яндекса вот самом деле типовой индекс а там без детализации он выглядит так есть типа объекта есть ибтига есть его значению но он весит там вот как бы на тестовый на маленькой базе 4 гигабайта ну вроде бы ни о чем на самом деле можно применить еще некую магию и получить сделать яндекс совсем маленьким и получить некую скорее не в скорости ворот ли есть такая фишка компрессировал индекса обычно что есть в яндексе есть его все значения в не уникальным и ссылка на строчку ворог ли можно создать так называемую компрессию когда мы создаем словарик значение индекса о которой находится в начале блока а на него ссылаются то есть а в самом блоки данных есть только ссылки это позволяет радикально убрать повторяющиеся значения так как тегов плюс-минус типов не очень много плюс-минус не очень много типов объектов мы получили следующие значит компресс 2 что такое компресс 2 это не уменьшить в 2 раза это то что надо создать префикс ную таблицу по первым двум полям индекса соответственно мы получили уменьшение индекса из-за этого на 40 процентов само собой это не бесплатно мы уменьшили скорость вставки на одну секунду на 1 процент это не о чем и абсолютно за бесплатно мы получили семь процентов прибавки к скоростью соответственно если подытожить как бы вот это вот нашу текущую архитектуру наш проект а что какие советы из него можно делать делайте асинхронный интерфейс он очень помогает скрыть нюансы производительности соответственно и нормализованная теги ангел модель работает на нормальных на серьезных наборов данных соответственно и сочетание компенсированных by three индексов и полнотекстовым диксов она работает как бы yabla характеризовал эту модель с точки зрения пингвине мачете moodle но в принципе как то так мы мы летаем мы почти летаем но как бы если не крутить педали она конечно же все упадет какие наши дальнейшие планы ворот ли 18 появился встроенный в ядро фацет search мы не знаем во 5-ки как он работает на больших объемах прям нога пальцем доступе но я сделал некий примерчик как это все работает мы говорим мы этим фацетный поиск и определяем просто наш список процентов где мы делаем mapping между полями каких угодно типов и названию процентов соответственно делаем табличку например данном случае у нас будет табличка с полем сил об в которой мы сложим просто вот такие xml т.е. если посмотреть видно название полей в xml как они совпадают с именами фацет of и создаем индекс говорим надо создать yandex вот с таким вот вы фацетный mma пингом можно одним из старых вариантов построить fat этой и на плоской реляционные структуре когда нет соответственно как бы xml а есть просто столбцы надо построить mapping между столбцами в полна текстом яндексе и и столбцами в таблице соответственно при создании индекса полнотекстового мы говорим используем mapping между столбцами таблицы полна текст индексы используя наши заданные фацеты и работай как выглядит сам поиск очень просто мы говорим выбери к нам все ковры а данные по коврам сделай два фацета один по производителю и при этом нам надо чтобы он упорядочиваться по убыванию и по количеству и по цене чтобы при этом он цена была по возрастанию и собственно ворот возвращает вот такой замечательный xml чек с нашими фацетом и все замечательно придрочиться заработать реально очень быстро очень круто какие наши будущие планы более глобальным сенатора классе очень хорошо и здорово но не будет непонятно куда мы на самом деле очень хотим уменьшить все равно время запросы мы понимаем что на текущей архитектуре мы практически исчерпали все возможности но мы решили попробовать еще одну вещь мы решили попробовать in-memory опция соответственно она стоит денег потому что это oracle но путем ни значительных инвестиций в лицензии и буквально 3 дней разработки чтобы понять как это все работает как это готовить мы получили ускорение по скорости в четыре раза это очень хорошо на самом деле ну собственно проекты я буду рассказывать на другой конференции и я буду про этом попытаюсь может быть рассказать на конференции на хайло де за доклад на путь высушить обсуждений вызвало очень бурную реакцию соответственно как же выглядит хорошей правильный поиск нас это очевидно должно быть решение на базе полнотекстового поиска да он должен быть либо в базе данных либо это должен быть отдельный сервер но по причинам указанным ранее я против того чтобы он был в базе данных потому что базы данных все-таки менее масштабируемся специальные заточенные сервера давайте посмотрим как же он должен выглядеть случае если мы используем отдельный сервер на ком серы будет смотреть мы будем смотреть конечно же на apache доллар почему потому что в нем есть специальный язык для фацетный навигации но и потому что я просто его люблю и так мы будем работать в режиме менеджер схему менеджер схемы это тот режим в котором мы жестко задаем схему данных ключевое здесь вот это единство строчка мы создаем полис типом так мы и задаем ему тип string и говорим будь мульти велю то есть мы реализовали третью модель с вложенными типами данных на базе полнотекстового поиска еще раз напоминаю наши цифры 3 миллиона постов 8 миллионов тегов и соответственно что тут я сделала я взял сознательно в два раза уменьшила характеристики машинки ну он же должен быть быстрее солод и что мы получили собственно вот наша запросу смотрим премьер смотрим поедишь нику то есть кино холодном кэша на самом деле она работает не так и быстро то есть на холодном конечно 06 секунды для поиска по одесскому на самом деле это весьма грустно то есть вся фишка полна тексту серверов тогда когда у них разогревается кэш когда индекс нормально работает соответственно запрос по одному тегу вот тут уже как бы я его еще сложнее на добавил слой фильтрация добавил сортировку я добавил пиджин то есть это все очень удобно классно делается и он в принципе среди и 112 тысяч записей нашел все джаббы очень быстро самое интересно как я уже говорил это тогда когда у нас есть несколько тегов как мы вы помните деградировала в случае поиска через полна тексты сервера баз данных очень сильно что же будет здесь а тут во-первых ну как я уже говорил очень красиво это просто все пишется и деградация скорости не наблюдается абсолютно то есть упал на текст из серверов которые заточены под это проблемы набора множество тегов не существует соответственно облако тегов облако тегов это на самом деле классический пример фацетный навигация у солларов консольки нет для этого ни чего поэтому я написал суток сверх я говорю что мы будем использовать фасадную навигацию в качестве фацеты мы будем использовать поле т.г. а для расчета самого flats от и мы будем использовать каунт собственно вот за одну секунду помните там было 40 мы получили облако тегов смотрите него внимательно вы помните надеюсь что облака и те языки нет ли никакой разницы с тем что было до шарпа нету куда делся sharp потому что у солнца есть такая штука называется кенозеро которая делит наши слова на части таки найти рф и дефолту sharp за символ не считает собственно вот язык до фацет то есть как бы старый язык где все задаются большим огромным параметрам это вот пример так называемый range фацеты когда данные делится на кусочки как боясь и джейсон модный там еще очень удобно там все очень четко очень красивый очень понятно как эти фацеты делать что же касается производительности я взял пример когда у нас есть горячие как бы хороший разогретый кэш полнотекстового сервер на базе данных и полнотекстового сервера ссоры и видите то есть сравнивать их по факту практически невозможно то есть когда идет разговор о выборки нескольких тегов разница на огромные порядке можно сравнить выбор по анечка можно хоть как-то пытаться сравнить выбор по одному тегу то есть выход один что если что-то надо сложная без полноте кто серверов от без базы данных не как на самом деле существует очень сложной архитектурой фацетный поисков для крупных интернет магазинов каталогов но они как я уже сказал они определяются настоящим хайло дам и определяются нюансами предметной области я подозреваю что что-то такое мы сегодня увидим в 5 часов на докладе авито про эволюции их поиска но это не наша история итак выводы на самом деле в любую модель надо проверить и померить конкретно ваших условий я допускаю что у кого-то будет тормозить полнотекстовый поиск и будет классно работать реляционная модель на самом деле надо верить в уникальные стежки вашей базы данных не важна эта реляционная база данных или полнотекстовый сервер есть один нюанс надо понимать как работает эта фишка иначе вы получите проблемы с вложенными таблицами oracle и или сolor отрежет половину ваших тегов конечно же общие рекомендации таки если у вас нет условий нет фацет навигации возьмите ненормализованную модель на самом деле все будет хорошо если у вас появляется у хоть что-то как-то сложно сразу на начинается полна текста сервера и никогда не повторяйте распространенные ошибки думаю что по тегам никто никогда не делает аналитики делают и много ну собственно всем спасибо за внимание очень рад что все пришли я с удовольствием отвечу на ваши вопросы всего за доклад не пробовали ли вы в наверно индекс засовывать не просто значение тега но и его тип через какой то развели зарезервированный каким образом сэкономить на запросах на join ах ну вот смотрите вот этот самый индекс который показывал там как бы был тип объекта как раз тип т.к. и значение то есть именно вот этой был яд мы пытались а и вот именно как бы сделать целиком индекс чтобы даже как бы вообще не было не было никаких джонов но в данном случае происходило очень сильной деградации по вставке потому что именно из-за нюанс в предмет области надо было бы тогда в яндекс тащить ну еще полей так 8 то есть особо смысла бы не было то есть пробовали да не взлетела спасибо за доклад и за такой необычный обзор потому что как правило заканчивается последним пунктом вставим полнотекстовый поиск все работает накатываем в продакшн вопрос такой я просто немножко в комиксе работал и пассивный поиск ну там у них одно из главных вот и вот мне как-то прилетел такая задача это вот эти т и которого группируем слева ранжировать то есть как вот вы в текущем что-то выше поставить что-то ниже поставить на одной страничке это выше на другой страничке ниже как вот вы в текущей модели который сейчас находится смогли бы выполнить такую задачу как вы решили на самом деле то есть вот я вот как бы нарисовала структуру таблиц конечно же одна условная да то есть я сама собой кабель для как бы вот этого мероприятия все это проверял но настоящая структура который на продакшен там есть обвес мета-данных еще табличек примерно 8 которые определяют для какого типа объектов можно какие теги применять то есть именно те самые веса то есть где вот эти фацеты они встанут друг на друга при чем как бы вот эти параметры они есть как в рамках конкретного тега так и на самом деле вот этой группы fat центов то есть сторона как бы для определенного типа объектов она может быть 1 а там где эта страна не нужна она может быть под словом м2 то есть вы это задача решили да спасибо здравствуй спасибо за доклад у меня вопрос по поводу ссора вас проблема со спицы в лобби то было то есть сишарп то есть не портился а я так понимаю это особенностью цены вот и кенозеро как можно решить эту проблему то есть , полностью переиндексация с но с новыми настройками таки на это ну да ну то есть как бы это вот то о чем я говорю что надо понимать как она работает и то есть как ни смешно это звучит теги надо знать то есть да как вы делаете таки назир прописывается в конфиге и все работает само по силам собственно наверное вопросов больше нету всем спасибо за внимание"
}