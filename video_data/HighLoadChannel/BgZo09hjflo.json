{
  "video_id": "BgZo09hjflo",
  "channel": "HighLoadChannel",
  "title": "Современная архитектура Android-приложений - Archetype / Степан Гончаров (90 Seconds)",
  "views": 4471,
  "duration": 2139,
  "published": "2018-01-16T11:58:00-08:00",
  "text": "меня зовут гончаров степан я ведущий разработчик компании на энди секанс офис которой находится в сингапуре вот и чем занимается компания мы так называем платформа для производства видео это можно как бы представить себе как uber где вместо пользователей которые пассажиры это заказчики видео с вами водители это так называемые крейтер и то есть это видео режиссёры операторы актеры музыкальные операторы и все эти люди с помощью наших платформам производят видео профессионального качества есть если вам нужно видео опрос приходите к нам описываете то что вам нужно мы вам предоставим продюсера и сделаем вам отличное видео вот если же вы умеете снимать на камеру либо актер можете также за и команды понимал где найти как организовать код что делает каждый класс также мы был бы неплохо если наша архитектура позволяла все это делать гибко то есть мы могли бы что-то очень быстро менять при этом другие части приложения и бы не ломались вот так же было бы неплохо легко это расширять то есть добавлять но функционал к уже существующему без каких-то необходимости переписывания существующего кода и одно из самых главных критерий это тестируем оси то есть мы должны этот код потом протестировать есть еще другой набор проблем который связан именно с андроидом но не все они связаны напрямую с андреем не которые связаны с тем что мобильной платформы очень сильно отличаются от того что было до них да это навигация диалоги и сетевые запросы состояния жизненный цикл и так далее вот и мы с вами сегодня посмотрим как же с помощью подхода под названием archetype мы можем решить эти проблемы вот еще стоит поговорить об инструментах то есть архитектура само по себе это просто набор правил и чтобы эти правила реализовать эффективно да нам нужны какие-то инструменты в нашем случае мы будем использовать код я на рыжего вторую dagger data by нинги библиотека под названием навек который позволяет нам работать у домыслов циклом а также всю модель который хранит наше состояние которое мы отображаем навью на самом деле была очень забавная история примерно месяц назад когда с этим докладом выступали с моим коллегой и один из отзывов был что до что эти ребята несут как бы просто набрали модных технологий и говорят что эта архитектура вот и как-то модность теперь называть хайграунде валютным и как бы месяц назад конечно да я бы согласился что действительно много модных технологий они все в трендах но буквально 2 недель назад на гугла и все технологии которые мы использовали стали как бы официальными рекомендациями от google и теперь уже google рекомендует эти технологии для новых android проектов да и также для существующих вот так почему с чем связано это то есть на google и и google официально объявил что копин теперь еще один из языков официально поддерживаемых для android dagger 2 это также библиотека от гугла который позволяет нам очень удобно работать записи джеджун кстати кто из вас знает что такое dependency injection о отлично прям порадовали меня спасибо вот держава 2 также google имеет поддержку в новой библиотеки ru которые она анонсировал на гугла ем также архитек components которой как оказалось очень сильно похоже на то подход о котором сегодня пойдет речь и объявим как один из таких подходов архитектурных связывания view с бизнес логикой которые google продвигает в виде библиотеки под названием dota банник давайте сразу начнем тогда со сравнение того что рекомендуют google и как это отличается от того о чем мы сегодня будем говорить то есть это один из слайдов 10 голов здесь гугл нам рекомендует разбивать все приложение по слоям на четыре слоя под названием а ей контроллер который занимается взаимодействием совью view model который занимается преобразованием данных взятых из репозитория для того чтобы их можно было отобрать жить отобразить на view тогда все понимают что данные которые мы получаем сервера это абсолютно не те данные которые мы хотели видеть в наших списках предположим вот и самый дельный слой это источники данных таких как базы данных сеть и тому подобное вот в подходе же под названием archetype мы добавили еще немножко абстракции связано это с тем что чем больше абстракций тем абстракции получается меньше и легче понять и для чего они нужны и легче понять как их использовать как тестировать вот что же мы сделали во первых для его и контроллера google предлагает использовать activity либо фрагменты мне лично подход этот не нравится и я считаю что activity фрагмент должен содержать как можно меньше кода и частично это решается библиотека do to buy dance где код который связывает нашу модель и наш объем который находится у нас в xml ялте этот код который занимает связан генерируется автоматически из специального велик самой немножко еще один поподробнее расскажу вот и и модель остается без изменений так как рекомендует google вот следующее шаг было это отделить репозиторий от view модели с помощью из кейсов иль так называемых интер акторов те кто знаком скин архитектор ну вот это один из слоев которые очень широко используются в этом слое мы будем хранить наши бизнес-логику потому что рекомендации google нигде не сказано где у нас конкретно бизнес только будь то есть у нас есть ее модель репозитории а бизнес-логику мы будем именно инкапсулировать внутри эскиз дальше под слоем репозиториев у нас пойдет один из таких ноу-хау который мы используем это экшен и экшены нужны для того чтобы инкапсулировать взаимодействие с внешними библиотеками под внешним библиотеками я понимаю это базы данных какие-то может быть цензоры а также android языка компоненты то есть все компоненты которые мы рассматриваем они нужны для того чтобы как можно сильнее абстрагироваться конкретно вот android sdk потому что исторически так сложилось что чем больше вы завязаны на android из-за к тем сложнее вам протестировать ваш код вот немножко в более такой треугольном виде наши компоненты и давайте пойдем сверху и немножко поподробнее рассмотрим что же такое например view нашем понимании под view мы будем понимать layout который описан конкретном андройде виде xml здесь вы можете видеть layout написан с использованием до доминингов и например в textview вот нотация с собачкой и фигурными скобками говорит нам о том что это textview всегда будет отображать у нас имя юзера а второй textview будет фамилии отображать и при этом каждый раз когда у нас меняется поля вы там user автоматически происходит связывание этих данных и информации который отображается на view этим занимается библиотек города биллинге вот так примерно выглядит доступ к этому layout и из кода мы берем дата биллинге и передаем туда лайалл то иди и получаем собственно наш видим котором внутри содержится нашим view model вылет быть примерно так то есть у нас есть например логин мы передаем туда нашу базовую модель который занимается сохранением состояния и отпиской от существующих асинхронных to suck которые у нас могут быть в процессе отображения каких-то данных пользователем тоже мы можем туда за инжектить через конструктор ещё много разных вещей чтобы иметь возможность до связывать какие-то участки бизнес-логики то есть нашем случае это будет состояние логина да и логинюсь кейс который позволяет нам именную владеет нашу usa вот сами и space выглядят примерно так то есть у нас есть интерфейс и его реализация тут как бы ничего сложного и стоит понимать что из кейса могут быть абсолютно разные то есть это самый простой случай вот кадр забыл сказать что все компоненты связанные с помощью паттерна обзор то есть мы используем риджал вторую повсеместно и взаимодействия компонентов происходит именно через обзор игры синглы если кто-то не понимает о чем сейчас говорю поднимите руку я могу объяснить немножко подробнее отлично все знают о риджал вот это вот это хорошо так а вот еще одна задача который занимается наша view model оно подписывается на наши обзор углы чтобы хранить наши подписки потом ведь возможностях них отписаться вот еще один паттерн который мы широко используем это репозиторий на экране видите такой простой пример реализации сессии репозиторий которая хранит модель нашего авторизованного пользователя и все что можем здесь сделать это вызов не тот путь куда мы отправим данные логина логин пароль нашего пользователя в самом простом случае и вызовем логин action которые очередь авторизуют нашего пользователя и все это будет работать через в r-bass вот если кто незнаком скотт ли нам здесь может показаться немножко странным как написано to close дело в том что аннотация buy означает что мы делегируем реализацию интерфейса символ валери по конкретному классу конструктор которого вызывается как раз после боев вот это позволяет нам очень удобно отделить логику который будет реализовывать наши интерфейс и позволяет очень удобно потом к ним обращаться то есть мы будем работать с классом for bass а у смогла репо как с простой реализации интерфейса но при этом внутри самого класса никакой реализации нет вся реализацию как раз в классе for buy singulair алеппо вот ну и самое интересное это экшен и экшена предназначена для того чтобы работать с какими-то внешней библиотеками в том числе android sdk и экшена бывает двух видов стерилизован все реализуемые и неси реализуемые то зачем это нужно для неси реализуемых решено все очень просто это практически самый широко используемый то есть если вам надо сделать навигацию на средний экран либо сделать какой-то запрос которого мне важно выполнится или нет да то тогда можно использовать нереализуемо экшена в принципе там правил практически нет пишите какому-то угодно единственное что нужно здесь понимать то что action содержит какой-то кусок логики которую бы вы могли очень легко подменить то есть изменяя реализацию от экшена во всех местах где вы его использовали да все изменится вот siri лизу и мышь на немножко более сложная здесь вам понадобится 1 и аргументы то есть здесь смысл в том что для определенного класса приложения есть действия которые мы не хотим чтобы пользователь совершал второй раз если что-то пошло не так да грубо говоря он обновил свои данные нажал сохранить но произошла ошибка сети или телефон перезагрузился или что то типа того вот в этом случае если мы можем эссе реализовать этот экшен мы васи реализуем сохраняем нашу базу и следующий раз когда приложение запускается можем его восстановить и выполнить опять вот и для этого как раз мы используем ся реализацию и инкапсуляции логике внутри action очень сильно нам помогает обработать эти кейсы если у нас один экшен был неси релизу им им мы просто немножко меня лойко делалось реализуем думаем о воде и теперь мы уже можем все тех же на восстанавливать и выполнять когда нам это нужно вот ну и medley самый нижний слой под ним мы понимаем все что не связано с компонентами которых мы сейчас говорили база данных android sdk и библиотеки это могут быть сенсора или что то еще да любые внешние компоненты от которых мы хотим абстрагироваться вот немножко поподробнее сейчас я объясню как происходит так называемый поток данных между нашими компонентами то есть если мы возьмем view и беники которые связывают view model view здесь все очень просто view отдает какие-то событий бен гу и бенинг меняет состояние view добавим сюда экшен и здесь мы имеем возможность вызвать action прямо и спиннинга то есть это делается для очень простых случаев когда у нас есть экран какая-то одна кнопка другой открыть следующий экран да нам не нужно каких-то view модели добавлять туда и из кейса репозитории все это нам сулит не нужно в этом случае мы просто добавляем action который описывает нашу навигацию которые у которого в качестве медовые выступает android sdk и просто вызываем прямо извиним если у нас что-то более сложно то есть нам нужна какая-то минимального и к на экране грубо говоря переключить состояние какое-то кнопки из поменять текст о каком-то событии что-то еще лет она уже нужно в модели которая свою очередь также может взаимодействовать с action то есть в этом случае мы можем например вызвать навигацию по изменению какого-то состояния или делать куда более сложный логик который не вовлекает какие-то большие куски бизнес-логики если уж так получилось что у нас сложная бизнес-логика мы добавляем еще один слой из кейсов вы носите сословия туда и из кейса также могут обращаться экшеном вот здесь я бы все довольно прямо ну и последний шаг когда у нас уже совсем сложный случай да то есть нам надо какие-то данные получить откуда-то где-то сохранить в базе данных еще где-то вот тогда у нас появляется репозиторий которая опять же может взаимодействовать с экшенами экшена уже будут получать данные и сохранять данные в этот конкретный репозиторий до также взаимодействуют с любыми внешними библиотеками немножко поподробнее рассмотрим вот последний участок с кейсом репозиторию потому что здесь мы можем использовать комбинации из кейсов и репозиториев если уж у нас прям что-то совсем у сложно у эскиз есть возможность зима действовать с несколькими репозиториями также из кейса могут содержать другие из кейсы и view model s очередь может содержать несколько эскизов которые она внутри себя может связывать то есть эта схема такого очень сложного случая который встречается наверное уже в больших таких сложных приложениях я не ожидаю что кто-то вызов всматриваться в эту схему вот я включила в доклад для того чтобы могли уже после если вам будет интересным внимательный посмотреть и более глубоко понять что происходит вот как же вся вот эта схема которой я щас описывал помогает нам организовывать наш код лучше делать его более тестируемым и гибким вот для начала это как это помогает нам организовать код каждой абстракции имеет определенную цель и предназначена для определенных действий и если новый участник вашей команды имеет представление о том для чего нужна экшн и что такое репозиторий что такое из кейс то когда он видит в коде классу спейси он уже практически сразу понимает что там должно происходить ну конечно самореализацию же зависит от пиратов разработчиков но в целом понимание кода облегчается так как абстракции стали меньше на точную вынесли какие-то специализированные действия до грубого рядом в экшен или из кейса то эти абстракции стало легче понимать вот и связи с этим меньше абстракции легче тестировать вот гибкость так как у нас мы не обязаны для каждого экрана до добавлять эти пять слоев которые очень все усложняют вот мы можем для простых кранов сводов два три четыре слоя то есть дает нам определенную гибкость реализации и уменьшает количество баре более plate кода который нам необходимо написать вот и также наш код очень расширяем потому что мы можем добавлять новые экшена практически неограниченное использовать там любые библиотеки которые нам вздумается вот давайте рассмотрим немножко примеров как мы можем реализовать например навигация помощи экшенов то есть тут все очень просто мы создаем новый экшен который нашем случае содержит контент мейкер но мы в этом примере используем до инжекторы первым ними напрямую на самом деле можем использовать injection через конструктор то есть тут не важно самое важное здесь это метод start and end здесь мы видим как мы можем абстрагироваться от навигации и предоставить возможность навигации наши машину и в случае когда мы вызван метод на волка экшена мы просто перейдем на новые activity один из плюсов такого подхода в то что нам больше не нужен на роутер очень многие архитектурные подходы используют специальные классы которые предназначены конкретно для навигации и это очень специализированная абстракция по моему мнению часто не нужно и можно обойтись просто инкапсуляция внутрь экшенов вот но если уж у вас действительно прям очень сложная навигация и вы не представляете как это сделать без навигатора вы можете вместо метода start and end да в экшенах использовать навигатор который вам нравится есть луна библиотек который позволяет сделать ум навигации если он действительно так удобнее можете опять же абстрагироваться от навигатор с помощью action of dialogue как вы могли ведь практически ничего не изменилось мы просто вызываем диалог другим методом используя диалог maker да это класс который позволяет нам робот сделал данном случае он просто проектирует методы кондрат sdk вот один из таких частых вопросов и одна из самых больших проблем особенно на старте у начинающих разработчиков как нам расширить данные между несколькими экранами и например сервисом то есть у нас могут быть очень сложные случаи да когда несколько экранов зависит от конфет каких-то конкретных данных и нам необходимо на одном экране те данные обновить и чтобы на другом экране мы получили об этом уведомление да что-то изменилось и как обычно делают но я надеюсь никто из вас так не делать это прокиды вание предположим ссылку на период фрагмент и потом дерганье у прн фрагмент каких-то методов до которые модифицируют его обновления данных и в нашем случае мы из леса так не делаем и когда вы хотите чтобы несколько экранов обращались работали с одними и теми же данными получали утомление мы всегда можем за инжектить репозиторий во все эти экраны то есть все взаимодействие связанная с обменом данных происходит через репозиторий и мы практически никогда у нас не возникает потребности передавать ссылки на период фрагменты либо еще делать какие-то хаки вокруг этого и здесь как бы каждый разработчик команде понимаю да что мы хотим обмениваться данными мы для этого используем репозиторием все четко и просто вот работа сети здесь немножко или сложный пример но на самом деле на что нужно обратить внимание это на контекст и метод fit который мы вызываем у него то есть контекст нашем случае это и 5 то есть конкретно в этом примере это используется просто retrofit мы передаем наш экшен retrofit и вызываем у него конкретный метод и внутри экшена мы инкапсулируем логику которая обрабатывает данные для того что мы могли их сохранить нашей базе торе и иным углом вопрос от экшена кто его исполняет вот да я на самом деле опустил специально деталь чтобы не усложнять доклад есть два варианта то есть для простого варианта когда у нас action неси реализуемый мы просто выполняем она прямой мы создаем экземпляр вызываем метод он бог и да здесь например мы вызываем метод на волк передавай туда контекст аргументами да но это старый пример мы так раньше делали на самом деле лучше за инжектить прямо в конструктор экшена и за инжектит сам экшен например репозитории вот и второй вариант когда у нас action оси реализуемое там немножко более сложная схема нам понадобится в идеальном варианте action продюсер который будет принимать айди экшена и возвращать конкретную реализацию и также action fender который будет его исполнять вот это сделано как раз для того чтобы мы могли при знании и диски и шины и знание какие аргументы ему нужны естественно аргументы тоже должны быть реализуемыми мы могли бы восстановить action ханбир он один на все приложение или их много для каждого контекста вот которые здесь наш случай пи до нужен будет один экшен продюсером и action хэндлер и также для каждого следующего контекста нам нужен будет ещё один наш продюсер из их связать придется например но очень маловероятно но если придется тогда можно сделать через кейс спасибо ах да за вопросы футболочки и все таки так что будьте активней у меня вопрос чисто практический я здесь привет спасибо за доклад цифр вообще вопрос практически вот в клинки тех чем и чтобы не повязывать из кейсах объединяемых им тракторы и получается довольно компактно а вот вы не утопаете в экшенах потому что на каждый чих же получается с одной стороны может показаться да но как бы тут стоит понимать что экшены могут разных видов быть то есть мы можем конечно создавать какой-то отдельный класс для каких-то очень простых экшенов класс даже может быть не обязательно конкретно вход линии мы можем использовать в качестве экшенов обычные функции который в принципе делаю тоже самое и при этом мы погрязли в функциях вот а вторая часть вопроса а по поводу из кейсов за что их становится многое надо будет объединять контрактор и а ну как бы как бы на тебе экшены имеют разные контексты пока еще за всю историю использования эта архитектура это порядка уже 9 10 где-то месяцев ни разу не возникало к потребности то есть обычно разные контексты они таким натуральным образом скупят наш экшена и скорее всего тебе никогда не придется связывать разные контексты через экшены добрый день и спасибо за доклад все-таки что же насчет тестов больше всего интересует интеграционные тесты до протез ты была отдельная секция на прошлом докладе я даже могу сейчас наверно его найти и показать во первых есть репозитории там есть примеры тестов можете посмотреть и сейчас посмотрим мой доклад mobius а вот но вот так примерно выглядит теста то есть понятно что мы можем писать и там интеграционное с помощью эспрессо можем немножко более низкого уровня этом с помощью раба лекторы к делать и здесь чтобы каждый компонент из за того что он небольшого размера мы просто имеем возможности проще протестировать да и вот как раз примеры тестов могу показать если что-то конкретное интересует могу даже ответить как примерно это можно сделать хорошо здравствуйте спасибо за доклад собственно вопрос по поводу экшенов опять-таки и из кейсов вот принципиальная разница и из кейсов то есть interac таро в чем с экшном то есть я так понимаю что action еще один дополнительный этап который делает одну задачу между сервисом и получается view моделью у вас ну не совсем на самом деле экшены нужны ему для того чтобы абстрагироваться от конкретных библиотек каких-то компонентов sdk который мы используем то есть изначально основная идея в том чтобы как можно больше использовать голый java и что это что мы там используем вот и если нам нужно использовать грубо говоря навигацию навигации это уже особенности реализации конкретно android sdk и мы хотим от нее абстрагироваться и для этого мы выносим внутрь экшена вот это дает возможность во-первых action подменить до для тестов на что-то другое что мы не дергали android sdk и с другой стороны это нам до позволяет не париться о том как экшен реализован айос кейс и это конкретно бизнес-логика бизнес лаек чисто там же учетом сложить посчитать цену до например и потом уже вызвать какой-то экшен ну у вас получается что экшн идет скажем так в обход бизнес-логики если нам необходимо сделать какое-то простое действие правильно если если вам необходимо сделать когда происходили которая вас связано с внешней реализации чего-то да то есть всю модель напрямую работала с экшном для кажется ли вам что это неправильно с точки зрения архитектуры то есть у вас в одном случае view model общается с ю с кейсом трактором другом случае она общается с экшном вот да но это сделано для того чтобы не усложнять простые какие-то случаи то есть у нас есть супер простой экран мы естественно не будем делать там пять слоев чтобы там сделать к это фейковые репозитории который будет при каком-то триггере вызвать к нам достаточно одного слоя и вызвать экшен и свои модели то есть в конкретном случае если мы сохраним action во вью модели у нас в you модель будет использована внутри winning of и у нас action будет дерганый самом деле бенинг я знаю звучит наверно ужасно но в целом получается что view model просто контейнер он не содержит никакой логики которая будет был которая вызывала бы экшн а сам экшен триггерит каком-то действие пользователя то есть я не говорю что это там супер правильно да естественно такой каноничный подход быть реализовать все это пять слоев и там где-то дернуть action самом конце но очень часто этого просто не нужно и здесь мы можем немножко до поступиться какой-то супер чистотой и просто сделать как удобнее на вам разработчикам понятно спасибо микрофон человеку здравствуйте спасибо за доклад в вопрос такого характера у вас очень длинная цепочка вот интересно как вы передаете контекст и бывает нужно что контекст самому верху нужно использовать самом низу для вызова каких-то android api и как вы следите чтобы они не утекали вот за нас на самом деле все делал дпс injection единственное что в этой схеме может утечь это подписки на наши реактивной компоненты вот да и здесь есть у меня пример из предыдущего доклада где мы как раз отписываемся так а так вот он да сократить внимание на вот эту строчку мы подписываемся на ивент в нашем случае detach и трясет композите способа у нас отписывает все наши подписки в котором и подписывались новые модели вот то есть это позволяет нам бороться достать очками памяти потому что каждая view model отписывается от всего на он detach вот контекст мы инжектить с помощью дядя куда нам нужна еда так как у нас скоб это конкретно в реализации который сейчас пользу это фрагмент то при уничтожении фрагмента все отписки и уничтожаются и это позволяет нам избежать утечек памяти так у меня еще много футболок ну да я рад что все всё поняли вот но если какие-то вопросы либо кто-то стесняется прям спросить при таком да конечно так конечно раз всем спасибо за доклад подскажите пожалуйста в чем мой взгляд текущей подход лучше например чем блин архитект хорошо вопрос дело в том что здесь все зависит конкретно от проекта то есть для некоторых проектов может быть лучше данный подход для некоторых может быть лучше клин арки тех чьи и здесь уже я из своего опыта не знаю как решить для какой подход лучше для кого проекта потому что нужно планировать изначально данный подход родился для конкретного проекта то есть изначально не было никакой архитектуры потом появились наши инструменты дакоты наряжала 2 dagger и путем такой эволюции многочисленных рефакторинга выработался какой-то универсальный подход который очень хорошо подходит для конкретного приложения на котором мы работаем и я убежден что может быть использован успешно других проектов тоже поэтому я и приехал как бы об этом рассказать это уточняющий вопрос о чем не подошел длинных тех чьи например в вам вашем проекте вот вопрос даже не в том чем клин архитект не подошел вопрос на что есть очень много разных интерпретаций очень много разных подходов есть там в п м м в м и каждый по-своему понимает там view моделей в юму долга как каждый по-своему понимаешь что к презентер вот я был свидетелем дискуссии о том что да куда выносить бизнес-логику в презентеры или в модель или в интер actor и вот все это люди как бы обсуждают и нет какого-то основного подхода до который бы говорил что вот тут делать так то делать а каждый понимает по-своему и бы выбор из этих вот всех подходов до занял бы очень большое количество времени вот и в моем случае было проще взять и сделать архитектуру под конкретный проект чем выбирать и и как бы пытаться подогнать уже существующей к этой подход который кто-то использует а кто-то использует другой по то что мне было нужно на себя вот ну что ж если у кого то будут еще вопросы я буду здесь задавайте"
}