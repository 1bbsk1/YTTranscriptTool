{
  "video_id": "8pdkhkQm2Ik",
  "channel": "HighLoadChannel",
  "title": "Octree, или Сказ о поиске пути в 3D / Антон Поцюс, Евгений Ченцов (IT Territory)",
  "views": 160,
  "duration": 1910,
  "published": "2024-04-17T00:59:44-07:00",
  "text": "друзья Всем привет меня зовут Антон я из студии территории которая входит в My Games со мной сегодня Женя программист из нашей студии Ну и сегодня мы поговорим о поиске пути в целом и о том Чем отличается поиск в 2D скажем о том как решали эти задачи одно из наших С какими проблемами столкнулись как их боролись покажем потребности и особенности нашего проекта могли оптимизировать решение Ну и в итоге из этого Получилось расскажем немного о нашей компании it-tor является частью My Games в которую входит десяток студий которые разрабатывают и издают игры самых разных жанров сотня тайтлов 25 миллионов активных игроков почти 2000 сотрудников Это все можно сказать о нас если же говорить конкретно о нашей студии то за более чем 18 лет существования выпустили почти два десятка игр среди них отдельно отметим Аллоды онлайн браузерную Легенду и расширять Наш новый хит сзади написано что в команде 250 человек Однако нас уже больше И мы продолжаем расти но выпущенные нами игры сыграла свыше 100 миллионов игроков перейдем к установке проблемы поиск пути этого распространенная Задача В геймдеве но порой какие-то особенности проекта заставляют решать ее таким новым соусом что может поставить вступить даже опытных разработчиков Так что если вы интересуетесь в частности И алгоритмами вообще то это доклад как раз для вас Итак у нас есть карта с препятствиями Ну или какой-то Лабиринт нам нужно найти маршрут из точки А в точку б для двумерного случая существует достаточно много решений Вот например визуализации нескольких алгоритмов любопытно здесь разница не только время вычислений но и сам найденный путь почему это происходит Давайте разбираться основная идея всех алгоритмов поиска пути является оценка вершин графа насколько та или иная вершина подходит для дальнейшего движения и чем меньше ее стоимость Тем более она привлекательна для посещения но оптимальный путь это путь который состоит из набора Вот таких связанных вершин с наименьшей стоимостью самым известным алгоритмом пожалуй является алгоритм dextra в простом случае он имеет квадратичную сложность и почти не используется на практике в чистом виде алгоритм требует посещения всех графа что конечно же приводит к высоким затратам но зато он выдает самый оптимальный позже предложенные другие алгоритмы в которых вершины стали оцениваться несколько иначе популярность получил подход где стоимость клетки это сумма двух функций первое оценивает удаленность точки от старта вторая так называемые юристической функции насколько дорогим может оказаться переход конечный именно в общем-то это ивристика делает расчет экономичным нам больше не нужно обходить все точки Ну и Конечный результат соответственно может отличаться от идеального и ключевым здесь в общем-то является как раз выбор этой самой эвристики вот тут можно увидеть самый распространенные из них в зависимости от потребностей выбирается та или иная самым популярным юристическим алгоритмом в целом является звездочка его можно встретить не только но и во множестве других приложений плюс существует много улучшений каких-то альтернативных алгоритмов и функций вот ну и их количество Конечно только подчеркивает тот факт что поиск пути в 2D Это хорошо изученная задача в чем же особенность 3D Несмотря на то что большинство игр являются трехмерными для них не требуется использование трехмерного поиска пути перемещение в любой трехмерной игре происходит по набору плоских поверхностей которые объединены в карты так как мы можем легко решить задачу поиска пути для каждой этих поверхностей то можем решить ее для набора в итоге мы создаем как бы почти плоскую сетку внутри которой можно построить Граф и решить задачу никакой магии подробнее о технологии построения поиска пути можно посчитать по ссылочке Ну послаете среди прочих интересностей там например рассказывается про вейпоинты и Navigation mesh в counter-strike Итак во многих играх в которых перемещение проходит по поверхности нет необходимости использовать трехмерный поиск пути А где же такая необходимость есть справа пример такой карты в которой нужно использовать трехмерный подход объект может перемещаться в трехмерном пространстве без какой-либо привязки поверхности А в самом пространстве находится препятствия которые не позволяют пролететь из любой точки в любую просто в чем же принципиальное отличие поиска пути в 3D ведь и трехмерную задачу тоже можно свести Граф и в этом графике использовать те же самые стандартные алгоритм Давайте посмотрим на табличку и попробуем оценить сложности таких алгоритмов Первый параметр Это количество соседних вершин Граф в которой мы можем переместиться значение здесь не абсолютные скорее просто интересует некий такой порядок Итак если мы находимся на двумерной сетке и учтем все диагонали то мы можем перейти 8 соседних клеток с когда случаи возможных вариантов в три раза больше 26 но Проблема не только возможных направлениях движения Например можно посмотреть на количество клеток в квадратном километре для плоскости если размер каждого блока будет составлять квадратный метр то мы получим поле из миллиона против целого миллиарда клеток кубическом километре разница в количестве элементов отличается уже в тысячу раз три порядка в таких условиях количество связей в графе будет отличаться более чем в 3000 раз такая разница приводит к тому что трехмерный вариант в чистом виде работает очень даже для небольших Поэтому нужно придумать способ который позволил бы сократить время поиска все проблемы и вопросы которые мы задаем стали перед нами при создании игры Пираты штурм небес она была создана нашей студии еще в 2016 году это free-to-play игра является спин-офф омолодов и представляет собой набор ПВП активностей которых вы управляете боевым летающим кораблем корабли могут летать в трехмерном пространстве управлять ими могут не только игроки но и боты поэтому перед нами встала бизнес-задача реализовать поиск Какие же требования к этому поиску предъявлялись Ну Первое является очевидным он должен работать в трехмерном пространстве поскольку Пираты как колоды являются серверной игрой то вся игровая логика включая поиск пути Должна осуществляться на сервере размер карты не может превышать кубического километра А время поиска на расстоянии средней карты 30 секунд Есть и хорошие новости У нас не было жестких ограничений на объем памяти потому что расчет производился на серверах с большим ее количеством помимо самого поиска пути Нам необходимо было осуществлять дополнительные процедуры такие как быстрый трейс в любом направлении и проверка видимости Ну а результатом поиска должен быть сглаженный похоже на естественный путь в настолько ресурсоемких задачах решение в лоб чаще всего оказывается слишком медленным Чтобы достичь нужной скорости всегда необходимо так или иначе использовать все особенности контекста Задачи в нашем случае контекст это карты правда а что мы знали о картах Пиратах ну прежде всего они параллелепипед а чаще всего куб внутри которого и происходили все основные игровые действия Часто у карт где игрок летает в пространстве может отсутствовать дно или же оно может оказаться каким-то частичным например Космос или какой-то выступ у скалы чтобы алгоритм не пытался найти путь в одном нам нужно явные ограничения поиска по высоте важное для нас деталь заключается в том что в действительности карта не перегружена объектами и в ней очень много открытого пространства с набором парящих в воздухе препятствий это особенность для нас очень важна Ну и как во многих других играх края карты представляют собой некую запретную зону при вылете за которую корабль начинает получать урон вплоть до его полного разрушения Итак задача поставлена самое время ответить на вопрос причем же здесь как-то дерево это структура данных Где Каждый элемент либо является листом и не имеет потомков либо имеет аж 8 вот так вот это дерево можно представить в двухмерном виде а справа уже изображено трехмерное представление в таком виде сразу становится Понятно применимость Окта дерева используется Везде где нужно разделить пространство на множество вложенных объемов это не обязательно поиск пути но и задачи графики рендеринг потомки родительского узла называются октантами одного уровня ложность одинаковые они не пересекаются друг с другом и полностью заполняют объем родителя а здесь нужно небольшой дисклеймер для простоты иллюстрации мы будем заменять это дерево Квадро дерево это его двухмерный это нам позволит акцентировать внимание на сути не усложняя наши картинки Итак Из чего состоит Окта дерева первый элемент нам уже знаком Это в который входит все остальные узлы как и в привычных деревьях в нашей структуре есть листья это конечный элементы которые не могут иметь Слушай окна деревьев Можно также сказать что листья это октанты не имеющие какой-либо дополнительной влажности octant имеющий родителей детей называют свет лист может быть пустым или же хранить в себе коллизию коллизию то есть препятствия через которые невозможно пролететь одна из важных задач для нас это научиться правильно и достаточно быстро отмечать элементы дерево как содержащие применим нашу структуру данных для трехмерного поиска пути пусть у нас есть некий объем в котором есть коллизия в нашем случае будет кораблик построен для нашей карты дерева и посмотрим на каждый из них в отдельности пронумерованы октанты видно что коллизия есть всего в одном из них продолжим строить вложенные октанты для этого узла чтобы как раз уточнить расположение вот в нашем примере в семи из восьми октантов нет ни одного препятствия Требуется ли разбивать их дальше Конечно таким образом главная идея использования дерева Это детализируем только то что требуется Поможет ли такой подход решить проблему размерности Давайте посмотрим если у нас есть информация о том что Октан содержит только пустые листья то дальнейшая детализация он не требует и даже более того мы можем их объединить в один который будет иметь более крупный размер было у нас 8 элементов стал один вот такой заодно такое объединение мы сэкономили 7 элементов Давайте теперь поднимемся на один уровень повыше и теперь представим на секунду что все остальные октанты как и красные на которые мы обращали внимание все еще также пусты то есть теперь у нас было 60 было бы 64 элемента останется снова 1 мы сэкономили уже 63 элемента таким образом эффект сильно масштабируется на разных уровнях дерева Чем выше объединение тем больше элементов на экономию Конечно же если в вашей карте есть большое количество мелких равномерно по ней распределенных препятствий то акта дерева едва ли поможет вам решить вашу проблему Но в нашем случае мы ощутимо выигрываем за счет того что на карте имеются большие открытые пространства причем если мы на секунду представим что например на месте спавна в родительском актанте у нас один из дочерних элементов корня вообще пуст то мы уже экономим 12,5 процентов от Всех элементов которые могли бы находиться в нашей сетке Давайте вернемся к нашей табличке и добавим для нее еще один столбец это дерево Да у нас все еще пока остается необходимость искать путь по большому числу направлений Однако с этим можем будем на самом деле бороться далее тем не менее возможность бросить пару порядков должны весенние у нас есть и это говоря по правде вовсе Итак давайте разберемся что же нам нужно для построения необходима система координат в которой мы будем вести расчет нужны координаты центра корневого элемента который будет вмещать в себя все остальные узлы ну и наконец нам нужно знать размер ребра корневого элемента чтобы его построить Ну и это все это все что необходимо чтобы построить пустое дерево с одинаковыми элементами система координат центр ребра одинакового размера с помощью ребер можно построить вспомогательный ортогональной плоскости после чего формируется куб который есть корневой элемент Теперь мы хотим построить 8 потомков центра октантов вычисляются просто Ведь они одинаково удалены от оси синего цвета расстояние в половину ребра родителя теперь курсив на применим каждому потолку тоже самое процедуру Вот и все всего три параметра мы построили дерево целиком кажется Теперь мы наконец готовы к тому чтобы начать строить акта дерева уже для самой карты Ну как говорится поехали Хотя наверное в нашем случае все же полетели Давайте внимательнее посмотрим на то как происходит вставка коллизии в дерево обратим внимание на картинку У нас есть какая-то точка в которую мы хотим ставить листы пометить этот лист Как коллизию этой точкой будет в нашем случае красный крестик давайте сделаем полный путь построим ветви и пометим коллизии зная координаты мы всегда можем выбрать аккаунт в котором эта точка находится там слишком большой он выше минимального размера листа Поэтому нам нужно сделать дополнительное разбиение построим детей мы все еще можем выбрать аккаунт которого и он все еще слишком велик сделаем еще одно разбиение и теперь после того как мы выберем октант мы выясняем что его размер минимально допустимен является минимальным Мы дошли до конца пометим теперь все что мы сделали Как листы ветви и коллизии соответственно красным крестик крестиком выделяется беспрепятствия Мы также создали шесть веток и три пустых листа работать с точками Это здорово но наш мир все же является трехмерным нам нужно каким-то образом отобразить нашу логику на полноценные трехмерные объекты Давайте Сначала посмотрим на то как мы работаем с терраином то есть с нижней части карты в его случае мы считаем что все что находится между дном карты и террейном есть некое сплошное препятствие и поэтому мы находясь под поверхностью Рейна ходим по оси Z с небольшим шагом и в каждую из точек производим вставку коллизии таким образом поверхность превращается вот в такую сплошную коллизию в случае же парящих препятствий которые вообще говоря могут И не иметь никакой связи с террейном нам нужно использовать другой подход в таком случае мы разбиваем нашу правящую коллизию на множество полигонов разрезаем каждый полигон на набор примитивов для этого примитива выбираем минимальную координату именно в неё производим вставку коллизии мы превосходны дерево готово на этом блог построение подходит концу и мы переходим к тому к тому как с помощью окна дерева мы будем реализовать непосредственно сам поиск пути Давайте сначала расскажем о принципиальных решениях в части выбора алгоритм своей основе мы используем всю ту же звездочку дешево и сердито это как раз про неё в качестве эвристической функции взяли она лучше подходит для случаев когда надо учитывать диагональ на эвристику мы немного доработали для любого вертикального перемещения мы ввели штраф то есть мы стараемся не менять высоту без необходимости так как корабли в нашей игре быстрее передвигаются А по вертикали Ну и вместо карты проходимости которую обычно используется мы взяли инвертированную карту коллизий наконец поскольку корабль имеет довольно большие геометрические такие размеры то в алгоритме нам также потребовалось учесть проходимость пути для него Давайте детально обсудим допустимые направление поиска в начальный момент времени поиск идет по всем 26 направлениям Ну так как мы не владеем какой-либо дополнительной информации о том в каком направлении нужно искать Однако после первичного выбора Куда Мы двигаемся максимальное количество направлений сокращается до 17 мы не будем искать в противоположный от выбранного направления стороне после начала движения В некоторых случаях мы можем еще сильнее меньше число направлений Например если вперед лететь запрещено там находится какая-то коллизия то и диагонали в общем-то проверять смысла нет и такие направления Вы тоже отбрасываем в итоге количество направлений может сократиться до 12 то есть мы снизили их общее количество более чем в два раза и напомню что мы не выбираем направление которые ведут нас за пределы карты мы все еще не выполнили одной из требований которое предъявлялось к полученным результатам на данный момент мы теперь уже умеем искать путь из одной точки в другую Это здорово Но ведь построенный путь это какая-то полилиния которая является не только естественным способом движения но еще не оптимально с точки зрения хранения данных для перемещения Давайте попробуем это улучшить Сначала мы откажемся от всех точек которых не меняется направление движения поскольку итоговый путь после их выброса никак не изменится а данных для обработки станет меньше сглаженность движения при поворотах достигается за счет клиентских доработок Если бы мы остановились сейчас то путь выглядел бы как-то так однако для того чтобы избавиться от дополнительных точек в нашем пути мы сделаем объемный трэйс специальную процедуру с помощью мы можем понять сможем отказаться от других точек которые не находятся на прямой сохраняется видимость до следующей точки и вот если мы проведем эту процедуру и откинем все лишние точки сохранение видимости то наш путь станет уже вот таким он будет одновременно плавным в нем будет меньше изгибов а сервер будет проще с ним работать Казалось бы все готово и можно расслабиться но после оценки скорости оказалось что мы все еще долго дерево Можно сказать не справилась задачи и нужны какие-то оптимизации мы сделали много но расскажем о самых важных первая оптимизация касается способов ставки соседних препятствий до текущего момента вставка всегда сопровождалась проходом дерева на всю его глубину сверху вниз то есть предположим У нас есть квадрат дерево и мы хотим ставить коллизию в точку помеченную крестиком но если мы хотим также пометить коллизии соседний элемент крестиком то в таком случае нам придется пройти весь путь с нуля подняться до корня дерева и спуститься снова выглядит довольно дорого Давайте упростим мы знаем что чаще всего следующая точка С колесить будет находиться рядом С предыдущей Поэтому будем использовать так для хранения информации о всех посещенных Итак мы недавно вставили коллизию в Красную точку и наверняка знаем стек всех октантов которые мы посетили Давайте изобразим стек видео уровней и номеров октантов на каждом уровне видим что на максимальной глубине точка в которую мы произвели вставку не лежит выбранном октанте Давайте перейдем теперь на один уровень выше теперь точка уже попадает в октант и мы можем сразу же продолжить ставку Это значительно сократит затраты на проход по дереву для поиска нужно а дальше при анализе видимости объекта могут возникать граничные ситуации Например у нас есть два зелененьких корабля между которыми есть коллизия грубо сетку Окта дерева можно представить вот так Казалось бы корабли без проблем должны видеть друг друга если их условные глаза расположены на Однако точности нашего дерева не хватает и с точки зрения игры видимости не будет такие ситуации будут часто раздражать игроков Если же мы сделаем листья меньше и таким образом повысим точность то это приведет к значительному росту потребления памяти но не хотелось Да и такая точность нужна не везде А значит там где это необходимо мы можем создать ну такие как бы специальные листья которые как бы будут хранить себе дочерние актанты но представим мы их виде битовой маски это позволит нам не создавать дополнительные вложенность чтобы еще больше Сократить потребление памяти мы используем такие вот специальные уточненные листья только для парящих то есть для terrain на такой потребности нет И мы там используем более грубую сетку с поиском пути связанные и другие задачи которые требуют оптимального решения мы поговорим еще о двух из них и первая из них это поиск в радиусе пусть у нас есть корабль отмеченный красным крестиком который обладает некой поисковой сферой схематично изображена оранжевые штриховой линии и внутри нее нам нужно применить какую-то процедуру К объектам вокруг например посвятить противника или нанести урон мы смотрим на акта дерева здесь голубые точки представляют собой набор объектов представляющих для нас какой-то интерес и мы хотим найти дешево в сети Точки которые находятся внутри нашей поисковой сферы для решения задачи нами использован готовый алгоритм ссылочка на него есть на слайде который был специально разработан для авто деревьев основная его идея заключается в том чтобы октант экономно хранил данные об объектах внутри себя если Октан целиком находится в шаровой области то мы можем взять все объекты которые принадлежат этому актанту и поместить их в как часть решения вторая часть решения будет находиться Иначе мы найдем все октанты с которыми пересечение поисковой сферы является частичным и для всех объектов внутри этих актантов мы произведем Измерение расстояния объединение решений сделанных на этапе 1 и 2 будут являться нашим готовым результатом с которым дальше мы будем делать какую-то полезную работу вторая задача которую мы поговорим это нахождение трейса Давайте сначала расскажем что это такое вычислить Trace значит найти все октанты которые были пересечены лучом или прямой линией Trace часто используется в компьютерной графике при моделировании различных тел Однако в нашем случае основное назначение трейса это анализ видимости а также обеспечение работы например таких объектов как торпеды на картинке представлена схематично это дерево на котором зеленым выделили плоскости пересеченные синие линии или лучом если для такого случая мы захотим вычислить то он будет представлен в таком схематичном виде То есть три из восьми октантов оказались пересечены нашей линии массив из них будет являться тем самым ответом с которым Дальше можно будет также работать как и в случае поиска в радиусе для акта дерева разработано несколько эффективных алгоритмов построения трейса алгоритм который мы использовали относится к группе Top Down также ссылочка на слайде лишь кратко опишем его идею потому что он довольно сложный и основано на том что Луч можно представить неком параметрическом виде где координаты зависят от параметра Давайте теперь посмотрим как все рассказанные нами работает на практике Итак мы летим между лодами видим парящие препятствия остров и сетку коллизий для него Обратите внимание насколько она мелкая это сделано специально для того чтобы корректно вычислять видимость между двумя кораблями вторая же часть демонстрирует разницу между листом для тиреина и листом для парящих препятствий поверхность снизу помечена как от того ее коллизии являются довольно крупными В то время как парящие препятствия имеет значительно большую детализацию особенно Забавно здесь наблюдать за разницу между парящим препятствиями в зависимости от того как их покрасил геймдизайнер ну и наконец третья часть видео это поиск пути между двумя точками здесь все оранжевые октанты это те актанты которые принимали участие в поиске а довольно плохо Зеленая линия отображает готовый путь Обратите внимание на то насколько неохотно поиск пути меняет свое значение по высоте это лишь подчеркивает корректность работы нашей эвристики которая имеет штраф на вертикальные перемещения Ну что ж Давайте подводить итоги первое поиск пути в 3D достаточно специфичен нужен только в тех случаях когда перемещение осуществляется без какой-либо привязки к поверхности То есть если вашу задачу можно свести к 2D обязательно это делаете вы сэкономите много времени на дачу которая изначально казалось очень сложной с помощью акта дерева стало вполне посильной трехмерный поиск это яркий пример того как удачно подобранная структура позволяет значительно ускорять вычисления это второе третий Несмотря на то что кто дерево позволяет существенно сэкономить время существует значительное количество доработок и каких-то оптимизаций которые позволят решить вашу задачу еще быстрее еще эффективнее И хотя сам алгоритм поиска мало Чем отличается от двумерного случая надеемся что решение вам было интересно на этом У нас все спасибо задавайте ваши вопросы"
}