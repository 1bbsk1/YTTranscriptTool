{
  "video_id": "fohXkD2SKUs",
  "channel": "HighLoadChannel",
  "title": "PHP generics / Антон Сухачёв (cdnnow!) (дубль, более короткий)",
  "views": 348,
  "duration": 1679,
  "published": "2024-04-17T00:59:44-07:00",
  "text": "Привет меня зовут Антон я разрабатываю на PHP уже 8 лет примерно год назад я задумался ну серьезно Почему в PHP до сих пор нет дженериков я полез смотреть Россией я полез смотреть там Исходный код какие-то читать статьи какие-то читать Вот все это в принципе вылилось в то что у меня получилось написать собственное решение дженериков для PHP на самом PHP вот об этом опыте Я бы хотел сегодня рассказать свой доклад Я поделил на три части Что такое дженерики И зачем они вообще нужны какие есть подходы к реализации дженериков и как сделать а ценерики это очень много про типизацию Поэтому вот в принципе хотел бы начать Сначала с типизации какая она бывает сильно и освоботизация языки сильные типизации характерны тем что не позволяет смешивать в одном выражении разные типы а языки особо мотивизации позволяют смешивать такие типы Ну и могут выполнять неявные преобразования Вот например как в PHP статическая и динамическая типизация языки со статической типизацией обычно выполняет проверки типов на этапе компиляции динамических типизации проверяют типы на этапе рантайма то есть сначала написали код вот на PHP зайти по или его скопировать и только потом уже в рантами узнали что у нас там где-то что-то неправильно но большинство языков в принципе не облагают не обладает какой-то строгой строгой типизации или строгой слабой типизации Они обладают какой-то смешанной типизацией которую где-то что-то больше выражено вот даже в том числе в PHP есть это ошибки компиляции на этапе компиляции для типов то есть такие небольшие случаи в принципе валидный код можно зайти проверить и того HP динамический соботизированный позволяет смешивать типы в одном выражении делать не явные преобразование проверяет типы на этапе ран тайма в принципе PHP проектировался как язык вот такой вот без типов чтобы в принципе можно было быстрее проектировать быстрее писать Ну проще писать А зачем тогда в принципе Добавляйте Зачем типы печки могут понадобиться Ну вот например типами читать и писать код проще предположим что разработчик есть какой-то библиотеку для оплаты без типов есть хороший разработчик Он должен будет в теле функции проверить что аргументы передались определенные типы для каждого аргумента он обязан проверить Ну проверить что все хорошо при этом пользователь который будет пользоваться этой функцией как минимум должен будет проверить что такое функция вернула и если вдруг он захочет посмотреть А какой же в принципе тип ему нужно передавать в эту функцию ему нужно будет посмотреть не на сам интерфейс функции а залезть в само тело функции и там уже посмотреть как эти типы обрабатываются Какие типы можно туда передавать смотреть довольно сложно получается при этом если мы добавим типы то во-первых разработчик который пишет эту функцию Ему больше не нужно делать проверок на типы за него это будет делать язык разработчик который использует эту функцию ему тоже не нужно будет делать проверку на Тип который эта функция возвращает плюс если он захочет посмотреть интерфейс функции он открывает интерфейс видно очень удобно то есть проверки типа происходит на уровне языка разработчику не нужно за это думать и писать и читать код с этой стороны проще становится почему еще проще если мы добавим типов в код то стад анализ станет работать намного мощнее ошибки которые мы можем выявить не врантайме как в PHP А в на стадии написания кода Ну это здорово намного намного раньше чем вот когда код упал там где-нибудь на на сервере да На продакшене вот пару слов про аннотации аннотации мощная штука можно указывать типы но аннотации это все-таки документация это комментарий коду от одного разработчика другому Сам PHP эти аннотации не учитывает а аннотации Как и любая другая документация Может встревать может быть Не валидно а при этом даже если мы написали что мы ожидаем какой-то тип там вот в функцию совсем не обязательно что туда этот тип передадут это просто договоренность на уровне языка такие типа не проверяются Ну и того Зачем нужна типизация в PHP проверки типов выполняется на уровне языка разработчику за этим следить не нужно писать код становится проще опять-таки разработчику не нужно писать какие-то дополнительные проверки читать код становится проще потому что мы сразу же видим интерфейс функции интерфейс класса Здорово более мощно работает стационализ Ну и аннотации могут устаревать поэтому могут устаревать могут быть принципе не валидные поэтому вот железно положиться на них на уровне языка мы не можем а где сейчас можно использовать типы в PHP Ну Практически везде мы вот можем и в аргументах функций Используйте возвращаемых значениях много где где нельзя ну в коллекциях нельзя то есть мы не можем сейчас PHP взять и указать что массив будет конкретно из Вот таких вот типов мы можем указать конечно через аннотации но как я уже говорил они на уровне языка ничего не дают язык сам не проверяет что внутри массива жестко будут какие-то типы как это сейчас решается сейчас для каждого такого типа создается своя коллекция в котором добавляется и там по одному в котором как раз таки можно указать и вот этот тип как раз таки будет проверяться на уровне языка Но получается что для каждого такого типа нужно будет сделать свою коллекцию то есть нужно будет написать свой отдельный класс со своим конкретным типом это больше кода в общем неудобно вот тут нам могут помочь дженерики можно написать один дженерик класс шаблонным типом и использовать его много раз но очень здорово получается пишем и всего один раз коды немного проверка происходит самим языком проверка получается очень удобно Здорово то есть и читать и писать будет удобненько какие есть подходы к реализации дженериков Ну вот я знаю три это typera effication И мономарфизей вот сейчас я немножечко про них расскажу Tape речь или стирание типов заключается в том что мы будем стереотипы на этапе компиляции то есть разработчик пишет код с дженериками с шаблонами типами все очень здорово на этапе компиляции должны выполняться проверки и после этого эти типы стираются такого подхода есть ограничения Ну кроме того что проверки должны выполняться только на этапе компиляции еще во время рантайм есть ограничения по использованию шаблонных значений то есть Вот например если мы захотим вызвать статическую функцию от шаблона переменной какой-то то время рантайма этой переменной не будет И поэтому виртуальная машина не будет знать откуда в принципе вызывать эту статическую функцию того у стирания типов довольно простая реализация проверки типов можно выполнять только на стадии статанализа или компиляции но при этом есть ограничения использования в коде Ну и нет типов дженериков фронта непонятно заключается в том что для каждого конкретного набора аргументов дженерика мы сгенерируем свой конкретный класс и подставим его вместе использования То есть если мы захотим контейнер дженерик контейнер для типа int то во время компиляции компилятор найдет такой дженерик сгенерирует для него конкретный класс для int и подставит вместо использования реализация опять-таки довольно простая можно использовать полностью дженерики в коде то есть нет ограничений как при стирании типов проверки типов происходит и на статонализа можно и в компиляции и в runtime но при этом требуется дополнительная память и опять-таки нет дженериков в runtime в самом то есть вот там уже будут конкретные типы и последний это refication отличается на предыдущих двух тем что сами дженерики сохраняются и в ран тайме тоже а то есть реализация будет такая что в рандайме у нас можно будет сделать reflection можно будет посмотреть Какие аргументы Какие дженерики были у такого подхода при использовании дженериков нет ограничений также как у пристирании типов при этом проверка тоже можно использовать и на уровне на стадии стад анализа и на стадии компиляции в рантайме есть одно но Это вот сложная реализация три подхода в одну табличку чтобы было проще смотреть получается что стирание типов довольно просто делать но они не подходят в PHP потому что PHP такая вот он динамический все проверки нужно делать в runtime а при стирании типов проверки хорошим нужно делать на этапе компиляции Ну или стад анализа хорошим конечно на этапе компиляции поэтому не подходит вроде бы хорошо но кушает много памяти в зависимости от проекта к проекту в принципе сейчас карты новая версия PHP Вот они держат такой баланс между тем чтобы Добавить каких-то новых фич и при этом не замедлить язык так вот тут вот тоже будет очень сложно с тем чтобы добавить дженерики Да и не сделать так чтобы памяти кушалась вдруг сильно-сильно больше refication в принципе подходит по всем пунктам Кроме того что сделать его довольно сложно Почему сложно Ну вот сейчас как раз я об этом немножечко Расскажу какие есть проблемы в том чтобы в принципе как я уже говорил при каждой при каждой новой версии у нас добавляется какие-то фичи при этом есть баланс между тем что печки работал быстрее я взял сделал немного синтетических тестов который замеряют время проверки типов которые которые ожидает функция какая-то то есть вот есть функция без типа аргументов с типом Рэй микс и класс и на этих тестах получилось так что если мы не указываем тип то есть принципе проверка типов в принципе не происходит конкретно когда аргумент передается функцию то такой вариант самый быстрый если мы указываем имя класса какое-то то видимо там еще класс реализовывается еще какие-то дополнительные проверка происходит то есть вот он практически на 20 процентов на этих тестах конкретных медленнее работает в принципе в таких динамических языках чем больше типов тем больше проверок в рантами тему чуть медленнее работает с этим вот нужно как-то будет баланс находить Какие еще есть Проблемы есть проблемы с синтаксисом вот Вполне себе валидный код PHP который сейчас поддерживается если так присмотреться кажется что там внутри есть на самом деле дженерика нету PHP сделать не явное преобразование там будет 2 болевых типа вот Но вот такие вот коллизии они должны решаться нужно их как-то обходить и про синтаксис принципе я хочу немножечко побольше рассказать вам дальше нам потребуется чтобы немножечко рассказать вот где он в принципе используется в PHP Мы сначала пишем код потом используется лексер парсер для Что для того чтобы построить абстрактное синтетическое дерево это дерево компилируется в обход его коды сохраняется уже как бы обхода вот там как раз таки синтаксисы нужен какой как в принципе PHP сейчас парсит код он использует для этого байса байса это генератор парсеров с помощью него мы можем описать синтаксис какого-то языка из генерировать парсер для этого языка который сможет построить абстрактное синтаксическое дерево вот здесь на примере такой маленький пример простого калькулятора синтаксиса простого калькулятора если мы добавим еще немножечко кода сгенерируем парсер то он сможет распарсить синтаксис такого калькулятора и вывести значение его с помощью вот этого байсона из кода на PHP получается как раз таки абстрактность синтетическое дерево Какие с этим есть Небольшие проблемы Вот исходный код PHP использует bysson bison поддерживает два алгоритма один из них который он сейчас использует он как раз таки плохо обрабатывать такие исключения такие вот коллизии о которых я недавно рассказывал он может переключиться на другой алгоритм там с этим можно как-то работать А есть такой пакеты Попова пить парсер который используется везде он используется во всех большинстве линдеров он используется при кодогенерации очень много где при этом он использует для парсера который именно вот я как-то аналог байсона Но использовать он может только один алгоритм который как раз таки плохо обрабатывает эти вот ошибки синтаксиса по хорошему нужно перевести его на байсон но пока что это вот довольно сложно потому что я который использует PHP parser написан на PHP байсом в общем-то написан на си и вот нужно как-то вот перевести так чтобы можно было Использовать байса можно обойти это ограничение с другой стороны у Никита Попова Есть еще одна библиотека которая строит абстрактно синтетическое дерево и при этом оно использует парсер который уже встроен в PHP то есть тот Паркер который сгенерированной который есть PHP используется вот в этом экстеншине проблема какие есть во-первых его нужно дополнительно ставить не очень удобно во-вторых вот таким методом можно распарсить только версии либо текущего версии PHP либо предыдущей версии PHP то есть не получится раз парсить например на версии 7.4 версию 8.0 с какими-то новыми фичами с новыми синтаксисом добавить какие-то фичи туда новый синтаксис тоже не получится вот я попробовал сделать такую же библиотеку но с помощью одной проблемы по крайней мере для меня меньше мне не нужно ставить дополнительный экстеншн потому что фай ставится по умолчанию но при этом такие же ограничения вот на версии на какие-то фичи если мы вдруг захотим добавить там чтобы на будущее их нету Какие еще есть проблемы с реализацией но rfc еще не готов то есть нет документа конкретного по которому можно было бы уже начать делать дженерики вот для примера один кусочек кода У нас есть класс дженерик и квас а и квас б который наследуется от класса А если мы будем сравнивать дженерик в которой передали кваса который передали класс B то есть таким типом кто для стирания типов такие классные потому что класса А и Б они сотрутся и получится сравнение одного класса с другого одного и того же они будут равны если мы использовать будем мономорфизм подход то для каждого такого класса А и Б сгенерируется конкретные классы и они будут уже не равны если мы будем использовать рефекции то в зависимости от подхода который там будет реализован можно сделать и так и так это одна из самых тоже больших проблем Это очень много кода для изменений то есть придется очень много кладоизменить очень много тестов написать Ну хорошо PHP втянуть как-то не очень получается а Давайте попробуем тогда сделать дженерики PHP на самом PHP Какие сейчас есть принципе решение Ну вот есть аннотации самая сейчас распространенная мощное решение используя мастера не типов потому что вронд айме аннотации этих нету комментариев этих нету синтаксис языка не меняется дженерики пишется через аннотации проверки типов только при стационализе при этом как я уже говорил если вот у нас не использует кто-то не использует ES подсветкой аннотации кто-то не использует в проекте linter на постоянной основе Вот то такие аннотации могут встревать за ним Нужно следить Вот и их поддерживать не всегда удобно опять таки проверки типов происходит только при стад анализе в ран тайме проверок никаких не будет каких-то таких железных проверок что обещают типы программиста их нет в фронтайме у спати есть библиотека которая может например делать коллекции с каким-то типом вроде все хорошо но при этом этот тип мы не сможем указать в качестве типа аргумента какой-то функции то есть вот он синтаксис языка опять-таки не меняет можно сделать определенный список с каким-то типом но передать его уже в качестве типа аргумента не получится то есть вот наглядности вот этой при написании при проверке нету но при этом до проверки все вратарь происходит у Time To Go есть библиотека такая более поинтересней вот на последней строчке использования дженерика вроде бы как но не совсем понятно что там в принципе дженери но используется встроенный автолодер свой он понимает что там есть у класса Maybe есть дженерик для класса std класс он найдет квас дженерик мэйби и вместо типа Type поставить sd-класс его он сохранит систему и уже подгрузит вместо использования мы без вас здесь используется когда генерируется конкретный классы он не меняется языком абсолютно валидный все эти конкретные класса сохраняется на файловую систему но при этом нужно использовать встроенный автолодер и синтаксис он конечно не изменен но читать его сложно вот такой вот с таким такой подход он сложный для чтения для написания при этом проверке типов происходит время рантайм что собственно Очень круто и самое такое интересное это у версии Max есть тоже библиотека для дженериков она уже меняется синтаксис языка и работает примерно так же как и предыдущий вариант он для каждого вхождения дженерика генерировать свой конкретный класс и поставляет его опять-таки используется свой автозагрузчик используется как предыдущем предыдущий разрешен уже добавлен новый синтаксис просто так на PHP такие классы не получится исполнить сгенерированные классы подгружается через его необходимо встроенный автолога использовать но при этом Да все опять-таки очень круто во время runtime все происходит все проверки Ну да как и как же сделать на PHP ну для начала нужно добавить новый синтаксис парсер а потом нужно найти места использования дженериков в коде Не сами А места использования для каждого такого вхождения использования дженерика для каждого конкретного набора аргументов для дженерика нужно сгенерировать конкретный класс и уже этот класс вместо использования подставить Ну хорошо я взял Вот парсер Никита Попова взял синтаксис который там был и туда дописал дженерики с помощью яко сгенерировал новый парсер добавил немножко кодов саму библиотеку и собственно теперь с помощью этого парсера можно парсить новый синтаксис дженериками получать абстрактно синтетическое дерево вот прям круто Теперь написал библиотеку которая ходит по всем файлам и Source и ищет вхождение дженериков вот для каждого такого вхождения дженериков для каждого набора аргументов она генерирует конкретный класс и сохраняет его в директории кэш паровую систему Затем в composer jesson нужно будет указать что при загрузке файлов нужно будет ходить сначала в директорию кэш только потом в директорию Source для такого решения нужно чтобы у нас было как минимум три файла первый файл в котором будет автозагрузчик подгружаться от композера и в котором будет использоваться класс в котором используется дженерик Второй файл это класс в котором используется дженерик и третий класс на сам дженерик То есть первый класс в нем первый файл в нем синтаксис не нарушен его может обрабатывать Вот сам PHP а второй третий класс в нем синтаксис уже нарушен Поэтому при его подгрузке используется вот эти вот наши закошированные файлы в которых уже есть валютный синтаксис вот здесь для примера Да у нас есть файл индекс.php в нем вот на первой строке подгружается на следующий используется класс юзечь и юзать он уже достается из директории кэш в каше уже используется конкретный конкретный для этого написал команду для композитора который проходится и все это генерирует плюс он может проходиться генерировать не только для директории Source но и также для венторов то есть написали библиотеку с дженериками подключили свой проект там есть вот она сможет сгенерировать не только для ваших библиотеки Ну вот для не только для ваших библиотеки Насколько быстро все это работает конкретные классы генерируются заранее поэтому их можно кэшировать Но чем больше конкретных классов тем больше тратится времени на их подключение на проверку типов на хранение в памяти то есть вот эти все основные минусы при мономортизации нельзя использовать без композеров telloat Ну вроде не такой большой минус reflection reflection нету Как я говорю для монофизации reflection не может быть и самое больное это поддержка синтаксиса вы его пока нет например нет поддержки дженериков Ну потому что даже до сих пор все еще не определен свой до конца работающего плагина для протокола lsp тоже нет такой протокол который позволяет написать свой сервер и с помощью этого протокола с сервером и общается и может подсвечивать синтаксис новый какой-то который вот она до этого не умела подсвечивать там распознавать как-то какие-то подсказки делать Хак язык который основан на PHP в котором сейчас есть дженерики Раньше вроде как поддерживался в PHP но сейчас нет поэтому вот синтаксиса с дженериками шторме нету вскоре в принципе есть поддержка его спи Но для PHP с дженериками синтаксиса сервер такого нету Есть плагин для Хак там есть поддержка синтаксис вот этого Хаксли но не так удобно как PHP Шторм использовать со всякими подсказками Ну в общем на этом все на последнем своде ссылку на библиотеку с дженериками там есть еще ссылочка на эту презентацию Ну в общем я готов сейчас буду отвечать на ваши вопросы Все спасибо"
}