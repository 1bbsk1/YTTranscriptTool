{
  "video_id": "qd9POgbSuNM",
  "channel": "HighLoadChannel",
  "title": "Make form validation fun again / Павел Ловцевич (LOVATA)",
  "views": 2284,
  "duration": 2793,
  "published": "2017-06-28T07:06:54-07:00",
  "text": "я целью этого доклада я ставлю демонстрацию вам возможностей api покажу вам какие-то не очень удобные не очень удобную архитектуру в чем-то какие-то проблемы с кроссбраузерность и попробую вам показать как эти вопросы как некоторые из этих проблем можно обходить для того чтобы полноценно иметь возможность пользоваться встроенной а пешкой валидация браузеров меня зовут павел коваль мне уже представил а я работаю в компании ловато на позиции технического директора и так же у нас есть свой собственный проект стартап в сфере мид тихо называется туда убивай я такую же позицию там занимаю и это наверное основной продукт с которым мы сейчас работаем кроме этого наша компания специализируется на проектах в сфере экономики совместного потребления мид тех а как я уже сказал и в последнее время немножко мы работаем с проектами в сфере интернета вещей validation валидация это как видите очень серьезная штука если даже ребята из международной организации по стандартизации придумали целое определение и ввели его в как международное понятие пропала презентациях все хорошо домой ok значит validation валидация в частности валидация форм это очень серьезная вещь с точки зрения пользоваться кого интерфейса потому что от успешной работы пользователей с формами зависит напрямую успешность проекта в том числе связанные с конверсиями там и так далее поэтому это серьезный вопрос который нужно серьезно подходить и w тряси попытались нам помочь сделать сделав спеху специальную встроенную в браузер специальная песка встроенные в браузер и для того чтобы упростить нашу жизнь ну так ли это или нет мы посмотрим в процессе моего выступления основными целями валидации вообще являются в первую очередь получение нами как у потребителями скажем так корректных данных в корректном формате в ожидаемом формате для нашего приложения для того чтобы могли с ними корректно работать корректно обрабатывать соответственно давать таких фидбэк пользователю вторая цель это защита самого пользователя потому что в частности можно привести пример с паролем до слишком простой пароль если мы позволим пользователю сделать его это может привести в конечном итоге контент комплиментации аккаунта самого пользователя и ну и соответствующими потерями в том числе репутационными для проекта ну и защита самого приложение опять же мы должны получать данные в нужном формате консистентными этом и так далее для того чтобы наше приложение было в меньшей степени к возможно как комплиментации к взломам опишите называется конфликт вальдшнеп и это большое api которая включает себя изжил скриптовые через на участие и позволяет нам а без использования дополнительных скриптов проводить валидацию валидацию данных она имеет несколько методов а коль я тебя попрошу сделай пожалуйста контроллер чтобы у меня по частям появлялись слайды обнови просто страничку контроллер или control shifter а все окей спасибо значит там есть несколько методов есть несколько свойств основные у вас на экране первый метод чек validity он на самом деле в целом такой относительно бесполезный потому что все что он делает он позволяет вам получить понимание о состоянии поля валидно она или не валидно она возвращает вам труфелс соответственно а также генерирует специальное событие которое событие не валидности поля который можно отловить с помощью css второй метод report validity он уже более интересен и потому что он помимо того что возвращает знание о том валит на поле лет он еще возвращает описание ошибки в виде системного облачко которая всплывает браузерах но здесь есть проблема этот метод во первых не поддерживается пока что никаких никакой из версий браузеров от microsoft а во вторых он имеет один очень серьезный изъян реализации в хроме которые мы я попытаюсь вам про демонстрируется процессе этой презентации третий метод сетка as the validity он предназначен для задания кастомного сообщения об ошибке которые выводятся в системном облачке браузера мы тоже посмотрим как это как это делается он точно так же и его по главной особенность что помимо того что вызывает это системное облачко с ошибкой он еще из передает состояние полю если мы облачко вызвали то поле автоматически становится инвалид и к сожалению а фишка это большой изъян в архитектуре описки она не имеет состояние вылет при для того чтобы вернуть полю велит нам придется передавать пустую строку с помощью этого метода свойства welded возвращает нам по сути знания о том какой из полей будет варьироваться то есть до травли ваем это свойство на конкретное поле и получаем ответ будет она вы участвовать валидации соответственно возможности саммита формы или не будет и третье свойство валить и второе свойство видите это по сути лучшая замена методу чек validity потому что она помимо она не просто возвращает вам понимание валить на поле или нет она возвращает целый объект с набором свойств уроды ограничениях там длина строки величина числа там и так далее поэтому это более удобный способ для того чтобы понимать что конкретно произошло с полем не так поддержка в принципе в целом неплохая как вы видите но со своими нюансами как это обычно бывает здесь единственно особняком стоит opera mini ну как бы и черт с ней в принципе это уже я сказал достаточно мертвые браузеров и к популярности которого прошел на мой взгляд поэтому можно в принципе на мой взгляд не учитывать его при принятии решения о том использовать эту а ты или нет своем проекте переключить a slight пожалуйста о есть первый способ задания ограничений с помощью а фишки это указание на обязательность поле мы просто вставляем в нужное поле в качестве аргумента были фрагмент рак варят и соответственно браузер начинаете считать это поле обязательно к заполнению и не принимать запрос на отправку формы пока в поле что-либо не будет введена коль сейчас нужно будет помочь значит в первом поле в виде в любой символ пожалуйста вот обратите внимание у нас изначально форма была красного цвета и поле первой была красного цвета значит что означает эти рамки внутренняя рамка и the field внешняя рамка это сам элемент форм так вот свойство валидации на основе браузерного пи consolidation она дает вам понимание состояния валидности не только поле но и группы поли если они обернуты хелсет и самой формы если хотя бы одно поле внутри там валидно или не валидно в принципе неплохо во дела только единственное чем нужно помнить edge и интернет эксплорер к сожалению не позволяют получать информацию о валидности полей и не пробраться не позволяет пробрасывать эту информацию на фил set in a form при определенных обстоятельствах это может служить проблемой если вы будете пытаться делать валидацию форма чистом css частности у вас будут проблемы с тем чтобы управлять возможности кнопки отправки сообщения тоже это покажу но в целом как бы я сомневаюсь что кто либо из вас здесь в принтер много ли вообще людей знало о том что в наффилд это на форма пробраться состоянии валидности формы вот просто интересно но я бы сказал 5-7 рук наверное да поэтому в принципе не считаю это большой проблемой вы просто будете об этом знать и как бы когда появится поддержка в фиджи допустим тогда уже можно будет это использовать пока это не составляет большой проблемы вы обратили внимание наверное на то что кнопка у нас изначально была в состоянии валидности у нее была зеленая синюшка вокруг это дефолтное состояние кнопки при любом состоянии формы она в принципе не имеет состояние не валидности за одним единственным исключением в фаерфоксе есть специальный верны интерны интерны псевдо-класс массами тонзиллит который применяется к кнопке если она сделана не с помощью баттона с помощью input type батон тогда мы можем получать состоянии не валидности for any валидности кнопки если какие-то поля формы не валидны в этот момент сын верит в принципе все то же самое за исключением велит за исключением того что кнопка постоянно у нас валидно ну а feels эта форма не точно так же в реджине поддерживаются вот на этом дыма я попробую вам показать что в принципе мы можем обойти это ограничение место невозможности принять кнопкой состояния валидности инвалидности формы коль в by пожалуйста да вот мы начинаем взбивать у нас кнопка уже становится валидный это обход не неспособности самого constraint валидация работать с формой сейчас я покажу как это работает а коль я понял с ними фокус вода значит мы обходим это простым способом мы просто смотрим валидно она или валидно бесполезно мы можем управлять возможностью отправки формы мы можем просто на основании понимания валидная форма или нет дизай возможность клика по кнопке соответственно возможность отправки этой формы это вам поможет если вы захотите попробовать сделать валидацию на чистом css и готовясь к этому выступлению я в чатике телеграмму этого мероприятие увидел вот такое забавное сообщение в котором один из участников мероприятия сообщил о проблеме с формой в которую можно было убить свое имя для того чтобы он напечатали красивую визиточку все это решалось решается всего лишь одним атрибутом которые к сожалению почему то разработчики не применили хотя это никак бы не составляло бы для них каких-то больших трудностей решило бы такую элементарную проблему пора пора пора аргументов пара выжимание аргументов нет правила по пара атрибутов спасибо пара атрибутов мин lenso maxx ленс предназначены для того чтобы как раз обрабатывать такие ситуации если вы не хотите чтобы ваши пользователи вбивали большее количество символов чем вы готовы принять то вы можете использовать эти бутман мартенс это не в последнюю очередь может вам помогать с точки зрения решение технических вопросов ограничений например когда вы можете принимать в определенные типы полей в базе данных там ограниченное количество символов и задача браузеров не дать пользователю вбить большее количество символов чем вы установили в качестве ограничениям принципе они так и работает нарушений ограничения отлавливается с помощью java script а я с помощью css в джесси это два свойства тут уж worth it along который возвращает true или full зависимости от состояния поля а все связи и как вы видите мы можем быть только только отловить в принципе состоянии валидности инвалидности соответствии или несоответствии этой паре ограничений mdn вас немножко обманывает говоря о том что out of range тоже должен срабатывать по крайней мере на ограничение max ent но это неправда потому что я погиб ковырялся успехи specs по большому счету явно говорит что out of range предназначен только для числовых полей для полей у которых стоят ограничения мин макса которых мы подальше говорим поэтому не ведитесь на эту ошибку внедрением очевидно очевидный способ применения коль в виде пожалуйста первое поле два символа во второе поле виде пожалуйста тоже два символа но вот в принципе минимальное ограничение мы отработали а теперь попробуй в любой из полей вести большее количество символов чем 4 вот как как видно нет это не получается сделать потому что у нас стоит ограничение поддержка хорошие это снова нам немножко мешает но эта проблема решаема я покажу как это можно обойти с максимальной с ограничением максимальной длины строки все гораздо лучше не обращайте внимание на вот если вы от же вы увидите там есть поме . фото по веточке связано и с тем что имеет бак связано с тем что он учитывает в валидации формы за дизельные поля и поля с атрибутом readonly то есть поляна который пользователь в принципе повлиять не может и если они будут ошибочны то пользователь не сможет отправить форму используя нативную валидацию поэтому это просто то понимание которое вы должны иметь в виду и учитывать если вы захотите использовать валидацию в данном браузере с этим типом ограничением есть еще один интересный момент значит я поясню в левом поле у нас стоит ограничение от 4 до 2 до 4 не торопись пожалуйста но при этом вы могли видеть что там 6 символов у нас введена коль убери пожалуйста пятерку четыре символа теперь ограничение соответствует тому что мы задали но как вы увидели изначально было 6 символов то есть если вы прописываете для строго для текстового поля для строке и ограничения длинной строки и и при этом вы указываете в качестве дефолтного значения большее чем это ограничение браузера его отобразит и при этом он валидация не сработает пожалуйста во второе поле фокус ввода переведи здесь стоит ограничение минимальной по моему три или четыре попробую начинать вводить вот ситуация тоже самое даже если у вас будет дефолтное значение меньше в меньшую сторону точно так же браузер во лидировать это не будет с ними пожалуйста фокус это такой сюрприз вам от разработчиков описки это единственный случай когда дефолтное значение него лидирует со пока пользователь не начнет с ним что-то явно делать все прочие значения связанные с ограничениями либо вы лидируете изначально либо нет возможности в принципе в бит что-то не валидные как случае с числовыми полями я это покажу тоже далее 2 точнее уже третий способ ограничения пользовательских данных это ограничение на основе паттерна паттерн и это стандартные 1 подобные регулярке которым мы привыкли в java скрипте ничего особенного здесь нету но это пожалуй самые хорошие с точки зрения поддержки типа ограничений наверное сложно что-то сделать с регулярными они либо работают либо не работает поэтому в принципе если вы захотите что использовать эту описку используя только паттерн вы гарантированно получите 100 процентный рабочий результат основные пожалуй приемы которые можно использовать при использовании применять при использовании паттерна это возможность задания диапазонов ограничений на диапазон ограничения на вот только букв но вот только чисел какие-то вариативности и ограничение на длину строки длина строки вы помните что в ядре есть проблема с поддержкой midland как это можно решить вы можете использовать ребута midland подставить руку помощи вашему хрому ваш имиджу в виде паттерна да разумеется в джейс вы будут возвращены две ошибки но понимая как вы палевого лидируете вы можете обрабатывать этого это понимание и соответствующим образом реагировать на него значит есть еще один нюанс связано с тем что обозначение начала и окончания строки регулярке она является опциональным при использовании скантр инвалид с кан straight вальдшнеп и поэтому вы можете как писать указывать это ограничение это начало и окончание строки так и не указывать эти записи будет равнозначно и будут работать разумеется когда мы используем жесткое ограничение на основе регулярке мы ожидаем некие строгий набор некой строгое соответствие нашему ограничению пользователю нужно как-то об этом сообщить ограничение на основе паттерна это единственное ограничение которые позволяют нам выводить в системная облачко кастомное сообщение бизнес пользу javascript а для этого вам необходимо прописать атрибут тайтл нужному полю и вот это сообщение будет выведена в системной облачко после того как будет окончена как будет произведен процесс валидации если в нем возникнут ошибкам давайте попробуем право лидировать почтовый адрес я буду опираться на минске почту в адрес так как я из минска каждый индекс у нас начинается обязательно с числа 220 и вдаль и дальше указываем что мы ожидаем от пользователей если он ведет не в нужном нам формате и посмотрим как это работает а коль не вводи пожалуйста ничего сначала на с ними просто фокус а поэт посмотрим как работает применение трибута тайтл вот сейчас пожалуйста нажми на кнопку отправить мы получим него ли дна и полей и начинаю вводить не валидный адрес не валидный yandex вот вы видите что мы увидели здесь стандартной системой сообщения плюс 100 сообщений который мы прописали в тайтл здесь есть один нюанс данная презентация запущена в хроме будет тот который является родным для локали вашего браузера если бы был это англоязычный браузер даже при русской вот различные локали вашей операционной системы и все равно увидели бы англоязычное сообщение для того чтобы работать с этими с этими задачами вы можете воспользоваться фокусники пожалуйста вы можете воспользоваться специальная пешкой которыми достаточно формат дата время формат денежных единиц и так далее а сильно подробно мы на этом остановиться не будем можете самостоятельно покопать в эту сторону и посмотреть как работает интер залезаешь на пин это был набор простых видов ограничений в конце лета вальдшнеп и которые применимы классическим текстовым полям так стерео текст type texting & пулевым атрибутом типа ради обратная checkbox и так далее но разработчики и спецификации не остановились на этом они предлагают вам новые типы полей на основе семантики значит первым набором типа типов полей является email такая тройка email телефон и юрл телефон в данном случае он по сути не сдает самоограничение по себе его главная задача видами ограничений потому что они вводят такой встроенную регулярку для того чтобы задать определенных как бы встроенный паттерн для каждого из типов полей валидация емейла встроенная оно достаточно мягкое вам достаточно в виде ввести число либо букву до собаки поставить собаку и ввести число либо выкуп после собаки и браузер будет уже считать что это корректно и валит на и поле в принципе поспеть и так и есть но если вы хотите использовать более жесткую сложную валидацию по пути по e-mail вы можете его спас пальца дополнительно паттерном помимо прочего email тоже влияет на клавиатуру он в клавиатуре добавляет дополнительную кнопку в виде символа собаки тип юрл тип полем точно также имеет простую регулярку стройную и призван включить дополнительную кнопку чаще всего это кнопка . комп современного домена в сети интернет для того чтобы пользователи могли вбивая в это поле какой-то url-адрес быстро указать этот домен эти типы полей поддерживают уже рассмотренные нами типы ограничений но имеется в java скрипте все с свое собственное обозначение этих ошибок вот собственно griptight мисс матч это новый тип ограничения которые мы можем отловить с помощью java скрипта и он будет связан именно с типом семантики поля как я говорил в принципе поля в sepsis с нам сложно отловить что конкретно за ошибка произошла большинстве случаев мы имеем возможность только увидеть валить на поле или не валидно попробуем с помощью этого поля от разграничить обязательность обязательность ввода данных и семантику поля видеть что-либо у вас зеленый 1 зеленый у меня тут цветопередача похоже когда мы начинаем что-то вбивать то а первое указание об ошибке становится у нас зеленым говоря как бы нам о том что все верно это уже в биты это какие-то данные попробуем ввести теперь e-mail коль ну вот один символ здесь как здесь простая валидация один символ и браузеры считает что в принципе это и моим мы можем с ним работать с ними пожалуйста фокус как это реализовано есть специальный псевдо-класс placeholder шоу который позволяет нам детектив поля в которых отображается placeholder как мы все знаем если placeholder отображается значит в этом поле не введены никакие данные от пользователя соответственно мы можем понимать что если placeholder нос не отобразился псевдо-класс не сработал значит у нас поле заполнено а таким образом мы можем имитировать без применения java скрипта вывод сообщения о том заполнено поле или не заполнена выглядит это следующим образом мы placeholder шел используем в паре с всегда селектором отрицание нот и соответственно читаем если плейсхолдер не отображается то мы выводим ошибку который находится рядышком с нашим полем тип валидации типа уже имела мы выводим с помощью стандартного сообщения варит инвалид на самом деле это является каком specs предусматривает специальный псевдо-класс юзера которые пока не имеет реализации ни в одном из браузеров и он призван во лидировать только те поля которые имеют реальную ошибку от пользователя они они являются невалидным и по умолчанию например а так как они не заполнены а это уже тип ограничения валидации следующий важный тип ограничению настави семантики это числовые поля с ними все обстоит несколько хуже потому что они имеют некоторые баги в разных браузерах поле которое мы отловить и помощью соответствующих инструментов далее ошибка типа полем а и запрещать пользователям вводить не числовые данные ну например firefox этим не справляется он позволяет вам вести все что угодно но тогда будет срабатывать вам будет возвращаться если будет запрашивать свойство бутылку вам будет возвращаться в труп соответственно вы будете понимать что в данное числовое поле введена не число также это поле имеет пару атрибутов которые призваны задать величину этого числа то есть не просто длину строки и величиной числа и также вы можете задавать ограничения на основе кратности числа заданному значению если вам это необходимо например вы продаете обувь только ну парами допустим специальный псевдо-класс in раньше out of range это единственная псевдоклассы всей sense которые позволяют вам хоть как-то разграничить ошибки без применения java скрипта они реагируют на непопадание знать числового значения в заданный диапазон мин и макс внж есть баги мы сейчас тоже их рассмотрим попробуем сейчас выделить вот эти три разных типа ошибок обратите внимание коль попробую вбивать что-нибудь не числовое в это поле но почему он набирает но у него ничего не получается фаерфоксе мы могли бы вбить также это поле получает специальные специальные управляющие элементы виде стрелочек которые с помощью которых мы можем изменять величину на заданного значения в виде пожалуйста единицу поле арклайт отлавливается тем же самым способом которые я вам уже продемонстрировал в виде пожалуйста теперь двойку диапазон величин и значения данного поля равняется 2 2 до 4 как только мы ввели двойку то у нас range попал в ограничении валидации но так как кратность у нас также равняется двум он тоже попал в виде пожалуйста тройку поле заполнено в диапазон мы попали но при этом мы не попали в кратность как мы это сделали опять же напоминаю здесь ни строчки java script on с ними фокус пожалуйста попадание вынырнешь ну логично да мы используем а псевдо классный range то здесь есть важный момент in раньше срабатывает только тогда когда есть явные данные которые можно вы лидировать то есть если мы и для пустого поля и раньше всегда будет валиден потому что нам ни к чему применять эту кратность и вот для того чтобы опять же обойти эту ситуацию так как у нас юзера пока не поддерживается браузерах мы используем но к из holder шоу для того чтобы понимать что есть что вы лидировать и только тогда мы применяем этот псевдо-класс ну а вылет мы с помощью вылет мы отлавливаем непосредственно уже ошибку шага это не то о чем вы подумали это не тот это лишь понятие just in time во время а вы видели что все дымке изначально имеют состоянии валидности и не валидности на самом деле пожалуй лучшим способом проверки данных является не проверка по ходу набора этих данных в в поле потому что это выглядело бы примерно так как у вас за спиной стоит преподаватель по русскому языку и по мере диктанта когда вы пишете слова он каждый раз когда вы набираете пишите каждую букву будет вас бить по голове учебником говоря о том что ты сделал ошибку но вы еще просто не закончили написание этого слова то же самое происходит с валидации вы лидируете поля только тогда когда пользователь явно закончил с полем работать это возможно следующими способами как я уже показывал с помощью такой целый простыни псевдоклассов css мы проверяем на то что поле у нас является заполненным и мы проверяем является ли но фонов фокус если поле фокси значит пользователь все еще работает с ним если она не фокси значит он закончил работу с ним и если поле при этом является невалидным соответственно тогда мы можем обрабатывать эту ошибку явно указывать на нее пользователям коль попробуй пожалуйста вбит что-нибудь здесь с ними фокус вот то есть мы показываем что поле него видно только в тот момент когда пользователь явно закончила работать с ним набери что-нибудь похожее на e-mail с ними фокус вот теперь мы горим пользователь что все окей на самом деле с точки зрения валидности не обязательно дожидаться окончания набора вы уже в принципе можете в процессе набора показать что все окей ну об ошибках обязательно горите только после того как вы убедитесь что пользователь закончила работать с вашим полем в случае срыва скриптом достаточно отлавливать события angler для того чтобы начинать работать с ошибками пользователям вот в частности мы можем сейчас посмотреть на демонстрацию работы свойство рапорт validity который продемонстрирует вам очень некрасивый неприятный баг в браузере google chrome кальби пожалуйста что нибудь не являющийся емейлом попробую снять фокус из этого поля смотрите значит как рука ведет себя google chrome когда он находит поле с ошибкой он выводит сообщение об ошибке и переводит фокус ввода туда и вы никогда не сможете снять фокус ввода из этого поля пока не исправить эту ошибку вся эта ситуация усугубляется тем что системное сообщение об ошибке появляется однократно исчезает через 55 секунд поэтому на самом деле использование системных облачков об указании ошибки является такой скользкой дорожкой со множеством проблем и да и ваши дизайнеры и разумеется не будут рады тому факту что вы никак не можете повлиять на внешний вид этих облачков потому что они не поддаются стилизации в принципе в кроме на определенном диапазоне версии были специальные вен жирные псевдоклассы для этого но потом они были выпилены из из браузера в виде пожалуйста сейчас email и теперь с ними фокус вот теперь как видите фокус снимается поэтому как я уже говорил report validity не самое удачное решение лучше будем использовать пользоваться друг другим методом с отказ там validity мы точно также можем работать с этими булочками но задавать свои собственные сообщение они могут дублировать те же системные сообщения но в такой ситуации вы не столкнетесь с богам в chrome связанным с тем что в ней пользователь не сможет снять фокус ввода пока они не исправит ошибку в поле работа с отказ навалились выглядит примерно следующим образом вот в частности мы можем видеть что мы вешаем обработчик на снятие фокуса ввода с поля которые мы собираемся вы лидировать и дальше мы проверяем условие в данном случае мы проверяем что например поле допустим это поле является полем типа e-mail и мы проверяем соответствует она этому типу или нет и соответственно если он не соответствует мы выводим кастомное сообщения об ошибке в самом начале когда я говорил об этом методе я говорил о том что это поле этот тип метода помимо того что выводит сообщение об ошибке для выбранного поля с ошибкой он еще и передает состояние валидности и не ли вы не валидности полю поэтому если вы передали сообщение кастомное поле стало невалидным вас должен быть альтернативный вариант когда вы снимите состоянии не валидности у поля и делается это вот таким вот образом вам просто необходимо передавать пустую строку это вот тот самый неудобный то самый нидус в архитектуре а фишки которая не предоставляет нам в принципе метода задания валидности с помощью какого-то свойства там или отдельного методом но здесь важный нюанс который позволяет вам обходить по сути все огрехи в реализации все неудобные архитектурные моменты вам достаточно взять управление валидации в свои руки для того чтобы не сталкиваться с богами как это выглядит вам необходимо прописать булев атрибут но валиде это для элемента формы что это нам даст значит в первую очередь он включить системное сообщение то есть вы должны понимать что если поле будет невалидным сообщение уже не не будет показываться но при этом он сохраняет состояние валидности него лили не валидности который будет продолжать отлавливается с помощью скриптов и с помощью ваших специальных селекторов в рейтинге ли ты и раньше out of range но при этом он позволяет отправить форму поэтому получив возможны новые ляды сохраняет состояние но в состоянии валидности него лености плену при этом передает управление возможностью отправки формы в вашей руки так в принципе вот это блок listen кода который вы уже видели но как можно вмешиваться в процесс валидации вот здесь вы видите условие при которой мы проверяем свойства на наличие или отсутствие конкретного типа ошибки вот эта та точка в которой вы можете вмешиваться и по сути писать любые условия свои собственные но при этом иметь возможность передать состоянии валидности инвалидности поля чем это отличается от каких-то привычных воды для вас инструментов валидации каких-то привычных библиотек это похоже на семантику вычтем эл да то есть вы можете писать все дивами оформлять как заголовки списке ссылки и так далее здесь то же самое вы можете сколько угодно разукрашивать ваши поля с помощью без применения api и показывая что они валидные не валидный но при этом семантический они всегда будут в неопределённом состоянии и я на самом деле не готовлюсь к этой презентации я не проводил исследования относительно скрины лидеров но я знаю что некоторые нюансы эксперт и аспекты screen лидеры учитывают при работе с с полями поэтому использование нативного способа номинативной валидации позволяет вам по сути использовать привычные его методы но дополнительно позволяет вам использовать возможность семантики валидности для конкретного набора полей вот например как можно было бы вмешаться в процесс валидации у нас в конфликт вальдшнеп и не существует специальный момент за который проверяет соответствие полей но вы можете сделать это сами записав в переменные значения этих полей а потом в в в условии вместе сравнения условия проверить соответствует ли не соответствует с соответствующим образом передать полю состояния валидности элиной валидности данная следующий пример по демонстрирует способ сбора информации о поле для того чтобы потом с ним работать особенность например нативных системных сообщений заключается в том что они выводятся во первых по очереди то есть сначала у разных браузерах то бывает по разному в системном облачке выводятся например сначала сообщения об обязательности поле как только вы его запомнили выводится следующее сообщение это может быть не всегда удобно тем более что если пользователи совершил много ошибок во множестве полей мам множество раз придется а пробежаться по полям и увидеть все эти ошибки и попытаться их исправить мы же можем единожды собрав всю информацию о проблемах с конкретным полем использовать или потом так как нам необходимо либо единоразово выводить для одного поля все ошибки либо держать варианты ошибок прямо в дом в доме страницы и отображать или скрывать их или же держать где ты это в скрипте и дни и динамически выводить их на страничке давайте посмотрим попробуем поле email сохранить переменную далее в переменную мы сохраним о массив из тех видов ограничений на который мы будем проверять выбранное поле с помощью функции shower мы выведем в консоль для того чтобы увидеть как это вообще работает те ошибки которые были собраны для данного поля ну и вот самая магия это собственно говоря обработчик которые срабатывает проверяет наше поле прогоняет вот этот массив ошибок и в дальнейшем выводит их в нашу консоль коль открой пожалуйста консоли в 12 в бей по же здесь стоит два типа ограничений email и длина минимальная e-mail а потому что мы например считаем что три символа для емейла это не совсем как бы у кейт хотя браузер это считает ну мягкой валидации уже считает за email в виде пожалуйста а вот уже вел да вы видите что вывели вывелись ошибки которые были собраны для данного поля мы увидели type mismatch браузеры считает что это не email он видит длину строки слишком короткой не похожи на email теперь виде пожалуйста символ собака символ . два символа хотя бы сейчас не очисти консоль пожалуйста видеть один символ с ними фокус ну вот теперь браузер считает что это что-то похожее на email но слишком короткий и введи теперь пожалуйста точку и любой домен ну вот теперь у нас ошибок нету браузер считает что это что-то похожее на e-mail вот это в принципе тот способ который вы можете собирать информацию обо всех найденных ошибках для полей и в дальнейшем жером обрабатывать работать с ними так как вам будет удобно кроме того вы можете глушить системное сообщение то есть выводят садко оставались вы можете допустим глушить сообщения обычным привет дефолтом если вы хотите работать только с кастомными вот этот голландец его зовут петр паньков в мае месяц опубликовал целую серию статей в блоге разработчиков браузера samsung интернет если я не ошибаюсь которые полностью посвящена вопросам валидацию провел титаническое исследование в котором собраны все факты о том как реально работает данная данная фишка в браузерах на мой взгляд он несколько пессимистичен он не говорит о том что мы можем вмешиваться в процесс валидации и сглаживать вот эти вот острые неудобные моменты описки и по его мнению пока это фишка слишком стара для реального применения на мой взгляд это не совсем так для среднестатистической формы этой пешки более чем достаточно да это непривычный метод валидации но при этом он априори работает быстрее потому что это работает не на уровне вашего джесса который исполняется виртуальной машине он работает на уровне по сути это msi вашего браузера если вы конечно не вмешиваетесь в валидацию с помощью java скрипта поэтому для статистических форм как я уже сказал донатти по валидации вполне себе подходит если во что-то более сложное прочитайте эти статьи пересмотрите мою презентацию и примите для себя решения готова ли ваша форма для применения в для валидации с помощью данная пески среди главных выводов можно перечислить следующие во первых вы можете как я продемонстрировал какие-то вещи валеру я только с помощью сейчас вы можете до того как приедет ваш skype и валидации в браузеры или если он не приехал вы можете уже с помощью css обрабатывать состояние ваших полей дайте не привычный способ решения задачи но это лишь опять же вопрос привычки нужно просто попробовать чтобы сделать для себя вывод это на мой взгляд правильный способ решения задачи как я уже говорил мы не разукрашиваем поля мы работаем с семантикой состояния полей валидности не валидности и проблемы багов и архитектуры это я пешки решаемой я попытался продемонстрировать вам некоторые способы решения отдельных проблем и на мой взгляд это получилось ну и на мой взгляд это отличное место для нового панстарс проекта который бы вывел работа с этой пешкой на более высокий уровень на которые в свое время работу с домом вывел например джек вере обрабатывая все острые углы все неудобства описки или проблемы кроссбраузерность совместимости поэтому если вы хотели начать какой-нибудь интересный java script новый проект эта тема для нас я хочу вам задать вопрос прежде чем закончить свои выступления какой самое главное какое самое главное правило клиентской валидации который я вскользь упоминал в своем выступлении верно разумеется валидация на сервере это главное главное правило клиентской валидации потому что клиентская валидация разумеется подвержена любому вмешательству и соответственно компрометации вашего сервера скрипта поэтому дублируется полностью ваши валидацию на сервере и будете спать спокойно на этом все я готов ответить на ваши вопросы спасибо большое спасибо павел сейчас пока руки поднимаются и мы ведем к вам с микрофонами у меня сразу вопрос о чем это лучше вот того что мы 10 лет назад каждый писали свою библиотеку валидации на джесс были счастливы ну как я говорил здесь я только вскользь интересовался темой доступности screen гидры вот буквально недавно по моему в последнем подкасте веб-стандартов обсуждалась тема того что какой-то товарищ провел исследование что screen гидры уже априори хорошо работают со страницей без всяких во и там ария атрибутов если страница просто корректно семантически размечена примерно похожая ситуация может наблюдаться и непосредственно с полями потому что поляне просто разукрашиваться они имеют некое состояние соответственно я убежден что скрины ритор и даже если сейчас это не поддерживает рано или поздно они будут работать именно состоянием более они с их визуализации спасибо за доклад я тут от меня слышно у меня замечание может даже больше вы говорить что же можно использовать css валидацию в проектах да уже сегодня тем самым избавив исполнении так скажем валидации в же в скрипт новой машине отдав это все движку но у нас есть нюанс то что нативная им и валидация а на него лидирует домино и рф то есть когда мы используем доме врыв занятость валидация будь всегда говорить что это не водить я говорил про возможность из пут комбинации паттерна с семантическим типам полей вы можете задать тип поля email помочь пользователю дополнительными кнопками на экраны клавиатуре но валидацию сделать на основе паттерна который вы считаете будет наиболее точным образом обрабатывать ваших тег ваш тип данных в данном случае email адрес я забыл упомянуть что паттерн имеет наивысший приоритет при прочих типах ограничений то есть если вы задаете длину строки и с помощью атрибутов и с помощью паттерна то приоритет будет у паттерном я понял спасибо у меня вопрос спасибо за доклад как все это работает с автозаполнением не совсем был вопрос ну либо браузерная автозаполнение полей либо это какой-то сторон не автозаполнение которое и скука вперёд она будет влиять за вы за заполнение передача атрибута вылью какое-то значение динамического или автозаполнение автопостановка просто сохраненного именно автопостановка значение а как она должна работать это в принципе относится к валидации просто когда данные появляются они начинают быть подвижными либо валидации либо не валидации не совсем привычный вопрос то есть авто подстановка если мы сбивали какие-то данные ранее вбивали email и в полете поимел по-другому же проекте начинаем тоже убивайте моего браузера говорит нам подставить ранее введенные mail то он подставиться и будет фрезероваться если правильно провел по нему вопрос ну просто это поставляется до обработки или это после вот в том случае когда мы какой то вы задали а потом уже он съел и я пашенку так и не выдал то есть но он его не съест он будет обрабатывать вообще поля находится в состоянии валидности инвалидности в любой момент времени и мы либо обрабатываем это эту информацию за единство исключением с длинной строки при использовании вылью как я показывал уже до во всех прочих случаях поле всегда либо валидно либо не валидно поэтому если мы подставили email браузер тут же ну как бы сам движок сразу же изменит состояние поля на валидно или не валит на спасибо"
}