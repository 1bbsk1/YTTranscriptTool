{
  "video_id": "jOyTCTZHzS8",
  "channel": "HighLoadChannel",
  "title": "Use actors, Luke / Андрей Парамонов (Dodo Engineering)",
  "views": 1490,
  "duration": 2872,
  "published": "2024-04-17T01:10:29-07:00",
  "text": "Всем привет Меня зовут Андрей и я пришел немножечко рассказать про актеры что ж поехали балдеж собственно цель моего выступления во-первых Что рассказать про авторы К сожалению ну или к счастью нам об этом редко рассказывают в университетах мы редко видим подобный доклад на конференции и даже в практической работе многие разработчики редко с этим встречаются редко сталкиваются никого нет практического опыта поэтому хотелось бы это серую зону как-то осветить во-вторых покажу что мы сделаем с помощью актеров и в конце призывать вас обсудить со мной что вы думаете на этот счет Итак пару слов обо мне зовут Меня Парамонов Андрей и я работаю в доме жиринги Это тип подразделения всем известно Додо пиццы найти меня можно по хендлам в Твиттере и в телеграме вот разрабатываю софт преимущественно эти последние 7 Бывает такое И последнее время я в основном их вижу до этого разрабатывал наш платежный шлюз Итак о чем поговорим авторная модель потом как сделать актеры распределенными и в конце про применимость распиленных авторов Итак началось вообще как и все многое из конверсайз чтобы рождено человечеством где-то во второй половине 20 века тогда люди очень активно вкладывались всякие теоретические модели много исследовали много придумывали А техника затем не поспевала к сожалению и всем этим году Карл Хьюит придумал модель параллельных вычислений который назвал автор модел там была череда статей это не очень важно важно следующее что в принципе во-первых Он жив у него есть интересный блок можно его почитать до сих пор пишет с проекторы Ну хочется разобраться что же такое несколько с точки зрения прикладной Так что такое вообще актерной модели эта модель как можно понять настоящая из акторов каждый актер это некоторый примитив параллельные вычисления и собственно акты размениваются сообщениями как можно понять сообщение - это некоторые синхронные коммуникации а собственно Кто такой актор как я уже сказал это примитив То есть это самый минимальный строительный блок вашей модели при этом редактор он работает параллельно с другими актерами можем проверить вычислений и он имеет входную очередь сообщение в которую эти сообщения могут отправить либо другие авторы либо кто-то из определенных системы и автор соответственно получает сообщение в свою очередь в сообщении входную и обрабатывают их Строго по одному и строго полностью вот если чтобы актер можно было сообщение отправить он имеет адрес при этом важно отметить что в оригинальной модели было несколько таких не явных ограничений Первое это отсутствует гарантии на порядок прибытия сообщений То есть у нас есть один актер первый и второй сообщение третьему в порядке 1.2 они могут прийти обратном порядке два один как бы изначально модель Это подразумевает и второе отсутствует гарантии доставки сообщения То есть это всем известная это может он с гарантии не более сообщения может теряться и поскольку как бы сообщение никуда-то отправляются и Возможно даже она не долетит это всегда синхронная коммуникации синхронных вызовов Итак что же можешь сделать актер когда он получает сообщение вообще автор он как примитив состоит из двух компонентов это его состояние и поведение то есть в качестве поведения может либо Отослать конечное сообщение другим актером конечная Потому что сама модель у нас формальная значит число актов которые мы отправим сообщение оно конечно что организовать модель при этом он может создать конечное число новых авторов то есть авторы порождают другие авторы это важный момент при этом он может поменять своё состояние внутреннее на основании полученной информации он может меняться поведение что в дальнейшем такие же сообщения или другие обрабатывать уже иным образом и при этом он может выполнить какое-то произвольное действие например не делать абсолютно ничего так когда я говорю что это примитив параллельного исполнения на самом деле я немножечко лукавлю лукавлю по той причине что к сожалению Ну термин параллельно он достаточно широкого потребим и не всегда про развивает то что мы имеем в виду на самом деле акты Это история про конкурентное исполнение я не буду здесь подробно останавливаются потому что Пайк в своём известном всем видео э очень подробно раскрыл всю разницу между конкретными и парализом надо понимать что актеры этой истории про контенте но я продолжу говорить про реализм потому что ну тут так принято Так зачем вообще нужны авторы Какие проблемы не могут решать смотрите дальше будет очень много моих личных мыслей но всему моментам первое что мы неправильно поняли о п и второе что вообще всё многопоточное программирование параллельно программирование и так далее Всё с ним связано Это очень сложно насчет оп Алан к там когда-то в переписке отметил что когда он имел в виду оп он имел в виду не то что все мы поняли это не наследование полиморфизм вот а история про то что у нас есть сущности у них изолированное состояние они коммуницируют посредством сообщений и применяется связывание то есть всё максимально изолированные ничего друг от друга не зависит ни в каком виде и вторая проблема наиболее важная и принципиальная потому что насчёт Анны какие-то дискутировать это что многопоточное программирование все вариации оно сложность смотреть У нас есть процесс У нас есть тренды системные зелёные У нас есть некоторые абстракции в мастериновых языках типа fitch of и так далее Потому что создавать и брать потоками Это очень дорого дорогая операция У нас есть крутины когда дальнейшее развитие этой идеи У нас есть коммуника началось процессинг Ну представлен например каналами есть все теперь и куча всяких экзотики и в ней никто не разбирается Какие проблемы вообще есть во всех этих подходов во-первых это разделяемый ресурс в частности разделяемая память самая основная проблема Как мне кажется пытаясь решить проблему разделяемую память только То есть когда у нас возникает ситуация при которой один или более потоков выполнения кода пытаются поменять какой-то общее состояние мы применяем либо какие-то механизации либо блокировки они порождают соответственно проблемы с этим связанные это могут быть детлоки могут состояния гонок различные И это всё очень тяжело понимать уложить в своей голове тяжело это очень сильно отлаживать Если у вас на продакшене внезапно ваш сервис раз и никогда делает что-то на что вы не рассчитывали скорее всего Эта гонка и просто ответ ладите найти зачастую не представляется возможным акция как раз изолированного состояния и строгого порядка действий при обработке сообщений это проблема способна решить Итак как же мы докатились до жизни такой что трактор мы не знаем ничего а многопоточным программированием учимся каждый день практически Ну во-первых потому что многоядерные процессоры какие мы их видим сейчас они появились достаточно недавно то есть в 2005 плюс-минус уже массово а до этого вообще бытовое мнение особенно когда huid создал свою модель что у нас будут компьютеры у них будет множество процессоров и у каждого автора будет своего процессором будет на нём выполняться и всё это будет работать но технологии почти немного другим путём то есть ограниченное количество небольшой ядер но зато много потоков и на них всё крутится при этом сами потоки которые потоки операционной системы с ними сложно с ними сложно Сложно По той простой причине что всех победил язык а его дальнейшее развитие в виде плюсов и всё дальнейшее дерево языков программирования от него вошедших э в нём изначально не было вообще никакой помощи программисту при работе с этим То есть предлагалось разработчиком самому идти договориться операционной системы что-то получить что-то и дать и так далее в плюсах это пройдём также никак не было решена тип SD Red появился в одиннадцатом стандарте то есть спустя уже много лет после появления многоверных процессоров в прошлом десятилетия в языках типа Java решали не проблему сложности а проблему чтобы разработчики сами не управлять рядами когда им это не нужно для их задача А чтобы runtime всё сам делал Ну принципиально ничего не было решено и тут отдельно стоят Ребята с кооперативной как бы к ним не относились Разработчики у них как бы свой особый путь свой Vision и если вспомнить язык он всё-таки Он как раз таки очень сильно похож на то о чём говорил Алан кей то есть там объекты не вызывают метод методы друг друга а Они отправляются сообщения прямо на уровень синтаксиса языка это пошло толком во многом и во-вторых сегодня опять так да А в недавно в э из которой развивает компания Pay был добавлен это не тип это даже примитив на уровне языка Эктор сам по себе то есть на уровне языка у вас есть некоторые примитив которые позволяют нам изолировали внутреннее состояние во-первых во-вторых выставлять на оружие какие-то методы которые можно синхронно по в которой можно синхронно по посылать сообщения ресурсер с помощью асинквейта и в принципе есть про позу там подробно описано как с этим работать не думаю что этим активно пользуются хотя на мобилки стоят есть проблема что если главный поток с которого можно иметь UI и Из какого более Поэтому думаю им это особенно актуально но ни в другом языке программирования я таком не слышал чтобы было сделано вот вообще когда мы говорим что не хотим ничего шарить есть целый архитектурный стиль принципа называется черносинг то есть когда мы говорим что у нас есть какой-то запрос на обновление данных и чтобы его правильно обработать без всяких проблем нужно чтобы он был максимально изолирован друг от друга и выполнялся надо ноги подразумевается совокупности э процессора некоторые вычислительные мощности совокупности оперативной памяти и даже отдельные стороны то есть чтобы никогда не возникало ситуация при которой э два параллельных запроса на обновление какой-то сущности действительно исполняется параллельно и потом мы приходим к тому что происходит возникает конфликт в версии и непонятно кто нас победит последний ли или первый э что случится и так далее и в американском многие из вас пишут на так же есть рекомендации что не нужно использовать э Неужели коммуницировать с помощью общей памяти оно нужно использовать общую память для коммуникации как раз-таки те самые пресловутые каналы То есть когда у нас есть Ну со стороны кто-то с другой стороны кто-то этим планеты взаимодействует через общую прослойку но при этом сами её напрямую не меняют там на самом деле много статей было люди защищали докторские по уже распределенным актерам Нам сейчас не очень интересно потому что в 86 году Джо Армстронг не тот который саксофонист не тот который астронавт он вместе своими друзьями коллегами внутри Sony Ericsson решал их внутреннюю проблему и нужно был инструмент чтобы решать задачи целиком и в телекоме очень много значит с параллельными вычислениями много задач с распределёнными вычислениями и они пилили для себя свой инструмент Итак родился эрланг и Судя по той информации что я нашёл Они вообще знать не знали про то что там есть какие-то акты какие-то докторские исследования и так далее они просто решали свою прикладную проблему делали как видели И в итоге то что получилось у них считается одной из эталонных реализации актерной модели вот бывает такое собственно что делать талант там есть концепция называется процессы это некоторые э абстракция это легковесный поток э которые живут изолированно на остальных потоков рамках одной ноды у него своё адресное пространство и он коммуницирует с другими э потоками таким образом что на них орёт Почему орёт потому что синтезит таков что вы э должны использовать знак восклицания чтобы отправить другому потоку процесс сообщения что там появилось такого интересного во-первых они действительно были очень легко весны может стать очень большое количество одной машине физической во-вторых у них есть своя виртуальная машина которая краска позволяет обеспечить самое кон каренса то есть вычет контекст чтобы каждый процесс получал свое какое-то время на процессоре при этом появилось понятие лакоша транспаренс Это когда для вызывающего кода семантически нет разницы идет вызов и отправка сообщения на удалённую машину к процессу удалённой машины или к процессу на локальной машине то есть для вызывающего кода это не принципиально дальше сам разрулит И как вы понимаете даёт большие возможности к линейным и масштабируемости дальше долгое время не происходило ничего было аккор скале в Джаве Вот но принципиально там ничего не поменялось пока в четырнадцатом году ребята из Microsoft research это внутреннее подразделение Microsoft которая занимается как можно понять из названия они запилили Пейпер выпили его в котором обрисовали что они создали фреймворк они передумали авторы назвали Егор линз И что это такое собственно они называли это первым в мире нажимается виртуальными актами во-первых во-вторых Это первый в мире colo вот на эти фреймворд чтобы это не значило В чём суть они во-первых а пере придумали немножечко актера они изменили подход к работе с ними что теперь актёр это больше не какая-то единица вычисления Это теперь такая абстракция логическая То есть вы просто можете отправить ему сообщение и вам не нужно переживать созданным кем-то не создан жив ли он или нет то есть runtime дальше сам всё сделает за вас он сам создаст трактор если он был отправлено сообщение сам его прибьёт если сообщение у него больше не посылаются и прошло какой-то настроенный период времени при этом сохраняет ссылочная прозрачность вызывающему ходу без разницы Где находится эта трактор и находится ли сейчас он вообще где-то э при этом есть автоматическом масштабирование как посредством э сохранения этого авторного подхода когда есть какой-то один instance а в рамках всего кластера так и у них появились так называемые авторы это когда у вас актер имеет только поведение но не имеет внутреннего состояния и так далее их можно создавать он деймонд потребованию для обработки каждого сообщения Прямо даже на локальной машине чтобы избавиться от сетевого хопа и это они реализует там ещё кроме свейс в программе Ну это вот всем плюсы то есть когда у нас коммуникации мы отправили сообщения и мы как бы не знаем что потом произойдёт вернут нам когда-то в ответном сообщении результат или нет тут же нам возвращается фреймворком промис который мы можем выявить и в нём соответственно уже получить результат нашего обращения то есть код простой понятный ну как бы он не взлетел не взлетел потому что это не был просто платформенным тогда взлетел потому что ну Microsoft их технологии не особо были популярны и как бы сам подход тоже не сыскал свои Славы и как-то все это зачахло потом появилась новая идея crls компьютер То есть когда нет серверов А есть какие-то лямбда или функции которые полезная работа Я считаю нужно сравнить и понять Вообще что это такое и возможно ли лямбдами заменить актеры и на самом деле это немножко про разные на самом деле тут есть целый Калейдоскоп проблем которые так вместе сталкиваются и не позволяют им сделать на функциях то же самое что мы можем сделать на авторах проблема много начиная от того что во-первых октора внутреннее состояние у лямбда его в обычном понимании Нет там можно изоляции как-то с окружением можно закаляться с тем что при хранилось состояние куда-то но это не то же самое Это не состояние в памяти при этом у вас гарантированно будут какие-то сетевые задержки на обращение вас никогда не будет обращения локально тоже ноду при этом самый важный монотонная нагрузка она там может мецписано соиди каким-то либо угодным образом но главное что монотонно скорее всего с салямдами можно очень легко остаться без штанов в своём проекте потому что это дорого дорого По той простой причине что во-первых в облаках и сами никак не пойдём во-вторых Потому что опять-таки много очень ресурсов тратится И помимо сетевых ресурсов тратится через ресурсы на то что наши языки современные мейнстримывают у них с виртуальная машина и нужно время на прогрев А вот компиляция к сожалению не там Не там пока ещё не очень не развита и это очень сильно влияет на первый старты запуск каждой Анды Вот и недавно вышла статья от ребят из Amazon Prime вот здесь по ссылочке можно её почитать как они пересмотрели свою архитектуру обработки видео на лямбдах и переписали на распрелённую монолиты сэкономили 9%, э ресурсов на этом переходе то есть не всегда это лучшее решение а далее прокторы вообще как можно было заметить у нас изначально были авторы которые порождают другие авторы были авторы которые просят существуют это два разных подхода Давайте на них дали посмотрим первая модель это иерархическая которая изначально была Хьюит и так далее в других реализациях форланги и представлены например в Аки как такому инстрим фреймворки это когда родитель может автор создать Он решает что с ним делать случае ошибки отправлено сообщение Он приобретет сообщение упал сообщил об этом своему родителю может принять решение либо сортануть актер причем некоторые реализации например как они позволяют вам рестартить автор без потери сообщения в боксе то есть Они отдельно существуют и вы потеряли только то сообщение на котором произошла ошибка вот при этом парадаптер может решить что дочерью актер больше не стоит существовать он сделал свою работу Отправить ему поздно пилу то есть сообщение типа завершайся и при этом Как вы понимаете это самый восстанавливающая система То есть вы устанавливаете тертоговый автор он восстанавливает родители те своих детей вычисления продолжаются в случае же с одноранговой моделью у нас автор виртуально они называются в темноге Орлин с грейнами и там всем управляет runtime частное время жизни каждого актера то есть его созданием его завершением также актер может сам принять решение своим завершении и что важно отметить принципиальная разница это будет гарантированно пока все время по системе То есть она будет доступна и Partition толерант она не будет консистентна в отличие от предыдущей модели потому что мы можем стать немножко поиграться зависимости от решения Например у нас есть три ноты первая вторая третья на Первом одни актер размещены вторую вторые на третью третье и в случае если первого нода у нас выпадает мы можем просто актеры с этой ноты Больше нигде не создавать тогда мы теряем в доступности но справляется консистентность либо же мы можем перестать их на другой ноте тогда у нас опять будет Apple система То есть она будет доступной но мы можем потерять какое-то состояние которое там было незаметно где эти самые актеров различных своих реализациях можно использовать на самом деле примеров очень много это и выстраивание всяких конвейеров один передает другому вычисления имея какое-то состояние которое позволяет ему вычисления производить например какой-то кэш локальный при этом Вы можете в конце месте сделать некоторые пул актеров И тем самым распространенной системе сделать ограничение сверху на параллелизм выполняемые работы даже так дальше это традиционные приложения всяких финтов на пятке есть актер состоянии изолировано асинхронное сообщение нигде ничего не развалится дальше это стриминг данных системы чаты отправка идентификаций Ну там сообщение там сообщение здесь в принципе всё понятно дальше мультивизор Кан Карен это абсолютно весь геймдев то есть один использовался в халат также я слышал что ребята там которые пили Танки и другие игры также зачастую используют актеры для каких-то игровых механик затем Это приложение у которых есть распределенное состояние вынужденный распыленное состояние потому что вам не хватает мощности одной машины для того чтобы все данные в неё в оперативную память загрузить Вы можете опять-таки разбить ваши данные по некоторым актерам которые будете данные хостить сделать кластер из машин они на них разместятся и дальше уже асинхронно пусть гораздо дольше свое вычисления произвести дальше отдельно это интернет вещей Почему так потому что актер во-первых они очень сильных квесты во-вторых работают также как работает ift то есть через сообщение какой-то датчик температуры чего-то еще отправляется сообщение своему актурирует состояние это сообщение потерялось то что изначально Модель этого подразумевает Ну как бы ничего страшного наверное не произойдёт при этом таких актеров может быть на одной машине очень много они легковесны их состояние хранится в памяти вам не нужно откуда его доставать чтобы какую-то коммуникативное значение читать всё хранится памяти и работает достаточно быстро и последнее это когда вам нужно таймеры вам нужно крутить очень много таймеров по разным условиям и нужно это делать в рамках какого-то класса из машин кстати об этом будет мой пример так переходим к примеру собственно я сказал что я из года Додо это про пиццу до Да это про продажу пиццы мы продаем пиццу уже почти в 20 странах и в каждую страну в которой мы выходим нам нужно создавать условия для того чтобы люди могли оплатить в приложение мы все любимые в приложение заказала она к тебе приехала И для этого мы интегрируемся с эквиваленгами а странно помню 20,2 И к сожалению они работают все по-разному то есть нет никакого стандарта Она работает и там прямо полноценный зоопарк и интегрирует с этим прямо задача не из простейших а вот такие проблемы собственно есть смотрите у нас есть платеж так оно ну-ка балыш у нас есть платеж мы хотим там его создать Например у кого авторизовать деньги клиента Мы хотим списать деньги клиента к нам их перечислить Мы хотим отменить и вернуть деньги клиенту команды которые должны понять платеж у нас и поменять платеж у них очевидно что мы меняем когда себя и меняем у них у нас какой-то появляется эффект система наших при этом у этих эти сайты эффекты они могут быть не допотентные да странно какой-то финансовый но бывают аквариум у которых нельзя отправить два запроса на холдирование одного и того же платежа второй гарантированно отвалится или первое отвалится там как пойдёт при этом э команды которые мы испол- засылаем там авторизация отмена и так далее они могут быть ещё асинхронными то есть когда мы не сразу получаем ответ типа 200 ом деньги заходили или вернулись клиенты А когда нам говорят конечно 200 ОК но мы пришли вам на дефекацию В ком что с деньгами клиента ну их э захладировать или не смогли А вы как бы посетить подождите и при этом добавляются еще одно ограничение что многие квали и квайры они еще требуют последовательного исполнения команд то есть мы такие отправим запрос на авторизацию они говорят окей сидишь не нотификацию мы идем дефекацию клиент У него крутится кругляш этот загрузка он передумал платить нажимает отмену мы идем к аквариум хотим отметить платёж он говорит Извините мы ещё ту операцию не завершили но начать не можем Приходите позже то есть Нам нужно ещё последнее выполнение команды чтобы одни не одни команды завершались э Не рань одни команды ждали завершения других команд Вот так вот при этом как мы это сделали Ну на самом деле там было эволюционно решение прямо велосипед вот эти костыли палки как мы любим мы использовали для команд просто очередь сообщений закидываем квартиры их разгребают они там сканируются и в принципе всё неплохо работало особенно когда большая нагрузка много платежей много команд соответственно в оркеры которые команда разгребают они пролиты в процессе параллельно параллельно Но поскольку команд очень много у нас не возникает кейсы когда одну и ту же по одному и тому же платежу возникает несколько параллельных команд то есть первые гонки взял команду на авторизацию что-то там долго считает думает и тут второй уборки берёт уже следующий команду отмену этого уже платежа вот когда у нас наступает вносите пиццерии закрываются это кисть начинает очень неприятно постреливать и как любой неприятный кейс он стреляет именно ночью и как бы есть проблемы еще там есть нотификации которые могут прилететь нас когда-то них была отдельная тоже очередь идентификаций была гребанкратила порядок но по итогу мы не придумали ничего лучше чем решать все эти проблемы Просто расставляя разного рода пессимистичные Локи распределенные через базу Ну как бы Селяви такая жизнь лучше мы не смогли сделать используя наши инфраструктуру А у нас есть ограничения у нас два облака ажур Яндекс и можно использовать только те менеджер ресурсы которые есть и там и там и там Поэтому в Москве будет Лог и поехали мы жили решение это как бы нам не нравилось и мы очень долго смотрели Что можно делать ещё и года с девятнадцатого мы смотрели на как раз-таки тот самый орлиндцев Microsoft актеры Мы с ними такая проблема причём со всеми что все они в какой-то момент прикидываются мёртвыми на пару лет и в них вообще ничего не происходит и мы честно говоря боялись тащить к себе что-то что как бы уже мертво оно как бы хорошо но мёртвая и не хотелось ну как бы это брать к себе на сапорт когда нас там сидит полтора Землякова поддерживает э сервисы А ещё тащить Вот но потом в предыдущем э в прошлом году мы как раз анонсировал Новый год net и к нему выходил Уже новый обновлённый нос на последнем тут на эти они там всё перефачили всё переделали Вот и как бы мы решили что пора собственно что мы сделали мы сделали поверх виртуальных актов мы сделали виртуальной очереди то есть автор Он помог Представьте такую маленькую очередь в качестве состояния используется прям реально внутренняя Q в которой попадает команды за счет того что команда из бокса просто падает New там никакой поток безопасности обычно простая кью У нас очень быстрая ставка 5 миллисекун плюс-минус При этом при попадании сообщения внутри актера запускается таймер таймер синхронно текнет если что-то в очереди возьмёт сообщение с командой и за шатуль исполняется на текущей ноте соответственно потом таймер будет дальше продолжать крутиться и чекать как там выполнение его задача происходит для чего это сделано чтобы мы максимально изолировали всю эту логику работы в одном маленьком компоненте они тащили еще какое-то знание о том как работать от системы куда-то за пределы этого внутреннего актера поэтому сделали на таймерах собственно когда таймер течет в очередной раз и узнать что сдача выполнилась синхронный результат он значит берёт что ли следующая командное исполнение или же там завершается таймер потому что больше команд нет Значит можно ничего не делать ничем либо же он поймет Ага команда завершилась но результаты команды пока нет потому что на синхронные Значит нужно ничего не делать и ждать носификацию соответственно у этого акта это добавить команду и добавит идентификацию вот таймер завершается мы с ним идентификации если идентификация по какой-то причине не приходит то просто система завершит работу этого актера там в базу тоже прикапывается вот рассмотрели актеры обычно распределенные рассмотрели пример использования А когда же использовать не стоит во-первых когда у вас нет проблем с конкурентностью Нет проблем с мутацией какого-то состояния скорее всего это будет огрихед потому что это целый фреймворк и оно скорее всего не нужно во-вторых это приложение которое очень Сильно критично к производительности например идея которая могла прийти к кому-то в голову мне например пришла в своё время написать свой а-лядис то есть определённый кэш э прямо на орлите у нас же есть наше приложение оно уже у нас развёрнуто можно прямо в нём сделать определённый кэш она не очень хороша По той простой причине что поскольку актер коммуницирует всё-таки синхронно посредством сообщений оно не выдержит большую нагрузку на чтение То есть вы будете делать множество get-запросов к какому-то актеру э у него эти сообщения будут копиться в инсте А например этот актер неудачник и ему очень сильно не везёт и он не получает кванты времени на исполнение на процессоре у него Копится в очередь он не разгребается соответственно у вас как минимум растут задержки э led-се-вавших где-то запрос вашего кша в худшем случае у вас сейчас расти очень сильно потребления оперативной панель то есть сообщение Копится э при большом трафике И последнее это когда больше буквально воспринимает что авторы - это примитив или люди с этого домен если мы говорим там любой круглый аристорию нашего приложения так делать не стоит актер - Это первый очередь инфраструктура которая там некоторое гарантии актеров не менее где-то около него быть не должно Вот Но тем не менее отмечу здесь что если вы пропишите по ddd и у вас есть агрегаты они очень тяжелые и есть проблема с их изменениями параллельными то возможно Стоит подумать над тем чтобы как раз таки этот актер в актор завернуть этот самый ваш тяжёлый агрегат у вас всё будет состояние в памяти оно всё время будет максимально актуально потому что актер хостит это состояние и вы сможете его менять одновременно из нескольких источников э просто обучить подольше но никто не будет никаких конфликтов Итак если решили тащить к себе о чём я забыть Ну во-первых многие метрики Трейси потому что система распределённые в ней гарантированно будет ничего не понятно затем помнить что хотя актеры Они хоть и легковесны достаточно они не бесплатные вот ограниченные ресурсы вычислительные ресурсы по оперативной памяти мы бокс тоже Занимает какое-то место в оперативной памяти для каждого актера подумать над тем как вы будете восстанавливать состояние если вам это нужно Когда какие-то ноды будут кластеры вылетать или там при диплоях подумать как вы будете балансировать нагрузку здесь скорее даже не нагрузка в плане запросов к вашим актерам а скорее то как вы будете актера после многом распределять То есть если вы хотите избежать задержек вы всё на тот же самый ноте Если вы хотите чтобы надо были равномерно заняты Во множ какой-то более хитрый алгоритм скорее всего Робин не подойдёт мы используем поворофтов 2 случайные ноды смотрятся где меньше Шахтер туда следующий и не забывать что поскольку некоторые реализации например орлинз они там коммуникация она хотя синхронная она асинхронная синхронная То есть вы получаете промез который можно подождать и в этом моменте можно сделать себе дедлок когда одинаково Послать сообщение другому получать когда он зарисовывается а второму акте чтобы попробовать Сообщение нужно отправить сообщение первому акту а Первый актёр он сидит когда зарисовывается от второго актера тем самым получили detlock и такие ситуации Лучше избегать там есть свои Механизмы как это можно обойти прям фреймворки но так лучше не делать Итак О чем я осознанно не рассказал во-первых как вы помните в самом начале октора есть адрес другие реализации более продвинутый виртуальными актами они используют понимаете кому сообщает идентификаторы и как сущности между собой связаны там все интересно но очень специфично для конкретной реализации поэтому я вскипнул за ненадобностью и не рассказал как все это безобразие работает ну уже конкретно реализации именно фреймворк распределённых там есть интересное решение Но на них тоже не хватило времени к сожалению Итак какие выводы можно сделать во-первых актеры это действительно достаточно простая концепция вы рисуете очередь цикл тру и все так что смогли жену объяснить как работает актёр в принципе с накпоточной программированием так не получится дальше помимо того что простая абстракция она очень сильно упрощает ваш код выбирает из него все ненужные подробности забирает их на себя как он там будет работать что там состояние и так далее Всё максимально просто пришла к информации мы обработали состояние если нужно поменяли и так далее Затем когда мы говорим про распылённые авторы это штука Она очень хорошо упрощает масштабирование опять-таки состояние изолированное коммуникации асинхронное это как бы то что нужно для того чтобы система могла очень хорошо масштабируется горизонтально а вот вопрос необходимости этого решения в каждом проекте он для меня по-прежнему открыт на нашу инфраструктуру на додода и понимаю что у нас есть буквально полтора еще проекта Где бы актер могли реально прийти практическую пользу большинстве наших проектов это обычные круды и там в этом просто нет необходимости Итак на что можно Что можно посмотреть во-первых замечательный видос где тот самый хилый второго слайда рассказывает ребята из Microsoft Как работает авторы и там как раз есть про адреса про идентификаторы и так далее затем книжка Семь моделей конкурентности за 7 дней там примере на Джаве и на кложе Ну она легко читается там в принципе всё понятно для расширения сознания самое то и Всем рекомендую уже не проекторы А в принципе про то как проектировать приложение под облака Не в плане технологии а именно в плане подходов идей и механика это клауди за паттернс в документации секундочку Вот и на что можно посмотреть во-первых ака Джава Скала есть реализация Forge под net есть орлиц про который я рассказывал от Microsoft Он жив Благо есть просто актер с ним то же самое что было сравниться помер Потому что его Автор который кстати по-моему портировал Акко на дуднет он разочаровался в актарах ушел в лямбды фреймворк умер но недавно он вернулся и продолжил над ним работать есть тотнет есть голову можно пользоваться наверное не знаю не пробовал Вот и последнее duper это вообще распределённый runtime да распилен Тайм в котором есть виртуальные авторы ребята явно очень сильно вдохновлялись орлинцем Ну прям видно по механикам которые там присутствуют и Ну я не знаю я видел буквально полтора доклада где люди в продаже Не используют и вроде как им не сказать чтобы супер нравилось тоже можно посмотреть что ж на этом все давайте обсудим Спасибо Андрей ваши вопросы можно задавать зала также в чате и обязательно голосуйте за мной доклад Если вам понравилось если понравилось тоже голосуйте пишите комментарии даже негативные как спикер говорю так давайте вопросы зала давайте давайте Спасибо за доклад вопрос по поводу распределенных авторов это же по сути должно как-то крутиться в какой-то среде да вам У вас есть ноды у которых вычисления И вам на самом деле нужна только точка синхронизация то есть чтобы но до вашего кластера могли встретиться друг с другом понять Ага нас типа больше чем я одна и дальше А как они инфраструктура как они передаются Да дальше на сцены выходите сами расплённый алгоритм про который я не стал рассказывать там все очень интересно но в принципе актуально всё вертится вокруг того что вам нужно точка чтобы нам договорились и дальше различные протоколы они называются гости протоколы протоколы обмена информации между нами о том где Что расположено кто там из кластера вылетел голосование за него и так далее и плюс даже если вы тут хешинг и всякие его реализация для того чтобы понять кого Куда заплатить а вот Теперь главный вопрос это всё надо делать руками или вот перечисленные они уже все это орлинцы делают самыми руками в аке изначально нужно было руками говорить Где Какой автор создать но потом они тоже сделали виртуальные актеры вот в какой-то реализации Как работает из кода октариф ссылочка и дальше Вы в неё Говорите этому объекта Отправь сообщение а дальше runtime он всё делает за вас WhatsApp Он Откуда это сообщение нужно зарутить с этим здесь очень интересный бак у меня есть время да ещё 5 секунд расскажу короче сообщение актеры Мы ставим автор какой-то ноте со своим у него сообщения они обрабатываются потом автор многие завершается вот потом приходят новые сообщения и автор создаётся нужен другой ноги но к сожалению в районе 10 бак что информация о том что акция создалась на новой ноги она не обновляется на предыдущую на ноги с которой мы отправляем сообщение и в итоге сообщение идёт на старую ногу так понимаю что это актер у меня нет переслать этого на новую ногу но при этом очень Сильно ругается что вы не туда отправили сообщение то есть эта система Она работает по итогу автор получает сообщение оно работает но к сожалению там может быть эффективность от того что где-то видимо теряется в протоколе обмена данными информация о том что автор переехал Ну или может эту бак входит то есть да оно работает оно работает само но не всегда прям супер ровно и бесшовно Слушай у меня свой вопрос родился в предложении темы А вот распределённые залочится могут Да я уже рассказывал это не слушал Ну вообще вообще авторы не должныться Но поскольку не должны Бывает такое а только если вы используете механизм Если вы ждёте ответа трактора то есть вы можете отправить сообщение как изначально модели Вы можете дождаться когда мы вам что-то ответят и на моменте когда что-то отвечает Вы можете задаться потому что он у вас там ничего не ответит Ну это же это же ожидание просто Это этолог это блок потому что ему чтобы Вам ответить нужно чтобы вы ему ответили ричар взаимных блокировках да то есть сообщение ему он вам и вы друг друга ждете автор может адресовать конкретному актеру то есть идентификатору Так давайте дальше Вот в красном по-моему тянул руку Кто ещё дальше слышно очень классный доклад Никита из ВК Вопрос вот в модели актеров подразумевается что ошибки ребёнка обрабатывают родители Это всегда так Нет не всегда Ну это так во многих реализациях факторных моделях например а тебе детали нужны или я рассказывал что есть несколько подходов Кто управляет жизнью актера что с ним делать случае возникновения ошибок это либо актер его порождающий либо runtime актером управляющий система координации да Да Вопрос такой Тогда что будет если например связь между родителям и ребёнком между нодами на которых эти два акта расположены распадёт или если допустим нода с родителям умрёт как-то Да ребёнку ждать э от кого обработку своей ошибки а но в первом случае родители может периодически чекать жив ли акта у которого он родил вот если Э что его пересдать а во втором случае э ну ничего не произойдёт скорее всего ну то есть Пока актер никто не скажет э типа завершайся он сам не завершится ну в той если мы говорим про иерархию между актами то есть именно этот проект сообщения на завершение тогда он завершается высокой нет того кто может это сообщение ему отправить э ну он будет существовать но актер который был породил по идее должен кто-то пересоздать верхний уровень какой-то супер-видер который понимает Ага у меня это трактор помер Он не нужен я его перед создаю тот э вернулся в строй проявил что там всего детьми Ну и там дальше какой-то применил напоминает немного проблемы Зомби процесс Ну в принципе тоже все об одном и том же так всем спасибо есть вопросики у нас из чата я задам парочку начну с такого что с транзакционной логикой логикой в актерах Я так понимаю речь идет о isod Ну вообще если ты тоже про сторы А в принципе не про актеры но традиционно смотрите поскольку у вас нет параллельных изменений у вас состояние всё время актуальнее консистентно в рамках акта Ну как бы код Напишите естественно Ну само назовём это гарантировать если мы говорим про именно реализации транзакций наверное про транзакцию то есть там какие-то транзакции то есть один актёр меняется состояние Второй третий и так далее то он то да факторовках есть Прямо механизм транзакций в организм Всё сделано через двухфазные коммиты Вот но наверное вы не хотите использовать двухфазные коммит И вообще распределённых транзакции почему медленно Да на Большом числе участников на Большом числе участников там оно экспоненте растёт Ну понятно Так давайте вопрос давайте давайте молодой человек чёрным Привет меня зовут Святослав Спасибо большое за доклад А вот вы упомянули о том о случаях когда не стоит использовать распределенные актеры одним из них являлся критика у перформанс приложения и вот у меня с этим связано два вопроса Первый это замеряли вы оверхед при переходе к модели актера по сравнению с вашей прошлой архитектурой Если да насколько он оказался для вас критичным и второй вопрос как примерно определить нагрузку приложения сервиса когда ему можно переходить к модели акторов когда ему всё-таки стоит Какие использовать какие-то примитивные синхронизации базовые и всю вот эту паралич Да классный вопрос Смотри э про ресурсы Ну во-первых мы очень сильно срезали изначально на коннектор к базе потому что Каждый каждый блок распределённый это cont-base держать чтобы этот блок было у вас в системе Мы очень много срезали ресурсов на ожиданиях то есть стали гораздо лучше спойма потому что сообщение очень быстро засовывается приводить к графике потому что у нас красивый графики с большой нагрузкой есть три раза в год 8 марта 1 сентября 23 февраля тоже всех влюблённых как мы с тобой вот и соответственно красивый график не заготовил поэтому придется поверят на слово единственное где мы очень сильно потеряли это в CPU потому что таймеры они зачастую крутятся впустую Ну потому что сказка Может там завершится через 5 миллисекун Может через 100 Может через 400 и ты когда круче их много а я закрутит этот пульсами там CPU подрастает но это не критику можно с этим поиграться с переводом срабатывания и нормально Вот А насчёт второй вопрос напомню когда примерно нагрузку Ну как По каким критериям можно определять нагрузку приложения вот идеально Когда у вас есть какая-то таск система вот вам нужно получить тоску её гарантированно в себя забрать и дальше обработать это прямо очень хорошо заходит потому что дальше Вы можете очень их э гибко играться с тем как она будет исполняться Один трактор множество факторов и так далее и ещё хотел отметить наверное что Если у вас есть проблемы опять-таки с э например состояние распределённых корзины пользователей вам клиент нажимает кучу раз на кнопочку плюс плюс плюс и у вас прилетает пять запросов они инжектором заблокировались на пять разных нот на каждой работался дальше как-то этот конфликт или каким-то образом и клиент что-то получилось скорее всего не то что он изначально задумывал что у него будет плюс 5 если конечно вы не супер классные вот э здесь Возможно стоит сделать завтра спасибо большое еще вопросы из чатика при падении актера Каким образом сохраняются сообщения из его очереди и очереди и где Что за хранилище если возможность выбора зависит от реализации как я сказал например в аке при если актер падает с ошибками не сам весь по себе не надо целиком то maybox сохраняется теряет только сообщение на котором ошибка произошла в какой-то момент в аке была дюрабельная очередь сообщения мейлбокс через монгу но потом мне кажется это выпилили в принципе они всегда хранятся в памяти поэтому если крашится надо крашится все сообщения а по этой причине мы для себя делаем так Мы когда автор получает сообщение мы не делаем там никакой сложной логики мы тут же пишем его базу и во внутреннем состоянии в базе пишем чтобы это был дибильно а внутреннее состояние потому что большая нагрузка и мы всегда пишем в конец у нас просто Майское мы всегда пишем в конец таблиц Э что бы у нас э хендри сами себя таблицы они всё время были в кошеба база чтобы когда нам нужно понимать состояние мы поняли те данные которые сам актуально нам нужны чтобы не рвались страницы и была всё время самая максимальная возможность запись самая быстрая вот такой момент ещё вопросы Из зала Ну давайте да Андрей Спасибо Артём X5 тех Вопрос такой очень понравился пример с эквайрингом в разных локациях Додо мне интересно следующее если это разные все эквайринги скорее всего и стоят машины у них все разные по платежам как вы это дело мапете у себя вы натягиваете на свою стоит машину чужой эквайринг или делаете какое-то проксирование свёртку как это у вас Да у меня был про это слайд заготовленный прямо но я его выкинул с презентации Да там есть локальная стоит машина у нас короче есть эта машина где у платежа четыре состояния его создали его авторизовали заходили один клиента деньги за комителя нам зачислили и Его отменили на любой стадии и чтобы из одного состояния перейти в другую мы крутим Саги а вот Сага как раз-таки такой сложный ветвистый механизм где пойти как Вару даже оцентификацию сертификация та которую мы ожидали 7 подождать ещё и так далее То есть Да есть наша машина и чтобы со всеми эквайрингами учесть интеграции поскольку состояние всего четыре там получается 300 мы используем Саги То есть я правильно понял детали реализации под каждой эквайринг вы з- закрываете вот этим механизмом своим нет Э общая стать машина Угу А вот дальше Как ведёт себя Сага зависит от того э как мы интегрируемся с аквариумингом Угу то есть поскольку Сага она может пойти налево может Пойти направо Вот соответственно это динамически определяется уже в момент работы с платежом и слово выполняется на всех машина своя интеграция там уже где ифчики есть вот они в машине все спят в старых в шагах все спрятаны Это позволяет гибко этим управлять Давайте еще кому-нибудь слово сзади вас еще кто-то будет все больше нет Последний Спасибо за доклад всё было интересно как вот совместить сагу и вот авторы получается что мы просто будем создавать разные рода актеры на каждое действие Давайте расскажу если находит времени если не хватит в кулуарах собственно у нас в актер э завёрнут только очередь входных команд но какие-то действия с платежом у нас в нашей системе дальше нам нужно что-то сделать в системе эквайринга там крутится Саги и они просто выполняются там локально в рамках локальной машины то есть там никаких актеров там больше команд которая на основании результат выполнения текущей команды понимает Какой следующий шаг Если Вы получили синхронную результат прямо сейчас авторизации Окей мы помещаем команду завершенный актер сам поймёт что по таймеру типа что команда завершена возьмёт следующая если нужно даже спецификация Сага останавливаются И ждёт идентификации потом когда идентификация э-э соответственно она через очередь про свою инсайгу Сага построенной дефекацию скажет Конечно дефикации или нет даже идентификации смотрите наши платежи А там есть 3DS Когда нужно показать клиенту там где какое-то SMS вот или же например иногда бывает случаи например в Британии когда там что-то провести платёж нужно уточнить адрес доставки Если он неправильным клиентом уточнение до конца взаимодействовать и вот все эти кейса обрабатывают Сага получается что там у Саги есть там свои топики свои сервисы по вот отслеживанию или регистратора Нет там просто там просто примитивная прям очередь очередь степов которые просто хранятся в базу в табличку за счёт того что акт он значит механизм ремайндеров он дюберальный ну то есть он поднимется Сам он поскольку команда исполняться он застрелительное исполнение Сага посмотрит на какой стадии исполнения она остановила выполнение команды там ждала носификацию или там всё сделал не успела сказать что всё хорошо и так далее и продолжится выполнение то есть всё начинается с q-актра А дальше Всё уже без авторов происходит Да спасибо всё спасибо наверное уже не успеем Это я придумал Мой коллега если что все Славы ему вот дальнейший вопрос Андрей же Давайте в кулуарах в чатике и лично и как угодно а выберем лучший вопрос Спасибо мне понравился вопрос человека в чёрном футболке который А вот это да Ага И тебе тоже подарки от организаторов поаплодируем Андрею"
}