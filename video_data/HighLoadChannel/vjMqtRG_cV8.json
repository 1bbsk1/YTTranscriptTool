{
  "video_id": "vjMqtRG_cV8",
  "channel": "HighLoadChannel",
  "title": "Декларативное целеполагание на примере музыкального приложения seesu.me / Глеб Арестов",
  "views": 221,
  "duration": 2180,
  "published": "2017-04-05T14:12:38-07:00",
  "text": "я работаю в компании еврохим свободное от работы время я занимаюсь разработкой приложение для поиска и прослушивания музыки это клиентское приложение которые устроены таким образом что не обладают никакими собственными данными но комбинирует данные из других источников таких как last.fm вконтакте soundcloud и других я приложил много усилий чтобы организовать быструю и удобную навигацию по музыкальным данным доступны пользователю странице артистов тегов альбомов страницы пользователей last.fm вконтакте и сопряженные странице мой доклад посвящен принципу декларативного целеполагания так я его называла словно и обстоятельствам разработки приложения в ходе которого я его сформулировал доклад состоит из трех глав первое о том какие проблемы какие источники сложности в реализации приложения источники динамизма 2 2 глава о том как я пытался организовать код своих неудачах и о том как преодолеть технологическое отставание разработки от кулинарии о принципе в этом подходе и о том как его использую на практике третья часть она о том 3 глава о том как в перспективе можно сделать код еще более лаконичным еще более производительным основной основной проблемы основным источником динамизм являются принципы проектирования интерфейса которыми я руководствуюсь второй причиной это большой объем взаимодействия с другими сервисами и третье это техническое ограничение однажды я увлекся проектирование интерфейс и прочитал книгу джефф раскина которая называется интерфейс новые направления проектирования компьютерных систем в книге изложен системный подход к решению многих интерфейсных проблем эта книга меня очень вдохновила я расскажу не обо всех принципах которым я пользуюсь о тех которые добавляют большего динамизму напомню вам что джефф раскин это автор проекта компьютера макинтош это автор упомянутой книге которая была написана 15 лет назад и одной из его одним из его предложений которые он озвучил 15 лет назад было отказ от метафоры файловой системы как основы интерфейса и пользуюсь сегодня современными мобильными операционными системами мы можем увидеть что там такая метафора не используется как основная отличаться более старых операционных систем первая идея первый принцип о котором я хочу рассказать это принцип зa мнoй это это так как устроены карты это возможность оценить общий план возможность увеличить детализацию приблизить и его вернуться обратно к общему плану принцип зa мнoй является основой таких продуктов как игл нот и раскин фом ок также этот принцип получает сегодня распространения и в современных массовых интерфейсах этот принцип повлиял на то как я организую модель данных из самого начала заставил думать о том как я буду мать с технологической точки зрения технической как буду реализовывать переходы между страницами второй принцип это отказ модальных окон в первую очередь это отказ от блокирования интерфейса это отказ от навязчивого требования от пользователя совершить какие-то дополнительные действия это потребовало хорошая организация представления вьюг и дополнительного учета состояния том когда нужно показывать или не нужно то что должно быть на дальнем окном и соответственно визуальное решение как как как это должно быть если не модальное окно следующий принцип это предоставление пользователю максимума структурированной полезной информации на минимум его действий на минимум введенных им данных соответствии с этим принципом поиск в приложении организован таким образом что по мере ввода запроса результатов отображаются сразу же не нужно нажимать кнопку энтер например руководствуясь этим принципом я запустил мгновенный поиск приложений примерно за полгода до того как был запущен google instant search я еще раз подчеркну что в приложении нет собственных данных и чтобы нормально отобразить страницу артиста приходится выполнять много запросов в различные сервисы чтобы отобразить страницу артисты выполняется несколько запросов в last.fm несколько запросов в soundcloud отправляются запросу диск огс в hyip м и аналогичным образом устроено странице тегов и многие другие страницы руководствуясь этим принципом я организовала поиск файлов приложения и на верность часто одна из самых сложных частей в нем поэтому я хочу остановиться на быт опыт на этом подробнее как устроен поиск во первых при выборе композиции поиск происходит сразу же во всех доступных источниках второе это как только находится какой-то файл который отлично подходит для воспроизведения выбранных композициям вас прежде не начинается сразу сразу же и наоборот если результаты первые неудовлетворительные то воспроизведение не начнется до тех пор пока не будет завершён поиск кроме того пользователь может выбрать какой то источник данных как предпочтительный и в таком случае воспроизведение не будет начинаться до тех пор пока не будет получен результат из выбранного источника опять-таки приложение не обладает собственными данными данные получаются из разных сервисов композиции берутся в одном месте файлы берутся в другом месте нельзя сразу сказать можно ли будет воспроизвести эту композицию или нет чтобы воспроизведение происходило плавно как только завершён поиск файлов для текущей композиции происходит поиск файлов для следующих если поиск файлов был неудачным то будет произведен в поиск для следующей через одну и так далее до тех пор пока не будет найдена композиция которую можно будет воспроизвести в приложение сразу же поиск в вконтакте недоступен но как только пользователь дает доступ к своему аккаунту появляется возможность искать во вконтакте сразу же происходит поиск файлов для текущей композиции и происходит повторный поиск для следующих что особенно полезно когда поиск неудачным таким образом устроен поиск и в принципе на этом все принципы предоставления максимума полезность структурирован информации на минимум действий но не совсем потому что из этого принципа я выявил три правила сформулировал который позволяет организовать высокоскоростной взаимодействие пользователя с интерфейсом что это за правило первое это то что вычисления рендеринг они не должны блокировать взаимодействия пользователя с интерфейсом технически это организовано таким образом что вычисления не синхронные они могут прерываться и если в текущей итерации вычисления занимает больше 200 миллисекунд а не прерываются и откладываться до следующей итерации это происходит с помощью функции с это мыс это медиа и мидий или реку 100 не меньшим фрейм и на следующей итерации вы наверное знаете что браузеры в первую очередь обработают события пользовательские и только потом будут выполнены отложенные функции второе правило это то что при переходе на какую-то страницу должна быть отображена не просто пустая страница или страница с примером должна быть отображена полноценная структура страницы таким образом пользователь может проанализировать структуру страницы и принять решение о том чтобы перейти куда-то еще сразу же даже не дожидаясь первых результатов третье правило это то что запросы которые обеспечивают странице данными должны приоритизировать а если пользователь принял решение если пользователь попал на страницу артиста и принял решение перейти к лучшим композициям то в первую очередь нужно обеспечить данными страницу лучших композиций здесь вы можете видеть что была выбрана одна страница она загрузилась и только потом загружаются остальные страницы то есть в первую очередь загрузилась то что необходимую а потом остальное загружается этот принцип позволяет воспользоваться преимуществом клиентских приложений а именно то что шаблоны уже загружены и нет в общем то причин не показывать их пользователю не давать взаимодействовать с ними если вы в приложении в плане производительности все уже там на оптимизировали то можно воспользоваться этими правилами чтобы сделать приложение быстрее я написал на эту тему заметку можно по этой ссылке почитать на этом принципах которыми я руководствуюсь при проектировании все следующая проблема это большое количество взаимодействий сервисами сервисы предоставляет много различных данных я стараюсь утилизировать максимум и пользователи есть возможность перемещаться по страницам артистов плейлистов альбомов страницам пользователей в стаффом вконтакте и библиотекам и чтобы обеспечить эти страницы данными в приложение выполняется около 40 уникальных запросов эти запросы нужно приоритизировать обрабатывать и проблема в том что у сервисов разные api в некоторых сервисов даже в пределах его 1 разные структуры ответы это добавляет проблему так это можно пропустить еще один еще одной проблемой является технически ограничение например многие среды запуска приложений заставляют жестко разграничить представления и модель модель данных и представления таким образом что основной процесс может общаться с отображением только с помощью сообщений когда были запущены расширения в опера в опере они взаимодействовали ну папа пачек который открывается взаимодействует с основным процессом только с помощью сообщений расширение которого которые встраиваются в странице кроме они взаимодействуют с основным процессом только сообщениями среда запуска платформы электрон бывший а там shell аналог not with кит он запускает основной процесс на базе но джесс отдельно chromium который позволяет пользователю взаимодействовать приложением отдельно и общаются не только сообщениями помимо того что нужно как-то рассылать сообщение хочется чтобы это не пришли мне приходилось придумать протокол чтобы это происходило быстро из большая проблема что как только вьеха закрывается она выгружается из памяти и все когда пользуетесь заново и открывает нужно полностью восстановить состоянию следующая проблема заключается в том что во первых так вот это проблема следующая проблема заключается в том что многие то есть во первых браузер и ограниченное количество одновременных соединений сервисом во вторых многие сервисы сами ограничивают количество соединений интервал времени ну например нельзя слать больше одного запроса в секунду в last.fm это тоже добавляет проблемы и вот и перехожу ко второй главе со всеми вот этими своими задачами идеями я пытался организовать код писать приложение я в первую очередь конечно использовал и событийной модели и как как я мог организовать код как ему организовать какой-то результат который зависит от трёх других динамичных вещей я подписывался на одно событие подписывался на второе ответ станцию на 3 в результирующем коде заново считывал по отдельности это эти состояния вычислял какой-то результат записывал его куда-то может быть вызывал еще одно событие чтобы дальше можно было воспользоваться этим результатом и такой код помимо этого часто было необходимо получить этот компонент не дожидаясь того как произойдут эти события такой код дублируется его становится много этот код построен на сайт эффектах где-то что-то записывается где-то потом чет считается это может произойти потом в неправильном порядке слишком рано записан или записали что-то перри затерли в общем такой код становится сложно управляемым после и объемным после трех месяцев разработки прочитать код который тогда был написан сложно разобраться и кроме того появляется большое количество багов исправляешь одном появляется другого другое но со временем я заметил что в принципе подписка на событие то такое рутина и действие его можно автоматизировать если описать взаимосвязи чтобы то что тот код который будет автоматизировал понимал как связаны наименование событий тоже хана лично для меня было проблемой то что надо придумывать название события постепенно как то это стандартизирован но когда этот процесс происходил со временем и со временем перешел к другим выводам которые позволили организовывать код гораздо эффективнее и как ни парадоксально первый основной вывод который я сделать то что клиентское приложение не серверные и они могут быть сложнее проблема в том что многие подходы и в принципе многие решения в них прослеживается такое отношение к клиентским приложением как будто это просто какое-то представление для сервиса для для сервера сервер и отличия здесь заключается в том что сервер формирует какую-то структуру данных отдает ее вы клёвые забывает про неё и ему с ней не нужно больше взаимодействовать в клиентском приложении структура может меняться в процессе взаимодействия и нужно работать с этой структурой следующее я подумал о том что сервер часто структуре вот в ответ а просто вкладывают какие-то сложные модели в качестве поля другой модели хотя на самом деле они так не хранятся и если использовать такую же структуру из рук в клиентском приложении модель какая-то вложенная часто меняется и используется в каких-то других местах тут возникают проблемы кроме того я пришел к выводу что если если сервис что-то не хранит это еще не значит что это не состояние что этого состояния не существует и это позволяет многие динамичные вещи в выявить ну как бы осознать что это действительно состояние его и с ним нужно работать как состоянием еще одной проблемой является то что нет никаких протоколов способов организации для описания изменений взаимоотношений ну то есть если вот есть пользователь в социальной сети у него удалился друг как это изменение описать нужно что все поле фрaнс со всей вложенные структуры отправлять или как к этим выводам я пришел постепенно в процессе организации кода но сейчас могу сказать что ну для меня кажется странным что языки программирования позволяют в в теле одной функции написать и геттер и сеттер и там отправить запрос сделать promise какой-то call back намешать в общем сайт эффектов одной функции и согласитесь что странно если бы повар в процессе приготовления какого-то блюда взял бы вышел на улицу пошел магазина отстоял взял с прилавка картошку отстоял в очереди вернулся из грязными руками продолжим приготовление это странно повара так не делают они готовят а за картошки ходится другой потому что все знают что для приготовления чего-то там нужно вот картошка идеальный рецепт выглядит следующим образом во первых в рецепте описано что получается в результате название чего-то сложного второе это то от чего зависит что необходимо для приготовления третье это непосредственно процесс того как получить результат из компонентов аналогичным образом благодаря этому повар может сосредоточиться на приготовление никто другой там какие-то курьеры логист искали программисты могут обеспечить повара необходимыми компонентами и разделения специализация позволяет быть более эффективным аналогичным образом можно построить можно организовать код можно разделить актуализацию состояний от описания взаимосвязей можно как можно было бы описать взаимосвязи первое это то что вы то ради чего происходит некий процесс то что вы получаете в результате как как можно к этому обратиться второе это то от чего зависит результат и третье это непосредственно функция и это должна быть чистая функция которая принимает на вход аргументы и возвращает результат и в процессе выполнения функции не должны никаких происходить со и дефектов как это в принципе есть принцип декларативного целеполагания когда вы описываете что вы хотите получить что для этого нужно и как вычислить используя компоненты а непосредственно актуализации должен заняться какой-то другой код я использую это следующим образом первое это и в приложении есть модели в модели есть состояние состояние технически это просто объект states с вложенной в модель поля объекта states это какие-то примитивные значению обычно строка число правда ложь в принципе это такая стандартная вещь для месси framework а дальше есть сложное состояние они организованы как раз по этому принципу первое это название для чего-то сложного это то ради чего мы вообще будем выполнять какие-то действия второе это то от чего зависит наш результат в данном случае first name в с ним и третье это чистая функция которая принимает в качестве аргументов необходимые зависимости и в результате выдает ответ здесь мы указали зависимость явно благодаря этому код который актуализирует состояние может своевременно вызывать эту функцию и поддерживать актуальном состоянии fun и аналогичная штука есть например вам берджесс но синтаксис несколько отличается vm берджесс ну во первых в моем случае структуру несколько проще у меня просто массив массив функция здесь используется property и кроме того здесь функция которая построена нас на сайт эффектах она не принимает в качестве аргументов вычисления и ну во-первых вы не вы не сможете воспользоваться какой-то другой функция которая могла быть вспомогательной которая построена на на использование и аргументов во вторых это не чистая функция это с точки зрения функционального программирования и они в принципе не буду этого касаться но думаю стоит упомянуть дальше для того чтобы описывать взаимосвязи между моделями я вел такое понятие как вложенность технические вложенность это объект nice things его поля это другие модели либо массив моделей и значение меняются от присутствия или отсутствия модели во вложенности можно эти два понятия комбинировать так если мы хотим вычислить является ли пользователь самым молодым среди своих друзей мы можем прямо указать что нам нужно получить возраст что нам нужно получить возраст внутри поле возраст внутри вложенности друзей и собственная возраст здесь несколько усложняется синтаксис позволяет явно указать что нам нужно обратиться к положенности благодаря этому код который будет актуализировать состоянием может выполнить это так если эта функция будет вызвана если изменился возраст текущего пользователя если изменился возраст у одного из друзей и если изменился список друзей будет всегда вызвана эта функция и свойства из яркость будет всегда актуальным в принципе подобную штуку можно сделать vm берджесс но я пошел дальше и сделать так чтобы можно было указывать более глубокие структуры взаимосвязи можно получить друзей друзей и вычислить ее является возраст текущего пользователя среднем благодаря тому что здесь явно указывается взаимосвязь эта функция будет вызываться автоматически и только тогда когда меняется возрасту друзей друзей друзей меняется spi у одного из друзей меняется список друзей или если у текущего пользователя меняется список друзей это состояние всегда будет актуальным и это работает быстро потому что работает аналогично сиеста с селектором слева направо ну с точки зрения практической реализации аналогично по принципу декоративного цели полагания я организовал описание взаимодействия сервисами первое это то какие состояния можно получить от сервера второе это то как но здесь не очень понятно но то как состояние необходимый нам взаимосвязаны с той структурой данных которая приходит сервером что очень полезно особенно когда у вас много разных сервисов они вам все свою какую-то кривую структуру присылают и вам нужно подстраиваться и третье это как непосредственно выполните сетевой запрос эта функция это описание позволит должна вернуть promise который потом будет обработан так нельзя который 1 польстятся карты вот собственно с помощью описания взаимосвязи состояния и структуры этот promise можно будет приоритизировать в автоматическом режиме если пользователь перемещается по приложению у вас там сотни запросов ну или десятки запросы этим можно автоматизировать автоматически приоритизировать вам не нужно совершать для этого дополнительное действие третье по принципу декларативным целеполагание организовал шаблоны здесь опять-таки явно указывается что мы хотим вычислить правильный класс и класс зависит от состояния селектор в данном случае совмещены и описание необходимых компонентов и их вычисления это то как пишется java script statements они в принципе достаточно декоративны аналогичным образом можно указать взаимосвязи текстового содержимого и какого-то состояния благодаря тому что я отделил отделил описание взаимосвязи описание того как структура дом дерево зависит от состояний я могу в отдельном коде совершать различные оптимизации я сделал много оптимизации с домом чтобы приложение рендерилось очень быстро и подробнее об этом написал заметку можно почитать по ссылке благодаря тому что мы разделяем код мы разделяем описание взаимосвязей состояний и код который актуализирует взаимосвязи мы можем сделать большое количество оптимизации в коде которые актуализирует состоянии мы можем вы менять при этом приложении никак не меняется и приложение все в целом становится начинает работать быстрее мы можем делать doom оптимизации мы можем java script оптимизация делать много всяких кэширования сделать так что на само приложение это в принципе не влияет можно снизить нагрузку на garbage collection коллектор и так далее дальше 3 глава о том как можно сделать код еще более лаконичным и так у нас есть шаблон из того как написан шаблон понятно какие состояния используются в этом шаблоне второе у нас есть сетевые запросы и описание того как связаны состоянии приложения вот данных на сервере это что значит что когда пользователь открывает страницу рассматривает шаблон фреймворк или и я не знает язык программирования может в автоматическом режиме понять что необходимо для этого шаблона и выполнить все необходимые сетевые запросы не нужно их вручную вызывать просто пользователь открыл у нас описано взаимосвязь кроме того имея все описания того какие атрибуты зависит от чего мы можем вычислить все комбинации дом дерево я расскажу о тех принципах которые у меня не реализованы которые в принципе можно реализовать используя если код написан использую использует этот подход в общем у нас есть те комбинации дом дерево есть все необходимые компоненты мы можем посмотреть css-файл какие css селекторы подойдут для каждой из комбинаций все с файле написаны свойства которые могут делать рифов при paint и еще чего то там и мы можем понять какие операции более тяжелые и приоритизировать более тяжёлые операции мы можем понять что если мы меняем вот это состояние то нам желательно поменять местами рендеринг так чтобы чего-то не произошло какая-то тяжело операция дважды также имея имея все комбинации дом дерево и имея css файл css свойства мы можем вычислить какие под деревья какие ветви дерева полностью изолирована и автоматически промаркировать их согласно новой спецификации css контеймент дальше если у нас есть полное описание взаимосвязи не там и при разработке можем очевидным образом понять что если вы что-то удаляете у вас что-то где-то поломается потому что явно указано взаимосвязь между этими вещами можно строить какие-то визуализации дальше имея все вы взаимосвязи можно в автоматическом режиме строить какие-то сложные искали запросы которые в одном ответе вернут нам все необходимые данные и что полезно когда у вас мобильная сеть и низкая пропускная способность большой пинг эта ссылка на спецификацию в принципе на этом все хочу еще раз подвести итог этот принцип позволяет разделить описание взаимосвязей и актуализацию взаимосвязей позволяет в принципе в принципе сделать код еще более актуальным лаконичным и совершать оптимизации кода не меняя самого приложения потому что вы указываете лишь взаимосвязи это позволяет это кроме того позволяет разделить специализировать по навыкам разработку это понижает пару к вхождению разработку это на мой взгляд позволяет скажем верстальщикам писать достаточно сложный интерфейсом и что в целом удешевляет разработку а с хорошим специалистом позволяет делать всякие крутые вещи быстрее и легче вот надеюсь что кому-нибудь из вас был полезен доклад и заинтересует не было бы интересно обсудить то как его можно было и бы использовать этот принцип все если есть вопросы спасибо за доклад классно много всего интересного мне больше всего понравилась часть про данные где поля зависит от других полей можно написать чистую функцию который сразу получает тоже напомнила эмбер но тот синтаксис такой более функциональный как правильно функция чистая а в этом же ключе не рассматривают и не применял ли к себе примерял ли реактивное программирование функционально реактивная вот например библиотеки бекон эрик же я сейчас модно стало они как там он может в том же ключе но еще более лучшая или ты не и не в курсе ну я об этом думал во первых как бы я давно это приложение делаю и как бы слежу за ростом моды там пока дело приложения стало модным backbone потом angular теперь акт просто смотрю да интересно конечно но с моей точки зрения реактивные программирование она в принципе здесь применила но это то как технически организованы взаимосвязи но не то как они описываются так чтобы было понятно сразу то есть ну в принципе программист вручную соединяет там какие-то шланги грубо говоря тут ты просто говоришь что те нужно вот так а это свойство итэф язык программирование делай что хочешь но дай мне его актуальным и все ну вот итак кого еще вопросы давайте активнее и активнее у нас есть время на стекле сегодня за доклад твиттере пишут что повар все-таки ходит за картошкой можете прокомментировать ну я не знаю какие повара ходит за картошкой прямо в процессе приготовления может он ну там пишет что во время готовки или заранее ходит видимо во время готовки цена java-script рекомендую есть у него но я так понимаю что с вопросами как-то тяжело идет до 161 source окей видимо доклад был исчерпывающим спасибо тогда глеб тебя большое за то что рассказал нам про принципы проектирования и как их применить на фронте нди ну и давайте тогда сейчас небольшой перерыв не расходитесь пожалуйста сильно потому что мы как бы практически сразу начнем следующий доклад"
}