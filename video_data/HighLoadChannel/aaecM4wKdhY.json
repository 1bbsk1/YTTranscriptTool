{
  "video_id": "aaecM4wKdhY",
  "channel": "HighLoadChannel",
  "title": "Вся правда об индексах в PostgreSQL / Олег Бартунов, Александр Коротков (PostgreSQL)",
  "views": 38791,
  "duration": 2795,
  "published": "2017-04-22T14:46:51-07:00",
  "text": "так Здравствуйте Хочу представиться Я Олег бартунов и Мой коллега м Саша Коротков мы сегодня будем рассказывать об индексах в по SQL доклад он называется вся правда но на самом деле это не вся правда потому что мы поняли что всю правду рассказать за те какие-то 40 минут 45 минут невозможно поэтому мы остановимся на тех вопросах которые нам пришли в голову надеемся что они как говорится будут для вас полезными вот ну давай следующий это вот первый слайд я Обозначил его как серебряная пуля Кто не знает что такое серебряная пуля могут прочитать на английском но на самом деле бытует мнение У разработчиков что индексы спасают всё То есть если какой-то запрос работает Медленно или приложение тормозит то говорят обычно ну нужно какой-нибудь индекс создать ВС будет хорошо и в этом смысле это прича ВХ является Серебряной пулей то есть действительно индекс когда-то бывает полезным Вот но бывают случаи когда индекс просто вредит или просто ненужный Вот и мы попробуем рассказать про это Ну что такое икс всели зна что такое икс прили говорить индекс - это просто-напросто некая дополнительная структура призванная для ускорения запроса она не является SQ частью SQL она вообще не имеет отношение ционной алгебре Вот потому что это отдельная физическая структура вот результат запросы работы запроса с индексом и без индекса Понятно должен быть совпадать вот в постгрес и вообще в базах данных он используется для поиска для того чтобы ограничения целостности работали эффективно быстро для сортировки группировки и соединение таблиц обычно индекс мы говорим бывает полезный но на самом деле он может быть не полезен когда он обладает мало селективностью Например если вы пытаетесь индексировать пользователей по полу женский мужской то понятно что обычно индекс он не нужен потому что приблизительно 50% будет таблицы выбрано то есть обладает мы в этом случае говорим индекс обладает малой селективностью надо Отметь что так мы вносим в рассмотрение личную сущность то есть индекс - это лишняя сущность дополнительная то есть создаётся некоторый оверхед на его поддержание на размеры на диски и так далее поэтому могут быть ситуации когда этот оверхед уже превысит все ваши ожидания его полезности можно следующее вот на самом деле использование индексов это некий философский вопрос потому что разработчики приложений и администраторы баз данных Они немного как бы из Разно из разных команд то есть разработчики пишут сэли и они знать не знают о том где это лежит Какое хранилище что там с ними делается и более того они мало представляют собой что такое индексы потому что они пишут на SQ индексы не являются частью Эля и из-за этого получается такая проблема что администраторы они как бы занимаются физической работой То есть реализовывает то что разработчики написали но при этом они не знают запросов вот а если даже Могут узнать запросы из логов то они не могут эти запросы изменить то есть создание индексов на самом деле в принципе Об индексах должны знать не администраторы а должны знать разработчики то есть человек который пишет SQL он должен понимать что такое индекс как его создать и как он работает иначе будет проблема что у меня индекс не работает можно Ну вот несколько замечаний о том что что такое индексы постгрес то есть в постгрес в отличие от многих других баз индексы все индексы являются вторичными то есть они отделены от таблицы они отделены таблицы и вся информация вся об индексах То есть их описание она содержится в системном каталоге То есть постгрес - это база которая описывает описание своё описание держит самой себе Вот индексы связывают ключи и так называемые тиды это идентификаторы плов часто говорят путают тупы талы записи так далее так вот запись - это на логическом уровне а ту - это На физическом уровне на физическо уровне плов может быть много То есть у каждой записи в си ногоон может быть несколько версий вот эти веси физические они называются туплами для того чтобы ди понима а то ча путают что та тул и запись вот и эти индексы в пог сделаны Так что они не содержат информацию о видимости то есть из-за того что по многорядные Все изменения происходят внутри транзакции и соседняя транзакция просто не видит соответствующую другие записи порождённые в другой транзакции поэтому для того чтобы результаты поиска по индексу показать Человеку нужно каким-то образом провери ви по это транзакции или нет существуют полез отклонения об это попозже расскажем Ну вот любое обновление записи в таблице К сожалению приводит к появлению новой записи в индексе что это означает даже если вы Обновили Обновили ту колонку по которой индекс не построен ВС равно все индексы обновятся То есть это часто проблемы производительно связана именно с этим То есть надо за индексом тоже следить так же как и за таблицей за его распухает а при поиске индекс может использоваться Вот вы видите в колонка оператор и значения для сортировки в том или ином порядке вот или скажем для сортировки это уже специальный вид Это кнн для метода ближайших соседей поиска Да е не знали Open удр клонировать странички знаю ВМ ча возникает вопрос Мы создали индекс смотрим акс не используется Почему здесь перечис условия для того чтобы идекс использовался то есть должны совпадать ти аргументов порядок и оператор и причём порядок скажем аргумента важн то есть левый аргумент оператор правый аргумент например да то есть некоторые индексы Они разные могут быть для порядка то есть каким-то образом должно чётко совпадать индекс должен быть валиден то есть не все индексы которые вы написали Create идекс они валидные например если вы говорите Create индекс конкурентно то он может быть некоторое время быть невалидный то есть он не будет использоваться Хотя будет виден в системе в ного колом индексе важен порядок То есть если вы создали индекс по первой колонке по второй а предикат у вас содержит только вторую колонку этот индекс может быть и не использоваться не используется то есть важен порядок ну скажем для дна индекс это порядок неважен там все колонки они равнозначные следующее условие это то что план с его называется есть он подсчитывает все планы А плано может быть очень много если у вас в системе много индексов вот и надо выбрать именно Тот который наиболее порождает наиболее дешёвый план вот оптимизатор Всё это делает И это он делает с той информацией которая содержится в системном каталоге то есть умудряется выбрать самый оптимальный вот если этих требования не выполнены то индексы не будет использоваться надо быть просто внимательным Иногда просто люди пишут скажем какие-то очевидные вещи для них А вот компьютер не понимает то есть надо например использовать Явный Каст То есть вы пишете двойка там а нужно нужно явно сказать что это Например какой-нибудь Бин или что-нибудь такое то есть помочь можно вот Ну вот Ну это я расскажу да давай да Ага ну вот пример выбора нужного индекса вот в этом примере мы создаём табличку которую заполняем случайными значениями через generate Series и Random Вот и создаём индекс один индекс стой по точке и ещё один primary по ID и ещё один определённый прямоугольник вот у нас получается bitmap ИК вот по вот этому индексу по колонке P Вот и как происходит выбор этого здесь вот показана на самом деле достаточно упрощённая схема того как это выбирается из системного каталога вот даже на достаточно упрощённом варианте получается немного запутано вот ну во-первых мы находим нужный оператор вот оператор мы находим по его имени есть непосредственно значку вот по типам тип Мы узнаём из таблички P attribute мы по ID таблички и имени узнаём его номер и его тип Вот и по правому выражению там бокс понятно что это тип бок там по табличке Мы тоже находим ушник находим оператор вот по атрибуту мы е можем найти сразу вот внс инде который атрибуту вот дальше мы у индекса находим его так называемый класс операторов Вот то есть это как скажем конкретной реализации типа индексов вот и по ней уже там через PG CL мы находим Есть ли в этом классе операторов вообще поддерживается ли тот оператор который нам нужен Вам не показывает Ну вот значит Ну вот алгоритм вкратце вот здесь вот приведен на слайде Вот его теперь вроде показывают вот находим атрибут нужный атрибут потом находим нужный оператор узнаём его идентификатор вот потом подходящие индексы находим просто по столбцу и табличке вот а дальше уже находим класс операторов и внутри него проверяем содержится ли там нужный нам оператор Вот и дальше среди вот всех этих индексов корыт вот в примере Он был один а их на самом деле несколько может быть среди них мы уже считаем стоимости и выбираем нужный индекс вот алгоритм Так выглядит то есть вот вы поняли Насколько сложно происходит на самом деле по это делает очень быстро потому что информация системного каталога она кэшируется в системном ше происходит очень быстро всегда видели вот такие вещи как се Scan Index Only Scan bitmap Hip Scan ИК Scan То есть это мы это мы будем очень часто использовать в дальше в примерах и я хочу сказать пояснить что эти все сканы означают можно следующий слайд вот последовательный СН то есть табличка в Лио в постгрес лежит ээ в порядке неопределённым это положение вообще говорится реляционных баз данных то есть порядок не специи вот поэтому для того чтобы скажем поискать вот по предикату ме нужно просто последовательно прочитать табличку и отфильтровать записи это называется или вот как говорится седу понятно что это может быть для большой таблицы может быть медленно и Можно сделать такой самый простейший индекс взять скажем колоно вот C и вынести отдельно таким образом читать эту колоно она гораздо меньше всей таблички и находить значение а в колоночки находятся ссылки на соответствующие записи таблицы то есть мы делаем выигрыш соответственно это является простейший индекс Вот так мы поступали в школе Ну грубо говоря отде табличка следующий вот идекс появился в версии 92 992 это дальнейшее ускорение посу нам не нужно ходить в табличку мы просто можем если например значение можно восстановить из значения в индексе то мы можем просто сразу после поиска по индексу отдать пользователю потому что появилось такое понятие как вот 84 появилось понятие карта видимости которая говорит о том что какие странички видны данной транзакции вот в 92 это просто стало возможностью не ходить в табличку мы как я напомню Мы в табличку должны ходить для того чтобы проверить видимость видимость данной транзакции Вот Но сейчас это уже не нужно и скажем для скажем для индексов вот можно очень быстро скажем до за какие-то маленькие миллисекунды поискать по индексу и вернуть это пользователю Вот это очень эффективный такой индекс называется то есть никаких блоков та буде можно улучшить взять просто-напросто Вот эту колоно и упорядочить грубо говоря сортировать и тогда мы получаем дополнительный выигрыш мы уже не читаем всю колоно А с помою скажем бинарного поиска как говори опреде те строчки которые нуж это вот но при этом мы полу случайное чтение таблицы потому что записи в индексе они отсортированы не в том порядке в котором они вообще лежат в таблице Поэтому нам приходится читать таблиц В случайном случайном порядке скажем если индекс по колоночки становится очень большим и читать его уже становится невыгодно то просто-напросто строит дерево из него скажем в данном случае там нарисовал како дерево Например Она позволяет ускорить чтение инде раз Т уже на этой конференции говорил сказать Вот мы являемся авторами этих расширений скажем место B3 можно строить произвольные деревья скажем из гиста Джина или СП гиста которые поддерживают разные произвольные пользовательские типы данных То есть это всё относит к индексом к этой стороне но суть заключается всё равно в том что нам нужно Эти строчки про верифицировать на видимость в табличке вот поэтому это просто обычный индек можно bitmap Он возникает тогда когда мы например вот эти указатели на результаты индекс кана Мы не сразу даём пользователю а скажем собираем в памяти строим bitmap то есть карту битовую карту которая содержит информацию о том что Какие записи уже в отсортированном виде записи отсортированные то есть мы возвращаем мы читаем табличку уже не В случайном порядке а уже в хорошем нормальном порядке и этот он ещ позволяет соединять несколько индексов скажем легко две битовые маски пересечь там или объединить Ну вот здесь вот коро для управления индексами в посе придуманы такие операторы Я сказал придуманы потому что никакого стандарта наст приб сво везде То есть у нас можно создать можно индекс изменить и можно его соответственно удалить документация в обширная можно почитать ВС подробно некоторые моменты на хотел уточнить дава им коло им табли в скобках имя колонки Вот Но в пишут Потому что Существует несколько а методов То есть их можно посмотреть в таблице в частности это может быть B3 это может быть Ш это может быть и то есть у нас существует п а методов из но по умолчанию B3 Да по умолчанию B3 если вы пишете просто табличка в скобках колоночки это просто B3 вот можно видите есть такой интересный параметр Stage параметр То есть это некоторый Access методы имеют свои параметры которые влияют на создание индекса например вот B3 иги есть параметр фактор вот фактор он говорит какая степени за полности страницы иногда это бывает очень важно Например если вы считаете что ваши данные в основном readonly Вот и вы хотите просто-напросто сэкономить место то вы можете сказать Фил фактор например там ну почти 100% То есть у вас будет хорошая утилизация места на диске но при этом если будет Пойдёт апдейт то это приведёт к тому что места на этой страничке уже нет придётся перестраивать перестраивать индекс боле Более сложный то есть нужно сплети странички данные нички раскладывать на две странички Ну да Просто если фактор 100 то получается что у вас с самого начала когда пойдут апдейты сразу пойдут с плиты а потом через некоторое время он войдёт в некое равновесное состояние свой индекс А если вы скажем Да сделать фактор 50 то какое-то время у вас база будет существовать просто-напросто без без такого интенсивного перестройки дерева Вот то есть это важный параметр поддерживает B3 у обратного индекса есть параметр такой по умолчанию он включ и правильно Пусть он будет включён вот дело то что днн имеет по своей природе просто по своей природе он не очень хорошо адел вот и поэтому мы придумали своё время алгоритм для его быстрого апдейта и как бы некоторые люди сказали что хотели бы его уметь отключать Поэтому был введён токой параметр то есть по умолчанию вкн можно его ОТК чтобы не тормозил поиск Дело в том что update он влияет на он ускоряет вставку Но немного замедляет поиск То есть если вам ставка не интересна интересен поиск то можно его отключить вот есть параметр у Create индекса Table Space про него тоже часто забывает хотя на самом деле это такая вещь которая позволяет очень хорошо масштабировать производительность поса то есть вы можете просто напросто завести на отдельном нде физическом Вот и все индекс создавать на этом отдельном хранилище что это говорит это сразу вам даёт возможность парализовать чтение скажем таблиц с одной с одного хранилища с индекса с другого то есть всё гораздо быстрее они друг другу не мешают Вот То есть можно с помощью этого параметра э улучшать чтение запись Окс - это оператор для колонки скажем для одной колонки например для может существовать несколько разных алгоритмов вот можно выбирать и указывать специальный вот а это порядок каким как индекс сортируется То есть когда говорил колонка сортируется её можно сортировать как вниз так и вверх вот в принципе это не особо важно то есть по умолчанию в постгрес принята сортировка вверх то есть Да скажем по-моему сортировка вниз не знаю в общем базах в разных базах умолчание Разно это надо тоже помнить когда Тут ещё важно сказать что по он умеет ИК делать но тем не менее последо страниц тоже может быть важна Потому что если вы идёте по убыванию например вот то если у вас индекс тоже по убыванию то у вас будет последовательное чтение с диска ещё вот есть вариации что там одна колонка по возрастанию другая по убыванию Если вам нужен orderby То есть вот вот с помощью можно мать то есть индекс не просто если у вас стоит предикат by То есть вы сначала находите А потом выдаёте сортировки то можно сделать за один проход если у вас всё хорошо совпадает Вы по возрастанию индекс у вас тоже по возрастанию то не нужно делать отдельную сортировку то есть сум он сразу выдаёт в нужном порядке простой индекс он чем неприятен тем что он лот таблицу То есть если вы какието они будут ждать пока индекс не создастся это может быть на больших таблицах и при большой нагрузке это может быть критично вот поэтому в какой-то версии в Дея деят У нас есть уже конкурентное создание индекса То есть можно сказать это означает что он не будет блокировать таблицу то есть ГТО в никому не мешает а в нужный момент когда вот этот индекс создастся он просто станет валидный и будет использоваться у него такие есть проблемы что он требует два прохода И ждёт окончания всех транзакций но это понятно что он варит варит варит ему надо посмотреть что же изменилось в результате потому что за это время в табличка могла измениться То есть как бы он немного медленный Вот Но зато он работает в граун в фоне и не мешает его к сожалению нельзя создавать транзакции функциональный индекс г интересен тем что в нём скажем можно создавать индексы по функции от колонок то есть по выражению Вот и здесь э требования такие что функция должна быть иб то есть функция должна зависеть только от его результат работы функции должен зависеть только от его аргументов Да и состояние базы не должны менять не должна менять состояние базы вот а изменение индекса может быть дорогое И вообще потому что на каждый чих вам нужно опять эту функцию применить естественно Вот и условия при поиске для того чтобы индекс использовался это условие при поиске должно мать вот то что было в Вот пример Видите вот сеча создал функцию синус от Ашка глупый конечно пример но тем не менее видите при поиске по синусу ищется индекс А если там напи косинус то не будет иска естест То есть это надо же обязательно писать то есть иногда бывают такие индексы трёхэтажные выражение делаю трёхэтажные выражения там куча всего и вот при селекте нужно эти же трёхэтажные выражения везде копировать один к одному Чтобы по сумел распознать Что индекс можно использовать мониторинг вот кроме пользы прида создаёт ещё overhead и поэтому очень важно мониторить индекс Что означает индекс мониторить Это означает что нужно смотреть на неиспользуемые индексы на индексы дубликаты на индексы которые пересекаются то есть в результат эволюционного развития или просто бардака То есть когда вы отлаживать люди пишут Create индекс такой-то такой-то такой-то запущена система в Production что-то смотрим замедленная вставка размер ба большой вот нужно взять просто запустить некото несколько селекто и посмотреть что вот этот индекс не использовался ни разу с момента старта проекта то есть кто-то когда-то экспериментально его создал вот а надо сказать что любой такой индекс Даже если он не используется он он перестраивается при любой вставке он всё равно перестраивается и так далее вот поэтому это очень важно Они замедляют обновление занимают место их ещ надо реплицировать то есть как куча куча лишнего Хеда Вот и здесь уже конечно администраторы баз данных должны мониторить индексы есть такая страничка у нас на Вики где вот описаны всякие премудрости хитрости можно некоторые вот скажем примеры например найти неиспользуемые индексы Вот вы можете просто взять Вот cy и прямо на своём проекте сделать и вы увидите куча индексов в которых Вот видите индек 0 то есть ноль раз его использовали Так зачем он нужен вот здесь можно Как говорится с этим запросом можно экспериментировать но тем не менее Вот я просто взял на своём ноутбуке прогнал и увидел кучу всяких индексов непонятных можно индексы дубликаты Вот что я называю дубликаты например Видите вот я в правом верхнем углу есть табличка я создал там четыре индекса ну нормальный человек сразу увидит что три просто абсолютно одинаковые а Первый индекс он просто как бы его можно было бы не использовать потому находится первой колоночки у других индексов то есть они как бы пересекаются вот скажем вот такой селек Он позволяет вам выдать Вот эти все пересечения субличностей вещь потому что существуют такие соображения что вот этот индекс например по а B3 индекс по а он может быть просто более эффективным но он меньше размера можеть сильно меньше размера может быть Ну в общем информация вам Дана дальше для того чтобы подумать вот можно вот есть ещё вторая версия такого запроса которая выдаёт Вам даже Create ИК там информацию более подробную это всё эти селекты всего лишь навсего как бы они обращаются к системному каталогу то есть подтверждает того что вся информация в индексе там есть вот Ну дальше Вот мы уже приступаем второй часть это уже вот как бы продолжение примеров это вот Саша уже будет рассказывать да Значит значит вначале расскажу про параметр maintenance workman вот он влияет на создание индекса то есть вот здесь на слайде пример вот если был maintenance Work M 1 Мб то индекс там на миллионе записей создавался там чуть больше секунды если 128 МБ то Ну там с запасом конечно он не все Их используют то там 700 миллисекунд Дело в том что он определяет Сколько памяти может использоваться по индексу самый простой способ и быстро сделать B3 - это просто в памяти всё отсортировать потом на диск записать вот если памяти не хватает то там используется так называемый создаётся набор временных файлов туда там да отсортированные куски выборки записываются потом всё это сливается и это получается несколько дольше даже если всё это в кэш влезло Вот но понятно что если будет слишком большой и у вас сервер залезет SW то это будет ещё хуже Вот теперь про то как выбирается способ сканирования вот примере создаётся там тестовая табличка Вот специально с выключенным автовакуум вот чтобы автовакуум там случайно не запустился Вот и вот тест не испортил Вот и показывается что Вот пока мы не сделали analiz вот не собрали статистику У нас всё время будет использоваться bitmap ик и индекс будет всё время показывать в плане будет всё время показано что как будто 5.000 записей Мы собираемся выбрать вот а можно посмотреть по примерам это зачастую совершенно оказывается не так Вот потому что статистики нет вот и по умолчанию планировщик действует Так как только мы соберём статистику мы сразу видим что у нас стало более-менее совпадать предсказанное число строк и реальное То есть если мы выбрали вот у нас в колонке в значение от нуля до единиц если мы выбрали от 0 до 09 то это почти вся табличка и используется Вот потому что индекс здесь будет только лишне создавать нам надо индекс прочитать потом по нему там составить какой-то бит который всё равно нам даст почти всю таблицу это не нужно вот если у нас наоборот очень маленький интервал то используется просто икн то есть мы по индексу ходим и сразу же идём в табличку потому что записи у нас мало вот при средних ниях испо вду приме е пример то что нам даёт команда кр кластер она упорядочивает таблицу в том же порядке как и индекс Вот и можно видеть что кластер он очень здорово снижает инпут аутпут вот здесь показано вот число блоков диска которые использовались было где-то 5.600 стало 800 блоков диска использоваться Потому что если раньше они были записи которые мы извлекаем были как-то случайным образом расположены на диске то теперь они стали также как по индексу то есть некий непрерывный кусок мы просто с диска вычитали Вот и таким образом у нас инпут аутпут стал намного меньше Но здесь в данном примере было всё в кэше поэтому это не сильно ускорило А если большая таблица которая не в кэше это очень большой даёт эффект вот как индекс может использоваться при орба А значит во-первых если у нас просто есть индекс по колонке он может использоваться если у нас указан просто Order Buy и это позволяет нам избежать сортировки вот есть просто Order Buy по этой колонке но особенно эффективно Когда у нас есть Order byy и limit то есть например выбрать Там колонки с о записи с наименьшим значением какой-то колонки там top2 вот можно видеть что получается очень быстро вот а но вот если нам нужно обратиться Например А так называем там пролистывание часто бывает там в веб-интерфейс и так далее То использование больших значений of Set оно оказывается достаточно неэффективно потому что нам нужно поскольку же нам нужно видимость проверять то всё равно если у нас офсет 900.000 нам надо первые 900.000 всё равно просканировать вот чтобы вернуть нужные 20 Поэтому лучше будет если нам удастся избавиться от офсета и запихнуть это в условие в Это конечно не всегда так просто требует некоторых с точки зрения приложения доработок но зато получается очень быстро когда составной индекс то у нас соответственно должна должны совпадать обе колонки То есть если мы хотим сделать упорядочение сразу по двум колонкам предположим у нас Первая колонка у не не уникальное значение то нам нужен такой же операторы есть для сразу бы записей V2 объединили запись вот и сравниваем с другим значением тоже позволяет по индексу очень быстро пропустить часть значений значит пример с ином значит вот можно увидеть что пока у нас вакуум не было то вот мы делаем там Селект колонок которые у нас есть в индексе индекс о сна Как видим нет вот даже если мы его заставим использоваться принудительно установив соответствующие переменный все другие способы сканирования выключив то всё равно видим Что во-первых быстрее не стало Стало чуть медленнее А во-вторых что вот много так называемых хип фей то есть перепроверка видимости по по хпу Вот а если мы сделаем соответственно проставиться везде единички то что все странички они видимо всеми транзакциями тогда нам уже не нужно будет ходить и мы можем всё очень быстро сделать из индекса вот здесь видно как стала ноль и время заметно уменьшилось хип это мы называем табличкой Ну хип да Где хранятся непосредственно плы самой таблички Т вот при основном индексе Когда у нас тоже идт Order и мы можем использовать например только первую колонку и по ней будет делаться тоже нормаль о а если только вторую сделаем то уже не получится у нас план будет выдавать сортировку ROM тоже влияет То есть он указывает нам планировку то наму т ди случайном порядке то есть вот она по умолчанию равна едини а равна чеке вот если мы поставим R равным едини то у нас например индексы будут использоваться более так скажем агрессивно Вот и bitmap инк например будет вместо bitmap использоваться просто ИК поскольку планировщик решит что нам ВС равно что мы будем ходить по диску В случайном порядке про если у ва вся база помещается в памяти че удобно поставить или вы работаете на правда не единичку 1 но меньше чем че можно поставить вот тоже влияет он влияет вообще на разные ноды планера например он влияет то он уже не может хранить не помещается в как если он помет туда все тиды То есть все вот эти указатели на записи Хи Вот ему придётся сделать бит и по которому потом делать чек вот можно видеть что мы поставили маленький 128 КБ вот у нас получилось много чека потому что у нас получился bitmap котом пря только для странички хранится но или А уже для тени приходится по самой страничке перепроверять Это получается медленней то есть в некоторых случаях Когда вы видите что у вас много вот этих вот removed by Check Вы можете просто Work mem увеличить и станет лучше а значит вот небольшой пример когда индекс неправильно используется а значит здесь э специальный такой пример значит здесь а создаётся табличка которая наполнена миллионом многоугольников Вот и по ней мы создаём гист индекс по этим прямоугольником и мы ищем все вот эти пары разных прямоугольников которые между собой пересекаются и здесь два условия то что дишни у одного должен быть больше чем у другого И они пересекаются и вот можно увидеть какой у нас получился план у нас во-первых Мы то что по вот этому индексу пого одновременно ещё он решил искать по дишни кам и их пересечь Но на самом деле по дишни кам очень плохая селективность И этот индекс нам только мешает вот и получилось Получилось что очень долго выполняется этот запрос вот а почему так происходит на самом деле Проблема в том что просто для вот этой операции пересечения полигонов у нас не определена функция селективности там в соответствии со статистикой Там просто выбирается Константа вот Вот селективность для него хорошая пока не реализована и что с этим можно сделать вот первое самое простое можно просто выключить bitmap ИК Вот и тогда будет использоваться просто индек который не может использовать сразу да индекса Вот и план сразу станет лучше стало вместо 900 секунд на такой достаточно тяжёлый запрос стало всего 11 Секунд Это хороший резу есть Роме этих переменных дотель воз влиять на план на выбираемые индексы есть Вот например такой модуль как планнер вот е когда его соберёте можно его загрузить и указать Какие индексы запрещены к использованию и всё тогда значит этот индекс не будет использоваться который нам мешал будет использоваться только тот который нужен тоже получился Ну примерно такой же результат и есть Вот ещё такой более мощный модуль г hint п так толь небольшая неточность на слайде здесь нет самого хинта Вот но на самом деле Он позволяет в комментариях перед запросом указать а совершенно разные параметры того как можно как выполнять данные запросы то есть там можно Указать тип сканирование sequential Scan ИК Scan bitmap ИК SC типы соединение таблиц и так далее То есть даёт достаточно большой контроль над планом запроса вот очень удобно То есть это аналог хинтон то выполненный в виде модуля Ну только Слишком увлекаться этим не надо как бы если есть какие-то если проблемы возникают во многих местах это значит всё-таки нужно как-то настроить параметры оптимизатора чтобы он давал вам правильные результаты в большинстве случаев А вот ещё один вопрос не всё ли равно когда сделать индекс например вставить вначале данные или потом и потом сделать индекс или наоборот вот в данном примере можно видеть что очень большая разница есть если мы в начале создали индекс а потом вставили данных вот здесь получилось 5 секунд Примерно вот а если бы мы вначале вставили данные а потом создали индекс получилось 3 секунды Примерно вот это как раз из-за того что если у нас когда мы создаём индекс он достаточно эффективно делается то есть записи сортируются а потом уже по ним достаточно быстро создаётся B3 А если у нас уже есть индекс то это уже идёт последовательные вставки в B3 которые медленнее работают и ещё К тому же сам индекс получается больше как раз из-за того что у него оказывается другая степень упакованной Что такое частичный индекс вот частичный индекс - это просто мы в нём можем записать некое условие Вот здесь например там колонки 2 вот мы по коло мы сделали индекс с условием по колонке V1 то что V1 равняется нулю Вот и можно видеть что здесь стал использоваться индек SC Вот именно по этому индексу Да здесь пропущен сам Create Икс Вот но здесь просто был и1 ра Ну и вот для целого ряда запросов даже где V1 ра ну или там на V2 указывается условие этот индекс используется вот или ещё пример функционального индекса например ну у Олег был там похожий пример Вот здесь например просто по сумме колонок мы сделали индекс Вот и вот в условиях когда содержится сумма этих двух колонок тоже этот индекс используется механизм Ладно Значит он Суть в том что он позволяет если у нас индексы не апдейт то позволяет нам только в хи обновлять тапы А в индекс сам не трогать Вот то есть у нас остатся один указатель на запись вот и там уже дальше он По ссылкам может найти нужную версию вот здесь приведён пример что когда мы апдейт колонку по которой нет индекса то размеры индекса не размеры других индексов не увеличиваются поскольку у нас было свободное место той же самой странички Вот и удалось вот этот механизм ход применить Вот а если мы обновляли другую колонку Вот то соответственно у нас уже там размер индекса тоже увеличился и вот ещё небольшой пример на гист вот то что этот механизм он уже позволяет делать ускорение по поиску ближайших соседей вот здесь пример мы создаём табличку которую заполнили случайными равномерно определёнными точками вот а потом ищем те которые ищем 10 ближайших вот к середине к точке с координатами 05 вот без индекса нам пришлось бы Везде это расстояние посчитать отсортировать и выдать 10 ближайших вот а с индексом нам уже приходится только сразу по индексу мы можем сразу по индексу в нужном порядке извлечь и получается очень большой выигрыш Это только на миллионе записей такой выигрыш там в 10 больше дети раз а на в большем числе запис там ещё больше получается выигрыш Да ну вроде бы всё Да мы как-то уложились Да даже ещё минута осталась Да вообще как-то непривычно вот такое так в такой Ленске проекции потому что одни смотрят туда другие смотрят туда а ты получаешь смотришь непонятно вопрос Да гси это партиции не на не на уровне таблиц ни на уровне индексов что не позволяет использовать эту базу для очень больших таблиц вопрос Почему нет И когда будет руки не дошли то есть приходится потому что на самом деле не дошли руки а во-вторых просто люди уже написали такие скрипты которые автоматически делать делают для индексы для этих партицирование с Да в принципе па были уже па были просто сечас очень сильно изменилась уже система политика принятия патчей более строгая и людям как не очень хочется возиться с такими вопрос конечно один из самых частых есть сделаем Можно ещ небольшой Толи вопрос Оль его использовани что он оптимальность учитывает исходя из того из количества операций ввода-вывода Ну не только вот тогда может уточните в каких случа как и такой вопрос Вот вы показывали такие страшные большие запросы там как узнать неиспользуемые индекс Почему нет каких-то простых алисов там Икс US или что-нибудь такое чтобы не копипастить огромный запрос каждый раз можно было ввести его ну можете вху сделать Ну я могу но когда они есть стандартные все Все одинаково запомнят Одно название Это удобнее Не ну в принципе это не сложно надо просто в System views SQL туда добавить это да если надо но но надо понимаете это надо же коммьюнити убедить что Вот Нам нужен именно такой способ определения неиспользуемых индексов а не какой-нибудь другой Там же их там десятки велосипедов это тоже такой достаточно непростой процесс их все свести в одно что будет доказано что всем удобно"
}