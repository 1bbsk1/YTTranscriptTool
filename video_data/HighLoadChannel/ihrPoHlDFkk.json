{
  "video_id": "ihrPoHlDFkk",
  "channel": "HighLoadChannel",
  "title": "pg_shardman: шардинг в PostgreSQL / А.Шер, С.Кельвич (Postgres Professional)",
  "views": 6136,
  "duration": 2792,
  "published": "2018-08-16T04:07:12-07:00",
  "text": "меня зовут арсений шер мы сегодня со стасом келли чем расскажем как мы строим sharding в под грехи начнем мы немножко издалека зачем вообще люди чего люди ожидают от распределенных субд и зачем они себе обрекают на такие страдания первое наверное желание это масштабируемостью производительность одной ноты перестает нас устраивать по чтению по записи или потому и по другому хочется чтобы доставил нот и все стало летать второе это high availability но стало еще больше значит проблем тоже стало еще больше нужно как-то восстанавливаться и наконец транзакции был взорван что в как раньше как на одной ноте месяц как учит университетах что вы если транзакция закончилась то она закончилась целиком или не скатилась вообще и заметите что вы если транзакция закончилась то оно закончилось так надежно и от души чтобы мы ее больше не теряли да и durability чтобы транзакций которые выполняются параллельно друг другу хоть и мешали но мешали не слишком сильно есть разные формализованные уровни изоляции транзакций прекрасно это знаете есть сама известность которых это 4 стандартных определенных стандарты сиквела и еще есть буква вкусе консистенции которая на самом деле почти ничего не значит как мы же признались авторы кроме того разговор распыленных субботы последние годы неизбежно возникает cup теорема я ее упомяну главным образом для того чтобы убедить вас что вы его берете и качественности в том смысле в котором было доказано эта теорема строго это не то что вам нужно а по поводу последнего свойства у вас даже нет выбора и так неформально как теорему звучит так что распределенной системе невозможно гарантировать одновременно следующие три свойства какие именно свойства 1 консистенция на всякий случай сразу это не имеет ни малейшего отношения consistent with там у которой есть если пытаться притянуть daisy кто скорее имеет смысл говорить о правилах видимости то есть об изоляции транзакций так вот консистенцию в коап теореме это линия рисуем а я согласованность не вдаваясь детали это вот есть у нас есть какое-то глобальное состояние есть действие запись и чтение с ними и генерируемая согласованность это когда эти действия с точки зрения молитву них процессов выглядит так как будто бы они все происходит моментально то есть можно говорить о глобальную линейном порядке причем этот порядок еще накладывает некоторые ограничения здесь важно то что если в качестве таких действий взять транзакции то это чрезвычайно строгие требования даже самый сильный уровень изоляции сериала и забыл определенной стандарте секула не дает таких гарантий слилось был просто говорит что транзакции выполняются так как будто они выполнялись линейно впарят в одном поэтому в грунт колонны порядке на неважно в каком именно при том что сериала и забыл до сих пор реализован даже не во всех традиционных собой реляционных вот в плоскости недавно появился вора клипом он до сих пор даже нет просто потому что он почти никому не нужен большинство людей вполне себе мириться с аномалиями возникающими на более слабых уровней к изоляции или просто даже не знают о его существовании поэтому консистенции в котле ты скорее всего не то что вам нужно а вы ловите в cobie требует чтобы любая но до начала на любой запрос успешно за какое-то время поскольку это математическая теорема конечно она не говорится какое именно вот это тоже не то что нам нужно потому что обычно вы ловите формулирует скорее на практике в терминах какого-то все раздавал agreement а то есть там 99 и 9 пациентов транзакции должны успешно завершаться за там не меньше чем на секунду вот но это не имеет никого отношения к ответу всех навсегда и наконец третье свойство я специально не хочу его шифровать потому что на мой взгляд название выбрано очень неудачно и не только на мой взгляд но смысл его в том что система наша должна продолжать работать в случае сбоя в сети если сети у нас никогда не сбоит то все окей мы можем это буква от этого свойства отказаться и все у нас будет хорошо если же мы живем не стране единорогов если лучше на что мы можем рассчитывать это на то что все единороги отделе водолазные костюмы шлифовать стали нарвал ими то есть бает резьба и ты тогда конечно мы хотим продать работу все это привело к тому что сам автор cup теоремой regular в 2017 году сказал что да если пойти на некоторые компромиссы отказаться от этих строгих формальных формулировок и то можно получить систему которая вполне себе available который вполне себе consistent и в каких-то разумных разумных ограничениях вот мы хотим пойти тем же самым путем мы хотим чтобы наши системы тоже было консистентная и доступное в более-менее двукратных формулировках разработка нашей называется пожар sharp macbook такой был рабочее название потом оно прижилось шарман предназначен прежде всего для типе нагрузок хотя мы хотим чтобы аналитику тоже не слишком сильно тормозила для горизонтального масштабирования и мы претендуем на то чтобы иметь честные транзакции шарман это расширение для 10 пояса под либеральный подрисовывать они доступны на гитхабе ручки чем будет внизу и он может работать с ванильным под грифом но некоторые фичи требует патчи ведро поэтому поддерживаем и по чину возраста же на гитхабе шарман это не какая-то самостоятельно официально с разработка это скорее компиляция разных технологий расширений и сейчас мы будем рассказывать про каждый из них в отдельности и про то как они нам помогают достигать свойства моментах вначале я расскажу про масштабируемость и прочей стас потом нам поведает про транзакции и мы постепенно загрузимся и так масштабируемость шарман поддерживает хэш горизонтальное хэширование то есть имеет раскидывать данные по нотам согласно хочу включая формирование как можно поиграть и получить кэширование можно пойти снизу пойти вот позиционирование позиционирование то же самое что и шарли рование но в рамках одной ноты мы берем одну большую табличку и разбиваем ее на того табличек поменьше окажется что это имеет смысл это часто имеет смысл делать даже в рамках одной ноты примеру если мы главное то что если мы можем быстро понять в какой партии в каком практичный лежат интересующие нас данные то сканировать вот только этот портрет будет гораздо быстрее чем сканировать изначальную конскую таблицу что в полисе с портишь ним в 96 до 96 включительно все было грустно и печально был только раньше или спарте shining реализовывался он регистрировался он вручную нужно было самому настраивать триггеры так что они отправляли этапу в правильные пар тишины и поэтому чем он был мало того что неудобно он был еще медленный уронить портишь ник это когда мы разбиваем данные по диапазону значений ключа самый типичный пример это какой-то временной ключ например можно табличку с годовыми данными разбить на месяц или неделю или сподвижник когда мы на прямой говорим что вы строчки с таким плечом лежат таком партии шину с таким ключом такому и так далее десятки которые недавно вышла был сделан большой шаг вперед появилась позиционирование декларативной можно как белый человек есть и успели написать хочу зонирует табличку тоже только лист и ранчпар хищник это здорово это большой шаг вперед но там по-прежнему нету хэш профи цианирование и еще никто ограничения которое нам из-за которых нас не получилось его использовать поэтому используем ожирением пиджи пасман которая разрабатывается нас компании там есть hash profits и они рование более того там есть разные крутые оптимизации она быстро находит нужный партнер знать опять не нужно и в том числе в ран t'aime поэтому шарм он использует пасман факты выглядит вот представим себе что у нас есть большой мешок рогов вот табличка большая и мы решили разделить на 4 мартишина 1 стала 4 хорошо а на это все в рамках одной ноты а нам нужен шорник нам нужно раскидывать их по разным народам как это можно сделать в полисе с недавних времён появился достаточно давних появился механизм где добавив орейн до этого пирс который позволяет по сбросу научить мозга и сходить за данными не в его обычно да это директория а куда нибудь еще этом например варкала по соседству или или в подвес или другой полюс для этого достаточно написать с соответствующей адаптер таких адаптеру довольно много и вот один из активно развивающихся это внезапно после смерти w который позволяет одному полюсу ходить в другой postgres технически это выглядит так пользователь создали создает виртуальную форум табличку и после того как он читает из нее данные postgres читает их из другого по сгрыз а когда пишется весна не туда отправляются под газ сердитого действительно активно развивается вот там последнее время появились такие крутые штуки как join и критично обсуждал значит это значит что пост грессов рядовой устраивается планировщик если мы при планировании запросов понимаем что нам нужно соединить две таблички они находятся на одном фарин сервере то вместо того чтобы сначала вытягивать одну табличку потом вытягиваю другую табличку и только здесь их соединять сразу по запросу лед туда они там соединяться и нам придет уже результат тоже самое с кирпично но есть и некоторые пока ограничения нету параллельно форин скана то есть если мы в запросе сканируем 3 for in табличке мы это делаем только последовательно это очень плохо с точки зрения проведения аналитики наш обмане но рано или поздно появится это ну теперь понятно что если мы совместим партии shining и пользуется где w то вот можно раскатать пар тишины пробросить в барин таблички и можно будет ходить на ногу и видеть при этом глобальную таблицу целиком если сделать так как вот на этой картинке то понятно не очень здорово потому что глобальные табличку мы видим только на первой ноде но нам ничего не мешает взять и на создавать их везде везде создательский партер одесскую таблицу везде создать форум таблички пробросить и вот мы уже можем ходить на любую ногу вот сюда вместо я буду называть марте шины shard подразумеваться одно и то же просто кусочек данных лежащих где-то она-то ведь таблица и прежде чем приходите к репликации ну так работает shacman прежде чем переходить привлекаться еще немножко поговорим о принципу кастрюлей распределения данных как я уже говорил что он поддерживает только hash sha родирование потому что для распределенной системы это представляется более и более входящем вызова литр наверное балансирует нагрузку и все равно не сейчас нельзя изменить количество сортов однажды однажды распределенной раз появившийся таблицы поэтому его нужно разумно выбрать вначале если их слишком мало мы не сможем равномерно раскидать пар тишины при увеличении числа но залипли их уменьшение а если их слишком много топнуть появляется слишком большой вверх от на метаданные вот ну поэтому разумно вам представляется 10 сортов на каждой ноги еще одна техника которая обычно упоминается в этом контексте этой consist in cash in который как раз позволяет изменить число сортов выбирается хитро хэш-функция так что если мы меняем числу шагов допустим сделали новый шарф то туда перетечет чуть данных с каждого существующего остальные данный останутся на месте то есть без полного перри 3 не я данных ну а стонет потому что мы общением и иметь количество ходов вот но это и не нужно если их заранее сделать достаточно много перейдем к high availability чтобы переживать падение нужно с чего-то восстанавливаться чтобы с чего-то восстанавливается нужно фиксировать данные как-то можно делать ну два базовых подхода это брать воду целиком совсем что на ней есть и реплицировать пользуясь это проще сделать с помощью физической или streaming потоковые репликации так делают у самок считаю без версия cytus а я прям спиральных картинку немножко странно потому что это позволяет потому что это вынуждает нас либо иметь в два раза большее количество нот либо нужно ставить под вопрос глютена надо либо можно инфицировать на уровне отдельных сортов для этого нужно логическая репликация еще одна историческая справка и реклама 10 кгц до десятки имеет логическую репутации подлостью можно было только с помощью расширения ти послание вам стоит который опять же были чрезвычайно трудно и управления и опять были медленный потому что они сновали основана на триггерах в десятке в ядро вошла логическая репликация основанная на декодирование вала как наверное все знают в пожгли съесть валко это классический райта hotlog который в которой пишутся все изменения которые используются для восстановления случае падения обычного по сброса как работает логическая репликация на мастере работает в гранд процесс вал sender который читает вал и скармливает его специальным мега течки плагину для логического dec 1 га он превращает бинарный вал в какой-нибудь более удобный формат произвольный например есть плагин болту джейсен который позволяет вам получить такую задачу которую написано вот сначала выставлен такой тапов такую таблицу потом был сделан апдейт такого табло и так далее ну в стандартной логическая репликации используется логин бюджет под который конечно представляетесь паскаль сам он превращает грубую рак текстовый формат и отправляет вал потом на реплику а там специально обученный apple и worker эти изменения получает и применяет другой ноги так вот если добавить к той схеме реплики каждого портишь на то появится примерно такая картина с точки зрения пользователя это выглядит так он говорит я хочу добавить хочу уровень убыточности иен для такой тоже родированное таблицы и шар на создает и она реплик для каждой для каждого партизаны а под газ поддерживать синхронную синхронную репликацию и шарман соответственно тоже это компромисс между раз компромисс между доступностью и надежности записи синхронная репликация блокируется если связь реплику потеряно оно медленнее потому что мы ждем но мы практически не теряем транзакции которые были зари прощены как законченные асинхронный аппликации наоборот работает быстрее вослед последние несколько транзакцию могут быть потерян при добавлении но да есть функция ребаланс который пользователь говорит и туда нам из новую ноту переезжает часть портишь ный фо реплик иначе зачем добавлять ноду причем перемещение подвижных в реплик тоже реализовано с помощью логической репликации поэтому происходит бесшовно пока мы отлично переезжает можно в него продолжать писать только самом конце когда осталось копировать совсем чуть-чуть мы блокируем запись портишь на пережает до конца и мы везде обновлен там форме таблицы и что еще нужно сделать failover но ты тоже обрабатывается пока что в полуавтоматическом режиме то есть должен прийти человек сказать это надо сдохла все мои и выключаем из кластера и тогда соответствующие реплики станут обычными практичными при этом пока что мы не умеем корректно восстанавливается к сожалению если количество реплик больше одной потому что реплики могут оказаться в разном состоянии ее нужно их потому что куратор аккуратненько сшивать им пока этого делать не умеем теперь как всем этим управлять самый простой подход это понятное дело выделить одну ноту которая будем этим заниматься но мы так и поступили назвали ее шар лордом потому что хотели уже в мастером но мастер слова черезвычайно перегружено в разных контекстах шарлот это отдельные из нас поскольку который держит таблички с метаданными то есть о том какие спорте шины как есть но ты где находятся эти партии шины казалось бы этот такой single point of older но это не страшно потому что на самом деле потому что метаданные совсем немножко вот данных табличек их можно куда-то реплицировать вот при необходимости шар лорда сменить это все его состояние и более того для обычной работы кластера широт вообще не нужно он как в этом не участвует он только нужен для вот управления при добавлении новых нот для ричарда и так далее ну такое техническое значение сейчас собор не может быть обычный рабочий ноты потому что все особенности логической репликации просто примерчик как выглядит чтобы было понятно заходим на шар орды говорим добавить но вот такую добавить на такую это обычно или покушай конечно стринги потом создаем табличку обычным клеить ты был наш орды и говорим что хотим ее раз радировать на по ключу вид на 30 пар тишина в суру ним безубыточности один вот потом можно взять посмотреть то будет запросить таблички с метаданными действительно вот вы видите пар тишина не находится на таких-то нотах относится к такой таблички и реплики тоже самого пыль из реплик и на разных родах у меня временно этом все сейчас расскажет про транзакции и потому что чуть-чуть микрофон ага спасибо так ну я продолжу про транзакции вообще у нас в конторе я хожу сям предлагаю транзакции арсений не сдержался согласился хотим мы их распределенные между нодами что все было хорошо красиво вот соответственно из там первое определение и сердца для транзакций нам нужно там атомарная изоляция так к ней у нас должны быть распределены и нам нужно и то и другое распределенное это важно и после этого мы все получим вот но что мы знаем про распределенные системы дадим такой живой классик перефразировав другого мертвого классика сказала что все распредели все надежные распределенные системы похожи друг на друга и каждая ненадежная ненадежно по-своему и вот это вообще отсылка к такому утверждению лэмпард а что все корректно и распределенные системы это ровд если это не ровд она не корректно фоксман raw показ на показ было раньше чем раб так вот собственно что нам нужно для от омар насти можно использовать такой достаточно известный протокол двухфазный к made the писи для изоляции клок исаия про него расскажу это более новый протокол которые позволяют достичь snapshot изолейцин или в терминах пожгли скрипит agile ride между нодами честно вот сначала про атомарная вот так выглядит двухфазный commit у нас есть кайт координатор который рассылает транзакции когорте когорты это ноды это может быть в терминах шарма на это вот координатор этот куда юзер than 1 которую юзер при конечен когорта те партии которые участвуют транзакции не важно не локальные или удалённые вот соответственно мы рассылаем транзакцию потом рассылаем для неё такой запрос при п р типа вопрос можешь ли ты ее применить если иное на этот вопрос полученные утвердительные ответы то мы рассылаем всем commit и вот здесь важно из-за чего нужен такой 2 2 2 round trip эти нужны потому что для многопоточный базы данных это вполне легально ответить что нет сейчас я не могу применить эту транзакцию это происходит из-за того что может быть дидло может просто был какой-то параллельные апдейты у нас высокий уровень изоляции это же сказали что нельзя если бы когорта могла применять транзакции без вот возможности в нормальном режиме сказать нельзя тип например как репликация в под грехи устроено так же вопрос посылаем туда страницы и реплика говорит окей применила применил или без ли бы это был бы условные редис однопоточный если мы все constraint и проверены на координаты ри то мы можем его посылайте и тогда можно избежать вот это вот описи в случае если это пост grease или и вслух или в случае если это в принципе sharding и у нас constraint и разные на разных новых мы этого не можем избавиться но есть одна проблема вот тоже недавно вне дальность это такое сильное утверждение tu fais коммент это протокол не про доступность а мы хотим вроде как в доступность поиграть что автор имел ввиду допустим носить координатор которые рассылают который за примерю подготовил транзакцию на всех нотах и начинает рассылать коммиты вот он разослал 1к мид и после этого взял и упал и упал вместе с вот этой но дай получается что у нас произошло 2 2 2 сбой в нашей системе и 7 нот и осталось 5 же вы их ну ну вот эти пять живых not не знают что произошло вот там вот вот там камин произошел или аборт и у них нет информации о том что вот как бы они за между собой не общались они не выяснит что там было если они у себя решат закомитить или за борт они могут не угадайте вот то надо которая ушла она после того как если вдруг она решит вернуться она не сможет этого сделать точном решение могло бы другое и коммита борт нельзя отменить то есть это вот такое разрушающе разрешающая штука и и мол больше не вернём в обычной базе данных стелс на чем можем сделать с этим есть два варианта либо мы можем усложнять то писи то есть нам за счет добавления промежуточного шага то есть сделайте вот трехфазным можно можно добиться того что ноды будет завязываться на большинство и меньшинство никогда не решает сама большинство решает вот протоколы типа пак сосками то или x3 писи делаю так либо есть другой вариант делать так чтобы участники ту би си никогда не падали и можно вот это переформулировать так вот то есть всегда когда мы делаем записи между кем-то парте шинами каждая из пар тишина за бы каплин допустим обычной репликации синхронный если у нас одна из нот падает то всегда вот эта информация о подготовленные транзакции или о за комичные транзакции она за бы капли на и вот в этой ситуации то есть надо здесь тоже есть сценарии сбоев но вот здесь существует правильный сценарий кто что после чего должен делать когда падение нот в реплике шин группах она не приводит к тому что нам вообще нужно что-то про вот зависшие транзакции решать вот соответственно примерно так же делают в спа мире так угловая такая база данных и г.р. брейер одобряю одобряет то есть утверждение в том что spanner при возникает такую проблему тем что каждый каждый участник топи see it up access группа и если если вот кто-то из access-group и умрет то его просто другая но до заменит и координатор может продолжить работу вот здесь вот я написал рипли тень шин группа и здесь репликация может быть разное это может быть например в том числе ровд в общем какой-то алгоритму репликации в общем ступицы разобрались как мы это делаем теперь еще одна еще один нюанс эта изоляция мы сделали все это у нас все там арно но у нас есть дырка между коментами вот на но дохни одновременно происходит commit это можно сделать простой тест вот эта настройка юстус фон этого то нашем почтенном под грехи которые на гитхабе там ссылка будет можно ее включить и попробую делать такие транзакции это вот обычная транзакция которая переводит данные из одной ноты в другой то есть российская табличка holders у них есть холмс и врать holders они могут жить на разных родах допустим там чётное на 1 четные не на на другой мы переводим корпус 1 с одной партиций на другую вот это вот одна такая транзакция которая будет распределенной параллели начинаем считать сумму всех и мы знаем что вот этого транзакция она не меняет total сумму никогда то есть у нас было там 1000 на всех 1000 должна быть но так как вот есть вот эта дырочка что на одной ноте она закончилась на другой нет то мы бы видеть не контентный результат то есть в среднем он будет примерно 0 но у нас это не устраивает дальше нужно говорить про то как вообще в принципе нога versions и баз данных на нескольких процессоров избегает такой штуки если коротко то осно идея в том что не нужно на апдейты наделит и менять данные in place нужно сделать новую версию данных вот такой вариант копим в райт соответственно каждый апдейт создает новую версию тепла и каждая транзакция видит только те туфли или кортежи или строчки которые которые должна видеть вот здесь слайде есть история для одного тупого допустим у нас есть юзера и d1 и у него какие-то значения вот тех же там холмс они были сначала 024 кто-то их меняет вот между версии 30 40 начинается новая транзакция она берет новые снапшоты вот это snapshot когда она взяла его была версия базы данных тридцать четыре отверстия баз данных это может быть косицы сын там таймс темпа времени от сильное упрощение вот но вот этот транзакциях которая 34 она не должна видеть сороковую версию потому что она появилась позже и она должна из всех предыдущих версий вид только 30 потому что 20 и 10 они уже устаревший то есть к момент когда началась кто-то их обновил вот идем дальше то есть основная идея как сделать распределенные транзакции в том что вот эти вот счетчики отвечающие за счетчики начала транзакции снапшоты вынести на отдельную ноту так делают почти все olap базы насколько мне известно так делает вас grease excel примерно также делает green план sap hana примерно также делает вот то есть нас транзакция начинается на одной ноги и нужно сходить вот я нарисовал там часики это штука которая tracked вот эти счетчики cdc сны и так далее цсн и to commit секунд набор оксиды это транзакт найди счетчик мы берем там этот счетчик делаем кит важные дела с этим ситом ходим местным что там ходим на соседнюю ноду и потом к метимся вот на коммент там в разных системах по разному иногда нужно брать счетчики иногда не нужно но это детали если не нужно брать наконец счетчик тогда нужно сна про ты более как подгрести под бисерине на наконец брать счетчик но за счет цены того что snapshot это не число а целый массив транзакций так вот в итоге получается что у нас все ноды ходят завод состоянии метра счетчика на нашу ноду которую которую можно назвать transaction менеджер например там вот так пузырь из excel она называется jetem global transaction менеджер и эта штука становится очень быстро узким местом то есть мы делаем не авад транзакции которые длинные которых мало в секунду она может идти час считает что то вот если мы делаем о типе нагрузку мы хотим их делать сотни тысяч в секунду со всей нашей системы и вот штук стразу становится узким местом то что поддержание счетчика с правильным инкрементом это по сути одна по точная вещь из вот у нас нет больших возможностей по масштабированию вот этого transaction менеджера часиков вот дальше идея простая вот соответственно алгоритм klo касаешься описываю что если мы заменим все эти счетчики назначения локального времени каждая но она берет себя время ходит на соседнюю но делает транзакцию и получает время для камина и все было бы хорошо есть мы умели синхронизировать время время мы синхронизировать не умеем абсолютно точно между нодами потому что синхронизация время над порядка миллисекунд там принципе а транзакция мы хотим сделать гораздо больше ответственно здесь получается все парадоксы которые связаны с путешествиями во времени был такой фильм праймер детонатор или и буквальном к переводить что нужно делать если происходит путешествие во времени мы хотим избежать кого-то парадокса один из вариантов если вы увидели что что-то произошло в ближайшем будущем то вы хотите как-то этого избежать и сейчас еще раз пробую чтобы избежать парадокса нам нужно сделать так чтобы мы с собой не пересекались давайте еще раз за ход сделал сложная штука путешествие во времени мы хотим вернуться в чуть-чуть назад во времени и хотим чтобы две версии нас мы которые были оригинально которые вернулись и которые попали не противоречили друг с другом не привели к каким-то аномалиям вот соответственно один из вариантов которые был реализован в этом фильме что парни запирались полностью в комнате на один день прошел новый день они заперлись в комнате потусовались на весь этот день ни с кем не взаимодействовали после этого залезли в машину времени вернулись обратно весь этот день они ходят их двойники которые тип из прошлой временной линии они сидят в комнате вот и так они избегали того что происходит продукции так они там в конце вот первого дня смотрели котировки акций и потом еще раз шире торговать вот соответственно что делает cock is a им делает что-то подобное visibility в правила или билеты можно в вести такую поправку что если мы видим версию дупла или строчки у которой таймс темп ассоциированные с которой он больше чем наши текущие локальное время то мы просто начинаем ждать и ждем и ничего не делаем с этим тупым не читаем не пишем вот когда это время наступило мы можем продолжить его читать взять заново статус этой транзакции которая его породила и продолжить и вот это обеспечивает нам то что алгоритм визе велите он сам тебя сама синхронизирующий ся между нодами связи время чуть-чуть разъехалась то автоматически соседние ноды чуть подождут и наша корректность не будет завязана на степень синхронизации нод по сути на будет завязана только скорость работы то есть если у нас времени синхронизован там и не когда вот этот вот эта сцена и не реализуются вот но и дальше еще нюансы что между ту писи и мы не видим транзакцию потому что мы не знаем у нас она prepared но мы не знаем еще она на других модах какую не остаться поэтому нам нужно подождать пока она знакомится или забор tits ну и алгоритм комет такое что мы везде разослали припер со всех ног собрали их время и закончились максимально вот эти три правила обеспечивают нам правильную правильную изоляцию транзакций вот соответственно бенчи небольшие то есть здесь здесь синий базовая линия нарисована нарисованный дпс на погребение минус это такой и cebit тест который переводит вот тоже просим простенькие апдейта там вот на одной ноте это 10000 дпс порядка вот шармом нас начиная с трёх нот начинает обгонять сингл instance и вот эта красная линия зеленая линия это с одной асинхронная реплика соответственно чём здесь видимо первых она масштабируется все-таки относительная линейно на этом тесте вот во вторых мы видим еще что три ноты далее далее скорость сравнимую с одной поэта основное замечание что пока bench это один из самых плохих вариантов для такой системы то есть сам пока bench in генерирует случайные апдейты и случайные переводы с модно но то есть он ничего не знает о том где какие партиции лежат соответственно если у вас applications какой-то работает с этим всем то есть допустим не знаю игрушка то вы можете знание о том где какие шарда лежат вносить частично в приложении сделать такую оптимизацию чтобы в основном все-таки транзакции ходили на свою ногу это не обязательно но это сильно повысит performance вот основная идея здесь было продемонстрировать что это линейно масштабируются вот ссылочки соответственно жар но он сам extinction с документацией находится вот по такой ссылке под grease прошлый шарман его можно поставить на обычный после 10 можете если что-то найдете что то увидите кит проблемы репортите шью вот некоторые фичи про которые я рассказал этот описи изоляции и прочее требует того что пузырь с надо пропатчить и соответственно это живет в репозитории поиск рис кластер в branch и пока шар ну то есть его можно скрыть его можно скачать либо полностью исходники под без а оттуда либо гитхаба сделать почти новые жить их на под gris вот соответственно появится то писи со snapshot ами и copy from потому что perform his пользуясь это же там на фидер и не поддерживается на и где w вот вот так вот всем спасибо кит вопросов а или да наверное надо подождать микрофона вот уже или по моему ну вы можете спросить я повторю пока давай доставать вы еще раз слышу повторите то есть я и есть оперативные данные то есть есть оперативные данные из которых работает наш есть отдел который потом или национализирует да есть тяжелые report соответственно проходит сутки мне с этой реплики которые классическое ничего не надо чтобы там они уже дошли до рн и я нанял нагрузку даю у меня ничего в продаж и не страдает как у вас с этим планируете я думаю это все таки для у лтп и для того что вы назвали оперативными данными то есть чтобы от масштабироваться на вот этой первой базе данных вот и потом можно действительно гонять аналитику на другой базе в которую там репликацию или как там events ворсинка это делать вот то чтобы делать аналитику вот на жаргоне это такая дальняя задача нужно в поезде w много чего уносить это пока они не основной приоритет то есть слой приоритету ftp нагрузка чтобы можно было на лету добавлять ноду убивать ноды или если надо сама умерла то можно было быстро с этим справится в текущей реализации не получится что если мы с оперативными дома работаем и я потом это реплицируют ведь я же как буду реплицировать я же всю всю логическую репликацию тоже за собой тему схему репликации всего можно сделать надо рассказать как то есть это обязательно будет логическая репликация можно на каждой найденной к которой является мастером для своего пар тишина нужно поднять вал сингер и он там я так подняты из-за бэкапов нужно просто поднять еще один и подключиться на всех логическая репликация она умеет сливайтесь многих потоков то есть так можно сделать всего за доклад о такой вопрос с фарин ключами обстоит зеланд между партициями можно другую есть группа по шардже них таблица есть еще одна группа пошла джин к таблице они как-то связаны логически что в этом случае можно сделать что-то здесь мы рассматривали здесь случай с одной таблицей везде вот предполагается предполагается что у вас есть какие-то таблицы rush origins например таблица с юзерами антипод глобально шарден вот дальше и есть варианты если какая-то табличка строгой зависит от юзеров то ее имеет смысл хранить вот только на тех новых куда попал этот шарф и там же и и бы копить то есть у нас есть табличка users и табличка допустим не знаю ой там где есть в рынке юзера иди вот мы везде заводим users и везде заводим а items но есть локальность вот куда попала транзакция с юзера иди равным 100 там же будет лежать а это мы его там же они будут за бы каплин то есть фаренгейт constrain здесь срабатывает из коробки есть таки да плохо все скоро с фрэнком который на шарнирную таблицу вот это не поддерживается этот скорее даже значение пасман и которые там снизу действительно это можно с этим можно бороться с помощью просто локальных таблиц не все нужно сервировать да ну то есть и идея наверно в том что наша реагированию таблиц фаренгейт не самый ну то есть идея есть людей господи есть варианты когда это нужно но и обычно от не нужно если есть какая то топ таблица от которой почти все наследует вот если правда у нас есть сообщение то там чуть-чуть по-другому будет когда у нас джордана шардоне можно можно вопрос первый момент не очень понятно что будет из там не знаю одно из нот чувствуют на час назад например ну там что-то пошло не так а второй момент все таки если я взял и неправильно выбрал там количество шаров которыми есть какие там вряд ли действия этих случаях ну то есть если тоже что-то пошло не так взять и я про часы отвечу если часы отстают на час назад так делать не надо то есть вам вам влог будет писаться когда вы начинаете там есть такой специальный 3 школ который сейчас стоит в десять секунд если логан аноде превосходит 10 секунд он отказывается начинать транзакции и ругается в лоб что типа что-то уже идет не так то есть по-хорошему по алгоритму мы могли бы подождать 10 секунд начать транзакцию но все будет работать медленно поэтому лучше держать хотя бы ntp включенным вот это ответ на ваш вопрос то есть если вы видите ошибки о том что время а та та та та все разошлось то включите ntp все последовательно это нормальная область вот а про количество сортов но тоже не надо так делать вот можно можно реализовать sharding просто сейчас это тоже не приоритете вообще такое лирическое отступление что в целом у нас довольно молодое но мы это пишем скорее под одного конкретного заказчика поэтому он просто нас есть ледники и приоритеты вот сейчас есть этого потому тупо нагрузка поэтому тоже а вот это не то на чем работаем прямо сейчас на самом деле услышал важно клодта что нельзя одновременно выполнять параллельно запрос на разных шар дав последовательно будет отбегать вопрос пределах одного шар до параллели зале и select и то есть можно ли управлять временем линейно запросу за счет там распараллеливания или нет за это отвечает обычный поезда там потом появился параллельное выполнение , но запросы она там есть спасибо за доклад я может быть не услышал про индексированию гардеробных таблиц что с ними там глобальный индекс и локальные и так далее спасибо хороший вопрос индексирование индекс на все таблицы можно повесить при этом если вы делаете на свою шарди рваную таблицу uniq constraint то вот это не будет работать то есть у них constraint по шариди раваны и таблице не будет работать по таблицам которые зависят от нее я не локализованные той ноги и естественно все нормально вы там можете на 10 unic ну вот глобального и unique нет пропускали также как и в форме комфорт ключи это конечно нет почему unic глобальная таблица имеет смысл ну типа use email по уникальный по помощь там было обсуждение в рассылке но это глобальный индекс и вопрос просто такая же ситуация с вот сейчас пост грехи десятом появилась позиционирование там тоже нет глобальных индексов ну вот мы этой традиции свята следуя был же вопрос про фризен включена то что нужно сделать чтобы они располагались на 1 шар для а возможно лишь радировать таблицы по разным ключам то есть вы выделяете какую-то фишку которым сортируйте он применяется один ко всей базе или можно настраивать но ключ с родированием прт ибо шокирована и если у вас 2 провяжите 2 таблички они могут быть просто цианирования по разным ключам такой вопрос а вот гарса вдв вы используете штатный который десятка идем вот записи для заберите это почти вот ну то есть логика сама сама роение плана запросов там да да да в этом так пока что мы ничего не меняем но потом брали ход потому что там вы с джо и нами на самом деле и даже в десятке там уже down у него очень редко срабатывает согласно планы какие то есть есть конечно то есть плана и из этого сделать самую лучшую база данных нет то есть для мозга 1 of 2 то есть мы здесь специально старались минимизировать количество того что мы сами пишем и максимум использовать встроенные штуки где w логическую репликацию и так далее чтобы их патчить и чтобы это уходило в основной под бриз въезжает ближайшая наверно из всего это правильная агрегаты по fdw сейчас вот агрегат имеется ввиду грубой прокидывает а если что-то типа сумму прокидывает 100 можно было бы сумму там посчитать а здесь перри суммировать вот сейчас такого нету вот это сделаем на иран леев ди дабл ю правильно сканирование и параллельно и сканирование это вот ближайшие планы ну сумму по моему он пропитывает на где w-net он умеет перелет локально вот он там нюанс что если есть параллельно если есть локальные партиции то он умеет построить перевел план рассчитать сумму на каждой партиции из агрегировать его fdw в принципе не поддерживает принял scolloped моя логика не срабатывает но если вы научитесь это обойти то напишите нам друзья у нас время уже ограничено поэтому вы что-то говорили на вопрос секрет нет времени отвечать да"
}