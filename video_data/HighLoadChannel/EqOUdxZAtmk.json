{
  "video_id": "EqOUdxZAtmk",
  "channel": "HighLoadChannel",
  "title": "О распределённых транзакциях / Владимир Комаров (СберТех)",
  "views": 852,
  "duration": 3068,
  "published": "2025-01-17T02:27:22-08:00",
  "text": "вот сегодня тема нашего разговора О распределённых транзакциях вот вы знаете что маховик импортозамещения раскрученный мощность вот Сбер об импортозамещении начал задумываться ещё 10 лет назад и Одной из самых главных проблем были гигантские базы данных на уникальном оборудовании Мы думали чем же их можно заменить и естественно какие-то надежды возлагались на распределённые базы данных Мы думали сейчас вместо одного большого сервера поставим много маленьких и будет нам счастье вот я достаточно долго изучал вопрос и стал идейным противником распределённых баз данных вот частью находок сегодня с вами поделюсь В чём главная Проблема в том что большинство прикладных разработчиков Ну не тех которые сидят здесь А большинство к базе данных относится как к чёрному ящику совершенно не понимая что там внутри почему оно так работает и зачем оно так работает вот а когда даёшь такому разработчику распределён ную базу данных он начинает с ней работать как с таким же чёрным ящиком только большим вот естественно у него там достаточно быстро возникают всякие нежелательные спецэффекты и он винит либо службу поддержки либо соответственно вендора вот когда я работал в Сбере Я играл роне команды эксплуатации сейчас я работаю в сбертехе это вен В общем мне бы досталось в любом случае поэтому я против вот очень люблю такие совпадения кто вчера был на последней лекции Да вы помните что в чёрном квадрате нет смысла Это чистое искусство вот сегодня мы точно также из любви к искусству приоткрой чёрный ящик посмотрим отку сэ вот знаете китайским императором нанимали учителей Вот и учитель С одной стороны должен учить императора а с другой стороны он не может ничего знать лучше императора просто по определению вот поэтому Значит каждый урок начинался словами как вам должно быть известно или там позволю себе Напомнить вашему императорскому величеству так вот позволю себе Напомнить аудитории что вообще Вран используется п классов решений Пять оттенков чёрного кластеризация Монолита что это такое берм обычный постс или Oracle и делаем нужное количество реплик плюсы такого решения очевидны мы там при соблюдении известных гигиенических правил бесконечно масштабируемые а именно ведущий узел выходит из строя то вся система встаёт и ждт когда её починит значит второй класс - это распределённый консенсус когда равноправные узлы должны совместно принять какое-то решение вот ну все известные мне реализации дискутировался безопасные типы данных это структуры которые заранее рассчитаны на то что их будут менять в разное время в разных местах не всегда связанных друг с другом вот кто вчера слушал лекцию Евгения Кузовлева про финансовую систему в которой там Три кусочка баланса в трёх разных цода Вот это простейший пример такой структуры смыс структу в том одинаковый Ну собственно Вы это видели вот ну и наконец компенсирующие механизмы когда Давайте побыстрее запишем Пусть данные будут не согласованы когда-нибудь мы их согласуем либо это какой-то фоновый процесс либо проверка прич Вот либо некоторые базы данных вообще вываливаются несогласованные данные прямо на приложение и приложение должно принять ресм пй Рени ция то есть Самый наверное строгий класс когда несколько независимых участников делают изменения и должны решить либо все эти изменения применить либо откатить Ну и вчера видели да что чёрных квадратов на самом деле четыре у нас будет два чёрных ящика это сервер и драйвер то есть принято считать что единственная задача драйвера - это сериализация данных то есть преобразование вызовов языка в протокол базы данных это не всегда так иногда в драйвере тоже скрывается некая магия вот всего мне известно три способа выполнить распределён ную транзакцию и первый из этих способов который долгое время вообще был синонимом распределённой транзакции Это протокол двухфазной фиксации вот картинку которая сечас на экране наверняка много-много раз видели вот смотрите фотографировать и записывать ссылки Не обязательно в конце будет QR код по которому можно будет слайды скачать без регистрации SMS мне стало интересно откуда же растут ноги у этого алгоритма и я не нашёл вот смотрите статья 1986 года называется содо это нная база данных Компани так подозреваю что многие из вас родились в 1986 году или позже Да Поднимите руки кто моложе во года ну смотрите вот а вот в этом документе протокол двухфазной фиксации уже назван хорошо известным то есть по всей видимости какого-то источника Где бы он был описан его не существует вот ну и проб все тах арит потом описаны в том что очень мало внимания уделено модели отказов Вот и если мы посмотрим то отказы вообще говоря не предусмотрены то есть участник там Может на какое-то время пропасть но диск у него должен быть надёжным он всегда возрождается и всегда с теми данными которые успел записать Вот и в 1991 году таки вышел стандарт где описан именно протокол двухфазной фиксации и вот эти все неявные предположения зафиксированы явно участник имеет надёжный диск и всегда возрождается и всё что он записал сохраняется навечно вот Ну давайте посмотрим как это реализовано в реальных системах очевидный подход Ну давайте действительно обеспечим надёжный диск в ЧМ проблема такого решения Ну представьте себе что вышел из строя Вот и надо быстро-быстро заменить сервер вот Ну даже если предположить что там рабочие на низком старте Вот они быстро там бегут серверы стойки выдёргивают и вставляют всё равно для фиксации транзакций это слишком долго вот поэтому во всех таких системах надёжное дисковое хранилище сделано разделяемый то есть если вдруг узел отказал то его работу подхватывает либо другой работающий узел либо специально стоящий запасной узел Вот но Обратите внимание во-первых все системы которые здесь перечислены это аналитические системы не транзакционные вот во-вторых это то что называется словом Кровавый Enterprise Ну Единственное что может быть Oracle - это в какой-то мере транзакционная система НОК он по большей части встречает виде экзоты а не в виде всяких самосбор комплексов вот а эдата - это достаточно специфическое оборудование которое умеет достаточно быстро восстанавливаться вот ну и ещё прикол Вот и Microsoft и orle Ита - это всё традиционные дисковые системы хана - это система в памяти то есть для того чтобы восстановиться ей недостаточно просто проверить целостность файлов и читать их поблочно надо ВС состояние считать в память соответственно перейти на резервный кластер гораздо быстрее чем дождаться пока восстановится основной так Проклятие кликера Ага вот второй подход Давайте просто обеспечим отказоустойчивость всех участников и такой подход мы можем видеть например в Гуглом спане там тоже используется протокол двухфазной фиксации Но каждый участник транзакции это группа серверов так называемая таблетка и Значит все серверы этой таблетки расположены в разных центрах обработки данных То есть если какой-то сервер выйдет из строя то значит его партнёр по транзакцию вс-таки завершит Вот кто знает почему таблетки обведення знает да это контуры греческого острова Пакс где по слухам функционировал парламент с достаточно хитрым протоколом голосования следующий способ давайте мы просто будем готовы к тому что часть участников можем потерять и смири с этим Ну например аналитическая база данных Green PL координатор у неё дублирован то есть координатор мы считаем что надёжен и не выходит из строя А вот узлы не дублированый кусок данных находится на нескольких узлах И если мы какой-то из узлов Теряем мы просто назначаем изменённым кускам нового мастера и завершаем транзакцию оставшимся кворум а отказавшиеся то ли его совсем вычёркиваем то ли как-то восстанавливаем Вот ну и наконец ещё один подход Если вдруг произошёл сбой то разбирать последствия всем миром например такой подход реализован в игнате или в лка когда идт транзакция все участники знают обо всех остальных участниках и если вдруг кто-то из участников пропал причём включая координатора там нет выделенного координатора там тот узел на котором началась транзакция является координатором для этой транзакции вот а соседний узел может быть координатором для другой транзакции вот если вдруг кто-то не отвечает то узлы начинают обща друг с другом Нае тем дольше восстановления вот ну я смотрел в Исходный код в общем код успешного завершение транзакции он примерно в 10 раз короче чем код восстановления сбойного как мы сказали координат он должен сначала подготовить завершение потом с командовать Всё теперь действительно завершаем это всё занимает время вот Ну понятно что в аналитических системах Это не проблема то есть если транзакция длится 10 минут то там одну секунду на комит мы себе можем позволить в транзакционных системах это проблема значит одна из попыток решить эту проблему замена двухфазной фиксации однофазной То есть если мы видим что мы поменяли только те куски за которые отвечает какой-то один участник то мы можем просто завершить транзакцию на этом участнике вопрос кто такие мы в данном контексте и на этот вопрос разные вендоры дают разный ответ вот если мы рассмотрим например Oracle с опцией sharding там на этот вопрос отвечает клиент то есть совершенно прозрачно для приложения клиент понимает что какие-то транзакции можно завершить локально на одном из узлов к этому узлу идт и завершает в хане немножко не так там координатор выделенный узел координатор должен понять что транзакция может быть однофазной соответственно говорит клиенту перелоги на конкретный узел и посп ве реализация в холка там приложение должно решить что комит будет однофазный и в документации прямо английским по белому написано что Если Вы выбрали однофазный комит но при этом поменяли данные на разных узлах то в плохом случае Можете просто потерять данные вот Но насколько я знаю в одной из ближайших версий отказывается от двухфазных транзакций вот Ну ещё интересное решение вторую фазу можно выполнять асинхронно есть такая распределённая база коро db основная идея заключается в том что создаётся объект транзакции То есть как только мы транзакцию начали как только мы поменяли первый объект значит за этот объект отвечает какой-то узел и этот же узел отвечает за транзакцию у него в памяти создаётся объект где записа все ключи Вот кстати заметьте я говорю ключи то есть коро - это реляционная база И вообще говоря по теории ключ в реляционной базе не обязателен Но для распределённых систем ключ становится обязательным так вот все ключи сохраняются в этом объекте и после того как мы говорим узлу комит узел ходит во все узлы участники говорит готово Готово после этого он записывает на диск объект транзакцию и клиенту отвечает всё нормально соответственно после этого все изменения которые были сделаны на удалённых узлах применяются асинхронно вот Ну на самом деле там не делаются изменения прямо в данных там записывается так называемый intent то есть новая версия вот ну и соответственно либо другой клиент который видит этот интент либо какой-то фоновый процесс ходит собирает и вот в объекте транзакции отмечает что все данные надёжно записаны Это долго но пользователю это незаметно потому что происходит асинхронно второй способ выполнить распределенную транзакцию это детерминированные транзакции кальвин протокол н кальвин известный богослов его даже называли в сво время швейцарским папой его основная мысль заключается в том что вся наша жизнь предопределена Богом и Наша задача следовать этому предопределения и не мешать вот если переложить это на язык баз данных то Ну рассмотрим какие-то изменения он записывает эти изменения в журнал здесь подход обратны давайте мы сначала сформируем журнал а потом значит выполним транзакции записанные в этом журнале на разных участниках И если мы одну и ту же последовательность транзакций выполним на разных участниках то мы должны получить одинаковые результаты собрата была опубликована в 2012 го неко систем которые реализуют этот протокол значит перед вами кавин машина это рисунок прямо вот из оригинальной работы значит приложение по пунктирной стрелке читает какие-то данные значит оно определяет С какими ключами оно будет рабо и это последовательность чтений и записи причём когда операция читающая обязательно указывается версия объекта которую она должна прочитать то есть таким образом реализуется механизм оптимистический блокировок если реально прочитанная версия не совпадает с той версией которая быть прочитаю как-то упорядочивает эти транзакции Ну Неважно как главное что вот это вот в модели кальвина есть тот самый Бог который пишет предопределение и рассылает его участникам вот ну и Обратите внимание что участники общаются между собой То есть если какой-то участник обнаружил что он не может выпо транзакцию ожен это ции значит какие недостатки у этого метода Ну во-первых только низко конкурентная среда то есть если мы строим например систему работы Ну допустим С банковскими картами то наверное это будет работать если мы строим к примеру расчётную систему где там через два десятка счетов проходят там сотни тысяч операций То никакой кальвин нам не поможет то есть оптимистические блокировки - Это для низко конкурентной среды вот второй недостаток - это огромные задержки то есть во-первых секвенсор должен выждать какое-то время чтобы собрать транзакции в пачку в оригинальном кальне это 10 миску вот если сек знат они все должны как-то между собой синхронизироваться получается немножко дольше Вот во-вторых вы видели что секр отправляет данные Всем участникам на картинке было нарисовано там четыре участника на секвенсора Но на самом деле участвуют же не уст это тоже занимает время вот ну и наконец обмены участников между собой они тоже занимают время Поэтому если вам нужна быстрая обработка транзакций то это не прока но Существует очень много всяких хитрых оптимизаций значит сейчас посмотрим например система Яндекса которой здесь уже несколько раз говорилось есть замечательная лекция ссылка на неё тут приведена рекомендую посмотреть что сделали коллеги во-первых между секвенсора и участниками они поставили медиаторы то есть секвенсоры общаются со всеми медиаторами а медиатор общается только с частью участников то есть количество сетевых обменов оно пропорционально не произведению количества секвенсором знат второе что они делают они могут менять порядок операции Вот честно говоря я не до конца разобрался как это помогает ускорить обработку транзакций вот ну если начать в этом разбираться это целая лекция ссылка на которую здесь приведена и наконец главная оптимизация слепые транзакции какую-то версию данных нам в принципе неважно Какую мы можем обратиться напрямую в хранилище и номер версии мы получим но в принципе он нас не волнует Либо мы можем хотеть записать что-то и Допустим мы записываем и нас не волнует что мы для такой заливки Совершенно не обязательно прогонять эту транзакцию через секн можно напрямую отправлять е в участника она запишется быстро Вот вот благодаря этим оптимизация работает существенно быстрее чем классический кальвин но возвращаясь к началу нашей лекции отдавать такую базу данных среднему разработку по те мы вместо эпох в которые секвенсор собирает эти транзакции используем реальные временные метки и такой подход реализован в алгоритме аккорд который соответственно реализован в пятом релизе Касандра тут фактически каждый узел является сам себе секвенсором если ему надо сделать какое-то изменение он отправляет это изменение тому узлу который реально должен данные изменить вот отправляет свой Пит отправляет показания часов и там некое логическое время Второй узел смотрит если нету заявок с более ранним временем то он отвечает Окей значит я его выполню на самом деле совершенно зубодробительный алгоритм вот опять желая лекция конста приведена здесь вот причём она помечена красным вот поэтому углубляться не будем вот Единственное что я скажу вот в этом документе меня очень-очень смутило одно предложение там написано мы считаем что часы в кластере синхронизированы и мы можем получить разбег этих часов и учитывать его в своей работе Вот и вот этого я никак понять не могу я е одну базу данных которая рассчитывает на временные метки это Google SP Вот Но они там используются по-другому но тем не менее Вот но спаннер запускается в контролируемой среде там в каждом цоде серверы точного времени там свой протокол синхронизации там свой порядок синхронизации и база данных действительно Может на что-то рассчитывать на что рассчитывают создатели этого протокола могу толь пожелать удачи Вот и наконец ещ одна хитрая оптимизация Давайте мычит сделаем централизованный менеджер блокировок реализована такая штука В базе Foundation db вот причём интересный момент вот мы помните говорили о продуктах то есть есть там какая-то ири есть проду ирия то есть мы говорим мы сделали основание вот если кто-то хочет сделать на этом основании нормальную базу данных берите наш движок и Делайте как работает этот движок клиент читает какие-то данные у него там естественно выстраивается последовательность изменений которые он хочет провести Вот и всеми ключами отправляется в прокси сервер вот прокси сервер ходит к одному из координаторов выдаёт этой транзакции метку А дальше начинается процесс блокировок Как устроен этот процесс прокси сервер идёт в кэш и говорит Я хочу менять Вот такой-то ключ если такой ключ в кэше уже есть ш говорит нель соответственно Проси отвечает клиенту транзакция не удалась Если такого ключа нет то кэш запоминает этот ключ и говорит можно вот ну и после этого прокси сервер значит записывает данные в журнал Ну и дальше они расползаются по узлам хранения Как снимаются блокировки а никак то есть блокировку записали через 5 секунд она потухает вот если через 5 секунд пришла новая транзакция блокировки нет то ей опять разрешают изменения вот Ну соответственно длительность любой транзакции ограничена ть секундами То есть если транзакция длится дольше то её откатывать даже не пытаясь что-то сделать вот Ну опять же это оптимистические блокировки опять же здесь возможно ложные отказы Вот Но тем не менее система вполне Рабочая насколько я знаю её купил Apple и даже что-то на ней построил вот ну и наконец третий способ выполнить распределён ную транзакцию Это сага тоже Казалось бы совершенно новая модная Молодёжная технология на самом деле нет статья в которой этот подход описан опубликован в 1987 году Вот но здесь сначала описали подход Потом значит дошли до реализации значит сага все вы знаете очень-очень простая просто по очереди выполняются все транзакции входящие в эту сагу вот всё как бы очевидно быстро дёшево замечательно проблема в том что мы привыкли что транзакция у нас эт атомарная Да согласованная изолированная надёжная вот ну Сага безусловно надёжна настолько насколько надёжны все её участники она безусловно переводит всю систему из одного согласованного состояния в другое вот Амар она весьма условна поскольку Ну с точки зрения того кто эту сагу запускает она действительно амарна вот а с точки зрения всех остальных Вовсе нет ну и никакой изоляции здесь нет то есть в процессе выполнения Саги даже её инициатор может видеть некие промежуточные состояния вот вчера как раз только о возможностях базы но и о предметной области вот поэтому Ну если мы например делаем питупи перевод Да классический пример если мы сначала зачислили то это будет плохо А если мы сначала спишем деньги с отправителя потом зачислил Ну как бы да изоляция нарушено но с точки зрения бизне это нено момент значит когда я рисовал процесс выполнения Саги там не было никаких сбоев вот а на самом деле сбоев может быть очень много всяких и выясняется что выполняя сагу мы не можем выполнять какие-то произвольные изменения на участниках мы можем выполнять только некие фиксированные процедуры и эти фиксированные процедуры должны обладать целым набором свойств Они здесь перечислены вот ну и опять же здесь есть ссылка на прекрасную лекцию по сагамхай файловая система там запись реализована в виде Саги вот Ну на самом деле нет необходимости засовывать реализацию Саги прямо в базу данных её всегда можно реализовать сверху вот ну и такой класс программного обеспечения как оркестратор вам прекрасно знаком собственно вот этот подход выбрали и мы значит компания Сбербанк Технологии она делает технологическую платформу для Сбербанка Ну и для других крупных предприятий и конечно же это микросервисная архитектура Ну вот год назад на конференции я рассказывал Почему в Сбербанке без микросервисов никак Вот собственно масштабируется нагрузка функциональным делением каждое приложение оно маленько обладает уко фун функциональность не вмещают в одну базу и для них мы применяем шардирование то есть если допустим у банка Ну условно там 60 млн клиентов можем сделать шесть шардов каждый из которых обрабатывает 10 млн вопрос А как делить клиентов по шардам очень долго думали Там то ли по регионам то ли там по хэш сумме то ли ещё как-то ну не получается хорошего деления в конце концов решили просто явно Поделить по спискам То есть ты в Один шар ты в другой шарт Ну и так далее А как клиенту сообщить С каким шардам его работать вот а оказывается что прямо в кубернетес есть такая штука Как подсказка маршрутизатору если маршрутизатор не знает куда отправить вызов обращается к этой под встроили так называемый межк индекс это база данных типа ключ значения распределенная база в памяти но вот для данного типа нагрузки это идеальное решение на базе нашего же дата грида ключом является название сервиса и идентификатор клиента а значением является номер шарда соответственно получив нужную Куку марто отправляет выв в нужный ша Да работает с Вот а если вдруг там Вася переводит деньги Маша и они находятся в разных шарда вот ну это всё естественно обрабатывается оркестратор сратов У нас тоже собственный насколько я знаю коллеги пытались использовать активити Но в общем не устроил он их Пришлось написать собственный код вот а В качестве базы данных для оркестратор используется кавка несколько Неожиданное Решение вот но тем не менее Но вот реально оптимально то есть Сага - это очень короткоживущий объект и всю свою жизнь Она проживает в памяти оркестратор вот А после того как она завершена объект уже никому не нужен То есть читаются эти данные только в случае какого-то сбоя главное их быстро-быстро записать Ну записать куда-то быстрее чем в каку наверно сложно Вот соответственно там на выходе стотт технологии вот и там в тех исключительных случаях когда оркестратор падает мы с таблице считываем состояние запущенных сак Ну и перезапускает Вы наверно знаете что у каждого лектора есть куратор и когда мой куратор первый раз увидел мою презентацию он сказал обязательно скажи про хореографию то есть где распределённая система там хореография рассказываю хореография прекрасна на полотнах га И ещё я очень люблю балет Игоря Моисеева вот там где речь о деньгах там никакой хореографии вот если узнаете что в какой-то финансовой организации финансовые транзакции происходят по схеме хореографии скажите мне я заберу оттуда свои деньги и друзьям посоветую Вот и наконец ещё одна архитектура о которой хотелось бы сказать так называемые облачные базы данных Почему они облачные потому что пй очень сложный и доступны они только в виде облачных сервисов Я ещё не видел такой базы данных которую можно было бы поставить у себя значит Первым был Amazon со своей авророй на базе Майкла затем подтянулись Google и Microsoft и есть ещё одна база данных не успел её сюда вписать называется Neon э тоже построена по такой же схеме одноименной компании под руководством нашего земляка Никиты шамгунова Как устроена такая база данных значит для пользователя это экземпляр Ну того же самого постгрес или любой другой традиционный дисковой базы но этот экземпляр не занимается вводом выводом То есть у него есть буферный кэш у него может быть дополнительный кэш на каком-нибудь схм ше но он не заботится о том чтобы сохранить блоки данных он пишет журнал вот а под ним лежит достаточно хитрая распределённая система хранения данных которая эти журналы принимает накатывает их на страницы значит Эта система она заботится о том чтобы страницы были целостные заботится о том чтобы сохранять может быть несколько версий страниц таким образом В некоторых случаях даже дела нум резервное копирование вот Ну и по запросу отдаёт нужные страницы экземпляру то есть При таком подходе понимаете да Что экземпляр можно перезапустить очень быстро он вообще ничего не теряет Если нужны читающие реплики можно их в неограниченном количестве запускать Они мгновенно готовы к работе Вот ну и естественно производительность такого экземпляра больше чем производительность экземпляра с традиционными дисками вот всё хорошо в этих системах кроме сложного деплоя поэтому повторю ещё раз доступно они только в виде облачных сервисов вот ну и минутка рекламы вот то что я рассказал это в некотором роде Азбука и вот 10 лет назад я искал букварь в котором мне эту азбуку кто бынина пришлось такой букварь написать самостоятельно Вот Всем рекомендую значит в электронном виде книжку можно совершенно легально скачать без регистрации SMS если кто-то любит бумажные книги то лучше покупать непосредственно на сайте издательства там цена примерно вдвое ниже чем в традиционном книжном Вот на этом всё видите даже уложился в тайминг У нас есть время подискутировать м сылку на слайды Вот кому надо можете скачать отлично погнали с вопросами друзья прошу Здравствуйте Роман Васин компания Арена дата мы вот как раз занимаемся тоже целым набором распределённых баз данных в том числе кликхаус я вот хотел спросить по шардирование например в кликхаус принят подход Ну как один из Common PR Когда в качестве ключа шарди выбирается случайная функция Random как бы вы делали какие-то бенчмарки как бы случайно записывать пользователей Ну клиентов Сбербанка по шардам либо Вот ваша как бы архитектура которую вы показали смотрите это немножко не те системы про которые я говорил значит Аната ну вс-таки честе этоже более то в сбе тоже принят но он не принят как система хранения данных он принят только как система обработки Вот то есть если нам во-первых не нужно надёжно хранилище во-вторых нам не нужны точечные чтения Вот А нам нужны чтение всех данных сразу и агрегирование Вот то в этом случае конечно это хорошая практика Вот ноли нам эти данные нужно читать и желательно по ключу Ани все подряд то конечно нет да Владимир Спасибо за очень насыщенный доклад вопрос про кальвин машину как я понял блоки которые были нарисованы это партиции собственно баз данных а как в эту систему встраивается репликация Ну и построение реплик собственно построение реплик А в кальне Нет такого понятия как репликация То есть если М не хватает мощности на чтение вы просто-напросто добавляете ещ один блок и он точно также начинает выполнять те же самые транзакции то есть поскольку все как бы ну вся наша жизнь предопределена Богом то добавление лишнего Ну лишнего блока это предопределение не изменит будут теже самые реу ру данные между секвенсора репликации между блоками Нет спасибо Привет Спасибо за обширный доклад такой вопрос вроде бы ни для кого не секрет что в Яндек Cloud основная база данных - это в idb получается там не побоялись дать в руки обычному разработчику такую распределенную сложную базу Ну получается так да даже зацепились как-то с коллегами из Яндекса Я им говорю что не надо Ну так давайте я сделаю оговорку что в зале сидят высококвалифицированные профессионалы Вот Но это как бы верхушка сообщества вот а вот обезьянам гранату давать я бы не стал при том что граната прекрасный инструмент в некоторых местах коллеги из Яндекса считают по-другому Ну как бы Пусть расцветают 100 цветов Почему ничего не было сказано о механизме вал архивов и их репликации cdc на основе коротких временных задержек вот оно так я не до конца Понял Вопрос но наверное речь идёт о том классе решений о которых я говорил в самом начале это кластеризация монолитной база когда мы из одного постгрес делаем там допустим 10 постгрес сов из которых девять являются репликами вот ну просто это не тема сегодняшнего доклада Добрый день Андрей Сбер такой вопрос а трёхфазный комит Ты считаешь это как это подмножеством и модификацией двухфазного или он не применяется Ну по сути да это как бы я прошу прощения за грубое слово как-то презерватив натянуть на свечку а потом ещё и второй вот ну насколько я знаю на практике Он нигде не применяется Ну просто потому что это долго даже двухфазный долго а уж трёхфазный совсем долго Спасибо Здравствуйте а Владимир Большое спасибо за доклад интересный у меня по хореографии Вопрос вот а кавка по сути является шиной Ну это брокер сообщения О каком оркестратор не оркестрация не Нет смотрите У нас есть оркестратор который даёт команды каждому участнику то есть схема централизованная давайте я ещё раз этот слайд найду ВиДи сок кода - это самый настоящий оркестратор вот а кавка она используется как база данных для сохранения состояния оркестратор То есть если вдруг оркестратор упадёт то те Саги которые были запущены их же надо как-то там перезапустить закончить Вот и в это состояние откуда-то надо восстановить вот оно восстанавливается из таблиц кака Поня Спасибо но в этом случае Нет ли такой альтернативного решения что если мы используем Оке А хореографию то каждый участник транзакции если не смог завершить у себя делает отправляет сообщение в каку на компенсацию чтобы остальные участники могли откатиться такое решение рассматривается Ну альтернатива такая есть Вот Но вот я против такой альтернативы Потому что всегда должно быть какое-то одно место в котором можно посмотреть текущее состояние и сде какието выводы достаточно сложно понять то ли один участник не успел отправить там сообщение то ли другой его не прочитал то ли не правильно понял вот ну в общем в финансовых системах я бы не стал такое делать Вот Но с другой стороны если речь там о каких-нибудь маркетинговых инициативах типа того что человек там Подошёл к банкомату и я в кафку кинул сообщение значит если у вас есть что ему сказать там что-нибудь ему Продайте В таких ситуациях да Угу спасибо Александр интересуется в двухфазном коммите как реализуется откат в случае когда узлы готовы сделать комит И один из участников не применил комит по той или иной причине например отвалилась сеть Ну как по-разному я как раз рассказывал то есть если стадия подготовки прошла то транзакция успешно завершается в любом случае вот ну то есть либо кто-то подхватывает данные вот этого отказавшегося смириться Да второй вопрос вроде в последнее время было довольно много новых протоколов например слог или деток и Они вроде бы ломают несколько ту классификацию которая была на слайде Как делать расе транзакции наверно Нет давайте вы ко мне подойдите Я хотя бы запишу ключевые слова и погуглю спасибо и финальный вопрос Здравствуйте спасибо за доклад очень интересно познавательно Но заявление о том что финансовы как бы хореография финансовых системах неприменима что всё что вы рассказывали и все эти значит распределённые системы они вообще-то не про скорость вот а м есть целый класс финансовых организаций где скорость самое главное вообще что может быть это Например биржевые системы Вот И там хореография Практически везде по крайней мере на российских площадках везде на Московской бирже на бирже санкт-петербург и так далее Спасибо Ну смотрите тут Надо разбираться в каких ситуациях она применяется Я же сказал что и в Сбере хореография Вполне может применяться но не там где изменяются остатки на счетах спасибо Ну и вишенка на торте автор книги автору книги пожалуйста У меня вопрос вот а как решается в саге Ну и в предыдущих тоже та проблема надежности диска Потому что если один р набором клиентов вылетел то мы же его потеряли или вот нет Ну на самом деле каждый шарт он защищён то есть там во-первых у нас два кластера кубернетес То есть если один кластер отказал то на другом бизнес логика продолжает работать ну и са база данных евен то есть там синхронная репликация и данные не теряются Вот кстати ещ вот не совсем по теме доклада но хороший вопрос у нас применяется два кольца защиты то есть смотрите Ну вы понимаете да Что одновременно обеспечить нулевую потерю данных и нулевое время восстановления невозможно надо выбрать что-то одно система Вот про которые я говорю там значит синхронная репликация там ну естественно возможны отказы Вот и переключение занимает какое-то время Вот но мы не можем потерять данные А есть фронтальная система которая постоянно общается с клиентом и которая в какой-то момент может сказать Упс вот вы ввели тут заявку введите её пожалуйста ещё раз я вашу заявку потеряла вот Вот то есть во фронтальных системах мы не теряем контакт с пользователем но можем потерять данные вот ну и благодаря вот так двум кольцам защиты у нас получается непрерывный сервис Ну асинхронная репликация означает что мы фактически там внутри под капотом двухфазная синх двухфазная это или что-то ещё потому что мастер узел ждёт пока передастся на второй ну или кто-то там вот внутри это делает чтобы запись гарантировать на оба узла или нет правильно мастер ждёт но она не двухфазная то есть ну он по-другому ждёт не Нет это одна фаза то есть мастер туда записал Ему сказали Всё я принял Вот и второй фазы Нет ну а он Том Должен себе тоже записать на диск ну себе на диск Ну да это как бы параллельными процессами запис Ну понятно Угу Спасибо друзья Владимир теперь надо определить у нас есть три сувенира махни пожалуйста рукой все кто задавал вопросы первый - это коллекционная матрёшка хайлоу которую надо за вклад в сообщество отдать вот чей вопрос максимально полезен Всем был Ну вот наверное вопрос последний вопрос Максиму Да Максим к тебе уходит матрёшка и ещё у нас есть два сувенира книжка и от и сувенир от MTS Digital вот так давайте сувенир от MTS Digital вот коллеги из Сбербанка больше МТВ в твоей жизнь так вот а книжку а книжка уходит с Коллеги с которым мы так долго спорили Я думаю ещё мы поспорим в кулуарах Ага это вот молодому человеку в синем да отлично И тебе тоже памятный приз от конференции Спасибо большое за подготовку за доклад за ответы"
}