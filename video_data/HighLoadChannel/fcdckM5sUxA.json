{
  "video_id": "fcdckM5sUxA",
  "channel": "HighLoadChannel",
  "title": "Менеджер транзакций в GoLang / Илья Сергунин (Авито)",
  "views": 5406,
  "duration": 920,
  "published": "2023-12-20T00:53:39-08:00",
  "text": "Здравствуйте коллеги я сергунин Илья из компании Авита работаю в продуктовой команде которая делает трейн телефонов на го го зарекомендовал себя в различных областях в частности мы его используем в микросервисах для веб-разработки Однако Уго особенные отношения с бизнес логикой из-за специфики работы с ошибками и ли передавать на уровень выше в отличие от исключений которые спокойно меняют поток выполнения программы Далее в презентации обработка ошибок будет скрыта со слайда также Уго ограниченный ооп в частности в области наследования также отсутствует Протек метод модификации доступа и собственное понимание интерфейсов следуя специфика заключается в том что язы молон в начале этого года и также отсутствует Готовое решение для множества задач и нельзя просто взять и перенести из одного языка паттерны в наш язык го а в частности сегодня мы поговорим о паттерне репозиторий который сопоставляет данные нашей модели с представлением в базе данных по умолчанию он его интерфейс очень прост метод для получения и для сохранения хочется чтобы он всегда оставался идеальным и таким же простым перейдём реально примеру предположим У нас есть пользователь у него есть следующий репозиторий с методом для получения нашего пользователя и для сохранения Всё достаточно просто далее мы создаём сценарий в котором пользователь у нас регистрируется добавляем валидацию и само сохранение Всё достаточно просто далее к нам приходит бизнес и говорит что он хочет уведомлять нашего пользователя о том что он зарегистрировался в вроде бы Однако очередь может упасть и в данном случае пользователь будет зарегистрирован но уведомление до него не дойдёт хотелось бы этого избежать Давайте добавим транзакцию кажется не так много строчек Однако нам нужно явно передавать транзакцию в наш репозиторий также мы усложняем внутренности сохранения в нашем репозитории ему нужно знать о том что существует транзакция и наш репозиторий немножко изменяет свой интерфейс Да мы получили транзакционный но потеряли наш идеальный репозиторий Но небольшая Беда с этим можно жить а далее бизнес нам приходит и говорит Я хочу позволить нашему пользователю делать заказы мы говорим не проблема создаём репозиторий делаем сценарий предусматривая заранее что всё работает с транзакции и явно передаём в репозиторий и в очередь нашу транзакцию но бизнес у нас неугомонный ись покупку в один клик мы делаем набросок понимаем что всё Опять же нужно опять завернуть в транзакцию готовимся к этому и делаем явно передаём транзакцию и тут надо учесть что вложенные сценарии нужно модифицировать и из двух строчек у нас появляется всё больше и больше кода инфраструктуры в наших сценариях хочется этого избежать Да мы получили поддержку вложенных сценариев но получили дополнительного лишнего кода и также чем больше такого кода тем сложнее перейти на другую базу данных хотелось бы это избежать и Давайте попробуем добавим замыкание в наш репозиторий а вроде бы хорошо мы скрыли работу в транзакции в одном месте Но наш пользовательский репозиторий начинает знать о заказах нужно ли ему об этом знать совершенно нет потому что чем больше моделей тем более сложные сценарии и тем больше таких методов у нас будет в юзер репозитории И тем самым р репозиторий потеряет свою изначальную функцию Поэтому данное решение нам не подходит Давайте перенесём замыкание на уровень выше в отдельную функцию назовём её Vis transaction далее наши сценарии похудеют и мы сможем видеть уже сам замысел этого сценария а не инфраструктуру вроде бы хорошо далее можно попытаться Поша манить с рефлексией и посмотреть что из этого получится мы передаём нашу функцию со сценарием из неё получаем все нужные нам репозитории потом подготавливаем саму функцию и обогащаем репозиторий транзакции и вызываем её в итоге наш код немножко изменился мы переставили передавать в одном месте транзакцию кажется что потери производительности от рефлексии не окупают себя от тех плюсов которые мы получили и это решение можно отбросить что у нас есть А посмотрим на наши хотелки мы поправили работу с транзакцией теперь она у нас скрыта но хотелось бы сделать наш репозиторий идеальным снова То есть убрать явную передачу транзакции попробуем это сделать через Фабричный метод который будет обогащать нашу наш репозитории транзакции в итоге мы немножко усложнили наш код и добавили возможность ошибки потому что нам нужно помнить о том что репозиторий нужно обогатить транзакции поэтому данный вариант нам не подходит тогда что же нам делать можно обратиться к опыту Яков и посмотреть как они решают проблему с хранением транзакции кто-то явно передаёт как аргумент транзакцию но нам бы хотелось от этого отказаться если язык работает в один поток то можно использовать глобальную переменную либо привязывать транзакцию к потоку кажется нам это может подойти но нужно учесть что рутины это не одно и тоже что и потоки Поэтому нам нужно модифицировать это решение Какие есть варианты в Где мы можем хранить транзакцию Первое - это передавать как аргумент но мы от этого отказываемся следующий вариант использовать для привязки транзакций рути нет AP который предоставляет язык плюс если использовать Хаки они могут сломаться при переезде на другую версию поэтому Давайте не использовать это решение следующее использовать Local Stage К сожалению они в большинстве основаны на Tin ID либо если использует другое решение то конкретно привязано под определённую версию поэтому данный вариант тоже нам не подойдёт и последней у нас остатся пакет контекст А пакет контекст внутри устроен как список и значит у него сложность поиска оан поэтому кажется идеального решения у нас нет И нам придётся как-то изворачиваться но есть легальное решение - это пакет контекст он никуда не уйдёт из языка и не потеряет возможность работы при переезде на новую версию поэтому остановимся на нём Давайте посмотрим на наши хотелки Какие из них закрыты какие нет вспомним что у нас уже есть И что мы понимаем нужно для нашего решения это и хранилище нашей транзакции далее начнём мапить наше решение на наше хотелки что закрывает уже часть потребностей Давайте расширим рак до менеджера транзакции который будет иметь интерфейс с возможностью до настройки текущей транзакции чают некоторые параметры которые соответствуют различным базам данных но также эти настройки можно расширить для конкретной базы данных у которой есть определённые опции которых нету других и в итоге наш сценарий который раньше имел очень большой кусок инфраструктуры уменьшится и станет более легче его станет легче читать а также поменяется и создание заказа и покупка в один клик она станет Короче если же хочется убрать вообще работу с транзакцией из сценария это можно легко сделать из паттерн декоратор конечно хотелось бы сделать чтобы можно было использовать аннотации как в других языках но го это не поддерживает а решение с динамическими прокси которые есть на го являются нестабильными и не развиватся хранилище для транзакции оно нам позволит сделать репозитории идеальны посмотрим мы введём следующий интерфейс для хранилище транзакции чтобы можно было из контекста получить нашу транзакцию по ключу или ключу по умолчанию Зачем нам нужно получать по отдельному ключу потому что у нас может быть несколько подключений к разным база данных и там нужны транзакции В итоге наш репозиторий с данного вида похудеет и будет выглядеть так кажется что проще читать и меньше кода далее Хотелось бы чтобы наше решение легко мигрировало с одной базы данных на другую Для этого нам нужно сделать абстракцию над транзакции она будет выглядеть следующим образом По факту это компиляция которая взята частично из Spring в Java и System Trans из C и в итоге мы нам нужно е модифицировать хранилище для транзакции чтобы ть с абстрактной транзакции и сделать локальные транзакции для локальный менеджер транзакций для отдельного драйвера либо О В итоге мы прокрасить Но какой ценой что нам пришлось отдать жертву Давайте посмотрим решение работает только на го 1 версии и выше кото вышло в 2019 году что не так давно но преимуществом го является то что обновление чаще всего происходит минорные версиями и до тринадцатой версии можно достаточно легко обновиться далее пока что существует не так много адаптеров для драйверов и баз данных либо м Но примерно 60 строчек кода и вы можете Дописать свой для своей базы данных это небольшая проблема Давайте немного бенчмарка изначально я написал бенчмарк на SQL M который мы используем для тестирования в результате мы видим разрыв с и без менеджера транзакции около 35% Однако меня удивили результаты которые были в миллисекундах что достаточно много поэтому бенчмарк я переписал с SQL M на SQL Lite в памяти в итоге получил следующий результаты разрыв увеличился до 18% в среднем и результат были в микросекундах что кажется уже реальным Однако более частотный кейс является когда база данных лежит в файле Давайте её туда и перенесём получилось что разрыв сократился почти до 0% это связано с большими издержками работы с файловой системой также дополнительно стоит учесть что существует кейс когда мы работаем с базы данных на отдельном выделенном сервере и у нас добавляются затраты сетевого взаимодействия Поэтому в большинстве реальных задач Можно пренебречь темер даёт решение потому что они значительно меньше затрат на работу с файловой системой или сетевыми вызовами далее нам теперь везде нужно таскать контекст Но если вы пишите веб-приложение на го скорее всего вы его уже используете потому что вы не хотите делать лишние вычисления когда пользователь запрос также возможно в нём хранить данные пользователя который был авторизован либо другие данные для логирования следующий минус и кажется он самый значительный решение не поддерживает Долгих транзакций То есть если у вас будет сетевой вызов к отдельному серверу для проверки по паспорту или по телефону Лучше это выносить из транзакции это можно полечить через паттерн Unit Однако это отдельная тема Давайте подытожим все недостатки и подумаем перекрывают ли они те плюсы которые даёт нам решение мы видим то что у нас была жёсткая привязка к конкретной базе данных и репозиторий сам об этом говорил Теперь в него передаётся контекст при том что надо учесть что чаще всего вы и так бы передавали этот контекст также мы изменили внутренность репозитория они стали меньше уменьшилось количество строчек кода и А следующий плюс то что сами сценарии которые например сейчас не умещаются даже на слайд Их можно увидеть потому что инфраструктурный код был убран из нашего решения с помощью нашего решения А теперь давайте посмотрим на график А в зависимости количества строчек кода от количества вложенных сценариев а при использовании менеджера транзакции у нас сразу добавляется по умолчанию около пяти строчек кода на инициализацию и на использование Поэтому если у вас ноль вложенных сценариев то можно пренебречь менеджером транзакции Однако при увеличении количества вложенных сценариев видно Как меняется количество строчек кода и примерно на двух вложенных сценариях уже можно задуматься О использовании менеджера транзакций дополнительно можно изменить этот график и добавить коэффициент который будет влиять на когнитивную нагрузку и на вероятность ошибки программистам потому что два этих показателя увеличиваются при количестве кода при этом шаблонного но решать конечно же вам использовать это решение или нет А на данном слайде Вы можете найти ссылку на решение она находится рядом с иконкой гитхаба далее идут ссылки на меня и на са презентацию Спасибо за внимание и ставьте лайк этому докладу Если не хотите задумываться о транзакциях и делать легко вложенные сценарии буду рад вашим вопросам также можем обсудить идиоматичность этого решения Как работать с долгими транзакциями и другие подходы которые позволяют удобно писать бизнес логику в го"
}