{
  "video_id": "hEC8CX8Drac",
  "channel": "HighLoadChannel",
  "title": "Как правильно выбирать очередь / Владимир Перепелица (Mail.Ru Group)",
  "views": 32554,
  "duration": 2718,
  "published": "2021-10-04T02:47:02-07:00",
  "text": "я сегодня начну с простой такой темы хорошая разминочка для утро понедельника для начала конференции как выбирать очередь я записан как владимир перепелица я больше известен как man сандерсон потому что так и везде подписан немного расскажу о себе может быть кто то не знает я почти 9 лет работы в mail.ru до этого я работал в рамблере и архитектор облако mail.ru mail.ru cloud solutions архитекторы products тарантула нашей платформы базы данных сервер приложений в общем много всего я очень люблю очереди я использую очереди с 2008 года я проникся этим паттерном я люблю реализовывать очереди конечно же на tarantul и это очень интересный инструмент для этого я люблю рассказывать про очереди несколько лет назад я подумал что надо бы рассказать про очереди я довольно много про них знаю вот я сам умею готовить я умею их выбирать надо рассказать о том как их выбирать первоначально я подумал что я возьму много разных очередей я их проверю и проверю их на разный перс предложу варианты сравнительные таблички много грузило вынос мозга потом потом я передумал во-первых потому что как обычно доклады готовятся в последний момент во вторых потому что гораздо важнее знать не перф перф может проверить каждый то есть вы просто берете свою собственную там инсталляцию берете выбираете одну штуку другую штуку третью штуку и как бы проверяете удовлетворяет она вам попер foo или нет в большинстве случаев вот поднимите пожалуйста руки тем у кого скажем так нагрузка по запросам по сообщениям по ещё чему-нибудь превышает 10 тысяч запросов в секунду вы можете оглянуться и посмотреть это довольно малый процент из большого зала холода то есть целом большинству этого достаточно большинству достаточно того что даст им любой брокер гораздо более важная вещь это то зачем вообще нужны очереди как они устроены и как они работают я расскажу несколько сценариев я буду говорить про то как они устроены про то какие вообще есть решение и мы сможем то есть вы можете всегда подойти ко мне и поговорить еще про очереди значит очереди нужны для распределения задач на пример простейшей сценарий у нас есть 3 сервера один помощнее один послабее и один вообще не работает у нас есть входящая какая то нагрузка если мы возьмем классическую балансировку которая равномерно распределяет нагрузки на эти сервера мы получим следующую картину тот кто послабее он будет перегружен тот кто посильнее он будет не до кружим и какая-то часть запросов будет еще и фэй лица если мы вместо классической балансировки поставим очередь мы будем входящие запросы складывать в очередь и те сервера которые работают будут забирать это в качестве задач на обработку тот кто мощнее будет забирать больше задач потому что он мощнее он успевает их обрабатывать тот кто послабее будет брать меньше но это обеспечивает самое честное самое качественное распределение задач значит далее очереди часто используется для планирования исполнения например у нас классическая синусоида или еще какой-нибудь график волнообразно когда у нас в один момент нагрузка большая в другой поменьше для того чтобы обслуживать такую нагрузку нам нужно иметь железо для обслуживания пика нагрузки то есть остальное время когда у нас ночью там лив не аудиторный час нагрузка снижается мы не до используем ресурсы то есть мы могли бы снизить количество ресурсов которые мы предоставляем откладывая те задачи которые превышают наш оптимум то есть мы можем поставить меньше же я за когда мы не успеваем обрабатывать задачи мы складываем их в очередь и а не разгибаются позже когда ресурсы появляются то есть целом очереди это про например честность выделение ресурсов очередные можно реплицировать какие-либо данные при помощи очередей обеспечивается отказоустойчивость надежность передачи гарантия того что сообщение будет доставлено также очереди используется в качестве инструмента для коммуникации микро сервисов это породило несколько архитектура есть событийная архитектура есть потоковой архитектура она же streaming и это все как бы показывает нам что очередей очень много и они применяются довольно часто если посмотреть где очереди применяются то их можно найти на железном уровне то есть наше оборудование использует у себя внутри принципы очередей очереди есть в операционной системе то есть это всякие и пол как и у всех буфера сигналы если подниматься выше очереди есть в приложениях в приложениях у нас есть общение между разными трендами между разными процессами между разными процессами на разных постах то есть мы переходим уже к сетевым взаимодействием то есть в целом распределенные системы очень часто используют очереди в целом даже когда у вас есть построенная система она может использовать в очереди или не использовать на очереди часто используют для того чтобы состыковать разные бизнесы например два банка два разных банка они между собой общаются при помощи очередей то есть они передают одни транзакции в другой банк при помощи очереди фактически можно сказать что очереди применяются везде вот вы можете взять любой слой своей системы ткнуть туда и найти там очередь в том или ином виде очереди это своего рода клей между различными уровнями системы значит что такое очередь это средство для коммуникаций коммуникация в очередях происходит при помощи сообщений то есть мы берем сообщение мы кладем это сообщение в очередь и кто-то другой его может оттуда достать это простейшие определение очереди на низком уровне на уровне структур но в распределенных системах мы идем дальше есть разные подходы то есть есть подход когда мы очередь кладем задачу один раз и один раз ее оттуда забираем это подход пут и тейк то есть вот по названию методов которые это делают есть продюсеры которые кладут задачу в эту очередь есть консьюмер и которые приходят берут задачу могут обработать и тогда она выбрасывается то есть она считается обработанная либо они могут не успешно ее обработать и вернуть обратно есть подход который называется publish субскрайб или попса это подход когда продюсер доставляет сообщение один раз и на эту задачу может быть подписано разное количество концу меров бывает много сценариев бывает так что задача доставляется если концу миров нет она уничтожается бывает так что они там лежат и консьюмер и могут многократно эту задачу обрабатывать но так или иначе в отличие от первого подхода это один ко многим продюсер публикует задачу и у нас может быть много концу меров которые эту задачу могут взять и обработать есть еще подход в очередях он изредка встречается request a response вот тот самый классический request response как мы делаем серверах только в этом случае это делается при помощи сообщений мы отправляем сообщения request он где-то процессе ца концу мир отправляет сообщение обратно который является респон сам очередей бывает очень много протоколов то есть за все время существования данной темы есть протоколы mtp advanced message queuing протокол mqtt применяющийся в оборудовании 100 мб на дзиро intel то есть с этими словами можно столкнуться вот просто начал искать про очереди я немного скажу что это такое и в каком случае что применяется какие у нас есть варианты если мы хотим взять и попробовать очередь вот хорошо я вас убедил вы до этого не пробовали очереди что довольно странно решили попробовать вы можете попробовать облачные решения то есть на сегодняшний день очень много различных облаков и вы можете взять амазонов сказки смыл ручной вязки с яндекса в москве с в общем иск весов очень много иск весит a simple киу протокол простая реализация которая позволяет пользоваться облаком как очередью то есть точнее очередью в облаке помимо облачных решений существуют специализированные брокеры то есть те продукты которые вот как есть базы данных для хранения данных и есть брокеры для очередей то есть они были изначально придуман и чтобы быть очереди наверное самый популярный продукт здесь это ребятенка также я хочу отметить кафку есть много разных других продуктов которые можно для этих задач использовать в конце концов если вам не нравится что-то готовое или вы хотите какой-то кастом вы можете взять базу данных и с его помощью приготовить очередь на этом пути есть много подводных камней поэтому тут нужно подходить с умом понимать что вы делаете но тем не менее если посмотреть в устройство очереди то можно увидеть что там очень много подходов которые похожи на базу данных ну есть еще класс очередей которые очень часто называют сокетами на стероидах первым был же рынке а позже появился над который вырос в общем-то в полноценный брокер но изначально это были сокеты на стероидах они ничего не хранят они просто дают некоторый интерфейс взаимодействия то есть с точки зрения там одного узла он может поближе сообщение с точки зрения другого узла он может subscribe to на сообщение но это просто небольшая настройка над сокетами значит давайте пройдемся по кандидатам которые стоит на сегодняшний день рассматривать если вы хотите воспользоваться очередные apache кафка популярный продукт на сегодняшний день вот они конкурируют с ребятам очень часто то есть можно вот если вы слышите про очереди вы услышать либо про кафку либо про rabbit кафка это распределенный лог-сообщение то есть основное назначение этой очереди для стриминга второе место это ребятенка это традиционный брокер очередей с поддержкой протокола mtp и он очень часто используется на третьем месте облака облаков много резки вес или облачные мкпп если вы уже размещены в облаке вам будет проще всего подключить именно облачную очередь еще я хочу упомянуть над довольно молодой про проект который скажем так вырос из сокетов на стероидах сначала без всякой пирсе стен пасти рассчитаны на масштабирование это хороший инструмент для соединения микро сервисов между собой когда вы побили свой монолит которую я надеюсь вы не вы его не писали вы сразу его заранее разбили вы можете воспользоваться нациям для коммуникации между узлами ну и конечно же я не могу не упомянуть тарантул я очень люблю делать очереди на таран туле тарантул дает возможность создавать абсолютно любые продукты поверх данных в частности очереди то есть все очереди которые я использовал за последние несколько лет были на tarantul и потому что это удобно да это требует некоторого вложения времени то есть мне нужно было реализовать зато я получал ровно ту очередь которая мне была нужна и так пройдемся по конкурентам между собой apache кафка реплицирует некоторый log то есть а на пирсе стець сообщения на диск то есть мы организуем messaging по принципу publish субскрайб эти сообщения записываются в один лак кафка рассчитана на то что этот лук может быть повторно проигран и этот лог не может быть изменен то есть в отличие от классических брокеров лог кафки неизменен то есть если вы записали сообщение в каком-то порядке они не могут поменяться отсюда у нас появляется строгая упорядоченность кафка дизайне лась на ограниченное количество консилеров то есть на одном логе то есть на 1 партиций может быть строго 1 концу мир из одной консьюмер группы в противовес очередям сообщения могут перри проигрываться то есть если вы там вашей системе что-то испортили то есть какая-то часть сообщений было обработано некорректно вы можете перемотать этот logo проиграть его заново после обработки сообщений они удаляются кафка прекрасно интегрируется со всей к системой apache и очень часто используется для анализа данных для процессинга для передачи для репликации то есть и собственно мне кажется именно кафка породила по термин стриминга в кафки сложно делать традиционные для обычных брокеров очередей истории типа роутинга у нее довольно сложная архитектура то есть ее просто так на одном узле долго поднимать ей нужен пер но при этом оно хорошо горизонтально масштабируется она дизайне лась именно для этого rabbit создавался как брокер очередей с протоколом mtp с подходами мкп то есть позже к нему были прикручены альтернативные механизмы такие как include отеле столб это такие более древние протоколы или более привязанные к железу в ней есть очень много всего то есть в ней есть приоритеты в ней можно создавать athlon ii отложенные сообщения то есть фоновые то есть можно взять задачу отложить ее обратно чего нельзя сделать в кафки в ней нет к ограничение на количество потребителей то есть к одной очереди вы можете подключить любое количество потребителей и они будут быстрее разгребать эти сообщения в кафки не так rabbit умеет хранить данные в памяти и на диске может реплицировать данные может даже использовать кворум на и очередь использовать кворум для сохранения сообщений ребят довольно простой в освоении то есть я думаю вы с легкостью его поднимите но у него есть нюансы он давольно сложный в настройки отказоустойчивых сценариев то есть если у вас есть необходимость настроить очень надежно и гарантированное хранилище вы задал боитесь то есть нет вы справитесь с этим можно справиться но в целом rabbit сложный когда вам нужна надежная распределенная система сценарии это традиционный попса брокер то есть он часто используется в качестве слоя шины данных между разными микро сервисами если говорить про облака здесь провайдер облака берет на себя все задачи то есть оно полностью managed вам не нужно ничего поднимать ничего настраивать ничего мониторить это все делает за вас облака то есть вы просто туда кладете сообщение если вам нужно больше вы просто платите за это больше она очень хорошо подходит когда у вас малое количество сообщений потому что вам не нужно ставить лишний сервера вы платите за очень малое количество и squares стандартизованной а api вы не привязывайтесь какому-то конкретному брокеру туз сегодня вы можете работать на амазоне завтра вы можете работать в мае ручном облаке после завтра в яндекса вам и потом обратно это хорошее связующее звено если вы пользуетесь с облачными сервисами такими как из 3 или лямда то есть там вам иногда бывает нужно куда-то кинуть сообщение из одной системы в другую то есть и вот там используется из квест нас изначально родился как система для передачи сообщений его целью была высокая производительность и практически линейная масштабируемость он был заточен под любые сценарием и по цап и путей к и request response но впоследствии на нем появился движок стриминговый jet stream в котором есть уже и потоковая обработка и надежное хранение ира второй кластер то есть в целом нас вырос в довольно таки хороший брокер сообщений в целом используется для распределенных систем в качестве шины между микро сервисами написан нога лонги де плавится довольно просто в целом вполне можно рекомендовать ну и тарантул в нем есть готовый брокер который можно просто взять поставите использовать втором туре есть интеграция с различными стриминга выми очередями то есть тарантул можно например подключить кафки сторонку ли есть модули для построения собственных очередей если вам нужен кастом то есть если вы смотрите на сценарии они вам не подходят они вас не устраивают вы можете спокойно взять тарантул и написать свою собственную очередь с кастомным процессингом с кастомными приоритетами с любыми с любыми зависимостями в рамках одного брокера то есть одного узла исполнения у нас есть транзакционных например если мы возьмем кафку в кафки нельзя взять из одной очереди закинуть в другую то есть если у нас внешний консьюмер в tarantul и мы можем объединить это в одну транзакцию поскольку внутри вот там на глубоком уровне он хорошая транс акционная база данных с огромной репликацией когда его можно использовать когда вы готовы разобраться в том как работает ваша очередь когда вам нужен производительный брокер в целом мы тестировали пропускную способность различных брокеров и на таран туле нам удавалось развить самую большую скорость несмотря на то что лидером в данном вопросе является на сегодняшний день кафка тем не менее на таран туле можно больше но для этого нужно приложить некоторые усилия ну и в целом если мы хотим что-то большое и сложное значит мы рассмотрели основных скажем так конкурентов давайте посмотрим на очереди а какие вообще с очередные проблемы но взяли поставили работает почему нет здесь есть целый спектр проблем эти проблемы многослойные той первый слой проблем это алгоритмы даже когда все работает ничего не ломается алгоритмы очереди может быть заложена очень много хорошего или плохого во первых очереди бывают число как я уже говорил строгая упорядоченность сообщений бывает ли for last in first out это стык по сути встречается крайне редко но тем не менее может быть нужно для каких-то задач чаще всего встречается очередь которую там так или иначе называют best of art она в основном фифа но иногда когда например у нас происходит отказ какого-нибудь концу мира который уже взял сообщение сообщение возвращается обратно и они перри упорядочиваются для большинства задач это подходит то есть это нормально и скажем так это позволяет с очередным работать намного проще то есть если вдруг у вас какой-то консьюмер в обработке задачи залив или там она выполняется долго он не тормозит вам остальную очередь дальше в очередях бывает нужно приоритезация то есть например в той же кафки приоритизации нет потому что ее не может быть каждое сообщение дописывается в конец топика то есть вы не можете скажем так прислать сообщение которое не ляжет в конец топика или как-то их между собой перри упорядочивать вот они как пришли так они будут лежать иногда бывает нужно в рамках большой системы организовать огромное количество маленьких очередей например по одной очереди на одного клиента дальше повтор отложенные задачи различные ретро и задержки то есть если это полноценный брокер у вас это все будет если это у вас брокер на заточена на streaming у вас будет проблема с тем чтобы реаль заводь повтор то есть повтор можно реализовать новые на самом деле задачу вы мити из очереди и положите ее заново для того чтобы организовывать повтор или постобработку используется так называемая diddley торчу в целом это инструмент который появился из-за того что в некоторых брокеров нельзя вернуть задачу обратно то есть нельзя ее положить это такой механизм который позволяет куда-нибудь откладывать задачи которые мы не обработали еще бывают созависимые задачи еще бывают проблемы с временем то есть time to lev time to release footbag то есть если кто то взял задачу то через какое-то время мы можем посчитать что этот кто-то этот концу мир умер и мы возвращаем задачу обратно из всех этих алгоритмических вещей вылезают еще очередные проблемы то есть если у нас есть приоритезация то у нас возможно например голодание допустим есть два потока сообщений одни с высоким приоритетом другие с низким если поток сообщений с высоким приоритетом достаточно чтобы загрузить концу миром то задачи с низким приоритетом могут вообще никогда не добраться до консьюмер а то есть у нас будет голодания у нас может быть ограничено очередь по пропускной способности то есть принципе система за дизайне на так что у нее есть узкое место которое никак не масштабируется конечно же алгоритм может влиять на перфоманс то есть если у нас там условно говоря линейная запись на диск это один перс если у нас рандомно доступ к диску это другой перф очередь должна учитывать или не учитывать возможности масштабирования то есть если это сингл узел возможно с репликации у него нет никакого горизонтального масштабирования и если вы стукнете со потолок у вас будут проблемы любая очередь ограничено просто потому что наш физический мир ограничен у нас нет бесконечных хранились бесконечной памяти бесконечного диска поэтому нужно всегда смотреть как очередь себя ведет как а она заканчивается еще алгоритм может учитывать такую вещь как сохранность сообщений но это скорее больше темы для алтай ja даже когда все работает у очередей есть одна очевидная проблема то есть очереди изначально придумывались вот на уровне железо на уровне софта когда никаких потерь нет когда вот процесс работает и внутри этого процесса что-то происходит мы сообщение достали сообщение положили случае сети у нас есть undefined by heather то есть мы отправили пакет и мы не знаем этот пакет дошел и его там получили или этот пакет потерялся то есть это классическая проблема двух генералов то есть если кто то не знает оно состоит в том давайте так кто не знает проблемы двух генералов значит суть в том есть две части одной армии между ними есть вражеская территория генералы должны договориться им нужно одновременно атаковать или одновременно не атаковать если кто-то один нападет а другой не нападет эта армия проиграет что они могут делать они могут посылать сообщения друг другу то есть гонцов и это проблема не имеет алгоритмического решение сколько раз мы бы не пытались один генерал отправляет гонца ему нужно подтверждение с той стороны что этот конец дошел но гонец подтверждением тоже может потеряться его могут перехватить то есть можно отправить десяток гонцов то есть можно увеличивать как бы этот поток но стопроцентной гарантии что вот они договорились не существует в целом можно сказать что в распределенных системах есть две сложные проблемы это строгий порядок сообщений и доставка строго один раз вот доставка строго один раз как раз является частным случаем вот этой проблемы двух генералов до недавнего времени вот несмотря на весь опыт я считал что exactly one или доставки строго один раз не существует просто потому что она невозможна в нашем физическом мире но я столкнулся с системой в которой и где клеманс был реализован есть одна система из нее поступают сообщения есть консьюмер который как-то коммуницирует с другой стороной и вот задача в том чтобы сообщение было обработано строго один раз что происходит если возникает неопределенность например мы сообщения отправили и непонятно оно дошло или не дошло или соединение порвалась это сообщение кладется в так называемую digit.ru вот для этих сообщений которые лежат в две дырки нужно принять решение для этого нужно уметь посмотреть вот в ту удаленную систему и решение оказалось очень простым человек человек который сидит смотрит в эту очередь который разгребает эти сообщения которые может скажем так посмотреть в одну систему в другую в логе позвонить на ту сторону то есть человек это своего рода божественная сущность вот если у нас есть эти два генерала вот для них вот мир он там плоские они между собой общаются есть кто-то кто находится над ними кто видит что происходит и может принять решение так вы двое договорились все вы нападаете в исходном решение системы такое не предусмотрено но в реальности когда нам это очень нужно мы можем прибегнуть к такому подходу пойдем дальше помимо сети у нас есть еще диск и сеть и диск влияют на производительность это пропускная способность сколько сообщений может проходить через очередь и это задержка в работе в зависимости от того что используется у нас может она быть предсказуемо и или непредсказуемая ну и напоследок мы приходим к ситуации когда у нас что-то не работает то есть все те кейсы были для системы которая работает работает штатно в ней ничего не сломалось но на самом деле у нас бывают поломки поломки бывают временные бывают постоянные вообще если спросить кого-нибудь что ты сделаешь для того чтобы обеспечить сохранность и сохранность сообщения сохранность базы данных можно очень часто услышать поставлю rate но на самом деле это спасает только от одного самого нижнего случая когда у нас вылетает один диск но у нас может вылететь целый host лично на моей практике был сценарий когда машина с шестнадцатью дисками получила разряд посетим блок питания и не защитил сгорели все кроме двух дисков то есть вот просто напрочь то есть даже если бы там был рейд rate бы не спас то есть машина может выгореть целиком целиком может выгореть даже дата-центр то есть вот всегда нужно планировать масштаб отказа что отказать может даже дата-центр отказы бывают временные например у нас пропала питания у нас порвалась сети и там переехали каким-то экскаватором и это приводит например то есть если порвала сеть приводит к сплит brain у две разные части системы одновременно живые но они об этом не знают они не мог договориться и отказ бывает постоянный это физическое уничтожение то есть это сгоревший диск это сгоревший сервер это сгоревший дата-центр в принципе считается что дата-центр ну не должен сгореть но иногда они горят значит отказы влияют на две основные метрики в нашей системе это доступность и надежность доступность это возможность сохранить систему сообщения то есть доступность важно для продюсера надежность это то что если мы сообщили кому-нибудь что мы сообщение сохранили но мы не должны его после этого потерять то есть мы гарантируем что мы сообщения обработали и мы его доставим давайте рассмотрим разные паттерн и вот как можно организовать надежность и доступность в распределенной среде если у нас есть брокер очередей самый простой подход самый простой самый наивный к сожалению чаще всего использующийся мы просто берем один брокер ставим ему говорим вот это у нас очередь у нас распределенная система у нас вот здесь продюсеры вот здесь консьюмер и все хорошо у этой системы есть куча проблем во первых у неё нет масштабируемости когда брокер закончится все ваша система перестанет принимать сообщения во вторых у этой системой довольно низкая доступности низкая надежность потому что если эта штука сломается вот совсем вы потеряете сообщение которое вы туда сложили даже если оно сломается временном там не знаю сервер в ребут ушел у вас низкая доступность вы не можете туда положить сообщение поэтому эту систему можно очень просто за апгрейдить то есть можно поставить несколько очередей и класть в любую из доступных у этой системы показатели намного лучше во-первых у нее высокая доступность если одна из очередей умерла у вас есть еще много других то есть вы можете варьировать эта система масштабируема то есть поскольку вы можете ставить столько очередей сколько вам нужно то есть это своего рода ручной sharding но у этой проблемы есть серьезный недостаток то сообщение которое вы положили в очередь принадлежит только этой одной очереди если эту машину уничтожить вместе с данными вы теряете данные поэтому гарантии этой системы все еще потенциально x меньше единицы то есть где мы сообщение можем не доставить проблемы можно решить несколькими способами например мы можем класть несколько очередей то есть просто дублировать в тупую в этом случае у нас получается высокая доступность высокая надежность ну кто-то из очередей то это сообщение довезет у нас нормальная масштабируемость то есть мы можем ставить н очередей и класть в к из них то есть к можно выбрать зависимости от того сколько мы хотим н в зависимости от того сколько мы на нам нужно здесь не очень удобно с доставкой сообщений потому что каждое сообщение будет доставляться в среднем к 1 и соответственно нужно делать либо и дым патентное сообщение либо что-нибудь как-то проверять что мы это сообщение уже применяли мы можем уйти в сторону и подумать о какие еще у нас системы страдают от подобных проблем вообще базы данных и мы можем воспользоваться подходами баз данных для того чтобы решить эту проблему можем воспользоваться репликацией мы берем лидер и лидера и говорим что мы будем работать с точки зрения продюсера и с точки зрения концу мира только с лидером реплики находятся в стендбай а они ждут если лидер пропадет они готовы принять на себя роль нового лидера и продолжить работу если мы вместо каждой из вот этой одиночных очередей поставим рипли кассеты мы придем к весьма неплохой системе то есть у нас будет хорошая масштабируемость ставим больше реплик ассетов получаем пропускную способность у нас весьма неплохие гарантии вот в такой системе execution одной задаче будет стремиться к единице то есть он никогда не упадет меньше единицы иногда случае обрывов соединений он может превысить единицу но в данной системе она будет около единицы ну и поскольку мы уже заговорили про базы данных мы можем взять к вор умные базы данных в принципе все то же самое только за выборы у нас отвечает не классическая репликация аквариумная репликация кворум защищает нас от потери данных то есть если мы прислали сообщение кворум его подтвердил то в общем она у нас надежно сохранилась кворум гарантирует довольно высокую консистентной нос кворум ными подходами у нас будет пониженная пропускная способность потому что узлу нужно будет обязательно подтвердить это сообщение иногда допускается вот такая ошибка то есть кто-нибудь берет color умный брокер ставит одну штуковину и такой вот у меня кластерная система она клёвая надежная она будет работать нет когда эту систему 1 parte циане рует то есть допустим у вас 2-го label эти зоны 2 дата-центра вырасти ну liquor умный механизм на несколько дата-центров вы получите пониженную доступность то есть у вас в той части где не хватило узлов которые оказались в меньшинстве вы не сможете производить сообщение вы не сможете их класть поэтому в случае портишь энинга ваша система проседает по доступности и скажем так вы испытываете проблемы также у этой системы есть проблема с масштабируемостью здесь нет ничего для линейной масштабируемости то есть у вас сообщение процессе один лидер реплики эти сообщения у себя держат подтверждают но здесь нет масштабируемости поэтому вспоминаем как мы делали с реплицировали my очередями то есть какой у нас был хороший подход и меняем здесь просто подход базы данных с обычной репликации на кого ровную репликацию получаем те же показатели это надежная очередь с хорошей масштабируемостью с высокой доступностью с высокими гарантиями если у нас более одного кворума нам нужно его грамотно распределить то есть нельзя просто как бы поставить абы как то есть мы должны рассмотреть ситуацию что если у нас есть две его label эти зоны то мы должны распределить узлы таким образом чтобы кворум одного кластера был в одной вал ability зла не кворум другого кластеров другое лал ability зоне при коммуникации с очередным есть два подхода вот в принципе там можно крутить эти протоколы там с одной стороны с другой но по сути все сводится к двум подходом задача привязывается к соединению или задача не привязывается к соединению то есть соединение не имеет состояние если задача трека ица в соединении мы имеем кучу профита то есть в случае если соединение порвалась мы можем тут же задачу вернуть обратно на обработку но у него есть и минусы мы не можем эту систему легко масштабировать потому что нам нужно чтобы клиенты консьюмер и непосредственно работали с самим узлом очереди в противовес системой без постоянного соединения довольно легко масштабировать то есть мы все прекрасно знаем как масштабировать хоть и т.п. мы можем воспользоваться классической хотите пышной балансировкой типичной балансировкой но у этой системы обязательно нужно делать автовозврата сообщения потому что если кто-то придет через соединение без состояния скажет я взял задачу задача зарезервировались за каким-то концу миром и все он упал и он больше не вернется и вообще его больше не существует вот эта задача залипнет навсегда если не сделать авто возврат в системах тип с авто возврат сделан автоматически потому что без этого никуда ну и на последок про что ещё нужно подумать то есть если мы вводим себе в эксплуатацию какую-то новую систему нужно понимать как ее правильно мониторить основной показатель который нужно мониторить на очереди это размер очереди поскольку я говорил любая очередь лимитировано даже если вы не выставили ей лимиты оно всё равно лимитировано и нормальное состояние очереди это пустое вы присылаете сообщение вы эти сообщения должны разгребать если очередь начала расти значит в вашей системе что-то пошло не так поэтому это первый показатель который нужно мониторить второй показатель это время она вам пригодится тогда когда ваша очередь начнет расти можно измерять полную обработку сообщения от момента когда вы положили до момента когда вы обработали и можно считать отдельно время консьюмер а то есть концу мир взял сообщение концу мир вернул сообщение что он его обработал в разных ситуациях тот зависимости от внешних факторов или от внутренних факторов вот это время покажет вам где у вас проблемы также поскольку и размер очереди и время это показатель моментальные то есть вы пришли посмотрели очередь пустая через некоторое время еще пришли посмотрели очередь пустая но при этом через эту очередь за единицу времени могло пройти 1000 сообщений или 10000 в этом случае вы как бы в какой-то момент обнаружите что ой у нас очередь начала расти а почему она начала расти не понятно поэтому нужно еще обязательно мониторить такие проблемные вещи как количество повторов потерь отказов и поток сообщений то есть в этом случае вы будете понимать что с вашей очередью происходит помимо критичных показателей ну и такой совет лагер уйти сообщение вот там где вы кладете сообщение в очередь если вы можете его залакировать но за лагер уйти но будет немножко лишних логов но случае если у вас произойдет авария если вы что-то потеряете лучше доставать игре под сообщения из логов чем обнаружить себя в ситуации что сообщений нет ну и обязательно планируете отказ система упадет обязательно упадет от вас зависит как именно она упадет и как именно вы будете подниматься можно переставать принимать новые сообщения если все если все сообщения важны переставайте принимать новые если вдруг старые сообщения не важны можете начать уничтожать старые то есть но принимать новые иногда бывают сценарии что в вашей очереди часть сообщений еще живая часть уже совсем старая то есть для них прошёл какой-то дедлайн можно обрабатывать те которые еще живы и и для них выполнить задачу а потом уже вернуться к тем которые все равно уже провалились для чего нужно планировать падение для того чтобы подняться после того как ваша система упадет если вы не знаете как ваша система падает и как поднимается вы можете свою систему не поднять есть изречение конфуция что велик тот кто поднимался после того как падал то есть поэтому очень важно знать как ваша система будет подниматься давайте подытожим какие у нас есть варианты и что нам брать вот вам нужно очередь если вы хотите толерантность сервиса точнее если у вас есть толерантность к потере сообщений то есть вы можете терять сообщение ничего страшного если одно-два на там миллион потеряется вам нужно организовать передачу сообщений между сервисами вам нужна высокая пропускная способность и масштабируемость возьмите нас это хорошая система она хорошо себя показывает можно взять еще какой-нибудь и носки у который похуже можно взять за рамки который вообще ничего не pure system но вот здесь мне больше всего нравится над он простой он хороший он развивается плюс у него есть эволюционная . для persistent а если вы хотите быстро попробовать вот услышали прониклись решили попробовать очереди если вы находитесь в облаке если у вас там микро сервисы кубер нить из вот это все возьмите облачную же очередь возьмите sqs от любого провайдера в котором вы поститесь возьмите с если даже вам хочется mtp и вы считаете что вот только ребят есть облачные решения для mtb например клауда mtp облачный ребят но и в целом можно попробовать простые брокеры то есть для того чтобы пощупать эти самые очереди rabbit над но обязательно смотрите на то как ваша система настроена вот все то что я рассказывал то есть если вы этот узел потеряете вы потеряете сообщение или нет смотрите за настройками если вам нужен streaming то есть у вас есть поток сообщений там вы его хотите обрабатывать перекладывать в биг дату если вам нужна высокая сохранность ваших сообщений и или например требуется строгий фифа это apache кафка кафка было за дизайне на под этот подход у нее есть различные подходы к организации обработки сообщений перри проигрыванию поэтому кафка здесь вне конкуренции также можно взять jet stream от нас или можно взять тарантул энтерпрайз там тоже есть механизмы для потоковой архитектуры если у вас сложные сценарии если вы хотите очередь в очередь сообщение класть а потом отложить а потом взять и вернуть или если вы хотите настроить сложный pipeline что у вас сообщение входят разделяются потом сливаются и вы хотите делать что-то сложной astra но если попроще это ребятенка если посложнее у вас есть тарантул кью или возможность при помощи тарантула построить любую произвольную конфигурацию очереди у меня все спасибо за внимание"
}