{
  "video_id": "nsapC5_xcZA",
  "channel": "HighLoadChannel",
  "title": "Хранение json-документов в Tarantool / Андрей Дроздов (Mail.ru Group)",
  "views": 1707,
  "duration": 1964,
  "published": "2017-04-22T14:48:15-07:00",
  "text": "чем я расскажу сначала я расскажу зачем нам понадобилось хранить же сон потом будет немножко теории и гарсиа нирования потому что это тоже одна из котором мы решали и потом расскажу кто используется в продакшене и в общем то самое главное это бенчмарки сравнении с другими фреймворка me в этом году их вышло аж 4 очень кая проблема была перед нами поставлена представьте что вы крупная компания вы существуете много-много лет вас огромное количество разных сервисов там каких то приложений запущена они все работают в разных интерфейсах и все создались в разное время разными людьми в общем огромный-огромный зоопарк все это как-то работает но спустя там десять лет или даже больше вы приходите к выводу что как то неплохо бы все это свести к одному и 5 при этом возможно какие-то и тени документированы вообще вот большая проблема это одна из проблем все это называется словом виртуализация данных в общем-то об этом пойдет речь в первую очередь предположим не все источники данных у вас имеют все нужные данные вы хотите от нам их как-то обогащать естественно это актуально для legacy проектов собственно о чем я говорил и возможно вы хотите как-то джонни данные с нескольких источников ну предположим что все данные джейсон кроме того вот это первый проблем что нужно все это объединить как это воедино сделать общее 5 помимо этого еще очень важно выдерживать большие нагрузки которые скорее всего не выдерживают те источники данных которым вас есть ну так сложился что мы хотим получить в итоге мы хотим получить некий черный ящик такой магический с которым будет общаться пользователь api будет строго одно для всех источников данных и при этом вот этот черный ящик будет как то данное доставать при этом так получиться что он в себе же будет это кэшировать и соответственно тем самым обеспечить высокую нагрузку в чем мы начали понятно что у нас есть тарантул он является базой данных и сервером приложений у нас есть engine кс который умеет работать с тарантулом по протоколу massage pack естественно проксирование чтобы что-то бы запросов тарантул у нас есть много разных модулей при помощи которых можно создавать очень интересные приложения чем в общем-то многие занимаются однако есть одна проблема мы вообще не умею хранить джейсон вот прям не как и в общем задачи нужно было в первую очередь решить проведя анализ того как можно хранить же сон мы выбрали схема вр очень простой пример представьте что у нас есть там какой-то простой час он в левой части экрана системы фамилия и мы хотим это описать схемой проще всего один из вариантов на самом деле как это может сделать это схема вр а есть и другие нотации тем не менее мы выбрали авраам причем я уточнила вреда не только схемы данных но и на самом деле формат хранения поскольку у нас в пользу из шпак мы использовали только схема на данном примере понятно что мы описываем наши джейсон с именем и фамилией просто у нас есть одно только отражается first его типа строка 2 пуль который называется last эта строка мы же одна и поэтому мы не хотим хранить никакие ключи нужно написать некую систему которая будет на лету вытаскивать все ключи и соответственно хранится в виде табло только значение это оказалось достаточно сложно потому что в целом это работает очень медленно изначально самый простой пример как ты должна работать представим что у нас есть две версии данных предположим у нас есть имя фамилия еще заметки вот как с предыдущего слайда если пользователь делает запрос в той же версии в которой давно лежат он получает соответствующий джейсон тут все понятно может быть другая ситуация вы просите данные в первой версии где последнего поля нет тогда мы должны также на лету это сконвертировать в другую версию схемы и соответственно дать только то что просил пользуется может быть и третья ситуация что в базе хранятся не актуальные данные ну не в актуальной версии а пользователь попросил данные в последней в таком случае при помощи дефолтов мы должны данный обогатить и так и раньше вернуть поле стиль данную в той версии в которой он просил как мы вообще как проходил процесс разработки изначально мы взяли родную элемента цию это библиотеки от компании apache и поняли что она очень медленная и к тому же там еще и поддерживались дефолт и поэтому в общем-то было принято решение писать свою соответственно как мы смогли сделать при помощи лоджа то который у нас уже родной встроенный вообще все хорошо и еще есть версия эмма которая расскажу чуть позже на графике мы видим несколько версий реализации тарантула в той библиотеке которая может преобразовывать джейсон staple и обратно соответственно зелененьким показана скорость изначальный реализации от компании apache она составляет порядка 600 тысяч преобразований в секунду в итоге у нас получилось порядка миллиона шестьсот преобразований в секунду наложите и еще больше на м об этом чуть позже возможно у кого то из вас вается вопросы почему график в конце загибается дело в том что влад детей есть так называемый трасса которых вчера я рассказывал ник дворецкий и в итоге мы решили немножко снизить производительность в пользу универсальности чтобы все всегда хорошо je te las соответственно если мы jit вообще отключим мы получим очень маленькую скорость вот это просто для того чтобы показать насколько logic быстро работают и как играл есть еще реализации slv она работает еще быстрее там количество преобразований джейсон вто по порядку этом 3 миллионов 200 50000 естественно это очень быстро однако в продакшн пошла версия с ложью том потому что мы как-то мимо его готовить вообще давно с ним работаем по поводу преобразования схем ключевые понятия 3 поскольку у нас схемы генерятся и по сути нас написано свой компилятор тоже разумеется вас есть функция compal который позволяет из текста или лова таблица создать схему после этого вы можете работать со схемами не совсем так как в манге но вот примерно то же самое то есть вы объявляет схему и начинаете работать и две ключевые функции это flat on flat on flat on как у нас в команде внутри называют скукоживается платон рассказывает лишь это значит flat он берет на вход схему и джейсон на выходе получать the pale делать ровно то же самое наоборот лед на вход схемы это получать джейсон вы обратили внимание что там есть параметры схемы и на схема out это сделано для того чтобы вы могли сразу преобразовывать данные к нужной версии схемы то есть чтобы не было такого что сначала преобразовали deeson staple а потом еще нужно версии приводится получается что все происходит сразу и есть еще операции кс платон которое на самом деле похоже на flat он есть она сжимает и превращает джейсон в то полно на самом деле получается не то пола тарантул апдейт statement это нужно для того чтобы скажем какое-то конкретное более обновить то есть вам не нужно присылать всегда все данные обновлять можно конкретно и поля который вы хотите помимо этого мы продумали миграции потому что скорее всего в реальной жизни у вас может быть много различных схем в продакшене одновременно все это будет работать и версии будут постоянно добавляться поэтому разумеется есть функции добавления удаления полей из документа разумеется вся система может работать во всех версиях сразу то есть условно вы добавили поле накатили версию вас со временем все версии при ведутся в новый актуально об этом чуть позже помимо этого есть операций арина им который позволяет при помощи авраам параметра элис переименовывать поля это не совсем честный rhino им но тем не менее так работают и кроме того мы наткнулись уже на тестовых а тестовом периоде что не совсем достаточно функцию удаления потому что мы можем терять данные если нас много разных версий нужно еще скрывать то есть это то же самое что удаление но при этом на самом деле вы просто не отдаете в новых версиях схема это поле но по факту она хранится чтобы можно было делаться апдейты вообще не терять данные эта операция хайд ну и вот последний момент теоретический как вообще работать со множеством версии очевидно что на чтение это достаточно просто предположим пользуется сделать запрос мы делаем select и потом мы проверяем там версии в которой работает клиент она соответствует той версии которая в хранилище если да то мы выполняем операции он flat on и отдаем данные если нет то мы трансформируем данные и точно также даем данные а вот на запись о немножко сложнее такая версия в лоб можно просто все запросы выполнить версию клиента такой вопрос а вот точно ли это хороший вообще план не будет ли ничего плохого да совершенно верно минус этого в том что версии не возрастают и один и тот же запрос может в рот в разные ответа зависит от того кто когда пишет поэтому такая стратегия не подходит более оптимальный вариант это всегда стараться все приводить в последней версии тут можно разделить отдельно вставку и отдельно обновление в случае с вставка все просто почти так же как с чтением мы просто проверяем не на эту версию которую прислал клиент и на ту которая сейчас максимально в списке наших схем если клиент прислал данный в максимальной схеме мы выполняем ставку если нет то мы сначала трансформируем тому половину ставку случае с апдейтом все немножко сложнее потому что дело в том что мы сначала делаем select и сначала мы должны проверить что то что сейчас лежит в хранилище должно содержит максимальный версия это может быть в этом случае не так представим для начала что она все-таки в максимальный тогда мы выполняем операцию x флотам и генерим апдейт statement и дальше проверяем ситуацию аналогично вставки то что же проверяем версию клиента и максимально из нам трансформируем выполняем апдейт однако если все таки то что лежит в стороны не соответствует максимальной то нам придется сделать как кости сказал не подпорку а гениальное решение нам нужно прямо на месте трансформировать эту схему в актуальную версию а потом выполнить весь блок который справа который помечен пунктиром после чего выполнить операцию рублей чтобы заменить данные ну и после этого можно давать ответ возможно это было немножко сумбурно непонятно поэтому представим что мы сейчас выполняем отдать запросы до багеров смотрим что происходит если мы вспомним пример то у нас есть имя фамилией заметки и представим что данный хранится в первой версии где нет заметок яшьлек да и запрос хочу поменять именно андрей и что должно произойти с то мы увидим что данные хранятся в 1 версию неактуальный сначала мы приведем их максимальный до полным дефолтом после этого сгенерим апдейт statement после чего сохраним данные версии 2 вот примерно так все работает в чем минусы такого подхода то есть понятно что мы в итоге получили проблемы что всегда данные будут консистентная но при этом мы теряем данные из удаленных полей то есть может быть такая ситуация что какой-то из клиентов пишет в старой версии и при этом допустим 1 летку это поле а это поле удалена и он обновляет а польза сана не меняется ему сюда возвращается дефолт это не очень хорошо в тест на вот для этого как раз удобно пользоваться операции хайд потому что вы не потеряете данные все будет хорошо кроме того в avr и реализовано еще две функции в играх можете вы лидировать данные без компиляции схемы без преобразований например так удобно конфиге всякие проверяется очень любой джейсон и кроме от весь развертка палитесь son of the pale это удобно чтобы не делать лишних запросов в базу то есть вы можете проверять тип данных вообще все что к вам пришло еще до того как вы все преобразуете и делаете запрос естественно лишние запроса можно отбрасывать это тоже полезу на рисунке мы видим множество всяких модулей тарантула в том числе евро к чему это я например если мы хотим создать растопи чтобы хранить же сон и так далее нам достаточно взять модуля которым я говорил реализовать те подходы со стратегиями на работу с версиями и поставите джинсов стрим модуль спереди после этого мы получаем готовый рис . то есть тарантул одновременно и хранит и обрабатывает индекс проксирование запроса 3 это выглядит так у джеймса есть тарантул up stream он знает именно про то как ходить в сам тарантул через massage pack внутри работает вошло код тебя бизнес логика может ну по сути работы с джейсоном внутри вы используете модель oro но когда дело доходит до хранение как вот мы только что смотрели при помощи функции flat on a flat он выработается сторону то есть если совсем грубо говорить то такая вот тарантул в режиме mongo db работают не совсем конечно но джейсон хранить можно это скорее на правах шутки что из этого можно сделать очевидно что можно поднять раз цепей в кавычках назовем это 1 уровня система с рипли кации 1 уровня там что у вас нету множества слоев возможно вы захотите использовать более сложной архитектуры скажем разделить хранение и сервер приложений а то есть если у вас sharding или какие-то внешние источники бы что-то более сложные так тоже можно это работает в общем то эта задача которую мы изначально решали она была для большого телекомы там вот скорее вот 2 2 архитектура используется вот и самое интересное все это можно комбинировать всеми модулями которые есть в танту ли то есть допустим может сделать хранение party till можно совместно хранить что-то в памяти что-то на диске в виниле о котором константин рассказывал и не знаю вот допустим вчера был доклад про разработку игры на lua там человек показывал что он сделал pokemon go вот точно такую задачу можно было решить при помощи модуля там не знаю на этом слайде там аверин джинкс и еще гис вот абсолютно точно сам тоже самое бы получилось был большим добром ну как и грелся на храним отдельным можем использовать модули там шар дом если мы хотим устраивании данных то будем использовать модуль экспресс н.д. таким образом можно сказать что текущая система тарантула позволяет очень быстро удобно из разных кирпичиков строить различные системы вот однако понятно что в теории нас так хорошо звучит но очередная проблема нужно задумываться о том как преобразовать версию да наверно можно скачать эту презентацию и еще как-то может самому подумать но это придаст реализовывать на lua помимо того что нужно будет реализовывать строки стратегии по работе с версиями с миграциями нужно будет оборачивать весь этот код в хранимой процедуры который быть вызываться за джинкс а вот конкретно вашу задачу и нужно будет связывать индексы в чосоне то есть индексный поля которые вы хотите использовать адрес он а с индексами в топляк для этого нужно разбираться как авра хлопковые данные вот и вообще удобно было бы создавать раз ты пей простые автоматически без использования лого для того чтобы решить вот я сделал отдельный модуль который в общем то все задачи решает о называется тарантино и он является такой над строчкой на тарантул в которой мы по сути все это решается которых вы автоматически настраиваете тарантул вы можете вообще ни разу с ним не быть знакомые что получится вторых вы не конфигурируете ничего в lua просто это один джейсон файл и там достаточно построек чтобы все заработало в третьих те стратегии которых я говорил ранее там реализованы то есть вы можете запускать restful api с версиями с преобразованиями вот с теми алгоритм зубы тоже отлично работать потом разумеется из за того что там реализован эти стратегии все хранится только в одном то плену все версии сразу вы не будете иметь свой ход от количества версия хоть одна будет хоть что все равно быть один the pale кроме того вот прямо в ближайшую неделю это в меру появится иерархические связи между схемами то есть можно будет делать join если у вас есть несколько зависимых с кем данных ну и сейчас мне нужно программировать на lua это один из главных бонусов примерно так будет выглядеть конфигурация то есть мы просто задаем количество памяти порт на котором мы слушаем индексы отношения между схемами и собственно все версии 5 внутри при этом произойдет следующее мы вызовем боксов э.г. в tarantul и я думаю многие знают что это такое выделяем нужное количество памяти начнем слушать нужный порт в данном случае мы начнем еще вал писать данные по то что мы хотим persistent насти и создадутся все space и индексы в соответствии с тем как вы здесь описали вашу модель что произойдёт при этом снаружи вы получите раз такой такой же как на любом модном фреймворке который собственно позволяет это сделать ну и вот так будет выглядеть join то есть вы просто добавляете еще данные которые вот как последним запросе вы просто дарите prefetch этот ну и собственно самое интересное почему я об этом рассказываю чем она лучше или хуже чем что то еще я создал абсолютно одинаковые условия для тех поговорках и которых я буду говорить но используем 4 физических ядра одинаковая модель данных и в итоге я выбрал танго с framework go restful и но джинс экспресс в случае с войной с еще использовалась mongo db для хранения хотя по сути тут самое важное это то как сам фреймворк работает то есть понятно что там база не будет испытывать адский дискомфорт по сути ботаника то именно сам application framework ну в нашем случае вот и так мы гоняли даны в самом тесте чтобы получилось мы просто загружаем какой-то набор данных начинаем читать читать читать а в тесте на запись мы начинаем обновлять какое-то поле начнём мы с на джесс фреймворк экспресс сейчас очень популярна считается что очень быстрый в тесте на чтение он показал на 4 ядрах бренд такие цифры то есть порядка трех тысяч запросов в секунду мы видим что явно начинает всё дрожать при этом лет инси начинает достаточно неплохо скакать на мой взгляд это такое время не самое оптимальное тем не менее никаких ошибок сетевых по времени марка не было то есть ну все хорошо было у нас же с и манги в плане не отказывай устойчивость но какой-то стабильности то есть ничего не упало все хорошо на запись еще меньше это порядка 2000 рпс там 2100 это же дальше дело не пошло естественно light если там еще выше при записи дальше был бы restful тоже популярный фреймворк с мангой он был значительно достойный показал 4 8500 псы при этом видосе составил там порядка 500 миль skoda ту же более приемлемый результат это прилично но тем не менее можно и больше на запись горесть фоллз мангой показал порядка 8 тысяч запросов в секунду и like a sir в среднем такую же примерно но вот там какой был скачок я думаю что возможно это просто спайк сетевой а может быть это какая-то была проблема были коллеги которые считали что год должен быть очень быстрым поэтому я про benchmark про бенчмарка отдельно газ что пора утром при этом даже без записи в базу просто чтобы помирить а warhead т.е. по сути что мы делаем там куда запрос у нас просто в дикси лежат данные мы их выбираем вот голоса что-то по ротором сказал 20 тысяч запросов в секунду на 4 я трахалась я неплохо или тынц и при этом был порядка 200 миллисекунд это хороший результат но я же вам тарантулы пока да еще один был конкурсант который я считаю сошел с дистанции это джангар с фреймворк нет был 27 тонн да ну то есть там его из гаи был все было хорошо ну естественно django да не справляется вот в итоге ну django естественно там лег пал это совершенно большие числа и само интересное тарантино вот тот подход о котором я рассказываю поскольку сам тарантул запускается на одном ядре то мы можем запустить на 4 но я решил сначала померить на одном сколько он сейчас может при этом поскольку у нас есть versio нирования еще мы храним данной версии 2 и в каждом запросе мы запрашиваем первую версию то есть во время каждого запроса на лету будет преобразована данной схемы версии 2 версия 1 то чтение тарантино показывает совершенно феноменальный результат 25 тысяч запросов в секунду ну не то что феноменальный но так и для чем больше чем конкурентом при этом light нас не больше 100 миллисекунд это это под конец на самом деле если у вас там будет чуть поменьше нагрузки туалет если будет еще меньше 20 миллисекунд на запись в тоже очень хорошо порядка 15 тысяч запросов в секунду или tense тоже порядка 100 среднем тоже меньше таким образом общие результаты тарантул уверенно побеждает на одном ядре гайи ноду ну и джон гарвард понятно на 4 ядрах если мы поднимем четыре таких инстанса я объединим их в условном реплика сад получил такие цифры что в общем-то очень достойно как можно вообще использовать тарантино понятно что это не там какой-то enterprise уровень это просто мой отдельный проект тем не менее он может подойти для легковесных расцвел сервисов из вам не нужно много какой-то сложной бизнес-логики при этом нагрузки большие нужны для мобильных приложений очень может быть удобно то есть скорее всего там это будет актуально вторых естественно versio нирования если у вас много версий приложений одновременно выкатывается носим всей ситуации сердца нирования еще есть две идеи 1 про научное приложение представим что у вас и скит расчеты и в 0 версия хранить сыр и данные а в какой-нибудь там 10 вы храните результат и все промежуточные данные вы будете записывать какие-то версии получит что в конце эксперимента у вас прямо по шагам из серии все промежуточные расчеты эксперименты это удобно и последнего то что вчера был доклад про игру действительно такой backend для мобильной игры тоже бы зашел то есть pokemon go можно прототип pokemon go можно накидать в целом у меня есть еще димка вот но тут возникли проблемы с подключением поэтому меня есть скринкаст который записал сейчас просто прокомментирую это слайд потом еще покажу а можно теперь видео включить нет так вот спасибо большое вопросы есть сейчас еще димка димка не хочет да ну давайте я просто сейчас туда подключу это винда то это печально так а можно все таки подключить так так сильно по показывает плохо показывает вот вот вот так будет видно несмотря на технические неполадки сейчас мы покажем значит что я тут делаю от вверх вот так выглядит config то есть мы можем задать индекса можно задать отношения есть еще авторизация через стоки и настройка репликация можем задать модель мы видим жила здесь еще вложенный рикард из дефолты и вторая модель которая дочерняя и вторая версия который почти все тоже самое только есть что там одно поле вот соответственно кроме того еще я хотел показать что сам тарантино можно запускать в облаке которые она скоро появится и в принципе можете зайти на тарантул . и общему можно будет скоро использовать прям вот из облака как мы видим у нас запущен один instance тарантула то есть сейчас на одном ядре на авра тарантул орг можно поиграть с аврам живую попробовать по создавать схемы вот это собственно тарантул его с облаком и сейчас как бы видно что мы можем тут создавать тарантул в разных режимах там режимом каша в режиме тарантино вот примерно так это будет работать это пока такая бета тем не менее попробовать все можно прямо сейчас она уже запущен вот и собственно сюда можно будет заливать конфиг вот который показан был до этого для того чтобы пользоваться тарантино или заключение будет benchmark которым я говорил то есть мы просто запустим индекс танк вот мне очень нравится утилита вот индекс танкан а строит мониторинг на том узле на котором по которым будем стрелять и собственно дело пошло мы будем разгоняться ступеньками по 5000 rp с и дойдем до 25 вот сейчас мы видим что нагрузку пока небольшая мы потихоньку разгоняемся чтобы было интереснее я сейчас зайду на с другого села в тарантул я буду показывать что в нем происходит при помощи тарантул ctr я могу зайти в работающей instance вот наш тарантино и команды box that можно посмотреть как вообще тарантул сейчас чувствует вот мы видим что у нас инсар electrical и порядка пяти тысяч соответственно все село нагружаться и дальше соответственно мы будем разгоняться летать и будет увеличиваться и все заработает поскольку принципе есть временную я думаю смысл понятен я просто промотать чуть подальше где где мы уже разогнались вот вот там порядка 20 лет носить чуть по повысилась мы видим допросить или очень хорошие вот у нас уже 20 тысяч там порядка 2 килобайта . ну на этом тесте там была и там порядка 15 тысяч записей но вообще в продакшн и мы тестировали на совершенно других объемах там порядка 100 миллионов записи они были не такие большие тем не менее в объёмные то есть само собой большой вот есть как бы 9 процентиль не меньше пяти миллисекунд и вот мы разогнались в общем ровно как я обещала все видео записано вчера я хотел все это показать прямо вот на живую от 25 тысяч запросов в секунду и бокс то показывает тоже сам автор антон естественно двадцати пяти тысячах там уже все сотка упирается и мы видим что вот на самом деле вот вот он уже так немножко плавает вот при этом естественно сейчас я переключу обратное будет видно что лейкерс уже подскочил тем не менее сочинил и танцы вполне себе приличные вот в общем-то на этом все у меня готов тысяч вопрос спасибо большое внимание вопрос первый что в овраг схемах с массивами то есть джейсон это не всегда объекты ключ-значение да безусловно поддерживается вся спецификация apache врата есть вы можете там объявить массив и нам union чтобы ну вложенный джейсон то есть с винила в продакшене вы это тестировали уже не тестировал тестировали пред продакшене используются совместно и хранения то есть у нас вот примерно такой же observer и на отдельном узле есть условно такое сдвоенных хранилище между ментах самым винилом вот и там как бы мы тоже туда всех схему складываем какой размер результирующего то плану рекомендованы вот у вас 2 гигабайта да это в принципе лучше не больше ну я бы сказал так опять же в каких-то там enterprise задачах есть схемы которые не знают там на 3000 строк сама схема при этом вас там могут быть массивы вот таких рекордов как я показывал все это превращается в огромную простыню она как падает но естественно будет деградация по производительности потому что если у вас такая вот разлапистые схема это такие разгадке там например там 4000 bs вот против 22000 или как это будет ну скажем так при увеличении в 50 раз если мы там сделаем скажем 100 килобайт ну процентов наверно 40 присядем да конечно потом"
}