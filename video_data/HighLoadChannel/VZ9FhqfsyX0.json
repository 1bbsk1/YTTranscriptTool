{
  "video_id": "VZ9FhqfsyX0",
  "channel": "HighLoadChannel",
  "title": "Кодогенерация и как ее использовать эффективно / Александр Синичкин (ГК Юзтех)",
  "views": 289,
  "duration": 2282,
  "published": "2024-10-29T03:08:40-07:00",
  "text": "я приглашаю на сцену Синичкина Александра с докладом про генерацию меня зовут Александр и программирую я уже больше 10 лет последние года Четыре где-то Наго И когда я столкнулся с код генерацией меня прямо захватила эта идея Сначала я подумал что за фигня вот потом когда я немножко разобрался меня очень сильно захватила Это идея я понял как много проблем можно с этим код генерации решить и как раз в этом докладе я хочу поделиться сваими наблюдениями и в частности Как можно эффективно всем этим делом пользоваться как обычно у нас всё начинается к примеру делаем кабуд какую-то опиш а используем схему Open к примеру и из неё генерируем код описываем в ям наши ручки натравлю специальную утилиту она из этого уже гожый код нам куда-нибудь складывает и мы этим делом пользуемся проект разрастается мы используем больше схем какие-то утилиты для миграции базы данных генерации ену мов какие-нибудь там утилиты хелперы Не суть важно но всё дело разрастается самое важное оно расходится по разным файлам обычно конечно Всё дело вполне определённых файлах например в моделька либо там всё что относится к капе то есть мы более-менее знаем где искать но тем не менее уже начинаются проблемы когда Всё дело расползается а опять же Всё дело раст мы начинаем использовать какие-то свои вещи что-то своё пишем для код генерации например что-то специфичное для нашей компании там наш трейсер какой-то наш логгер либо сборка ошибок А и А можно мне включить пожалуйста другой режим отображения я не сразу понял что здесь не так кто-нибудь слышит О спасибо всё а в чём плюсы А того что мы используем во-первых весь B plate код который уже давным-давно тестирован давным-давно и переиспользовать много раз он нам не интересен вообще мы всё это пиха в код Ген и пишем в основном бизнес логику А нам становится в принципе приятнее писать мы не упирается мелочи на которые надо отделять внимание и э пришла задача Мы её сделали Всё плюс стандартный синтаксис языка стандартна у запуск из коман строки опять же через фактически это синтактический сахар натами но мы избавляемся от необходимости разбирать Как запускать скрипты В каком порядке и так Дале тому подобное если же говорить о мину привести к мину как я сказал это синтактический сахар над л скриптами поначалу это в принципе полезно и легко мы не паримся о том как это что делать у нас есть запуск через го мы и программу запускаем и тесты и в том числе генерация кода но к сожалению на практике при увеличении количества инструментов у нас мало того что увеличивается время так е и может случиться такое что нам необходимо будет следить за порядком в котором мы запускаем разные утилиты для генерации кода го нам гарантирует этот самый порядок Мы всегда точно знаем что если мы запустим го укажем до проекта из них запустит каждую инструкцию в том порядке в котором написали К сожалению на практике нам может этого не хватать потому что у нас результаты генерации кода одной утилиты могут зависеть от результата генерации другой Поэтому бывает так что мы всё же возвращаемся К тому же к тем же ло скриптам просто всё равно мы запускаем их через Go где генерить генерировать этот самый код варианта два собственно говоря это локальный складывать в Гид или в пайплайн генерировать локальную те генерацию кода то во-первых это высокая скорость всегда Мы один раз генерис этого сгенерировать конкретный маленький участок запустить конкретную маленькую утилиту которая отвечает за это дело тем самым обеспечивая высокую скорость а каждому разработчику который скачал проект не нужно запускать всё это дело ему не нужно знать в каком порядке Где как не нужно в принципе надо этим париться он скачал и начинает работать там писать код запустить Build или ещё что-нибудь Мы всегда поддерживаем сгенерированный код в актуальном рабочем состоянии мы по идее мы всегда пишем тест на наш код Правильно мы всегда в этих тестах учитываем что весь генерированию в том как он используется где он используется соответственно Мы за этим следим Сами как я упоминал вероятность того что можем запутаться в последовательности за этим тоже надо следить Но обычно есть Ремарка конечно что повторный запуск генерации кода оно это дело исправит есть риски что если мы в тестах например либо у нас нет тестов Либо мы в тестах не учитываем весь сгенерированный код который у нас есть мы можем добавить что-то новый функционал например enum или новый endpoint но забудем сгенерировать это дело если мы всё закинем в git то в какой-нибудь схеме э этот новый функционал появится и клиенты по идее будут ожидать что они могут его использовать и Когда начнут его использовать то получат в ответ ошибку потому что наш Кэн об этом ничего не знает Ну и мы не можем быть уверены что этот сгенерированный код не был кем-то вручную подправка либо изменён Мы обычно на ревью мы это дело пропускаем Зачем каждый раз смотреть на заново сгенерированный код если там всегда одно и то же по одному и тому же принципу но мы так или иначе должны класть всё это дело в Гид если мы распространяем библиотеку чтобы не заставлять наших пользователей самим надо этим делом париться как-то заставлять их генерировать код который по идее мы должны им предоставить а если обратиться к генерации кода в пайплайн то во-первых самая большая проблема - это скорость работы в пайплайн у нас машины не всегда хорошие не всегда такие же хорошие как у разработчиков поэтому скорость что билда что тестов Она всегда влияет Мы всегда хотим чтобы всё побыстрее было и проблема времени работы код генерации здесь влезает прямо критично Но это вынуждает нас решать эту проблему о чём я позже поговорю а мы снижаем когнитивную нагрузку в первую очередь на разработчика который всё это дело запускает ему не надо париться на тем сгенерировал он код запушил в нужном состоянии или нет ему пайплайн всегда скажет если он не прав если что-то забыл тем не менее опять же это не перекладывает ответственность на пайплайн разработчик так или иначе всё равно должен за этим делом следить а с ревью снимает нагрузку в виде того что огромные файлы будут отображаться в утилити при этом опять же Ремарка мы можем пометить через гит атрибуты подобные файлы как бинарные и некоторые утилиты могут это дело скрывать но к сожалению не все Поэтому в качестве пункта это дело здесь присутствует А по поводу правильной последованности это было и на предыдущем слайде но в случае если мы выносим в пайплайн то мы так или иначе вынуждены поддерживать правильную последованность Мы просто не сможем собрать в случае если это где-то локально мы храним то часто бывает так что документация не всегда правильная где-то что-то на словах передаётся и там новый разработчик приходит и какое-то время тратит на то чтобы собрать проект Когда мы выносим это дело в пайплайн то Если мы будем придерживаться такого подхода у Нам необходимо крайне необходимо всегда поддерживать виртуальном состоянии нашу сборку в том числе и код генерацию А поддерживая это дело новый разработчик приходит и всегда видит актуальное состояние А ещё пункт который в в пайплайн можно повесить сборку и генерацию кода для разных платформ Да локально Мы через Крос компиляцию можем тоже самое это делать но зачем на разработчик это дело складывать если у нас есть машины которые Пусть этим занима теперь по поводу эффективности самое интересное как вообще всё это дело работает для начала немножко контекста дам потому что это важная Ремарка есть разные инструменты для генерации кода одни какие-нибудь простенькие утилиты им через параметры указал указал какие-то параметры они из этого просто взяли сгенерировать код ничего больше не надо есть другие варианты которые например э прото бав который смотрит прото файлы из-за этого уже генерирует какой-то код а и третий вариант который э самый как раз важный в данном случае - это тот что парся от Гош най код из этого что-то делают как-то данные собирают и генерируют вот Я сейчас буду говорить только про последние последние варианты потому что первые с этим особо ничего не сделаешь либо не нужно как в первом случае в простом либо как в случае с прото файлами Ну действительно тут особо ничего не сделаешь надо только пользоваться тем что есть А В первую очередь У нас есть инструкции гогет их много мало много неважно но они разные по файлика раскиданы и каждая из них она запускается отдельно по факту Это тот же самый вызов какого-либо скрипта внутри сначала читаются файлы проекта по умолчанию путь до проекта передаётся жм ран тайм когда он запускает после этого обычно парси Исходный код всего нашего проекта строится из этого синтаксическое дерева дальше уже специфика инструмента каждый инструмент смотрит в синтаксическое дерево и выполняет какую-то свою логику везде разную по сбору нужной ему информации информация о типе структур информация о функциях интерфейсах о ЧМ угодно специфично для конкретного утилиты после этого подставляю всю собранную информацию в шаблон и т это шаблон вфа в том что вот эти вот операции они крайне медленные причём крайне медленные по своему смыслу в принципе прочитать файл проекта записать файл с шаблоном это операция от операционной системы Она сама по себе медленная построить Исходный код распарсить Исходный код построить синтаксе дерево тоже медлен операция но уже на уровне языка по себе медленная быстрая операция - это посмотреть в уже собранное построенное дерево и доставить всю нужную информацию после этого как-то её пририсовать и передать шаблон вот оно быстро и что можно с этим сделать я начал смотреть Ну наверняка не я первый который столкнулся с этим когда у нас куча вызовов они очень сильно замедляют сборку наверняка где-то кто-то как-то решал так и есть кто-то что-то решал но не универсально например вот утилита для генерации Open схемы конкретно э утилита смотрит на волшебные комментарии в коде в данном случае SU параметры suc роутер один раз её вызываешь как сверху через вызов она проходится по всем фай проекта он она один раз строит синтактический в шаблон там по-моему три шаблон и один раз записывает все эти три файла всё и не нужно несколько раз писать go generate в каждом файле где у нас есть эти волшебные комментарии говор это конкретно это утилита есть утилиты наоборот которые из готового Ям схемы генерирует тоже Гош най код то есть это другой вариант а следующая утилита та которая уже Мы пользовались и который натолкнула меня на эту мысль это генерация Гош кода для Граф схемы она может генерировать код опять же просто имея схему а а может можно натравить её ещё на наш собственный код указать биндинг модели к структурам и дальше она уже будет парсить всё это дело опять же строю Син тактическое дерево единожды и единожды записываю все нужные файлы А я на это дело посмотрел и захотел повторить для наших утилит код генерации как это можно Повтори как можно сделать так же вот это минимальный код который не приглядывай ись я сейчас подробнее расскажу Но это минимальный код который нам необходим в первую очередь это указать куда смотреть что загружать Какие пжи после этого пробежаться по построенному дереву собрать необходимые нам данные записать данные в шаблон записать шаблон файл напомню что вот эти операции они медленны можем от них избавиться потому что они везде одинаковые это записать файлики и собрать всю информацию нас интересует только пробег по дереву и собирать какие-то данные Причём здесь ещё возникает такая интересная проблема когда мы пишем данный файл то как нам понять если мы используем какую-то свою утилиту что нам делать с этим файлом нам нужно новы ть А если он уже есть если он же есть Нужно ли нам проверять данные которые мы хотим туда записать вдруг они тоже там есть потому что Напоминаю что Go каждый запускается отдельно ему не придаётся никакого контекста отдельного Если вы сами того не захотите то есть нам эту логику надо как-то реализовывать самому проверить есть ли уже данные там внутри Если есть в нужном ли они формате Вдруг нам надо как-то поменять если нет Что нам сделать Дописать файлик либо в нужном порядке ВС это выстроить общем вопросы возникают Они конечно решаемые но хотелось бы их Конечно не решать хотелось бы сложить всё это дело на куда-нибудь чтобы решалось вместо меня в итоге придумали утилиту помощник которая возьмёт на себя всё это дело что она се представ приме нека ту м добавить пагинацию для неё простенькая обёртка с курсора с различными флагами Не суть важно что внутри добавим ещё функцию которая эта обёртка будет добавлять и внезапно обнаружим что у нас помимо юзера ещё и проект также с пагинации ещё третья структура тоже с пагинации понима что неплохо Это дело конечно коген делаем опять же магический комментарии В данном случае по тому же принципу как стандартный вызов пользуется только через магические комментарии указываем что мы хотим здесь что-то сгенерировать и название нашего генератора в данном случае шаб оп нужно знать только имя структуры для которой мы хотим всё это дело и сама функция которая вытащит необходимые данные из дерева в функцию передаётся нода над которой был замечен комментарий и вот э нода и есть наша структура главное достать только имя и вызов самой утилиты А мы указываем здесь куда смотреть за теми самыми магическими комментариями Какие пэкеджинг натора чтобы ориентироваться в самом коде и запускаем генерацию всё готово А я это дело выложил Open Source Если хотите воспользоваться буду очень рад э вопросам предложениям пиаром мы успешно используем её вот уже полтора года наверное весь новый код Ген всё пиха туда хочу оговориться ещё момент что большая часть того что у нас есть можно было бы решить дженериками на данный момент но не везде Мы готовы переходить пока на них так время у нас есть я хотел ещё показать в качестве Бону те задачи которые мы решали перво у нас была задача когда мы хотим селекти все Поля из какой-то таблицы поля у нас указаны в тегах самой структуры можно было бы конечно через рефлексию сделать но в ран тайме не хотелось потому что медленно и с типами там тоже надо решать вопрос А через код генерацию легко быстро нам нужно простейший шаблон достать пройтись по полям структуры достать теги распарсить их как надо и в принципе всё тоже самое было с порядком полей в выгрузке в Экселе та же самая задача по сути Мы точно также достаём данные из полей структуры единственное парсим теги чуть-чуть по-другому вот здесь уже было сложнее А мы активно используем дата лоде и проблема в том что для них очень важно возвращать результаты отсортированы в том же порядке в котором пришли ключи изначально опять же по мере разработки обнаружили что большая часть наших сортировщика она одинакова меняется только поля по которым мы проводим сравнение и вариант того что мы это может быть либо слайс структура либо слайс слайсов структура посидели подумали написали уже посложнее немножко конечно но тем не менее Вот всё что нам нужно знать указания конкретное поле - это Потер и является стало приятно удобно красиво и самое крутая штука ну крутая потому что я на неё кучу времени потратил и я прямо очень гордился ей Конечно мы в grq когда используем описание различных инпутов из них он генерирует нам структуры и когда есть структуры достаточно простенькие проблем особо нету но когда возникают слайс тогда и пробле потому что по умолчанию он генерирует таким способом Что проходит инициализация слайса это не будет л Если значение не передано то есть простая проверка на длину массива она не работает Не работает также на ни потому что она никогда не бывает тоже самое с мами в Мы оказались в такой ситуации конкретное поле Линта неважно откуда с фронта с других сервисов или не от этого инструмента Мы зависели мы не могли никак ничего сделать кроме какда залезть внутрь но мы обошли другим способом посмотрели что есть в стандартной библиотеке SQL ре единственно нужно было как-то подружить наш и который вот э и утилиту который генерирует нам код напрямую подружить не удалось потому что уне не поддерживает Так что мы пошли к любимой нашей код генерации тут Конечно мы собаку съели уже пришлось очень сильно копаться с тем как доставать всю необходимую информацию Я теперь знаю отлично Как как поля разные называются как они отличаются чем они отличаются что внутри Если в рамках контекста как синтактический супер спасибо большое за доклад если вопросы Если есть вопросы в зале Пожалуйста поднимайте руку Также можно задавать вопрос в чат и я в этом случае его зачитаю к вам бежит девушка как только добежит будет Вопрос Спасибо за доклад большая работа проделана и хотелось бы вспомнить комикс с kcd которые говорит что программисты любят автоматизировать сколько бы сама работа не занимала вопрос собственно В чём А вы оценивали сколько жоп часов сэкономили на дальнейшем развитии вашего продукта за счёт использования этих инвестиции времени в инструмент да как я сказал мы начали свои утилиты использовать для код генерации и с течением времени я заметил что у нас их там на тот момент было штук шесть где-то и каждая из них она по-разному парси Исходный код по-разному строила дере по-разному смотрела в в это дерево То есть даже простая операция достать импорт нужного эджа в разных утилита делалось по-разному и вот после того как я объединил ребята опять же у нас эти утилиты разные ребята писали у них разный уровень подготовки и скорее всего изза этого были написаны настолько по-разному после написания это утилиты написани новых каких-то инструментов щелчок пальце Потому что во-первых есть и аналоги во-вторых не нужно думать над тем как достать всю эту необходимую информацию где её достать И самое главное гуглить не надо потому что гуглить вот эти пробле это очень сложно Ключевое это types и если гуглить golang types что-нибудь ещё то он тебе вообще не ту информацию выдаст которую ты хочешь это надо читать официальную документацию которая достаточно ограничена смотреть Исходный код Но в основном Конечно дебаггер вот когда мы убрали большую часть этих проблем то новый инструмент пишется достаточно просто просто посмотрев примеры супер Спасибо Давайте дадим слово левой половине зала Здравствуйте спасибо за доклад У меня два вопроса А первый а вы здесь много рассказывали про генер ску кода для таких Как выглядело это достаточно Рудо систем которые выдают данные или просто скажем обновляют пользователей не легче ли было взять какие-то готовые инструменты скажем ну написать это просто на Джаве даже потому что уже там всё есть для этого да Второй рассказывали вот очень много про написание своих инструментов но многие герт скажем код по спеке Можно ли как-то это оптимизировать или нужно именно писать своё первый вопрос Ну мы тут на пишем пра поэтому на переходить такой вопрос по поводу генерации кода ипе если тримм й с примером свайера вот он тут ускорять особо нечего ребята конкретно здесь в этом примере уже ускорили по максимуму как я сказал Они самые медленные операции они взяли на себя они выполняют единожды ты так или ина никак не сгенерирует синтаксическое дерево Но это можно дело ускорить когда у тебя всё раскидан по разным файлам вот эти магические комментарии это как раз они обычно раскиданы по разным файлам И нужно как-то собрать всё вместе вот они всё это взяли на себя и молодцы сделали это настолько быстро Наско могут в том Когда А это становится медленно Тут уж надо конечно конкретные утилити идти к разработчикам и Там разбираться почему это медленно что как Но а есть ряд А утилит который Если э мы смотрим на самый А первый слайд где Я показывал как оно всё начинается вот ряд утилит типа мы типа ГОСТ Cleaner они достаточно мелкие но и каждый вызов как я говорил замедляет Да им необходимо распа и все дела в теории используя мой утилит помощник можно через рефлексию достать приватные методы в конкретном утилите достать там шаблоны которые они используют достать функции которые они используют чтобы парсить код или ещ что-то Убрать всё медленно и оставить только быстрые какие-то штуки Но это конечно нужно проводить работу для каждой утилиты вопрос цены То есть если утилита важ то конечно можно а иногда есть вариант просто выдернуть нужный код встроить его мою утилиту мы так делали несколько раз потому что те утилиты что мы раньше использовали Они уже давно не поддерживаются и туда особо смысла ответил на вопрос хорошо спасибо супер Спасибо ещё вопросы в зале и я ещё попрошу девушку хелпера не могла бы ты принести мне телефон с с того конца зала чтобы я заглянула в чат Спасибо большое вопрос У вас Касту го структур то есть с прото никак не не экспериментировали Нет это отдельный Пласт проблем то есть мешать в одном в одной утилите и то и то точно нет Тем более про это там Google все дела конкурировать с ними как-то не хочется Спасибо ещё вопросы в зале ЗТЕ Спасибо за доклад ме такой вопрос Вот вы показали свою утилиту И как вы планируете её дальше развивать поддерживать потому что ну как я понял не так-то просто было её создать и не Любой человек сможет войти туда и принести какой-нибудь ть Это только вот года два Да сначала Как мы начали пользоваться код генерации и к моменту когда начали пользоваться утилитой как я сказал принесёт пользу буду рад если кто-то туда посмотрит внутрь разберётся принесёт какие-то идеи опять же буду только рад она сейчас развивается по принци того что мне нужно но так чтобы это было более-менее универсально что можно было людям пользоваться не привязывая к моей какие-то специфике Спасибо ещё вопросы в зале Можно пожалуйста выдать микрофон молодому человеку в белой футболке на первом ряду кто-нибудь дойди до него кто-нибудь один Спасибо за доклад У меня вопрос вот в последнем слайде на выводах вы предлагаете обсудить как же исполь Да локально или через icd Я так понимаю вы используете локально Наоборот в пайплайн в локально А в ги игноре все сгенерированные файлы за несколькими исключениями А тогда у меня сразу ещё несколько вопросов да А всё равно же разработчик наверняка когда он разрабатывает локально он генерирует это у себя да да да он должен генерировать щ не заб естественно и добавляется новое что-то сгенерировать и мы это всё добавлять в у нас все сгенерированные файл они имеют суфикс нижнее подчёркивание Ген Соответственно по маске соотвественно любой какой-то новый сгенерированный фай автоматически И тем самым мы сразу на когда последнее мы с таким сталкивались что нте какой-то обновляется А генерация ещё не успела за этим А по идее не должен отрава на сгенерированные файлы как минимум в са популярный линтер там по-моему документации даже сказано что мы по умолчанию не нтим файлы которые начинаются с Ну станда наверно надо посмотреть внутри файла сгенерированный файл который не успел ещё может там добавить специальные специально обозначение что этот файл сгенерирован либо в исключение нте То есть туда лезть особо не надо это сгенерировано оно там валяется и всё спасибо ещё вопрос справа на втором ряду молодой человек поднесите пожалуйста карту микрофон у него должна быть Красная кнопочка влю Давайте второй микрофон дадим у нас разнообразие Спасибо за доклад Подскажите пожалуйста в итоге насколько это увеличилась скорость производителя вопрос насколько сильно увеличила производительность этого утилита Да у нас один проект самый большой пот генерации было очень много структу вешалось по несколько утилит для коге Билд для неё был 18 минут там конечно много времени и на тесты и на миграции в БД но сама генерация кода занимала примерно половину из этого дела после ввода утилиты генерация кода сократилась до 30 секунд Спасибо Есть ли ещ вопросы зала Хорошо вопросов больше нет Давайте я проверю чат нет в чате пока никто не задавал вопросы пожалуйста Не забывайте о том что вопросы в чат можно задавать не только в конце заклада это можно делать прямо по ходу доклада если вам приходит вопрос даже из зала вы видите QR код на экранах его можно отсканировать и таким образом вы попадёте в чат Я хочу Вас поблагодарить за доклад давайте выберем вопрос который вам больше всего понравился самый первый по тому как это дело всё использовать отлично молодой человек не уходите пожалуйста Мы хотим вручить вам подарок от нашего партнёра вас Я тоже хочу поблагодарить Это было очень круто Спасибо большое Приходите к нам ещё и вас Мы тоже Хотим поблагодарить и Подарить вам подарок о тонти Ну а с вами я прощаюсь на Y"
}