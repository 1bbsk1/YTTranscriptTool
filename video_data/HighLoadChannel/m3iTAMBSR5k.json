{
  "video_id": "m3iTAMBSR5k",
  "channel": "HighLoadChannel",
  "title": "Redis — такой простой и такой сложный! / Андрей Комягин (STM Labs)",
  "views": 2343,
  "duration": 3187,
  "published": "2025-01-17T02:22:55-08:00",
  "text": "друзья Всем привет Как вы уже поняли меня зовут Андрей и я c компании stabs мы специализируемся на разработке очень больших распределённых систем Ну понятное дело высоконагруженных класса bigdata отрасли самые разнообразные это и телекомы наша любимая гасу ВС здесь есть Так я забыл кликер взять на самом деле где он тут вот он замечательный конечно же мы в своих проектах широко применяем Open Source компоненты и решения и дис одно из таких решений наверное сейчас я не совру если скажу что во всех наших проектах мы используем ди в той или иной степени сложный начнём наверное с названия Да кто считает что дис - это тоже самое что вот такой корнеплод хрустящий поднимите руку Ну я вас разочарую на самом деле всё не так это грустная скучная абревиатура как мы все с вами любим Ар расшифровывается это diction Server в принципе относится к классу новы SQL баз данных это база данных и е один подкласс есть это данны разработан он был Достаточно давно разработчиком одиночкой сальватора Сан Филиппу Решал он абсолютно классическую задачу типовую как которую мы все с вами регулярно решаем То есть он фиро нагрузку чтобы не приземляется Ну для этого собственно придумали кэш Вот первая версия была написана на языке tcl или кто Как называет содержало всего 319 строк кода конечно в дальнейшем всё было переписана на си и стало работать значительно быстрее в 2009 году проект презентовали в Hacker New под лицензи и внем вче лицензию на двойную Ну почему потому что все мы хотим зарабатывать да а везде лицензии очень сложно заработать едем дальше сделаем краткий обзор понятно что если решение такое популярное то и поддерживается оно Практически во всех языках программирования есть официальная поддержка библиотек в сипе в Джаве в go в пайне в nodejs и в принципе список не конечный поддерживает большое количество структур данных не только строки Как вы думали то есть здесь поддерживается очень много различных структур данных но основные это какие это строки хш таблицы списки сеты Вот наверное это основные с каждой структурой данных можно работать с помощью специализированного набора операций Ну если говорить про строки Это операции там списке это там стандартные lpush L и так далее То есть в принципе даже перечислить все структуры данных которые поддерживает дис будет невозможно потому что мы ограничены рамками доклада операций ещё больше немножко про хранение Несмотря на то что это inem база данных предусматривает два режима стент режи о них мы чуть позднее поговорим более подробно пока это просто обзор едем дальше Конечно строя высоконагруженные просто построить её не используя отказоустойчивые компоненты Но это смерть подобно так делать не нужно иначе вы Выстрели себе во все части тела на продакшене причём очень быстро и естественно поддерживает различные топологии вания включая отка с репликации полноценный кластер который поддерживает сегментирование или шардирование его сейчас называют Ну и так далее с точки зрения информационной безопасности Здесь тоже всё прекрасно есть поддержка шифрования есть контроль доступа с точки зрения администрирования это и configuration Management и мониторинг всё в принципе из коробки есть и ничего изобретать отдельно не нужно с точки зрения производительности я вот для наглядности изобразил такую пирамидку в которой Чем выше вы находитесь тем быстрее и производительнее работает элемент Ну понятно что первые два элемента - это кши первого и второго уровня они работают со скоростями соответственно од наносекунда и 10 наносекунд соответственно А редиус у нас расположился в этой пирамиде ровно посередине и работает он со скоростью 100 наносекунд то есть скорою оперативной памяти ниже расположились ССД диски у ССД дисков среднем скорость работы порядка 100 микросекунд всё это примерно в среднем Да как средняя температура по больнице то есть не надо эти цифры там за истину брать Ну и внизу расположился у нас постгрес здесь вот 10 миску выполняется какой-то средний запрос данных понятно да по производительности А мы движемся дальше что же такое рес в принципе дис - это большая распределённая хеш-таблица А в качестве ключа используется обычная строка в качестве значения один из перечисленных вот типов данных которые дис поддерживает Ну здесь я перечислил это строки списки хш таблицы сеты там сортированный сеты и всякие разные экзотические типы мы поговорим чуть позднее типовые сценарии использования понятно что самый первый топ сценарий использования это конечно кэш Самый классический о нём мы чуть позже чуть поговорим дальше идёт Session Management То есть можно использовать R как Session storage можно на нём строить распределённые блокировки distributed Log можно строить лимите можно считать рейтинги всё что угодно можно делать даже строить какие-то аналитические отты Ну первый сценарий самый простой в принципе все его наверное используют поднимите кто кэширует запросы в редисе Отлично всё просто То есть у нас идёт обращение мы не каждый запрос приземляется запрос на уровне базы данных соответственно результат выполнения ширу в том же кэше и последующие обращения будут у нас значительно быстрее понятно что хранить данные в кэше вечно не нужно данные должны быть всегда актуальными И для этого есть такая история как ТЛ Да Time to то есть на уровне каждого ключа задаётся время его жизни И тем самым мы автоматически получаем актуализацию данных то есть данные проха свежие данные их вытесняют распределенная блокировка тоже очень простой сценарий очень часто применяется есть некий общий изменяемый ресурс к которому необходимо организовать конкурентный доступ в Реди из коробки поддерживается блокировки Ну и собственно вот сценарий очень простой вот на картинке изобра использова То есть у нас есть некая клиентская сессия клиент при работе с нашим сервисом с ресурсом получает идентификатор сессии Ну какие-то метаданные с этой сессией связаны вся эта информация хранится соответственно Элементарно строится на базе Реди учитывая то что поддерживает персистентность В общем ничего дополнительно изобретать не нужно ИП жизни соответственно ТТМ можно это время жизни и ограничить едем дальше следующий сценарий ограничитель запросов или лимитер способов реализации его бесконечное количество можно реализовать на основе обычного счётчика можно реализовать как-то по-другому чуть попозже об этом посмотрим Ну то есть если это счётчик то какие тут недостатки Да всё просто реализация просто Элементарная но такая история не работает с пико нагрузками то есть Никаким образом сгладить пиковые нагрузки нам не удастся для этого есть два других алгоритма первый алгоритм - это алгоритм скользящего окна То есть у нас есть окно определённой размерности и запрос соответственно в него поступают окно постоянно движется смещается соответственно всё то что не уложились в запрос Ну в данном случае у нас минутное окно и четыре запроса в минуту оно поддерживает вс отсева отбрасывается развити этого алгоритма который называется Бат или протекающее ведро то есть запросы капают в некое ведро скорость его наполнения фиксированная и плюс ко всему это ведро протекает позволяя всё новым и новым запросом поступать собственно на вход если скорость наполнения ведра превышает скорость протекания то ведро так или ина запол это неизбежно законы физики поэтому алгоритм мы демфи вот эту нагрузку скоростью протекания ведра как это реализовать мы поговорим чуть позже следующий сценарий использования - это все различные рейтинги рейтинги тоже в редисе реализуются с помощью стандартной структуры данных Ну в данном случае вот данный рейтинг там топ спике 2024 можно реализовать с помощью только одной структуры данных которая называется Сор э структура имеет соответственно мемберов и скоринг Да скоринг - это Собственно сам рейтинг и плюс она автоматом уже для нас упорядочена вот таким вот образом Всё у нас рейтинг готов можно эту структуру использовать поэтому даже не надо ничего на уровне приложения городить можно просто воспользоваться встроенной структурой данных ну и самая интересная наверно сть это архитектура Как же это усте все думают ой редис - это такая простая штука И что там какая там архитектура Да написали на коленке 319 рок кода и поехали в продакшн но всё не так просто как кажется как я уже сказал а топологии развёртывания очень много первая топология самая простая наверное все с неё там начинали когда первый раз щупа редис это топология с одним узлом да имеет право на жизнь но не является отказоустойчивый просто по определению потому что это Один узел Он умер всё умерло Но для каких-нибудь дев сред Да сред разработки сред тестирования Вполне себе можно такую топологию использовать особенно если у вас ресурсы ограничены вы не можете развернуть там полноценное отказоустойчивого решение А мы едем дальше Да вот следующее решение оно построено уже на базе отказа устойчивой архитектуры в которой У нас есть две реплики реплики в редисе называются соответственно главный узел который принимает всю пишущую нагрузку это да или мастер между узлами происходит репликация о ней чуть подробнее скажу позднее и вот здесь стоят такие узлы фиолетовые это так называемые сентинела это топология с использованием сентинела сентил - это по сути узе который мониторит основные улди выявляет какую-то что-то сбои и запускает процедуру восстановления То есть в принципе сенел - это штука которая занимается исключительно мониторингом никакой такой а другой функции она не имеет но кластер редиса э развивался И относительно недавно Появилась возможность строить полноценный кластер полноценный кластер он выглядит примерно вот таким вот образом то есть Ну в данном кластере у нас шесть узлов три мастера и три узла То есть три реплики между ними идт репликация непрерывная репликация в редисе асинхронная Но кстати если кому-то не устраивает вот эта асинхронность да то есть возможность эту репликацию засивки есть такая команда то есть после каждой команды Вы можете обернуть етом идеа синхрон делать Так конечно я не рекомендую но есть сценарии которые этого требуют репликация построено на базе протокола Гоп такое странное название это семейство протоколов которые алгоритм которого очень похож на распространение эпидемии то есть есть узел он знает данные у него есть о двух соседних узлах и информация распространяется на эти два соседних узла как эпидемия заражает эти два соседних узла то есть информация идёт на эти два соседних узла понятно что с мастер узлов у нас можно работать и в режиме записи и в режиме чтения с реплик мы только читаем то есть писать на реплику нельзя да немножко вернусь забыл сказать что кластер в редис Это не просто вот такой вот реплицировать сегментирование то есть здесь из коробки идёт сразу реализация шардирование то есть данные в кластере шардирование используют алгоритмы консистентность они не применяются А здесь используются так называемые хэш слоты Что такое хэш Слот Да есть у вас ключ по которому вы обращаетесь к данными за данными вре Да от этого ключа Бер вычисляется ш функция Ну в данном случае в редисе это используется CRC 16 или CRC 16 кому как нравится в редисе всего 16384 хэш слота то есть берётся вот от этой от результата выполнения этой функции берётся остаток от деления на 16384 получается некое число и дальше диапазон вот этих полученных чисел он уже обслуживается определённым узлом кластера то есть там например от до 5 обслуживает узел М1 Ну и так далее таким образом то есть вот эти все диапазоны будут распределены между узлами кластера для чего это было сделано Ну все знают кто эксплуатировался никому не понятно вот чтобы эту проблему решить чтобы добавление и удаление узла из кластера не превращалось в какую-то боль были придуманы вот эти слоты то есть по сути при добавлении узла происходит Просто перераспределение диапазонов то есть они чуть-чуть сужаются Ну и полного шардинг об персистентность персистентность - это то что данные можно сохранить на диске и в случае восстановления соответственно прочитать с диска есть два режима персистентность режим rdb и режим а начнём с А это режим который в основном сейчас используется на продакшена как он устроен по сути это журнал операций То есть все операции которые дис выполняет он журнали ет просто в файле Каким образом просто добавляют эту операцию в конец файла поэтому так и называется append Only File то есть добавление в конец файла файл этот журнал он человек читаемый то есть его можно открыть там в текстовом редакторе можно его редактировать и ничего не сломается Ну естественно Если вы там сохраните определённую консистентность и формат операция быстрая операция не блокирующая и в принципе у неё есть только один недостаток недостаток этот тоже очевидный связан он с тем что при добавлении операции файл у вас файл постоянно разрастается Да размер его увеличивается и надо что-то С этим делать что придумали создатели редиса они просто взяли и придумали процедуру сжатия этого файла но не сжатие с помощью алгоритма сжатия а просто алгоритм азит и сжимает это до одной команды Зачем пять раз выполнять инкремент если можно выполнить его один раз ну этот режим называется и он по сути уменьшает размер файла вот таким вот нехитрым способом делается компак журнала А мы едем дальше следующий режим персистентность - это режим rdb расшифровывается редиса То есть всего датасета которые есть в оперативной памяти он скидывается на диск Каким образом это происходит сразу скажу что редис - это штука однопоточный у вас выполняются в рамках одного потока понятно что мы не можем просто взять и сохранить сшт в рамках того же самого потока поэтому что нам нужно сделать нам нужно форкнуть процесс собственно это и реализовано есть форка в ственно нового процесса выполняется сохранение снапшота какие здесь неста Недостатки есть недостатков здесь очень много Ну первое то что операция блокирующая второе то что в принципе р связан с тем что у вас в самом плохом случае будет утилизировать в два более то есть X2 объём оперативной памяти от того что вам штуки типа Copy onri в операционной системе в ядре линуса это всё можно это всё будет хорошо работать да это будет классно работать если вы с данными в редисе ничего не делаете Если вы не меняете данные в памяти но если у вас высоко нагруженная система у вас происходит непрерывно изменение данных в датасете и Copy onr он конечно будет работать но не так как нам хотелось бы то есть эта штука при высоких нагрузках работает плохо поэтому rdb никогда на мастерах Не включайте Ну и это в общем-то стандартная рекомендация не делайте Так ну либо у вас если маленький датасет то можно едем дальше пакетная обработка кто слышал что в редисе реализована пакетная обработка или батчинг немного а она есть Она есть называется она очень хитро я сам сначала не догадался есть такая штука называется пайплайн посмотрите какие красивые Циферки сейчас немножко расскажу как это всё работает в редисе реализован протокол который называется работает он или сокращённо работает он поверх tcp Ну по сути классика в режиме запрос ответ мы что-то получаем Как же можно минимизировать вот этот сетевой об который происходит Понятно кома руть сго это называется пайплайн в Реди такая группировка то есть мы группирует в одном запросе и Соответственно ответ тоже приходит сразу для всего вот этого сгруппированный прирост А если говорить про группировку в которой 100.000 команд то это уже семикратный приро видите для нагруженных систем даже учитывая то что быстрый но Пан нужно использовать и в приложении эту фич закладывать обязательно архитектурно едем дальше Поговорим немного про типы данных которые поддерживает не буду я конечно говорить про тривиальные типы типа строк там хш таблиц и так далее поговорим про всякие специфичные вещи Ну то есть вот здесь как раз примитивные типы данных изображены а мы поговорим с вами про вот эти вот штуки какие здесь мы видим штуки я конечно все не буду не смогу сделать обзор на все типы данных Но вот четыре я взял просто потому что они мне нравятся потому что я их использую первая структура - это bitmap вторая сор перло это вероятностная структура данных и стримы Стримы Да куда же без них и в редисе они тоже есть кто слышал что в редисе есть стримы отлично Опять наш лимитер просто в качестве примера я не призываю вас писать свой собственный лимитер есть гораздо более качественная реализации в том же Эн джинсе и везде где это должно быть а но вот на базе редиса лимитер реализовать тоже можно на базе сорта Сета А здесь показан а как реализовано алгоритмы скользящего окна То есть у нас поступают запросы в качестве скоринга используется непосредственно тайм шмп запроса Ну вот эта штука вот там 1 это таштап запроса То есть когда запрос у нас поступает на вход соответственно окно у нас постоянно движется и мы можем с помощью операции работы сорм удалить по диапазону скоринга некий диапазон просроченных записи Да вот вот те которые перечеркнутый линией мы удаляем с помощью функции Z rore соответственно дальше что нам нужно сделать нам нужно проверить размер окна сколько у нас запросов уже в окне осталось после этой операции если это можно сделать с помощью команды zc если количество запросов не превышает пороговое ниезва профу всё в принципе реализация готова там буквально можно на коленке слепить это в течение часа и всё будет работать едем дальше аналитическая история аналитические задачи э тоже часто приходится нам их решать а здесь у меня показано использование структуры данных которая называется bitmap и как ни странно да Казалось бы Причём тут биты и аналитика а но есть связь Представьте что у нас есть некий ресурс которому есть большое количество которого есть большое количество пользователей и нам нужно понять какая у нас статистика посещения этого ресурса в разрезе суток Ну то есть в разрезе суток мы должны знать набор уникальных пользователей которые посетили там наш сайт Наш ресурс наш сервис и так далее для этого подходит структура которая называется клю можно сделать вот таким образом например сделать префикс Visit там дальше дата собственно какой день у нас и дальше идёт битовая маска а оди бит Map содержит два в тридцать второй степени бит информации То есть это достаточно компактная структура Я не думаю что у кого-то есть два в тридцать второй степени пользователей Да поднимите руку У кого пользователей больше чем 2 в Т2 степени нет таких ну Да я там думаю даже у Яндекса наверное столько нет вот э Поэтому нам всем достаточно такой структуры если у вас идентификатор пользователя просто число какое-то там монотонно возрастающее то вы можете просто в качестве офсета в качестве смещения использовать фактически этот идентификатор и допустим у вас этот пользователь посещает сайт вы проставляется соответствующий бит в битовой маске Всё вы знаете что этот пользователь посетил ваш сайт если у вас там какой-нибудь гуи строка всё что угодно Ну Превращаем строку Я не знаю в хэш вычисляем остаток отделение то же самое число используем в качестве офсета в качестве смещения в битовой маске Ну и так по каждому дню делаем статистику работать с битовой маской очень просто есть операции Set Bit getbit всё это очень просто делается описано в документации по ресу Поэтому вот такую задачу можно решить стримы вот смотрите такая картиночка ничего вам не напоминает вообще кавка да да слышу слышу возгласы кавка это же кавка всё правильно в общем-то лавры популярности Кафки не давали спать спокойно создателям редиса они такие А давайте мы тоже сделаем В общем решили зас всю эту историю и создали свою Каку на минималках абсолютно просто склони есть продюсеры есть коню есть коню группы всё это называется в редисе стримом структура данных Стрим все операции работы со стримом имеют префикс X Ну то есть например если мы хотим что-то записать в Стрим это операция X создать consumer группу X Group Create и так далее прочитать там X R Group Ну то есть всё очень тривиально и всё очень знакомо и похоже действительно на кафку А у кого есть проблемы и кто не хочет создавать такую разнородную среду да Нет там возможности развернуть полноценный кластер кавка пожалуйста можно всю эту брокер сообщений всю эту историю реализовать с помощью редиса будет работать а Мы двигаемся дальше и следующая структура очень экзотичный я упомянул в самом начале доклада то что мы сейчас очень активно занимаемся обработкой всяких Big Data вот этого всего это Очень актуальная задача и есть задача Которая так и называется определение мощности множества Ну или определение кардинальность Ну или по-другому просто мы вычисляем количество уникальных элементов на определённом множестве если множество очень большое Ну например перло в редисе поддерживает количество элементов множествах 2 в че степени элементов понятно что для того чтобы посчитать классическим способом кардинальность такого множества Ну нам потребуется очень много ресурсов той же оперативной памяти и так далее в редисе вот эта структур занимает 12 КБ маленькая компактная делат свою чёрную магию рассказывать как она это делает Я не буду конечно в рамках доклада это очень круто и стандартная ошибка при оценке кардинально множества составляет 0,81 то есть Очень низкая вероятность Да этих ошибок то есть достаточно точно всё мы определяем работа со структуры тоже очень просто есть операции pf pf то есть pf собственно определяет нам мощность множества или его кардинальность двигаемся дальше паттерны антипаттерны наверное сае интересная часть Особенно для новичков кто не сталкивался кто не наступал на эти Грабли в продакшене я к сожалению наступал А И вот первые грабли которые мы встречаем - это бра грабли связанные с использованием вот этих двух операций операции Scan и операции kys одна из них блокирует сервер вторая нет делают примерно тоже самое то есть если вы почитаете документации то есть они фактически по определенному паттерну просто делают выборку ключей из редиса причём кис это делает гораздо более в удобной форме Не надо заморачиваться и конечно есть такой Соблазн пользовать йс но нет Это плохой не верный путь так делать не нужно история блокирует сервер То есть если у вас датасет очень большой То есть это миллионы сотни мил ключей то ни в коем случае не надо на продакшене использовать ж тем более логику на уровне приложения потому что это годится только для сред разработки Да и то там с натяжкой в отличие от операции SC у нас то есть реализована она на базе курсора и не блокирует сервер и прекрасно подходит для прок у ней есть нюанс связан он с тем что она не обеспечивает защ от дублей То есть у нас в принципе реу выполнения мотб мы можем получить дублирующие ключи но там стинт сделать уже потом простенький алгоритмом каким-нибудь не представляет ничего сложного Поэтому вот знаете вот такие грабли есть а expiration я говорил про алгоритм ТЛ Да Ключи у нас просра Но как они просра Никто не знает то есть для всех это чёрный ящик И вообще как это устроено непонятно есть две стратегии удаления ключей в редисе Первое - это ленивое удаление то есть на самом деле что происходит вы дёргай небудь Get ВС что угодно вызывает функцию expire If need и в этой функции просто проверяет а не просрочился у меня этот ключ если он просрочился собственно он вам говорит что нет такого ключа То есть он его удаляет в момент собственно доступа к этому ключу удобно классно гори IMP оче простая реализация неприятная реализована кривень это периодическое удаление все держим в уме Что дис штука однопоточный и в одном потоке и при этом ещё чтобы он работал там отвечал на какие-то запросы создатели подумали подумали и поняли что никак Что же делать бират случайный набор ключей небольшой набор И вот так итеративности из rdb все данные которые просрочились они просто отсеивать удалён А значит с точки зрения репликации все алгоритмы просрочки работают исключительно на мастеру узлах на secondary узлах никакой просрочки не происходит то есть реплика просто получает от мастера команду что дорогой друг вот этот ключ был удалён Удали пожалуйста его у себя и всё то есть всё очень просто про улучшение понятно что алгоритм не очень Да мягко говоря что же что же с этим делать Вот сальватора недавно на конференции рассказывал как они это улучшили они взяли индекс построили индекс на базе Дик 3 и что для чего для чего они его применили они фактически вот все ключи которые они Сплит когда-либо отбирали Да в рамках вот вот этого отбора они просто помещают в индекс и повторный повторная проверка она будет идти значительно быстрее потому что индекс просто быстро работает radix 3 - это быстрая штука Она работает Быстро тем самым а ускорили алгоритмы просрочки Ну вы все должны понимать в уме Что если у вас ключ там должен просрочиться вот прямо сейчас он может просрочиться спустя там 5 минут и это нормально так происходит и если у вас большой датасет у вас Ключи будут просраться с определённой задержкой не ожидайте что они просрочится в ту же секунду это не система по тюнингу требует тюнинга по тюнингом я понимаю тюнинг непосредственно операционной системы и тюнинг каких-то основных параметров которые в редис есть с точки зрения операционной системы так как это база данных мы дол пам и мы должны лимитировать редис в использовании оперативной памяти Ну рекомендация такая 75 85% в зависимости от системы да то есть могут быть системы где лимит можно чуть поднять или чуть снизить но всё зависит от задачи tcp тоже немножко нужно потютьков Если у вас нагруженная система Если система там со средней нагрузкой можно делать Ну и я уже говорил что rdb не используем на Мастере то есть rdb никогда не используем на Мастере есть конечно варианты но лучше так не делать Ну и на сладкое Я оставил сравнение с альтернативами Почему появились альтернативы чем же так плох редис Да что с ним не так ну основная проблема редиса то что он однопоточный и Казалось бы надо-то с этим дела ите в эту ро но они сделали многопоточность только для операции ввода-вывода сейчас за многотонные операции они так и работают в одном потоке и в принципе я считаю что это нормальная история Давайте разбираться самое свежее вот такое миско которое подъехало относительно недавно и мы его поупа попробовали на продакшн среде на Большой очень большой системе не бува idb - это не Fork редиса это штука которая была написана с нуля на c+ Plus тоже in Memory база данных а совместимое с ris Что значит совместимое с ris они себя позиционируют как drop-in replacement редиса то есть взяли и поехали просто заменили И приложение не догадается что у вас там не redis а dragonfly но всё ли так гладко разберёмся чуть позже а под капотом у dragonfly понятное дело уже многопоточная архитектура это их основная фишечка они на этом пиарят и Переса алгоритмы вот этого сэмплирования отказались Они от сэмплирования слава Богу переписали рюш на сво собственный алгоритм Ну на этом тоже не буду останавливаться это никому не интересно никто не запомнит вот такой вот классный график приведён на сайте ребят из ДНФ смотришь и думаешь Вау как кру Я хочу Dr вместо своего редиса тормозного но не всё Так класно то есть естественно ребята Пиа и стратегия продвижения она была самой простой и самой такой легко реализуемыми они взяли просто силно редиса однопоточный и поставили рядом многопоточный dragonfly сравнили в лоб Вау круто всё быстро работает но мы понимаем что это читинг то есть никаких тут скоростей естественно нет на продакшене никто дис в сингл ноде режиме не использует я надеюсь По крайней мере из вас вот поэтому всё это ВС Это неправда но Понять и простить ради стратегии продвижения что не сделаешь это кстати история очень сильно задела создателей редиса Они подумали вообще как так-то нам плюнули в лицо просто мы не можем просто оставить это просто так что это такое Ну об этом чуть позднее а сейчас едем дальше что там в планере ли так красиво и такие розовые Пони как нарисованы на сайте нет всё не так гладко оказалось воткнули Мы в один из проектов dragonfly на тестовой среде не на продакшене и поимели ошибочка оказывается эта штука не поддерживает keyspace нофи keyspace фике если кто не знает э штука в редисе которая вам говорит что с ключом что-то произошло он там закс парился в его кто-то просетинг по поводу отсутствия поддержки для keyspace тифи Есть открытая isu 1657 вот здесь ссылочка есть на него то есть с этим Пока ничего не происходит никакого движения Нет к сожалению поэтому для нас ну dragonfly не подходит не знаю для остальных кто может быть не использует вот эту технологию может быть подходит готовность к про я вот Оценил такими четырьмя квадратиками в dragonfly нет горизонтального масштабирования то есть он не масштабируется как дис есть вертикальная понятное дело на Это основное упоры сделан для этого собственно добавили многопоточности вот всё остальное но горизонтального масштабирования нет учтите это есть если у вас они количество ресурсов там вы не можете развернуть много-много узлов то может быть dragonfly Вам подойдёт а нет поддержки keyspace notification events и есть очень много вопроси к методике тестирования и вот к тому нчу который приведён на официальном сайте драгона создатели redis провели альтернативный тест взяли уже полноценный кластер ris включили пайплайн батчинг Да и вау Всё поменялось кардинально да ди почему-то оказался впереди и более производительным как так произошло непонятно да Ну конечно ВС понятно То есть просто полноценный кластер даёт фору многопоточного ДНФ вот пайплайн тоже нам как мы знаем даёт существенный прирост то есть использовать операции пакетирования бачин обязательно нужно на продакшене такие вот види вывод использовать для каких-то стартап проектов Когда у вас там я не знаю одна нода есть вы что-то подняли что-то пописали Потом если что можно эту штуку заменить на полноценный R кластер и про неё забыть может быть может в будущем это всё как-то разра появится поддержка тех же Space notification ивентов но пока вот так едем дальше стремительно ускоряем следующая решение kbb в отличи от Dron собствен реализаци KB это тупо просто взяли его заного пото и вс на ровном месте получили прирост производительности X5 Ну по крайней мере то что заявляется у них на официальном сайте понятное дело поскольку это то это полноценный Dr но есть нюанс у KB очень странная я бы сказал экзотическая реализация репликации есть уних есть два режима репликации и мультимастер мы попробовали обе обе работают как-то не очень то есть мягко говоря это ВС начинает тормозить начинаешь копаться там на к оверфлоу и на Ребята кто это пользовал в общем-то у всех одинаковые проблемы это можно настроить но всё равно это хуже работает и менее стабильно чем та же репликация в том же редисе поэтому нуби любителя Яре критерие первой многопоточность в kdb она полная в редис Это только операции ввода-вывода способ масштабирования здесь опять же упор на вертикальное в редисе на горизонтальное отказоустойчивость здесь такая экзотическая там полноценный кластер Надёжность репликации в kdb низкая в редис высокая Ну и готовность для прокш Ну я бы для kdb Оценил е как ну можно использовать Да можно использовать допустимо Но для нагруженных я бы всё-таки не рекомендовал вам на эти грабли наступать и использовать традиционный классический дис и ничего не выдумывать Ну и последнее решение такая изюминка которая тоже появилась относительно Дина К сожалению я не успел её лично пощупать но Планирую в ближайшее время это сделать это изюминка от компании Microsoft называется она garn тоже орная штука тоже кэш хранилище написана вся эта история на си шарпе под капотом многопоточный движок Microsoft он собственный То есть это не г а у них движок варит это там РК их хранилище Может быть кто-то знает Ну в узких кругах известная штука Microsoft Faster вот хранилище у них тоже сделано немножко по-другому оно разделено на два основное и объектное в основном хранилище лежат строки в объектном собственно объекты все данные лежат в CP хип позиционируется как Drop in replacement в части совместимости СС лично не проверял но майкрософта доверяю всё-таки серьёзная контора но надо проверять конечно перед тем как где-то это применять в проектах пам кликер О спасибо тест ребята тоже сделали Бен сравнили уже см с дном и в общем-то бенчи впечатляющие они не пошли по пути читинка Ну по крайней мере на первый взгляд так кажется то есть использовали батчинг пайплайн и Ну в общем Впечатляет Впечатляет то есть однозначно стоит посмотреть в сторону Microsoft гарта где-то на будущее на перспективу Потому что если они действительно не бросят не забросит проект то у него однозначно Есть перспективы Ну вот и всё Давайте подытожим о чём был доклад мы успели сделать краткий обзор типовых сценариев обзор самого редиса его архитектуры поговорили про структуры данных в том числе экзотические обсудили паттерны антипаттерны нюансы использования не прошли мимо тюнинга и даже сделали сравнение редиса с его основными альтернативами такими как dragonfly ки db и garnet А я готов ответить на ваши вопросы Спасибо большое Андрей это параллельно ещё друзья был мастер-класс как выйти на сцену перед полным залом и не потерять дар речи я буду спикером молодым показывать это на тренингах значит слушайте нам как минимум надо Два подарка подарить матрёшку имени Олега Бунина супердак Тесь в том сообществу потом поднимите руку подумал давай Андрей Спасибо большое за доклад очень интересно для меня дис - Это новая технология я много слышал Теперь ты много детали дал исходя из своей практики использования Спасибо тебе вопрос такой ты говорил про сохранение файл в журнал когда опен изменения и сказал что единствен мину файл постоянно разрастается И для этого можно Ну придумали алгоритм сжатия что я так понял пачками дописываются что-то произойти и вся эта пачка не записаться инс упадёт и данные потерялись или нет Ну ты совершенно прав то есть а как все любые в принципе элементы редиса они могут где-то отказать и что-то Краш Но мы же помним что у на кластер да и у нас не просто мастер узел там или один Second узел у нас несколько данные реплицировать нормально а там будет кворум новый лидеры И оттуда будут конечно спасибо спасибо бегом в режиме блица Всем привет Спасибо за доклад очень полезно и собственно на вопрос какие-то абстракции над редисом используются или нет абстракции нам Что ты имеешь в виду а какие-то прослойки которые позволяют менеджмент редиса сделать проще в том числе из кода слушай ну мы вот не используем никаких абстракций дополнительных потому что в принципе библиотеки вот те которые клиентские они достаточно простые в использовании там какие-то накручивать армы поверх этого всего я не вижу смысла понял спасибо спасибо Зря ты на Яндекс набросил сейчас будет тебе вопрос Привет Спасибо я Дима из Яндекса э ну Вопрос нормальный ээ вот Андрей в прошлом году на одной из конференций был доклад о банге в парес там ребята руками сделали батчинг увеличили отлично в редисе это тоже руками или есть автоматика вот что из коробки батчинг будет и мне ничего не надо делать Да батчинг абсолютно ручной То есть ты реализует это вот формирование пачки по сути на прикладе Ну а уж как ты там реализует Спасибо Да всем привет Спасибо за доклад вот я бы хотел спросить по части Client Сай шин вы ну применяли это Сай что Client Сай шин А каширование на стране клиента то есть на стране клиента Да как бы организуется некоторый канал Да с редисом чтобы он обновлял ключи как бы в локальном кэше какого-то конкретного например пода Вот вы это использовали или нет мы делаем вот этот Cent Сайн только для пайплайн то есть мы копим команды подгореть можно в принципе это складывать в каку ГТО копить эти пачки Но мы вот реализовали так Я просто Когда читал документацию там есть ти тельный способ Да там оповещать клиентов типа чтоли какие-то ключи вот или обновление какое-то произошло чтобы то что запарили ключи У тебя есть механизм который я сказал как раз ктоу слышите Как площадка реагирует на парня который прочитал документаци в общем мы не применяем ничего больше экстра сверх этого возможно что-то есть я может не понял в кулуарах обсудим то есть нотификации принимаете Да нотификации используем ещ два вопроса Раз и два и потом памяти и что его производительность очень сильно зависит от того с какой реализации молока он собирается вот ваш опыт на эту тему Вы пробовали его там собирать с разными реализация там как тестировали понял да Вопрос Вопрос хороший точно не знаю потому что Ну по крайней мере то что я смотрел Там есть собственный менеджер Вот Но по опыту эксплуатации скажу теме у которой нагрузка там 15-20 сся псов без рестартов больше 2 лет память не сильно фрагменти ется поэтому Ну мне кажется всё нормально с этим хорошо спасибо жирную точку Да здравствуйте Андрей У меня вопрос совсем короткий вот самый последний пункт сравнение редиса dragonfly kdb и garnet А было ли сравнение с apch ignite или нет э Хороший вопрос всё-таки apch гй его нельзя назвать в отличие от от редиса легковесный в плане развёртывания а потому что ну инфраструктура ач она мягко говоря такая тяжёл Поэтому в плане бенче я не смотрел честно говоря ну и плюс Сейчас вы знаете что в России не сильно можно apch ignite применять особенно на там каких-то проектов госо вых а в том же телекоме в общем-то Он практически под запретом везде поэтому Ну мы от Игната отошли мы его раньше применяли сейчас от него отказались по бенчан не скажу не знаю Не свеял ну что ж это было прекрасно друзья в 13:40 на экране будет теток как раз про B B редис и как Газпром банк тех с ним боролся потом гео распределённые данные от нька А сейчас Поднимите руки кто задал вопросы чит Т вот какой вопрос был самым важным для сообщества это самая сложная часть доклада Да перестань ты выступал вот так вот покрутим покрутим покрутим Раз отлично матрёшечки уходит сюда а кому подарим супер суперприз от Ну давайте молодому человеку с Александру от МТСа и потом Мы фотографируем обязательно спикеру обязательно спасибо большое друзья следите пожалуйста"
}