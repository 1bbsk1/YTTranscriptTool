{
  "video_id": "h6c4IkZxFZY",
  "channel": "HighLoadChannel",
  "title": "Удобный и расширяемый роутинг в iOS-приложении / Тимур Юсипов (Avito)",
  "views": 1103,
  "duration": 2283,
  "published": "2017-05-17T12:46:19-07:00",
  "text": "день давайте начнем нас 3 доклад тимур юсипов и завита расскажет про удобные расширяемый роутинг в ios приложение рад всех видеть спасибо что пришли я ios разработчик из компании авито меня зовут тимур юсипов одна из моих должностных обязанностей является навигация в нашем приложении подает я программирую уже почти 5 лет до этого имел опыт небольшой на плюсах на кьюти шарпей джаве потом была в актив и которым я долгое время нравился но сегодня его полностью затмил свифт поэтому сегодняшняя презентация будет исключительно на swift вот историческая справка авито это уже давние приложение изначально делался на аутсорс и пару лет разными компаниями переходил из рук руки от осадного разработчиков другому пока однажды компания виза не решила перенести разработку winehouse и тогда оказалось что приложение представляет из себя винегрет разных подходов и технологий где-то были красивы историю бардов целая латы сегвеи где-то была навигация кодом и верстка тоже кодом где-то и везде была куча костылей мы со временем это приложения зари factory ли сейчас используем свифт объекте все причем две трети приложения уже переписана нас views вот количество кода здесь представлена без стоит party зависимости и без тестов вот помимо этого хочу заметить что мы тоже используем вайпер но на свифт и он у нас сильно отличается и мы делаем верстку и навигацию полностью кодом как будет проходить нашу презентацию мы с вами ведем понятие роутера попробуем написать роутер посмотрим на какие грабли мы будем при этом наступать потом адаптируем роутер для поддержки айпад сформулируем общее архитектурные требования к построению навигационного стека решим пару навигационных задачек и посмотрим дымку для закрепления результата а для начала я в виду пару понятий которая будет участвовать потреблять во первых что такое модуль не важно какую архитектуру используете виси вайпер или еще какую то другую под модулем я здесь понимаю совокупность всех слоев этой архитектуры все что мы будем сегодня говорить применимо к любой архитектуре главное выделить слово слой роутера по моему свой роутер это самый плохо описанный слой и вызывает наибольшее количество споров разработчиков так же было и у нас и второе понятие это debling deep link это внешняя ссылка на примере этих по которой приложения должна что-то сделать как минимум там например открыть какой-нибудь новый кранчик на свои то есть такой кран где кнопка ее действие настраиваются сервером с помощью deep ленка сначала пользователь должен авторизоваться потом приобрести услугу потом применить услугу и только потом кнопка делали что-то кастомное мы сегодня будем говорить о киплинг ах только как а способы перейти на новый экран давайте начнем нашу презентацию с риторического вопроса что не так с этим кодом здесь viewcontroller обрабатывает нажатии на кнопку кстати а яркость и гройтер и новый контроллер обрабатывать нажатия на кнопку создает контроллера авторизации создает навигационный контроллер и показывает его модель на собственно чтобы ответить на этот вопрос нужно знать ваши реалии разработки если у вас маленькая команда или вы вообще один дома в тапочках сидите пилите свой стартап то пожалуйста написал так код и понеслась production все работает все нормально но если у вас большая команда вы пилите серьезное приложение и у вас важны такие критерии как качество кода в лице его перри используемости тестируем асти а также возможность распараллелить от сработку над модулем между несколькими людьми то вы будете выносить код добавлять слои разделять ответственности и ни в коем случае не допустить и такого мы сегодняшнюю презентацию будем проводить так как будто мы пишем сложное большое приложение и поэтому мы вынесем за связь 1 к контроллеру со вторым добавив слой роутера как бы он выглядел для viewcontroller а роутер был бы закрыть протокольчик am с одним с одной с одним методом так в самом простом случае выглядело бы реализация у нас было бы два слабых war общину поле навигационный контроллер чтоб делать pushviewcontroller и руки контроллер чтобы делать pop то viewcontroller собственно возвращаться на свой модуль как бы выглядел код роутера роутер бы создал контроллер создал бы следующий роутер проставил и контроллеры для этого роутера и связал бы авторизационный контроллер все роутером и потом собственно сделал бы пух-перо что хочется заметить что инстанцирован и экземпляров слоев и проставления зависимости между ними явно не обязанность роутера хочется этот код переиспользовать поэтому вынесем его в слой ассамблей ки как бы выделил свое сам блики у роутера появилась бы фабрика ассамблеи закрытая протоколом она бы возвращала конкретные сам блики например ассамблей к авторизации которая просит в качестве параметра не опциональный навигационный контроллер вот у роутера они хранятся слабы чтобы не мешать ее и готовому стейку управление памятью вот но здесь функция требует нормальный viewcontroller потому что иначе пользователь подумает передам к я нил и все будет работать на самом деле это не так вот посмотрим как изменится код вот у роутера добавится фабрика ассамблее и коды станет чуть меньше но во-первых он проверить что у нее есть нагишом контроль что делать переход потому что этого требует ассамблей к из фабрики достанет ассамблей q попросите собрать модуль передав новейшим контроллер и наконец сделает пушки контроллер от уже лучше но есть еще куда расти во первых вот эти поля будут у всех роутеров поэтому и хочется вынести в базовый класс так мы и сделаем и как будет выглядеть примерно так появится наследование ты кода уже стало намного меньше уже смотреть приятнее но есть все равно проблемы во первых нужно в каждом роутере написать такую проверку если у меня навигационный контроллер а нам нужно чтобы сделать push а если вы делаете пока с модельного контроллера то у вас будет повторяться другой код создания навигационного контроллер для модельного перехода этот код тоже хочется вынести в базовый класс и тогда роутер будет выглядеть уже очень красиво а именно так есть будет метод pushviewcontroller derive сам франкла уже готов который для для нас уже передали навигационный контроллер и просят и просят нас вернуть из кожи этот контроллер который надо запушить собственно первые две строчки остаются неизменными а третье то мы возвращаем контроллер который хотим запушить в чем преимущество такого внешнего вида коля во-первых я открываю этот класс вижу функцию show of the resolution и вижу первое pushviewcontroller заставляй меня уже не волнует я уже знаю что он возьмет фабрику томасом блейка и так далее а вот второе приятная что я могу взять и поменять pushviewcontroller но презент model-view-controller и весь подход останется прежним я быстренько зари факториал таким образом мы выделили хороший фасад но посмотрим на базовый класс мы перенесли сюда поля одна из них это слабая ссылка на новейшем контроллер этот случай не покрывает все варианты потому что есть еще мастер detail модуля например на ipo диск любви контроллер или на айфоне есть гамбургер меню его еще называют боковое меню это что подержать такой нам нужна вторая ссылка на youhei шим-контроллер поэтому нам понадобится второй базовый класс баэс мастер detail роутера вот у меня собственно две ссылки на юге шим контроллер на мастер и detail и метод называется не pushviewcontroller об уж мастера и пушки тел если присмотреться на этот код то тут мы делаем push мастер а передаем в кожу один новейшим контроллер хотя мастер detail роутер требует 2 это означает что нужно добавить 2 навигация контроллер в код уже даже не влезет в слайд и плюс если нам понадобится еще что-нибудь 3 потом передавать то мы будем по всему приложению 3 factory лучше сразу позаботиться об этом и добавить структур q для передачи всех параметров от роутера к раутеру вот назовем их семечко роутера будет два семечка 1 для обычного роутера 2 для мастер detail а таким образом рефакторинг теперь станет удобней если мы добавляем поле в какой-нибудь из роутера мы добавляем их семечко или фактором только в базовых классах клиентский код останется неизменным под клиентским кода мы здесь понимаю наш новый улучшенный фасад pushviewcontroller и из роутер сюда нужно создать viewcontroller кампуш мастер сет detail покажи модели навигационный покажи папа эра издавали длинное название методов но зато они дескриптивный как говорится so far so good но есть все равно парочки недостатков во первых что если нам нужно показать модуль авторизации не из одного viewcontroller и а из любого например у нас есть уведомления об истечении сессии и мы хотим внезапно показать модуль авторизации что пользователь подтвердил свой а тут нам на помощь придет свифт у него есть протокол extension можно написать дефолт на реализацию примешать этот протокол ко всем роутерам метод к стильный но в принципе сработает вот а если произойдет новая задача появится поддержка тип линков хотя бы в базовом варианте когда нужно из любого места приложения открыть какой-то ряд экранчиков то этот подход нам уже явно не не поможет хотелось бы чтобы за обе эти задачи отвечал только один модуль в идеале это должен быть корневой модуль приложение потому что больше я не знаю зачем он вообще нужен его роутер иначе ничего вообще бы не делал вот наш чтобы показать навигационного показать новый контроллер нужно это сделать на самый верх а значит роутер нужно научить искать самый верхний модуль вот мы получим выражение лица примерно такое мы говорим в корневом роутере pushviewcontroller и он автоматически пушиться на самый верх вот а в качестве бонуса сервиса поиска ртов и контроллера мы получим возможность показывать плавки push-уведомлений и alert of самом видимом экране там где пользователи всегда увидит и как раз этот сервис можно засунуть в семечко роутера и мы уже получили профит от того что его завели посмотрим как бы выглядел поиск этого верхнего модуля тут начинается самое интересное допустим он был закрыт для роутера протокольчик ом и реализация выглядело бы примерно так здесь было бы поле чтобы начинать поиск откуда-то более корневого контроллера и был бы цикл в котором мы искали бы презентацию контроллер но тут есть проблема если у меня презенты контроллер это там бар и выбранном тоби у меня сплит viewcontroller имеющую нужно с мастер детей лампа ковыряться чтоб понять куда мне запушить там не появляется большая портянка с кучей if files of и куча down костов помимо down костов здесь еще какая проблема я завязал завязался на я и китовые контроллеры это бар контроллер speed controller если я хочу поддержать кастомный например рдв табор контроллер то мне придется написать еще больше до ункас тв в принципе на этом можно было бы и остановиться но у меня была задача сделать красивые хорошо поэтому я призадумался как бы мне обратить и да он костра и я принял решение написать свою систему навигации зачем она мне нужна была бы во первых она хранила бы всю историю переходов таким образом я мог бы по ней легко определить какой самый верхний модуль по дереву во вторых в качестве бонуса я могу проверить что модуль действительно был когда-то показан как это вообще можно проверить другими способами можно проверить presenting viewcontroller но если бы лпу что этот метод не сработает можно проверить что view винда у не равно нил но она будет ни у если поверх показан на данный контроллер и еще можно хранить слабую ссылку на контроллер но этот метод иногда не срабатывает если у вас контроллеру по каким-то причинам становится с англ тоном это конечно плохо но мы бывает такое и еще если у вас как-нибудь там управление памятью нарушены из-за retain сайкл av controller просто не дело целуется пасе по полной истории можно было бы четко узнать был он когда ты на экране или нет и второй бонус это можно учитывать расстояние между модулями и тем самым победить проблему победить проблему дубликатов модулей например вы в appstore нашли приложение нажимаете и приложения разработчика и видите то же самое приложение переходите на него другие приложения разработчика на него и таким образом бесконечно закапываете пользователям навигационный стек хотя в какой-то момент можно было бы просто сделать обратный переход и пользователь бы все равно получил тот экран на которую он хотел попасть вот вторая задача система навигации это обернуть ее кит так что было легко добавлять that party контроллеры и чтобы можно было быстро ли factory когда изменяется из dk например когда ей papaver контроллер сменился на ей попу presentation контроллер от прежде чем я начал делать новую систему навигации я посмотрел на базовый роутер еще раз и увидел несколько проблем во первых это поле вишни контроллер есть не у каждого роутера если роста бар приложения то корневой модуль будет представлен tab bar контроллером и в нем будет роутер бездны гей шим-контроллера вот во вторых то что роутер делает pushviewcontroller сильно завязывает иван iii накид почему потому что если появляется еще один какой-то сторонний навигация контроллер и у него метод называется power shell nex-3 контроллер то нам нужно еще одна пара базовых роутеров чтобы поддерживать этот случай а хотелось бы чтобы было все 2 обычный мастер detail и я понял что нужно абстрагировать роутера ты ее кит видя какую-ту прослойку я добавил два понятия идентификатор перехода который роутер бы хранил на себе и обработчика перехода в которому бы роутер говорил что нужно сделать чтобы поменять так навигации например он был ему говорил сделай отменяем эй переход и в качестве параметра там идет структурка с контроллером на который нужно перейти и стиль перехода например там пуш или презент моду отменяем и переход это тот у которого есть обратный например у пуша есть папу модулей презента есть dismiss но бывают и не отменяем и и переходы это например сетку controllers но новейшим контроллера обратного метода нет это методы ухода из модуля есть еще два метода возвращения отмени переходы после идентификатора если роутер передаст туда свой идентификатор то он отменит все переходы из этого модуля и значит вернется на свой модуль еще один метод этот мини переход с идентификатором если передать туда идентификатор роутера то можно закрыть модуль роутера вот таким образом теперь роутер общается с обработчиком переходов они с ей китом обработчик переходов в свою очередь оборачивают я viewcontroller какие viewcontroller и есть чтобы их можно было верно обернуть на самом деле дых два типа анимирую щи и и контейнеры имеющие представлены следующими обработчиками обычный который ее иви контроллер оборачивает этот что оборачивает ее не видишь на контролер и контейнеры с базовым классом я я бы обертка для сплита и для табора что делают анимирую щи и у них есть аниматор и они ему говорят запустить анимацию и там произойдет соответственно либо push либо презенты контроллер если у нас появится сторонний навигация контроллер то мы просто добавим еще одну обертку в котором аниматор будет делать там шоу next контроллер а для раутера код останется прежним мото контейнера говорят какие у них видимые анимирую щи и обработчики и все они миру ющие обработчики видимые нужны тогда когда я хочу запушить в выбранный tab табора они в какой-то рандомный а все нужны тогда когда я ищу по истории провожу поиск мне нужно знать всю информацию о всех переходах таким образом стало легко добавить third-party контроллер будь он анимирую щим или контейнером нужно просто добавить еще один обработчик переходов как теперь выглядит роутер раньше было два выговора общинного поля теперь они заменяются двумя лет полями одно это идентификатор перехода за месте ссылки новый контроллер чтобы возвращаться на свой модуль или закрывать свою модуль а вторая это обработчик переходов причем он не просто обработчик в в боксе с двумя кейсами и numanni миру ющие содержащий то есть таким образом мы этим роутером можем покрыть любой модуль с любым view контроллером будь то там обычный контроль юный гей шим контроллер или табор так выглядит вообще переход роутер говорит своему обработчику переходов сделай например отменяем эй переход и передает туда параметры на какой viewcontroller и с каким стилем там пуш или модальный например вот сам обработчик переходов сразу делать переход не должен потому что нужно найти самый верхний модуль за это отвечает transitions координатор и обработчик переходов говорит ему сделали для меня переход передает те параметры которые получилось роутера и передает сам себя вот координатор может проверить кто его просит анимирую щи и лисы или контейнер обработчик если они миру счета он сразу поищет по истории если контейнер то он поищет среди видимых обработчиков возьмет историю каждого из видимых обработчиков найдет ту которая больше всего переходов и тем самым найдется самый верхний анимирую щий обработчик и только тогда скажет ему запустить анимацию собственно только на этом шаге произойдет pushviewcontroller например вот на этой схеме нет ни одного viewcontroller а есть только обертки над ними таким образом если мы добавим новый контроллер схема не изменится а это значит что мы победили down касты он взглянем ещё раз на базовый роутер потому что в нем есть недостаток он сейчас не может закрывать свой модуль потому что у него нет ссылки на обработчика переходов который совершил переход на модуль с этим роутером но и ссылка на своего обработчика переходов но тот еще переходов не делал и более того не делал переход на модуль роутера поэтому добавляем ссылку слабую на показавшего обработчика переходов и теперь роутер может закрывать свой модуль как можно закрыть свой модуль допустим был роутер один и он совершил переход на модуль с роутером 2 у каждого из них есть свой обработчик переходов которые кстати равны только тогда когда это пуш аналогично тому как у двух контроллеров спадает новейшим контроллер а если мы делаем модальный переход то у них разный шим-контроллер ужасный обработчик и роутер 2 хранит ссылку на 1 обработчика как на показавшего его вот и чтоб вернуться на первый модуль есть два варианта либо роутер 1 говорится своему обработчику вернись на мой модуль либо роутер 2 говорит тому же самому обработчику закрой мой модуль передав то свой идентификатор возникает вопрос какой же этих методов лучше использовать допустим посмотрим flow из приложения авито пользователь смотрит объявление и хочет уточнить географию поиска и например есть список всех городов search баром наверху когда пользователь выбирает город происходит обратный переход на фильтр и к примеру мы сделаем так что модуль городов говорит своему роутеру закрой наш модуль мы возвращаемся на фильтр вот все работает но однажды приходит менеджер и говоришь что теперь у нас все усложняется у нас появляется фильтр города теперь и сгруппированы по регионам и только когда ты выбираешь регион ты получаешь города этого региона и теперь чтобы вернуться на фильтр нужно миновать экран регионов за один переход и предыдущий код работать не будет нам нужно чтобы города сказали модуль регионов я закончу модулю региона сказал бы модуль фильтра я закончил и только тогда модуль фильтр ск модуль фильтра сказал бы своему роутеру вернись на фильтр таким образом можно сделать вывод что вернись на модуль всегда гибче чем закрою модуль потому что удобнее рефакторинг но в то же время нужно проставлять лишние зависимости между модулями там вот через модуль out put on предварительные итоги от того о чем мы поговорили мы выделили свой роутер выделили слой ассамблей ки сделали два базовых класса роутера и поддержали айпад и мастер detail случае например на айфоне сделали простой роутер тем что добавили фасад абстрагировались от ее кит подготовились поддержки сверкать и контроллеров подготовились к поддержке deep линков хотя бы в базовом варианте когда нужно когда нужно показать новый контроллер где-то там наверху и обсудили подходу к выполнению обратных переходов предлагаю закрепить это небольшим дыма этот написал одно приложение на iphone и айпад работает но сама навигация на них выглядит немножко по-разному вот например приложение на iphone здесь есть список категорий похоже на приложение авито текущие вот айпад тут есть мастер detail тут слева список категорий а справа placeholder на экран который ничего не делает так заглушку просто выбираем категорию на айфоне происходит пуш на айпаде происходит push мастер пока все похоже дальше iphone делает push айпад делает сэт detail переход не отменяем и есть нет обратной кнопки он ту же здесь становится понятно что у нас один перри используемый viewcontroller и два роутера которые сильно меняют тип навигации на разных устройствах посмотрим второй этап здесь модуль который показывает сам себя просто для усложнения тестов на и пойдем показывать по поваром она и фоне вот такой необычной анимашка чтобы сделать такую необычную анимашку роутер нужно было написать не просто презент model-view-controller а с дополнительным параметром аниматор там , аниматор : они матар таким образом мы можем легко поменять анимацию перехода в том же декларативным стиля вернемся на 1 модуль на список объявлений еще некоторых объявлений ей замочки потому что они требуют что пользователь авторизовался допустим мы нажимаем на такое объявление видим окно авторизации и она во-первых показано в виде форма счета там опять же применен кастомный аниматор и во-вторых она показана корневым модулем приложения допустим мы нажимаем войти исходит переход на экран объявления нажимаем то же самое на айфоне здесь во-первых произошел push хотя переход тоже из корневого модулю приложения нажимаем войти попадаем на экраны объявления на айфоне вот пока все похожие прикольно но это не единственный способ как им можно показать экран авторизации как я уже говорил если у нас истекает сессии то нужно подтвердить пользователя я здесь сделал это через симулирование предупреждения нехватки памяти и мы видим просто так возник экран авторизации но он ничего не делает просто пустой и проверим что произойдет если у меня уже есть окна авторизации и я показываю второе на деле осталось остался только один модуль авторизации но у него перезаписал всяком плюшем блок поэтому кнопку войти теперь ничего не делает она из второго случая таким образом я смог добиться того что у меня всего лишь один viewcontroller вместо двух потому что я проверил если у меня контроллер авторизации в истории перейдем на и так выше и первое что проверим это видно ли экран авторизации поверх верхнего модуля напомнил он показывается из корня приложения и до его видно все работает код там просто покажем отдельный контроллер он показывается вот во вторых я тут сделал второе необычное предупреждение вернее event это шейк жест когда вы потрясли устройства и тогда приложение показывает плашку push-уведомления в котором есть debling перехода на экран категории допустим я нажимаю и этот переход опять же сделан корневым модулем приложение можно здесь еще раз будет следующий экран рекурсии еще раз категория не по кругу идут на айфоне все тоже самое только переходы сделаны модальным образом нечто есть еще можно интересно и заметить мы видим здесь появляется третий экран категорий который очень похож на вариант с айфоном потому что он два раза пушит но на самом деле они отличаются а именно тем что пушит они разные списке объявлений на айфоне происходит модели переход она и поди происходит по power почему они действительно так все ведут по разному потому что этот роутер когда хочет перейти на модуль объявлений он бросит собрать айпад версию модулю потому что это ipad роутер а этот модуль когда просит ассамблей q собрать модуль объявление просит собрать ему iphone модуль таким образом у нас под каждый вид роутера появляется один новый метод в ассамблея и последнее что я хочу показать в дымке это экрана объявление здесь есть бог рекомендуемых объявлений в котором есть все время фруктики или ягодки они все время одинаковые например открываем яблочки открываем бананчики яблочки бананчики яблочки бананчики итак можно бесконечно делать на айфоне а потом пользователю будет все время нажимать кнопку назад эта проблема решена на япония следующим образом допустим я перехожу на яблочки на бананчики и хочу еще раз перейти на яблочки я здесь сделал так что система навигации может проверить расстояние до предыдущего модуля яблочек она видит если расстояние равно 1 то делать обратный переход от вместо этого вместо копирование происходит обратный переход от в то же время если я еще один экранчик добавлен пример вишенки и хочу открыть яблочки-то переход произойдет потому что расстояние уже больше чем один вот еще можно открывать разных экранчиков и смотрите как мы будем возвращаться назад ананасики яблочки вишенки это уже практически новая игра fruit кит можно назвать вот это все что я хотел показать в рамках дыма давайте поймем что мы там увидели на этом дема во-первых мы увидели что есть один viewcontroller и много роутеров то есть мы перри использовали один код от копировали другой но на самом деле отличается между собой показывая разные модули и проверка на какое устройство нас сейчас на экране ipad или нет больше не нужно почему потому что iphone роутер просит ассамблей q собрать iphone модуль а ipad роутер просто сам блейку собрать айпад модули все единственное где вам нужна проверка на и за ipad это победили готти когда вы создаете самый первый ваш корневой модуль вот в чем тут плюс в том что это хорошо сказывается на тестируем асти под локоть проверку на девайс идиомы достаточно проблематично а тут вы из коробки избавляйтесь от этой проблемы от вторых мы увидели поиск верхнего модуля на примере того как авторизация показывается наверх как deep линьки показывается всегда в самом верхнем модуля и как показываются плашки push-уведомлений плюс мы увидели что можно проверить наличие модуля в истории показав только один модуль авторизации проверили модули на дубликаты на примере фруктиков и чуть-чуть и видели в действии кастомные аниматоры переходов сейчас зайти сделай еще раз слайд хотел фотографировать хочу вам сказать несколько общих советов по тому как вы будете строить ваш навигационный стек во-первых выделите слой роутера он должен отличать отвечать именно за стиль открываете роутер видите pushviewcontroller вы понимаете какой стиль больше у вас ничего не интересует выделите слой ассамблеи чтобы она собирала с экземпляры слоев и поставляла зависимости во первых этот код можно переиспользовать во вторых когда-нибудь нас есть те появится ди ай и вообще все будет прекрасно будет легко ли factory абстрагируйтесь ваше утро ты ее kit таким образом вы сможете легко подержать новые страты эти контроллеры и вообще вошел просто будет выглядеть проще описываете все переходы в декоративном стиле а всю логику касательно поиска топки контроллер и принятии каких-то решений выделите в отдельный слой и используйте вернись на модуль вместо закрой мой модуль а ты еще одно это система навигации называется маршрут мы буквально вчера выложили ее ноги т'хаб также мы выложили дыма которые вам сегодня показывал она написана на свифт и вайпер по архитектуре очень напоминает приложение vi то советую вам его посмотреть от касательно маршрут попробуйте там попользуетесь сделаете это несколько фичи request of напишите пару тестов наше тесто там уже есть несколько ссылок на докладчика на этом все у меня спасибо за внимание привет слышал пару недель назад вот рассказывала видна ваша другая команда про апликэйшен координаторы если я не ошибаюсь вот там основной акцент то что они легко могут менять flow то есть переставлять местами вот эти вот контроллер не контроллер даже получать модули наверное во славу приложение от вас есть такая или вы мышц креститесь подходи как ты file system in stroke но у них вообще на самом деле идея была в том чтобы связи между модулями были непрямые а через посредника что просто данные прокидывает в посредника вот на самом деле код роутера очень простой pushviewcontroller томасом блейка берется и возвращается вот код кстати на экране примерно такой взять и поменять местами один контроллер другим это просто взять скопировать эти пять строчек кода в другой класс и все готово единственное что у них действительно решается это передача данных вот допустим если вы из одного роутера передаете айдишник следующий а потом из следующего передаете а уж никак не словарик и так далее то вам приходится много чего переделывать если вы меняете местами контроллера но если вы делаете прокиды вание данных из презентер а какой-нибудь промежуточный модуля output и потом достаете их оттуда же то поменять местами экрана вообще ничего не стоит спасибо такой вопрос вы ищете самый верхний контроллер правильно понял по тегу с которым было произведено на него на него переход так а такая ситуация во первых этот трек ангельского случайно при переходе или мы сами в руками задаем но осмотрите вы делаете вот выдавайте pushviewcontroller derive from вам дают семечко роутера залаз и вы все что должны сделать это передать его в конструктор следующего роутера то есть вам вообще не нужно заботиться навигационной связи так это этот идентификатор до генерируется создается новый обработчик переходов если нужно создается навигационный контроллер все это за друг с другом связывается и запаковывается семечко роутера кей тогда такой вопрос вот опять же определение того контроля козлович который сейчас самый верхний да в том случае когда у нас на айпэде два контроллера одновременно потом предположим в правом контроллеры мы показываем какой то еще попап а после этого пользователь у нас в левом контроллер начинает переключать экраны несмотря на то что в правом у нас уже ну дерево переходов выросла дальше и то есть мы возвращаемся на какой-то предыдущую ветку и начинаем новую ветку переходов и вот как тогда понимать просто не всегда же с верхней контроллер тот контролю с которым будет взаимодействовать пользователей но вот если папа потапа power to всегда вы не можете здесь ничего сделать не закрыв попой да но у нас тут 1 марта только переходы когда у нас появляется контроль который перехватывать на себя все взаимодействие пользователь а если у нас будет ситуация когда пользу все таки может взаимодействовать с контроллерами которые обновляли стоит только сейчас до мастера detail ну вот этих детей мы перейдем сейчас там на какой другой фрукт да но смотрите я сейчас показываю плошку push-уведомления и перехожу откуда она перейдёт в мастер лиге trefl такой вопрос да да да но я просто захар отходим что переход был в detail если это кому-то понадобится то можно это заказ там айзек но вообще на самом деле можно эту проблему решать получше на уровне превенторов или на уровне сервиса который вообще будет следить за всеми двигаться и помимо этого вот например у вас вы хотите чтобы какая-то часть переходов была отменена прежде чем произошла обработка тип ленка да ну основное желание до которых и чтобы не было какого-то глобального такого глобального класса который отвечает за всю логику и знает обо всех экранах и всегда и в любой момент может сказать где чего должно произойти то есть вот вы говорите то что может создать какой-то класс общей логикой до который будет непосредств каждая ситуация разруливать сам но он разрастется до есть у нас приложение там пару десятков экранов этот класс он будет в каждый момент он будет просмотреть что они и сейчас находится на экране также точно кастовать смотреть какой конкретный экран должен в этот момент обработать внешнее событие мне кажется очень сложно класс получится нет смотрите если у вас вот like которую я написала на по дефолту делает одно и то же она не зависит от того сколько у вас переходов но если у вас вот есть и кранчик на котором нужно как-то по-другому пахан лети по другому открыть никак вот обычно за счет сделает детей а вам нужно чтобы он открыл на каком-то конкретном экране по-другому то вы можете перехватить там обработку deep линков и просто сказать своему роутеру сделать такой же как бы переход и он сделает его в нужном для вас стиля до но а в твоей ситуации смотри предположим то что в этот момент до когда у нас сработал шейк нету экранный detail то он запушит вот как здесь на айфоне просто кого в единственный экран вот у нас навави то реализовано более сложная обработка deep линков допустим у нас здесь открыт модальный контроллер и нам нужно перейти на экран рекурсии не просто так а закрыть его там сделать несколько обратных переходов например учитесь на фоне показывать закрыть модальный сделать обратный переход пока у нас не появится там бар и только тогда перейти на табор например у нас это реализовано так ассамблей к которая собирает модуль она получает от предыдущего роутера роутер хит там есть те самые вещи по которым можно идентифицировать модуль там есть идентификатор переходы обработчик переходов вот и она просто говорит там сервису который у нее за injection зарегистрируем модуль там такого то типа и сын ума например модуль рекурсии и придает эти параметры и там вычисляется у нас под какой-то подходит эти параметры под 1 ли под 2 и соответственно когда происходит обработка тип ленка у нас на именно на нужном тоби отменяется нужное количество переходов до тех пор пока виден табор не станет сам лейка не просто говорит зарегистрирую она говорит видим табор на этом модуле или нет вот этот сервис он на самом деле тому же самому обработчику переходов говорит одну строчку отмени переходы после такого тут не секатора сам решает какой из них последний на котором на последнем был виден табор спасибо все вопросы больше не будет тогда же всё спасибо тимур"
}