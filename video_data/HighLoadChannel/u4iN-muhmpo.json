{
  "video_id": "u4iN-muhmpo",
  "channel": "HighLoadChannel",
  "title": "Классические архитектуры во фронтенде / Александра Шинкевич (LOVATA)",
  "views": 6763,
  "duration": 2175,
  "published": "2017-04-22T14:47:59-07:00",
  "text": "Всем привет. Меня зовут Шенкевич Александра. Вы меня должны помнить, потому что я вчера бегала с микрофоном, объявляла докладчика вот в той половине зала. А сегодня я хочу вам рассказать о классических архитектурах во фронтде. А а давайте немножко тоже ещё раз разомнёмся. Кому из вас, а, знакомы вот эти вот понятия? О'кей, отлично, это очень хорошо. А кто из вас пишет на каком-нибудь фреймворке? Ну, людей поменьше. О'кей. А, тоже неплохо. Сейчас будет слайд. Я не буду рассказывать сегодня про вот это, но в процессе прогона меня просто попросили сюда вставить этот слайд, поэтому пусть он тут останется. А, а есть ссылка. Я буду показывать сегодня примеры. К сожалению, не в той полной версии, в котором они в которой они есть по ссылке. Это ссылка на GitHub, а где можно увидеть, собственно, презентацию, ссылку на источники, а, и сами примеры. Так что, если кому-то интересно, я сейчас остановлюсь, можно перейти и следить более полно. О'кей. Отлично. 1 2 3. А, погнали дальше. Начну я с примера. А пример, как и во всех архитектурах, которые я буду показывать, это простой пример. Это to Application, которая реализует всего лишь две функции: добавление и удаление элемента и списка. Для добавления есть, а формат, и для удаления всего лишь нужно кликнуть по чекбоксу. А как мы это реализуем, если мы не хотим использовать какую-нибудь архитектуру? Мы вот простые фнд разработчики, мы не знаем никаких фреймворков. Для начала нам, естественно, нужно разметку объявить. А в Джесе мы сделаем что-то примерно типа такого. Объявим два, а обработчика события, ну и как-то обработаем а данные. А если нам нужно добавить синхронизацию сервером, отправку данных туда, возможно, нам придётся реализовать что-то типа такого, то есть получить данные из HTML, как-то их преобразовать и потом уже отправить на сервер. А у такого подхода, естественно, есть свои недостатки. А и первый недостаток - это то, что данные хранятся непосредственно в дом. И для того, чтобы их обрабатывать и как-то отправлять на сервер и потом показывать пользователю, а необходимо писать функции, которые будут эти данные преобразовывать в нужный формат, вставлять в разметку, обновлять эту разметку. Это довольно долго и неудобно. А если данные представляют из себя какой-то объект или даты, например, а в моём примере проблема не стоит так остро, так как я всего лишь оперирую массивом строк. Но если это разветлённая структура, а как и это какая-то информация, которая состоит из нескольких полей или это большой массив информации, то это уже становится очень неудобно, и функция, которая обрабатывает эти данные, становится большой громозкой, и задача обработки таких данных совсем не тривиально. А и вторая проблема, которая, в принципе, есть в джаваскрипте - это вариативность синтаксиса. В моём примере вот этом быстреньком, аа обработчики событий объявляются в джаваскрипте. Однако, а JavaScript также, вызов функции JavaScript можно также объявлять и в HTML-разметке. А если мы не используем архитектуру, также можно по-разному писать один и тот же код. И когда в команде находится несколько разработчиков, то, естественно, у всех уже есть какой-то стиль, им нравится писать так или иначе. И вот этот вот подход, он иногда, а, очень затрудняет разработку, если стили написания кода некоторых разработчиков очень сильно отличаются. А для для того, чтобы решить частично вышеперечисленные проблемы и существуют архитектуры. Сегодня я буду говорить о архитектурах семейства MV. А и главное, основное понятие, которое они, а, несут в себе - это такое понятие, как separation of concerns. На русский это понятие переводится как, а, разделение ответственности или разделение зон влияния. Что оно означает? А это означает, что мы мы намеренно разделяем наш код а приложений на какие-то части, которые отвечают только за что-то одно. Допустим, часть отвечает за данные, часть за их обновление, а какая-то часть кода отвечает только за то, чтобы отобразить пользователю эти данные. А и то, как какие именно это части и как они между собой взаимодействуют и называются, собственно, архитектурой. А что помогает, какие проблемы помогает решить архитектура и какие преимущества её использования? Ну, во-первых, самое большое преимущество - это определённая структура. Аа, как правило, архитектура приложения, если вы какую-то конкретную архитектуру выбираете, у вас а уже должна, а, должна быть определена структура не только самих компонентов, на, на что делится приложения, но зачастую архитектура вам может диктовать и то, как организован код, а не не только взаимодействие кода, но и, допустим, даже файловая структура. А, естественно, намеренно разделяя наш код, мы повышаем его модульность, а, и дробим на какие-то более мелкие части, которые легче, удобнее поддерживать и развивать. А из второго пункта, естественно, следует третье - это переносимость кода. И разделив на какие-то отдельные маленькие компоненты, вам намного проще переносить код из одного проекта в другой, если вам необходимо тот же модуль в нескольких приложениях. А повышается, естественно, масштабируемость, так как а мы, написав правильную, спроектировать правильную архитектуру на 10 компонентов, мы вполне легко можем её расширить и на ещё 90 компонентов. А, и, естественно, мы повышаем тестируемость, так как маленькие кусочки кода намного проще тестировать, чем большую простынь, где совершенно непонятно, какой, а, какая часть кода за что отвечает. А в связи с этими при А что хотелось ещё добавить? А то, что вы используете какую-то архитектуру, отнюдь не означает того, что у вас есть все эти преимущества. А, к сожалению, если вы начальном этапе, а, неправильно выбрали архитектуру для вашего конкретного приложения или неправильно следуете, а, структуре этой архитектуры, то вполне возможно, какое-то из этих преимуществ у вас не получится получить. А, MVC, а, как и все архитектуры, про которую я сегодня буду рассказывать, она состоит из трёх компонентов. А первый компонент - это модель. А модель включает в себя как описание структуры данных, которые хранятся в приложении, так и методы работы с ними. А хочу заметить, что описание и конкретная реализация модели, а, иногда намного больше влияет на то, как у вас будут реализованы остальные части приложения, чем даже, в принципе, выбор какой-то конкретной архитектуры. А вторая часть архитектуры MVC, это View или представление. Его ещё иногда переводят как вид. А оно отвечает за отображение. В отличие от двух других компонентов, аа View представляет собой не только JS-код, но также в него включены ещё HTML-разметка и CSS-стили. И третий компонент - это контроллер. Его функция - это осуществлять контроль за а потоком данных из представления в модель. как эти компоненты между собой взаимодействуют. Допустим, пользователь нажал на кнопку на экране в браузере. Представление, естественно, отловило это событие и сообщило контроллеру о том, что произошло событие нажатия на кнопку. Контроллер, а, сообщил модели о том, что ей нужно обновить какие-то данные. А модель никак не связана со всеми остальными компонентами. И единственное, что она может делать, помимо того, что она хранит данные, их каким-то обм каким-то образом обрабатывает, она может, а, триггерить события о том, что в ней что-то изменилось. А, соответственно, когда данные модели изменились, а модель, а, выстреливает события о том, что у неё изменились данные, и на это событие подписано представление. А представление знает о том, какие методы есть у модели, и обращается за получением новых данных. Модель отдаёт эти данные, представление их каким-то образом вставляет в разметку. отображает для пользователя. А если включить в эту схему какую-то синхронную модель, а и для чего вообще в принципе а хорошо, что модель изолирована? Допустим, данные пришли с сервера, нужно обновить эти данные, они пришли не отльзователя, который нажал на кнопку, то а модель посредством триггеринга событий сообщает о том, что данные изменились и а представление, естественно, вот по все той же схеме получает, обновляет свои данные. А также модель сама по себе может изменять данные. Ну, допустим, там через каждые 10 секунд или n единиц времени ей нужно менять какие-то счётчики, перегенерировать состояние, и при этом это всё такая же асинхронная модель. А давайте пример. Ну, для начала нужно, естественно, объявить разметку. Как вы видите, а HTML-код здесь просто огромный, а, большой компонент, который нужно объявить, много классов. А стандартное сейчас JavaScript SPA приложение. А, о'кей. Что здесь есть ещё? Есть объявление пяти, а, JS-файлов. А самый первый первый верхний файл называется. А он необходим для того, чтобы реализовать полифил кастомных ивентов в джаваскрипте есть спецификация, которая позволяет создавать эти кастомные ивенты, а, в браузере, не привязываясь к элементам дом, как мы, ну, обычно привыкли, но, к сожалению, не во всех браузерах работает, поэтому приходится использовать полифил. А дальше у нас есть модели, представления, контроллеры и файл upjs, а, в котором осуществляется точка входа в приложение. Файл очень большой. В нём всего лишь объявляется контроллер. А контроллер. В контроллере инициализируется модель и инициализируется представление. Обратите внимание, что при инициализации модели представление в представление в него передаётся инстанс модели для того, чтобы представление знало о том, какие методы есть у модели. Ну и, естественно, а создаются колбейки на события от представления. В представлении, в свою очередь, объявляется какая-то структура разметки, а затем осуществляется подписка на события. И два публичных метода, которые на прошлом слайде вызывались - это непосредственно непосредственно а ивентхендлеры. модель представляет собой всего лишь структуру данных, которая сама по себе сохранит структуру данных и, а, имеет какие-то методы. В нашем случае это получить все элементы, добавить элемент или удалить элемент. А при необходимости аа генерации события в каком какой-либо функции моделей после того, как данные были изменены, необходимо это вызвать это событие. А демашка о появилась. Так, ладно, гулять-то гулять. Вау, оно работает. MVP. А отличие А MVP вообще - это продолжение развития идеи MVC, только а в нём ещё больше отделяется представление от модели. А вместо контроллера здесь объявляется presenter. Первые два элемента в нём такие же, как в MVP, такие же, как в MVC. Я не буду на них останавливаться подробно. А Presenter осуществляет управление уже двумя остальными элементами. А как это работает? Допустим, опять пользователь нажал на кнопку, представление отловило это событие и передало о том, что это событие произошло презентеру. Презентер обращается к модели о том, что ей нужно обновить какие-то данные. А модель посредством всё той же асинхронной, а асинхронного триггера ивента сообщает уже презентеру, а не представлению о том, что какие-то данные изменились. Презентер запрашивает необходимые данные, модель отдаёт эти данные, и презентер передаёт эти данные представлению для того, чтобы оно отобразило новое состояние пользователю. А опять же асинхронная модель. Если данные изменяются в модели, то аа сервер, то модель, а триггерит ивент презентеру. Презентер запрашивает данные, а эти данные обратно передаются и а презентер и презентер передаёт их модели, представлению, а для того, чтобы оно отрисовало это пользователю. А пример MVP, так как уже есть реализованный пример MVC и мы знаем, в принципе, чем отличается MVC от MVP, то намного проще, конечно, реализовывать эту модель, а имея какой-то бэкграунд. Итак, что же нужно изменить? Во-первых, нужно перенать переименовать файл controllers presenters, а во-вторых, инициализировать presenter, а не контроллер. В-третьих, нужно при инициализации представления передать просто данные, а не а инстанс-модели. Ну и, естественно, перенести из представления регистрация событий, подписка на события от модели. А в модели же нужно добавить один публичный метод для того, чтобы презентер знал, как через что обновлять модель. Live демо. Вау, она тоже работает. Спасибо. А, MVVM. А, в ней, в этой архитектуре также три компонента, хотя в ней четыре буквы в названии. И третий компонент называется View Model. На русский его переводят по-разному. У меня на экране написано как модель представления, но ещё в литературе можно встретить вид модели или вид-модель по-разному. Ну, лично мне нравится называть её так, как она есть на английском View Model для того, чтобы более про лучше понимать, что это компонент именно вот view model, а не VW или model. А, говоря о VVM, нельзя не сказать о таком понятии, как связывание данных. А связывание данных - это механизм, который позволяет, а, моментально, а, изменить, а, состояние данных в модели, если они были изменены в представлении и наоборот. А, соответственно, как компоненты взаимодействуют между, а, друг другом. Когда пользователь каким-то образом меняет данные в представлении, они сразу же моментально, а, попадают в View Model. И там нету каких-то механизмов, которые передают колбеки. Это уже вот просто вот они данные, они одинаковые. А View Model, в свою очередь говорит модель о том, что нужно изменить данные. А модель посредством всё той же, а кастомного события сообщает Vmodel, а о том, что данные изменились. View Model запрашивает новые данные. И когда в тот момент, когда новые данные попадают во view model, они моментально отображаются пользователю. Пример MVV. А, как вы видите из слайда, а я не продолжила тот же паттерн и реализовала свой пример. Почему для этого была причина, на самом деле? А дело в том, что архитектура MVVM очень сильно, а, зависит от того, каким образом реализовано связывание данных. А, к сожалению моему, а в джаваскрипте нету нативного вот вот прямо на уровне языка вот этого связывания данных. И его необходимо а даже не полифилить, просто реализовывать. И вот эти реализации, они уже, естественно, есть в различных фреймворках, они довольно сильно различаются. И, в принципе, а, реализовав связывание данных, вы, наверное, можете сказать, что вы реализовали MVV. А, соответственно, писать свою реализацию, а, было просто непрактично и как бы проще намного использовать фреймворк какой-то готовое решение. А почему был выбран Framework Knockout? Это Open source Framework, который реализует MVVM, а, и связывание данных. А почему был выбран именно он? Потому что из аналогов MVVMфреймворков у него, наверное, самый один из самых простых синтаксисов. Его проще просто понять, глядя на код. А, какого-то простого веб-приложения, даже не знаю вообще о том, что что такое нокаут, какой у него синтаксис, вообще что-то. А аналоги MVVM фреймворков есть, это Bкбон, Angular, самые известные, наверное, фреймворки MVVM. А, итак, HTML разметка. Естественно, уже появляется HTML-разметка непосредственно в BДИ. А, и вместо пяти файлов, которые подключались до этого, подключается всего два. это сама библиотека анокаут и объявление View Model. А разметка тоже не так проста становится. В ней, естественно, появляется а специальный синтаксис, который объявляет о том, что эта разметка связана с элементами и компонентами в джаваскрипте. А что здесь есть? дата атрибутами объявляется о том, что по сабмиту формы будет добавляться итем, аа итеративно выводятся элементы списка, которые а показывают список дел в нашем приложении. А привязывается по клику удаление элемента и непосредственно вывод текста названия, а элемента списка. А View Model а также не представляет из себя чего чего-то сложного. В ней всего лишь объявляются, а переменные, которые хранят непосредственно данные в нашем приложении. А в моём примере это список элементов и элемент для добавления. А они представляют тип их специальный observable стиль тип а самого а нокаута. Но в принципе разобраться с этим было несложно. Я пример свой написала минут, наверное, за 10. При том, что большая часть у меня времени ушла на то, чтобы вообще посмотреть, как написать, а биндинг. И, естественно, а объявляются функции добавления, удаление элемента. И в конце нужно, естественно, инициализировать а view model. Пример. Всё тоже работает. Я ещё раз повторяю, что в конце будет ссылка ещё раз на репозиторий. А можно все эти примеры открыть, посмотреть, поиграться, посмотреть более полную версию кода. А, итак, что же выбрать? Ну, если а естест если, а, можно реализовать или использовать связывание данных, естественно, это MVV. А есть такой парадокс, на самом деле, с MVVM. Для того, чтобы его вот реализовать с нуля до какого-то каркаса, который вы можете использовать в своём приложении, вам нужно потратить довольно много времени на это. И в принципе то, как вы вот реализуете вот именно связывание данных, и, в принципе, определит структуру ваше вашей архитектуры. А при этом из всех всех рассказанных сегодня мною архитектур- это самая, наверное, простая а и удобная для разработчиков архитектура. А мы годами пишем обработчики событий, а каким-то образом постоянно обновляем данные пользователя на в браузере. А MVVM позволяет это делать намного более просто, чем остальные архитектуры. Если нельзя использовать свя связывание данных, лучше всего использовать MVP. В нём прекрасно, если правильно спроектировать архитектуру, прави прекрасно изолировано представление о то, как отображаются ваши данные, непосредственно то, как они хранятся и обрабатываются. И если нужна в любых других случаях или нужна э связь представления и данных, то можно использовать MVC. А интересно, что аа в очень часто путают MVC и MVP, говоря о том, что вот у нас есть MVC архитектура. По факту это MVP архитектура, так как представление там довольно сильно изолировано от данных. А что можно почитать на эту тему? А у в списке литературы есть даже книжка. Это книжка Эди Османи, довольно известный фронтнд-разработчик, он в Гугле работает. А он какое-то время назад очень сильно а интересовался этой темой архитектур во фронтенде, классических архитектур, а и писал много статей. Здесь вот представлена одна его статья и книжки. Ну, в общем, если интересно, можно реально почитать. Книжка есть на английском, она в бесплатном доступе, по-моему, на сайте Safari Books. В общем, можно просто брать, читать. А, ну, вместо вывода. Последнее время архитектуры на фронтде всё усложняется и усложняются. Появляются фреймворки, инструменты, то, что помогает нам, а, делать нашу работу быстрее, проще и удобнее. Однако у нас, как у разработчиков, не всегда есть время на то, чтобы капитально разобраться, что же именно под капотом у тех или иных инструментов, которые мы используем. И, как мне кажется, это довольно, а, довольно часто причина того, что мы строим неправильные архитектуры или неправильные архитектуры для конкретного проекта или не пониманим, как нужно правильно организовать и структурировать наш код. Так, собственно, давайте знать все эти понятия, давайте писать правильной архитектуры, писать чистый, красивый код, и, как мне кажется, наш мир фронтенда станет чуточку лучше. Спасибо за внимание. Спасибо за доклад. Да, я что понял? Вы по реакции слушателей сразу проснулись. Я хочу сказать, что Андрей стойкий человек. Он слушал, смотрел, как как я пыталась сделать из того, что у меня было, нормальную презентацию. Спасибо ему. Вопросы. А была оговорка, чтобон - это MVP. Здравствуйте, меня зовут Вадим. Хотел спросить, это оговорка была или что-то изменилось, чтобы Бон стал MVMмм? Ну, на самом деле, я не Ну, вроде бы MVP. А на самом деле насколько MVP? Ну, возможно. Я смотрела в списке того, какие форморки. Я не знакома с Бэкбоном, не писала на нём, но в списке того, что это MVV, он был вот прямо выше Ангуляра, правда. А, ну да, в принципе, а на самом деле чисто классическую архитектуру, ну, довольно сложно реализовать. Возможно, это какой-то гибрид. Вполне. Я уверен, что я даже читал книжку Гаррит - это бонбоём. Совершенно нет сомнений, чтобы бывает. Ещё вопрос. А в теории это, конечно, всё хорошо, но в реальной жизни так получается, что использовать что-то одно, в принципе, почти нереально. даже внутри одного приложения всё равно где-то в кусках такое используется, в кусках такого-то. Те же компоненты, они сами по себе являются скасками. Вот с точки зрения вот именно А то есть у вас такой очень обобщённый был вывод по поводу, что лучше использовать, а вот именно с точки зрения не возможностей, а кейсов, как лучше использовать конкретные вещи? Допустим, когда, скажем, представление более-менее сложно, то есть у нас есть часть данных, которая нужна серверу, а есть часть данных, которые отвечают только за визуализацию, например, там хайлай или что-нибудь такое. Вот в таких случаях что лучше использовать? Ну, не знаю, лично вот мне кажется, что MVVM довольно, ну, вот этот вот механизм связывания данных, он позволяет, а, намного вот тот механизм рендеринга какого-то интерфейса. Вам нужно намного меньше писать кода, чем, и, не знаю, если правильно, как правило, вы же не выбираете там, я вот реализую вот этот этот проект новый, а то на MVP, вот мне захотелось. Так, вы обычно выбираете фреймворк, на котором вы хотите это реализовать. Ну ведь правда же. И а фреймворк выбирается в соответствии с задачами. А это может быть какой-то Ангуляр, это может быть тот же Bкбон с какими-то там настройками, а вполне каус JS, да, а или react с какими-то наворотами, так как - это в принципе не фреймворк, это библиотека только. То есть вот моя главная мысль в том, что помимо того, что нужно знать что под капотом, нужно, а объективно и чётко понимать, какие задачи перед вами ставятся, и в зависимости от этого выбирать. А ещё хотел задать один такой вопросик. С какой подход с точки с вашей точки зрения более подготовлен к внезапной изменения архитектуры и пониманию, что всё, что делалось до это немножко не то и нужно чучуть переделать? А я на самом деле у меня есть печальная история о том, как не надо делать и строить архитектуру приложений. А где-то год назад я пришла на проект, который уже длился какое-то время, и там архитектура была простыня кода на QUERY. В общем, а там где-то на пятом или четвёртом месяце мы дошли до того, что у нас один большой файл где-то 2.000 строк кода. И в общем, это поддерживать было фактически невозможно. И просто нам пришлось принять решение переходить на что-то другое, переписывать приложение. У нас ушёл месяц то, чтобы просто переписать существующие решения. Так делать очень плохо, я понимаю, но а смысл в том, что нужно заранее думать, что вам нужно. И, ээ, если у вас гибко, хорошо написана архитектура, вы примерно в начале представляете, что, да, вот заказчику нужно это, но основываясь на опыте разработчика работы с заказчиками, вы примерно там можете вот как бы ему, может быть, вот это понадобится и а проектировать и писать свой код с учётом того, что возможно здесь будет расширение. Это всегда, мне кажется, правильный подход в том, что думать о том, что ваше приложение будет развиваться дальше. А переписывать с нуля, ну как бы если заказчик вначале хотел одно, потом он совершенно другое, ну это, наверное, проблема немножко заказчика. Ну тут ведь дело не только в том, что в отношении заказчик-разработчик. Допустим, у нас внутри компания разрабатывает свой продукт. То есть мы, в принципе, сами, ну, просто мы, допустим, то, что делаем сейчас, мы понятия не имеем, в какую сторону мы пойдём, допустим, через год. И вот с точки зрения именно развития архитектуры, не так, что вот вы изначально знаете свою задачу, сделали, всё хорошо работает, а с точки зрения именно развития и, возможно, какого-то изменения, у вас есть опыт, что удобнее, или тут вообще нет кто-то делал? Тут тут вообще нету серебряной пули. И мне кажется, главная мысль, которую нужно для себя уяснить, то, что нужно, а, думать о развитии и писать, пытаться строить такую архитектуру, которая при, ну, не то что любом изменении бизнес-требований, она сможет как-то адаптироваться, расширяться или вообще немножко переделаться для под ваши, а, нужды. Вот как-то так. Нет серебряной пули. Для этого и у нас множество зоопарк целый фреймворков есть. А здравствуйте. А, спасибо за доклад. Я можно вот слайдик просить? Какой и из а самый первый вот там четвёртый шаг. А я правильно понимаю, что модель imвент и что подписывается тически Да. Дадада. Всё. Ну такое более классическое представление, конечно, привыкшить вещи. Да. Хочу ещё добавить, что, допустим, в бэкэндовой модели MVC вход, э, непосредственно в приложение может осущест может и осуществляться через контроллер, а не через представление. Ну, мы работаем с фронтэндом, у нас, естественно, обработка событий происходит через View. Нет, тут немножко затерялся, не прошёл. А вообще ты нас просит, мы уже обработал интернет-магазина. У нас тоже большие простники четверть года. А и сочувствую искренне, да. Но смотрю на фревки и в основном смотрю это в основном сили, то есть когда закрывается, что бодо нет, его что-то ругают, нельзя так делать и так далее. Вообще вот скажите, а для того чтобы разрабатываем в магазинах там на ПДП, какой фреймворк, какую модель лучше смотреть, чтобы избавиться от прострене кода, тем не менее, чтобы исходный код у нас оставался, что событи были довольны. То есть какой модель по игрок? Ну, ну, на самом деле, а я не очень вообще знакома с этим понятием, но мне кажется, вам стоит копать в сторону серверного рейндринга. Нет, а чтобы вроде бы и то есть, по-моему, и второй ангуляр, и React, они вам позволяют это реализовывать. В общем, у вас уже слишком долго. Вы можете использовать первый ангуляр и с помощью директив расширять интерфейс стандарт стандартной разметки. То есть у вас будет вытьсяваться нечто к тому, что вы привёте, а дальше уже нати это будет разворачиваться в приложении. Или вы можете использовать какой-нибудь ренer i как, ну, это в том числе и локально, они можете себе её поставить, не пользоваться сервисом. Она будет просто прирадовать вашу страницу и всем поисковикам её отдавать по собранном. Никто не будет у вас это проси. Здравствуйте, спасибо за доклад. Предыдущему оратору хотел сказать: \"Возьмите любой фреймворк, в котором есть роутер, и в на классическом сайте вы не будете знать горе\". Вот такой вопрос тоже наведен одним из спрашивающих. А вот во всех этих архитектурах MV там Samsung такая проблема существует, когда А дада. Угу. А, как уже спрашивалось, у вас существуют некоторые бизнес-данные и существуют некоторые данные, которые отвечают за state. Например, если вдоли добавить кнопку и удалять только отмеченные, то появится состояние у чекбоксов. Вот. И существует ли, знаете ли вы какой-то best practices в этом там направлении, как отделять э данный бизнес и от данных состояний, если они и те, и другие лежат в моделях, и как этой каши не допустить? А я не скажу, что я могу сейчас прямо сказать решение, но я просто не копала никогда в эту сторону. И я в свой вообще в принципе флстек разработчик Minн Fullsк разработчик Angular Noa а там, ну, немножко другая, там таких проблем нету. А как это реализовать? Для того, чтобы вам ответить, мне нужно покопать и посмотреть. Я не могу сходу ответить. Давайте опять я отвечу, пожалуйста. Вот вы здесь видели, допустим, model new model, там есть модель, это ваше бизнеслоги, там всё, в принципе, данные хранятся и взаимодействуют, а есть модуль. Вот эта вещь, когда вы можете сохранять как раз-таки состояние вашего, потому что это модуль, модель представления. Вот там и храните все ваши данные вашего представления. А модель - это бизнес. Ну такбон - это точно не viмо. Там можно реализовать. Ну спасибо. Но в классическом таком архитектуре, да, это пятый похоже на вот. Но тут наступает небольшой момент, когда есть ещё одно разделение, то есть данные, которые хранятся, допустим, на сервере, но при этом а необходимое какое-то сохранение состояния, чтобы можно было вернуться. То есть, по сути дела, эти данные вроде бы как не относятся к бизнес-модели, но тем не менее какой-то механизм э синхронизации, например, или восстановления состояния. То есть это всё по идее бизнес-модель идёт, если уже такие требования появляются и или как? А, ну мне кажется, да, это скорее к бизнес-модели, чем к состоянию, так как вы работаете непосредственно с самим самими данными, да, пусть это версионность будет, но это данные. И опять же, от того, как вы реализуете вот именно компонент модели, у вас может архитектура вообще кардинально поменяться. И вы решили написать на MVC, а в итоге у вас получится MVP, и вы придёте к MVPям, в конце концов. Ну, то есть, а они, в принципе, вполне могут как-то гибридно существовать эти архитектуры. А в классической реализации их вот, ну, прямо, наверное, сложно сложно реализовать, особенно на фронтде, так как, ну, мы работаем не только там с генерацией представления, но и непосредственно с обработкой событий с представления. Всё, давайте закругляемся. Большое спасибо за доклад."
}