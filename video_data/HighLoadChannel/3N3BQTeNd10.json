{
  "video_id": "3N3BQTeNd10",
  "channel": "HighLoadChannel",
  "title": "Работа с аренами — почти избавляемся от GC / Максим Горозий (Тинькофф)",
  "views": 153,
  "duration": 2944,
  "published": "2024-10-29T02:57:01-07:00",
  "text": "Максим горозией он расскажет нам про гарбич колектор и что вокруг всего этого можно сделать встречаем Всем привет Как вы видите на слайдах меня зовут Максим по традиции представлюсь расскажу Немножко себе Я работаю мм ВВ Шеки я Достаточно давно я работаю над нашей внутренней платформой образования мска которая служит для разных направлений нашего бизнеса Я даже поставил сердечко о том насколько я люблю это тех потому что я считаю что образование - это прям абсолютный топчик я сам преподавал преподаю и буду преподавать А уж работать над инструментами обучения - это просто бесконечный Кайо я идеологический фанат Гош и ддд также так как я Тим Я люблю всякие процессные штуки на де конфа этим не хвастаются но я просто люблю системы и строить их взаимосвязи неважно это микросервисы или команды Но на самом деле я пришёл порасскажу чистого си потом работал в ged в двух ged конторах где управление памяти занимало не последнее место в оптимизации производительности нашего кода начну я свой рассказ с классической фразы всех программистов оно тормозит тормозить оно может по разным причинам и без медитации нам с этим не разобраться Ну ладно шучу не без медитации без про медици над профан В общем неважно сегодня мы поговорим о том Почему наши программы будут тормозить изза вопросов связанных с управлением памятью управление памяти - это простой кл мы алоем кусочек памяти Где размещаем что-то нам нужное потом как-то это используем что нас не особо интересует как и достаточно интересно вопрос Как нам потом освободить этот кусочек памяти для того чтобы его можно было либо отдать обратно операционной системе есть разные типы управления памяти там всем известно самое классическое это ручное управление памятью Где вся когнитивная сложность того как освободить ложится на программиста Она же в большинстве случаев самая быстрая но нам приходится за это платить Я уже сказал что когнитивная сложность раз второе управление памятью и неверное управление памятью становится чуть ли не главной причиной различных багов в программах и уязвимостей которые находят тестеры где-то посередине есть другие подходы я здесь Для при примера привёл Counter который в котором ранта подсчитывает количество ссылок которые есть на объекты пока их больше нуля не держатся в памяти как только стало нум очищаются практически ВС время на таком подходе чисто Живёт там в перле в первых версиях тоже был только coun и не было сборки мусора Ну и конечно есть языки со сборщиками мусора где разработчику вообще не нужно париться Вообще ни о чём мы просто создаём объекты Сколько нам нужно и верим что оно как-нибудь там очистится есть и там другие подходы там достаточно уникальный подход владения по поводу того когда очистить объекты Ну как уникальный в целом оно похоже на пульсовые смар поте оно всё-таки называется немножко иначе имеет свои особенности ну или к примеру какой-то миксо вый подход в классической тройке скриптовый языков Python ru perel одновременно используется и сборка мусора ин coun вообще даже если мы управляем памятью вручную М это тоже отнюдь не бесплатная операция и авторам и локаторов приходится делать какие-то решения мы либо заранее просим операционной системы побольше памяти для того чтобы не делать лишний сикол Но тогда у нас мы тратим лишнюю не используемую память или наоборот нам приходится делать сколы Почаще в современных операционных системах не так дорог Это одд микросекунды но всё же это в раз в 20 дороже чем просто создать использовать существующую память также нам приходится как-то бороться с фрагментацией и мы либо допускаем фрагментацию ускоряем нашу программу но терпим то что программа будет выглядеть как будто она течёт или нам приходится тратить цпу на какие-нибудь хитрые алгоритмы распределения памяти которые снижают фрагментацию или Не дай Боже на уплотнение памяти что приведёт к ещё большим затратам цпу если мы перейдём к языкам со сборкой мусора здесь у нас две первых пункта два первых пункта остаются такими же но добавляются затраты цпу на собственно сборку мусора чем больше у нас мусора тем больше будет тратиться цпу там о том что немножко рам ещё тратится на сами вот эти воркера очистки на какие-то пометки можно прямо игнорировать и знаменитый ужасный stop the world который требуется выполнять то есть в самых банальных реализациях языков с gc наш программа полностью тормозится на какое-то время чтобы позволить gc спокойно почистить неиспользуемые объекты или там в хороших реализациях тормозятся не весь World условно а отдельные потоки Чем дальше мы движемся в тюнинге gc тем паузы короче но от них вообще никуда не деться они нужны в гошкевича Ну у нас память выделяется большими снами то есть мы избегаем лишних Силов спа под обект под объекты определенных размеров То есть это позволяет нам избежать прям жёсткой фрагментацией и активно переиспользовать освобождённые участки памяти Также авторы языка чётко нас предупредили что если будете много создавать объектов то 25% вашего цпу Будет уходить на сборку мусора может звучать ноно то что 25 цпу у нас будет сверху и как бы можно с этим жить п the world в гошко же минимизации сложно найти другой язык разве что там последней версии джавы с их новым сборщиком мусора большие изменения в этом были в горшке 1,5 Давненько это уже было иде как раз ушли от достаточно банального сборщика мусора который бы в ранних версиях к современному кон Mar СПУ где у нас Постоянно работает граба которая раскрашивает объекты на достижимые недостижимые тогда кажется достигли что-то там пауз при маленьком хи меньше микросекунды и там порядка нескольких микросекунд на больших хих но G планомерно улучшали и в последующих версиях ИС даже с большими хпас имеет субо микросекунд значение ещё наш gc нередко ругают за то что у нас там нету использование поколений то есть Гош gc постоянно обходят все объекты Но на самом деле оно особо нам не нужно не всякие где тиче приводит к его падению в хип у нас большинство короткоживущие вс-таки будут оставаться на стейке и очиститься автоматически но в любом случае остаётся вопрос что если мы поняли что профайлинг увидели что нам что-то мешает сборка мусора и нам нужно чуточку улучшить производительность пром е из семидесятых которые активно исследовали управление памятью на основе регионов на этом подходе даже пытались делать отдельные языки То есть как единственный способ управления и сборки памяти но вроде бы до продо вых оно так и не дошло и осталось в академических работах в статьях об этом обычно не пишут норе что вот B Management мне Очень напоминает СТК То есть у нас есть выделенный кусок большой памяти мы для того чтобы создать новый объект мы никого не спрашивая просто увеличиваем указатель стека на нужное значение помещаем объект готово и то же самое с очисткой нам не нужно там по одному очищать объекты мы опять сдвинули указатель обратно ини почистили все объекты вот э вот фишка того что мы можем маленькими кусочками выделять память а потом забрать её освободить её целиком прослеживается и в аренах то есть логика абсолютно такая же мы пред создаём большие чанки памяти в которых потом мы можем быстро выделить какую-то нашу новую структуру для этого мы просто лам указателю инкремент выделять дальше единственная дополнительная проверка лишь в том что нам нужно проверить не вышли ли мы за размеры уже выделенного чанка как только мы понимаем что вышли мы должны аллоцировать новый чанк как следствие мы все эти объекты которые выделяются внутри арены освобождаем от управления gc о них знает соответственно он о них не беспокоится и мы вручную можем просто убрав указатель первые чанк освободить всё целиком gc достаточно быстро придёт и всё нам почистит ещё из плюсов то что мы обеспечиваем локальность данных что положительно влияет на кэширование процессором самый банане пример который поме Ну используют естественно в реальной жизни в играх вот к примеру мы все привыкли к тому что наши игры будут играться на 120 п FPS и на меньшее Мы не согласны А ещё Мы очень хотим чтобы игры у нас не текли по памяти и не вылетали соответственно языки с gc автоматом сложно потому что тогда пау на сборке мусора могут нас Настич в любой Случайный момент и тогда пользователь точно заметит что что-то не так с ручным управлением тоже не всё гладко если у нас будет сикол прямо в самый активный момент игры опять будет какая-то просадка памяти и пользователи Будут жаловаться что всё медленно и остаётся вопрос с тем как после уровня почистить весь мусор который там накопился А в играх реально даже простой уровень память огромное количество объектов Поэтому вот этот подход с аренами очень даже применим у нас начинается уровень вот у нас большой кусок памяти там на консолях нередко даже делают его фиксировано размера на всю свободную память Мы в этой арене создаём вообще не думая ни о чём объекты Сколько нам нужно мы защищены от си сколов то есть никаких просадок не будет а в конце уровня неважно сколько там было объектов нам не нужно их обходить мы просто Арену начали заново с 120 в Гош у нас появились арены мы можем теперь их попробовать и в своём коде для включения У нас появился специальная переменная Go exper я так полагаю арены пока что единственное что через них включается но Я полагаю будут ровать каки другие жеты использованию или более привычно через битаги которые кстати тот же гон лучше понимает что у нас арены теперь доступны вообще пакет достаточно лаконичный он содержит метод для того чтобы создать Арену и у арены есть ф для того чтобы е освободить для того Наре У нас есть функция для того чтобы нам ровать сй есть опять же заметьте то что оно у нас использует современные дженерики для того чтобы у нас всё было строго типизированного чтобы после освобождения Арены в целом я вам пересказал достаточно длинненькие Гайк по аренам можно было бы завершаться но у нас остаются вопросы отдельные вопросы которые Было бы неплохо разобрать опять же единственная причина начать использовать арены это когда вы видите что gc именно тормозит програм тем более оно экспериментальное Основной причиной как я понял зачем в аре арены затащили в горшку это grpc особенностью grpc является что при парсинге про профа у нас памяти возникает огромное количество мелких объектов которые потом ложатся грузом на наш сборщик мусора - это основ протокол которы для разработки своих микросервисов Да и в целом если смотреть по рынке у нас в Гош значительно популярнее остальных протоколов вроде реста и ребята на практически пустом месте получили рост пятипроцентный именно на парсинге профа раньше именно парсинг про толь в пх Нея на то что там ручное управление памятью в других языках особенности со сборкой мусора динамических такого не было потому что там наверное Никто особо не парится о производительности А здесь вот решили поэ коно для Гугла оптимизировали немножко jpc и теперь и мы сможем этим пользоваться правда кажется в Мастере оного в Мастере нет ноде пого стабильными оно появится если теперь у вас возникла мысль то что у меня тоже куча мелких объектов и мне нужно затюнить это с помощью Арен Я наверное третий раз говорю не надо пока не будет чётких данных профайлинга в профайлинг мы должны заметить что gc занимает какое-то значительное время К примеру Можно попробовать поискать сколько у нас занимает G gc BG markw это штука которая работает постоянно в бэкграундер в хи чтобы их раскрасить на маленьком хип оно будет вообще незаметно и наш симпли профайлскул а второе что можно заметить в профайлинга - это gc Start эта штука вызывается Каждый раз когда у нас хип увеличивается чувствительно Ну и собственно начинается сборка мусора очистка объектов оно его вы можете увидеть когда у вас слишком большой рейд создания объектов JC не будет не успевать и он будет запускаться чаще и чаще теперь давайте что ли посмотрим несколько примеров кода создадим тестовую структур на две на два Инта и конструктор для неё и теперь небольшой бенчмарк в котором будем просто создавать эту структуру вообще вот такие бенчмарки Не рекомендую никому писать потому что в идеале у нас должен быть один цикл бенчмарки пон и чтобы бенчмарка сама определила Сколько нужно сделать итерации что пока значения не стабилизируются но здесь такой вот уникальный кейс что создание просто переменное но достаточно дёшево и время сильно плавает для того чтобы оно было каким-то более в среднем стабильнее нужен внутренний цикл и слай это уже нужно для того чтобы в памяти у нас набралось достаточно много обв и мы напряг немножко gc если мы запустим этот бенчмарк то увидим вот такую нечитаемо портянко Давайте лучше посмотрим тоже самое в таблички то есть здесь из самого интересного миллисекунды и объём выделенной памяти не так важен но Мы заметили что у нас есть мы создам миллион объектов внутреннем ЦИК у нас вхи миллион локаций Теперь давайте посмотрим награ того что происходит в целом у нас основная Работа как раз создания объектов и собственно New object занимает большая часть времени но можно увидеть что gc Mark Work занял больше 10% нашего времени также если посмотреть на длинные хвосты в создании то ещё можно заметить что мы не раз ещё наши сны полностью очищали и приходилось гому локатору ходить к операционной системе просить больше памяти Теперь попробуем тоже самое сделать с аренами для этого перепишем наш конструктор теперь первым аргументом будем передавать уже инициали Арену и структур будем создавать на ней бенчмарк выглядит абсолютно таким же образом просто мы сначала создали Арену затем на этой арене сделали слайсинг а в конце каждой итерации бенчмарка сводили Арену дальше мы будем видеть в табличке сравнение с проценти ками которые дал Bench Stat он также будет показывать среднее отклонение результатов при нескольких запусках и Как видим у нас Мы немножко сэкономили цпу теперь на 40% меньше потратили на создание всех переменных потраченная память плюс-минус такая же на самом деле это удивительно что там даже чуть меньше создалось но пусть будет так и плюс интересно то что с миллиона локаций теперь у нас се видимо именно одна локация непосредственно саму Арену и нам скорее всего потребовалось шесть чанков для того чтобы ВС разместить выглядит оно так все функции связанные со сборкой мусора у нас сжались практически до невидимых значений большую часть времени мы собственно тратили на создание объектов Также хотелось бы упомянуть тически всегда когда мы сталкивались с тем что у нас какие-то проблемы со сборщиком мусора классическим решением было использовать сипу он также снижает давление сборщика мусора но главным образом на локации и очистку но Син собственно вообще идеологический сипу предназначен для хранения объектов чьё создание достаточно дорого ну и плюс то что он предназначен для одинаковых объектов только одного типа также сил Очень неплохо себя показывает если нам нужен один пул на множество рутин потоков Но если у нас мало потоков или вообще одно поточная программа то лишние ките наоборот могут на чувствительно замедлить имом сколько финале будет объектов если мы если их плюс-минус столько же сколько рутин и мы успеваем Вот на этом рете жить то всё будет неплохо А вот если рейд создания объектов побольше и в пуле спится достаточно большое количество объектов то на нас тут же начнёт давить вот этот поющий объекты так как ничего не знает о поколениях то он постоянно будет обходить Всё Давайте ещё посмотрим бенчмарк с пулом опять же практически тоже самое снова поменяли конструктор передаём туда инициализирован пул из пулы берём марак сами пулы сделаем глобальными один пул непосредственно для маратов и один пул для слайса здесь Бенч немножко поменялся Ну как поменялся слайс получаем из Пула мы создаём с помощью конструктора но здесь нам ещё приходится делать дополнительный цикл для того чтобы в конце всё-таки вернуть все объекты в пул обратно и если мы посмотрим на бенчмарк на результаты этого бенчмарка то видим то что всё-таки пул значительно быстрее чем просто выделение на хи Томы сэкономили 15% цпу но всё-таки до арены не дотягивает из-за того что объектов было достаточно много но зато здесь Мы практически не тратим память Так как постоянно пере используются одни и те же объекты Если посмотрим на Flame то здесь у нас опять же gc практически нету объектов у нас там было мизер количество основное время заняла работа с самим пулом Теперь давайте поговорим о всяких подводных камнях которые могут встретиться У нас при работе с аренами первая проблема Я сделал это практически тот же код что был в начале но я сделал два маленьких изменения изменил точнее одно изменил тип переменная которая хранится внутри макта у нас был а теперь слай Тоже самое я сделал в самом бенчмарке теперь у нас не просто G попадает в Конструктор А слайс интой если мы запустим бенчмарк то с ужасом Увидим что у нас почему-то произошло 2 милна локаций хотя на арене их быть вообще не должно было быть поправим наш Бенч у нас поло не так и Давайте тепер попробуем создать слайс варения после чего у нас всё стало нормально у нас снова всего лишь 11 локаций Так в чём дело дело в том что арены автоматически не будут создавать все ваши Потер типы структур автоматом на арене по всему дереву вот вложенных объектов Всё нужно руками создать Наре иначе оно утечет в хип туда же как и слайсы в общем всё что по поинте утекает в хип к примеру слайсы Но для слайсов У нас есть специальный метод А вот те же строки и мапы у нас вообще не получится сдать варение и тут уже при иска какие-то обходные можно предложить коню вот для мав уже практически ничего не придумает будет её туда засунуть вторая проблемка вот мы такие счастливые создали варение слайс с capacity 5 мы докинути слайс снова Уте в хип Ну точнее не слайс а нижележащий массив чик в целом оно понятно почему потому что мы не можем как бы убрать предыдущий слайс расти ему некуда потому что там в следующей памяти уже может быть что-то записано Поэтому если вам нужно использовать сй то нужно заранее выделить весь необходимый пересоздать новы Если вдруг она выросла Ну и третья проблема которая самая очевидная это то что теперь у нас появилось ручное управление памятью я написал Вот прямо банальный пример с ошибкой Мы создали Арену создали переменную очистили Арену и пытаемся распечатать наш майстра здесь очевидно там в реальном коде может быть не так очевидно но у нас классический пример что может привести проб к проблемам Ну точнее там в плюсах почти наверняка Это был бы какой-нибудь сиол но Гошка нас об этом не предупредит всё Отработала нормально потому что сборка мусора не успела почистить чанки арены и поэтому адрес у нас по-прежнему была нормальная структура Здесь нам ещ где-то в годи ИП Google добавил Сай в Гош и где-то в 11 также как и с нашим детектором ребята из скоро разработки решили не придумывать велосипеды а взяли то что уже используется тогда это был теперь вот и санитайзеры Memory сайер нужен для того чтобы найти использование неинициализированной памяти санитайзер немножко похитрее он следит за обращением к адресам которые сейчас недоступны адреса то есть не инициализирован адреса которые выходят за выделенные области и прочее изначально их добавляли для того чтобы удобнее работать с бинга с сиш и плюсовых кодом но и сейчас когда создали арены их заинтересуется в докер контейнерах если мы запустим ту же программу с Memory санитайзера то он нам тут же упадёт с информацией о том что мы используем инициализирован значение санитайзера тоже самое только чуть больше отладочный логов то что у нас снова идёт обращение к адресу которое уже было очищено рано или не рано пока что использовать аре вопрос достаточно спорный Я хочу сказать вам преувеличил сколько нам дают арены пользы то есть вот эти 40% если оно начинает давать эти 40% только при Очень большом количестве объектов если мы посмотрим какой-нибудь другой пример если мы реально посмотрим пример из жизни то к примеру когда к нам приходят баче вые запросы свки там на 4-8 МБ не знаю Как у вас настроено но в целом там достаточно много объектов мы можем создать памяти для того чтобы бачева их обработать как-нибудь переложить куда-нибудь но там скорее всего их будет от нют не миллион если уменьшить количество создаваемых объектов до 256.000 то арены начинают то есть отставать даже от хпал продолжает сохранять своё превосходство если что 256000 - это не какое-то магическое число а скорее примерно Я много раз запускал свои бенчмарки с разными значениями и примерно Вот на этом порядке значений Происходит надлом что больше начинают выигрывать арены А меньше Скорее всего будет выигрывать просто хип Но на самом деле мы же не только сейчас столкнулись с тем что gc нам иногда мешает думаю большинство из вас помнят статью рда девятнадцатого года где ребята пожаловались что они не справились вились со сборщика мусора в горшке в их сервисе который широва количество непрочитанных сообщений и им пришлось переписать этот сервис Нара в том же девятнадцатом году не только discord столкнулся с тем что у них есть большой кэш которому слегка мешает gc есть компания Граф которая пилит одноименную графо базу и внутри этой базы есть ш rest который кстати по-моему намного популярнее чем сама база и во многих приложения уверен что многие её использовали так вот ребята из графа столкнулись с проблемой что gc им мешает и они всё-таки разобрались с тем А как можно улучшить кэш для того чтобы безопасно и быстро хранить объекты в памяти они для этого написали свою маленькую обёрточная Гош ная прослойка над плюсовые локатором Gal э внутри этой библиотеки есть локатор который практически целиком такой же как Арена только используют именно а не какие-то свои внутренние туки по использованию очень похож на те же арены опять же ещё один конструктор который в этот раз принимает локатор только в то время е не было дженериков и нам тут приходится сначала выделить память у нас остаётся указатель на первый элемент этот указатель это к указатель структуру можно спокойно использовать У нас тоже примерно такой же как с аренами Кроме того что слайс опять же выделяем с помощью маги Как оно выглядит локатор быстрее чем хип арены пул и таким он остаётся Даже если мы начнём уменьшать наш N до там достаточно маленьких значений в слайдах я это не отметил Но кажется даже на объектах локатор ВС равно будет скорость создания переменных в в целом локатор мне приходилось использовать он работает достаточно быстро для отладки того что у вас нету всякой неправильно работа с памятью те же ан также подходят Если вы увидели ваших марках профайлинга и так далее Что вы Урае в gc его можно использовать Но если конечно не боитесь в целом на этом всё там голосуйте за мой доклад QR коду если что связываетесь со мной в любых соцсетях по хенд слайды можно скачать по ссылочки пер вопросы супер спасибо большое за доклад для того чтобы задать вопрос поднимайте пожалуйста руки к вам подой с микрофоном можно будет его задать также не забывайте о том что вопросы можно задать в чат зала Спасибо большое за доклад было очень интересно и надеюсь может быть полезно на практике вопрос возник такой вот вы рассказывали что если есть структура с большим количеством каких-то вложенных полей которые слайсы или указатели на что-то то приходится выделять и конкретно поля на арене чтобы они не утекли на хип ли желание или необходимость написать какую-нибудь тузу чтобы это как-то автоматизировать не знаю там кодо генерацию или Ну какое-то прощение этого процесса и как думаете Будет ли идти стандартная библиотек в эту сторону чтобы упростить разработчику путь так первый вопрос Нет не приходилось нам так или иначе идеологически го не будет делать никакой магии если мы хотим выделить объект не в стандартном месте то скорее всего нас будут заставлять руками это делать Тоже самое по поводу каких-нибудь не уверен что это будет так уж Легко но возможно здесь Я скорее хотел бы вот подчеркнуть что если вы решили использовать аре уровне там Арена New Не сработает А вот по всем конструкторам вниз по дереву создаваемых структур так или иначе придётся её пробрасывается ответил Спасибо вопрос с правой половины зала Спасибо большое за доклад уточнить вы используете вс-таки в каких-то своих сервисах арены или же предостережение три раза о том что не используете это опт потому что потратили время и не получилось профита если есть Профит Используйте Расскажите Кай сейчас арены ещ нестабильные мы их не используем как локатор это опыт с позапрошлой работы где мы пилили свою систему сбора логов и когда к нам прилетал файл с большим количеством записей нам нужно было каждую запись порть и сложить оть сложить обратно тогда мы как раз столкнулись с тем что gc начинает нас сильно тормозить и тогда же я вот впервые воспользоваться локатором найдя его Спасибо вопрос по центру Максим привет Спасибо что за доклад очень понравился но у меня возник вот такой вопрос мы поняли как размещать файлики если у нас их много в аренах в памяти но вопрос потом что с ними делать Окей мы их можем прочитать что-то мы можем поменять в каких-то там небольших пределах и ещё непонятно что со строками там произойдёт если у нас в структуре строки Да как они будут меняться в аренах и там я видел есть метод Клон да то есть мы типа клонируем какой-то объект мы его клонируем получается в стек и теоретически если мы неправильно подойдём к этому вопросу работа с этим объектом он у нас опять учёт хип если мы где-то будем его дальше использовать Есть ли какие-то гайдлайны ты какие-то видел или можешь порекомендовать как вообще с этим работать ну как бы в реальной жизни Если такое потребуется потому что пока что кажется что это просто какая-то штука для создания там каких-то Шей для больших количества объектов где можно там что-то прочитать Да и как бы как бы всё А так достаточно широкий вопрос первое оно предназначено для бачей обработки чего-то когда у нас в памяти создаётся много всего по очереди и мы хотим чтобы потом ВС это очистить одним махом не напрягает G здесь по сути мы там создали объект на арене там поработали с ним обогатили всё такое а потом просто забыли о нём пока не закончим текущий пакет то есть оно нам в дальнейшем где-то вспоминать о том что было не нужно говорил вот Клон забирает из арены в хип это по сути такой дип копия которые глубоко проходит и забирает ВС хип Ну если там финальная версия какого-нибудь объекта нужна на хи то он как раз позволит его забрать возможно по мере развития вот этого инструмента появятся какие-нибудь хелперы которые будут орать о том что что-то у Вас случайно утекло в хип пока что такого нету Так что аккуратно профайло до и после внедрения Арен Ну до чтобы понять что проблема с gc А после что у нас действительно уменьшилось количество локаций других подходов чтобы вот гарантировать что ничего лишнего пока слово молодому человеку слева Спасибо за доклад А у меня такой вопрос есть ли какие-то механизмы переиспользование Арен Ну насколько я понимаю метод фри он да делает её негодной мы её должны заново New ara выделять Да есть какой-то механизм Аля Синг Пула использования переиспользование арены или что-то в этом плане потому что Ну да если мы очень часто выделяем арены это в любом случае нагрузка было бы логично их попытаться как-то переиспользовать когда мы поняли что нам она не нужна и очистить её именно внутри Арен и способов прямо их переиспользование нету потому что основная логика в том что мы создали потом забыли о ней Она сама очистится в целом создание новых Арен не так дорого как может показаться потому что вот в аренах слеш снах памяти в которых Гошка создаёт свои объекты под эти пересоздать зарезервирована память Вот как раз их размера и вновь созданная Арена чанки арены лягут опять же на те же в те же спа здесь понял И тогда закончу этот вопрос но я правильно понимаю что у нас нет никакого механизма управления размером арены минимальные максимальные какие-то размеры задава Да я Кстати забыл сказать что я обратил внимание что в локаторе мы указываем какойто жела вотре нам кстати стат заранее указать Сколько места Нам надо в отличие от Z локатора здесь у нас есть возможность и для того чтобы бенчмарк был честнее я как раз э ээ Блин я забыл как прочесть это число в общем арены выделяют столько же да понял спасибо спасибо Есть ли ещё вопросы зала поднимите пожалуйста руки у кого есть вопрос барышня во втором ряду в центре а Спасибо большое за доклад вот мы часто говорим о том что важно прокиды арены из родительского объек дочерние для того чтобы они свои тоже размещали на той же арене критическая секция для вот этой существующей арены где Как определить кто именно является родительским объектом чтобы определить Вот это время жизни самой Арены Так я на самом деле не до конца Понял Вопрос поэтому буду да Повторите пожалуйста вопрос для того чтобы это было слышно на запись и для тех кто смотрит трансляцию это может сделать докладчик всё в порядке В общем вопрос был в том кто вообще должен создавать Арену На каком уровне Здесь вопрос также ответ достаточно бесхитростный у нас в любом случае будет какой-то основной цикл где у нас начинается обработка какого-то большого количества объектов и их завершение там если мы опять вернёмся к самому первому примеру с игрой Понятно где у нас начало уровня Где конец и как раз в этом месте логично создать Арену а потом её уничтожить там можно придумать какой-нибудь пример так не надо делать там от Арена нету выигрыша я уже пробовал то что в начала веб-сервер в начале Квеста мы создаём Арену и все вместе с контекстом вот обычном реквест отправляем в дальше Арену для того чтобы все служебные наши переменные выделять на арене Ну и авто после завершения Квеста дача автоматом очистить арену примеру такое можно там было бы завести какую-нибудь Вари супер спасибо У нас есть время на последний вопрос поднимите пожалуйста руку У кого есть вопрос всё что не успели можно будет потом задать дискуссионной зоне в последнем ряду есть вопрос и на этом мы закончим текущую сессию вопросов ответов добры дела вопро нестабильности у арены и какие подводные камни использования если вдруг по каким-то причинам вс-таки она применяться На текущий момент Ну именно подводные камни я говорил когда мы обсуждали и А почему рано вот поэтому потому что это первая реализация Арен и она работает пря достаточно медленно вот на целом миллионе объектов А таких вот там пакетов данных мы сталкиваемся достаточно редко в то же время Z достаточно намного быстрее А значит это показывает что и у пакета Арен есть такое пространство для оптимизации тюнинга после которых он будет работать там на 100.000 объектах нормально как-то так Отлично спасибо на этом месте мы завершаем сессию вопросов ответов в зале после чего можно будет пройти в дискуссионную зону вместе с докладчиком и задать дополнительный вопрос который вы не смогли обсудить здесь или вступить в какую-то дискуссию А давайте выберем вопрос который вам понравились а для начала для того чтобы подарить подарок от нашего партнёра Газпромнефть Дайте вот этот вопрос отличный вопрос Спасибо Не уходите пожалуйста чтобы мы могли вас найти вас Мы тоже Хотим поблагодарить и Подарить вам подарок от онтика Спасибо большое за то что вы приехали к нам и выступили Ага Это было очень круто а и наверное вот этот вопрос о том когда выделять это уже не полноценный подарок но мини подарок от э отлично Спасибо большое тоже не убегайте пожалуйста докладчик подарит вам подарок от теньков Спасибо вам большое"
}