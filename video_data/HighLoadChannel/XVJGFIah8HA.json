{
  "video_id": "XVJGFIah8HA",
  "channel": "HighLoadChannel",
  "title": "Алгоритм сетевого планирования как способ повышения производительности сервисов / Игорь Чирков",
  "views": 209,
  "duration": 3242,
  "published": "2023-10-06T07:18:47-07:00",
  "text": "Здравствуйте Уважаемые коллеги дамы и господа сейчас я оборудуюсь оборудованием Сегодня я представлю Вам доклад тема которого заявлено на слайде сразу хочу пригласить всех кто прослушать мой доклад на стенд почтой тихо который находится в амазоне там можно пройти небольшой завлекательный Крис ответить на вопросы получить какие-нибудь призы за правильные ответы А за неправильные ответы соответственно не получить вот ну и приходите пару слов так у нашей компании она обеспечивает эти решения для бизнеса Почты России и некоторая информация представлена Вот на этом слайде теперь собственно говоря о докладе который я хочу представить сразу Обозначил математику Я хочу рассказать о том как можно улучшить ускорить работу сервиса который может быть представлены в виде совокупности затратных по времени операции зависящих друг от друга в плане данных для этого применяется алгоритм известный алгоритм сетевого планирования область применения которого производственные процессы с высокой степенью параллелизма он используется для составления технологических карт и отыскания узких мест в производственных процессах в принципе аналогия прослеживается Поэтому был выбран вот такой вот алгоритм свой доклад Я хочу построить не виде Академической лекции и о виде наоборот такой истории о реальном приложении чтобы это воспринималось не так сурово и поэтому структура моего доклада будет такая двухслойная первая часть Я хочу рассказать немного о нашем приложении чтобы получить некоторую привязку на местности а вторая часть Она более Техническая и посвящена собственно говоря изложению тему заявленная в докладе еще сразу хочу сказать что изложение я буду иллюстрировать неким абстрактным примером умозрительным который несколько упрощает реальную ситуацию но тем не менее содержательный и демонстрирует все основные моменты которые я хочу продемонстрировать а не основные моменты он скрадывает чтобы мы не погрязли в деталях реализации и чтобы было понятно о чем-то идет речь а речь пойдет о приложении которое называется личный кабинет юридического лица вот там в уголочке есть ссылочка на это приложение в prody начиналось в 2015 году с аналитики и первая версия нашего приложения попала в пруд по весне 16 года изначально это было небольшой век приложение ориентированное на интернет-магазины позволяющие удаленно оформить обычные посылки и потом просто принести их почтовое отделение и сдать Без особых хлопот это была некоторая замена доступного приложения приложение в общем-то стало довольно-таки популярным прежние клиенты быстро очень на него перешли мы стали обрастать дополнительным функционалом произошла интеграция с другими сервисами Почты России аудитория нашего приложения росла но кардинальное изменение нагрузки произошло после того как мы реализовали возможность отправки письменной корреспонденции через наше предложение что повлекло подключение очень крупных клиентов которые генерируют большой поток таких отправлений график роста нагрузки Я вот здесь представил на такой диаграмме ну помимо всего прочего я хочу отметить результаты текущего года Это данные до миллионах отправлений Кстати это данные на середину октября можно заметить что уже на середину октября мы превзошли результаты 21 года который вообще считается у нас довольно таки удачным Я думаю что финальный результат этого года будет вообще очень хорошим мы ожидаем хороших результатов Так что с точки зрения бизнеса наше приложение является успешным генерирует порядка 15 процентов выручки компании с точки зрения клиентов Я думаю что мы тоже выберем неплохо у нас есть индекс удовлетворенности клиентов как-то он так называется nps сокращенно Я правда не знаю как расшифровывается вот этот самый nps он демонстрирует стабильный такой вот рост приложение как вы видите является высоко нагруженным но тем не менее оно не является беспроблемным с моей точки зрения как разработчика это проблемы я бы сказал проблемы роста мы начали с маленького приложения сейчас это огромное приложение огромное и с точки зрения кодовой базы И с точки зрения стека используемых технологий Ну и еще есть проблемы которые связаны со скоростью разработки в общем был период когда Новый функционал добавлялся прям в большом темпе Я думаю что вы все представляете какие отсюда могут быть следствия о чем пойдет речь наше приложение является микросервисным и у разных микро сервисов соответствующая ответственность есть я поговорю сегодня об одном из наших микросервисов которые отвечают за взаимодействие с курьерской службой я перейду сейчас новый слайд чтобы он повисел здесь некоторый срок Ну и предварительно я все-таки скажу некоторые общий взгляд на Ростова микросервисы и вообще на все вот микросервисы можно посмотреть как нам системы массового обслуживания в системах массового обслуживания есть два самых важных параметра который определяют в общем-то то как они работают а именно это скорость входящей очереди и также скорость обслуживания единичных сообщений Ну вот представьте себе такую ситуацию Когда у вас очередь такая точнее входящие сообщения поступают довольно быстро а обслуживающий механизм будем сначала считать что он единственный он такой вялый что в этом случае будет происходить понятно что в этом случае мы будем очередь копить и теоретически она будет расти бесконечно реально это приведет к тому что мы будем просто терять некоторые сообщения как не обработаны в принципе эта проблема решается с помощью масштабирования Ну то есть в общем случае Вы можете просто докинуть несколько инсонсов вашего микросервиса подключить несколько серверов и потом роутить входящие сообщения между этими инстанциями стандартный подход и в принципе он очень хорошо работает Если вы имеете дело с асинхронным процессом То есть когда вы не отвечаете на запросы сразу что-то Пишите в базу и потом это когда-нибудь пользователю видит но в случае если вы поставлены в ситуацию когда требуется синхронный ответ в этом случае решение с масштабируемостью не является совсем хорошим то чтобы от него нужно отказаться Ну тут возникает необходимость уже прям поработать отдельно с производительностью от наших микросервисов как таковых поэтому эта задача актуальная и в общем я к этому перейду вот этот самый курьерский микросервис у него там есть несколько методов и вот один из этих методов он так был довольно таки тормозной работал медленно Прямо скажем и все не было повода с ним разобраться но тут у нашей внешней системы одной поменялась API и мы вынуждены были внести изменения в логику работы нашего этого самого микросервиса Я на тот момент был новичком команде и не очень представлял как это все работает открыв исходники Я обнаружил там нехитрую структуру этого микросервиса то есть слой контроллера который принимал запрос сервисный слой где была сосредоточена логика обработки нашего запроса а также некоторые периферийная структура представленная базой данных и какими-то внешними системами которых было на самом деле тут нарисовано там с десяток Примерно вот и не все эти системы принадлежали нашему контуру некоторые вообще совершенно внешние для нас были все бы хорошо структура простенькая кроме одного момента код класса который представлял сервисный слой был довольно плохо структурирован и содержал порядка 2000 строк кода кучу приватных методов и собственно говоря было непонятно где вносить желаемые изменения Ну что в этой ситуации оставалось делать Надо было сначала разобраться с логикой сервиса Поэтому моя идея была очень простой представить работу сервиса в виде комбинации отдельных операций бизнес операция желательно и сам сервис представить в виде такого оркестратора который бы этими операциями манипулировал Сказано сделано все эти операции я представил в виде каждого из этих операций я представил виде узко специализированного класса с единственным методом и соответственно сервис Я просто не стал менять логику работы изначально а просто сделал такой вот рефакторинг в результате которого получил вот такой вот картинку давайте я немножко поясню напомню что сейчас я буду излагать все На некотором примере и вот этот пример собственно говоря начался здесь на этой картинке технология такая свои классы операции Я здесь представил виде стрелочек которые Обозначил латинскими буквами а вершина вот этого линейного графа соответствует состоянию системы После выполнения той или иной операции и начальная вершина у нас будет соответствовать поступлению запроса конечная вершина будет соответствовать у нас формированию ответа после обработки всего запроса и соответственно переходы между этими состояниями соответствует выполнению вот наших операций чего я добился Ну первый просит такой что я стал понимать как это работает у меня улучшилась читаемость кода После этого мне стало понятно Где должен нести соответствующие изменения я их сделал виде отдельной операции которую строил вот в эту цепочку настал момент разобраться с производительностью этой системы Ну нужны какие-то метрики померить время выполнения операции Ну вот я тут маленечко отойду в сторону теории и замечу простой факт я думаю что все вы сталкивались таким фактом что даже один и тот же запрос базе данных с одними теми же условиями выполняется за разное время это величина случайная на нее оказывают влияние множество факторов которые очень трудно учесть Тем более это касается вот этих самых операций которые я здесь провозгласил мы с вами имеем дело с классическими случайными величинами которые являются основным предметом изучения такой науки как Теория вероятности слышали про такую наверное вот нужен какой-то понятный нужно какая-то понятная Метрика как эти случайные величины В общем померить Что можно у них померить я тут наверное не открою Америку Я думаю все понимают о чем идет речь есть такое в теории вероятности понятие мат ожидания Но это некоторая интегральная характеристика В общем случае вычисляется как некоторые интеграл смысл ее очень простой это среднее значение случайной величины плохая новость заключается в том что мы не можем в реальной ситуации кроме самых простейших случаев вычислить мат ожидания случайных величин с которыми мы имеем дело для того чтобы это можно было сделать нужно полностью знать ну скажем функцию распределения такой случайной величины я не буду вдаваться подробности хорошая новость заключается в том что есть несложные статистические методы которые позволяют оценивать параметры распределения в том числе им от ожидания с помощью некоторых Ну некоторых просто вычислимых статистик в частности для оценки мат ожидания наиболее употребимой точечной оценкой является так называемая выборочная средняя здесь я не стал городить огород а воспользовался готовой библиотекой вот ссылочка на github на слайде имеется Эта библиотека называется Speed for the инструмент для Ява разработчиков Он позволяет с помощью добавления несложной функциональности в метод класса снять с него какие-то статистические характеристики он считает довольно много характеристик у меня будет интересовать Вот как раз выборочная средняя Сказано сделано добавив соответствующую функциональность в код классов операций и выставив свое приложение в прод окружение настроив соответствующий логгер Я получил некоторый снимок статистики работы моего замечательного сервиса проанализировав этот Look файл я пришел вот к такой ситуации которая изображена у нас здесь на слайде Понятное дело что здесь вот ниже стрелочек я написал числа условные это условное время выполнения соответствующей операции в реальном в реальной жизни Понятное дело что я измерял миллисекундах а здесь я почему-то решил поступить так и времена у меня здесь условные единицы времени после этого собственно говоря можно по времени каждой операции оценить общее время обработки всего запроса в нашем случае оно составляет 22 единицы это обычная сумма этих вот средних значений на самом деле если обложить вот методом вообще весь метод сервисный то он дает немного другую немного другое число но они очень тесно коррелируют между собой вот таким образом собственно говоря мне стало в общем-то Понятно картина происходящего Ну давайте двинемся дальше какая стоит задача стоит ускорить работу сервиса организованного как последовательность выполнения нескольких затратных по времени операций зависит друг от друга в плане данных Я уже об этом говорил еще раз повторю Какие пути решения Такой проблемы Давайте их как-то обсудим я вот здесь их Ну то что мне пришло в голову я здесь написал во-первых можно бороться за производительность каждой отдельной операции ну этот путь Я думаю не сулит больших перспектив Ну и даже и понятно почему во-первых наш сервис обращается к внешним ресурсам на скорость обработки на той стороне мы повлиять не можем договориться с разработчиками внешних систем как правило ни о чем не получается есть конечно наши внутренние системы там тоже как правило резерв небольшой поэтому первое подход не сулит больших перспектив более перспективный подход это изменить структуры сервиса и перейти на многопоточную обработку Ну и третий подход это собственно говоря комбинация первых двух Ну и вот здесь Как раз мне пришло в голову что я имею дело в общем-то знакомой мне ситуацией и пора бы применить какую-то науку Ну давайте перейдем здесь я сразу хочу оговориться что поскольку я пользуюсь некоторым наглядным примером и картинку Поэтому я буду рисовать сразу правильную Если бы я сейчас что-то рисовал на доске я бы конечно изобразил как я это все придумал от неправильного правильного перешел но здесь у меня картинка более-менее статическая поэтому я вынужден сразу делать все как должно быть Итак после анализа зависимости моих операций друг от друга Я пришёл к выводу что операции А и Б зависит только от входных параметров этому соответствует состояние нашей так называемой сети вот такое то есть состояние 0 это поступление запроса на обработку и стрелочки это наша операции они могут быть стартованы сразу в момент поступления нашего запроса на обработку Вот такая вот картинка сразу внизу я пишу не забываю писать время выполнения каждой операции нам дальнейшем понадобится Ну следующий шаг построения нашего графа этот Граф Кстати я буду называть сетью в дальнейшем операция C ждет завершения операции а этому соответствует состояние системы которой я занумеровал номером один и соответственно оно соответствует тому что операция а завершена и может быть стартована операция C операции D и ждут завершения операции B Ну и картинка Я думаю уже соответственно Понятно двинемся дальше у меня 9 операций появляется у нас операция три вершина 3 она соответствует какой ситуации операции F и г ждут завершения операции C и D завершение операции C и D у нас соответствует состояние Номер три и соответственно исходящие ребра F и г Ну тут я уже даже не знаю что сказать все примерно то же самое операция H зависит от результатов F соответственно вершина 4 и последнее финальная картинка операция и зависит от результатов операции и финальное состояние системы оно у меня обрело номер шесть это результат и а таким образом я получил некоторую технологическую карту Как происходит сборка ответа на запрос Как происходит сборка ответа на запрос осталось нам понять на самом деле много чего еще осталось понять а именно первый вопрос который здесь можно задать какие операции можно раз параллели Глядя на такую сеть И сколько будет занимать общее время обработки если мы соответствующим образом распараллели выполнение наших операций давайте мы и приступим к этому все-таки я должен оговориться а некоторые терминологии рассмотрим все пути которые ведут от первой от нулевой вершины 6 кстати здесь еще есть такая оговорочка исходная вершина называется истоком о конечно называется стоком чтобы я потом к этому не возвращался Итак рассмотрим всевозможные пути от истока к стоку их обычно называют полными путями продолжительностью такого пути мы будем называть время которое нужно затратить на прохождение всех операций включающие которые этот путь себя включает совершенно понятно что минимальное время которое потребуется для выполнения всех операций равно продолжительности самое длительность продолжительности пути соединяющей от соединяющий исток со стоком во-первых нужно этот путь найти и во-вторых нужно измерить его продолжительность путь имеющий наибольшую продолжительность в таком графике называется критическим путем этот путь Всегда существует Но он не всегда единственный Тут нужно это отметить Вот и первый подход к отысканию такого пути Ну может быть предложен самый простой мы имеем с вами дело с конечным графом и соответственно мы все пути мы можем найти с помощью перебора Это самый такой кондовый подход но к сожалению чем он плох переборный алгоритмы как правило все экспоненциальные и в реальной жизни очень долго работают поэтому сразу его отметаем и собственно говоря начнем двинемся дальше начнем с понимания того какие операции могут быть распараллелены как это делается все вершины мы сейчас разобьем на слои на слои поступим формально нулевым слоем мы назовем исток у него нет предшествующих операций после того после этого Мы удалим все ребра соединяющие вершины нулевого слоя с вершинами со следующими вершинами вообще с какими-либо угодно В результате мы из нашего графа удалили Два ребра и получили вершины 1 и 2 в которых у которых нет входящих ребер вершины 1 и 2 у нас являются вершинами слоя номер один продолжает также с этими вершинами удаляя ребра три резьба которые тут пальцем не могут пнуть поскольку изображение мы получаем вот такую картинку следующим слоем является вершина номер три Ну и наверное финалочка Итак весь наш Граф распался на слои здесь Имеется два крайних слоя но они во многом формальные и три содержательных слоя что это нам дает заметим что операции соединяющие слои не зависят друг от друга в плане данных и могут всегда выполняться в параллельных потоках поэтому свой код можно организовать дальше особо не задумываясь а именно следующим образом запустить несколько потоков выполняющий операции между слоем ноль и слоем один дождаться их завершения также поступить с операциями между слоем один слоем 2 дождаться и завершения Ну и так продвинуться до конца уже на этом этапе можно получить хороший выигрыш во времени но не всегда этот выигрыш так сказать максимальный можно кое-что еще отжать как это сделать давайте мы перейдем собственно говоря вот изложению алгоритма сетевого планирования нам потребуется несколько важных определений для каждой вершины мы определим такой параметр назовем его раннее время что такое раннее время вершины ранним временем вершины мы будем называть самый ранний момент завершения всех операций которые приводят нашу систему в это состояние и сейчас на вот этой картинке я объясню как эти ранние времена вычисляются совокупность ранних времен мы будем называть ранним расписанием Да и найденные числа я буду отмечать на числовой прямой заранее хочу принести некоторые извинения за то что у меня здесь условный масштаб ночной прямой у меня масштаб чрезвычайно условный он просто демонстрирует кто за кем идет Итак давайте начнем с простого раннего временем начальные вершины мы назначим время 0 это время соответствует поступлению запроса на обработку Итак начальный момент времени мы получаем запрос на обработку и наша система переходит в состояние 0 раннее время вершины Как вычислить раннее время вершины 1 для того чтобы мы достигли состояния 1 мы должны завершить операцию а она занимает по времени две единицы времени мы стартуем с нулевого момента выполняем операцию а за две единицы времени и переходим в состояние один ранее время вершины 1 будет равно у нас 2 Аналогично без затея вычисляется раннее время вершины 2 я тут даже Останавливаться не буду оно равно 3 содержательность является вычисление раннего времени вершины 3 Давайте вот это продемонстрирую как это делается Итак чтобы попасть в Вершину 3 должны быть завершены операции C и D Какое самое раннее время завершения операции C мы должны достичь состояния 1 и потом потратить три единицы времени на выполнение операции C таким образом самая раннее время как мы можем попасть в 3 вершину 3 будет не раньше чем ранее время вершины 1 плюс время выполнения операции C Давайте посчитаем ранее время вершины 1 равно 2 плюс 3 единицы времени вершину 3 мы попадем не ранее чем в момент времени равный пяти Аналогично рассуждает для операции D получаем следующее это раннее время вершины 2 равные трём плюс время выполнения операции D Итого получается семь Итак вершину 3 мы раньше чем момент времени какой Не попадем Ну в общем да всем это максимум из этих двух чисел таким аналогичным же образом вычисляются ранние времена для всех оставшихся вершин для всех оставшихся вершин Ну я уже тут не буду растекаться по древу а просто представлю результаты вычислений Они здесь на экране представлены заметим что ранее время конечная вершины оно у нас здесь больше всего красы интересует равно 13 единицам что это как раз то самое время которое занимает выполнение обработки нашего запроса если мы организуем код нашего класса Согласно вот такой вот сети то есть минимум который мы можем здесь достигнуть равен 13 напомню что стартовали мы с 22 выигрыш Ну я считаю существенный выигрыш существенный что дальше Что дальше К сожалению на данном этапе мы с вами не можем сказать какие операции являются критическими и критический путь здесь не найден мы единственно знаем что все время обработки у нас занимает 13 единиц времени для того чтобы найти критический путь и выяснить какие операции сдерживают нас Мы должны построить так называемое позднее расписание позднее расписание Давайте перейдем к вычислению поздних времён Итак Кто такие поздние времена для вершин поздним временем для каждой вершины мы назовем самый поздний момент времени когда могут быть начатые операции исходящие из данной вершины так чтобы не задержать Весь процесс сложное определение много слов Ну я думаю сейчас при объяснении станет чуть-чуть более понятно Давайте также попытаемся вычислить поздние времена а именно позднее расписание для нашей сети расчет производится аналогичным образом только наш Граф мы теперь обходим не от начала к концу а наоборот от 100 к истоку начинаем с со стока для вершины номер шесть позднего времени как ни странно объявляется раннее ее время то есть для последней вершины постулируется что ранее позднее время совпадает это вполне естественно Итак позднее время вершины 6 равно 13 Давайте посчитаем позднее время вершины 4 мы с вами знаем что из вершины 4 исходит ровно одна Одно ребро соответствующая операция H которая занимает одну единицу времени для исполнения если мы начнем выполнять операцию аж позже чем 12 то мы опоздаем к моменту времени равному 13 поэтому позднее время до вершины 4 будет равно 13 минус время выполнения операции H и будет равно соответственно 12 аналогичным образом можно вычислить позднее время вершины 5 Я на нем Останавливаться не буду содержать Мне как всегда у нас является вершина 3 Давайте Вот мы с вершиной 3 разберемся как вычисляется ее позднее время из вершины 3 у нас исходит Два ребра какое самое позднее время выполнения операции ф и г может быть Итак чтобы не опоздать вершину 4 мы должны помнить о том что у нас операция F занимает две единицы времени Поэтому мы от позднего времени вершины 4 должны отнять 2 таким образом позднее время вершины 3 не может быть больше чем так 12 минус 210 позднее время вершины 3 не может быть больше чем 10 Потому что если мы чуть сдвинемся операция F у нас завершится позже чем 12 и мы опоздаем в точку 6 но у нас еще есть операция г рассуждая аналогичным образом мы не должны задержать вершину 5 позднее время вершины 5 у нас равно 12 таким образом позднее время вершины 3 не может быть больше чем 12 минус 5 это получается А7 получается не может быть больше чем 7 из двух чисел 10 и 7 мы должны выбрать минимальное таким образом позднее время вершины 3 у нас будет равно семи рассуждая аналогичным образом для оставшихся вершин мы получаем вот времена которые я отметил здесь на числовой прямой и собственно говоря здесь можно подвести некоторые итог вот результат наших вычислений красным я отметил следующую ситуацию для некоторых вершин странным образом ранее поздние времена оказались совпадающими это не случайно через вершины в которых позднее и ранние времена совпадают проходит наш искомой критический путь Вот такая вот картинка и операции соединяющие критические вершины Я здесь отметил на картинке красным цветом и собственно говоря наглядно представлен наш критический путь к сожалению здесь я немножко просохатил не отметил времена но я вас уверяю что время критического пути как раз будет и равно 13 единица времени 13 единица времени что это нам дает что это нам дает кое-что дает Нет смысла бороться за ускорение операции которые лежат вне критического пути их ускорение не приведет к уменьшению времени критического пути есть смысл сражаться лишь за операция отмеченные красным цветом если вам каким-то способом удивительным удастся улучшить время на критическом пути хотя бы в одном месте у вас общее время обработки снизится но после этого вы должны будете провести Новый анализ такой же самый возможно критический путь изменится и станет каким-то другим у вас возникнет другое узкое место и можно будет этот процесс Ну итерировать до самого финального результата сразу хочу сказать что Я не стал у себя в приложении ничего оптимизировать ограничился Вот вот этим Пусто и так слишком много времени потратил на это добился добился собственно говоря Вот чего давайте это подытожим во-первых лучше вас читаемость кода Я считаю здесь это в общем-то основное потому что читаемость кода это непреходящая ценность для меня получил выигрыш во времени за счет распараллеливания операций а также нашел русские места в нашем сервисе В нашем сервисе я уже говорил что я рассматривал некоторые умозрительный пример который привязан на самом деле к реальной ситуации в реальности у меня было 13 затратных операций критически будет был единственным содержала 6 операций и время средней обработки запроса снизилась более чем в два раза я не буду приводить абсолютных цифр чтобы так сказать не портить общий эффект Вот считаю что эти результаты вполне хорошие этого я добился с помощью просто реорганизации кода теперь позволю себе Да кстати аптечках традиционно финальный слайд где Я призываю вас оценить мой доклад и все-таки позволю себе сказать несколько слов общечеловеческого плана вот какого плана в бизнес разработки сейчас царит поголовное увлечение готовыми решениями фреймворками чем-то совершенно готовым более того имеет место презрительные отношения так называемым решением сделанных на коленке Зачем что-то новое придумывать все уже Придумано за нас бери и пользуйся этот подход в принципе он правильный потому что все в общем-то хороший алгоритмы они реализованы уже где-то под капотом известных операционных систем фреймворков сервисного баз данных скажем Возьмите вы алгоритм сортировки Я думаю что на скидку из вас не каждый расскажет какой алгоритм является самым оптимальным как он работает а что-нибудь придумают в духе методом пузырька у которого время работы полиномиальное потому что реально алгоритм который связан с черно-красным деревом известным довольно сложно устроен и про него Доказано некоторые теоремы но в принципе он под капот скажем методов сортировки в некоторых языках программирования но тем не менее все-таки не следует полагаться на готовые решения всегда мне кажется иногда бизнес разработки полезно посмотреть на то что вы делаете в ежедневно работает с некоторых более общих позиций и попытаться с помощью Ну я не знаю я считаю что мне это досталось не за дорого недорогих изменений вашего кода добиться хорошего профита вот мы все вспоминаем об алгоритмах По крайней мере я вот на себя хочу это примерить в момент когда вы проходите собеседование в Какую замечательную компанию типа Яндекса Где вас спрашивают как работает такой-то алгоритм А как работает алгоритм Фордов Херсона что-нибудь еще тогда мы конечно читаем литературу идем на собеседование вываливаем это все на интервьюера и потом благополучно об этом забываем место подвигу есть каждый день поэтому мой призыв не зашуривайтесь читайте книжки изучайте хотя бы простые алгоритмы и пытайтесь их применить вашей ежедневной работы как разработчиков Большое спасибо за внимание Да можно задавать вопросы Я так понимаю пожалуйста да да у нас технические проблемы Я так понимаю Добрый день спасибо за доклад Правильно я понимаю что основной идеей данного доклада было предложить понимание того что нужно превращать линейный Граф в какой-то более разветвленный Совершенно верно я сразу хочу сказать что эта ситуация применима не везде бывает сервис который устроен довольно просто там ничего оптимизировать но вот если у вас реально что-то сложное и то что вы можете представить виде композиции Вот каких-то таких операций Я уже сказал то можно за счет параллелизма получить хороший профиль второй вопрос по поводу расчета метрик как таковых Вы упомянули про мат ожидания и так далее и тому подобное вопрос Как вы оценивали распределение метрик автоматически возникает гипотеза нормальным Хороший вопрос Давайте по этому поводу скажу значит вообще говоря форма распределения для меня здесь не очень важна здесь меня собственно говоря интересует точечная оценка мат ожидания и в принципе Что можно сказать о распределении вот этих случайных величин Ну я тут позволю себе воспользоваться своими знаниями Согласно центрально-предельной теореме вот такие случайные величины как правило распределены нормально или их распределение очень близко нормальному более того сумма нормально распределённых взаимонезависимых случайных величин также распределена нормально и с э-э параметрами там которые вычисляются по составляющим частям Ну мне э Для меня эти знания здесь излишние мне здесь достаточно точечные оценки вот такой интегральной характеристики вот о чём я хочу сказать такой вопрос ещё а предположим что а время ответа сервиса зависит от какой-то Ну скажем так сезонности то есть не знаю после шести вечера конкретные сервисы нагрузку и время изменяется Ну совершенно несообразно нормальному распределению Да значит очень тоже хороший вопрос Ну вот тут Наверное нужно использовать такой подход нельзя объеять необъятное Нужно на чем-то остановиться всегда поэтому Ну что у меня было то я и посчитал у меня был спокойный сезон не предновогодний я поставил в пруд э своё приложение и я его поставил а соответствующие семь А мне предоставили метрики скорее всего Высокий сезон э метрики будут другие но в принципе я думаю что скорость ответа внешних систем она будет меняться у меня такая гипотеза пропорционально нагрузки если какой-то сервис Да что зависимость будет некотором смысле Линейная от нагрузки Так что соотношение в принципе оно останется плюс-минус тем же самым вот такой ответ Игорь тут как раз ведущий здесь тут как раз из чатика наверное в ту же тему вопрос почему при подсчёте статистики используются среднее значение они квентили там 99 98 Ну что вы с этим квантилем будете делать во-первых у него непонятная как бы сказать Ну неочевидно вероятностный смысл это доля запросов попавших там в некоторые интервал нас интересует Вообще говоря интересно всегда некоторая средняя значение Можно конечно заточиться на соответствующие квантили там их много разных бывает А кстати от ожидания тоже является квантилем в некотором смысле нет ну наверное тут перегнулся слегка более того мы ожидания не всегда существуют не для всех распределений Ну э-э я здесь воспользовался общепринятым подходом на самом деле Вот я думаю что с метриками каждый из вас встречался или по крайней мере большинство из вас Кто занимается реальной разработкой все всегда интересуют среднее время выполнения запросов Вот кстати спит он вычисляет и стандартное отклонение и какие-то акватили вычисляет Ну я ни разу не видел чтобы этим кто-то воспользовался Ну и в моем случае это тоже излишняя информация была я по крайней мере не придумал как и прикрутить Так у нас там еще вот был вопрос Да вот там надо спасибо за доклад я два вопроса вы рассказали видимо такую ручной вариант Ну то есть Понятно метрики автоматически сняли но потом чисто ручной анализ не собирались это как-то автоматизировать и на другие места прикрутить в режиме онлайн мониторинга вот подход имеет место на жизнь но просто интересно были планы Я понял значит этот вопрос я сам себе в некоторых тоже задал и ответ на него такой затраты на автоматизацию этого процесса На мой взгляд слишком велики Ну вот Мне с трудом представляется ситуация когда вы имеете дело сервисом в котором больше условно там 20 операций я вот прям с этим не сталкивался вот поэтому здесь анализ сети Ну во-первых я не знаю никакого метода который бы автоматизировал этот процесс здесь есть две составляющие первая составляющая она эвристическая которой я думаю в принципе не может быть автоматизирована это представление ваше моего моем случае сервиса как совокупности отдельных операций Я думаю что если бы другой разработчик занялся бы тем же самым возможно его разбиение было бы каким-то другим этот процесс Я сказал чисто эвристический по поводу автоматизации построения графа Ну честно скажу я в эту сторону не думал прям совсем хорошо но такой вопрос я себе задавал но какого-то удовлетворительного ответа не придумал мне не пришло в голову как это можно было бы автоматизировать Ну наверное здесь есть над чем подумать у нас еще один вопрос скорее всего у товарища один вопрос такая банальная Ну а стандартный способ берем профайлеры снимаем Всё что нас интересует тот же CPU да и всё что вы с ними с помощью профайлера Ну что ну как это здесь прикрутить вот на самом деле подобные вопросы мне уже задавали вообще зачем это всё нужно вообще у нас есть профайлер Давайте посмотрим поймем Что у нас там не работает Ага У нас вызов в базе данных держит соответствующее соединение фиг знает сколько времени надо вот там копаться Ну наверное да отчасти это правда Ну вообще говоря но вы При таком подходе не сможете реализовать подход с параллельными вычислениями это как раз вот классический подход о котором я сегодня уже упоминал ничего не нужно придумывать открыл профайлер воспользовался библиотекой и все заработало так не бывает вот скажу вам просто по опыту так хорошо мы сняли цепую и вы поймете какие операции вас друг за другом идет потом тот же самый анализ проведете Нет так не будет Я вас уверяю что так не будет у меня операции это бизнес операции хочу сказать это не есть скажем операция вызова там операция обращения к базе данных это немножко не так работает я сказал что это бизнес операции который отвечает за что-то там например валидация Это целый здоровый класс который грубо говоря отвечает там годен Как вы там из профайлера это достанете или например операция которая получает во внешней системе некоторые идентификатор Ну это ростовый запрос там еще кроме этого там что-то нужно подгрузить чтобы этот запрос был сформирован профайлером на это ничего не ответит Так что Ну в принципе я не против в эту сторону посмотреть как бы сказать Не хочу ничего отметать ну как-то я вот я говорю всегда за себя наверное не смог бы это прикрутить к данной ситуации Ну Возможно это и можно сделать просто я чуть-чуть чего-то видимо не понимаю иногда такое бывает друзья немножко выпадаемость тайминга я предлагаю вам вот эту дискуссию перенести в дискуссионную зону он нас последний вопрос из зала и будем выбирать лучше у меня Игорь Спасибо за доклад э-э несколько вопросов первый по поводу вот этих вот операций времени между состояниями То есть вы э соответственно это бизнес получается состояние и это процесс именно снятия вот этих метрик переходов времени да Это изначально не автоматизированные исследовали правильно То есть как она то есть это получается Эксперт аналитической отдел какой-то Да он делает это понятно второй вопрос А по поводу вот вы затронули Центральный предельную теорему и соответственно ожиданиями и так далее на центральное приведение теорема на практике работает при больших э данных насколько сколько какой-нибудь сколько вы прикидываете должно быть состоянии вопрос Большое спасибо за него значит ну точечные оценки хорошо работают вы правильно сказали на должна быть выборка такая довольно таки жирненькая с этим на самом деле проблем нет просто нужно установить время сбора статистики ну скажем сутки там этих запросов у вас выборка будет очень богатая вот у вас примерно я брал за сутки за сутки но сколько у вас получается состояние таких было там порядка 10 или 15 тысяч запросов было и тогда еще один вопрос по поводу вот вы рассказали соответственно Как вы делаете там таблицу и так далее вот такой вопрос что вот после того как вы уже скомпоновали Граф Вот такими же методами пользуюсь или там поиском глубину например или там другими другими другими алгоритмами нахождения критического пути критический путь нахождение критического критического пути Это совершенно формальная процедура которая завязана на хочу сразу сказать следующее есть эвристическая часть А есть часть формальная которая называется наука эвристическая часть это разбиение нашего сервиса на отдельные операции все остальное это совершенно формальный алгоритм И нахождение критического пути заключается это двухфазная вещь во-первых вы находите ранее позднее расписание и после по совпадению соответствующих ранних и поздних времен определяете этот критический путь всё понятно таким образом Игорь ну что я предлагаю выбрать лучший вопрос который Вам показался наиболее актуально Я вот хочу отметить молодого человека вопрос заданный о форме распределения случайных величин которые представляют время обработки каждой из операций я как бы поднимитесь пожалуйста чтобы наш помощник вам вручили подарок от Сбербанка Игорь Спасибо большое Я честно немножко словил Дежавю во время выступления немножко отвлекся и вся пара пошла куда-то подальше тем не менее Огромное спасибо за это выступление небольшой Презент тоже от хайлот тоже вам подарок Спасибо большое Давайте поаплодируем Не теряйте спикера его можно задать интересующие вопросы в дискуссионной зоне проголосуйте за этот доклад и ждем вас через несколько минут"
}