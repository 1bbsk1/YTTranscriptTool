{
  "video_id": "NpyHPKipXmg",
  "channel": "HighLoadChannel",
  "title": "Consumer-Driven Contract подход для тестирования микросервисов в Авито / Фрол Крючков  (Avito)",
  "views": 1701,
  "duration": 2510,
  "published": "2019-06-03T08:58:56-07:00",
  "text": "в привет меня разраб aquavita и сегодня хотел бы поговорить о проблемы взаимодействия микро сервисов на данный момент мы находимся стадии перехода с монолитной архитектуры на микро сервисную у нас уже появилось несколько десятков микро сервисов которые достаточно активно взаимодействует друг с другу другом и некоторые из таких микро сервисов имеют достаточно большое количество сервисов потребителей и такие разработчики таких микро сервисов сталкивается с большими трудностями в ведении разработки и поддержки такого микро сервиса предположим такую ситуацию у нас есть два микро сервиса один из них сервис-провайдер второй сервис потребитель сервис консьюмер команде команде сервиса концу мира приходит новая задача которая подразумевает в себе но получении новых данных возможных данных в новом формате от сервиса провайдера после получен такой задачи команды разработки команда разработчиков и сервисы provocante мира приходит формирует требование к команде сервиса провайдера о новом формате данных а возможно новых и новых данных о новом формате данных в результате чего команда разработчика сервиса провайдера принимает решение о том что скорее всего не более оправдана будет добавление нового метода api в их микро сервис так как изменения имеют изменения они совместимы со старыми методами api для того чтобы не было мать старые контракты старая api с другими микро сервисами добавляют новый api метод просто как они добавили его они протестировали и убедились в том что данный метод api соответствует всем всем требования сервиса сервиса заказчик заказчика выкатывает вопрос и оказывается то что внесенные изменения каким-то образом повлияли на взаимодействие данного сервиса на другой сервис потребитель почему так происходит так происходит потому что у разработчиков сервиса провайдеров как правило нет возможности контролировать сервисы потребители это выливается в то что у них нет уверенности в том что вносимые имя изменения никак не окажут негативного влияния на другие сервисы потребители и как правило у них нет такого централизовано инструмента который бы позволял знать так как их api потребляет или использует рассмотрим другую проблему данного взаимодействия предположим у нас есть также сервис-провайдер данный сервис провайдер имеет определенный вид этапе который говорит что поэтому это методу open я адам определенный контракт предположим какие-то данные пользователя приходит разработчики других сервисов говорят ребят нам нужно добавить новое поле разработчики сервиса провайдера решают то что они могут либо давать новый метод api либо расширить версию 1 но в данном случае не решаю добавить новый метод на данный момент у нас у сервиса имеется два метода api версии 1 вещь 2 они не могут удалить первый потому что еще старые потребители этот метод используют добавили новый потом приходят другие разработчики говорят давать еще расширим как там но при этом никто не приходит и не говорит к разработчикам ребят мы перестали использовать этот метод или перестали использовать данные поля этого метода и как правило так как у разработчиков сервис-провайдер нет этой информации данные поля кочуют из одного мира в другой и тату как бы продолжается до из до того момента когда до того момента когда ставится какая-то глобальная задача когда поддерживать api становится уже чужого необходимо произвести как это вот такой большой research на то какие методы api можно удалить какие поля не используются потому что это как минимум он увлекает себя разработчики теряют уверенность и желание вести разработку надо данным микро сервиса потому что у них нет уверенности и технических средств как их изменения тестируйте как не задеть сервисов другие сервисы также это имеет и другой негативный эффект на перформанс сервиса нам необходимо ходить базы данных делать какие-то лишние join и для того чтобы отдавать данные поля ну и как правило это технический долг который необходимо тратить время для приведения сервис api сервис а в порядок у нас есть интеграционные юнит-тесты но в данном случае они не будут работать потому что интеграционные тесты и функциональные тоже направлены на то чтобы как правило тестировать внутренней функционал микро сервиса второй момент что наиболее важен это то что данные micro series и контролируется с данный юнит тесты и интеграция тесты контролируется разработчики сервиса провайдера которая как правило и ломают контракт и взаимодействия с другими сервисами потребителями зачастую так зачастую бывают такие ситуации когда разработчик уверенно вносит какие-то изменения в micro series предполагают то что он договорился со всеми участниками взаимодействия со всеми другими микро сервисами о том что он знает что что все другие микро сердце не использовать данный метод и как правило весьма уверенно удаляет какой-то мере факт этапе метод также рефакторинг интеграционный или unit-тест этого метода вполне возможно их просто удаляет и как правило в таких ситуациях возникает проблема что какой-то не документированный сервис или какой-то один из участников взаимодействия все-таки использует этот метод и при выкладке в рот или стейджинг инфраструктуру мы ловим такие ошибки также у нас есть and one тесты intent с ты действительно выявит такой дефект что какой-то из участник взаимодействия поломал какой-то контракт перестал давать данные которые мне никак не предполагают что может в таком формате давать ломаются какие-то клиенты в чем проблема данного подхода несмотря то что он отловит отловит такие сломанные взаимодействия контент с и запускается самый последний момент в силу их дороговизны также они достаточно долго выполняются и как правило из за того что это достаточно много участников даны данного теста как правило нередки случаи когда происходят какие-то инфраструктурные сбои из-за которых и отладка без того скажем так чижовых тестов становится еще тяжелее и мы считаем то что ловить такие ошибки несогласованных форматов и взаимодействий достаточно дорого на последней странице ирония так как то выливается в увеличении времени тепло и и как бы есть он это не хорошо для таковых виды проблем одна из одно из решений это использует conti мир driving контракт тестирование а при данном виде тестирование смысл этого стиля заключается в том что ожидание от api сервисов провайдеров пишет сервисы потребителей по сути концепция заключается в том что тесты на api сервис провайдера находится в репозиториях сервисов консилеров что такое ожидание предположим у нас есть команда поддерживаешь поддерживаю поддерживающим микро сервис-провайдер а у них у сервис есть какой-то метод этот метод гарантирует какой-то контракт данный контракт может быть описанную в различных формах это может быть как jason jason схемы xml в зависимости там про табов также у нас есть другие участники это service can see more также сервиса консьюмер и которые также описывают используют данный контракт провайдера смысл заключается в том что как правило сервисы потребителей не всегда используют где есть контракт предоставляемые сервисом провайдером и как правило пишется код или клиенты использующие только определенные методы вот эти определенные методы я определенные поля которые фактически использует сервис консьюмер и является ожиданием данное ожидании могут быть в разных форматах и то могут как быть как джейсон схемы как xml и прочие виды описание контрактов перед тем как перед тем как приступить к поиску и реализации решения мысль мы сформировали список требует некоторой данный подход данное решение должно выполнять это в первую очередь простота внедрение такого подхода потому что с переходом на микро сервис на ящик туру у разработчиков микро сервисов и так появляется достаточно большое количество новых проблем им приходится писать вся и скрипты для дипломами красавица интеграционные тесты возможны инту эн тесты и не хотела бы их отягощать проблемами еще и такого взаимодействующих мы хотели бы чтобы это было как можно проще для разработчиков также вторая проблема которая мы считаем должно быть должно выполняться это то что то что поддержка данных ожиданий должна быть как можно более простая потому и в идеале мы видим что они автоматически генерируются из исходя из кода микро сервиса которые используют другие сервисы провайдеры так как если у нас допустим имеется если у нас есть как эта документация которая генерируется не из кода то скорее всего она будет устаревшая и как правило на полагаться не будет нельзя что есть из решений как правило мы посмотрели в интернете что присутствует какие решения бывают наиболее такой значим попался это факт фреймворк который не всегда пусть мы посмотрели какие решения предоставляет и поняли что он летает одному из требованию наши одному из наших требований и расскажу какой предположим у нас есть какой-то сервис потребитель так вот микро сервиса у нас есть у нас есть какой-то клиент к сервису провайдера предположим его как-то инициализируем и в данном экшене или хендлеры мы используем сервис провайдеров в данном случае два различных методов это тип получить какую-то сущность пойди и обновить сущность для того чтобы описать данное взаимодействие в пакт фреймворке нам необходимо используя dsl фреймворка языка которым мы пишем микро сервис описать еще раз данное взаимодействие то есть у нас появляется тест мы используем dsl описывая то взаимодействие в какие-то определенные форматы что мы считаем достаточно избыточным потому что помимо того что у нас возможно при добавлении какой-то новой сущности или добавление нового поля в контракта или в модель от испанца или в модель request a нам приход рабочим придется обновлять данный факт контракт или ожидание мы находим это достаточно прагматичным потому что приходится делать одну и ту же работу два раза помимо того что разработчики уже сделали клиент описали это взаимодействие на уровне кода которой они используют непосредственно в самом сервисы и параллельной и делают ту же самую работу используя чужой dsl с каким решение такое решение мы предоставили решение данной проблемы как я сказал у нас есть микрокод микро сервиса у нас уже есть какие-то клиенты возможно это какие-то вендоры написаны с сервисом провайдер возможно это разработчики концу мира уже написали собственный клиент для сервиса провайдера и мы прочитали почему бы не использовать уже данный клиент и и данный код как ожидание для ожидания от сервиса провайдера и пришли к такому решению когда мы используя нативный free марк лефлер который уже используют разработчик в своем для написания unit тестов для своего микро сервиса просто перенести вызов метода или дома на взаимодействие в изолированный unit-тест в котором сделать определенные assert и на то что у нас сущность response of реализовался или иметь покормили в нужный формат если у нас в зависимости от языка программирования какое используется таким образом у нас получается что для первого взаимодействия мы описали один юнит с перенесли его и для второго добавили еще один ограничением такого подхода заключается в том что для каждый метод мы используем отдельный unit-тест который необходимо добавить всю вашего фреймворка какие преимущества это дает по строению с пабк антрактом в первую очередь то что все изменения вносимые в клиент и взаимодействие микро сервисов однажды и если вы указали этот взаимодействию не тестах то как правило эти автоматически измене и будет подтягиваться второй момент это при добавлении удалении новых взаимодействие с другими микро сервисами достаточно петр реальная задача то есть это надо оба обернуть вызов клиентов в изолированный тест для того чтобы наш вся понял какие от каких сервисов провайдеров данные из микросферы зависит мы помечаем данные тесты специальными аннотациями также а не зависит от языка программе ли на котором написан service can see more и помечаем какой сервис данный тест был написан также мы делаем так чтобы клиенты цели zero вался из из переменные окружения после о какой-то описали на стадии одной из стадий сиань парсинга тестов приходит боксер проходит все тестовые файлы это определенные скрипты которые заточены специально для одного из этих трех для и вот этих трех языков из эти тесты формируются и группируются по сервису провайдеру пока для которого они предназначены из этого формируется докер-образ а затем пушиться в service broker через брокер пушиться взаимосвязь консилера с провайдером и к этой связи при при ленко вы вается сервис докер имидж который отвечает за описание теста между этими микро сервисами service broker достаточно примитивный сервис который содержит в себе только взаимосвязи с по сути дела это даг между всеми микро сервисами когда каждый связи привязан какой-то докер-образ который и будет запускаться в плане по сути дела это и есть вся концепция как данный подход интегрируем наш чай для тестов для выкладки микро сервисов как правило такой себя делится на 2 на 2 части это запуск сидите тестов для сервиса провайдера и вторая часть это актуализации тестов расскажу про сначала протестов у нас имеется репозитории сервиса провайдера у нас имеется семь это teams предположим ten city ли это может быть другой инструмент для также нас имеется service broker предположим разработчик вносит какие-то изменения в своей ветке микро сервиса и подхватывает эти изменения размера разворачивает изолированную тест вы институт сервиса мы понимаем воды сервисом понимаем все внутреннюю структуру необходимую для работы микро сервис и затем после прохождения харчиков что сервис развернуто мы поднимаем интеграционный функциональные тесты unit тесты и следующим шагом вся идет в service broker от него получает все необходимые ожидания сидиси тесты которые также запускает на поднятый сервис-провайдер в данном случае по прохождению всех тестов мы агрегирует результаты и разработчик может видеть на каждом пушек и изменения микро сервисы поломал ливан какие-то взаимодействовать другими микро сервисами второй момент это то когда разработчики потребители вносят какие-то изменения в сервис и возможно новый функционал затрагивает новых использование нового провайдера нового клиента после того как мы в неужели кита изменения с новыми изменениями микро при добавлении или удалении новых провайдеров мы инициируем билд и либо это происходит автоматически вся и подтягивает свежие мастер предположим что происходит на этой стадии вся и парсит 70s так этот присвоить то что описывал на предыдущих слайдах а также собирает докеры образы и пушит эти взаимодействия в service broker на данном слайде вы можете видеть те как как стоит использовать данные сидис и тесты тесты должны быть во первых изолированные то есть в дан в одном тесте мы не описываем какие-то сложные взаимодействия не полагаемся на какое-то предыдущее состояние здесь очень большой соблазн а начать использовать данные тесты как функциональные тесты потому что у нас мы можем сесть тестах написать какие-то серию вызовов сервис-провайдер что к категорически не рекомендуется так как это усложнит усложнить сами сами тесты и также повысит повысить вероятность ложных срабатываний за каких-то других проблем и как правило в таких сидите тестов появляются только контракты то есть мы не и проверяем никакие тематически значения получишь полученных данных а это позволяет делать так чтобы данный сидит с ты никак негативно влияли на флору разработчика то есть они как правило запускаются каждый тест и при этом не имеют достаточно редки и ложные срабатывания и sabbath только тогда когда действительно был поломан контракт и при этом как правило остается незамеченным для разработчиков если конечно они не сломали кайт взаимодействие в целом это все спасибо спасибо за доклад любопытный опыт у меня 2 вопроса по ходу было первый вопрос не смотреть в сторону граф quelle потому что вот она как будто бы просто идеально на вас ложится то есть вы забудете про версии про все вы сможете на стороне продюсера писать тесты в нормальные которые будут говорить о том что вы ничего реально не сломали на данный момент мы не используем используем граф келлер для взаимодействия к сервису нас и используя свое внутреннее рпц которая мы на данный момент используем как основной способ взаимодействий между сервисами то есть и не смотрели в сторону действует это мы смотрели обсуждаем новые подходы для того как сервис начинает взаимодействовать но на данный момент к нашей текущей реализации скажем так хорошо ложится в данный подход понятно и второй вопрос вот там когда происходит сидиси tasty тестирования она поднимается этом увидел в своем изолированном инстансе база откуда берется когда мы принимаем и солидный стенд сервис сервиса провайдера как правило для того чтобы прогнать интеграционные тесты функциональные тесты у нас поднимается базы данных она либо может зависимости от разработчиков сервисов либо сэмплер на либо накатываются митинг текстуры в которой и используется для прогона понятно спасибо спасибо за доклад вопрос по поводу того сколько версии сервисов у вас одновременно может крутиться и как собственно говоря не очень понятно вы выводите все таки вот этот неиспользуемый функционал как вы определяете что его тоже можно зарубить все понятно что вы его если вы решили зарубите зарубили то тесты вам скажу что все хорошо ли не все хорошо но вот как определить что вот уже можно рубить ну как правило задачи это не такая тривиальная и исходя из тез суета который мы прогоняем при изменении все весы провайдера мы видим какие какие ожидания формируются от сервиса и исходя из этих результатов тестов мы видим какие методы перестали использовать какие какие поля перестали использовать и исходя из этого делаем как бы рефакторинг микро-микро сервиса то есть это исходя из той суэтов сидиси тестов на данный момент мы используем одну одну версию сервиса то есть пока так нет непременно конечно сервисы deploy не независимые друг от друга но при этом для для тепло и сервисы как бы если используется кубер нити и docker и как бы как правило у нас поднимается в зависимости от стратегии deploy либо используется там сто процент допустим старых сервисов разворачивается новые если они проходят определенные hal chiquita то они водятся в под балансировку ну и исключается те но опять же если новый сервис не не соответствует каким-то контрактом мы не сможем выжить мастер и скажем так вообще выкатить сервис то есть если какое-то если функционал но сервис они не выполняет ожидания других микро сервисов то есть мы не можем выкатить сервис который который не имеет ни выполняет ожидания от других каких-то микро сервисов даже если те уже deprecated то есть мы сначала диппер к этим те сервисы те методы а потом уже вы катанова спасибо за доклад сказать пожалуйста как вы работать с downstream зависимостями вашего сервиса на данным на данный момент когда поднимаете сервиса в изолированной среде у нас имеется каждый сервис курсе своем стейджинг и для изолированного из танца если у нас есть какие-то другие зависимости то используются стринги то есть они как правило стабильные и повторяют профиль то есть там есть какие то это гвоздями база то есть там для определенного тесто вам нужно определенно набора данных в downstream сервис каким образом в этом менеджеру нет для для того чтобы тестировать как бы мы в первую очередь это стиль проверяем контракты да на микро сервиса и соответственно пишем тест пишем так пишем тесты таким образом чтобы они не не зависели от внешнего скажем так как правило не зависели от внешних дам фильм сервисов муки рассматривалось не рассматривали решение когда внешней зависимости могут независимости могут досмотрели это решение но пока обсуждаем как это можно применить потому что собирать в принципе как бы в пакт фреймворке также имеется такое решение как маки мог мог смог сервис который предоставляет моки принципе да то есть об этом мы знаем просто еще пока думаем как наиболее king 4 же вопрос продолжения база основном этого сервиса провайдера на тоже стояли она быстро peace каким-то она разворачивается вместе с с этим сервисом то есть это изолированная база которая умрет после того как к сервис под сервис пройдет все тесты киев не разворачивают определенный дам там либо либо используется это зависит от микро сервиса либо используется текстуры либо сэмпл и для разных тестов используется один набор текстур это в принципе может быть зависть это может уже зависит от разработчиков microsoft то есть это не не регламентируется но как правило да спасибо спасибо за доклад я даже можете сколько вопрос а сколько я здесь ну порекомендовать инструмент знаете ли вы такой инструмент как об dax нет ни но я думаю normal тут он знает это такое стартап из кремниевой долины я о нем узнала из радио ти вот тут такая двойная реклам получается вот смысл в чем его задача как раз вот вы использовать документирование api да какой инструмент swagger swagger да ну вот их собственно 3 свое ароматом и умрешь такие сам популярны вот смысл в чем они микро сервис твой документируют как бы out версии и и взаимодействие вот этот вопрос как бы остается на повестке дня вот мы с вами от этого решение отказались чем настя представляет это счас решение и вот поэтому нам не понравился раз потому что не не как я скотт то есть не в репозитории там пишешь конфликта ты создаешь проект и есть дата ресурс то есть тот ресурс 3 ст раст full ресурс супер есть дата ресурсы база данных и например я опишу свою микро сервисе мне нужно использовать метод какого-нибудь другого другого микро сервиса вот им я беру этот микро сервис выбирая списков data set of указываю and point и говорю я вот версия 1 и 2 я зная его заюзал вот и архитектор он все это видит он видит все зависимости видит кто его завязал и он там даже раздает задачи то есть вот вот я формирую то есть нужно сделать имплементировать такую фичу он там пишет здесь 2 in point а здесь 2 in point а здесь трин по янтарю типу риях связывая ребята раздают задачу через дыру вот и система на как бы вы лидирует все зависимости то есть ну как бы мне не понравилось то что это дивой что это счас ну а так вообще и что для нас это очень сложно а так не показывался в принципе подход неплохой вот что он пол и потом бам он даже есть интеграции то есть ты берешь свой стейджинг какой-нибудь и интегрируем его он может короче and point и дергать и проверять после того как apple и произошел произошел диплом новых версий ты запускаешь он проходит пробегает сеть контракты проверяет ничего не изменилось ничего не сломалось типы все ребята работает да как бы такой подход но скажем если допустим нас есть клиенты которые генерируются из этих контрактов то есть если они генерируются это действительно покрытую все intent имеет смысл действительно проверять ожидании контракт на уровне описания самих контрактов но если допустим есть один из клиентов взаимодействия который не генерируется автоматически из-за из-за контрактов то по факту может быть вы не используете какие-то какие какой-то функционал сервиса но при этом и контракт будет поставлять на при этом ошибка может быть в клиенте которая который может вы также выстрелить несмотря на то что как бы по контрактам мы бьем имплементации клиента может в клиенте рынок этому сервису которым мы обращаемся то есть что-то нет имплементировать до при парном предположим но это случаях если мы не генерируем клиенты даже на это что-то там было все хорошо спасибо об dax 0 и пи и ну и последний х . com вот они для нас презентацию делали мы их вы слышали пообещали мог сделать так или отдыхе сделали вот я им карму возвращаю может быть посмотрите просто скажите пожалуйста вот вы вас сердце то понимаю все взаимодействует по и 5 но есть какие-то асинхронное взаимодействие соответственно вопрос если они есть то как вы там контракта тестируете и давайте по порядку ли у меня второй принцип могу сам сразу вопрос задать не очень понял где запускается вот этот изолированный сервис на радар и понятно и если есть какие-то вот как в предыдущем докладе было то что есть один контейнер который зависит от второго контейнера 2 зависит от 3 и так далее то есть там использовался докер кампус или тест контейнер как вот здесь вот здесь у нас там при поднятии нашего провайдера нам нужно ему еще два конторе поднять как эти зависимости разруливаются понятно итак для того чтобы тепло и микро сервисов а у нас происходит в uber найти в первую очередь и темплейты из крестьян скрипты мы используем фильм для конфигурации этих дипломов и офис описываем все зависимости в нем как правило фильм template темплейт ах у нас используется несколько сред то есть это про тест стейджинг которая как правило практически практически ничем не отличается за исключением каких-то информантов каких-то ресурсов которые выделяются на контейнеры то есть по сути описывая фильм конфигурацию micro series и мы описываем там все коды необходимые для поднятия всех аптеке которые необходимы правильно понял что фактически провайдер который нам нужен для тестирования консилера поднимаются в cabernet да да он также и работает в продакшене в кубе r'nessa также для них специальным дымовскому вернитесь разворачивается коды полностью повторяющее инфраструктуру с микро сервисов вроде вдв кластер кудрин месяца то есть тесты по сути идут на тоже нас тест допустим поднимаем провайдеров уберется прогоняем тест потом уничтожаем у заново поднимаем так далее все это прогоняется уже потом если все прошло бы тоже кубер вообще в принципе то вы все сервис можем залить но просто в другую среду праймер да верно отдельная своя чисто для этого теста да да верно второй момент запуск происходит то есть все зависимости описываются в этом фильм template ах на либо это тепло мин конфигурация либо это чарты которые тоже сущности фильма для поднятия базы если это как не какие-то жареные ресурсы возможно возможно шарин ресурсы допустим как баз данных для это зависит все от а то как как много вас ресурсов и можете ли вы действительно поднимать на каждый опущу micro series изолирую полностью полную конфигурацию микро сервиса здесь понятно а вот с контрактами для серфа взаимодействия как здесь можно применить ваш подход у нас до имеется асинхронное взаимодействие в теории не вижу никаких скажем так проблем применить данный подход для асинхронного взаимодействия так как в принципе суть такая же то есть несмотря на то что само действие синхронно у нас все еще могут какие то и месяцы ивенты которая по сути дела могут быть не стерилизованный ли раз porsche раз поражен его сервисов права потребителей но скорее в этом в данном котлет в случае необходимо добавить функционал тока к иметь эти вот эти ивенты скажем так то есть на данный момент так official нет это прибор который рассказать вас урока по самописный морально что еще воркута сидиси ну вы отказались от пакт и сказали что сделали по-своему это самописная проморгали где то можно получить его края самописная по сути дела это достаточно такой минималистичный подход то есть там пару скриптов чай который парсит парсит сидиси тесты из-за нативного в тестового фреймворка для микро сервиса например этот бетон или php это набор такой весьма маленьких скриптов и второй момент что было реализовано это написание сервисы брокера который содержит в себе вот эти взаимосвязи но также как бы там его api весьма примитивно пушем взаимосвязь васудевы узлы графа и с привязкой к докер образу для этого взаимосвязи кровать у вас пример были трудозатраты по разработке данного варварка что вот если мы сами решим такой писать и по пути может вы выложите свой хоп куда-нибудь ну на данный момент для реализации всего pipeline а скажем так от концепции до полной интеграции мы потратили 1 квартал и параллельно вели разработку два разработчика которые не full-time и этим занимались спасибо большое спасибо за доклад а такой вопрос а был ли у вас опыт тестирования сервисов по series провайдеров которые вам не принадлежат например там смежной команде юг от которых свой сайт то есть если есть там swagger контракт может быть можно там у замок из провайдеры тестировать их контракты да так и случаи тоже бывают но как правило из за того что у нас архитектура скажем так подошла очень серьезных проблем к тому как у наши micro series эдип ловится у нас есть мы используем три языка в основном для microsd это как я сказал pitch пик боулинг и питон у нас есть определенные бойлер плэйт и для incense oud ну для разворачивания нового микро сервис а также в темп лентах описаны как правило seo и описан базовый сей то как сервис тепло и ца то есть и как правило себя из микро сервис не сильно отличаются по этому сделать интеграцию и добавить какие-то sedisti тесты не достаточно большая проблема и на стадии любом случае парсинга тестов смысл в том что как правило за того что подход к диплом сервиса стандартизирован то есть это не вызывает проблемы спасибо саммита часа ожидания кассира пони где хранятся вы говорили что начали что они должны хранить свои их консилеров вас так да так происходит то есть когда предположим вот я показывал слайд у нас есть скот сервиса консилера скажем так у нас есть какой-то клиент в нем это могут быть вендор может быть внутренняя либо у нас есть какие-то взаимодействия между у нас есть какое-то взаимодействие с сервисом провайдером и разработчики сервиса консилера своих июне тестах или там фреймворке которые используют нативную для тестирования описывают и соленые тесты с употреблением этого метода и таким образом эти контракты находятся в репозитории сервиса концу мира но при этом на стадии ся и когда сей когда сервис выкатывается консьюмер в прод вся и парсит исходный код сервиса потребителя и группирует все вот эти анонсированные скажем так и ожидание в докер имиджа которые уже ассоциируется с определенной связкой консьюмер провайдер и запуска это связка запускается при уже изменение сервиса провайдера с точки зрения процесс как в этой синко из изменение от этих сценариев и изменение поведения проводя ну как правило если приходит какая-то новая задача разработчики делают скажем так и либо расширяют api либо добавлять новый метод и как правило те уже контракты которые ожидания которые уже есть данный сервис провайдер прогоняются что данным новые изменения никак негативно влияют на сервис потребитель это выкатывается на у сервис иным методом api и либо либо новым методом up"
}