{
  "video_id": "k2ccFXWdBN4",
  "channel": "HighLoadChannel",
  "title": "YDB: мультиверсионность в распределенной базе / Андрей Фомичев (Яндекс)",
  "views": 1584,
  "duration": 2416,
  "published": "2023-01-19T06:59:52-08:00",
  "text": "всем привет меня зовут андрей фомичев рад приветствовать вас на своем докладе про мульти version ность в распределенной базе данных в распределенной базе данных войди by простой доклад вообще говорят доклад про то что мы добавили им вестись и расшифровывается как мальте вершин кантор насти control в базу данных vdb если вы не очень знаете много правой гибель или провести ничего страшного доклад мне устроен таким образом что я сначала расскажу про базу данных войди бип радиоустройства потому что такое инвестиции и как мы собственно добавили им вести в нашу систему и какие преимущества отдала и так vdb это open source дистрибьюции цикл дтп с вообще говоря все слова важны и дистрибутив сиквел дайте bass это такой термин означает вполне конкретные вещи прежде всего это баз данных которая работает на класс tired распределенная база данных это база данных со строгой консистентной стью и она в общем то реляционная база данных то есть позволяет определенным образом организовывать данные и позволяет адресовать эти данные при помощи языка запросов sql также недавно там буквально 3 недель назад мы выложили систему в open source под свободной лицензией apache 2 0 ну собственно теперь мы open source базы данных несколько важных интересных фактов про твой dp есть такое здесь такая известная теорема cup теорема вот с точки зрения этой теоремы что такое vdp ну никакого magica мы выбрали буквы сеппи то есть мы обеспечиваем консистенция во время park shin hye ну и войти by обеспечивает сериала из был уровень изоляции транзакций также это хай левел и был высоко доступная база данных как мы этого достигаем с учетом того что мы выбрали себе ну достаточно понятный традиционный подход часто инсталляция в тебе работают одновременно в нескольких зонах доступности в несколько дата-центр войди by выживает продолжает нормально работать функционировать и на чтение на запись при потере любой зоны доступности и дополнительно к этому даже стойки в другой зоне доступности также с легкой руки одного известного человека это база данных называется mesh in critical дтп с что это означает означает она работает 24 на 7 и чуть более с технической точки зрения у нас для системы не требуется окна обслуживание мейтан ос windows для того чтобы система продолжала работать для то что можно было обслужить и так далее также важно заметить что войди by это не систем которые вообще все на свете умеет это прежде всего лтп базы данных хотя на самом деле мы активно занимаемся разработкой в том числе по колон снова хранения данных для аналитических задач а также стоит отметить что мы платформа это означает что на базе войди by рисованный не только баз данных на самом деле много разных интересных вещей таких как persistent на очереди даже сетевые диски для яндекс клауд и некоторая там серии из базы данных дальше мне нужно рассказать за 5 минут архитектура voy a baby я постараюсь очень быстро в целом описать что к чему прежде всего это архитектура шер на song то есть мы работаем на обычном кластере обычного оборудования комодики хардовые с чем пользователь сталкивается вот у него есть таблицы вот у него есть запросы к этим таблицам и они все выполняются работают на мощностях этого кластер когда мы говорим про распределенную базу данных важно сказать про проецирование про сортирования если у нас есть таблицы пользовательские то мы их некоторым образом разделяем на шарды paper диапазон от первичного ключа и таким образом у нас систем масштабируются мы любого размера таблицу можно представить как набор шар дав сами шарды они хранятся в специальном таком компоненте которая называется ты конкретно пользовательские данные хранятся в dodge or tablet таблетка или теплит это на самом деле супер важный примитив войди by про него сложно говорить но я вот основные характеристики перечислю стоит воспринимать его как в.ю. некоторые видео на данными которые хранятся в распределенном отказа устойчивым блок сторож хранилище ну не view такой даже адаптер почему адаптер потому что через него происходит операции сохраним метана данными это такая ядерная часть в и деби написан на си плюс плюс соответственно войти этот тип лет предоставляет на уровне выше некоторый слой но самом простом случае можно говорить что например этот и пей который она предоставляет это вставить удалить строчку в базу данных или прочитать строчку по ключу диапазону ключей часто в районе в тебе есть некоторые в районе таблетки есть некоторые волатильны и данные например кэш хранимых данных используется для того чтобы быстро отвечать на какие-то вопросы очень важно что если ты плиту умрет по разным причинам например потому что процесс крашнулся или машина умерла ничего страшного цыплят может подняться на другой машине в более-менее таком же не более менее в таком же состоянии наказав в тот момент когда он умирал это делается за счет того что tablet пишет лоб лоб распределенный отказоустойчивой на на слой дистрибьютора че если посмотреть чуть чуть внутрь таблетки то там есть разные слои один из них это реплики чин стоит машин фактически это слой который что нам гарантирует он нам гарантирует что данные непротиворечивы изменяются вообще в мире подобные гарантии дают алгоритмы такие как показ ровд это вот такой важный примитив отказоустойчивости системы дальше есть таблиц state & bass эта штука которая хранит данные это некоторые там lsm дерево хранит данные это значит опять таки она управляет структурами данных которые хранятся на распределенным хранилище и tablet обеспечивает для этих данных set- свойство сет гарантия то есть атомарные собственно изменений your ability и так далее вот дальше логика таблетки параметризовано то есть у вас есть разные типы таблеток которые мы в системе используя также важно сказать что в тибет современные баз данных которые слон и хранения и вычисления разделены то есть мы можем независимым образом масштабировать количество узлов которые выполняют запросы и количество узлов которые хранят данных вот для общего понимания сами таблетки они запущены в компьютерах и также выполняется запрос пользователя супер важное свойство тебе это то что там есть балансировка на разных уровнях например можно балансировать таблетки между узлами они могут перемещаться переезжать ну и точно так же с теми пользовательских запросов это все нужно для того чтобы равномерно гроза размазывать нагрузку на кластер и не была в такой ситуации что в большом кластеру у нас на одной ноге и цепью перегружено на других нет вот на экране есть некоторые типы таблеток do the shard который хранит пользовательские данные с кем shard который хранит метаданные например информацию о таблицах хайфа как раз так то таблетка которая занимается балансировкой таблеток по кластеру есть блок storage controller через который это сущность через которую операция с метаданными дистрибутора что происходит и еще координатор медиатор это сущности для того чтобы выполнять распределенные транзакции супер важная часть супер важное свойство тебе это возможность выполнять распределенной транзакции что такое вообще распределенная транзакция очень просто это по сути транзакция между несколькими машинами в кластере если у нас таблицы данных протестирован и то вот пример на экране это на самом деле запрос который меняет две строчки в разных таблицах 99 плюс процентов что эти партиции будут на разных машинах ну и выполните запрос но это как распределенной потому что ты это распределенной сущности как вообще выполняйте распределенной транзакции но вот если мы поймаем капот человек в коридоре и спросим как но наверное либо ничего не ответят либо скажет что распределенная транзакция надо выполнять двухфазным томи там это такое наиболее распространенный протокол у него есть преимущество то что он достаточно понятный простой везде используются вообще везде он даже в дебит где-то используется для метаданных то есть но самый простой способ сделать что-то распределена тем не менее у нее есть достаточно серьезный недостаток и не только тот кто то который написано в википедии про то что если координатор транзакцию умирает то там все плохо на самом деле в дивеево многие другие системы координаторы транзакции не умирают они если что восстанавливается потому что ты бля ты отказоустойчивый у него есть такой недостаток связано с тем что если мы выполняем множество транзакций единицу времени через двухфазной кометы у нас есть контент шины то на самом деле пропускная способность такого алгоритма не очень велика gdb для выполнения распределенных транзакций использует колвин такая статья такой алгоритм на слайде вы видите авторов и название можно найти соответственно колвин умеет выполнять детерминистический транзакции без блокировок этот и конфликтов этого очень круто то что можно выполнять распределенные транзакции без блокировок и конфликтов вот но к сожалению не все транзакции которые можно выполнить таким образом поэтому в тибет и сильно больше чем колвин там есть дополнительные возможности для для того как вообще когда в такой момент каким образом транзакции выполнять давайте чуть-чуть углублюсь что такое вообще детерминистской транзакция что это за зверь такой на самом деле простая вещь по определению транзакция в которой мы на стадии как бы запроса к нам от транзакцию показали мы знаем ключи по которым будем делать чтение и запись вот пример такой простой распределенной транзакции какие транзакции не являются детерминистские ческими ну например те которые с практической точки зрения ходят по индексу это означает что мы в общем-то не знаем до какого то какой строчке мы хотим добраться изначально почему потому что мы знаем как бы косвенные связи сначала читаем один раз потому что им второй раз и в общем добрались до данных вот в этом случае как бы просто к лавина недостаточно это не детерминистский транзакций как колвин выполняет детерминистический транзакции ну чтобы не было блокировок базовая идея очень простая даже об скал тривиальная если у нас есть координатор и в распределенной системе которые может упорядочить детерминистский транзак шанс некоторым образом таким образом что все участники этих транзакций dodge орды которые хранят данных будут выполнять эти транзакции ровно в такой последовать как координата решил то утверждаете что во первых не будет конфликта между ран за акциями а во-вторых мы еще и получим такое классное свойства как сериала и забыл и айза лишен этих транзакций вот базовая идея как войди by выглядит выполнение распределенных транзакций мы конечно используем колвин но недостаточно это почему потому что ну при определенных сценариях можно сказать что один координатор может являться узким местом но в распыленной с тем все что является одна штука с некоторой с некоторых размеров начнет не справляться и получать в этом месте проблемы второй важный момент что мы дополнительно умеем выполнять не dither мистические транзакции там некоторым специальным образом расскажу сейчас как и очень важно что войди by умеет оптимизировать 1 шар давай транзакции потому что вообще распределенные транзакции круто уметь их выполнять это важно и необходимо но это всегда дорого с точки зрения лай танцы для обычно на примерке в или нагрузки если у нас такая есть хочется не получать пенальти за координацию транзакции за дополнительный тип протокола вот в целом схема как выглядит выполнение транзакция через несколько координаторов вот у нас на входе есть набор транзакций и допустим два координатора любая транзакция может пойти пойти смысле начать планироваться абсолютно любым координатором на координатора есть такие кванта времени соответственно когда эти транзакции прилетают туда то для кванта времени координатор назначают последовательность выполнения транзакций после этого координаторы отправляют для завершившегося кванта планирования эти транзакции надо от шарды которые выполняют их тоже в заданном там определенном порядке возникает вопрос а вот когда дать чарт получает от двух координаторов порядок об иных мер джек но какой порядок должен быть правильный ну это решается например мы считаем что первая координатора всегда выигрывает у него как было транзакция запланированным первым идут вторым координатор вторым ну в общем таким образом у нас получается глобальная схема как мы можем быть транзакций упорядочить важно что на этом на этом этапе важно что каждая транзакция который мы запланировали она получает такую пару боев последую в последующем узнаём версии это пара первый план степ это такой это дискатор квантума который на самом деле привязан к волку аптайм к астрономическому времени и некоторые уникальный день в котором транзакции таким образом мы можем сравнивать вот эти вот идентификаторы как мы выполняем многошаговые транзакции в войде by вот как раз давайте вспомним пример той транзакции которое недетерминированные едет не детерминистский транзакция достаточно просто идея опять таки на поверхности мы любую транзакцию которой в базе данных выполняется представляем как набор шагов каждый шагов является детерминистской транзакции и проходит через механизм работа колено между ними мы выставляем локи и за счет локов таким образом гарантируем сериала и соблазна и дальше важный аспект у нас блокировки является оптимистичными поэтому не надо искать кит конфликты я имею ввиду смысле как это бывает в двух дуальном графе когда транзакция блокирует друг друга в этом смысле выигрывает так которая локи не сломанной которая закончилась вот в целом я рассказала ситуацию теперь вопрос что вообще можно в этой системе сделать лучшее что может быть работает не так хорошо как мы бы хотели на самом деле самая серьезная проблема на мой взгляд эта проблема с многошаговые мечтающими транзакциями это вот как будто вы грубо говоря читаете по индексу вы не делаете каких-то right of вы делаете один шаг для того чтобы узнать ключ и а второй шаг вы уже читаете собственно сами данной по индексу что на момент до внедрения имве сессия в систему какие проблемы испытывали первая проблема блокировки проверяются на комете поэтому мы не знаем основных блокировках до окончания выполнения запроса что это означает это означает что мы делаем ride на основе этих данных делаем 2 рид и после и вместе с этим видом делаем commit вот если у нас все получилось блокировки не словно все здорово в какой-то момент вы могли узнать что ой за время как бы между эти двумя рядами могли произойти изменения commit нам говорит как бы не могу закомитить транзакцию потому что проблема ну и нам приходится повторять потому что между нашими двумя рядами вклинилась какая-то записывающей транзакция вот соответственно чтобы мы хотели мы бы хотели чтобы комит на таких читающих раза акциях не надо было вызывать можно было просто читать читать читать читать и все хорошо соответственно это как бы наша цель и конкретно для пользователей чтобы на читающий транзакциях у них вот таких ошибок от базы данных типа transaction log инвалиды тит никогда бы не происходило вот она наша цель плюс если мы говорим про распределенной читающие транзакции то это распределенная транзакция значит они планируются координаторами о планировании координаторов некоторый процесс в рамках которого даже запись на диск есть в общем когда вас читающая транзакция хоть каким-то образом там приводит каким-то записи на диск это как минимум не очень приятная и хотелось бы от этого отказаться и решить проблему соответственно есть такой метод им вести молча вершин концу control которая часто для подобных задач применяется но не так-то просто его включить применить и так далее потому что есть во первых накладные расходы на версии во вторых взять нераспределенного снапшоты не так не так уж простая операция в распределенные по издано несколько слов про миссис си ну на самом деле это очень простая штука идея в том что вот если у вас есть некоторые табличка киеве лью вы фактически делаете два системных столбца к этой табличке это версия создание этой строке версию удаления соответственно когда вы вставляете или удаляете строчку у вас вот данные таким образом меняется 15 ротация вставила строчку 20 лет и удалила вот у нас к костру старков байт данных осталось но пользователь следующий который читает как бы уже не видит транзакцию но тесном что-то которые начались раньше могут дочитывать вот когда у нас еще одна вставка у нас уже при две строчки в базе данных что это дает это дает возможность взять глобальный snapshot для чтения данных и в рамках этого снапшоты ничего менять не будет никаких конфликтов не не будет можно просто читать данные snapshot берется как вот максимум из айтишников за комичных транзакций если мы посмотрим на зеленую полоску там вот самую последнюю то вот собственно этот максимум берется плюс те транзакции которые в полете на основе этих айтишников мы можем предоставлять консистентные view данных которые транзакция читает просто фильтруя как бы то что не нужно какие преимущества vitesse ну собственно как я сказал очень крутая особенность это то что конфликты рид райт исключены решил представляете у вас есть рид транзакция рай транзакция и они никогда не будут конфликтовать чтобы не случилось это как бы очень классно и здорово еще и вестись и позволяет дело сделать snapshot айза лишь на такой уровень это на самом деле очень популярный уровень и часто даже максимальный уровень в некоторых базан тонах вот есть такая известная табличка есть про то какие уровни изоляции вообще против существует сериала и забил такой со всеми зелеными классными галочками что значит или крестиками что все хорошо вот a snapshot и залочен имеет райские аномалию но сейчас не буду рассказывать о то это как бы долго соответственно но вот стали мы добавлять поддержка висящий как это работает вот вспоминаем слайд где есть таблицей the bass собственно структура которая компонент который менеджер структура данных вот туда добавляем традиционным образом мы добавляем версию создания версии удаления и вот если у нас есть row of type lifecycle мой вход мире момент берем snapshot от а вот snapshot один видит версию 1 snapshot 2 уже ничего не видит потому что удалена транзакция и 303 видит 3 на самом деле вторую версию этой строчке все традиционно вот таким образом если чуть техники и добавить кода вот таким образом выглядит собственно версии которые мы добавили они как раз состоят из двух компонентов это план степ координаторы такси и и на самом деле важная вещь они сравниваются вот тут есть некоторый тривиальный оператор сравнения вот таким образом выглядит структура данных перикард это то как представляется строка в войде by в этом смысле мы версии туда добавили так что нам нужно было обеспечить обратную совместимость и вот красный прямоугольничек fixed it says это собственно данные соответствуют схема таблици если у вас там есть куинтин 32 столбец вот там четыре байта будет выделено если у нас есть произвольный текст to a fixed to the site будет placeholder который указывает на область вырывался из диета и terra у вершин заметьте фактически были добавлены в were able to it says хорошо у нас были в хедере и соответственно бить и кеном показывает если у нас в наличии роу вершин и какие есть вот соответствие интересные факты про то что мы тут сделали на добавляли во первых мы можем включать выключать висеть и ну оказалась не только мы так можем некоторые баз данных тоже но это на самом деле очень удобная штука для того чтобы протестировать performance протестировать посмотреть сколько на месяц на диске место занимает и так далее вот так же важный момент что чтение из последних версий у нас собственно не пострадали поэтому чтение последняя версия происходит фактически также если мы читаем как предыдущую версию то мы идем блок history есть на самом деле очень интересная штука в тебе называется там за горизонтом фактически мы ограничиваем глубину snapshot of насколько в прошлом мы можем читать данные ну для того чтобы не хранить как бы бесконечно много данных 1 а ещё один важный момент что мы можем даже достаточно вот эти вот тяжелой версии в прошлом не хранить то есть если данные были записаны когда давным давно у нас там все уже перри компактно и там какой-то рабочий набор данных сказать которые активно в транзакциях участвовать небольшой тору вершин будет храниться у них у старых данных не будут храниться что на самом деле хорошо с точки зрения занимаемого места вот в этом смысле когда мы говорим про и вестись и очевидно есть некоторые там проблемы с оверхендом поэтому здесь на слайде более-менее посчитано сколько какой у нас overhead до 32 гбайт на строчку при этом не всегда мы версию храним иногда и 16 байт например если строчка не удалена ну естественно дополнительным храним предыдущие версии если такова логика приложение которое добавляет удаляет данные вот и после компакта но мы не храним данные за горизонт а также когда мы говорим про миссис си есть такое страшное слово вакуум в некоторых базах данных вызывает некоторое количество проблем ну хотя это как бы природа им висячие природ такой проблемы тут над сказать что достаточно неплохо все получилось у нас потому что выйдет и хранит данные в целостном дереве и соответственно этот чай с треском пак шин и компактно означает что есть перезапись данных и в этот момент достаточно легко избавляться от старых версий им отца от старых версий данных и может быть даже избавляться от версии записанных данных вот именно роу вершин потому что они уже больше не нужны вот соответственно можно этот процесс как бы compaq шин во первых сам триггере ци запускается в зависимости от ситуации там с данными на диске во вторых его вручную можно запускать есть фоновый compaq шин так что в этом смысле достаточно все хорошо вот и теперь такая сложная тема называется распределенное снапшоты войди by мало хранить версии в базе данных гораздо сложнее взять снапшоты которые обеспечивают глобальной view на вот этот баз данных в таких традиционных локальных базах данных ситуация чуть попроще потому что обычно в базе данных есть sequencer он там инкрементироваться и такая достаточно простая структура поэтому несложно и инкрементировать взять текущую версию и использовать ее как версию транзакции в тебе все сложнее во первых нет единого секвенсора понятно почему потому что будет плохо масштабироваться во вторых есть некоторые round trip и на то чтобы от snapshot взять ну распылённый с тем всегда достаточно много раунд рипов вот соответственно координаторы войди битка краски сущности которые помогают нам решить проблему взять эту snapshot в целом ситуация выглядит вот как на этом слайде то есть когда мы начинаем выполнять транзакцию вот есть к вере процессор который условно говоря за выполнение отвечает что он делает в первую очередь он берет get snapshot и ответственно пшат отправляется внимание на все координаторы и дальше мы используем тот план степ tx айди который мы получили первым ну то есть первое ответивший координатор быстрейший координатор дают нам возможность использовать snapshot и дальше в рамках этому snapshot а мы ходим просто на dodge орды и читаем данные к все прочитали в общем все закончили тут несколько вопросов один из этих вопросов это собственно а как координатор отвечает на get snapshot какой собственно план септик сайге и выдавать это на самом деле не очевидная штука и в зависимость от того что мы как делаем мы либо аномалии наблюдаем либо там какие-то проблемы с перфомансом и выбрать там правильный способ не так-то просто вот у нас соответственно картинки есть несколько план степов нет несколько want a move планирования соответственно мы вот когда план старт когда приходит в детстве на счет надо что-то выбрать и объяснить и вообще почему так выбрали ну первый очевидный способ а давайте вот там где сейчас транзакции распределенные планируется там и в рамках этого план степа выделим какой-нибудь tx найти но навернется можно сделать выделим его возьмем плюс-минус как бы работающий вариант но что что не нравится в нем что плохо есть пенальти то есть координатор он же фактически генерирует некоторую последовательность выполнения транзакций и пока вот он 10 миллисекунд не пройдет пока он в ранг пока эти 10 миллисекунд не на планирует в общем то нельзя пользоваться нельзя выполнять эти транзакции и не хочется получать пенальти нарядах в таком случае ok давайте что-нибудь давно в прошлом возьмем но там же все все выполнили запланировали перепланировали как бы нет никаких проблем ну с одной стороны правда если берем в относительно далеком прошлом то нет никаких проблем но из минусов там появляются такие неприятные аномалии вот на слайде показана если пользователь записала значение а и б в каком-то там предыдущем квантами и что он важно он записал уже получил ответ что он всё записано а потом приходится ридом и вдруг получается напишут сильно в прошлом он свои а а и b не видят как бы расстраивается это явно не тот experience который хочет пользователи явно не только про должна работ по сдано фактически мы тут показываем что пользователь не видит своих собственных записей соответственно вот таким образом мы берем snapshot таким образом отвечает координатор что он делает он берет последний план степ который она раза солдат шар дам который уже гарантированно перестал планировать и всем разослал и собственно это первая часть роу вершин который выдает а вторая часть роберт это максу и 64 то есть ответствен берет в рамках этого квантума самое-самое последнее значение справа и это является той версии которое который можно читать данные консистентные они не будут меняться не уже не поменяются для всех читающих тренд транзакций и вообще вот эта штука которая можно в данном случае использовать возникает вопрос про двух координаторов мы же как бы дождались первый из них не приведет лет каким-то проблемам на самом деле не приведет почему потому что фактически dodge орды они синхронизируются через координаторов вот если нам координатор один что-то отдал а координатор 2 еще не успел до планировать этот план степ то когда мы с этим план степом пойдем читать на dodge орды они нашу читающую транзакцию чуть-чуть придерживают до тех пор пока не получит все от каждого координатора и не закончится этим план стопам в этом смысле действительно можно ждать только 1 1 самого быстрого координатор это кстати очень помогает когда у нас все кро-кро сдаться и координатор этом раскиданы в разных частях очень важный аспект про который я бы хотел сказать это оптимизация медеи to ride right of и мидий to ride райт это по определению те которые идут в один шар и вот важно чтобы они выполнялись быстро вот на key value нагрузки чтобы иметь id транзакции не участвовали в планировании через координаторов и не было там дополнительных у копов ну в общем чтобы накивале нагрузки все было классно соответственно вот эту проблему пришлось отрисовать и здесь показана картинка зад шар дом то есть иметь ее транзакция не прям сразу приходит на тот шар возникает вопрос к как собственно надо выполнять в какой последовательности нот синеньким здесь цветом показано запланированной транзакции они вот где-то в рамках этого квантово входит последовать запланированы если приходит и медиа 3d то на самом деле можно их выполнять более менее в любом месте и как можно скорее чтобы на чтение иметь это отвечать как можно скорее записями все сложнее но прям вот по настоящему сложнее потому что у и мидии trade of нету план степа ты кстати который какой не координатор выдал в этом смысле если выполните транзакцию сейчас мы можем повлиять на тот snapshot который уже был взят и в общем получить неприятную ситуацию в итоге во двигает такие медиа трой ты на самое начало следующего степа это как бы безопасно в этом смысле мы немного пессимизм ruim вот эти вот и медиа траты и это сделано намеренно для того чтоб сильно упростить и ускорить ритм очень важный момент что все это работает только если этот механизм включается если у нас в очереди есть распределенные райт и если их нету можно выполнять быстро что это означает это означает что для киева или нагрузки все будет как раньше то есть хорошо ну вот вопрос и что как бы делали делали что-нибудь еще осталось на самом деле осталось потому что когда все это запускаешь и так далее не так все просто и нужны некоторые определенные оптимизации которыми также выполнили там включая лиза координатором protect отрицает а что происходит когда происходит сбой dodge орда его нари стартует там много корнер кейсов подробности уже наверное сложно рассказать в рамках доклада но тем не менее после всех этих модификаций в целом все хорошо заработала ну и вот интересный слайд по производительность что значит хорошо заработала сравнивать надо первые третий столбец и 2 4 но первые трети они были менее одинаковы и поэтому не так интересны грубо говоря это сингл перед запроса то есть и me dit а вот 2 4 это прям интересные skates и грубо говоря раньше читающая транзакции были сложные распределенные координированные и обратите внимание что там и пропускная способность была низкая там чуть больше двух тысяч транзакций в секунду а после включения в сеть и и latency улучшились многократно и сруб от вырос там где то до 10 плюс 11 к в секунду но не все так идеально там есть некоторые на right of ухудшение вот но я показал красивую картинку нюансы можно определить пройти можно там чуть более конкретно обсудить уже может быть после доклада вот и почему он пример не с первый раз запустили в висе потому что одно дело теория другое дело практика вот на экране простейший пример самого негативного сценария для висящий которые мы обнаружили что делал пользователь пользователь делал select в базу данных 1 шар давай получал ответ а потом такой раздел iv века мид ну на самом деле комету совершенно бесполезен потому что он получал правильную картинку но программ было написано так что он делал select там commit очень программ неэффективно но именно на этой программе скорость ноги скорости время от времена ответов выдаст рафи чески падали вот на первой версии как падали от приблизительно вот так вот то есть первый столбец это то что было бедным вестись и второй столбец это как бы исходная версия вестись и которые у нас появилась и 3 4 это уже после всех оптимизации с разными размерами план resolution степа то есть вот там 10 миллисекунд или 5 миллисекунд и заметьте даже стала где то лучше более такого темно-зеленого в одну миллисекунду ложился вот ну собственно теперь выводы что мы сделали мы добавили поддержку им вестись и в базу данных и добавили поддержку snapshot ride ну то есть теперь можно читать данные включая распределенные рик транзакции где не надо думать про локи что они ломаются и в этом смысле конфликтов здесь нету также естественно вещь можно подумать просто желтой за лучше просто как у нас вместе появился но подумаем потому что совершенно неоднозначно что надо бежать и делать потому что уровень за верности хуже отдаст ли он performance какие-то benefits надо смотреть соответственно протестировать производительность и на самом деле обнаружили что можно разные новые интересные сценарий делать например консистентные вторичные индексы без распределенных транзакций и увесистый позволят такую штуку сделать а это такая с практической точки зрения очень прикольная вещь . обычно канал добавлять индекс системе поставляется распыленной транзакции light in se запрос который мы привыкли они падают ну извините как бы распыленной транзакции вот а можно благодаря вот некоторым приемам сделал так что вообще не падали почти не падали как то так спасибо спасибо большое у нас есть немного времени на вопросы я для начала задав вопросы из чатиках первый очень простой вопрос если лимит размер одной таблетки на размеры на размер одного ты плита сейчас если лимит на размер 1 т плита цыплята да конечно есть в том смысле что по дефолту у нас размер одного tablet 2 гигабайта ну там можно конечно ставить выше но грубо говоря в какой-то момент просто запрос начнет медленно выполняться потому что параллельность она тоже на уровне цыплята поэтому стараемся ограничивать и второй вопрос из чата как организованный больше еврей был союз большие-большие variable сей союз строки variable сайт строки окей сейчас они на самом деле это точка роста на самом деле такие вещи известным образом как реализовывать фактически над делать так что у вас какая-то большая строка разбивается на ногу маленьких и баз данных вам помогает менеджер в этом смысле сейчас пользователь приходится делать снаружи благодаря транзакциям от все можно делать но понять что не не так удобно если бы она появится функциональность было бы здорово времени у нас немного но на пару вопросов из зала мы точно успеем ответить вот я вижу там очень хочется задать вопрос не говорит здрасьте я здесь в центре вот по диску вы говорили 32 байта вернисаж это на все на все данные я галина определенной операции это на одну строку а понятно но я между на строчку вообще в целом или же при определенных операций как под гариком на апдейт например или по и дефолт на одну строчку всегда у вас 30 бат идет дополнительно это 32 байта на одну строчку грубо говоря всегда если . не за горизонтом но в моем понимании в подгрести тоже никуда не денешься от хранения версия но они там поправьте меня меньше занимают одна версия 16 байт а меньше давайте последний вопрос на добрый день мой вопрос есть такой известный тест на безопасность распределенных баз данных jepsen поделитесь проходили не проходили результаты это в планах потому что правда тест очень хорошие важный вот и прим в планах пока мы были как бы в него конкурсу внутри в общем-то всё было более менее хорошо хоть популярный вопрос но сейчас явно в эту сторону надо работать чтобы были независимое подтверждение"
}