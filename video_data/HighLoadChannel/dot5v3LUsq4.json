{
  "video_id": "dot5v3LUsq4",
  "channel": "HighLoadChannel",
  "title": "Как мы разрабатываем новый фронтенд Tinkoff.ru / Филипп Нехаев (Tinkoff.ru)",
  "views": 7347,
  "duration": 2903,
  "published": "2017-04-22T14:47:57-07:00",
  "text": "следующий доклад про новый фнн тиков сайта ovr вот доклад честно не проплачен если что всё вообще всё хорошо В общем всё честно всё честно да поприветствуем Филиппа Всем привет Меня зовут Филип Хаев Я занимаюсь разработкой и архитектурой интерфейсов в теньков банке И сегодня я хочу рассказать вам о нашем опыте разработки нового фронтенда. доклад будет построен следующим образом Сначала я расскажу о наших задачах затем сделаю краткий обзор предыдущих стеков и к какому стеку пришли затем затронуть тему переиспользование и оптимизации сборки и кае зада ремен супермаркет где любой пользователь интернета может воспользоваться нашими финансовыми услугами начиная от оплаты мобильного телефона и до там покупки акций от поиска налогов и до там оформления ипотеки всего месячная аудитория .ru составляет порядка 7 млн уникальных посетителей в месяц и над ННМ работает 30 разработчиков и мы ищем новых чиков что было раньше в 2011 году мы запустили сайт и инет банк на бке было тяжёлое Java spr приложение шаблоны писали в jsp на клиенте был совершенно непохожий стек это jquery handlebars backbone и всё это ещё первое время собиралось маном что было жутко неудобно и мы довольно быстро научились прикидывать в gsp ссылки до сетов и перешли на грант парадигма разработки старого сайта влекла за собой поддержка двух двух слоёв один слой Находился на сервере а другой на клиенте и как правило это приводило к дублированию логики и требовало двух групп разработчиков то есть фнн разработчик по сути не мог решить весь Спектр задач и приходилось искать энд разработчика решать с ним какую-то проблему задачу и только после этого передавать в тестирование также новы новые фнн Разработчики если они не были знакомы с Ява структурой с Ява приложением затрачивать довольно много времени на развёртывание окружения и вообще чтобы разобраться во всём этом тоже большой минус И следстви всё это влекло более дорогую поддержку помимо основного сайта вчем году мы запустили проект теньков кошелёк это ну сравнительно небольшое приложение но оно было интересно тем что здесь мы впервые опробовали изоморфный подход ренли часть в на сервере архитектура была mvc использовали шаблоны handle bars и в целом Мы свои задачи выполнили всё было хорошо но было понятно по итогу что на более больших приложениях на более больших сайтах такой подход мог принести больше проблем то есть у нас не взлетело из мор mvc было сложности были сложности с обогащением данных на клиенте приходилось писать отдельные контроллеры Для клиента и для сервера и в целом на следующем проекте мы выбрали полностью sle page Application Пади мы использовали Это был проект новы интерфейс банка мы использовали JS и также все свои задачи решили ну как это обычно бывает приходят новые требования ОТ заказчиков о которых мы не думали год назад допустим и это бы была задача там написать новы объединить всё в единую платформу собственно при sle page алике у нас был один UI слой только на клиенте но мы не могли довольно легко решить задачи SEO и smm А это было довольно критично в новом проекте и мы рассматривали пару вариантов развития существовавших стеков первый - это оставить sle page на клиенте в виде ангуляр а для сервера написать новое приложение серверное на носе это бы решило наши многие проблемы Но не избавила как бы от корневой проблемы Когда было два UI слоя и второй путь развития который мы видели это не писать серверное приложение а использовать существовавшие наработки в виде SP приложения просто это приложение рендерить на сервере с помощью безголового браузера Phantom JS нам такое решение показалось непригодным для продакшена потому что во-первых довольно сложна было сложно в отладке и и на большом количестве страниц могло принести Там определённые проблемы Ну собственно у нас планировалось довольно много страниц и мы посмотрели в сторону универсального приложения Извините и новый сайт мы написали в этой парадигме за основу взяли архитектуру в Каст и но новый сайт новый проект объединил под собой всю функциональность старого сайта интернет-банка кошелька запустили новые брокерские услуги и в ближайшее время планируем множество новых продуктов на базе этой платформы собственно здесь мы наконец-то решили нашу как бы основную проблему мы объединили два U слоя в один слой в одну кодовую базу на Ява скрипте стали поддерживать не затрачивая дополнительные ресурсы научились переиспользовать почти что весь код между клиентом и сервером за исключением там какого-то специфичного кода допустим как работы с куками и пришли к одной группе разработчиков сейчас JavaScript разработчик может решать весь Спектр задач и не прибегает там к помощи разработчиков с другой экспертизой следствие увеличилась скорость разработки что нам очень нравится и ещё один из плюсов сложившейся архитектуры - это отсутствие монолитно наше приложение строятся из множества небольших независимых модулей то есть мы не зависим от одного фреймворка от одного вендора и При желании любо можем заменить любой из модулей на какую-то другую реализацию более совершенную или написать свою реализацию в теории даже можем заменить там шаблонизатор в виде реакта на другую реализацию Виртуал дома за основу мы взяли реализацию Flexible это реализация от разработчиков из Яха они на нём делают новый Яха mail и на тот момент э реализация показалась наиболее подходящей под наши задачи она была ориентирована на изоморфны и довольно проста но мы используем не весь реворк а взяли только два модуля это роутер и дипар роутер реализует материю по страницам Он поддерживает экспресс подобные пути довольно быстрый сейчас роти более чем по 3.000 страницам и изоморфный работает на и в браузере иче это реализация диспетчера распределение архитектуры постоя выглядит следующим образом есть есть слой работы есть слой с сервисами через них происходит доступ к внешним II к внешним данным к браузерный ipi там чтобы работать с браузер хранилищами обращение к внешним веб-сервиса там содержится часть бизнес логики и сервисы могут обращаться к другим сервисам следующий слой - это действия действия там содержится часть U логики часть бизнес логики и только действия имеют доступ к сервисам дальше ры там содержится полностью логика и состояние всего приложения и слой с компонентами они со в htm прини запроса на на сервер на сервер там происходит роутинг на под приложение так как помимо раздачи htm мы должны раздавать немного статики иконки Robot там или Сай мапы и немного утилитарных веб-сервисов Ну если происходит роутинг на основное приложение там происходят запросы на внешние сервис загрузка всех данных происходит поиск редиректа если мы находим Red для для запрашиваемой страницы то отправляем Location htp 301 собственно раньше ну в старых приложениях FR разработчики порой решали такую простую задачу как дирек там Как дирек через клиентский Директ то есть приходилось выгружать все ресурсы в браузер и только после этого происходил дирек что было в десятки раз мелене сейчас это решается всё очень легко и непринуждённо ну и собственно Когда происходит весь этот рендер в HTML происходит стерилизация состояния состояние которое было накоплено в процессе запроса на сервер и передача в браузер htm и этого состояния браузер создаёт свой контекст приложения производит стерилизацию состояния вызывает все действия которые не были вызваны на сервере и запускает как бы клиентское приложение после этого наше приложение работает в браузере полностью как Single page Application не запрашивается сервер Что благоприятно влияет на нагрузку на наши сервера и собственно цикл приложения жизне цикл жизненный цикл приложения завершается на Ну вот на взаимодействие пользователя с ним ещё из интересного про контекст на сервере каждый запрос на сервер порождает свой Независимый контекст приложения это сделано для того чтобы максимально разграничить разные пользователи ки данные которые могут существовать в этом запросе и как бы обезопасить нас от множества э проблем единственное где запросы могут между собой чем-то обмениваться это находится на уровне с сервисами сервисы имеют свойство кэшировать и этот кэш Может переиспользовать между разными запросами то есть чтобы каждый запрос в отдельности не бегал к внешнему источнику данных там один раз там кто-то сбегал э всё это записал в ш и сервис уже быстро отстреливает этими данными Прогрессивная загрузка подход универсального приложения дал положительный эффект в виде прогрессивной загрузки которая благоприятно влияет на пользователей с медленным интернетом такие пользователи видят гораздо быстрее какой-то какой-то каркас приложения могут пользоваться сайтом переходить по страницам получать информацию а в фоне загружаются все остальные данные в том числе там если пользователь был авторизован загружается персональные данные происходит инициализация клиентского приложения и Собственно как бы этот каркас дополняется мы можем рендерить все данные на сервере можем рендерить только часть данных на сервере можем вообще отключить серверный рендер И использовать как полностью только клиентскую часть Собственно как мы управляем тем что загрузить на сервере мы это разруливает криэйтора это функция во Флакс которая создаёт Action у этой функции есть свойство из сервер указав которое мы разрешаем эту действию выполниться на сервере если у этого флага свойства нету то вызов действия будет пропущено второе интересное свойство которое есть на уровне Action криэйтора это Create required Rolls у наших клиентов может быть множество ролей Там могут быть лёгкие клиенты которые вошли только по номеру телефона и не являются нашими клиентами могут пользоваться услугами есть тяжёлые клиенты которые там имеют банковские продукты и могут пользоваться полной функциональностью соответственно здесь мы можем перечислять лист таких ролей если ролей не хватает то как бы вызов действия тоже будет пропущено из интересного на этом слайде можно увидеть пример вызова сервиса текста который мы передаём в Action Creator и по успешному результату вызова сервиса Мы в диспач мы диспетчеру действия с полезной нагрузкой переиспользование мы довольно быстро столкнулись с проблемой Перес не только в других приложениях другая архитектура и так далее Но даже в рамках одного приложения когда компонент когда компонент должен был работать с несколькими источниками данных там разные модели и так далее и код такого компонента превращался Ну в довольно сложный код там появлялись странные условия тестировать его было всё тяжелее и тяжелее и стабильность его пось перек когда делим компонент на два компонента наве подход довольно популярный сейчас становится собственно первый первая часть это компонент conect вторая часть - это чистый компонент компонент конектор знает О всём окружении приложения знает как получить данные из торов получает их передаёт в чистый компонент через проти обрабатывает колбеки в случае необходимости и вызывает действия Ну и чистый компонент в свою очередь получает эти данные из прон данные в HTML обрабатывает дом события вает колбеки собственно такой подход решил нашу основную проблему с переиспользование мы сейчас можем легко вытащить чистый компонент там и перенести его в другое приложение или написать свой коннектор для каких-то новых данных и и тестировать стало легче и код стал проще вот что из себя представляет компонент connector довольно типичный То есть он подключает в себя чистый компонент и мы используем свою утилиту Connect которая очень похожа на конектор из редакса это утилита принимает на вход список сторов в которых мы заинтересованы и при обновлении любого из этого стора вызывается функция маппинга которая принимает в первый аргумент состояние всех сторов и возвращает только те данные которые нужны чистому компоненту и ещё один из наших решений которые мы приняли в ходе разработки приложения это переход Ну на High Order components это компоненты высокого порядка которые позволяет составлять композиции они могут гарантировать своё окружение свой контекст их можно тестировать они пришли на замену ксим так как мы изначально начали использовать миксины потому что в классе была поддержка этого подхода для переиспользование кода но столкнулись с проблемой что не могут гарантировать своё окружение не могут там явно объявить От чего они зависят их тестировать сложно если на вашем компоненте больше двух-трёх кнов то поддержка такого компонента становилась очень проблематичной оптимизация пользователю важна скорость загрузки и скорость работы ве интерфейса и оптимизация универсального приложения находится на двух сторонах Первое это клиентская сторона вторая - это серверная сторона оптимизация на клиенте Первое правило быстрых компонентов это как можно реже вызывать метод рендер для этого мы повсеместно используем подход render который позволяет не вызывать рендер если исходные данные не изменились то есть или про не изменился то рендер не будет вызван но эта защита не всегда срабатывает по тем или иным причинам если у вас какие-то сложные структуры данных или разработчик неправильно работает с изменениями данных потому что мы не используем повсеместный мутабельный подход и бывает возникают такие проблемы ког не спасает собственно для поиска проблемы проблемных компонентов мы используем пово убм виде и количество рендеров того или иного компонента и если тот или иной компонент довольно часто перерисовываю мы его диагностируем более подробно для этого у нас есть ули rer loger который подключается в виде декоратора и логит в консоль в удобном виде изменённых данных тех данных которые пов повлекли вызов рендера и как правило вызов рендера происходит из-за того что компонент подписан Ну получает лишние данные в которых он никак не заинтересован и получается он как бы вхолостую рендерится и решается довольно просто там убрав там ну не переда Ну отказы от лишних данных и вторая проблема которая у нас была раньше распространена - это э создание функций в методе render и на вот скриншоте видна Как раз эта проблема когда вроде функция одинаковые но они не эквивалентны это случается как правило из-за того что Bind вызываем прямо в рендере или функцию там ER function допустим прямо в рендере пишем мы так никогда не делаем больше не делаем объявляем Ну привязываем контекст где-то в конструкторе где-то вне метода рендера чтобы не создавать каждый раз новые функции и Для этого нам помогает НН ES lint с плагином react и включена опцией GSX No Bind собственно эта опция запрещает использование банга и объявление функций внутри рендера следующее что мы практикуем это использование bch updates react имеет возможность включение какой-то кастом стратегии рендера и B upd позволяет накапливать пакет изменений и применять их единоразово к дереву компонентов но мы эту стратегию используем не постоянно только в момент повышенной активности приложения эта повышенная активность происходит при первоначальной инициализации приложения в браузере или там при переходах по страницам И следующий способ ускорения который мы довольно активно используем это визуальные ускорения эти ускорения дают наибольший эффект с наименьшими затратами покажу на нашем примере на главной сайта есть шапка где ност типов и при медленном интернете при Ну допустим мобильнике пользователь видел довольно продолжительное время пустую шапку серую он как бы ожидал чего-то и мы проанализировав эту ситуацию поняли что можем ускорить вот это вот поведение этот плохой визуальный эффект с помощью серверного рендера просто немного факторив компонент и наши стили смогли серверный ндер и пользователь начал видеть эти логотипы гораздо раньше чем ранее то есть загрузив HTML и CSS логотипы уже стали появляться А в фоне загружался весь остальной JS оптимизация на сервере собственно простых строковых ров это Т за большие плюсы Виртуал дома первые два способа они наиболее банальные наверно их все уже используют но тем не менее дают четырёхкратный - это использование классов это в разы быстрее класса потому что класса класс поддерживает автодин функций То есть вы можете не Объявлять там явно контекст у обработчиков событий а он сам делал соно из этого мене работает второе мен прок э переменная отключает вен и профайлинг когда он не нужен следующий способ который даёт всего 2% прироста это фирон версия ректа на сервере в этой версии совсем удалён код который как бы нужен для профайлинга Ну то есть убраны лишние условия с спосо иние трансформации кода мы используем для jsx компонентов для компонентов д плагина Первое - это constant Elements который анализирует ваш код находит объявление компонентов и поднимает их в корневой скоуп модуля Что позволяет единоразово затратить время ресурсы на инициализацию и при повторном вызове какие-то там функции рендера допустим вот это вот всё вызов функции и преобразует их более оптимальному формату в совокупности эти два плагина дают перерост скорости в 10% следующий способ у нас был тестовый стен где мы грили порядка 500 компонентов с разными уровнями вложенности и при переходе с обычных компонентов на функци есть функции кото самы комне проперти в себя и вот переход полностью Нате с функции дал прирост в 45% И следующий способ наиболее эффективный это модуль react dom Stream вчера о нём уже Немного рассказывали он даёт прирост 55% этот модуль преобразует результат render to стринга который используется используется на сервере в поток э соответственно это сокращает время до передачи первого байта по нашим замерам это там через 5 миллисекунд сервер уже отдаёт первый байт и сокращается последнее время передачи байта достигается за счёт того что все компоненты рендерится асинхронно и разряжай loop дальше кстати в ре дом стриме появилась Экспериментальная фича в последней бета версии которая позволяет включить кэш на уровне компонента то есть всё что вам для этого нужно это объявить определённый метод который возвращает ша если ключ ша не меняется то повторный рендер вызов повторного рендера будет возвращать результат из кша собственно что потенциально должно дать большой прирост скорости но мы сейчас это не используем потому что особо не нуждаемся по причине того что ширу всю страницу полностью нам пото нежные деви на сервере собственно которые не нужны там для основной нашей задачи для SM и мы ещё независимы от юзера Агента потому что у нас полностью адаптивная вёрстка и сейчас наш кэширует все наши страницы там на несколько минут собственно защищает нас от всех внешних воздействий наши сервера нисколько не загружены следующее что мы используем для ша это модуль этот модуль позволяет обезопасить приложение от потока однотипных запросов этот модуль мы используем больше так ну на всякий случай особой необходимости в нём не было И следующий модуль для кэширования - это ру кэш который мы используем для кэширования результатов сервиса по умолчанию этот модуль удаляет кэш По истечению тла По истечению время жизни кша но мы его немного доработали и на этом скриншоте показан два состояния кэша обновлённая актуальный кэш и неактуальный Кэш который требует обновления собственно при первом запросе сервиса сервис моментально во защищает из каша значение при втором и третьем запросе значение также моментально возвращается из каша но мы знаем что это значение уже неактуально и требует обновления и в фоне запрашиваемый источник данных как только данные пришли мы записываем в кэш и последующий запрос также моментально получают эти значения но уже обновлённые подобный подход нам позволил повысить отказоустойчивость нашего приложения и как бы понизить зависимость от других систем потому что бывает часто такое что система одна система падает и тянет множество других и вот подобный подход нас защищает от такого падения То есть если мы хотя бы один раз получили данные необходимые для рендера мы их уже никогда не потеряем сборка мы собираем приложения для отдельные бандлы отдельные артефакты Для клиента и для сервера поначалу для сервера мы ничего не собирали просто заливали код что который был в репозитории и там всё запускалось но со временем первые запросы к серверу стали проходить довольно долго потому что там мы используем бабел и он компилировать добавить этап прогрева приложение собственно это не нравилось очень админам и мы добавили пере компиляцию кода и для сервера тоже То есть перед перед сборкой мы компилирует мы после этого мы имеем кодовую базу которая готова к заливке на сервер приложение быстро стартует и на основе этой же кодовой базы собираем клиентский бан Клинский артефакт такой подход что не увеличивает итоговое время сборки то есть время затраченное балом один раз оно переиспользовать по сути в двух артефактах вот а второй подход который можно использовать для сборки универсального приложения - это эпак и два две конфигурации в пака одну для сервера другую Для клиента они отличаются немного но тем не менее увеличивает э время сборки что в нашем случае очень критично э следующая тонкость мы не записываем никакие переменные окружения в наши артефакты в наши пакеты а передаём их только в при старте приложения в переменных окружения мы передаём ссылки до эн поинтов до внешних серверов до там до II уровень логирования и так далее и собственно э если их нужно быстро поменять мы не должны пересобрать приложение просто там перезапустить сервер с нужными окружения соответственно как это всё передаётся на клиент довольно просто через процесс стерилизации и де серицит Я чуть раньше рассказывал И тем самым как бы мы имеем консистентной экземплярах приложения на сервере и на клиенте плой при деплой при запуске приложени мы используем утилиту pm2 это утилита имеет довольно обширные функциональность но мы используем лишь малую часть первая - Это команда Start or Full reload которая позволяет минимизировать время недоступности сервера при его пло и второе мы стартуем каждый экземпляр приложения на отдельном Порту с помощью P2 это делается очень легко просто нужно учитывать определённую переменную и собственно Если ваше приложение запущено более чем на одном сервере то между ними всё равно что-то балансирует И вот в этой схеме not JS кластер становится лишним и при переходе на запуск каждого экземпляра на отдельном порту мы добились как бы ну мы убрали лишнее звено из этого процесса и сейчас наш балансер знает о всех форка на всех серверах что осталось э собственно так как мы наши наш новый сайт разрабатывали Ну в довольно динамичной атмосфере как это обычно бывает остаётся какой-то технический долг и сейчас мы ищем хорошее решение для автогенерация для компонентов изначально мы начали эти дамо страницы собирать вручную но при резком росте количество компонентов поддержку таких страниц как бы такие страницы стали довольно быстро устаревать и требовать больше и больше ресурсов на поддержание второе это если у Вас планируется большое приложение то чем раньше Вы задумано разделении на банды Для клиента тем лучше сейчас мы ищем хорошее решение потому что у нас очень много страниц и мы ищем решение для какого-то такого умного генерации там балов на основе наших Ротов и ещё небольшая проблема которую мы решаем - это ускорение сборки стилей мы используем лес лес лодер и к сожалению рез К сожалению стили стали долго собираться если мы отключаем лес лодер то сборка происходит в четыре раза быстрее собственно ищем решение и э-э собственно что я хочу сказать в итоге универсальное приложение - это просто оно решает все поставленные задачи перед современным веб-приложения Я думаю Э в целом стоит попробовать этот подход Спасибо за внимание раз вопрос Здравствуйте В феврале прошлого года на хабре вышла статья про то как делали приложение на ангуляре для банка Сейчас вы рассказываете про приложение на реакте сколько времени заняло переписать всё приложение с агура на react И сколько человек это делало ну новый проект он подразумевал даже больше функциональность чем на старом интернет-банке и так как у нас работает довольно много разработчиков мы это сделали меньше чем за год е перев свой сат ето приложения функциональность из перенесли чуть меньше года то есть там у нас разработчиков сейчас там почти что 30 вот тольки программисты и вот там небольшие группы все разделены и довольно быстро Думаю разработали ВС равно можно похлопать Скажите как вы решили проблему контента а изменения контента вроде ЦМС у вас какой-нибудь както связано с билда Ну да я вот мы убрали слайды про нашу админку на самом деле старый сайт он работал на там на на определённой энтерпрайз системе и использовал там определённые цмку и мы тоже всё это переписали написали отдельную свою админку это другое отдельное приложение котора выдаёт весь контент все страницы и так далее И на самом деле слабая связанность между основным сайтом и вот этой админкой то есть там Они общаются по определённому и с этим Да есть небольшие сложности когда там разъезжается кодовая база и то что в админке потому что у нас там допустим есть тестовый контур один тестовый да И множество кодовых баз при разработке и вот у наших разработчиков есть правило если чтото из в админ то нужно думать об обратной совместимости то есть по сути у на одновременно существует много версий которые могут упасть изза которые могут стать неправильно работать изза неправильной настройки в админке вот ещ можно ещё подскажите Вы получается так как вы отрендерить на сервере например которые требует именно браузерных вы как-то их оборачивали там проверки просто какие-то идут Ну на самом деле так требует брауз допустим браузер хранилище и так далее но у нас таких задач нету И мы пытаемся таки задачи избегать Но если нужно будет то скорее всего вым э на лите э сер у нас сервисы ещ разделены Ну у на есть общие сервисы есть реализация есть сервисы которые работают только в браузере толь или только на сервере и вот код работы Допустим мы вынесли в этот сервис который вызвался бы из действия а действи вызвало бы только в браузере вот с Спасибо за доклад у меня тако вору ког за получить данные в этом данные айдини мне надо сделать ещё один запрос по этому айдини это всё глубже и глубже там запросы за запросами И вот так вот и ещё один вопрос Как вы остались ли у вас внутренние стейт у компонентов как там у пдау и открыт не открыт всякое такое в зависимость разных запросов Да друг от друга Мы довольно легко разруливает можем строить там любые цепочки из промисов То есть все наши сервисы они асинхронные возвращают промис и всё очень легко разливается Но мы пытаемся тоже избегать Именно таких сложных комбинаций данных Да потому что ну множество запросов и пытаемся именно чтобы возвращал какие-то уже готовые данные Ну чтобы мы не получали один запрос там не делали там ещ по второй запрос Ну то есть довольно долгая схема и мы пытаемся избегать такого в целом вот на уровне экшенов там цепочка сервисов Вот и ВТО вопро внутрение Стой не считаем Это какой-то плохой практикой это влияет положительно на скорость работы приложения если бы мы хранили любые там ну даже не значимые значения Да какие там допустим если в селекте там состояние селекта и всё бы это прогоняли через ГС под поток Ну через общий поток приложения то как бы ну просто общий поток диспетчер бы он заполнялся ненужными действиями Да и как бы это легко разливается на уровне на уровне компонента И тем самым его делает более независимым и более лёгким в переиспользование то есть мы независим на какой-то там реализации на фреймворке просто компонент самодостаточный и всё понятно спасибо большое Здесь вопрос и микрофон вот сюда ещё пожалуйста Спасибо за очень интересный доклад здесь я сказал вопрос в начале Вот сюда можно посмотреть сейчас потом Здравствуйте спасибо за доклад было интересно у меня вопрос такой вот пото года назад вы гуляр и как-то им менеджерам сказали нужно всё переписать Они наверное нервно отреагировали и через год вы сказали нужно всё переписать на как они отреагировали на это ну мы менеджерам не говорим что нужно что-то переписать говорим какой срок нужен для решения той или иной задачи и мы сами решаем Ну то есть мы как технические специалисты мы понимаем что лучше выбрать для более долгосрочного развития Да проекта то есть нас появлятся новы Да от заказчиков что нужно что там в перспективе будет И вот как раз вот я рассказал что Как Мы пытались остаться на сущест ну на существующем стеке да то есть как можно sle page Application дальше развивать но в целом как бы были другие варианты мы посчитали те трудозатраты тот некий оверхед Да как бы ну разумным собственно спокойно написали и сейчас приложение довольно хорошо работает и новые разработчики в НМ быстро разбираются и новые задачи делают Спасибо но всё же когда вот менеджер спрашивает о сроках Говорите один срок И тут вдруг срок 2x они обычно спрашивают А что случилось Почему там был абсолютно новый проект он даже по дизайну сильно отличался в целом мы изначально предполагали переиспользовать то те наработки которые были в старом интернат банке Ну на ангуляре написанном и в целом их логика она не меняется и там новому разработчику можно было просто открыть этот код посмотреть как это работает и как бы ну по сути просто портировать на какую-то новую архитектуру вот в этом плане мы как бы не сказать что прямо полностью переписывали с нуля То есть у нас уже были какие-то знания какие-то экспертизы и вот здесь вопрос Спасибо за очень интересный доклад У меня вопрос такой на одном из слайдов где вот вы показывали архитектуру вашего нового приложения есть такой квадратик бизнес логика Да уга вот а в банковском приложении бизнес логика - это вещь довольно тяжёлая потому что ну там есть очень много разных проверок там получение там данных из разных подсистем Там и так далее вот вопрос такой Как вам удалось объехать тормоза бизнес логики в вашем приложении Ну у нас наверное Ну мы стараемся всю бизнес-курс Наки чтобы нам ки возвращали уже максимально готовые данные вот но не всегда это получается и много логики Да у нас зашито на фронтах проблема ещё в том что в банке много фронтов там мобильных мобильные фронты там веб фронты и так далее И вот ну это проблема которую мы пытаемся как-то решать Потихоньку Да просто бывает как бы нужно-то зада быст очень сделать Да и дешевле всего это делать на фронте поэтому бизнес логики на клиенте но мы как бы решаем эти проблемы и потихоньку там наши ки подтягиваются мы удаляем лишний логику И всё спасибо Так вот здесь кто-то хотел вопрос задать не мне показалось хорошо можете Вот микрофон передать вон не не назад Здравствуйте спасибо за доклад Я на днях заходил к вам на сайт желая увидеть это скриптом увидел сообщение о том что включили бы вы пользователь jaas я могу ошибаться Но кажется это на влияет не очень здорово и если это было временное решение то с чем она связана Ну во-первых на это никак не влияет потому что эта заглушка сейчас на стоит там обнули там ну потому что менеджеры считают если там ДСА нету у клиента то как бы пусть включит лучше его вот но в целом это если ГШ кого-то убрать то можно спокойно по сайту ходить вот и ну это такой вопрос который мы сейчас обсуждаем с менеджерами Да и возможно сделаем как бы не такую не перекрывающий этом потому что это крутая фича и не нужно её так скрывать и второй вопрос Вот вы выбрали не redx и какие вы нашли преимущества вот в этом решении по сравнению с редак Можете ли назвать пару ключевых Или те что вспомнить Да ну на тот момент когда мы выбирали реализацию флакса редакс был не знаю в таком состоянии непонятном то есть ну как бы и строить на м большое приложение было довольно опасно и мы Вот выбрали реворк от Яха он ну как бы ну решал все наши задачи довольно хорошо и Ну сейчас мы не знаю на самом деле каких-то там кардинальных альтернатив которые решают там по-другому наши задачи Да два раза быстрее там или там и так далее Мы не видим и в том числе ну он там может быть какие-то плюсы есть за счёт редьюс за счёт того что их проще тестировать то есть вот ну как бы больше приветствуется работа с Дан боль с ви или плюсов там в других реализациях флакса то есть это Ну в целом паттерн общий Да там направленный поток данных и там ну плюс-минус там нет больших отличий хорошо Спасибо ещё дополню что серверный рендеринг он вам не даёт без Ява скрипто вю версию вашего сайта то есть какие-то ссылки они может будут работать но сам сайт его полностью надо ещё одну версию такую делать а учитывая там подход это может быть довольно сложно вот и всё Ну нет там это формы сабмит не будут неправильно это надо вообще совершенно отдельную логику это прописывать чтобы оно хоть примерно как-то работало а потом скажет у вас это работает а вот это почему-то не работает я ожидаю что и это будет работать А если это работае А тогда почему вот это не заработало и так и далее по нарастающий то есть и можно да сделать можно просто это всё больше и больше больше усилий будет требовать Ну да можно сделать обработку форм на сервере в целом Мы так не делаем можно но зачем Ну да спасибо большое за доклад Скажите Какое у вас покрытие тестами U довольно маленькая 023 Ну побольше может процентов п как вы это всё потом дебажить и фиксить проблемы у вас команда тестирования или пользователи Мы у нас команда тестирование есть там они автоматизацией занимаются И ручным тестированием рели у нас раз в неделю и там довольно тщательные регрессы проводим и ну как бы Пласт ошибок как раз вот находится на этапе регресса вот когда мы собираем какую-то релиз ную ветку вот Ну вот например у вас там сервисы были прописаны в виде строк это прямо удобно для дебага Вот вы это как-то вообще собираетесь исправлять Да это неудобство в том плане что нельзя проваливаться в сервисы вот Мы у нас есть уже решение для этого то есть мы можем передавать туда функцию сервисом и вот ну то есть ну у нас более распространённый вариант именно со строковой Ну вы на какую-то типизацию собираетесь переходить Потому что там вот ну чистый javas ошибся в одной букве оно где-то развалилось где неня про типизацию мы думаем вот ну просто пока думаем них пока двигаемся особо есть выбираем сри использ типизацию Но сейчас она там особо не нужна Спасибо за доклад несколько вопросов Скажите пожалуйста какой у вас Time to maret вот есть комит репозиторий как быстро он появляется на продакшн серверах На всех ли или какой-то Сплит тестирование У вас есть Ну maret наверно лучшем случае Неде неде какой-то комит он сначала появляется на машине тестировщика То есть у нас все ветки тестируются отдельно и тестировщик заливает определённую версию тестирует её и переводит задачу в После этого мы собираем какой-то резную ветку Да из всех протестированных задач резную ветку и заливаем на бой вот и такой е вопрос Вы упомянули широва на прокси есть каширование статических страниц а вот есть ли у вас слой каширования данных от сервисов Да есть вот кра авторизованные зоны с данными пользователей и так далее вот у нас есть сервисы они вот имеют свойство Каширова и вот красно этом уровне мы каширу все данные там неважно персональные не персональные а используете ли вы распределённый кэш какой-то или это in Ну сейчас мы не используем потому что нет необходимости такого льных данных есть у на задача серверного рендера только для может быть для сокращения и поэтому как бы мы Ну у нас нет такой проблемы нет такой задачи но в целом сейчас это если бы включили то весь кш хранился бы в Спасибо задаёте вопрос Вы хотя бы Вставайте тогда вас все будут видеть прекрасно Давайте Задайте он же никуда не убегает вот я даже его могу подержать для вас минут пять если Ну что зайти Вот увидимся здесь же через 10 минут будет доклад про святая святых фронтенд разработчика про костыли не убегайте Да спасибо за доклад ещё раз"
}