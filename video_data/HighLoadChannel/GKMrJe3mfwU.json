{
  "video_id": "GKMrJe3mfwU",
  "channel": "HighLoadChannel",
  "title": "Как не выстрелить себе в ногу из конечного автомата / Александр Сычев (RAMBLER&Co)",
  "views": 7538,
  "duration": 1955,
  "published": "2017-06-01T23:33:21-07:00",
  "text": "Саша сычёв из рамбле расскажет о том как вообще в iOS работать с стейт машинами какие у нас для этого есть решения И вообще зачем оно нам нужно всё верно Меня зовут Александр счв Я работаю в компании rum И сейчас мы поговорим о практике применения такой абстракции как конечный автомат в неигровых iOS приложениях и разберёмся позволяет ли он решить задачу управления и разработки объектов со сложной внутренней логикой А прежде всего ещё раз отмечу что доклад не теоретический он посвящён практическим аспектам работы с такой абстракцией а в начале мы разберёмся с постановкой задачи немножко вспомним теорию а потом в рамках одного небольшого примера посмотрим доступные варианты реализации а и в рамках заключения мы посмотрим на достоинство этого подхода и посмотрим на реальные примеры задач Где бы нам пригодился конечный автомат вообще в программирование в разработку приходят люди из разных сфер обычно с разным бэкграунда и не обязательно у них есть мощное основание Коте Science Да как там Универс курс какой-то поэтому Ну вот мы недавно там собеседовать одну учительницу на должность разработчика поэтому мы сейчас немножко вспомним Универс курс Что такое конечный автомат конечный автомат - это такая математическая абстракция а которая состоит из трёх основных элементов У нас есть состояние есть входные сигналы которые определяют как мы из текущего состояния переходим в следующее и А есть какие какой-то набор конечных состояний А после которых при приходе в Который наш автомат завершает свою работу всё очень просто А что такое состояние под состоянием мы понимаем а переменную или группу переменных а которые определяют поведение объекта А например если мы заглянем в приложени стандартные настройки в iOS в основные универсальный доступ У нас есть там перемена оттенки серого она определяет у нас цветной экран или чёрно-белый сонно посылая один и тот же сигнал изменить значение тумблера мы получаем разную реакцию системы у нас либо всё черно-белое либо всё цветное всё просто а находясь в разных состояниях получая один и тот же сигнал у нас будет разная реакция система нашего объекта в каких чаще всего областях ками тся программист из других сфер и там они сталкиваются с конечным автоматом А ну прежде всего первое что приходит в голову - это игровые приложения даже как мы посмотрим позднее сама компания Apple прежде всего предполагает использование конечных автоматов в игровых приложениях в принципе в рамках игрового процесса практически всё определяется текущим игровым состоянием Например у вас есть сильно прокаченный персонаж в механической броне со своей лазерной пушкой и слабо прокачанный персонаж в зависимости от этого состояние определяется поведение врагов наших они либо на нас нападают либо убегают И Или например если у нас игра находится на паузе нам не надо отрисовывать текущий кадр А если мы там находимся в меню или мы там в процессе в игровом процессе то соответственно у нас отрисовка совсем другая а вторая область знаний - это анализ текстов А например у нас есть какой-то набор стоп слов и Входная последовательность и мы должны либо отфильтровать либо отделить эту входную строку либо её вообще не выводить это понятно Если формализовать задача поиска подстроки в строке известный алгоритм кнута Мориса прата а он в принципе сам собой представляет конечный автомат где у нас в рамках состояние выступает а смещение во входной последовательности и количество найденных символов во входном паттерне в нашем стоп слое также там а при анализе регулярных выражений часто используются конечные автоматы или и ещё параллельно обработка запросов вообще какое-то выполнение каких-то набора инструкций А например в известном все всем веб-сервере у нас обработка запросов входных запросов различных протоколов осуществляется с помощью конечных автоматов в зависимости от конкретного протокола у нас выбирается конкретная йт машина и соответственно выполняется определённые зарание набор инструкций вот в целом получается у нас два основных класса задач мы либо управляем логикой какого-то сложного объекта у которого сложное состояние либо управляем потоком данных и управление этим объектом то есть какой-то каким-то алгоритмом понятно что в своих контентный iOS приложениях Мы тоже с этим естественно будем сталкиваться и сейчас вот поймём где именно и Поможет ли нам там конечный автомат а чаще всего в наших приложениях у нас слоистая архитектура и ну база у нас три слоя слой представления слой бизнес логики и какой-то набор там хелперов там сетевых клиентов и так далее а начнём с слоя потому что Ну логично что он больше всего принимает решение там сае сложное состояние наверняка там есть объекты Где нам поможет конечный автомат не зависимости от архитектуры Например у нас классическая мо VI контроллер ловя либо Ну там VI апте както там считает как кто называет у нас состояние будет в контроллере соответственно он принимает что у нас отображается VI и как нам реагировать на на входные сигналы там на нажатие на кнопку и так далее логично что контроллер Можно попробовать реализовать через конечный автомат в Мом Вот сегодня был доклад про чистую архитектуру состояние естественно лежит в презентер и именно он определяет какой у нас переход из текущего экрана и опять же Какие данные как отобразить во viw в хипстерское Mod viw VI Model у нас состояние скорее всего лежит во viw модели и независимость независимо от того у нас там реактивные бандинг у нас просто байдин какие-то у нас соответственно поведение нашего модуля определённого через mvvm будет определяться во VI модели тоже можно там попробовать применить конечный автомат на других слоях например в слое хелпера в слое бизнес логики у нас Наверняка есть какой-то сетевой клиент допустим в зависимости от того установлено у нас соединение там сервером или нет Он блокирует какие-то запросы Либо наоборот выпускает их в сеть тоже в принципе похоже на конечный автомат более сложные специфичные задачи например там какой-то платёжный модуль тут гораздо больше набор состояний более сложная логика можно тоже попробовать Почему нет Давайте какой-то реальный пример посмотрим и решим насколько нам там вообще выгодно применить конеч здесь в качестве примера взят контролер из нового приложения чемпионата Ну спортивного ресурса популярного в России это контроллер отображает набор комментариев в табличном виде пользователи заходит в какой-то матч фотографию к событию какому-то к новости И оставляют свои комментарии вот вроде бы экран Довольно простой нижележащий слой нам отдал данные мы их как-то обработали и вывели на дисплей нашего афона вс хорошо нос зама может быть отображение оно как-то зависит от того что содержится в этих входных данных нам может прийти ошибка а могут прийти реальные данные соответственно отображение будет разное а логично У нас появился первое вет ление первый такой илс который чуть нам усложняет вот наше поведение дальше задумываемся а если ошибки нет но и данных нет что это такое А может быть это новость про там например никому не интересные египетские хоккей а либо это там новость о новом тренере Спартака логично что про хоккей никому не интересно Египте там комментариев Нет это нормальное поведение нормальное состояние нашего экрана соответственно только он должен по-другому выглядеть появляется второй вот второе ветвление и уже такой простой экран у нас довольно там сложно управляется дальше предполагаем при старте этого экрана при первом показе логично показать какой-то лодер что мы вот только сейчас запросили данные вот мы их ожидаем Мы ещё не знаем есть ошибка Нет данных или есть какие-то данные у нас ещ один появился и так далее ирав развива наш экран в итоге мы получаем вот такой вот такую вот лесенку переходов которой Ну очень сложно управлять а тем более если вы её передадите потом на поддержку другому разработчику а он знает где вы живёте и он любит ходить с битой и называют её люсиль Ну вот наверно вам надо что-то с этим сделать Давайте поймём что нам не нравится в этом коде прежде всего он плохо читабельный это понятно я вот примерно к счастью в наших проектах тако не нашл взял с одного известного сайта такую лесенку Ну сложно в ней понять что там происходит Раз он плохо читается значит новый разработчик Придя на проект тяжело понимает что там происходит в этом коде соответственно он тратит много времени на понимание вообще логики поведения приложения соответственно у нас повышается стоимость поддержки развития надо будет поправить много тестов надо будет как-то понять что там происходило как-то это расширить и не сломать и этот код он не гибкий если мы захотим добавить какое-то состояние которое очень тяжело следует из текущего текущей лесенки возможно нам это вообще не удастся А если нам нужно какой-то сквозной переход резко сбросить прохождение этих проверок вот по этой лесенке как Мы это сделаем никак Вот ну мы можем это сделать но это очень сложно и здесь уже При таком подходе нет защиты от каких-то эффективных состояний реализую там вот лесенку этих переходов либо какой-то скей Ну особенно свич кейсе У нас есть какой-то дефолт где мы там что-то описали типа дефолтное поведение а это состояние логично с точки зрения поведения программы но оно скорее всего не логично с точки зрения человеческой логики потому что бизнес логики приложения хорошо у нас есть недостатки Давайте их как-то решать ну тема у нас конечный автомат будем применять конечный автомат в качестве примера для реализации мы возьмём то что нам предлагает компания Apple в рамках фреймворка gamep Kit есть два класса которые в принципе и помогают нам работать с такой сложной абстракцией это GK State и Gate по названию рка понятно что Apple хотела чтобы мы это в играх применяли но мы хитры в неигровых приложениях первый класс State он определяет состояние Что надо чтобы поработать с этим классом описать наше состояния в принципе четыре простых действия а мы наследуем се от этого класса и ну задаём имя соответственно состояние и определяем три метода первый - это валидно ли это состояние исходя из предыдущего вот это вот этот метод из Next State и два метода которые определяют логику которую мы будем выполнять при приходе при переходе в это состояние detent with previous State и при выходе из этого состояния Will Exit is Next State всё в принципе нам достаточно этих четырёх методов и второй класс Собственно сам класс конечного автомата GK State Machine А тут ещё проще у нас достаточно выполнить всего два действия Первое - это мы а передаём набор входных состояний через инициализатор передаём типизированный массивом и второе - это осуществляем переходы в зависимости там вот от входных сигналов спомощью метода interstate он же задаёт нам начальное состояние вот тут может смутить что инициализатор у нас принимает на вход объекты и он строго типизировать на вход клас any CL а соответственно Ну на самом деле ничего плохого не произойдёт если мы подсумков мата или вообще какой-то левый класс просто вот здесь тамм вернётся всё нормально работает никаких эксп и так далее Что надо вот мы сечас Как работать с этим фреймворк нашему примеру прежде всего Нам надо описать состояние и переходы между ними сделать это надо в наиболее понятной форме Ну я знаю два варианта это мы описываем состояние переход в виде таблицы либо описываем в виде графа переходов в принципе Граф переходов более понятный вариант он есть и в Юле Ну более стандартизованный А как он выглядит у нас есть наше состояние которое мы Ну описываем там какими-то их именами и стрелочками Соединяем эти описываем переходы между ними как я говорил в нашем примере есть начальное состояние мы ожидаем какие-то данные и есть три состояния в которые мы можем попасть из начального состояния это данные полученные данных нет и состояние ошибки в принципе вот это всё в рамках этого графа мы описали А в рамках кода это выглядит такими четырьмя небольшими классами Ну это классы заглушки понятно что они не очень большие и они в принципе формализуются в качестве примера состояние ожидания данных то а и его реализацию то тут можно отметить что во-первых мы в методе изве Next State определяем на основе чего мы в это состояние можем попасть И как я и говорил на основе трёх более дочерних состояний которые уже отображают данные и действия которые Мы выполняем при входе и выходе из этого состояния раз мы сейчас управляем нашим нашей View управляем её отображением то нам Ну можно держать ссылку на непосредственно vie контроллер в самом состоянии слабая ссылка потому что управляем ей у нас как бы родительским элементом будет сам контроле вот ну просто соответственно либо показываем индикатор загрузки либо скрываем ну и плюс дополнительная логика которая будет определяться уже там непосредственно вашим приложением вашей задаче и второе естественно мы описали наши состояние в виде наших классов там протестировали их и задаём параметры самого автомата возвращаемся к классу State ма описали создали четыре объекта наших состояний пото что больше нам и не надо Ида состояние в принципе всё А теперь мы получаем какие-то входные сигналы и на их основе просто ну говорим стоит машина Перейди в указанное состояние на основе вот этого сигнала а покод на самом деле мало что изменится Просто мы задачу формализованная реализация конечного автомата в любом примере который вы найдёте в интернете это будет в любом случае swch либо какой-то FS можно до какого-то варианты оставлять если там ведущий разработчик не жалуется и это в принципе тестируется а Но если нам э Ленка растёт как мы говорили что нам надо делать спросим Ну у ребят более умных которые уже всё за нас придумали есть специальный паттерн проектирование он так и называется патерн состояния он очень похож на Стратегию и в принципе он описывает такую абстрактную сущность как конечный автомат А ну его логика Основная - это в том что мы поведение переносим как можно ближе к самому состоянию и логика перехода непосредственно делегирует самому состоянию таким образом наш конечный автомат который сейчас изначально принимал решение Какое вызвать состояние либо ну рядом лежащий объект теперь будет передавать этот сигнал непосредственно транслировать его состояние и состояние будет принимать решение Так мы разгрузи вот эту нашу лесенку Ну хотя бы частично и сам код станет более приятны к использованию вот а но для этого надо стандартный фреймворк так не умеет он предполагает что gast машин будет принимать решение что мы можем сделать Ну понятно нужен входной метод который передаёт конфигурационный объект то есть наше состояние хорошая практика описать состояние одним объектом и его всегда передавать чем там писать вот большие много-много входных параметров мы формируем этот объект в качестве конфигурационного и Передаем его в наш конечный автомат и соответственно что мы делаем дальше мы дальше Просто делегирую выбор следующего состояния непосредственно в текущее состояние конеч автомат о нём знает он спокойно это делает и уже текущее состояние мы их к сожалению теперь связываем но оно знает куда мы будем переходить дальше какие вот достоинства у стандартного фреймворка понятно надо ничего грузить не надо какие поды использовать кортеж и так далее библиотека достаточно простая в изучении буквально там за 15 минут достаточно понять как работать с конечным автоматом и у нас сразу есть две реализации есть реализация на об FC и есть реализация на свифте не надо написать никаких бриджей всё хорошо никаких проблем Мы с этим не слом Какие минусы Kit доступен SOS 9.0 у нас большинство проектов поддерживает I 70 Есть проекты с iOS 80 и на iOS 90 у нас только один проект по-моему Вот это соответственно нас такая на самом деле нас не устраивает В чём ещё минус он нарушает принцип единственной ответственности состояние перехода тесно связаны друг с другой друг с другом а состояние непосредственно знает куда оно переходит и как и плюс тут никак не контролируется дубликат состояния передаваемый в стейт машину Мы стейт машину сдаём массив а не какой-то а не множество состояни и соответственно Apple как обычно передали несколько одинаковых состояний будет использоваться последнее только это где не документировать ничего не падает Но мало ли эта реализация не устраивает посмотрим что есть на гитхабе что нам там поможет а два языка соответственно Давайте на два варианта библиотек посмотрим а реализация на obc тут вот выделю две во-первых самую популярную уже давно существующую это transition Kit А в принципе это Она позволяет нам реализовать конечно автомат и все действия сонно с ним на блоках Ну логично по времени её там появления а она решает вообще все минусы которые я Обозначил ранее у нас состояние будет отделено от переходов в рамках transition кита У нас есть два А класса один класс для задания состояний и входных входных выходных действий ТК State и класс для описания перехода ТК Event соотвественно он СВ ТК Event связывает одни состояние с другими и сам эвант определяется просто с строкой обычным NS стрингов как бы плюсы появляются мы можем а передавать полезные данные при переходе работает так же как и при работе с NS notification центром все весь P полезный нам приходит в виде Юра афо Ну в виде словаря и мы там уже сами выбираем что там нам передалось при переходе при получении этого сигнала и плюс нам теперь при каком-то ошибочном состоянии при попытке перейти в какое-то не описываемое состояние нам будет выведено влог не только fse Да но и гораздо больше полезной информации это как бы очень хорошо полезно при деге вот где применяется transition Kit Ну он вот есть на м завязан сетевой комба в своих асинхронных операциях мы любим Но не очень Вот где там применяется он применяется для управления асинхронными операциями есть специальная машина на неё полезно вообще на исходники посмотреть как на сетевом слое как на слое управ обм чем управляет стот машина управляет операцией и управляет где размещать эту операцию вот наше disp в качестве реализации вот сказал что така стоит машина это тут этой машины всего три состояния начальное Понятно Мы задали нашу операцию потом шлём сигнал операция выполняй и потом мы её либо можем отменить нам это даёт позволяет эта машина либо она соответственно доходит до логичного конца мы переходим в состояние завершено работа с ней очень просто задали параметры написали Старт всё пожа выполняй уже сама стоит машина будет управлять интроспекции нашей операции то есть там задавать авары она будет управлять асинхронной операцией будет управлять её асинхронным выполнением будет управлять атомарность этой операции и также она нам даёт возможность отменить операцию а вторая библиотека которую я бы хотел отметить на obc - это библиотека Shift она это конечно больше учебный проект он там Существует очень давно и он реализован как категория над NS октом соответственно Ну на об FC в коде в нашем Любой объект может стать конечным автоматом точно так же действия которые мы делаем при входе выходе из состояния описываются блоками а сами состояния описываются обычной строкой Ну строки Нам уже надо самим как-то контролировать но в качестве того чтобы познакомиться со стойт машиной Там какой-то mvp реализовать Ну это там наверное самый идеальный проект а на свифте на свифте сразу очень много библиотек появилась а они все там быстренько звёздочки набрали А ну я вот выделю одну Swift State Маши а ну я её считаю более свифте она потому что единственная как структура реализована и у неё есть очень ряд там несомненных преимуществ над всеми остальными а во-первых а Swift State Machine заставляет нас полностью описать весь автомат допустим у нас есть пять состояний и там шесть переходов нам надо все 30 вариантов перебрать обязательно потому что сама стот машина в рамках этого этой библиотеки задаётся схемой которая Мы обязаны через вложенные намы описать все варианты переходов Но это нам позволяет полностью типизировать нашу стейт машину дальше благодаря этому мы полностью контролируем входные сигналы мы не сможем сказать нашей стейт машине перейти в неизвестный е сигнал или сигнал там из какой-то другой схемы благодаря Ну свитом дженерика как утверждают создатели библиотеки у нас повыше производительность становится потому что мы отделяем сам объект от описания его стейт машины от схемы стейт машины соответственно Мы один раз описали схему её дальше используем Меньше времени на создание объектов и одна очень клёвая фича - это визуализация есть графический язык разметки Вот как раз для работы с State диаграммами а Dot А И вот эта библиотека позволяет если мы каждый объект опишем с помощью Dot laab вот этого короче протокола указать как он будет визуализировать мы потом просто вызываем Print выводим в консоль вот этот Лок описание этой схемы и этот файл мы потом подсовывать какому-нибудь любому визуализатор там их вполне Ну там ряд можно через б поставить там их много там Гугли очень быстро и на выходе мы сразу получаем вот такую схему нам даже ТЗ писать не надо После того как мы описали в коде нашу Т машину у нас уже такая красивая диаграмма хорошо Ну давайте отметим основные достоинства вот применение конечного автомата в наших приложениях естественно это формализация задачи как только мы решаем применять конечный автомат мы просто выну описать все варианты переходов и все состояния мы просто садимся и задумаемся над тем как выглядит наш обе формализация позволит нам там выявить какие-то слабые места в Техническом задании описать их и соответственно там запросить больший срок у нас Более точная оценка становится нашей задаче формализация нам повышает тестируемого кода мы описали все состояния соответственно у нас там стало больше тестов меньше вариантов где упадёт приложение Мы полностью контролируем передаваемые данные по нашему приложению у нас появляется возможность жёстко контролировать возникающие ошибки как говорят если при работе сто машины возникла какая-то ошибка это мы просто пропу какое-то состояние на этапе проектирования плюс дополнительно такие плюшки появляются раз у нас всё те сходится к машине у нас теперь единая точка для логирования сбора статистики таже Swift State Маши содержит специальный метод который позволяет логировать текущее состояние текущий её описание переходов буквально нам один метод достаточно за использовать и если дальше развивать теорию автоматов там есть автоматы с магазинной память они нам позволяют хранить историю операций соответственно не только их записывать при перемещении в будущем но грубо говоря их отматывать как бы идти в прошлое в каких задачах вот я бы порекомендовал например поис пользовать стейт машину понятно как я говорил В задачах где у нас есть жёсткие поведение какой-то жёсткий алгоритм А у нас у холдинга нет своего приложения такси ну поэтому вот эти а заказ такси всем понятный набор там состояний мы А если их грубо начнём делать Вот так интуитивно Ну допустим напишем вот такой большой большой свич кейс Мы ждём машины потом мы там Машина приехала Мы хотим оплатить и вот такой код ну он даже здесь вообще не влезает и не понятно что там происходит А если мы ещё будем плохо декомпозировать и прямо всё в свич кейсе писать ну совсем плохо будет Давайте формализуются там в нашу историю Мы ставим оценку и так далее так ких классах которые в принципе можно распределить между разработчиками нашей группы и каждый из них будет протестируем это и паралели нам работу и как бы упрощает Другое Другая похожая задача - это оформление заказа У нас есть какой-то магазин приложение для магазина и мы просто там Наш заказ путешествие его по корзине от корзины до нас формализуются автомата точно также Разместили заказ а сформировали его оплатили он к нам приехал мы там получили наш чек Ну и всё хорошо а мы дальше опять поставили оценку там или так далее А это уже наше приложение афиша рестораны здесь вот конечный автомат применён для оплаты заказа как бы ну ещё один вариант нам не обязательно описывать диаграмму переходов нам достаточно от дизайнера получить все экраны и нам этого достаточно для формализации задач ещё один вариант вот просто задумался недавно А недавно коллеги из Авита рассказывали про Ап координаторы и у соры Хало в принципе там была отличная идея Что такое вообще а координатор вот этот весь набор инструкций набор последованности действий жёстко заданных такие как авторизация выполнение заказа можем делегировать одному конкретному такому суперобъем поведением вот этим набором правил А на вход мы получаем какой-то сигнал от конкретного в контроллера зайди вот с этим состоянием То есть например там уже выполняется поездка да Или зайди к нам состоянием оплата и он нам это а координатор сразу нас координирует и покажет нужный нам экран у того же уже соры Hand предполагается что есть центровой а координатор и потом каждый кейс нашего приложения дробится до непосредственных координаторов Ну там непосредственно решающих одну задачу Там выбор аватарки создание там какого-то контента и так далее Если приглядеться а координатор и выглядит как стоит машина у неё есть набор сигналов и переходы между ними по по заданным состояниям в принципе логично что если попробовать реализовать а координатор как стоит машина мы можем в принципе все переходы нашего приложения свести к одной иерархической стоит машине Ну и полностью формализовать наш задачу понятно что это введение дополнительной абстракции сильно увеличивает набор кода соответственно там немножко увеличивает нам время разработки но зато у нас будет полностью протестируем код и полностью формализованный непосредственные плюсы нас очень Ну могут порадовать вот когда стоит применять ть машину вот когда названные достоинства они действительно для вас важны Когда вам нужна формализация Когда вам нужна высокая тестируемой кода и когда вам нужно распределить задачи между вашими разработчиками тогда её применяйте не надо пытаться совать йт машину Ну во все объекты где грубо говоря есть один F это наоборот Ну очень плохая практика И вам это никак не поможет С развитием вашего приложения А в принципе у меня всё я готов к вопросам спасибо спасибо за доклад Мне очень нравится идея конечных автоматов и как-то удалось с ней поработать Вот и выяснилось Ну да это такой научный подход разного рода пром и есть одна проблема Дело в том что конечный автомат подразумевает что переход из состояния в состояние происходит за нулевое время и в разработке приложений у нас есть такая большая проблема Как анимация и когда мы стремимся к тому чтобы вьюшки были как можно более тупые и сливаем им какое-то состояние вдруг то Ну как вообще эту проблему решать вот есть состояние А есть состояние б и между ними вьюшка делает анимацию Вот она начала делать анимацию и приходит какое-то Ещё событие что нам нужно думать что она ещё в состоянии а или в состоянии б или Ну то есть получается что мы обрастаем какими-то дополнительными состояниями Либо они схлопывается начинает решать в каком состоянии она находится и ну обычные пользователи не всегда могут это сделать но тестировщики могут абсолютно всё и в общем Ну ничего хорошего придумать не удалось Поэтому вот вопрос что делать Ну ты сама говоришь правильно стоит машина предполагает переход за Ну нулевое время за единицу какую-то заранее определённую анимации если бы мы могли отменять резко то есть возвращать состояние отматывать понимали что мы действительно должны сделать чтобы пользователь не испугался что вот поступил новый сигнал а тут оп что-то с анимациями Там скакнуло они новые пошли тут стоит машина она так не поможет А по-моему даже Facebook не смог это сделать тут Ну вот поэтому Если у вас есть много анимаций а подумайте хорошо прежде чем использовать Т машина тся работа вот с с объектами где соответственно нам не важно время перехода где мы просто можем изменить одно значение переменно и всё будет хорошо а тут у нас есть последствия можем ты правильно говоришь начать вводить какие-то дополнительные состояния если мы сейчас анимируем се из А В Б Ну как их отменять вообще непонятно такого нету ну беда в том что другого решения Нет мы прибегаем к стоит машине потому что у нас куча состояний А тут мы к ней прибежать не можем и обще ничего хорошего не Получи стот машина нам не поможет а да спасибо за доклад Я тоже очень люблю теорию автоматов и тоже пытался это всё делать и там ещё другая проблема есть Очень похожая а мы как разработчики мы должны как-то сами хедли вот все эти состояния допустим юзер нажал на какую-то кнопку и мы говорим вот давай попробуем перейти Вот в это состояние и это работает всё ну настолько круто можно вот реально всё приложение создать на вот в виде автомата а но есть проблема например когда юзер делает свайп у най контролера мы это уже не контролируем ну по дефолту и у нас автомат получается в каком-то взвешенном состоянии и тогда приходится а либо хедли как-то свой делегат писать Ну короче и досыпать туда добавлять своих костылей только для того чтобы ублажить эту прекрасную абстракцию вот как вы боретесь с этой проблемой если она у вас есть Ну мы редко вот так вот опять же это управление это проблема UI Китая он такой вот а и мы сейчас пытаемся решить проблему а Китая вот того что мы им плохо управляем у нас есть вот эти супер неожиданные событи откуда оно пришло им надо как-то управлять с точки зрения конечного автомата А мы об этих сигналах ничего не знаем соотвественно ты правильно говоришь мы либо их должны ловить либо вообще не совать туда конечный автомат чтоб Ну мы же когда формируем задачу делаем декомпозицию и даём срок на ней если мы прекрасно понимаем что конечный автомат Да он хорош но надо заставить написать Вот свой делегат свой это свой это А зачем нам это Давайте напишем по старинке Да будет прит коно сделаем зада нем бизнес и далее СБО за используем конечный автомат и у меня вопрос про тестирование представим что у нас есть конечный автомат есть набор состояний Есть множество сигналов которые собственно может принимать этот конечный автомат Как вы тестирует вы тестирует Фло или вы тестирует состояние с набором сигналов и каждое состояние тогда проверяет обработку каждого сигнала как вот процессов постро у нас только модульные тесты какой-то Фло мы не Тестируем инте тестов у нас нету ну мы просто считаем что их долго поддерживать неудобно с точки зрения это тест Ну понятно как написать у нас есть зависимости конечно от фреймворка тут Да если мы там а используем Gameplay Kit нам надо там вот эти три метода протестировать понятно что ну там понятно что мы Тестируем вот опять же возьмём пример с состоянием ожидания мы будем просто в этот метод по очереди слать нужный нам сигнал и проверять что он говорит Да нет ну вот по факту такой тест простой модульный А про Фло то что я знаю есть технология Spotify но она больше формализация для тестировщиков мы как раз вот весь ло описываем в виде конечного автомата и вот этих его сигналов но они просто строят диаграмму переходов и потом по этой ло у них пишутся автоматизированные тесты Просто ну в виде спек Просто если то так далее но там не факт что должен использоваться конечно автомат они так просто формализуются процесс тестирования вот а интеграционные тесты Ну мы не пишем Я если честно не знаю Это очень дорого Спасибо E"
}