{
  "video_id": "0MmDdTDql5E",
  "channel": "HighLoadChannel",
  "title": "Как мы работаем над стабильностью нашей реализации Lua / Антон Солдатов (IPONWEB)",
  "views": 802,
  "duration": 2887,
  "published": "2019-05-14T14:42:32-07:00",
  "text": "всем привет спасибо ли меня антон и да я сегодня расскажу о том как мы работали над стабильностью нашей реализации lua а совсем коротко компания пион в занимается решили разработка технологических решений в сфере онлайн реклама его мы используем уже больше десяти лет для разработки бизнес-логики наших проектов и в 2015 году мы форк 0 джип долгое время мэр мы использовали лоджий для того чтобы запускать нашло код 2015 году мы фыркнули эту реализацию и сделали свою и пользуясь случаем могу сказать что буквально недавно мы получили от руководства одобрения на то чтобы опубликовать эту реализацию на наш форк уложит of open source и да спасибо большое нет никаких нет никакого commitment а по срокам но так или иначе эту деятельность мы мы мы начнем и надеюсь в следующем году что-нибудь сообществу покажем и сегодня я хотел бы поговорить о том как мы тестируем стабилизируем эту самую нашу реализацию вот ядро нашего технологического стакана выглядит таким образом да у нас есть вот сервер приложений написанные на наносите плюс плюс которые ответственны ответственны за сеть за прием и обработку и отдачу request of в него встраивается лома ширина изначально это был лоджий теперь это наша реализация которая в свою очередь исполняет бизнес-логику каждого проекта к от которых у нас есть несколько десятков и вот в этой матрёшечки нас главным образом и будет интересовать средний вот этот вот прямоугольничек который в свою очередь тоже имеет какую-то нетривиальную структуру да у нас там есть а frontend который берет ло код преобразует его в байт-код виртуальной машины есть runtime который реализует систему типов есть собственно говоря интерпретатор байт-кода который исполняет ваш код jit компилятор который во время работал авокадо пытается его jeds компилировать таким образом какой-то производительности добавить есть какие-то прочие компоненты то есть внутри это все устроено довольно сложным образом и очевидно там есть что протестировать и по стабилизировать а все это собрать будучи собранными вместе работает под довольно высокими нагрузками даст самый нагружены проект у нас в пике обрабатывает до 6 миллионов запросов в секунду и время обработки запроса все жестко лимитирован это такой в мире rtb в мире от торговли рекламы в реальном времени некий индустриальный стандарт 100 100 20 миллисекунд включая все возможные сетевые задержки вот должно пройти от того момента как кто-то примет запрос том что не требуется показать рекламу да уже собственно фактов показа это реклама и конечно производительность безусловно важно но кому нужен быстрый продукт который либо некорректен либо работает нестабильно очевидно никому соответственно мы сейчас я расскажу как мы тестируем нашу реализацию не вдаваясь в какие-то тонкости теории тестирование да вот скажу что речь пойдет о он не снять разных видах тестирования юнит тестирования о то есть а тестах которые берут какие-то отдельные модули ваши платформы вашего продукта и тестируют их о функциональном тестирование том когда мы берем уже всю нашу собранную платформ всю нашу реализацию lua целиком и проверяем собственно говоря может она корректно исполнять ла кот или нет интеграционное тестирование когда мы наш продукт встраиваем в наш сервер приложений корректно ли они взаимодействуют все ли работает так как надо вообще когда мы говорим о том вот так как надо да это вот нас есть язык но есть реализация языка и собственно говорят что мы в первую очередь тестируем так какая цель какова цель применения всех этих разных видов тестирования да нам нужно ответить на вопрос вот то что мы написали это вообще говоря в это реализация действительно реализует тот язык который описан в некотором стандартным документе и вот здесь i love my вот в экосистеме lua уже начинаются такие проблемы которые связаны вот чем вот смотрите у нас есть например язык си или язык си плюс плюс есть комитеты по стандартизации которые выпускают стандарты где четко прописаны языком является та та та та а кроме того определены такие вот синие и серые зоны и границы да вот здесь мы какой-то аспект даем на откуп имплементации здесь мы вводим понятие как антифа inbi хейварда и прочее прочее особенно для того чтобы тем кто делает например компилятора языка си было понятно где языка где уже детали реализации для лова а есть документ который называется вонючий эфирный смене л.а. короткий понятный довольно книгу суховатый но это скорее не не бага фича но к сожалению написаны в такой манере до что непонятно на что что понятие язык lua и реализация lua не различаются и это на самом деле довольно большая проблема потому что вот мы сделали свою реализацию до хотим ее поставить как дроп--ин replacement чего-то существующего а строгих формальных какие-то сертификационные гарантии что это тоже луну вообще-то нет потому что line which орехи нас много так написан и соответственно тестов официальных line which комплаенс тестов в языке новак в экосистеме к сожалению тоже нет на сайте разработчиков языка loord есть раздел тест но сами авторы подчеркивают что то что там лежит это тесты на их конкретную реализацию которую сами ребята из сами создателя языка из университета в рио даже ныне тогда вот поставляют когда выходит новая версия языка а частью в последнее время в сообществе начались какие-то подвижки в эту сторону и буквально в конце если бы 31 октября 2018 года был анонсирован проект который называется lua харнес изначально это некий набор тестов в составе другого проекта latest мор и это собственно говоря комплаенс тесты написанная независимо от реализации настолько насколько это возможно и написаны строго на основе лайчи reference миньо и как бы вот пусть мне официально пусть какой-то сервер платит с товарищи это но но она появилась но как я уже сказал это произошло буквально неделю назад дамы свою реализацию начале 2015 году мы завели себе девочкам плане комплаенс this thing для бедных есть как минимум две наиболее популярные реализации лу это собственно реализацию от создателей язык опухли углу и собственно лоджий для них в интернете есть тесты тесты на эти конкретные реализации написанные собственно говоря авторами этих реализации кроме того в том проекте latest mmorpg который я упомянул только что тоже было когда мы начинали с ним работа была какая-то вот тестовый сюита предоставлявшие комплаенс тесты и в проекте м иди которая развивается усилиями церна тоже есть какой-то значительный кусок комплаенс теста вот мы это все дело собрали в одну такую мета сюиту положили к себе в кодовую базу прикрутили к счастью поймали какие-то баги прежде чем они ушли впрок действительно поймали какие-то баги и вот она он сейчас живет дает нам такое вот ломич комплаенс в отсутствие каких-то fi какой-то официальной сертификации и это некоторое решение нашей проблемы да почему это решение для такой полноценной стабилизации да ну скажем так хорошая но не полное потому что очевидно с того момента как мы фыркнули лоджии ты начали работать наши кодовой базы мы туда мы поддерживаем фиксит баги добавляем какие-то новые фичи поэтому очевидно пока помимо этого все поедем тех тестов которые у нас есть нужно писать писать что то свое и собственно тестов у нас имеются юнит-тесты они написаны носи с использованием библиотеки симок а функциональные тесты написанная на частично на 7 частично на ул а вот собственно говоря все событиях в категориях тестов мы поговорим чуть подробнее unity стыда в чем в чем сложность состоит главное сложностью не тестирование когда мы тестируем такую довольно сложную махину до который включает себя интерпретатор байт-кода jit компилятор каким-то runtime garbage collector вот у нас есть некий симпатичный интерфейс да это вот один из интерфейсов того компонента которые реализуют единственную важную структуру данных таблицу вот что то что создает таблицу с какими-то параметрами да давайте возьмём вот интерфейс попробуем написать на него unit-тест сложность заключается в том что многие интерфейсов платформе в силу объективных причин пронизаны зависит от пронизаны зависимостями зависит от всяческих состояний например в данном случае да для того чтобы создать таблицу нам нужно под нее выделить память и вот как бы для этого нужно уйти в глубины платформы дает мы получаем зависимость на стоит который в свою очередь зависит от а локатора и прочее прочее и вот такие сложные зависимости да они вообще сами по себе не очень хорошо бьются с идеи и у не тестирование как тестирования хорошо изолированных отдельных модулей тем не менее какие-то части платформы iou не тестирования поддаются очень хорошо во первых что это такое это все и пи ай да это тот api который lua как язык обязуется вам предоставить для того чтобы встраивать лов какие-то внешние системы написаны на оси на си плюс плюс соответственно вот этот вот эти интерфейсы и не тестируется довольно хорошо всякие вспомогательные внутренние интерфейсы платформы который является какие всякие вспомогательные функции не знаю там реализация своя реализация функции стросс-кан например в качестве такого качества кого примера тоже можно покрыть июне тестами и все будет работать все будет выглядеть хорошо да нибудь не нужно будет ничего мог хоть какие-то зависимости придумают бороться с зависимостями и прочее даже некоторые части jit компилятора тоже можно хорошо покрытию не тестами до в частности такой компонент как emitter динамического ее megamix имитатор динамического кода что это такое да вот когда у вас вот во время во время runtime ада у вас работает ваша система jit компилятор в какой-то момент включается решает по генерировать динамический код и собственно говоря emitter это то что берет и записывает какие-то вот такие какие-то байки кида которые являются по сути инструкциями машинного кода складывается в какой-то буфер памяти и на первый взгляд кажется да что вот есть тоже какая-то зависимость от некоего состояния состояния ассемблера виртуальной машины и звенят а с с м birgit компилятор но на самом деле это не очень большая проблема подобное именно в этой части платформы интерфейсы можно успешно перри factory и вместо там зависимости на стоит добавить просто зависимость на тот буфер в которой мы динамически пишем нашей машины инструкции после чего избавишься от состояния мы можем написать хорошие легко поддерживаемый легко расширяемые юнит-тесты очень хорошо хотя казалось бы да jit компилятор такая вот сложная штука но нет при достаточной степени изоляции достаточной степени взгляда можно найти какие-то компоненты которые тоже хорошо изолируются uni тестируется функциональные тесты значит часть функциональных тестов как я уже упомянул мы пишем мы пишем носи и это собственно говоря те случаи когда нам не хватает lua когда нам по какой-либо причине нужно работать с памятью до или когда нам нужно нашу платформу перевести в заданное состояние да то есть вот у нас работает работает наше low машина да и по хорошему большому счету мы не знаем когда произойдет сборка мусора но представим что нам нужно написать какой-то тест который вы эмулировать ситуацию когда машина находится в одном состоянии garbage collector строго в другом jit компилятор в третьем и вот это все должно сойтись и тогда что-то вот этом случае конечно тесты на lua писать не получается не очень эффективно и вот это механизм описание функциональных тестов на сион довольно мощный да но скажем так много таких тестов не напишешь до этого нечто такое что нужно для особых случаев то время как тесты на лугу написать какой нибудь какой нибудь кусочек вроде культ файлик написать там какой-то ла кот добавить а cert of туда заставить код выполнять какую-то полезную работу запускай пожалуйста тестирует процесс не упал все хорошо значит вроде как все работает так как надо и это закрывает какие-то часть часть проблем но на самом деле только такого тестирования тоже оказывается недостаточно и вот почему почему недостаточного только таких тестов и а вот пример из нашего багтрекер 1 приходят разработчик и значит соби титана вот такой баг он говорит иди смысл вот в чем я говорит занимался смотрел на оптимизация jit компилятора и вот оказалось что одна оптимизация в которая отвечает за то что в горячих часто исполняемых циклах аллоцирование временных объектов да она не производится по она происходит производится скажем так закона по возможности элиминируются и происходят только тогда когда ну действительно необходимо так вот есть некоторая оптимизация на которой оказалась сломана пишет нам разработчик и заодно задается вопросом нужно же посмотреть почему при этом работают тесты дааа теста в данном случае эту эту оптимизацию покрывали тесты из тестовые сюиты наложит в которую в свое время мы взяли у майка поло у создателя языка мы проследовали оказался такой классический сценарий да мы добавляли что-то новое какую-то новую фичу в процессе сломали старая и самое неприятное то что тесты при этом ходит там дженкинс зеленый да все все нормально как же так что палубе что случилось давайте еще раз посмотрим на этот тест а вот у нас есть два цикла после каждого цикла сорт который сердит какой-то результат по результатам по итогам работы цикла есть в каждом цикле какое-то тело до из того что она выполняется в цикле мы делаем мы делаем предположение что этот код будет jit компилировать как исполняющие ся довольно часто и вот то что должно произойти она вот там вот в комментарии какие-то магические слова понятные только разработчику jit компилятора написано до что вот во во во во что то должно произойти до а сердцем мы только результат и это все вместе не очень хорошо работает почему потому что за работает компилятора по обработке вот каждого тела цикла на самом деле стоит ну не которое тоже сложная система да самое такое высокоуровневое представление можно вот такой вот машина и состояния диаграммы состояния писать и в данном случае даже важно не то что там написано до важно то что каждая веточка на вот вот в этой машине нашли не состояние может сломаться а явного теста на то что сломалось она или нет вот это исходный код не предоставляет более того даже если что-то пойдет не так jit компилятор написан и работает как и должен работать крайне консервативно да и при малейшем подозрении что он что-то исполняется что что что что-то идет не так как надо он говорит отличная там например прекращаю работу дальше работает дальше работает виртуальная машина я не буду пытаться jit компилировать этот код то есть результат в итоге вы получите правильный семантика языка окажется естественно соблюденный платформа от работает как надо но гарантий что именно jit компилятор вот undercut внутри отработал правильно нет вообще никаких соответственно тестируем конечный результат а способ которым он получился никак не можем проверить при таком подходе что можно позаимствовать кто бы на что можно посмотреть в утилитах в котором с которыми которые есть в и вложите в нашей реализации а есть такая штука которая позволяет вам процессе работы компилятора выводить а куча всякой отладочной информации что он в этот момент делает предоставляет довольно подробную информацию о разных этапах работы компилятора собственно говоря на прошлом хай-лоу я рассказывал как эту информацию мы использовали для анализа производительности да и ботаников в работе jet компилятора эту же самую информацию можно использовать в тестах соответственно похоже ли это на паттерн тестирование пологом да это похоже на паттерн тестирование пологом собственно мы берем запускаем наш файлик а дальше проверяем есть ли у нас в том что то что выведены да если у нас или отсутствует или какая-то информация которая является признаком того не просто того чтобы ла кот корректно это работал до но это что jit компилятор который этот лак от обрабатывал в процессе исполнения тоже сделал свою работу правильно это довольно простая идея на самом деле а к большому сожалению как бы вот в тех например в тестовых но но при этом в тестовых в тесто вы сидите лоджи да да и и нет есть просто вот этот лодку от не решает она при всей своей простоте очень много головной боли снимает ну во первых мы можем наш тестовый случае изолировать сколь угодно хорошо у нас есть куча данных за бесплатно да без какого-то желания подлезть куда-то каким-то кодом в нашу платформу да вот компилятор нам сам по какому-то хорошо определенному интерфейсу дает информацию о собственном состоянии это совершенно никак не относят эффект и производительность данного это же теста в конце концов для теста это производительность вообще никак не одна производитель из теста никак не сказывается и вот таким программу паттерна можно решать очень много тестировать много случаев решать очень много разных задач собственно что что мы и делаем вот до этого я описывал то что у нас есть скажем так в в кодовой базе то что можно автоматизировать да то что тестируется вся и в дженкинс и позволяет нам собственно говорят ну с помощью чего мы пишем тесты на новые фичи логан ошибки какие-то используем для регрессионного тестирования то есть еще собственно говоря с тем сервером приложений в которой мы встраиваемся у нас есть интеграционные тесты которые позволяют нам убедиться что все хорошо работает есть возможность выкатиться на стенд и посмотреть стабильность на каком-то более менее реальном трафике в такой в среде до которое будет благоприятных разработчик куда покатились включили трафик убедились что не падает посмотрели метрики все хорошо наконец есть у каждого проекта есть такая особая зона стайлинг стайлинг сервера да это еще не production но трафик уже реальный и вот если нас интересует какое-то глубокое тестирование например а бета-тестирование перформанс тестирование или stability тестирование важных фетида всегда можно прийти туда и собственно говоря за тестировать так как это нужно но это все выполняется руками до не не они автоматически и чего еще в этом всем не хватает чего нам бы еще хотелось а вот смотрите как я уже сказал у нас есть сервер приложений в которой встроенным виртуальная машина важны злит компилятором который исполняет бизнес-логику проектов на бизнес-логику есть отдельные тесты то есть вот зона ответственности проектных команд это писать тестом свою бизнес-логику да надо под они идея напрашивается взять весь код со всеми проектами тестами запихать какой-то дженкинс да и нагонять допустим на последнем на последнем нестабильном мастере наши реализации до убедиться что все работает хорошо хорошо это требует некоторой такой инфраструктурной подготовки дай мы находимся вот сейчас готовимся вот-вот решать эту задачу а кроме того еще подобно который напрашивается до в интернете очень много на lua кода есть куча хороших проектов у которых есть нормальная тестовые сидит и да и поэта почему бы не заглянуть и посмотреть на то как например создатели компиляторов там сели си плюс плюс делаю доберут кучу дикого кода и говорят вот компилирую да и получаем такой вот facing тестирование компиляторов и вот по аналогии с этим взять какой-то старой кокоцко яиц и сторонних проектов где-то в стороне развернуть и тестировать убеждаться что все она собирается и тестируется в этой связи наконец-то радует что лоракс 3 в третьей версии до единственный боль или менее живой пакетный менеджер дал он наконец-то научился запускать тестовые все это теперь осталось чтобы авторы модулей который публикуется через лоракс могли ну это возможность тоже вовсе у себя включили до сделаем баунти bounty программу но того тоже такой да да и вот все сделали все протестировали да вот такой конвейер и завернули да и автоматические руками а бывает так что она все равно падает до передней inox каждый раз по разному но бывает что вот происходит какой-то кришна какой-то машине в каком-то несчастном проекте что-то падает и дальше что-то свете что-то с этим надо делать в этот момент до когда вы уже все зарелизили а вам приходит кордом даче винна вам нужен вам нужен процесс расследования инцидентов и в первую очередь даты нужно осознать почему это важно расскажу сейчас буквально двух случаях ошибок docs с которыми нам пришлось бороться вот когда-то мы заметили такую интересную ошибку когда горбач коллектор обходит ластик иногда получалось так что он смотрел на какую-то переменную да и смотрел на какой-то слот на этом стыке и интерпретировал его содержимое неверно и это приводило к падением то есть вот у нас есть одна функция функция foo самом низу она вызывает функцию бар это две функции которые которые разложены вот на ластики и функции бар есть аргументы y у нее есть две локальных переменных да там они каких-то типов строчки числа и вот всю эту структуру стек до который в центре на картинке изображён горбач коллектору нужно обойти чтобы убедиться что вот то что лежит на стыке его коллег нет не надо она оно достижимо и должно должно остаться должно остаться в памяти и горбач коллектора обходят отходит да и вот на стыке дома можно понять лежат во первых локальные переменные аргументы и в то же время на этом же самом стейки лежат специальные кусочки метаданных которые например позволяют вам определить что вот эта функция была вызвана какое-то другое зло функции и этих как бы на самом низком уровне реализации там все подобраны таким образом до что garbage collector на них ориентироваться и понимает что вот тут у меня переменная а вот тут метаданные и я их как-то вот по-разному обрабатывают и все было бы хорошо пока мы а мы собственно говоря первым этапом что мы сделали в нашей реализации мы поддержали полностью 64 битные указатели и вот мы в работали с 6 4 бедными указателями и в какой-то момент нам начали приходить у нас так все в памяти раскладываться до что хвосты нижней 32 бита каких-то по литров да они их можно было просто перепутать с информацией которая значило что-то совершенно другое и вот этот момент garbage collector и все взрывалось все падало подала очень не часто падала один-два раза в месяц в на всей компании то есть вот папа всем по всем продакшен сервером по всем проектам и должно было какой-то произойти очевидно по 100 км с разобрались и поняли да что должно было произойти какое-то сочетание звезды должны были сложиться как-то очень неудачно чтобы вот так она упал с другой стороны у нас был другой баг а вот опять виртуальная машина опять сборщик мусора в какой-то момент запускается причем сборщик мусора да он решает как то вот так получалось что сборщик мусора решает вызвать деструктор userdata до совсем вкратце userdata это некий тип данных который позволяет вам предоставлять интерфейс в ло для работы с объектами которые определены где-то вот в нативной среде все или все + + и соответственно этот объект может аллоцировать какие-то ресурсы неизвестные а вот для того чтобы этот эту по эти ресурсы освободить предусмотрен такой механизм как финале затар это метод gc и этот me to me этот вид а метод запускается как обычный его функция запускается на востоке ну необходимо убедиться что стек стыку хватает места до чтобы принять эту функцию но в коде была ошибка где-то для каких-то других целей кашира вался указатель на старый стек и получалось вот так то есть у нас было две переменных нам нужно было их конкатенировать в этот момент по форма так написано что в этот момент может сработать горбач коллектором говорит конкатенации подожди значит мне нужно тут какой-то деструктор вызывать вызывает деструктор рио лоцируется так потому что нужно же ему место больше да и вот этот вот указатель макс так куда-то отодвигает а наш несчастный указатель ptr1 к остается да и когда garbage collector говорит все я значит поработал дальше можно продолжать исполнять нормально нормально программу вот этот указатель остается и опять всё разваливается и это было гораздо более критично это было на каждом захер чином проекте порядка десяти двадцати падений в сутки причем нам так везло что это происходило при обработке runtime ошибок и это уже очень походила на такой невольный доз нашей системы да то есть вот есть два партнера они торгуются по какому-то протоколу между собой вдруг происходит к это ошибка торговли вместо того чтобы не знаю там кидать кучу 500 их ошибок да и эскалировать откат к одним путем да у нас платформу просто рук и вот кусочек кластера уходил таким образом попадал с крышам 2 премьера две ошибки и там кордом путям core dump да но совершенно как бы очевидно пока не будет произведена произведено тщательное расследование причин то непонятно где ну как быть терпимо да и можно фиксить не спеша где караул и нужно срочно выпускать hotfix поэтому для каждого инцидента да абсолютно для каждого падения нужно уметь отвечать на вопросы что случилось каковы симптомы какого замуж говоря истинная причина потому что истинная причина она может быть от конечного симптомы очень сильно отдаленно как все починить и собственного как это протестировать для того чтобы ответить на вопрос что случилось у нас в компании давно испокон веков используется робот который обходит все продакшен сервера находит все core dump file и рассылает письма со статора и сами заинтересованным разработчикам из недавнего времени он передает корр файлы в единое хранилище опять же довольно простой такой бот до который решает кучу проблем во первых он не дает пропустить проблему потому что письмо придет она упадет в нужный фильтр разработчики заметит проблема не будет потеряно а потому что курдам будет сложно какое-то хранилище да а не останется на продакшен baxi а эта виртуальная машина она может быть свою очередь например там за выходные нашим обычным провайдером томска легче на термине равана что с ней может произойти да вот такие вот стектрейсы они позволяют собрать базу знаний что очень важно для того чтобы оценить риски от нашей ошибки и провести какой-то первичный анализ до что понять ну да там видели ошибку до видели там ошибку три раза за месяц до расследуем но как бы с кем-то спокойным приоритетом да и кроме того позволяет решать проблему оперативно потому что мы вот сидим в своем отделе занимаемся разработкой наша реализация а падает а в проектах соответственно сходить в проект в другую команду попросить какие-то доступа иные саше общем куча какой-то берг оптически более до которое мешает нам начать расследовать ошибки быстро получили кордом мы начинаем выяснять симптомы для того чтобы нужно ответить здесь на два вопроса да что что произошло в нативном коде пока мы не можем придумать ничего лучше gdb да и что произошло в lua коде а вот здесь от на самом деле тоже очень важный вопрос да для понимания нужно понять когда упала как бы платформ это собственно гостевой код что делал вот здесь нам долгое время помогал инструмент под названием об аресте gdb utils это набор плагинов gdb созданный авторами в фреймворка опен-рейз те который предназначен для паспорта мона лиза то есть когда у вас есть просто корка до мертвых слепок памяти когда вы не можете запустить какой-то процесс и собственно говорят что делает этот плагин весь приватной api он весь приватной api изначально там лоджи то да был повторён с помощью питонов ского пи gdb что позволяет вам посмотреть дам переменных позволяет получить наглядное данное состояние внутреннем состоянии вашей системы не только один минус есть у этого плагина давать поскольку он паре имплементировать весь внутренний api платформ это очень сильно зависит от реализации соответственно долгое время пока на шею наш форт не очень сильно отходил от лоджи то мы могли пользоваться в какой-то момент и разошлось пришлось написать свое но это очень сильно компенсирует ну усилия усилия по написанию своего оправдываются потому что без фонарей стыда отладка выглядят совершенно ужасно вы берете кастуете сырые указатели разыменовывает и что-то там пытаетесь найти какие-то адреса вы читать не очень удобно если у вас есть какой-то аналог платит такой плагин когда вы можете придумать себе какие-то команды до которые вам такой приятной форме позволит отлаживать ваш в корку и выяснять что же произошло у вас в в вашей системе перед падением и собственно говоря как только вы все поймете потратив на это какое-то время встанет вопрос как протестировать тут интересно качестве примера привести цитату из списка рассылки лоджа то от создателя ложе то майка поло который когда-то за к метил некий баг фиксы и написал что вот а вот бак есть я себя в этом убедил бак точно точно точно есть но мне кажется не получается его протестировать не fazer не справляется не как бы тест не могу скрафтить ничего не получается совершенно как бы признавая то что такие ситуации тоже тоже могут быть могу сказать что мы пока в этой простой практики не не сталкивались с такими с такими случаями дай даже для самых хитрых багов даже для багов которые в которым я рассказал например когда у нас там по плохому адресу а лоцируется памяти потом что-то в горбач коллекторе разъезжается да даже для них мы стараемся писать тесты в данном случае ну был написан тест в котором где-то 200 220 строчек кода на сие 80 точек кода на лугу вот что вполне на мой взгляд приемлемые поддерживаем на этом наверное буду переходить к выводам да понятно что работа над стабильностью там комплексная задача начинаем с приоритетов до решаем что вот наивысший приоритет у стабильности перформанс безусловно важно наведет потом сначала корректность и стабильность совершенно не стесняйтесь комбинировать тестирование различных типов да вот хоть что-нибудь да взлетит и когда у вас сложная система да вот сюда unit тестирование подсунули сюда функциональное здесь накидали какого-то что-то подобное на fazenda там интеграционными тестами покрыли это все так или иначе это гораздо менее гораздо более гибкого в поддержке дать чем потом ковырять какие-то падения падения в продакшене часто даже для нетривиальных случаев как показывает практика можно написать тест и их соответствие нужно писать инциденты нужно обязательно расследовать чтобы не оказаться в такой ситуации до что сначала мы машем рукой а потом у нас начинают проекты по проекты падать одним за одним ну и соответственно тоже для этого нужно чтобы было приятно и комфортно расследовать эти мрачные мрачные core dump это нужно развивать инфраструктуру писать утилиты заимствовать другие утилиты на этом у меня совсем все спасибо большое и ссылки на том чем я говорил и предыдущие доклады по теме нашей реализации спасибо большое да можно антон не забывай про приз лучшему вопросу антон вот на самом деле интересует вот очень такой интересный вопрос связаны с как вы вообще собираете jit то есть я его сформулирую из четырех компонентов этот вопрос вопрос номер один у вас есть синтаксис вас есть семантика языка вы это чем-то определяли расскажите пожалуйста как вы это делали соответственно какими инструментами это первые то есть там бизон или илья к то есть вы все рабочие вот это определяли второе вы же собирали jit машину как-то правильно то есть вы ее собирали чем зависит ли вообще компилятор которым вы с его собираете на качество непосредственно самого g это и четвертый компонент да то есть вот в принципе вот я не услышал один из механизмов тестирования вот таких вот внутренних языков которые используйте важно лулу и то или что то другое там java script какой-нибудь и да но один из хороших механизмов это вот пробовать тестировать собирать это разными компиляторами например там силен вам там с сэмом проверять этот м там на джесси на интеловском компе лири на разных процессорах в принципе немножко отличаются и и сравнивать результат вот расскажите вот вот про эту историю так смотрите давайте начну с конца да мы одним из этапов тестирования у нас есть сборка разными компиляторами и мы собираемся флангам и мы собираемся gcc и мы собираемся в разных комбинациях релиз сборка дебаг сборка там есть некоторое матрица да там тип компилятора тип сборки тип линковки конечной библиотечки которая все это дело реализует вот и а по стокам все собрали вот те тестовые сидит и которые у нас упакованным нашей в нашей кодовой базе да не как раз прогоняются у нас seo и решает себя решает эту проблему собственно говоря дамы в параллель запускаем вот не такое тестирование разных конфигурациях то есть до результата и сейчас стиль и ее тут же и тут же прикрутим еще clang отойди вот кота который которая которые смотрят собственно говоря вот то есть есть сборка разными компиляторами и статический анализ и даже где-то сбоку томске этот этого есть проверка автоматическая там на стиль кодирования да то есть это есть никакого бизона и flex нету потому что скажем так вот здесь frontend он является частью платформы тоже написан на си как бы свой свой контент который вот собственно говоря есть есть в кодовой базе да там мы в данном случае эту реализацию унаследовали от лоджи то вложить если не ошибаюсь от от 251 вот то есть там вот это этого нет и кажется какой-то вопрос пропустил тематику от этого зависит вообще качество то проблема которая возникает как будто нужно который очень редко используется она заключает попробовать и переопределить самостоятельно да ну то есть да если и если речь о том что у нас нет такого честного лампочкам плане с тестирования до его нет его как бы нет в принципе ни для одной реализации lua и да все пользуются как бы максимально чем чем могут использоваться до это внешними тестовыми фидами другими реализации тестироваться через реализации да это по-прежнему проблема дамы над этим думаем в микрофон пожалуйста у нас запись от оттуда все проблемы идут то есть вы фактически руками фиксики отдельные вот body который вас появляется это в принципе является все баги проблемами именно вот из того что вы не можете оттестировать саму семантику скорее не с этим я скорее соглашусь потому что бумага показать не можете таковы доказать не можно с да с скажем так смысле вот доказательство корректности компиляторов формально не можем мы можем сказал но зато мы можем сказать нас есть реализацию его 51 у на нее есть тестовые суета в соответствии с тем как написано в куче reference много мы считаем что вот в некотором смысле это тестовые суеты является новичкам плане с тестом ибо проходим то есть мы и в данном случае мы работаем также как работает референсная реализацию вот это мы можем доказать мне но тогда у вас должна как бы доказательная база строится на основе какой-то статистике вы должны на основе анализа большого количества различного кода строить будем говорить так чистоту использование тех или иных конструкций и в качестве тестирования вы должны брать самые редкие конструкции и прогонять с различными легко есть такой элемент файтинга редко используемых конструкции тогда уже в принципе вероятность того чтобы вы вы найдете бак она повышается мне кажется вы этого не делаете да конечно это хорошая идея нет именно этого мы не делаем и да мы смотрим вот в частности такой такой такой вот как вы сказали базы и базы года до хотим чтобы стали наши в наши проекты до которые работают в продакшене будем гонять тест на них и да в том числе решим эти проблемы которых вы говорите у меня сначала такой смешной вопрос а все-таки апа в студии не пробовали еще использовать шестую окей не знаю pvs-studio проводилась ли это первый вопрос и второй вопрос который проводит компиляцию а я правильно понимаю что это runtime его и джек индикация они когда происходит перед запуском многоуровневый проход и сборка в финального кода выбору максимально близко ну то есть чтобы есть 2g то есть который runtime а вы и насколько я понимаю и есть второй тип когда происходит аннотация долгий запуск но быстрая работа когда скажем половина языка не нужно потому что приложение не использовать его и так пвс до пробовали использовать буквально на прошлой неделе или две недели назад мне нужно внимательно посмотреть на тот отчет который он на генерал на первый взгляд он не показал с чего-то более серьезного чем показывает clang тайги но это неточно потому что как сказал только-только начали второй вопрос да jit компиляция у нас runtime avaya то есть это не какой-то там проход вот мы мы мы исполняем код виртуальная машина в интерпретатор исполняет байт-код за байт кодом в какой-то момент он находит горячий кот ну вот который исполняется достаточно часто и начиная с этого строит обходит этом горячие пути на графе потока управления и прям вот в динамике генерирует код еще один вопрос я правильно понимаю к лита форд или settle аджита то в именно их механики используются просто неожиданные там мир компании буквально на пол штыка в землю выяснилось что если очень хитро применять его можно он умеет же там работать дома форму сопло джедай реализация сейчас для компилятор во многом повторяет то есть не смотрели в другие стороны типов попробовать еще какие-то бы к науке мы скажем так ну такие идеи естественно уже были вот пока мы подробно не смотрели вот в эту сторону потому что на самом деле долгое время занимались именно такой решались задачи по другого форменной части вот и только недавно перекинулись на подробно напишет компилятор если я правильно помню на позапрошлом фосс доме был доклад от ребят который как раз на его время ложечку делают у них не очень быстро тогда было еще вопросы антон вопрос такой достаточно общей а что именно сподвигло делать арк но jetta и чем настоящий момент он отличается от оригинала то есть какие функции добавления и сразу скажу что вот прям подробная информация вот на этих по этих ссылок на этих ссылках есть можно посмотреть будет потом доклады а сейчас вкратце объясню насчет во первых у нас основная проблема была в том что лоджик вообще лоджий 20 до мы долгое время работали сложно 0 он прям очень сурово 32-битной там прямо вот в реализации probe зашиты 32-битные указатели и это стало для а если вы запускаете 32-битное приложение 6 и 4 на 6 4 битах то вам сюрприз доступны не 4 гигабайта виртуального адресного пространства один или два в зависимости от операционной системе версия операционной системы вот и в первую очередь это стало проблемой потому что когда вот наш сервер приложений с бизнес логикой работает помимо всего прочего мы действительно выгружаем туда данные которые объем которых начал доходить у клиентов доступ гигабайта да что это за данные то там некий такой инвентарная книга к той рекламы которую мы показываем это мы и хотим продать 2 ли хотим купить да эти данные росли и росли их стало столь много что значит не влезала и соответственно вот появилась не попробовали порешать какими-то другими способами стала сильно медленнее нам сильно медленнее это очень плохо потому что собственно говоря касты и хардварные до начинают расти неимоверно вот чем сейчас отличается этот форт значит во первых мы первым делом мы это все дело со карте для до linux x64 до поскольку другие аппаратные архитектуры нам не интересны мы можем поддерживать развивать адекватно мы решили проблему с памятью у нас честный 64 битные указатели мы туда добавили всякие работу возможности там шарить данные между потоками и какие то какие то скажем так дополнительные фича да то есть что что-то мы в компиляторе под подвигали то есть это некоторое улучшение функциональности добавления новых фич плюс честная работа в 64 64 битным адресным пространством до добавили добавили такую вещь как селинг это возможность горбач коллег то в принципе в lua он этот more can sleep дайвинг инкрементальный мы добавили возможность какие-то редко меняющиеся данные выносить в какую-то особую bus памятен про куда garbage collector не доходит то есть такой такой некий элемент генерации он настя такой вот и и эдем да и или и дан вот этого да да да вот еще вопрос если у кого-то еще есть какие то вопросы которые можно обсудить в кулуарах можно обсудить со мной всегда на стенде где удобно спасибо я буду спасибо антон сделай кому-нибудь приятно книжка о кстати отличная книжка на 7 талеб одураченные случайностью кому-то сейчас повезет книжка одураченные случайностью наверно знаете про вопрос про fading тестирование мне кажется нет спасибо"
}