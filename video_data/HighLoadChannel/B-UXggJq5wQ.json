{
  "video_id": "B-UXggJq5wQ",
  "channel": "HighLoadChannel",
  "title": "Создаём высоконагруженное приложение для Tarantool с нуля/Владимир Перепелица (Mail.Ru Group)",
  "views": 5236,
  "duration": 2818,
  "published": "2018-07-19T13:22:18-07:00",
  "text": "итак всем привет всем доброе утро надеюсь вы уже все достаточно проснулись для того чтобы воспринять огромное количество кода которое я разместил на слайдах как уже сказал костя это не совсем обычная презентация она нарушает каноны того как нужно делать поскольку хороший стиль это не показывает код но я решил немножко окунуться в историю вообще почему я использую тарантул шесть лет назад я пришёл mail.ru и у меня возникла некоторая потребность сделать очередь я знал что от кого-то я узнал что mail.ru есть такой продукт тарантул на нем что-то делает у него какие то есть экологии и прочее мне показалось что то на нем наверно тоже можно сделать очередь я пошел к кости да ну скажем так я недолюбливаю во-первых софт написаны на джаве и мне кажется меня многие в этом зале понимают во вторых я пользовался простыми очередями например ну ладно я сравнивал бен стал где может быть кто то слышал и активы мку может быть тоже кто-то слышал это было давно и в общем бен стал где показывал себя намного лучше об архитектуре он очень похож был на тарантул я просто показалось что если у mail.ru есть свой продукт внутри он используется то почему бы его не использовать я пошел к косте я пошел кости стал кость вот тебя тут все классно сделано наверно ты можешь сюда включить еще и очередь очередь должна работать так так так и так объяснил в общем ну я думал сейчас он возьмет сижку там все это в пилит в кор и так далее но на следующий день он мне дал приблизительно вот такой листинг кода все это был переломный момент когда можно сказать я влюбился в тарантул я просто понял что при помощи совершенно небольшого количества кода вам не нужно вы читаете здесь просто для оценки размера что можно написать совсем немножко очень простого кода на очень простом языке и получить совершенно новую для этой базы данных функциональность просто на ровном месте у меня появилось то что я хотел кость а дальше мне начал задавать вопросы а что дальше сделать может быть еще что-то добавить я сказал нет спасибо мне хватит я понял что с этим делать с тех пор было написано очень многое и сегодняшний доклад он для того чтобы показать вам как это сделать на современном tarantul и на тот момент это был тарантул 147 я более чем уверен что большинство из вас не сталкивалась не столько с 14 но и даже с 15 вы уже столкнулись с тем что можно назвать современным тарантулом в котором есть удобный мыса чп ок в сравнении с тем что было тогда есть много чего другого и это много чего другое появилась отчасти благодаря тому что мы начали делать на таран туле приложения была взята эта очередь я ее начал дописывать мне чего-то не хватало я приходил кости просила но появлялась и так далее и так далее и мы пришли к тому тарантулу которые у нас есть сегодня давайте посмотрим как решить такую же задачу на сегодняшнем tarantula для того чтобы начать вообще работать с тарантулом а кстати поднимите руки кто вообще вот не запускал тарантул не умеет что то писать на нем хорошо я кратенько значит для того чтобы начать работать в тарантулом вам нужно создать файлики netlogo тарантул это лу интерпретатор написать там бокс кафе г бокс кафе запускает непосредственно внутри нее скажем так кишки тарантула поскольку мы делаем некоторую очередь нам понадобится где-то это хранить создадим space space можно создать просто space без каких-либо данных но мы добавим к нему две вещи во-первых чтобы при рестарте нормально рестарте ца мы скажем что space нужно создавать только в том случае если он не существует также в современном tarantul и есть возможность указывать формат полей с описанием того что лежит внутри мы это сделаем под очередь я возьму совсем простую структуру мне понадобятся только идиш никита scanf их статус и и какие-то произвольные данные мне в общем-то все равно что там будет лежать space не может существовать space существовать может но работать с ним вы не сможете без праймари индекса поэтому мы создадим праймари яндекс по тому самому айдишник у причем до нужно обратить внимание что едешь ник мне один ник а тип записи должен совпадать и в формате и в яндексе это проверяется в общем это почти все все что вам нужно сделать дальше это например для локальной разработки подключить консоль и запустить ее и когда вы выйдете из консоли то есть с тарантула можно выйти вот это тарантул в режиме разработчика вы создаете вот такой файлик дальше вы его просто запускаете видите приблизительно такую картину и у вас есть интерактивная в консоль в которой вы уже сразу можете начинать что-то делать это первый и очень удобный момент тарантула вам не нужно делать что-то очень долго очень много устанавливать разбираться вы просто пишете не знаю там 10-15 строчек на любой локальной машине ну кроме винды и все вот вы можете начинать пробовать тарантул после того как мы его запустили дальше начнем писать собственно свою очередь во-первых я рекомендую tarantul и в режиме девелопмента есть если его самому собрать будет по умолчанию включен strict так он не включен я рекомендую сразу принести включить strict мы немножко будем говорить про язык lua он специфичен скажем так в нем есть странности в общем модуль strict призван немножко скажем так помочь вам когда вы будете ошибаться поэтому подключим strict а дальше начнем писать приложения объявим некую глобальную сущность которая будет нести нашу функцию атрибуты и прочую пилу и объявим две функции то есть для того чтобы сделать очередь самое первое что нам нужно это две функции положить task и взять task как нам положить task ну да поскольку мы их куда-то кладем откуда-то достаем у них будут какие-то состояния нам нужно трогать что task взят или task не взят поэтому я ищу заведу глобальный фишек глобальную таблицу с этими статусами и в качестве статусов возьму 1 буквенное значение однобуквенная ну потому что in memory база так компактней как сделать тут да вообще-то очень просто нам нужно сгенерировать какой-нибудь айдишник есть много разных способов здесь я просто написал в найди а дальше просто вставить данные space причем я получаю произвольные любые аргументы функцию собираю их то пол вставляю то что мне нужно а все остальное добавляю ну и генерацию айдишник а я делаю следующим образом вот тут уже пошли различные подсказки которые вы можете так или иначе использовать в своей базе например можно в качестве идентификаторов взять клок моно тоник чем хорош клод моно тоник для очереди кто может сказать чем хорош блоком она тоник для очереди именно причем теоретически может существовать кейс когда мы очередь кидаем task и там уже есть tasks такой с таким значением ну мало ли вот что-нибудь случилось мы можем просто посмотреть а нет ли тоска с таким айтишником и как лукмана тоник докинуть единичку поскольку это микросекунды я не думаю что мы от этого сильно пострадаем но мы соблюдем порядок и так айдишник сгенерили и да вот начиная с этого момента я где-то начинаю подключать какие-то модули тарантул идет большим количеством встроенных модулей и первый модуль которая подключил это клок по сути это практически прямые билдинги к хищной функции клок bedtime во-первых они очень быстрые во вторых там есть все что нам нужно мы можем смотреть cycle time thread тайм-волк лог тайма на тоник поэтому в разные моменты времени выбирают то что мне подходит больше пустого как мы написали путь мы ее сразу уже можем вызывать то есть мы в нашей вы это написали перезапустили дальше все в консоли мы говорим пут и видим что у нас запустился этот task то есть он выглядит как такой-то пол то есть эта штука называется the pool tarantul и все что мы туда кладем туда складывается причем мы можем класть даже произвольные данные некоторые структуры вложенные для нас тарантул каждый field упаковывает massage pack поэтому они хранятся и компактно и позволяют нам эту структуру сохранить все что мы запустили лежит спейси можно взять вручную непосредственно команды space и посмотреть что там лежит вот наши данные из того как мы сделали put наверное надо приступить к тому чтобы эти тоски bright сделаем простой тейк для того чтобы сделать тэйк нам нужно поработать со статусом то есть мы берём те тоски которые готовы к обработке поэтому мне понадобится отдельный яндекс по другому полю первичный индекс я создал поиде пойди нельзя брать то скину кроме как fools к нам вторая самая наверное удобная фича тарантула это возможность создавать различные индексы почти как в сквере вы можете создавать индексы на разные поля композитные разного типа и вот здесь я этим начинаю пользоваться я задаю второй индекс где указываю что у меня первое поле это статус я буду по нему искать а второе поле это непосредственно айдишник который у меня клок моно тоник он мне упорядочить тоски в рамках одного статуса ну и дальше функция тейк я просто беру уже встроенные функции для выборки есть специальный итератор вызывается он на спейси как player в него мы передаем часть ключа да здесь мы сталкиваемся с составными индексами то есть мы составляем индекс из двух полей ищем мы по первому упорядочена она по второму мы говорим найденном the black которые равняются статусу ради по первой части во второй они нам будут выдаваться в упорядоченном порядке если мы что-то нашли то есть мы просто переходим внутрь for a хватаем этот task обновляем его и возвращаем обновляемое его для того чтобы никто другой кто придет таким же вызовом тейк не взял его но если task-ов нет то мы не зайдем в цикл п р свернет ничего например если все тоски взяты и вернет пустую строку как будет выглядеть да кстати вот здесь я использовал номер поскольку первый уровень то плов tarantul и не имеет имен он numero ван при таких операциях как апдейт до практически совсем недавнего времени нужно было указывать именно номера в качестве вспомогательного элемента я сделаю я сделаю табличку в которой сделаю mapping имени поля в его номер мне это будет помогать при написании различных апдейтов при модификации кода чтобы не ошибаться и подставлю это непосредственно в мою функцию теперь запустим task и попробуем его взять в общем получилось то есть мы вызвали тейк он для нас обновил статус и вернул нам этот то пол если мы попробуем вызвать прелесть какая можно батарейку поменялись мне кажется работает на странно она я попробую мы вызываем tx тейк берет у нас task мы видим что он обновил нам статус и вернул непосредственно ту же самую записи и праймари кейсов падает если мы вызовем повторно тык-тык больше ничего не вернет потому что реддита сказ статусе р больше нет когда мы так взяли нам нужно его вернуть в общем суть очереди с одной стороны у вас продюсер который кладет леди тоски и to put с другой стороны у вас потребитель который тоски берет обрабатывает их у него обычно два исхода либо он их обработал либо ему нужно вернуть этот тоску он с ним не справился и его должен взять кто-то другой вот это были выделены функции f и релиз обе они принимают айдишник тоска выбирают этот task смотрит есть он нет то есть можно вызвать с мусором каким-то если статус что так взять мы его возвращаем обратно функция очень похоже единственная 1 удаляет обработанные тоски другая возвращает их вроде посмотрим как это уже работает со всеми четырьмя функциями то есть мы делаем путь 2 task-ов мы делаем track 1 мы ее релизом она возвращается обратно статус р и последующей тейк берет нам этот task если же моего процессе он будет удален и последующей тейк возьмет уже второй так то есть мы соблюдаем порядок мы спокойно берем и если так взять то он не выдается еще кому-нибудь мы получили вполне уже нормальную работающую очередь мы можем написать некоторые консьюмер который будет процессе тоски он будет их в цикле брать если тоски есть как-то его обрабатывать у этого концу мира есть одна проблема то есть когда мы вызываем тык тык нам сразу возвращает либо тоски есть либо тоска нет если написать такой цикл и запустить его целом все будет работать за исключением того что он будет просто так крутиться в цикле выполняя повод вот десять тысяч штыков на моем нур руки просто так в никуда на нагрев компьютера для того чтобы с этим что-то сделать нам понадобится следующих примитив который tarantul и есть уже давно вот начиная с тех самых младших версий этот примитив называется канал кто знаком с каналами для скажем так мешкай берново между этого взаимодействия в других языках значит смотрите канал это такая штука которая позволяет передавать сообщения туда по своему это как бы очередь сообщение из одного фейдера в другой у нас есть файбер который кладет то с кем то есть когда мы приходим в эту базу данных по сети или работаем с ней из консоли это fider в нем исполняется нашла код когда он приходит он эти тоски кладет ему нужно через какой-то примитив сообщить другому фай беру который ждет этих task-ов что появился новый тоска канал работает следующим образом в нем есть аллоцирование место то есть сколько-то слотов под тоски которые могут быть взяты потом она у можно создать пустого размера в этом случае положить можно только в кислоты которые кто-то ждет то есть мы создаем канал на например на два элемента в нем есть два слота под put если придет какой-нибудь потребитель он создать еще один скажем так слот под путь 3 если мы с другой стороны попытаемся сделать put в этот канал то у нас три пута пройдут успешно а четвертый путь заблокирует нам тот файбер который кладет в этот канал это позволяет организовать меж файбер на и взаимодействие по аналогии например в языке гол очень похоже примитивы для работы с каналами значит tarantul и для общения между играми тоже есть каналы и мы ими в данном случае воспользуемся мы возьмем функцию так как она у нас есть и немножко ее переделаем во-первых мы добавим тайм-аут мы будем вызывать тейк будем говорить что мы готовы ждать тоска в течение какого-то времени вместо простого цикла когда мы просто берем и что-то select им мы сделаем цикл который будет пытаться найти готовый task если он его не нашел он будет вычислять а сколько времени осталось ему ждать вот это время мы отведем как раз канал тут мы создадим канал который будет ждать какое-то время с этим тайм-аутом фишка канала в том что при помощи него можно разбудить другой файвер мы делаем так он пытается взять task если он его взял все хорошо он сделал retour но и ему ничего не нужно но если он не нашел тоска то существует возможность подождать в течение тайм-аута причем другая сторона которая будет этот task производить может этот fighter разбудить давайте посмотрим как это будет сейчас работать без того что мы будем будить наш fider я сделаю такую маленькую функцию в отдельном файле рим я сделаю task путь через 0 1 секунды то есть сейчас очередь пустая но если как бы запустить все кто через ноль одну секунду task появиться при этом я сделаю вызов tx тайм-аутом 3 когда я запущу это я увижу следующие мой тейк попытался найти task не нашел его и он уснул на три секунды через три секунды он проснулся и попробовал еще раз найти task и нашел его вот нам нужно сейчас сократить вот это время с трех секунд до 0 1 то есть на у нас так должен проснуться тогда когда у нас появится task для этого непосредственно функции put нам нужно сделать следующие мы возьмем вторую функцию пут и добавим в нее отправку сообщения в канал в качестве сообщения я воспользуюсь просто простым сообщением true я могу туда отправить строку я могу отправить еще что-то нам неважно что мы отправляем нам нужно просто разбудить другой файвер помните я говорил что путь может заблокироваться если в канале недостаточно места самому производителю task-ов все равно есть с той стороны потребителей или нет то есть он не должен блокироваться для того чтобы разбудить кого-нибудь поэтому логично поставить здесь 0 таймаут на блокировку если там есть читатели то есть если есть кому сообщит что появился новый тоска мы его разбудим иначе у нас сообщение в этот канал мне положится но в общем и не страшно в целом можно проверить а если там кто-то кто сейчас на канале ждет сообщений поэтому мы проверим что там есть читатели если читатели есть мы моих нём одному из них о том что у нас появился task новый после этого тот же самый код который запускали начнет работать совершенно иным образом мы создадим так через 0 1 секунды и тейк который усыпал на три секунды практически через эти 0 одну секунду просыпается и получает наш тест мы убрали проблему бизе лупа которые непрерывно висел в ожидании тоска и собственно переходим к следующему да если мы так не положим если тоска нет он подождет полностью все три минуты теперь перейдем к сети мы все потестил локально у нас все хорошо теперь давайте поработаем посетим вместе с тарантулом идет много всего значит первую очередь нам нужно будет наш сервер сделать сервером добавим в бокс кафе г лесам это порт на котором он будет слушать вместе с этим нам понадобится сделать какие-то разрешения я не буду настраивать разрешение я просто скажу что все кто подключаются имеют привилегии на исполнение про право вы можете почитать отдельно если этот код перезапустить он второй раз скажет что уже пограничный нельзя так делать и так далее поэтому мы завернём это в бокс vans бокс won't позволяет выполнить один statement на инстансе всего один раз дальше нам нужно производить тоски мы сделаем продюсер в поставке тарантула идет модуль который позволяет вам подключаться к другому тарантулу я мог бы взять другой язык для того чтобы это продемонстрировать но я это могу продемонстрировать и с помощью тарантула я подключусь вызову функцию put напечатаю результат и закрою соединения запускаю это самим же тарантулом я говорил тарантул это вполне себе интерпретатор lua передаю какие-то данные эти данные улетают базу сохраняются мне возвращается результат аналогичным образом выглядит консьюмер он подключается он вызывает так с некоторым тайм-аутом ждет получает результат если он получил task он его печатает после этого например он task релизе то есть мы сейчас его не пытаемся процессе мы запустим у нас task получен будет но при этом при попытке его зарелизить у нас вылезет какая-то фигня дальше мы начнем разбираться что же это за фигня во первых при повторной попытке концу мира мы обнаружим что у нас предыдущий концу mirta ske взял но он их не смог вернуть по той или иной причине то есть да у него произошла ошибка но тоски заморозились их больше никто не может взять но и никому из вернуть потому что тот код который избрал вышел вот мы можем поселить увидеть что они у нас взяты в этом нам помогут триггеры тогда в 2012 году триггеров не было но я очень попросил их сделать потому что без этого на плохо писать очереди приходится писать отдельный монитор фейдеры которые будут тоски как-то возвращать в tarantul и сейчас есть триггер и на подключение и на отключение клиентов если мы добавим такие штуки мы сможем видеть что у нас кто-то подключился с какой сессии session есть понятие совершенно идея с какого и печника и когда кто-то отключился правда есть один нюанс вызов сашан пир делает get there name непосредственно на сокете поэтому когда кто-то у нас отключается гербер name возвращает уже нечего и мы сделаем небольшой хак мы во время подключения запомним кто к нам подключился для того чтобы знать кто у нас отключился когда он отключился это позволяет легко отлаживать да здесь я ввожу такую штуку как бокс сашан старридж это временная таблица в которую вы можете сохранять все что вам хочется на время существования сессии теперь у нас отключается клиент нам нужно как-то убить его тоски введем понятие владения тоска то есть тот файбер то сессия которая так взяла должна за него отвечать заведем две таблички пакетов которые мы будем запоминать эти данные и модифицируем наш и функции мы модифицируем функцию тейк мы в ней запомним что конкретный так взят и что он взят конкретной сессией также нам понадобится модифицировать код возврата тоска с eg и релиз и мы сделаем под него одну общую функцию то есть мы будем проверять что у нас тоски есть что у нас так взят а также что task взят конкретно этой сессии то есть нельзя будет в одном месте это так взять из другого места прийти и сказать что вы освободите task мне он больше не нужен ну и наши функции ок релиз становятся очень простыми мы в них просто вызываем get up get those ты за нас все проверяет что так нам принадлежит взяты так далее и дальше уже с ними работаем когда мы вызовем наш концу мир повторно он нам скажет что тоска и дерек варит мы находим первую проблему в нашем коде я написал toast кайден когда мы работаем внутри тарантула то пол всегда ассоциирован со спайсом а у space а есть формат all формата есть имена полей поэтому там можно пользоваться именами полей над apple когда мы выносим это за пределы базы то пол становится просто то план просто массивом с и набором полей поэтому в данном случае мне нужно айдишник указать именно как первое поле другой вариант который я мог бы использовать я мог бы это сюзан ходит в massage pack мне бы это вернулась в клиент раз кодировала но это другой вариант когда я это поменяю я столкнусь с очередной проблемой я вызываю релиз а мне говорят ах ты такой task не брал при этом я смотрю айтишники очень похоже вот прямо но это один и тот же видишь ник только у меня есть еще какая-то строчка у л.л. здесь я скажу что добро пожаловать в lua за все удобства которые мы имеем стороны ли мы платим цену использования языка lua и не говорил вам о всяких вещах типа что 0 это true или про другие вещи вы можете найти старые доклады с хайло до были разные можете в конце концов почитать я расскажу про эту штуку она очень неочевидная и на нее очень легко наступить возьмем таблицу и положим в нее четыре ключа нормальный человек предположит что в общем эти четыре ключа положится как два поскольку мы берем единичку ну максимум там как три когда мы это все выведем когда мы это все вы видим мы видим что все эти ключи положились раздельно то есть мы видим в качестве значений 1234 причем при sealer при сериализации мы как-то не делаем разницы между большими знаковыми для знаковыми и обычными числами веселости наступают когда мы пытаемся это все забрать обратно берем нашу таблицу которая у нас есть и пытаемся из нее достать то что мы туда сложили здесь нас ждет определенный подвох большие типы bigint eager которые ansi он ценит лонг и an seiner и ланг ланг 64-битные интех являются расширением lua jetta являются так называемой си до той так вот сюда то в таблице сохраняется просто как адрес и у двух этих чисел просто два разных адреса и когда мы складываем уэллс таблицу мы потом не можем по такому же значению достать его есть таблицы поэтому нам придется немножко переделать нашу очередь и нашу наше владение ключами вообще это хороший шаг он вынужден и но он позволяет нам в дальнейшем модифицировать наши ключи и сохранять в качестве ключей произвольные значения возьмем мыса чп от втором туре он используется для хранения то плав мы здесь его вас пользу им и воспользуемся им днях превращение любого произвольного включая в строку эта строка будет являться у нас ключом в нашей таблице мы добавляем в тейк упаковку ключа и сохраняем уже в таблице в качестве упакованного ключа в функции get task мы проверим что к нам ключ прошел в правильном формате превратим его в намбер 64 если формат был неправильный после этого воспользуемся тем же самым кей паком которую пакует его нам в месяц pack ну и поскольку этот упакованный ключ будет требоваться всем функциям которые с ним работают мы будем возвращать из нашей функции get task с тем чтобы функции акриле смогли им пользоваться и очищать его из сессий поскольку у нас есть триггер и поскольку у нас есть триггер на disconnect мы теперь знаем что у нас disconnect эта конкретная сессия что у нас это цессия владеет какими-то ключами мы можем написать такую штуку мы можем взять все ключи которые взяты этой сессии и автоматом вернуть их в исходное состояние состояние рейде триггер запускается от имени сессии которая disconnected а поэтому проверка владения будет отработана адекватно то есть мы просто вызываем нашу фум нашу функцию релиз пока мы это все будем тестить мы столкнёмся с тем что мы task-ов набрали потушили базу запустили базу тоски никому не принадлежат но при этом они статусе тейкер поэтому еще мы добавим в наш код модификацию статусов при старте база стартует и очищает все тоски которые взяты мы получили очередь которая уже работает этим можно пользоваться это почти скажем так production единственное конечно его завернуть но нам его нужно немножко улучшить давайте добавим отложенные тоски мы добавим новые новое поле мы добавим новый индекс по этому полю в этом поле мы будем хранить время когда какой-либо task нужно перевести из состояния состояния мы модифицируем нашу функцию пут и добавим новый статус функцию пуст мы добавим поддержку delay если дела и передам то мы тасс кладем не состоянии ради состоянии выйти нг и говорим что через какое-то время он должен быть обработан нам понадобится кто-то кто этот по ст обработает для этого существуют фоновые fighter и вы в любой момент можете создать файбер который будет за вас работать не ассоциировано нескольким соединением мы создадим файвер который будет крутиться бесконечно который будет ждать ближайшего дедлайна ближайшего тоска если приходит время какого-то тоска мы берем его и модифицируем переводим из статуса ожидания статус готовности также notify церу я тех клиентов которые могут ждать тоски треки в целом вот эта функциональность помещается на вот такой чуть более мелкий слайд то есть вот это ведь файбер который позволяет нам организовывать самостоятельный task flow внутри очереди то есть очередь начинает сама модифицировать свои тоски сюда можно добавить много чего другого автовозврата scanf авто удаление task-ов но вот я показал на примере отложенных task-ов теперь мы делаем put сделаем делаем так тасс конец делаем так еще один с тайм-аутом который укладывается в появление нашего тоска и как только task появляется и мы видим что его появил нам именно файбер юра нет у нас он появляется мы его выдаем конкретному потребителю когда мы работаем с очередями нельзя забывать про такие вещи как мониторинг очереди потому что самое печальное что может случиться с вашей очередью она станет очень большой или вообще закончится tarantul и очень просто сделать статистику можно просто посчитать все что есть сколько лежит рассказ можно взять яндекс по индексу чего-нибудь посчитать и вы можете это все написать вот так и у вас она все заведется будет работать до того прекрасного момента пока он будет работать быстро до того прекрасного момента пока у вас не появится очень много task-ов то есть вы пишете приложение класс все работает очередь пустая нормальное состояние очередь это пустая но вдруг что-то случается у вас тут она летает миллион task-ов функций остаться прекрасно работает она показывает что у вас много ради task-ов правда она начинает работать очень медленно проблема в вызове индекс каунт нельзя вызывать индекс каунт индекс каунт вызывает индекс скан с этим ключом поэтому нам нужно сделать следующие мы запишем значение счетчиков мы создадим табличку на старте в которую сложим значение этих счетчиков непосредственно на старте бойца мы их посчитаем теперь эта функция начнет работать очень быстро все что нам понадобится к этому добавить это обновлять эти счетчики при любых операциях когда мы делаем тейк мы одно уменьшаем другой увеличиваем когда возвращаем уменьшаем увеличиваем так работать будет так были написаны первые счетчики они нормально работали все хорошо правда через некоторое время обычно при таком коде мы приходим к следующему у нас эти счетчики у нас эти счетчики разъезжаются поскольку поскольку у нас самостоятельно поддерживаемая консистентной счетчиков мы получаем что где-то мы что-то забыли в каком-то месте не ставили добавили новую функцию и они разъехались счастью в современном tarantul и есть такая удобная вещь как триггеры на спейси мы выкинем весь вот тот код который мы написали и просто повесим один триггер этот триггер будет брать любое изменение на спейси причем даже вы можете вручную прийти и сказать бог space апдейт и он это учтет и будет просто менять состояние для того чтобы учитывать вообще любое произвольное состояние можно сразу сделать вот такой хак если у вас записи в таблице нет значит у нее изначально нулевое значение после этого у вас все начинает работать нормально и например мы можем эту статистику отправлять по сети докторантуре есть сокеты это звучит странно сокеты внутри базы данных но тантал необычная база данных тарантул эта база данных и сервер приложений мы подключаем сокеты мы определяем хосты порт куда мы будем отправлять например это графит а дальше вот для того чтобы что-то отправлять коне понадобятся просто прорисовывать хост порт у просто создать успешный соки и что-то в него отправить то есть у dp делается так у тебя может быть не очень надежный поэтому я это могу переписать даже через tcp доступ к сроки там практически как си и это позволяет реализовывать практически любую логику так профессия сказал через раньше ну в общем типичный файбер который отправляет данные будет выглядеть таким образом и нельзя не сказать про такую вещь как рилот кода на горячую если вы сделали базу данных в которой гигабайты данных загрузили туда какой-то код вам этот код нужно обновлять обновлять базу гигабайты с рестор там не очень удобно частью прелесть к счастью тарантул позволяет перезагружать код значит что происходит когда вы загружаете код когда вы пишете рик флэр он помещает в таблицу покажу один то что загрузилась из файла для того чтобы выполнить рилот нам нужно сделать следующие нам нужно стереть эти данные из таблицы пришло дед и позволить коду продолжить исполняться рилот можно писать вручную вот приблизительно так но здесь куча глобальных переменных костылей и вы обязательно где-нибудь ошибетесь под это у нас написан готовый модуль про эти модули будет подробнее рассказывать на вечернем докладе игорь латкин один из модулей оттуда это пекка черри лот он за вас это всю работу делает можно приладить при помощи ту файл на файл и ни слова можно просто написать пока чело вот он сам запоминает из какого файла все было загружено для того чтобы код был ли лода был его нужно писать немножко по-другому вам нужно учитывать тот факт что код может быть исполняться может исполняться повторно может быть загружен повторно поэтому сам код немножко модифицируется также вам понадобится как-то учитывать перезагрузку триггеров триггеры поддерживает указания старой функции которая была под этот триггер и триггер возвращает функцию поэтому все что я делаю я запоминаю куда-нибудь в переменную какой триггер у меня был и передаю его при установке если его не было там нил он не заменяется устанавливается новый если он был мы его заменяем это работает из риплейс триггерами из disconnect триггерами и последнее это фейдеры файбер запускается фоне мы его никак не контролируем там написано в al tru он никогда не завершится и сам по себе не переводится нам понадобится канал для того чтобы его разбудить во время нам понадобится такая штука которая называется поколение то есть я это делаю так каждый раз когда кот загружается я нумерую текущее поколение приложение каждый fighter знает свое поколение и мониторе а работает до тех пор пока это поколение не истекло когда мы приладили код поколения поменялось пайпер и вышли но с новым кодом загрузились новые fighter ii ну и можно файбер найти файлы если он у нас и долго о том что ему хорошо бы проснуться ну и на последок у нас было консоль когда вы пари лоде тех пор вам скажет что ой консоль уже запущена мы можем это сделать либо так либо так итак подведем итог мы сделали и рассмотрели очень много моментов 200 список я уже не буду его перечислять поскольку у нас закончилось время я вам просто покажу листинг кода вот был листинг вначале вот это листинг в конце это обобщенная очередь всего того кода который мы здесь рассматривали это работающая сетевая очередь с авто возвратом task-ов с триггерами с возможностью отправлять статистику в графит по тисе пи и так далее она на нормальном железе спокойно выдает двадцать глпс такая штука пишется приблизительно за день вот изучая документацию и здесь порядка 300 строк кода вопросы я немножко затянул время но к счастью у нас впереди обед поэтому вы можете меня поймать и мы можем в принципе ведь немножко затянуть время я сейчас вам вернул список того что мы рассматривали для того чтобы вам было проще задавать вопросы и вопросы спасибо за доклад вопрос по пока тяжело этот каунта он сбрасывается при рестарте база или он пишется валок варлок не пишется в рилот не пишется в валок рилот относится исключительно к lua им можно пользоваться даже без вызова бокс кфг он отвечает только за перезагрузку кода скажите такого рода конт когда процесс разработки то есть муж так сходу не очень планет существует как бы инструментарий типа hyperfuse еще что то но самый такой классический способ профайлинга используемый и у меня и у многих других это клок прок классический benchmark клок прок форм насколько итерации вам кажется адекватным для того чтобы замерить еще раз клок прок смотрите сколько вы потребляете циpкa там единственный hand про профайлинг нужно учитывать что-то вроде бы очень быстрый язык но при этом у него есть garbage collection который откладывает какие-то вещи на потом при профайлинга обязательно учитывайте случающейся garbage collection либо вызываете его явно раз какое-то большое количество итераций либо следите за тем чтобы у вас количество итераций была достаточная для вызова карпач коллектора иначе профайлинг будет весьма нечестным спасибо за так вот не вопрос я правильно понимаю что она только локальные очередь работают только с одним торону или она работает распределён также если дату хотя в два слова расскажи как данный пример показывает как на одном инстансе сделать логику очереди я показывал продюсеры консьюмер которые могут похитить подключаться к другим тарантулом и это тоже тарантулы вам никто не мешает поднять много таких маленьких тарантулов соединить их все при помощи внешнего еще одного тарантула сделать проксю которая ходит в них все держат соедини это все та же можно но на создание скажем так сетевой инфраструктуры вокруг многих этносов можно потратить еще один доклад но это все можно делать и в реальном продакшене это делается спасибо за доклад меня дмитрий зовут вот такой вопрос самом начале сказали что обращение к вызов функции системного времени и накладные не накладно это действительно так или не проще жить и быстрее с нет нет софт инкрементом через sequences или как назвать потому что но мне кажется у каждый раз когда ходите время вам нужно точное время он ходит нам по цепочке ведро возвращается не проще посетите что происходит когда называете sequence одежде подобную реализации и смотрите вызов времени это та системный вызов но это довольно легковесный тянуть видом в люцисе но в любом случае в сравнении с производительностью нашей очереди то есть накладными расходами по записи хранения и так далее вот у меня получились какие-то цифры 20 крп количество клок моно тоников которые можно вызвать превышает это на несколько порядков стоимость взять яичниками зерна по сравнению с этим при этом sequence обязательно пишется в wow поэтому sequins это дополнительная транзакция которая стоит намного дороже чем как моно тоник ему я таких подробностей не узнал просто подумал что проще жить может быть для базы данных вот как приложение жить не обращая сейчас так времени предоставлять ему там когда кладете в очередь можете потом склеить власть уже туда пусть клеенку сам считает свое время а базу данных не грузит бодуэн можно можно и так существует например модуль расширение которое позволяет любой space превратить в очередь с различная функциональностью здесь был пример как это написать с нуля есть готовый модуль там например xq там он позволяет вообще хищник самому генерить передавать брать у избрать times и так далее из вариантов масса то есть вы выбираете тот который вам просто подходит под ситуацию лучше в общем вы меня можете найти сегодня периодически здесь если есть какие то еще вопросы пожалуйста подходите ну и в общем пишите"
}