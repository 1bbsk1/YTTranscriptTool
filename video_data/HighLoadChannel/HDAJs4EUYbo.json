{
  "video_id": "HDAJs4EUYbo",
  "channel": "HighLoadChannel",
  "title": "PHP в асинхронном мире / Дмитрий Мамонтов (МАГНИТ) (дубль, более короткий)",
  "views": 257,
  "duration": 1765,
  "published": "2024-04-17T00:59:44-07:00",
  "text": "Всем привет Меня зовут манта Дмитрий я занимаю должность руководитель команды Магните и сегодня вместе с вами и PHP Мы погрузимся в асинхронный мир Почему сказал Додо лучший способ объяснить это сделать это если вы захотите попробовать это сами в один из зимних дней я расскажу вам как это удалось Алиса в стране чудес наш доклад будет разбит на два блока основы и файберы о чем же будем говорить блоки основы это асинхронность реальном мире Как устроен PHP Ну и куда же без реальных примеров в блоке файберы я вам расскажу что же это вообще такое принесли ли они асинхронность нужны ли они нам и какую проблему они решают Ну и конечно же сравним реализации и попробуем сделать выводы подготавливая доклад на реальных примерах объясняющих асинхронную обработку с нуля Я понял что примеров слишком много И выделить самые актуальные затруднительно серьезно Вы можете себе представить процесс природе который следует определенной последовательности или организованной очереди И асинхронно это не значит хаотичный например улей это единое целое живущее Как хорошо управляемая система Несмотря на то что каждая пчела действует самостоятельно занятая своей задачей Еще одним примером является человеческое тело где каждый орган действует со своей целью и процессом однако все прекрасно скоординировано с повторяющимся ударами сердца постоянным тиканьем и проталкиванием крови по всем частям системы на самом деле гораздо труднее представить что-то действительно синхронное по своей природе Вы можете себе представить чел к примеру ожидающих свою очередь чтобы войти в улей и чтобы положить в него немного меда Я думаю это невозможно а это чудеса равнодушно пояснил Чеширский кот вниз по кроличьей норе если углубиться в тему PHP это язык сценариев общего назначения особенно подходящий для веб-разработки в отличие например от Java PHP не имеет встроенного сервера Но на самом деле он есть но это Экспериментальная функция не предназначенная для использования в продакшене Если вы хотите запустить приложение PHP вы Либо выполняете его как отдельный скрипт запускаем через интерфейс командной строки либо запускаете его как текущий серверный процесс например с помощью fpm который может управлять дочерними процессы в случае склеив Все очень просто для обработки одного запроса выполняется один процесс PHP компилирует код динамический по запросу Что означает что PHP запускается инициирует движок и подключит модули после того как это будет сделано PHP скомпилирует и выполнит ваш код по окончанию обработки Он отключится fpm все будет также но система постарается подготовиться к запросу приходящим сервера FM позаботится о том чтобы запущены процесс PHP уже существовал и был готов принимать запрос в зависимости от типа управления процессом статического динамического или по запросу он определяет сколько дочерних процессов необходимо выполнить для обработки входящего запроса ответ сервера Однако каждый из этих процессов выполнится для обработки одного запроса одновременно таким образом каждый второй запрос попадает в очередь и ждет своей очереди на этом безумном чаепитии и это не означает что рабочий процесс используется каким-либо процессором в каждый момент времени ожидания возможно был отправлен какой-то внешний запрос и процесс просто ждет ответ Чтобы продолжить выполнение текущего запроса было бы здорово если бы мы могли разумнее использовать ресурсы и выполнять другую задачу по времени ожидания а текущую По истечению времени ожидания мы уже отгадали загадку Некоторые из вас уже сталкивались с подобными ситуациями работая с импортом экспортом данных во внешней системе и мы думаем о том как запустить новый процесс или поток PHP непосредственно из вашего текущего процесса есть несколько у нас существующих расширений доступных для PHP это и параллель Оба на самом деле требуют сборки PHP с ключом zts возможно позже я подготовлю еще один доклад именно углубляясь многопоточность Однако Теперь мы ищем понятный простой и контролируемый способ не блокирующим образом без фактически необходимости использовать многопоточность или думать и Митин в виду что здесь основными целями являются повышение производительности и повышение удовлетворенности конечным пользователей поскольку мы хотим эффективно использовать наши ресурсы иногда Нам нужно запускать асинхронно даже если изначально он должен не должен был запускаться таким образом прежде всего нам нужно понять что именно означает асинхронная обработка это своего рода конструкция для вычислительных задач выполняющая их без каких-либо зависимости друг от друга каждая задача уникальна и последовательность выполнения не гарантирует одинаковый порядок доставки результат когда мы примеру запускаем сервер у нас такое же поведение при обслуживании веб-страниц для пользователя браузера чтобы это произошло как на текущем изображении нам нужно чтобы fpm выполнял как минимум 4 процесса если мы посмотрим в рамках одного процесса то Увидим что каждая задача ставится в очередь выполняется одна за другой но возможно ли чтобы один процесс выполнял несколько задач параллельно как на данном изображении если задача делать какой-нибудь внешне запрос например и какое-то время ждет результата мы можем оставить ссылку открытой и выполнить задачу В течение времени ожидания когда задача B имеет такой же внешний запрос программа может проверить готов ли уже результат для запросов задачи А и вернуть его пользователю а затем продолжить выполнение задачи Наверное я вас запутал лучший способ объяснить Это запрограммировать реализация на PHP может быть сложной но возможно например запрос хранилища данных может быть реализовано не как запрос базе данных а как постановка задачи очередь с последующей проверкой по заданной ссылке Если же есть результат реальные запросы данных могут выполняться каким-либо фондом рабочим процессом или заданием нам может понадобиться обновить пользователь ожидающего результата с некоторыми абстрактными значениями о том Чего ожидать когда результат будет доставлен это можно сделать через невыполнимая обработчик объекта который пользователь получит до того это может помочь начать рендеринг уже на интерфейсе это очень распространенное решение используемое на фронтенде и здесь нам поможет концепция популярный пример промесов в реальной жизни это заказ в известном ресторане быстрого питания часть терминал самообслуживания вы выбираете свой любимый гамбургер а затем система выдает вам билет с номера который точно описывает что получите после того Если вы разработчик транскрипт Вы должны быть знаком с этой концепцией и достаточно хорошо по сути промесы это прокси для результата который может быть еще неизвестен на момент создания промеса Обычно он может иметь одну из следующих состояний ожидания которое является начальным состоянием выполнена когда операция завершилась успешно или отклонено когда операции не удалась Если вы используете пример тайпскрипт Вы даже можете предоставить интерфейс и летим значение функции когда она будет выполнена Но если вы используете PHP настоящее время это не доступно из коробки в данном листинге Я очень просто описал концепцию промеса он реализует интерфейс с тремя методами разрешить Отклонить или получить значение результата После выполнения к счастью это достаточно реальная реализация у нас она может остаться практиком всегда потому что среда ряд PHP уже предоставляет отличную библиотеку реализующую опцию концепцию Я рекомендую вам с ней ознакомиться более подробно любопытнее и любопытнее сосредоточимся на недостающих элементах необходимы для реализации решения описанного на данном изображении учитывая что на этом изображении запущен только один php-процесс следующая задача выполнить вторую задачу В течение времени ожидания ответа от хранилища данных здесь мы и готовы следовать или цикл событий это концепция хорошо известна в мире но Джес цикл обработки событий один из самых важных аспектов которые нужно понимать цикл событий Постоянно работает проверяя есть а на данном изображении изображена изображен цикл событий и он применяется упомянутым ранее решение существующий пол задач который может обрабатывать функции и пулпромиссов обрабатывая ссылки и соответствующие промисы которые должны быть разрешены и сохранилище данных событий работает постоянно беря задачи и сохраняя созданный в том же цикле он проверяет результаты для разрешения сохраненных обещаний если бы мне нужно было реализации Я бы начал чего-то простого как примеру описано на данном а но Давайте скажем наверное еще раз спасибо такая базовая реализация не нужна нам и не нужно изобретать еще один велосипед вряд ли есть библиотека для цикла событий как и в предыдущем примере цикл обработки событий выполняется в одном потоке но с использованием такта таймера для синхронного программирования и выполнение всех задач и событий как и javascrip 5 реализует модель параллелизма полностью основана на цикле событий чтобы использовать цикл обработки событий в приложении необходимо создать один экземпляр использовать его для добавления таймеров Вот и в конце кода приложения цикла обработки событий должен быть запущен ряд PHP поддерживает несколько реализаций циклов Некоторые из них требуют установки дополнительных расширения PHP о которых я говорил ранее но тем не менее есть Стрим Селект и он используется как запасной вариант если Нет доступных конкурентных решений Скажите пожалуйста куда мне отсюда идти и наконец мы приступаем к самому интересному файберы Это новая возможность для синхронного PHP что же такое файберы Я думаю что документация Ruby хорошо описывает что такой файберы файберы Это примитив для реализации облегченного кооперативного параллелизма по сути они являются средством создания блоков кода которые можно приостанавливать или возобновлять подобно потоком основное отличие состоит в том что они никогда не вытесняются и планирование должно выполняться программистом а не виртуальной машины принесли ли в действительности файберы асинхронность нет а может быть это пожалуй Одно из самых распространенных заблуждений о файберах а также толк где все становится сложнее Так что выслушать у меня файберы предоставляют собой низкоуровневую конструкцию они позволяют создавать синхронные функции таким образом чтобы их можно было приостанавливать и возобновлять человек разрабатывающий эту функцию должен определить где эта функция может быть приостановлена и Какое событие она ожидает чтобы возобновить волнение сами файберы не выполнены не планируют эти выполнения но они позволяют дополнительного планировщику возобновить любой реалистичной среде это будет обрабатываться с помощью контлупа реализующего шаблон сам файбер не предоставляет такой цикл обработки событий и я это считаю очень хорошие вещи Это означает что вам все равно придется использовать ряд PHP sull или MP для предоставления модели асинхронного выполнения или для создания чего-либо что может выполниться одновременно Это означает что с вайберами или без них асинхронной PHP будет представляться внешними библиотеками Однако в то же время файберы могут использовать асинхронные PHP в большом количестве проектов с точки зрения среднего разработчика Они вообще никогда не будут взаимодействовать с вайберами файберы можно использовать как реализацию библиотека чтобы асинхронные функции выглядели точно так же как синхронно но с помощью могли выполнять что-то асинхронное внутри Это означает что есть шанс что в будущем Мы увидим больше асинхронных реализаций потому что они более легко интегрируются синхронной среды Нужны ли нам файберы нет как и говорил я в предыдущем разделе Нам нужен планировщик или Эван клуб чтобы запускать вещи асинхронно или параллельно это также означает что все равно придется использовать что-то Вроде предоставляться файберы это один из возможных строительных блоков для синхронного приложения Как конструктор еще не выдержали испытание временем тем не менее Мы видим что файберы могут навсегда изменить ландшафты и возможно лучше какую же проблему решают файберы файберы отвечают на вопрос Какого цвета ваша функция если коротко это если ваша каждая функциями на колбек или обычная функция с именем является или красной это асинхронный или синий Это синхронный Короче говоря это означает что во многих языках есть различия между синхронными и асинхронными функциями что еще хуже при использовании любой асинхронной функции весь стек вызовов также становится синхронно до дольше синхронные функции возвращают результат асинхронный нет замена не вызывает колбэк синхронные функции выдают результат как возвращаемое значение асинхронные выдают его вызывая кэлбэк который вы им передали вы не можете вызывать асинхронную функцию и синхронной потому что вы не сможете узнать результат пока синхронная функция не выполнится позже Да здесь указано достаточно длинный пост но вы можете прочитать его чтобы полностью понять проблему Ну и далее чтобы увидеть это на практике Давайте взглянем на некоторые код для отправки запроса в синхронном коде отправка httive запросы могут выглядеть примерно так но чтобы предоставить возможность возвращаемое значение вызова синхронной функции многие языковые среды используют некоторые языки предоставляют струнные реализацию кроме других языках Это обычно реализуется пространстве пользователя в печки это обеспечивается при помощи вот тот же пример с использованием для отправки проекты на основе промисов обеспечивают мощный и разумный интерфейс для работы с асинхронными ответами в то же время мы понимаем что этот пример может выглядеть сложнее чем вот традиционная синхронный аналог в частности при использовании асинхронной пэч весь наш чек User метод также стал асинхронным и должен возвращать именно промес это в свою очередь напрямую влияет на то как основное приложение использует этот метод но здесь в игру у нас вступают корутины это блоки квода который работает асинхронно то есть по очереди в нужный момент исполнения такого блока приостанавливается сохранение всех его свойств чтобы запустить другой код когда управление возвращается к первому блоку он продолжает работу Некоторые предпочитают реализовывать картины с помощью генератора чтобы тот же поток управления больше походил на асинхронных код среди прочего Вы можете найти это при комбинировании реакции или при использовании здесь доступ к асинхронному возвращаемому значению теперь безусловно выглядит намного проще Однако мы видим что теперь для этого требуется обернуть это функцию генератор Кроме того Теперь нужно реализация корутины на основе генератора предоставляющая оси которая подключается оператору и управляет потоком управления для наших Это означает что мы имеем дело скроемся к счастью Здесь нам могут прийти на помощь хайберы это выглядит красиво правда на самом деле с файберами вы больше не увидите что вы за функции вообще асинхронно файберы позволяют вам выразить синхронный поток программы поэтому вам вообще не нужно иметь дело с каким-либо асинхронным выполнением интересно что это также означает что средний разработчик приложения Вообще никогда не будет взаимодействия с фабриолизацией Я считаю это огромным плюсом файберы представляют собой строительный блок для создания функций которые можно использовать в синхронной или асинхронной среде без изменений их внутренняя работа скрывает тот факт что другие функции могут выполняться асинхронно с помощью файберы можно использовать как в синхронное так и в асинхронных средах без использования промежуточных адаптеров Это означает что у нас будет шанс увидеть асинхронной реализации потому что они более легко интегрируются именно синхронные среды Однако это немножко наверно некорректно страниц кроме сами приведем приведенный пример выглядит полностью синхронным но на самом деле потому что действительно синхроним чтобы провести справедливое сравнение с файберами и кроме сами Нам действительно нужно Взглянуть на пример который отправляет параллельный запрос Как выглядит параллелизм в реальных приложениях опять же Давайте возьмем наш предыдущий пример и проверки одного и мы проверяем 2 Извините это в нашем электронном примере не так уж сложно теперь предположим что первая служба всегда занимает одну секунду а вторая всегда занимает 2 секунды выполнение этого занимает в общей сложности 3 секунды легко понять почему каждый вызов происходит один за другим Так что время суммируется точно так же мы можем изменить наш предыдущий пример промеса чтобы получить данные из двух запросов Мы видим что добавление это 2 вызова не сильно изменилась структуру кроме будут выполняться фоновом режиме по умолчанию и мы можем просто дождаться обеих результатов используя All Теперь снова предполагая что первая служба занимает одну секунду а вторая всегда занимает 2 секунды выполнение этого займет всего 200 секунды внутри промеса все разрешается с помощью асинхронного это происходит одновременно Поэтому нам нужно дождаться завершения самого медленного из них Ну и Точно также мы можем посмотреть на переделанный код короче Мы видим что добавление это второй вызова снова не сильно изменилась структуру но также это что он начинает очень походить на предыдущий пример кроме с использованием на самом деле это не так уж удивительно учитывая что это реализация корутины будет построена поверхность Именно поэтому и по моему опыту реализации карантина обычно не приносит большой пользы многим реально приложения и теперь получается снова предполагаю что первая служба занимает одну секунду вторая занимает 2 секунды и выполнение этого снова займет 2 секунды а давайте посмотрим как выглядит наш предыдущий пример с вайберами Если изменить его на выборку из двух запросов Подождите минутку разве фаберли не должны упрощать асинхронность что-то вроде но на самом деле это не то что касается особенно помогают избежать вопросы Какого цвета ваша функция это не волшебство сами фаберли не решают проблему одновременно выполнения файберы позволяют выразить синхронный поток в тот момент когда мы хотим выразить асинхронный поток управления нам все равно придется прибегать в этом примере нам нужно использовать две функции предоставляемые нашей асинхронной библиотекой функция Осин превращает функцию на основе файберов кроме которая будет выполняться в фоновом режиме eaweight функция которая указывает Event loop выполняться до тех пор пока он не сможет вернуться к вашему синхронному потоку это assing функция выглядит как волшебство Похоже она может превратить Любую синхронную функцию асинхронную Однако К сожалению это работает только с функциями которые используют файбер который внутри инспектирует проблема Проблема в том что вы больше не можете сказать можно ли вообще использовать эту функцию в асинхронном контексте с тем же успехом он может Заблокировать все ваши не блокирующее приложение и вы не сможете узнать об этом заранее файберы устранили различия между синхронными асинхронными функциями и то что начиналось Хорошая идея означает что теперь Вы упускаете важную информацию и ваш Единственный шанс проверить документацию для каждой функции которую вы хотите использовать асинхронно как в предыдущих примерах в примере с файберами оба наших запроса будут занимать всего две секунды так как нужно будет дождаться самого медленного больше вопросов чем ответов Что же это означает для будущего промисов кроме куда не денутся но возможно мы будем видеть их намного реже с вайберами мы можем видеть как потребителям не нужно использовать промисы для многих распространенных случаев использования Я считаю что хорошо потому что это может сделать многие из более простых вариантов использования намного менее сложные всякий раз когда вы хотите одновременно выполнять несколько функций он все равно придется использовать асинхронные примитивы Это означает что кроме останутся жизнеспособным вариантом для асинхронных программных потоков как и сегодня это не то что файберы сделают устаревшее Что же это означает для карутин корутины на основе генератора иногда могут быть полезны хотите Взглянуть на мой Хрустальный как только файберы станут использования скорее всего сойдет и картины больше не потребуется как же насчет Осинка воид на самом деле способ которым многие языки решили предоставить нативный асинкай привели бы к основному вопросу Какого цвета ваша функция решение которого нацелены файберы Это означает что вероятность того что мы увидим эти ключевые слова таким образом снижается в приведенных примерах используются которые могут предоставляться выбранными вашими библиотекой Лично я по-прежнему вижу большую ценность в том что эти базовые строительные блоки были частью самого языка Таким образом мы потенциально могли бы обеспечить широкое взаимодействие между различными асинхронными платформами но в то же время эти реализации имеют гораздо больший размах хорошей новостью является то что мы начинаем видеть больше взаимодействия между этими реализациями да и вообще эта тема наверное для отдельного разговора Должен ли пить файберы Я думаю что файберы это достаточно интересные делают того что кажется большинство людей я первый признают что фабиз звучит великолепно и очень сложно описать нюанс файберы кажется обещает что мы увидим нативные асинхронный PHP а на самом деле они отлично справляется с решением вопроса Какого цвета ваша функция Это означает что есть шанс что будущее мы увидим больше потому что они более легко интегрируются тем не менее это первая реализация параллельно совместимости совместной многозадачности и я думаю что это отличное начало совершенно нового пути для PHP в мире асинхронность Если бы это было так это бы еще ничего если бы конечно оно так и было но так как это не так так оно не это Такова логика вещей Всем спасибо да это мои контакты пишите Подписывайтесь ставьте лайки Спасибо теперь можно задать вопросы"
}