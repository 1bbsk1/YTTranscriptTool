{
  "video_id": "AqeKHDKJ4To",
  "channel": "HighLoadChannel",
  "title": "Kotlin Perfomance on Android / Александр Смирнов (Splyt)",
  "views": 1915,
  "duration": 2548,
  "published": "2018-01-16T12:32:07-08:00",
  "text": "Что окей Меня зовут Александр Смирнов Я хочу с вами поговорить сегодня о перформансе котлина в продакшене на Андроиде кто-то из вас читал статьи на эту тему либо смотрел чьё-либо выступление про перформанс не про котлин а именно про performance его на Джаве либо на Андроиде Нет окей огонь потому что я просто сейчас увидел что ребята на хаб там написали одну статью в принципе они всё рассказали всё то же самое что там когда ты делал доклад напоите митрий дров и Jet brains Ну как бы там не про Android там про jav то есть там про Android не было проч ничего а пару слов обо мне Я работаю в компании Split На позиции Head of Android Я работаю Android разработчиком примерно с 2012 года я не помню LinkedIn так говорит А я веду видеоблог Android в лицах на юту в телеграме Вы можете найти мой видеоблог мой Telegram канал если напишете Android In Face из пробелов и также я организатор сообщества один из орни Android разработк в Москве мы 24 июня делаем в санкт-петербурге если тут кто-то есть из санктпетербурга или хочет поехать то тоже самое рекомендую зайти на канал дальше Вы перейдёте на другой чат и там можно будет поговорить либо там с кем-то поехать сразу в Питер вот будет весело сразу начнём с того как вы считаете вот есть работа Ja Как вы считаете котлин медленнее чем Java выполняется в фрон тайме или нет Давайте я всё время буду поднимать руки есть такие кто считают что котлин медленнее джавы в ран тайме Нет все считают что А есть один человек всё все стесняются Окей хорошо А кто считает что они одинаково выполняются быстро Ну код же один и тот же я тоже считаю что должны одинаково выполняться А кто есть кто считает что быстрее Вообще никого вы так не верите в Хорошо давайте ещ такой вопрос а кто пишет на котлине в прок два человека а кто пробовал писать на котлине что-то для себя там в проектах или смотрел а остальные не пробовали так правильно понимаю Хорошо Кто ничего не слышал про котлин или ничего не знает про него то есть не пробовал ничего хорошо таких нет будем тогда более это е говори без Берков то как бы что тебя слушать поэтому на Андроиде так как у нас нет у нас нет ну Лёша ЛВ не написал с другими ребятами мы не можем Всё такро замерить Круто как это можно сделать на Джаве у нас всё плохо так что нам остаётся делать такой зари коливо кто-то вот из разработчиков jmh будет грустить и будет плакать и приходить вам с ней никогда так не делайте поэтому на Андроиде можно делать бенчмарки в частности Google продемонстрировал это когда на последнем АО он говорил про performance они говорили что они очень сильно улучшили виртуальную машину в данном случае Ар И говорили что раньше там на Android 4.1 одна локация объекта занимала у них примерно 600-700 миллисекунд сейчас в последнем восьмой будет занимать порядка кун я вру наносекунд что-то я много сказал Да 600 700 наносекунд сейчас 60 То есть если они могут сказать что они с такой точность это замерили они замерили это на Андроиде на виртуальной машине почему мы не можем не гдето сделать У нас нет таких инструментов если мы посмотрим всю документацию то единственно Что они говорят ребята ну вот если вы мерите мерите мерите это вот так берите делаете ssf соно Давайте так и сделаем посмотрим в кон что но сво буде Какие вещи мы можем сделать Следующий вопрос А где вы считаете где важен перфоманс Когда вы делаете свое приложение Вот кто считает что у вас однозначно везде в любом потоке важно чтобы вы э абсолютно быстро выполнялись есть есть Да я вообще на самом деле считаю что это тоже так если бы так будет там у меня всё будет выполняться очень быстро я буду очень рад а но Кто считает что невозможно сделать так чтобы весь код зарабатывал очень-очень быстро и важно чтобы вот у вас тред просто не лагал и всё было очень круто так тах людей большинство есть такие считают Ну блин говорит что можно в базу писать и можно с неё считать как бы нормально може просто важно чтобы c анимации не лагали всё было очень круто есть такие кто считает Ну ладно анимации Окей вот тоже Согласен полностью Я согласен что вот и это очень-очень важно то чтот будет Дже сончик разбираться реализоваться то как бы ну какая разница это никто не заметит если посмотреть на то что говорил шталь психология и то как долго занимают люди когда Как долго люди не видят чего-то когда они моргают то грубо говоря я моргнул и примерно 150-300 миллисекунд мой глаз был не в фокусе То есть я не видел что там собственно чётко происходит Я что-то видел но не так чтобы очень чётко и как бы мне те 10 миллисекунд особой погоды не делают но если мы опять-таки вем ль психологии важно не что я реально вижу или что реально происходит важно то что я понимаю как пользователь То есть если мы сделаем так чтобы пользователь думал что у него всё очень-очень быстро а на самом деле это просто будет красиво обыграло как-то в какую-то красивую анимацию то он будет думать что вау Incredible очень-очень быстро всё А на самом деле это не так собственно вот на если сравнить подходы то мотивы шталь психологии в iOS продвигались Достаточно давно поэтому многие Ну если взять два приложения положить их рядо не будут занимать времени выполнения всё обработки одинаковое время Но люди будут говорить что на быстрее потому что там анимация обрабатывает немножко быстрее и потому что там раньше начинает показ спине лоров показ там многих других вещей анимаций таких так чтобы это было красиво Первое правило думать о пользователе второе правило можно погрузиться в хардкор если мы будем говорить про котн и мерить его давайте помери это с точки зрения сравнения с двой а поэтому нельзя получается померить некоторые вещи которые есть только в котлине например Collection API А почему Потому что API коллекции который нам предоставляет котлин он очень классный и он очень быстрый Если вы попытаетесь сравнить с чем-то в Джаве ну такого просто нет А есть только разные реализации Я им говорю сейчас про Java 6 либо Java 7 есть разные реализации которые нам предоставляют Ну например библиотека White Way Stream IP Но если вы хотите сравнить Ну она будет медленнее потому что она делает всё тоже самое что Cot только она делает плюс ещё там одну или две локации на операцию в том плане что она оборачивается это всё я уж Правда не помню В какой объект Ну грубо говоря в что-то типа sequence скажем так а всё то же самое но плюс она оборачивать од объекта то есть плюс одна локация если мы возьмём parel API который нам приходит Java 8 то или Stream API то он будет работать медленнее чем Collection API от cotl но за одном условие Collection API палии такой кото есть Java 8 если мы включаем на больших обх данных пор всех остальных случаях будет быстрый и быстрее работать поэтому я не могу говорить что вот стоит их мерить как-то потому что это мы сравниваем с точки зрения Анда вторая вещь которую можно нельзя сравнивать как мне кажется очень классная шка кто не когда Когда вы вызываете какой-то метод у него может быть какие-то параметры которые могут принимать значения точнее их а могут быть нам А и поэтому вы не делаете 10 разных методов с допустим которые принимают 10 параметров и 11 или все они нулы а а делаете один метод вы говорите что один из параметров может быть на и в дальнейшем Вы можете использовать эту же функцию без какого-либо параметра То есть он будет смотреть пришёл этот параметр либо не пришёл очень удобно в том плане что вам нужно писать меньше кода намного но неудобство заключается в том что за это приходится платить то есть получается синтаксический сахар предоставляет вас это вы считаете как разработчик По своему опыту что это один метод а в реальности под капотом вде Если Вы посмотрите он получается Гене Кроме того что вот этот метод он генерирует ещё кучу других каждый получается с каждый метод у которого какие-то из Парат ри в этом методе проверяет получается по битово если пришёл ли этот параметр если он пришёл то Ок если не пришёл дальше Составляем битовую маску и в зависимости от этой битовой маски уже вызовет собственно самый главный тут изначальный параметр изначальный метод который вы написали а побитовые операции и вот эти все If els они стоят чуть-чуть денег Но это всё очень-очень мало Ну как бы это нормально Что за такое удобство Вам приходится чуть-чуть заплатить нельзя сказать что это там плохо отколе и мне кажется это абсолютно нормально а кто пользуется дата классами а а я не пользуюсь вот ну короче смысл заключается в том что такое дата класс и все плачется что в Джаве есть параметры и в которых есть классы модельные например в которых вы берёте как параметры и делаете ещё методы Гетеры и сетера для всех этих параметров генерить и получается что у вас класс в котором как бы ну 10 параметров надо было быть и ещё такая вот портянка их геров сеттеров ещё куча всего и вам это ещё если вы не пользуетесь генераторами кода вам ещё всё это приходится руками писать как бы это вообще ужасно А котлин позволяет от всего это уйти во-первых так как у него есть свойства вам не нужно писать Get серы у него нет параметров класса у него все свойства во всяком случае мы так думаем наш экспириенс как девелоперов такой во-вторых Если вы напишите что это Data клас он ещё скуча сгенерить за вас всего остального например там equals to string шкод Ну грубо говоря в чём тут плохо А если например мне не нужно было чтобы у меня в equ сравнивались в моём большом дата классе 20 параметров сразу которые достаточно большие там какие-то объекты другие у них там тоже вызывается Мне нужно было сравнить три а он сравнит все 20 то как бы получается что я на этом тоже потеряю Что это там небольшой фомас Мне он сгенерить кучуров там или геров А мне допустим этого не надо было никогда И тут кому-то это не нравится потому что и Кроме того что Гене ещё куча там служебных вещей и получается так что код ээ который скомпилировать достаточно большой То есть если вы напишете это всё руками будет меньше чем Если вы это всё Используйте Data CL Я не использую по другой причине там были раньше ограничения что их нельзя было там расширять там куча других вещей сейчас с этим всём лучше но как-то привычка А что очень-очень классно в котлине и на чём он всег ну будет быстрее чем Java А это rifi types который тоже кстати есть в дарте а-а предыдущий доклад просто был про дар немного Я иногда вспоминаю так вот смысл заключается в том что вот есть дженерики когда все знаете что что когда вы используете genic когда он короче есть это только в этапе компиляции на э компиляции происходит стирание типов typ и в ран тайме вы уже не знаете собственно это Какой объект вот этого дженерика грубо говоря у вас это всё в об выходит с типами всё получается так что вам не нужно использовать рефлексию для многих местах Когда в Джаве вам это нужно потому чтот Илай методов и именной он получается не это не стирает А за счёт того что он это инлайт происходит такая классная вещь как тип остаётся знание о нём И поэтому получается что вы не используете рефлексию и ваш код становит Работать быстрее магия и есть ещё корутины как я говорил точнее упоминал немножко раньше в предыдущем докладе корутины зарезали они очень классные они очень мне нравятся но так как это Альфа что-то с ними мерять они вошли о1 но они не зарезали именно Как сами по себе то есть спецификация их написана на толь как на Альфе и она может ещё изменяться То есть вы можете сейчас думать что вот всё будет Вот так А через полгода это будет совершенно другой II всё будет работать совершенно по-другому и как бы зачем об этом говорить поэтому пойдём дальше Собственно как я сказал в предыдущих вещах перейдём практически к тому что мы можем замерить с двой и вообще на что мы можем повлиять А как я сказал в предыдущем 2 минуты назад нес нет Э параметров класса У нас есть свойства Кто не знает что здесь написано кому пояснить все знают все котлин уже так хорошо выучили потому что особенно после А было так много докладов начального уровня что я думал что всем надоело но хорошо что все знают Это очень круто когда проще будет понимать Окей У нас есть Вар У нас есть вал все мы знаем что происходит работа у нас есть внешний класс один одно из свойств этого класса тоже и мы собственно будем смотреть что собственно происходит у нас с функцией Work У нас есть два обращения мы суммируем значение поля А и поля B собственного класса и значение поля А и поля B внешнего класса который у нас че записан в неизменяемое в поле C так вот все мы знаем что это свойство вопрос заключается в чём Да хорошо что собственно будет вызвано в D все мы знаем что это с раз свойства то будет вызвано методы Get этого класса то есть для этого параметра так как изменяется это представление идт либо Get либо но если мы посмотрим сейчас уже что происходит под капотом так я открыл байд вы увидите что в реальности происходит обращение getfield То есть это в байде происходит не вызов inv Vir функции А вызов именно на прямое обращение к функции полю Точнее к параметру правильном было сказано нам изначально что у нас идут свойства А не вот да фиды Поля вот так получается что нас котлин обманывает есть прямое обращение Что будет если мы всё-таки посмотрим какой байт код гери для другой строки и в данном случае Блин опять открыл я слайд поспешил не получилось похавать с вами Да срываем маски сразу есть Fi аннотация она влияет на что она влияет на то что собственно внешнем раньше получалось было как ко всем полям когда свойствам Вы обращались Если это было не приватное свойство то у вас всегда был вызов inv Virtual если это было приватное свойство то к нему было обращение через getfield getfield отрабатывает намного быстрее чем invoke Virtual Потому что если вы даже почитаете performance спецификации от андроидам работать от х до се раз быстрее обращениями напрямую к фиду поэтому дут всегда обращаться к феода а не через Гетеры либо сеттеры а так было раньше я более чем уверен что сейчас ну особенно если Вы посмотрите то что было заявлено что будет восьмой а-а в восьмом Андроиде восьмом Арт виртуальной машине там куча оптимизации сделали то будет уже другие числа Но если вы поддерживаете ещё 41 там это будет верно А поэтому получается вам всё-таки выгодно чтобы вот было getfield а не invoke Virtual Как можно сейчас добиться сейчас можно добиться это если вы обращаетесь к свойству приват свойству собственного класса либо если это публичное свойство ему необходимо поставить аннотацию gmi тогда всё точно также будет вызов вде getfield который там 37 раз быстрее но понятно что так как у нас числа очень-очень маленькие это мы говорим в наносекундах то вы миллисекундах заметь например обращаетесь к другому классу за каким-то им публичным например даже в методе on какой-то ВХ обращаетесь к свойству другого класса то у вас это уже на каждом отрисовке каждого кадра будет сказываться и вы можете таким образом сделать немножко быстрее если сложить все оптимизации то это Может что-то и дать Окей что со статика все мы знаем что в котлине статики - это вот КОО обк если вы раньше использовали вот класс в котором наверняка было какой-то там Ну не знаю г например Public Static Final Static там string какой-то тег то вы после того как даже сконвертируйте ну это идентично Static Final допустим запись Ну допустим здесь не Final А всё-таки статическая это вот это вот правильный Статик или нет Кто считает что это правильный Статик Окей это вообще Статик или нет Окей все стесняются есть кто-то кто кому кто не понимает Ага Окей смысл заключается в чём Да действительно котлин заявляет что вот это вот в котле не Статик что об Это говорит о том что это Статик в реальности это не Статик если мы посмотрим на байд который мы Гене получится такая веь что он генерирует онгнет объект у которого делает instance записывает этот instance в собственное в поле которое он создаёт класса И после этого Когда вы обращаетесь к чему-то из Компаньон обк что лежит он обращается через этот э объект компаньонов ский То есть он дёргает Если Вы посмотрите берёт Get Static то есть берёт статический instance этого класса и вызывает у него inwork Virtual функцию Get K как раз мы говорили как э свойства берёт его и точно также делает Get Static и inv Virtual Work 2 Функции естественно Точно также мы получаем Так что это не Статик почему это важно по той причине что каждый вызов Vir он примерно на старых было так сейчас уже на хотспоте это оптимизировано виртуализации происходит Очень круто и это вообще практически незаметно нать 8.0 получалось так что inv Статик был примерно на 30% быстрее чем invoke Virtual вызов Это точно так же с оптимизация на спичках но как бы это есть а и получается так что у нас тут ещё есть лишняя локация а лишняя локация на 41 - это 700 миллисекунд наносекунд как бы тоже много практически миллисекунда А если мы посмотрим на Java код который мы можем получить если А обратно развернёт код то получается собственно такая запись Когда он берёт делает статическое поле кстати Ну Придётся делать статически реализацию причём объекта этого компаньонов ского делают у него Гетеры и серы при обращает причём к статическому полю внутри и всё как вы можете увидеть Всё достаточно грустно причём тический метод ещё один делает Ну окей мы поняли что это неста что можем сделать можем пова по смотреть что получится сразу скажу что GM Static вы никак не уйдёте это будет точно также объект так как это comp object лишняя локация этого объекта и будет в личний вызов Но единственное что он изменится он станет точнее изменится только у ш кашки потому что это будет Field он она напрямую будет браться уже не ложиться Get для неё не будет генерироваться она будет напрямую браться как Get ST а для Work 2 Функции которы Бут даже постати ничего не изменится что мы можем сделать ВТО навори документация что мы можем просто создать и это будет статический код какой-то в реальности это всё тоже не так у нас получается что мы делаем вызов тона который создаётся и вызываем точно такие же виртуальные методы единственный вариант как мы можем добиться именно это Order это когда мы просто пишем вне класса какую-то функцию вне ла статичная причём что самое интересное что это будет класс создан объект например в данном случае это тест КТ это он сам сгенерить объект у него сам сгенерить функцию положит эту функцию которую я написал в этот объект и Вот её дёрнется как inv Static Почему так было сделано непонятно многие этим недовольны кто-то говорит что типа не наоборот нормально Люди иногда Хали варят но кто-то говорит что будет менять кто-то Наоборот не хочет менять с точки зрения вот того что виртуальная машина даже Арто Андроидов ся улучшается это уже не настолько критично и восьмой версии точно так же как на хотспоте всё ЗАО Зро всё хорошо но когда вот у нас будет минус ДК 25 Ну это будет ещё очень нескоро поэтому чуть-чуть это будет ещё влиять следующая вещь интересная No ability Казалось бы ну мы помарка что вот Second может быть на его надо проверить Перед тем как мы с ним что-то будем делать да то есть вот в данном случае я ожидаю что вот у нас есть один If когда вот я вот этот код будет развёрнуты и типа если If Second не равен нулю то пойдём дальше иначе типа зайдём сюда и выведем только First А есть кто-то кто считает что тут будет не один и а там не знаю ноль либо два либо три никто не считает О'кей потому что на самом деле будет Проверка как это всё развернётся в Java CDE мы получим inic изначально Но сейчас спустим то что я говорил что вот этот вот If он перевернётся в ветеринарный оператор у нас будет проверка И как я сказал Но кроме этого так как мы Хотя даже помарка что у нас не может быть на строка Первый параметр он всё равно будет проверен через in in - это внутренний класс котлина который собственно у него есть некоторый набор параметров он проверок и каждый раз когда вы делаете в параметр метода небель он всё равно его проверяет Зачем Как можно мы сказали что по контракту он не может быть Затем что мы работаем в иром и может случиться Так что вы ожидаете что здесь не будет на но он с где-то прилетел Если вы него не проверили это пошло где-то дальше по коду и потом получится Так что у вас где-то в середине Где вы уже не работаете сво там не знаю через 10-20 вызовов методов прилетает вы делаете что-то с параметром который не может быть Нан оказывается на и у вас падает и вы не можете понять откуда собственно это прилетело Поэтому чтобы такой ситуации в каждый раз когда у вас происходит передача параметра у вас всё равно будет его проверка и если он будет на то будет Exception это стоит таже проверка денег и как бы если их много таких то всё тоже не очень хорошо Но на самом деле даже говорить на хотспоте то там по-моему 10 вызовов этих иксов будет стоить порядка 4 наносекунд То есть это вообще очень-очень мало И это не стоит но интересный факт есть такая веь как примитивы в Джаве в котлине как все есть объекты Да все вы знаете что в котлине Нет примитивов мы всегда оперируем с объектами но при этом в Джаве они есть как мы знаем они есть собственно для того чтобы обеспечить более высокую объектов на на каких-либо незначительных вычислениях потому что сложить два обекта Это намного дороже чем сложить прива здесь есть три числа первые два - это именно напрямую они будут небель потому что мы сразу говорим будет выведен для них для третьего мы сами говорим что он может быть как этот компилятор будет думать что является этот код если посмотреть над и посмотреть что он Какой jav код он генерирует он получится сделать так как первые два числа они буде Говори чтот При может содержать себе Нау это может быть только делать объект Поэтому он сгенерирует его в объект Ну собственно кстати ещё тоже что вот показано что вот делает integer W of 6 а Хорошая вещь авто боксинг Когда вы работаете с примитивами вроде бы понятно что если там вы делаете операцию с примитивами и не примитиво то какую-то из них либо надо будет або короче примитив привести либо в а сделать сразу в боксинг ему сделать в объект и Казалось бы вы сразу можете понять что если вы делаете операции с Прити в коне то вы тоже чуть-чуть теряете по перформанс причём если Эх операций много то вы теряете много но допустим в данной ситуации я бы ни за что не ожидал что может быть где-то здесь бонбон под кого есть какие-то варианты где может быть боксинг акн когда мы берём и просто в делаем которы именно примитив так он всегда у нас будет и этому буну мы прием Что делаем проверку если рка не пустая то типа то поставить тебе А если пустая то точнее Да Короче если ска либо непустая то у него будет если пустая то будет видит кто-то где здесь будет Бонн тоже Вика мнение если строка Now не Now если она пустая то установить тебе True А если иначе установить тебе fse вроде всё просто как типа Можно по-другому развернуть в реальности генерируется следующий код у нас получается B которому Давайте вернём самый внутрь то есть берётся ачка она касти в char sequence Вот это ачка передаётся после того как её закатили что тоже уже как бы время потратили вызывается другая проверка Strings CT Blend собственно это как extension функция для для записано поэтому оно Каси и отправляется после этого берётся так как это может быть Вот собственно говорится что это может быть Ну вот здесь как первое выражение может быть он берёт его и делает ка точнее боксинг получается оборачивается это всё в так как он понимает что первом выражение первой сти может Берт тоже боксит её делает её объектом И после этого уже проверяет что ну типа делает вызов ещё даже проверяет если не иначе типа и вызывает собственно виноват во всем вот этом вот этих во всех кастах вот э вот часть наб Кстати у нас же чтото есть вроде посветить да Ну ладно уже показал так Казалось бы такая простая операция блин такого нагели на самом деле таких вещей мало Работаете С связ Когда у вас может быть не этого может наге таких вещей достаточно много не самых однозначных и просто вот вы никогда бы не ожидали что там такое может быть но оно может появиться поэтому я Рекомендую вам как можно раньше уходить от не понятности то есть как можно раньше приходить к иммутабельность значений и уходить от чтобы вы как можно быстрее можно щепе следующая интересная вещь Вы можете использовать форы старые которые примитивный простой перебор который у нас есть в две но Вы точно также можете использовать новый более удобный API то есть вот сразу писать какому-то листу лист у нас в данном случае например R list писать ему for и переходить делать перебор его элементов Ну например вызывать функцию Work где и будет какой-то элемент этого листа каждый перебираемые умножать его на два там и делать какую-то работу а это на са То есть под капотом что там будет сне него будет вызван вот следующая функция так это другая функция Давайте сначала здесь расскажу смысл заключается в том что под капотом будет сгенерировано для него будет сгенерировано итератор и будет банальный перебор по итератор это нормально это много где рекомендуется но если мы посмотрим точно также спецификации документации Какие советы Google даёт нам когда вы работаете сфом с точки зрения фса только лишь для Элиста он говорит что перебор Элиста Когда вы делаете перебор не через итератор а просто перебор через for с значения от одного до сайза Он работает в три раза быстрее Когда вы это делаете не через итератор А в всех остальных случаях итератор будет работать идентично поэтому Если Вы точно уверены что у вас лист логично сделать другую вещь сделать другую написать свой for который предоставит Вам точно тот же API вам не нужно будет много менять Если вы увидите у вас тут здесь измена буковка е которая будет просто генерировать чуть-чуть другой код и вы не будете ничего тратить и Ко всё у вас останется точно так же здесь мы за используем всю мощь которая даёт нам котлин мы сделаем extens функцию которая будет Илай которая будет ref тип у неё мы ничего не будем стирать и ещё сделаем так что передадим ему нду которая Ронни поэтому всё везде ставится очень хорошо а всё будет с точки зрения того мы нигде ничего не продол просто вот этот кусок кода ставится в тот кусок кода где вы вызываете этот вызываете перебор и тот кусок кода который грубо говоря это ставится вот сюда вообще везде всё идеально всё отработает очень быстро в три раза быстрее как рекомендует нам спецификация Аида Гугла и Вызов будет Вот примерно также выглядеть то есть ничего не изменилось кроме буковки ется Если вы напишите подобным образом ре как я напомню Это делается через либо in две точки либо там дальше добавляется либо там ещё там Степы там вверх вниз расти Ну как генерировать от нуля там до скольки смысл заключается в чём это всё круто работает и вот вот этот случай когда вы просто делаете in и две точки оптимизирован одинаково то есть вот этот код и это будут идентично отработаны вде Но если вы попробуете сделать здесь либо мину о либо добавить либо там какой-либо степ там либо ещ что-то сделать то вы сразу получите то что у вас обратно будут итераторы и Кроме того что у вас будут итераторы у вас ещё будет локация для объекта который будет генерировать н То есть вы лоцируется изначальная точка с тапи которой берётся степ ставится и каждый вызов следующего Степа у вас будет вызов этого метода типа дай следу как бы нормально тоже но как бы про это стоит помнить Почему этом рассказываю в конце будет пример как я возьму jav код некоторый в этом ва коде сделаю Ну зарю что можно было сказано в начале после этого сделаю конвертирует jav в ковский после этого зап оп и точно так же как сделаю Три бенчмарка трх разных вариаций посмотрим какие цифры мы получим Дадут ли все вот эти оптимизации про которые я говорю какой-либо результат с точки зрения выполнения если мы вернёмся к инсам как было сказано здесь вот ещё один такой пример когда получается у нас делается уже два икса вызывается и для секонда и для ста мы их можно выключить Но их выключить в Ну короче можно сделать что ЕС вы Выделите толь то что вот очень важно вам даже вот эти вот каждые 4 миллисекунды ой наносекунды важны то вы можете сделать так чтобы отдельно сделать модуль котн с ЮА где Вы точно уверены что туда не может ничего попасть то что может быть на вы делаете там его нельзя добавить это опции в PL Но их можно передать именно напрямую кон компилятор Если вы передадите notion notion то это вырубит эти это вырубит как проверяющий параметры так и который проверяет результат если он может быть на ол там во многих местах а Ну на самом деле второй параметр Я не видел ни разу именно вызов этого трикса чтобы он Помог на Первый параметр но param assertion э вот собственно вырубает эти два трикса и всё работает очень хорошо А что ещё можно тут сказать Ну на самом деле это опасно с точки зрения того что если это сделать везде то получится не очень хорошо потому что приводит как му са говорил что может упасть там где вы не ожидаете А чему тех местах где вы действительно уверены в этом можно так сделать Многие считают что и серы Как написано в документации Илай прогар в прогар описании это написано но там ничего не Илай практически я бы сказал в 99% случаев вас метод который состоит из одной функции он не зайни 8.0 как раз тоже это оптимизировали и там уже с этим хоро ког Мы все будем на нём ещё какой вариант может быть это использовать кроме прогар ещ Еза от тоже Фейсбука называется она RX а они точно также говорят что они используют кучу оптимизации вашего байт кода который вы получаете Они инвайт они инлайт лучше Но точно также они не инлайт всё И точно также Get и они не инлайт то есть получается GM Field на данный момент единственно вариант Как уйти от для простых свойств Кроме этого они делают другие оптимизации в частности я взял создал простое примитивное приложение где абсолютно ничего там не писал никакого кода добавил Для него прогар он по вырезал всё что только можно было и получилось так что после этого провернул это приложение ещё через redex и получил мину 7% к весу АПК как мне кажется это достаточно нормально достаточно хорошо и интересно посмотреть возможно использовать это на продакшене перейдём собственно к бенчмарка я взял достаточно интересное приложение с точки зрения того что мне было бы удобно его меть потому что это приложение у которого есть много фреймов у него много анимаций по сути оно Берт и анимирует правую часть там есть точки есть линии и постоянно их перерисовываю это приложение написано было не так давно в конце мая я увидел его на арсенале е его написал Ярослав Халк со Львова парень и я делал бенчмарки на четырёх разных телефонах собственно я сделал и ку ку ку раз собирал эти данные после этого скриптами бал получить значение а я опубликую наверное завтра те скрипты и те данные что я замерил в на своём гитхабе SM и там будет собственно три варианта того кода что собственно было бенчмарка вось что собственно я получил это на устройстве Huawei достаточно не очень старым китайцем но достаточно слабенько 1,2 ГГц 1 гибче ядра 1 ГГц 1 ГБУ и 442 получилось так что есть три значения фиолетовой - это минимальный вариант одного кадра максимальный всегда он прыгал по-разному а медиана она была а не очень особо раскидывалась то есть там буквально погрешность медианы была а порядка четырёх сотых миллисекунды обычно и получается есть средняя мин - это зелёный и синий - Это медиана получается так что с этого бенчмарка ну графика достаточно сложно понять Поэтому я всё-таки решил показывать Это цифрами Если Вы посмотрите то получалось так что после того как мы переходили просто на котлин мы получали немножечко больше А времени на кадр если после того как мы производили все оптимизации мы получали э тут буквально чается в режиме погрешности но уходили почему-то получилось что медиана в котле не оптимизировано ом Даже лучше чем у джавы Но если посмотреть среднее получалось так что он лучше было чем просто генерировать оптимизации Ну посмотреть на четырёх платформах всегда получается была примерно похожая схема получается что они действительно помогали и приводили тому что коленовский код Он практически всегда работает также как джавс но иногда мы можете он чуть-чуть даёт за особенности того что он немного по-другому устроен немного другие абстракции Они немного дают охеда Но если вы захотите вы всегда сможете по оптимизировать так чтобы у вас был практически идентичная скорость работы Здесь точно также это другой китаец устройство и примерные цифры что получается немного рост и в дальнейшем уходим обратно практически тем же параметрам цифрам которые были на Джаве а всем хорошо видно цифры или их слух прозвучать хорошо видно отлично Ну собственно точно так же почему-то кстати ещё о особенность почему-то на котлино ских беч марках всегда показывало Так что минимально время на рисовку самого маленькое время на рисовку одного кадра уменьшалось то есть становилось даже лучше Но в среднем Вот получался либо небольшой рост либо точно тоже время в данном случае Samsung Galaxy S6 у него очень большое разрешение поэтому на удивление какого-то китайца с маленьким разрешением получается времени на рисовку одного кадра уходило намного намного меньше Ну практически в два раза меньше чем у крутого Galaxy S6 там сво ядер 21 и 1.5 седьмой версия Аида но при этом полу 2 924 Ладно собственно Ну тут точно также видно что оптимизации помогли почему-то кстати Даже при училось Так что тут наоборот единственный кого у Самсунга получился мин меньше чем медиана у всех остальных получалось обратно и это чма на пикселе который я сделал получилось так что А ну тут вообще практически получилось вообще без разницы всё то есть Всё в пределах од 1 миллисекунды как бы понятно хорошо за оптимизировали систему вроде дальше ещё лучше должны сделать будем ещё более довольны Ну и на того чтобы подвести итог Я бы хотел сказать что быт действие важно оно действительно важно только на потоке как мне кажется в и на кастомных ВХ очень критично Старайтесь избежать там от всех авто боксинг всех not Now параметров Чтобы вот не продол вот это всё времени там где вы не ожидаете Вы практически всегда можете написать на котле с идентичной скоростью работы в некоторых местах даже может получиться чисто Вот это просто очень круто Ну и да преждевременная оптимизация зло всё то что я сделал как бы могло затратить у вас очень много времени вы могли там как многие считать вот типа надо писать есть у меня просто такие друзья которые там тоже Android разработчики Но они там не очень не любят там RX очень не любят кон очень не любят кучу других вещей потому что считают что это там очень-очень плохо с точки зрения производительности Ну и в частности вот всей работы что я здесь проделал мне получилось Получилось представить доказательство грубо говоря того что тотли никак на это не влияет И можно без проблем Это использовать в продакшене никаких проблем с этим не будет Поэтому да прежде времени оптимизации зло Не тратьте время там где могли бы его не тратить Спасибо за доклад Спасибо за ваше внимание есть у кого-то вопросы О'кей А кто понял о чём я говорил о много людей Окей Ну хорошо Если у вас Бут ещ А есть да спасибо за доклад очень интересно познавательно Вот вы говорили про о том что там нельзя какой-то Кать разве нельзя просто там зать можно но зачем это делать ЕС Я говорил с точки зрения то что нельзя было зать об другого то есть Ну можно сказать грубо говоря сделать родительский дочерний класс то раньше нельзя было Дак чтобы они экстен друг друга Вот собственно что я говорил а переопределить метод вы можете как бы но как бы Зачем м для этого использовать дала а ну и поэтому получается уже тоже что это по большей части будет не Дак потому что он собственно создан Для того чтобы всё генерить ну устройство дата класса внутри оно как-то отличается Нет это точно такой же класс у которого проге ы у которых генерируются вот эти все которые было названы и плюс несколько ещё синтетических для внутренне Ну служебных вещей Ну и метаданные которые у любого ко кот лиско класс есть то есть абсолютно такой же класс Спасибо О'кей А спасибо за ваше внимание если у Вас будут вопросы я буду наверное на первом этаже сейчас и вы сможете мне подойти и дать любые ваши вопросы L"
}