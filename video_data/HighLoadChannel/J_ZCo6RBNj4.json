{
  "video_id": "J_ZCo6RBNj4",
  "channel": "HighLoadChannel",
  "title": "Анатомия конкурентного доступа к данным в PostgreSQL / Виктор Егоров (DataEgret)",
  "views": 6778,
  "duration": 2833,
  "published": "2018-11-20T12:21:43-08:00",
  "text": "меня зовут егоров виктор я это я да а и сегодня я бы хотел поговорить с вами о конкурентном доступе к данным именно на примере повзрослел мы с вами поговорим о конкуренции и о блокировках потому что а можно фон убрать потому что очень тяжело фанит микрофон о блокировках они идут вместе в конкуренции блокировки взаимосвязаны wear санирование и его особенности это основная тема доклада потому что по-русски это version ный движок далее мы обсудим блокировки при записи и поговорим о том как база читает данные в мульте version is среде и в конце поговорим о возможностях диагностирование которое предоставляет по сгрыз ну начнём с примера я долгое время проработал в европейском мобильном операторе и пару слов о том как устроен этот бизнес в телекоме очень сложно определить эффективность и эти и одним из критериев является то как быстро эти отдел может обеспечить доставку счетов своим клиентам после окончания расчетного периода счета подготавливает процесс который называется биллинг он обсчитывает все события которыми являются звонки сама если да то пакета и прочее эти события собирают сетевые элементы передают виде файлов в систему и дальше эти файлы обрабатываются процессом который называется рейтинг поскольку событий очень много рейтинг как правило запускает параллельно в несколько потоков и иначе мы не успеем к началу момент когда нужно запускать биллинг так вот в определенный момент я работал в службе эксплуатации бас к нам пришли ребята из поддержки одной из billing system и сказали что они запускают рейтинг в 10 потоков но у них все работает не так быстро как им бы хотелось и скорее всего проблема в базе данных пожалуйста посмотреть начинаем смотреть что там происходит действительно видим что все эти 10 потоков фактически в базе работают как один начинаем анализировать находим что существует узкое место то есть все 10 потоков почему то начинают конкурировать за одну и ту же запись в одной таблице выяснились с ребятами что же это за запись оказывается что это счет компании и каждое рейтинговое событие пытается изменить счет клиента и счет компании то есть эффективно все 10 потоков выстраиваются в такую дружную цепочку и ждут друг друга соответственно никаких 10 параллельных потоков у них не получается у них получается только один поток вот такой бутылочное горлышко они сами себе создали на резонный вопрос а что делать мы им отвечаем так делать не надо зачем вы пытаетесь изменить счет компании на каждое событием и тоже не бухгалтерская система ну на что получили ответ что это бизнес требование к сожалению ничего другого не сделать не могут тогда мы им посоветовали просто-напросто сделать несколько подсчитав и пустить каждый платок на свой подсчет а для отчетов которым это необходимо просто-напросто сводить информацию вместе и в принципе это нивелировала данную проблему но это один из многих примеров к сожалению подобной ситуации встречаются у наших клиентов очень часто в различных формах и возникает вопрос что ж с блокировки и зачем они нужны мы работаем с реляционной субд м и она нам обеспечивает ряд свойств которые описываются кронион и sit at a more ность целостность изоляции и долговечность данных в частности свойства атома рт насти обеспечивается транзакциями а свойства целостности изоляции обеспечивается блогерам блокировками в рамках этой транзакции которые обеспечивают то простой факт что пока одна транзакция работает с этими данными никакая другая не сможет влезть посередине и устроить какую-то кашу из данных они останутся целостными самый простой подход к реализации блокировок это 2 фазовой блокировки наверняка вы с ними сталкивались они подразумевают чтобы данным доступ обеспечивается на двух уровнях доступ на чтение это разделяемый доступ когда много параллельных клиентов могут пользоваться этим ресурсом и доступ на запись которая является эксклюзивным пока кто-то пытается изменить этот ресурс никакая другая параллельная активность с ресурсом не допускается и очевидно тут возникает большое противоречие пока кто-то пытается изменить этот ресурс никто в него не может даже прочитать это очень плохо для достижения нормальной конкуренции эта проблема ну-ка был возникла давно еще в семидесятых восьмидесятых годах прошлого века и одним из очевидных решений было поступить следующим образом вместо того чтобы изменять данные которые уже есть в базе сделать новую версию этих же данных и построить движок таким образом что те запросы которые работают они видят старую версию а те которые придут потом они увидят новую версию вот появляется идея version насти очевидная польза от этого то что писатели не блокирует читателей мы получаем для читающих запросов отличную конкурентную среду при этом писатели продолжают си реализоваться по 2 фазовым блокировкам это реализация упала в подольске ел версии 65 которая была выпущена в девяносто девятом году и она называется в мире после sqweel как им весь еси и мантии вершин конгар нэнси control а что было до того от того было все просто блокировки были на уровне всей таблице то есть пока кто-то пытается сделать апдейт в этой таблице даже одной записи вся таблица заблокирована никто из неё не может даже читать это основная причина по которой он весь еси это был один из самых первых таких больших проектов по модернизации продуктов блокировки на уровне таблицы сохранились они активно используются при ддл операциях то есть любой alter которую вы пытаетесь провести он однозначно будет хватать очень сильную блокировку на таблицу и в большинстве случаев эксклюзивную как пример если вы пытаетесь добавить колоночку alter the apple id каллум и указывайте какое дефолтного и значение даже если это ну то это означает следующее база схватит эксклюзивную блокировку и поскольку вы явным образом сказали и прописать какойто дефолтное значение она побежит по всем записям будет прописывать это значение чем больше таблицы тем больше это будет длиться и увы и ах это может привести к проблемам в продукции поэтому до версии 11 желательно вообще опускаюсь дефолт выражения и потом дополнительным альтера мы его прописывать когда у вас получится две операции но они обе будка временные вот начиная с 11 версии этот функционал значительно улучшили и там будет все гораздо лучше другой пример это если вы хотите каким-то индексом подпереть плохо работающий запрос и пишите create index на какую-то таблицу это стоит монтаже звонят эксклюзивную блокировку на таблицу это может еще сильнее усугубить ситуацию которую вас наблюдается вместо того чтобы писать просто create index рекомендуется использовать ключевое слово конкуренты которая позволит избежать эксклюзивных блокировок на таблице конкурент ли доступна для create index и для drop index к сожалению команды индекс пока не обзавелась такой функциональностью очень жалко в данный момент по сказке ел работает с блокировками на разных уровнях таблицы блокируются индивидуальные записи в таблице блокируют страничке но это внутренний урок уровень блокирования информации вы скорее всего от не увидите и также под газ предоставляет такую вещь как рекомендательные блокировки а два из релакс это что-то вроде api которая позволяет вам выстроить необходимые вам в ваших условиях достаточно сложную систему блокирования и разграничения доступа каким-то ресурсов она очень легковесное крайне рекомендуется во всех случаях где вы хотите сделать какое-то разграничение пожалуйста пользуйтесь давайте теперь посмотрим как это устроено физически есть запись у нее есть достаточно существенный заголовок который занимает 23 до эта полезная информация после которого следует собственно значение которые хранятся в этой записи в этом заголовки нас интересует несколько полей первые два это идентификатор транзакции которая вставила и которая удалила эту запись они по четыре байта и дальше там есть чуть далее 2 инфо маски каждая по два байта этими полями под раз оперируют для того чтобы обеспечить version ность далее все записи пакуются в странички и как вы видите у страничке тоже есть заголовок и сами записи падают в блог начиная с конца то из заполнения идет с конца а в начале сразу же после заголовка находится таблица указателей на записи это сделано для того чтобы в процессе работы база данных могла перемещать физически записи в пределах блока и чтобы при этом указатели которая находится в индексах на эти записи они ну не инвалиде рвались то есть вне зависимости от того в каком месте находится запись указатель на нее он фиксирован и потому что он ссылается на таблицу указателей а там уже смещение в пределах блока находится сейчас самое интересное особенности реализации x мин и xmax вот эти значения которое вставила запись и удалила записям не 32-битная 32 бита или четыре миллиарда это в современных системах не так уж и много у нас есть один клиент который пробегая 4 миллиарда транзакций в течение 1 недели и и может возникнуть следующая ситуация допустим какую запись в табличку вставила транзакцию которой идентификатор был миллион и в течение недели мы пробежали все номера чем до конца и этот весь диапазон транзакции он зациклен и когда мы добежали до конца мы возвращаемся в начало то есть хлобысь мы сейчас находимся в 0 транзакции и получается что эта запись с эти секатором миллион она оказалась как бы в будущем и нам и и больше показывать не надо то есть она физически была вставлена в прошлом но за счет реализации а на какой то момент времени может оказаться в будущем в терминах под русский л а это событие называется wraparound для того чтобы избежать подобных эффектов существует специальный специальная процедура которая называется заморозка записи то есть если под газ видит запись которой было добавлено очень давно то ей прописывается специальные идентификатор который означает что она вне зависимости от того где мы находимся в этом колечки видно всем и всегда еще одна особенность реализации если вы будете сравнивать например 40 вам versio не руются только записи в таблице то есть только хип и онду у нас хранится непосредственно в таблицах индекса не versio не руются это приводит к тому что если вы делаете несколько апдейтов одной и той же записи во всех индексах появляются по несколько указателей на разные версии этой записи даже если это индекс который обеспечивает уникальность все равно в нем появляется несколько указателей на разные версии строки с одним и тем же значением ключа вот такие вот эффекты все это нужно обслуживать для этого служит процесс уникальные для под раз и который называется вакуум собственно его основная задача проходить по табличкам помечается как свободное место те записи которые никому уже больше не нужны и также заниматься обслуживанием индексов но есть нюансы первое вакуум может быть достаточно трудоемким процессом с точки зрения потребления ресурсов и очень часто у пользователя возникает желание его притормозить выключить и этого делать не надо просто потому что вакуумировать к сожалению надо и вместо того чтобы тормозить процесс лучше наоборот сделать его агрессивным тогда если у вас накопился какой-то долг он какое-то время будет бомбить очень сильно но потом все устаканится и будет гораздо меньшая нагрузка нагрузка от вакуума 2 негативный эффект вакуум оперирует временем от начала самой старой транзакции которые у вас в базе данных запущены для того чтобы определить какие записи можно пометить как свободное место соответственно чем более долго транзакция у вас в базе присутствует тем хуже эффект от работы вакуума например очень часто мы увидим ситуации когда с одной стороны у нас на мастер базе основная нагрузка этого лтп огромное количество кратковременных транзакций с другой стороны периодически на не запускают какие-то очень сложные отчеты которые длятся несколько часов вот каждый такой отчет он очень негативно сказывается на вакууме это приводит к разбуханию табличка распухание у индусов так делать не надо мы всегда рекомендуем чтобы избежать последствий разбухания создать реплику выключить на ней хаттон биофидбэк и позволить ей вставать на нужное вам время там 6 10 часов и там запускать ваше тяжелые долгоиграющие отчеты и тогда у вас в принципе система будет более здоровое следующий нюанс множественные ссылки в индексах проблема в том что вакуум только в удаляет указатели он не перестраивает яндекс яндекс это сложная структура и вакуум просто ну как бы не наделен такими полномочиями это очень долго временный процесс если у вас там яндекс занимает десятки гигабайт поэтому если у вас произошла какая-то миграция вы там внезапно добавили новую колонку яфетом таблицы которые занимают 100 гигабайт прописали какие-то значения после этого пришел вакуум все это почистил но индекс ну скажем так получил большое количество дополнительных показателей они были вычищены но структура индекса стала такой что нак в каждом блоке очень много пустого места но физически его шлепнуть нет возможностей за счет того что индекса древовидная структура для того чтобы этого избежать вам нужно следить за такими большими миграциями и периодически после них перестраивать индексы это позволит держать ваш индекс более здоровыми и получить ну скажем так и лучший эффект от их работы эта проблема известна и одним из способов ее оптимизации служат так называемой горящие цепочки возможно вы они слушали хип only the poles они включаются в тех случаях когда вы делаете апдейт по колонкам который ни одна из которых не является индексирован и в таком случае индексы обновлять не надо и возраст делаю следующий он просто-напросто в блоке создает новую версию этой записи и между старой и новую версию создает специальную перемычку и соответственно если мы идем индекс к нам мы находим указатели прыгаем в таблицу видим старую версию записи и видим что там есть перемычкой проходим дальше вот так это все замечательно работает на самом деле если мы видим кого-то из клиентов таблицу которой очень высокое количество апдейтов и при этом очень низкий процент апдейтов keep on это пол с оптимизацией мы начинаем обязательно разбираться что там такого сделали какие индексы создали которые блокируют эту оптимизацию потому что она очень существенно снижает нагрузку на транзакционный лук и на количество дисковые активности как пример есть таблица есть колонка last-modified и мы допустим повесили триггер который всегда безусловно меня значение этой колонке вне зависимости того что до прописывается и если мы создадим яндекс по этой колоночки такой или более сложный но как только эта колонка появляется в яндексе это полностью исключает возможность для горячих цепочек в этой таблице соответственно так делать не надо в данном конкретном случае может быть вам будет выгоднее отказаться от индекса по этой колонке и в ваши запросы добавить ну-ка фанатам автоматически появится принудительная сортировкой если ваши запросы там станут отрабатывать не за допустим 3 миллисекунды а за десять миллисекунд мне кажется эта разница небольшая по сравнению с тем выигрышем которым вы получите от уменьшенной дисковой нагрузки поговорим о блокировках запись не блокирует чтение однако все писатели все сессии которые пытаются изменить какие-то данные они будут конкурировать друг с другом за одинаковые ресурсы поту фазовым блокировкам база хранит блокировки в заголовке за самой записи то есть как только какая-то сессия взяла блок на запись информация об этом появляется в самой записи и эта информация может пережить даже крах базы все просто в информации включается специальный бить их о том что это запись заблокирована и значение x max содержит идентификатор транзакции которая его блокируют возможна ситуация когда одну запись заблокировали несколько сессий это происходит случаях например когда вы делайте апдейты по подчиненным записям и мастер запись в какой-то мастер таблицы там где первичный ключ она блокируется в шары в режиме чтобы никто параллельно не смог удалить порно запись пока вы пытаетесь обновить подчиненные то есть возникает ситуация когда одну запись хотят заблокировать несколько транзакций в таком случае в инфо маски включается другой берег и в поле xmax находится уже не идентификатор транзакции а идентификаторы мультик зак структуры это специальная структура которые были добавлены по моему версии 93 они как раз служит для того чтобы обеспечить возможность блокирования одной записи множеством параллельных сессий в классических 2 фазовых блокировка у нас есть доступ на чтение и доступ на запись в воздухе они немножечко расширили этот диапазон если вы посмотрите документацию там есть select for апдейт select for nokia belle select for кейша силе просто фужер это скажем так они создали четыре уровня блокировок потому что заблокировать запись полностью через select for апдейт и заблокировать запись через select for now и апдейт это немножечко разный уровень блокирования то есть select for апдейт берет например делить когда вы пытаетесь полностью удалить запись а select for nokia будет берет апдейт потому что сама запись остается а но она пока изменяется включений ключи в ней не меняются и через вот эти вот 4 уровня вы можете построить достаточно ну скажем так сложную систему взаимоотношений между вашими параллельными сессиями которые работают в вашей системе один из примеров для чего это используется эта очередь то есть вам необходимо каким-то образом обеспечить processing каких-то событий которые вы складываете в таблицу и для того чтобы одно событие обрабатывал только один процесс вы устраиваете очередь через select воробей возрасте есть опция написать select ворот детский блок это позволяет организовать параллельно и обслуживание очереди потому что обычный select for a падает если он видит заблокированную записи он затыкается на ней ждет когда блокировка от пуститься select фура близкий плохо он просто пропускает такие берет первую которое доступно но реализация подобной очереди в version най среде она очень невыгодно просто потому что один из классических примеров это у вас опять таки совмещенной лтп и отчеты очереди это огромное количество точечной вставки огромное количество точечных удалений то есть of the vacuum должен прийти и подчищать чтобы размер таблицы в которой это всё хранится и размер индексов был ну скажем так прими примерно мать ну допустимых размеров чтобы то все отрабатывалась за единицы миллисекунд а если у вас параллельно бежит какой-нибудь многочасовой отчет он запрещает вакууму что-то выдай вычислить просто потому что ну как бы считается что сессии параллельные пока бежит за счет она сможет обратиться к этим данным и возможно не понадобится и таким образом мы видели ситуацию когда таблица очереди имела примерно там несколько десятков тысяч живых записей но при этом она занимала почти 100 гигабайт и на ней были индексы которые приближались к 10 гигабайт а принудительный вакуум это все схлопывается там пару мегабайт и начинает опять работать вместо нескольких секунд несколько миллисекунд и вот это все говорит о том что нужно использовать другой подход если вам действительно необходимо реализовывать очередь в базе то постройте немножечко по-другому заведите несколько таблиц и переключайтесь между ними через какой-то там промежуток времени допустим через час а предыдущую таблицы просто труп дети и тогда у вас вот это вот проблема накопления огромного количества старых записей она исчезнет лучше всего рассмотрите готовое решение в частности тоже печатью от skype лс им пользуется огромное количество наших клиентов отлично себя зарекомендовал 20000 ивентов в секунду прекрасно держит поговорим о чтении multi version их данных то есть мы в каждый момент времени в какой-то акра таблицы с активной пишущий нагрузкой имеем разное количество версий одной и той же записи и база данных по умолчанию из коробки с выставленным режима рядками даг будет вам всегда показывает самую последнюю и доступных версии это может привести к тому например что в рамках одной транзакции вы можете запустить запрос например который считается сумму там оборота пара кому-то счету один раз и потом еще один раз и между этими двумя и вызовами вы получите разные результаты просто потому что за счет параллельной активности произошли изменения и базовом сразу же их показала с одной стороны это как бы просто для базы это действительно самый простой режим работы с точки зрения базы новом как пользователям вашему приложению это не всегда может быть адекватно возможно это не то на что вы рассчитывали для того чтобы получить другое поведение вам нужно повышать уровень изоляции помимо рядками тэц есть еще горит онкомед нам возраст не позволяет читать грязные данные другим сессии есть лепида бурлит и сериала и забыл оба этих режима изоляции полноценно реализована в погрузке или и в частности повторяемое чтение означает то что снимок видимости фиксируется не перед каждым запросом а на начало транзакция ну точнее на начало первого запроса в рамках этой транзакции и соответственно все последующие запросы они будут видеть один и тот же снимок данных и не за вне зависимости того что там параллельно происходит у вас ну как бы будет целостная картинка того что происходит это очень хорошо подходит для всяких сложных отчетов которые состоят из нескольких запросов и для выгрузки данных если вам нужно сделать целостно вот в частности если вы знакомы с утилитой поджидаем то она как конкретно использую тряпицы был ли для того чтобы предоставить вам целостный снимок база данных при этом если вы начнёте использовать пишущие запросы в режиме ребята было ride у вас могут возникнуть ошибки сериализации то есть вы пытаетесь сделать апдейт а если какая-то другая транзакция эту запись уже поменяла с того момента как вы схватили snapshot вы получите ошибку это не значит что все пропало все сломалось это просто способ база данных поговорить с вами и сказать что нарушена сериализация которая ты просил просто попробую еще раз и тогда возможно все получится самый сложный режим это режим сериал ой забыл он сложен потому что база данных включает режим в котором отслеживаются не просто блокировки записи она начинает отслеживать предикаты которыми вы пользуетесь ваших запросов то есть она ищет логически нестыковке между запросами самое основное применение этого режима это когда вам нужно построить какую-то конкурентную систему например какой то сложный booking то есть где вам нужно всегда гарантирована либо там за забукать какой-то ресурс либо освободить его чтобы у вас гарантированно не возникало никаких конфликтов вот в частности пример нас простенькая табличка в которой две колоночки и цвет белый и черный и допустим у нас стоит задача приходит две сессии одна сессия хочет поменять все записи на черное другой осветили хочет поменять все записи на белые соответственно вы когда пишете подобные запросы вы ожидаете что у вас вне зависимости того как эти сессии придут будет все либо белое либо черно если вы это сделаете в режиме рипит и был рид вот первая транзакция она делает начинается транзакция делает апдейт ждет 2 транзакция начинается транзакция делает апдейт ждет потом вы делаете commit один комент другой облако меток входят здесь нет никакого конфликта но в результате вы получите не то что вы хотите увидеть цвета просто поменяются местами и все у вас не будет картинки когда все белые либо все черное почему так происходит потому что одна сессия берет блокировки по одному цвета другая по-другому эти блокировки не пересекаются режим рипит и было рид не в состоянии отследить то что логически эти сессии пересекаются если вы используйтесь воспользуйтесь сериал ой новым режимом и изоляции то одна из сессий та которая первая за к метиса она выполнит свою работу а вторая отвалится вот с такой ошибкой и как вы видите там есть hand если вы попробуйте еще раз возможно это все пройдет успешно то есть если у вас возникает такая ситуация что вам нужно действительно получить гарантию все реализации доступ каким-то данным вы можете пользоваться этим режим но с точки зрения база данных он самый тяжелый то есть включается достаточно много внутренних механизмов которые ну как дают ощутимую нагрузку я ее не мерил я не знаю там пять десять процентов времени исполнения запросов но можете примерно накинуть лучше всего тестировать на ваши нагрузки катана у вас есть другой способ применения блокировок может быть в ситуациях когда например вы осуществляете какие-то тесты и когда вы делаете все в один поток у вас все отрабатывает замечательно а потом вы устраиваете какой там стрессовый тест и пускаются там десятки потоков параллельно и вы начинаете видеть аномалии то есть какие то данные либо не меняются либо меняется многократно то есть происходит что-то непонятно соответственно у вас возникает аномалия результате конкурентные нагрузки что сделать в таких случаях рекомендуется явным образом организовывать узкие места например как бы брать какой-то из ресурс с которым вы работаете в явный оборот через select for апдейт то есть вы всю эту толпу конкурентных сессий выстроите в цепочку в том случае если они действительно конкурируют за один и тот же ресурс например там я не знаю такое случается что в результате каких-то неправильных действий вас две параллельные сессии могут схватить один и тот же объект и попытаться с ним работать то есть либо они удаляют из него данные больше чем надо либо они там апдейт делают двойной и так далее если вы сделаете select for апдейт для идентификатора во это этого объекта ну как бы вы увидите что у вас хоп сессии вдруг выстроились в цепочку и они начинают ждать друг друга то есть соответственно что несколько сессий пытаются работать с одним и тем же объектом она просто разобраться почему так происходит очень важно если вы делаете select for облиты устраиваете очередь брать блокировку не по всей таблице а по ключу ну потому что иначе могут быть проблемы поговорим о том как это все диагностировать самое простое в подрасе это воспользоваться представлением чистота activity который показывает все что сейчас запущена мы в своей работе обычно создаем специальная вьюшку которой мы пользуемся она у всех клиентов у нас находится и она делает следующее она во-первых отсекает все сессии которые работают меньше чем 100 миллисекунд потому что если что-то очень быстро отрабатывает но нам не интересно это видеть вторых мы сортируем весь вывод по времени работы сессии то есть все что работает дольше всего мы видим самом начале вывода и это несмотря на то что это все очень просто это дико классно позволяет прийти на незнакомую базу и сразу при спуск посмотреть что там происходит если есть какие-то блокировки мы сразу увидим если есть какая то сессия которая забыта в состоянии idol in transaction или например блокируют вакуум там 8 часов мы ее увидим если кто-то запустил апдейт из админской консоли нечаянно при этом открыв транзакцию пошел на обед и за ним выстроился хвост мы это увидим мы снимем эту транзакцию есть как бы это удобно если у вас идет очень активная работа и сессии короткие но при этом вы видите что возникает эта конкуренция вы можете воспользоваться другим запросам основании представления пиджи logs который построить дерево зависимостей различных сессий по тем блокировкам которые они сейчас держат в данном случае это синтетически сгенерирован вот видно что есть апдейт и он собрал за собой хвост виз enter the другого апдейты там еще и alter the block drop apple то есть есть запрос который позволяет вам посмотреть что в данный момент происходит на самом деле когда вы будете смотреть продукции там ничего сложного как правило не бывает либо однако эта сессия держится собой большое количество ожидающих либо там такие хвосты и выстраиваются и самое сложное то потом понять почему так происходит и где в коде у вас возникает такая ситуация которая приводит к таким последствиям на уровне база очень часто все что связано с блокировками это не проблемы непосредственно база да к сожалению проблема приложения которое работает база каким-то способом которые база пытается обеспечить но это не позволяет базе работать с достаточной скоростью в конкурентной среде если этого всего не достаточно к сожалению других встроенных средств возраста нету и вам в помощь уже приходят системные утилиты топ ios that it a hard as в том числе стресс и перф это уже такие достаточно низкого уровня вы утилиты если вы берете за такие то возможно имеет смысл там подключать сисадминов или стороннюю помощь как вариант вы можете брать снимки значения в этой лентой pva и the wind полей и строить по ним графики к сожалению саном под русский он не делает snapshot of то есть не собирает статистику о том ну сколько раз такой ивент произошел с течением времени это нужно делать сторонними приложениями идеальный случай если для вашего какого таки если вы можете сделать изолированный тест которой можно загрузить в пустую базу и увидеть проблему и за портить багрепорт в крайнем случае можете обращаться к нам мы постараемся вам помочь у меня все если у вас есть какие то вопросы пожалуйста задавайте спасибо за захват за доклад у меня вопрос если две транзакция одновременно начнут обновляйте одну и ту же запись они встанут блокировку илиада обновить другой отвалится они снова блокировка даже при обычной им уровни изоляции да спасибо здравствуйте хотел бы уточнить правильно я понял что после не совсем подходит для интенсивно обновляемых данных потому что в случае когда таблички сильно обновляется именно бледными то во-первых растет много не использовал пространство постоянный растет яндекс и без принудительного клонирования которое блокирует запись обслуживание дальше замедляться не совсем так есть системный процес сорта вакуумом который мы всегда у всех клиентов настраиваем крайне агрессивным мы даем им как можно больше ресурсов выделяем достаточное количество фоновых процессов и настраиваем пороговые значения достаточно низкими чтобы он срабатывал очень близко к этим значениям и очень часто при интенсивном изменений в принципе у нас ситуация когда 5 10 процентов место в индексах в таблицах находится в ротации то есть скажем так уже часть онду которая может быть отдана в свободное место но там присутствует она нормально если у вас распухание таблиц достигает там 50 и более процентов то это означает что у вас of the vacuum просто не справляется и вам нужно пересмотреть его настройки дать ему больше ресурсов его можно выкрутить так что он как он будет крайне агрессивный там очень много крутилок запомнив 2 табличной прострации в середине и честь это только через конца нет если у вас накопилась куча старых записей таблица крайне сильно фрагментирован а то понятно что он это место не может отдать существуют способы как переместить реальные данные полезные начала таблицы таким образом у вас останется пустой холст тогда он вас может подрезать но это ненормальная ситуация вам просто нужно настроить of the vacuum таким образом чтобы не приходить к таким ситуациям то есть он должен работать таким образом чтобы у вас фрагментация составляла 5 10 процентов не больше и это будет нормой хорошо спасибо у меня вопросец спасибо за доклад очень интересно я немножко прослушал для того чтобы избежать ситуации с распусканием донг вас посоветовали использовать реплику на реплики выставить отставания и еще выключить параметр вот этот параметр я послушал ход стендбай надо его выключить по сути говоря этот параметр пересылает информацию об активно работающих запросов на реплики обратно на мастер и тогда мастер считает что те запросы которые одной реплики они такие же транзакции и тоже откручивает вакуум то есть если вы этот параметр выключаете это означает что на master of the vacuum приходит быстрее и он может потенциально вычистить данные которые требуются запросом на реплики и тут у вас возникает реплики бывают двух типов 1 которая должна быть всегда актуальной потому что вы туда но разделили нагрузки мастер только пишет реплики только читает этот бам бам там важно актуальная информация бывает другая ситуация когда вы хотите запускать тяжелые отчеты которые идут много часов и понятно что они начнут конфликтовать с изменениями которые произошли на мази а просто напросто нужно отключить их астон давид бек и дать возможность реплики отставать на значительное время то есть если вы оставите дефолтные настройки компом пять минут через пять минут у вас запрос отвалится скажет что произошел конфликт восстановление а если вы позволите отставать на 10 часов то в течение этих 10 часов туда реплика безнадежно отстанет от мастера но ваша чё сумеет исполнится а при этом это не был не окажет никакого воздействия на мастер если я просто вы выставлю большое отставание не выключая эту информацию если этот параметр будет включен то это будет означать что вот там о своей идет отсчет 6 часов и реплика все время будет посылать информацию обратно мастер гарри что вот у меня есть транзакция активная которая уже длится шесть часов и оттоманку на мастере он не будет вычищать вот эти вот даны он будет ждать пока закончится запрос на реплики тоже вот здравствуй спасибо за доклад вот вопрос про триггер индекс верно ли такое утверждение что если мы в триггере меняем какое-то поле ток по нему нельзя строить яндекс или это вот конкретно вот этот пример с lastapp да и самопальная на костыли нарекли catia это неверно как бы индексом ничего не запрещает построить пожалуйста стройте просто нужно всегда смотреть на то что вы хотите получить ну и искать баланс между допустим призывать производитель все каких-то ваших запросов которые вам нужны для бизнес-логике и общее жизнь способностью системы то есть если вы можете там скажем так чуть-чуть переписан ваши запросы и потеряв допустим 5 миллисекунд на каждом получить значительные выигрыш по снижению дисковые активности но возможно стоит рассмотреть этот вариант если вы не построив индексы там там с нескольких миллисекунд до десятков секунд снижаете производительностью наверное это не приемлем нужно рассматривать каждый случай индивидуально но то что есть у вас какой то поле обновляется триггером по нему нельзя ну как бы строить индекс это не так спасибо за доклад скажите как postgres обрабатывает блоке d блоки если какое-то средство да конечно это встроено сразу же появилось то есть существует блок тайм-аут которая по умолчанию чтобы не соврать вам секунду и он сразу же находит что существует d-блок и отстреливает алитет какой какой процесс убивает если какой-то там алгоритм я если ну как бы мы поступаем таким образом что если мы хотим сделать какое-то изменение натыкаемся на блоке мы как правило в свои сессии руками выставляем доктор мало к меньшим значением и это означает что наша сессия потому что мой администратора на административный они без она будет отстрелено 1 соответственно от если это у который доктор малат меньше момент времени спасибо доктор молод он имеет возможность меняться в рамках сессии то есть да то есть для своей сессии я могу локтем одинок time on a statement м от ран , мат поставить как мне надо и соответствующим образом работать красоте спасибо за доклад нет такой вопрос вот у нас есть некое нормализованное хранилище данных да и там состоит она из 30 допустим таблиц оттуда мы выбираем хранится один объект он просто большой стрясти таблицы стоит и есть где нормализованное хранилища в котором мы хотим строить отчет там 840 полей хотим строить отчет и от вариации различных фильтров поэтому отчеты их много вот как в таком случае лучше построить индексы таблицы чтобы это быстро была выборка быстро длилась быстро работала выборка будет по нормализованной части им поди нормализованной но поди нормализованный если у вас есть индификатор объекта и дальше и содержимое объект это вам соответственно нужно как-то найти быстро сам объект я бы по ключу я нам допустим нужно выбрать кучу объектов по атрибутам отфильтровать стих может ну это именно несколько тут бы надо рассматривать все возможные вариации как это все делать но мы не вам даже сложно сказать нужно конкретно рассматривать ваш случай может быть вы просто подойдете мы детально поговорим я не могу так а из головы придумать что построить нужно возможно как бы воспользоваться джейсон и построить какой-нибудь полнотекстовый поиск я даже не знаю ну над исходить от бизнес задач которые вы пытаетесь решить я так навскидку не скажу что спасибо извините здрасьте у меня вот знаете как вопросы я немножко не уловил разницу между уровнями изоляции и регулировкой над таблицей над всей как это было в старых версиях образом блокировка над таблицей эта способность база данных схватить эту таблицу в определенном режиме которые предотвращают изменения по этой таблице скажем так более сложных любовь select он возьмет блокировку на таблиц в которой вы select по-любому но и это это именно на уровне таблиц а если мы говорим об уровнях изоляции то там немножко другие механизмы они оперируют именно случись сериал ой забыл конкретным блокировками на уровне записи и плюс они отслеживают предикаты которые используются ваших запросов и отслеживают перед логической нестыковки призы индикатор это разные уровни и и еще вот вопрос такой то есть босс креста и вот на обычных дисках на ssd дисках то есть здесь может быть разница в разы до или все-таки ну да будь бубу будет разницы в разы если у вас хорошие сиди диски которые именно ну серверные они какие-то специализированные например заточены и только почтения то там разницу видно не вооруженным взглядом 7 тыс за как бы есть клиент у которого база данных частом примерно 6 терабайт и та часть которая живет на из везде она работает очень классно понятно что столько ssd иметь накладные большой хвост уходит в архив на другой стороны чем более дешевые к сожалению нас больше не осталось времени на вопросе виды скажите пожалуйста вам задали несколько вопросов какой из них вам понравился может быть больше всего какой вы запомнили мне пожалуй запомнился тут мужчина два вопроса про of the vacuum распухание ну наверное мне этот вопрос корр сам интересно"
}