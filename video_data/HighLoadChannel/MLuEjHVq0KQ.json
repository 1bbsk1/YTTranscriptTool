{
  "video_id": "MLuEjHVq0KQ",
  "channel": "HighLoadChannel",
  "title": "Переход от монолита к микросервисам и эволюция архитектуры тестов / Анатолий Коровин (TheWhite)",
  "views": 2062,
  "duration": 2807,
  "published": "2020-04-27T12:21:38-07:00",
  "text": "в принципе даже такой небольшой к но аудитории как здесь вот показываю здесь довольно-таки приходишь на новую эту и тебя ждет огромное монолитное приложение и хорошо если это еще не какое-нибудь там древние legacy десятилетней давности пару лет назад со мной случилась такая же история я присоединился к команде разработки системы электронного документооборота у нас там позарез качестве основной базы данных власти ксерокс для быстрого поиска команда как движок бизнес-процессов там кто знает вышел что такое нотации bpmn вот весь этот ужас который любит бизнес-аналитики и ненавидят разработчики это вот все про это у нас много внешних систем с которыми нужно интегрироваться через active and you may be then kill тут больше зависит от того насколько это древнее legacy ну и все что не очень реляционная мы храним манги давайте перейдем к плану сегодняшнего накладно для начала мы посмотрим вообще что мы хотим тестировать определимся посмотрим как это делали в монолитном приложение распилим монолитно микро сервис и посмотрим чем это нам грозит какие проблемы сопровождения именно инфраструктуры тестов отсюда выливаются довольно детально разберемся как работать с докером в интеграционных тестах ну и напоследок все что может пойти не так в интеграционном тестирование со спаррингом да все это касается с джавы и спринга если вы вдруг хотите что-то другое там java script какой-нибудь вы точно перепутали слот стоит убежать пока не поздно вот ну начнем что мы хотим тестировать начала такая небольшая классификация я исхожу из того что все прекрасно умеют писать и unit тесты и в никого из присутствующих точно не надо учить этому нас интересовать будут именно интеграционные тесты и таких как вот компонент тесты и микро сервис 300 компонент тест это когда мы поднимаем какой-то специфичный узкий скоб контекста spring овой там будь то контекст для работы с базой данных либо контекст для работы с инверсии микро сервис тест по сути это конфигурация контекста которая максимально приближена к вашему продакшеном подняли всю конфигурацию полностью сервиса и на ней гоняем тест ну отойди от с ты тоже остаются за кадром это отдельная тема довольно долгое мы это не успеем обсудить ну вот вроде бы поговорили о классификации все здорово но не понятно что конкретно то тестировать собираюсь вообще давать больше конкретики вот я говорил что у нас используется postgres активно что это значит а значит что у нас есть однозначно нативные запросы у нас есть хранимые процедуры и конечно есть какие-то расширения из грасса все это нам надо интеграционном тестировать но кроме того что нам нужно все это тестировать было бы неплохо еще и сделать это удобно для разработчиков то есть декларирование того что нужно загрузить в базу перед тестом что нужно проверить в этой базе после теста было бы прекрасно если вы могли делать это как-то максимально удобно для разработчиков если говорить про тестирование таких вещей как взаимодействие с брокерами сообщений и те же вот этих им кьюри be think you to нам важен не только сам факт отправки сообщений асинхронной проверить но этот формат в котором он а уходит то есть мы это делаем джейсоне нам интересно что у нас и приходит и тот же сон на другую сторону ну давайте начнем для начала посмотрим что это что это все как как она выглядела в монолите и ну для начала под работа с базой данных postgres раз простой примерчик там возьмем task manager есть задача у нее есть название у нее есть какой-то эстимейт есть репозитории в котором наверняка есть нативные запросы для всего этого нам нужно это тестировать в тесте нам придется поднять как-то конфигурацию spring голы чтобы он работал с базой ну и кроме этого нам нужно будет собственно саму базу поднять учитывая что у нас всего этого добра довольно много вполне очевидны но такой момент что мы будем это делать не один раз и не два не три многих десятки раз вполне логично вынести куда-то эту конфигурацию то сделать абстрактный базовый класс там сконфигурировать spring чтобы он работал с базой и поднять эту собственно базу и тут как бы небольшой вопрос такое внимание на как какая база данных то есть продакшене у нас под gres вот как ни удивительно я иногда сейчас встречаю вот такие ответы что говорят что тестируют на я чту ну кому он 2019 год вот как-то так это выглядит если вы тестируете на мечту ваш production новый по сгрыз по сути ничего не тестируется то есть любой ваш зеленый бил то он может нафиг переломать продакшен когда в шаг влево шаг вправо от того что делает hibernate вот что делаем мы выносим postgres в докер image стартуем его в этом базовом классе ну и наследуем ся в тестах все нормально теперь у нас нормальная база на ней можно проверять все наши все что нам нужно если посмотреть вовнутрь тестов ничего сильно специфичному просто наследуем ся от абстрактного класса декларируем datasette который нам нужен перед тестом по лидируем что то что там было за папу ли равана в базу она реально почиталось что внутри этого базового абстрактного класса ну вот тот самый configure skype контекста который работает только с gp их level up to the job and test аннотация она конфигурирует только то что касается всех наших entity репозиториев transaction менеджеров entity менеджеров все всего остального здесь не будет создаем правила для работы с этими папуля то раме из джейсона никто не любит xml в 2019 год как бы лучше делать это как-то более удобно для пользователя и стартуем контейнер пока это все вот так вот скучный сын вариант еще 4 g unit у нас какие-то руны попозже мы сделаем этого интереснее вот ну и того мы добавили какой-то абстрактный класс для тестирования по сброса идем дальше у нас есть внешние системы ребятенка их тоже неплохо бы тестировать ну подход тот же самый базовом абстрактном классе стартанули контейнер сконфигурировали контекст от него от наследовали всех что нужно тестировать уже тесты пишем все еще один абстрактный класс но и под большому счету мы будем на каждую новую технологию теперь добавлять какие-то абстрактные классы вот больше технологии больше абстракции монолите все нормально монолитном приложение вполне рабочий вариант так делать никто не мешает добавлять этих абстракции все это сопровождать принципе не так сложно давайте посмотрим что произойдет когда мы от монолита перейдем к микро сервисом см и распиливаем наши монолитное приложение у нас вот в первой итерации получается что-то похожее на эту картинку мы вынесли отдельно сервис авторизации отдельно у нас там какой то и чар сервиса с документами в отдельном микро сервисе отдельный микро сервис там для обращений быстрого поиска по этому всему вот ну какой то такой небольшой набор на первую трассу это что получилось как это все тестировать мы берем эти наши абстрактные базовые классы перекидываем их из монолитного репозитория теперь по этим репозиториям копипастим по сути просто копипастим нужно в каждой из этих отдельных репозиторий нужно манга скопировали базовый класс для манги сюда нужен нам там по сгрыз rabbit скопировали его ну вот все вот примерно так и будет выглядеть так мы потихоньку подходим на самом деле к проблеме об сопровождения этого всего в чем оно заключается собственно у нас даже наш небольшой пример где 45 микро сервисов этих copy-paste и атаку лавинообразно поехала по проекту мы на дублировали этого кода как его сопровождать не не очень понятно вот и самих микро сервисов при этом тоже становится больше всех прям реально становится больше и больше и больше и небольшой тоже такой парадокс который мы заметили что в командах где разработчики один раз уж лет монолитах микро сервисом они назад возвращаться не хотят и как бы один раз поняв как это надо делать папа чего лечь и овер дофига шансов просто что следующий свой проект они будут делать именно микро сервис на вот и тут приходит очень стойкое понимание что копировать базовые классы просто не вариант что можно сделать довольно очевидное решение просто попилить это в отдельную зависимость тестовые унести и подключать ее в наши микро сервис и собрали все базовые абстракции эти в одном месте от наследовали в каждой микросферы все нормально все работает вроде под рабочий подход но если посмотреть на использование этого всего то у нас вот какой нибудь небольшой микро сервис который работает там с документами в манге ему нужно тестировать мангу а он получает вместе с этим всем еще кучу транзитивной зависимостей ну можно до сказать здесь принципе что разработчики способны там написать exclude и в полку добавили что-то по эксклю деле то что не нужно ведь никто этого не делает ну по крайней мере когда мы добавляем нам что нужно нам нужно как-то быстрее быстрее да протестировать этот сервис и в продакшен его закинуть не думать о том что там что-то лишнее то последнюю очередь а потом вспоминают и в общем довольно логичным решением этой проблемы кажется почему бы не разделить это все по модулям то есть мы сделаем отдельно модуль тестирования по сброса отдельном модуле тестирования манги весь и теперь все нормально вроде бы вроде бы проблему решили в микро сервисы подключаем только вот ровно то что им нужно вот но давайте посмотрим как это выглядит каком-то довольно типичном примере когда нам нужно тестировать и там postgres у нас база в по сгрызть и нам нужно еще тестировать ampy то есть есть какие-то листовые контроллеры по-хорошему нам нужен базовый класс для тестирования api базовый класс для тестирования подвеса и вот как-то их оба взять такого унаследовать а нельзя потому что джаве нет множественного наследования новым и получается обычно что мы делали в монолите когда вот с таким сталкивались убрали и копировали вот эти всю специфику двух классов копировали еще в один добавляли еще один абстрактный класс и в нем уже все это происходило ну вай нот взяли просто добавили еще один на копировали туда кода и так придется делать теперь для каждой комбинации ты каждый раз когда нам нужно что-то с чем-то соединить у нас появляются новые новые новые абстрактные классы в которых мы просто копипастим этот код ну можно до копипастить дальше ну только в надежде что кто-то другой это будет все сопровождать потому что ну блин 10 мест вот после 11 вы точно уже задумаетесь о стоит ли так делать особенно если там придется что-то править вот и почему я еще делал акцент на том что это все было хорошо в монолите и они в микро сервисах потому что микро сервисах у нас даже опции такой нету мы разнесли на разные библиотеки это все и куда положить этот абстрактный класс теперь вообще непонятно у него не хватает зависимостей ну для тестирования там он висит там у него только под газ в им вести не хватает зависимости из-под газ а вот ну и тут мы понимаем очень стойко что в принципе проблема в наследовании то есть сам подход он не очень живой нужно избавляться от того что мы наследуем ся что можно сделать с этим то есть вот наш типичный тест он наследует этот базовый класс можно заменить наследование парой аннотации здорово написали две понадобится 3 напишем 3 понадобится 4 ну здесь напишем 4 аннотации все окей вроде бы все нормально что внутри них внутри аннотации компонуемы теперь то что мы делали там базовых классах пытаемся это перенести на уровень именно декорирования другими аннотациями то сделаем таких композитные аннотации в которых все это заворачиваем просто им вести сконфигурировали для подвеса тоже сказали что это свой работы там дата gp и конфигурация базы какая-то вроде вроде все нормально это в принципе подходит такой рабочий подход можно нужно вроде бы как то так делать но есть нюанс как обычно в принципе вся эта штука не взлетит вот в таком ровно видео потому что мы здесь пока еще в четвертом же unity и тут есть вот страшная боль 4 g unit а это аннотация вот это ран виз собственно в чем моя проблема она только квас level и она не рипит обл что значит что она класс вывел значит что ее тупо нельзя указать внутри мета нотации и унести куда-то отдельно то есть можно так сделать то 4 g unit этого всего не найдет он будет сканировать сам классно предмета товара ниро его прямого родителя и все ни в какие ваши внутренние мета аннотации он просто не пойдет ему это не интересно вот и 0 и пи табал этот 2 та же проблема вы можете это с этим столкнуться и без всяких микро сервисов как бы то что в одном тесте нельзя сделать несколько раннеров по-человечьи то есть вы делаете два разных райнера указать одну аннотацию с одним вторую с другим нельзя нам не по пути с 4 g unit он если такое надо ну и что собственно делать переходим и на 5 g unit тут избавились от всех этих детских проблем есть теперь системой extension of которая делает все тоже самое только удобнее все раннеры меняем на extensions заместо рандгриз у нас аннотация extend виса на и как бы или пита был теперь и in herre ted мы можем ее написать внутри любой там своими то аннотации можем собрать целую матрешку этих аннотаций по вкладывать туда свои какие-то кастомные extensions и все это будет со сканированного 5g юнитам при тестах все-таки будут вызваны оттуда ну теперь можно делать вот такую красоту то есть просто как конструктор излива собираем эти тестовые конфигурации нужен там пост бросаем весе и разбитым киу просто тупо накидали аннотации контекст у нас сконфигурировал ся для того что нам нужно вот как теперь это все выглядит для того же под газ а например да что получилось то есть у нас есть extinction который стартует контейнер и есть аннотация которая все это подключает тест на самом деле этих аннотаций чуть чуть больше потому что все сделано чтобы разработчик меньше думал меньше у там искал как это сделать есть уже композитные аннотации которые компонуют вариант контекста вместе с подъемом контейнеров и использованием там всех его тестовых библиотек которые ему нужны обычно и тест сам максимально прост теперь сказали 1 аннотации я хочу под gres там и контекст do the job э-эй теперь мы можем приводить сюда идите менеджер сказать что вот у меня есть чудесная хранимая процедура там даже на экране влазит прям красота и мы тестируем вызываем говорим что вот то что мы получили из них не должно быть вот так вот выглядеть в принципе все нормально вот этого теста тот поднял в контейнере позарез той версии которая нам нужно то же самое что у нас продакшене вызвали на нем хранимую процедуру и право лидировали что все работает ровно так как вы этого ожидаете что получилось для манги для манги в принципе подход тот же самой остался подняли контейнер в extension не подтянули этот extensions смита аннотации все просто и там пара аннотация еще просто для своей какой-то удобной работы почему здесь тоже контейнеры а недопустимым в этот вариант но потому что им в этот вариант а просто как бы нету манги официального для джавы есть библиотека на гитхабе но нет никакой гарантии что кто-то при появлении новой версии манга тебе кто-то добавить туда еще и сразу ее поддержку а с контейнерами все просто вы завернули ровно то что вам нужно и пользуетесь тем самым имиджем в докере которую вас продакшене собственно сам тест конфигурация контекста подъем контейнера 1 аннотации говорим перед тестом какой нам нужен datasette в манге то есть вот этот же сончик он пойдет у нас в мозгу перед тем как мы выполним тест пару задач просто закинем но перед тем как выполнять проверяем что мы все это бы читаем все всё читается то же самое для записи такой своеобразный туду лист юного дарт вейдер или для начала нужно перейти на тёмную сторону силы делаем один task потом второй task на завтра уже ну что все джедаи хорошие да они мастера про кости нации 2 тоска в один день было бы уже слишком в этом удивляет 2 там будет на завтра пожалуй вот пишем была тоска в мозгу и а другой аннотации уже говорим что у нас теперь ожидаемый datasette в базе после теста он вот выглядит вот так почему я делал там акцент на даты потому что здесь есть небольшой такой сахар для удобного доит мачин года что-то не прибивать туда гвоздями какие конкретные даты а можно было написать относительно там сегодня плюс столько-то дней минут часов там ну неважно вот кроме депо чинга там есть еще возможность использовать регулярке можно даже скрипты нагрузить туда написать вообще по честному я туда добавил еще и джесс поддержку но я его терпеть не могу поэтому никому не говорю об этом вот что получилось для рыбе то подход опять же точно такой же подняли контейнер extension в нем его подтянули в компании в этом в аннотации своей и все теперь тест становится точно таким же простым собрали аннотацию что это rabbit and you сам тест собственно что у нас делает говорит что вот в эту очередь я ожидаю после выполнения теста записи вот таких то сообщений и в чосоне все их сказали что мы там где вам получить отправляем эти сообщения в очередь все все прекрасно разработчикам не нужно теперь думать каждый день как делать эти асинхронные тесты как это все реализовывать один раз это в extend они сделали за короче заморочили с тем чтобы сделать это именно асинхронно аккуратно пулить эту очередь какое-то время ждать проверить его лидировать что именно то что ждем пришло все это сделали в extend они запаковали внутри а люди просто пишут одну аннотацию и все прекрасно работает вот как все это делать с джокером подробнее теперь давайте посмотрим как все это выглядит мы используем библиотеку тест контейнер вот если посмотреть на наш extension конкретного вам это аннотациях мы подтягиваем его как он выглядит внутри он стартует контейнер по сброса и прописывает его в property спринга вы и чтобы spring при старте вычитал все это оттуда и собственно инициализировал ся на нем уже здесь есть как-бы один момент который вот но лично меня допустим немного смущает почему здесь все это происходит вообще static блоки вот как-то не очень красиво это смотрится и не очень очевидно такая конструкция как бы ну которое любого джавис то на первый взгляд немного смутить почему так ну ответ простой как бы нам хочется контейнер поднять один раз на весь прогон тесто всех то есть мы один раз его подняли а потом просто чистим данные перед тестом после теста ну во вполне способна это сделать мы чуть-чуть сэкономим времени если это сделаем один раз по хорошему нам нужен какой-то ну entry point который был по сути был один раз перед всем тестовым прогоном то есть там нужно что-то типа tan de force you it что то вот такое вот мой один раз эту точку вызвали а потом начали гнать все тестовые классы которые у нас есть если поискать в том же 5 g unity что-то похожее но мы ничего не найдем потому что там есть какие-то по перед методом после метода перед классом после класса но там нет никакого понимания о том что есть такая вещь как с тестовой скорлупы какие-то тестовые классы этого пока нет если пойти на гитхабе посмотреть ticket и дату можно найти один забавный ticket которому уже больше двух лет его за него брались откладывали переложили его из версии там пока горы 51 версию 52 потом 53 сейчас наверное уже в блоге 55 потому что версия 5 4 вышла в продакшен почему так возможно потому что один из карман тренеров 5 g unit а привел там workaround как можно добиться такого поведения мы сейчас посмотрим как он выглядит в коде и попытаемся его сравниться с этой статьи к инициализации что это что это такое вообще визуально вот то есть для этого нам придется сделать свой extension свой такой by force you it кастомный мы будем сейчас делать мы его сделаем на базе be for a walk рбк то есть это по сути обычный call back который вызывается перед каждым классом ну то есть перед перед всем классом но нам нужно будет теперь его вызвать перед каждым у нас есть там 1000 классов которые мы исполняем нам нужно сделать сейчас такое поведение что он будет вызываться перед каждым из них и что он будет делать он будет смотреть есть уже этот контейнер если есть то ничего не делать если нет то смотреть и нужно ли его стартовать если у нас принципе в тестовом скорлупы сейчас нет никого кто работает с подбросом но и зачем нам его контейнер мы просто можем ничего не делать а если есть то стартуем его и отмечаем контексте что он есть уже вот тоже новая фича 5 g unit а вот этот контекст старридж который позволяет шарить данные между тестовыми классными можно в одном тестовом классе что-то написать в этот контекст в другом тестовом классе уже пользоваться тем что мы там оставили и как бы мы между разными тестовыми классами пожарили какой какие-то данные также можно между разными тестовыми методами сделать при выполнении их вот почему здесь нету ничего про подчистку за собой то есть мы так сильно заморачивались чтобы сделать какой-то там be for all но при этом мы ничего не сделали чтобы от этих контейнеров избавиться потом ну ответ тут простой как бы библиотека тест контейнер с во многом нам помогает и они уже это все решили паттерном сайт корр контейнер по сути с каждым вашим тестовым контейнером они запускают рядом 2 который смотрит на того кто запускал всю эту кухню и если вы сделаете там в момент прогона вашего там тысячи тестов сделаете просто кинул -9 всего этого то тушить контейнеры будет именно этот сайт корр вот и все это хорошо работает принципе теперь остался только один вопрос как все это подключить во все вообще тесты то есть нам нужно это в каждом тесте чтобы было заставить разработчиков руками это делать ну вообще не рабочая ни разу тема потому что ну кто-нибудь по-любому за будет добавлять себе этот extension что можно сделать можно сделать глобальным его то есть можно сделать чтобы этот extension is глобально подключался к всем тестовым классом пишем мета ресурс в ресурсах meta-inf пишем просто класс reference этого extension а и в g-unit платформ property говорим что у нас теперь нам нужно auto detect я вот все это работает в принципе и теперь у нас наш extension запускается вместе с каждым тестом давайте немного сравним эти подходы статика инициализации против от такого кастомного варианта ну статика не цивилизация кажется на первый взгляд менее чистым вариант но зато она работает любом фреймворке потому что она сделана на чистой джаве то есть мы просто статический блок инициализации мы никакой магии не пользовались это будет работать практически везде он проще в написании написать еще один такой как бы ну реально намного проще чем вот эту всю кухню с какими-то глобальными extend шинами понимать как это делать и самое главное пожалуй что вот эти файлы g-unit платформ property их не может быть несколько в проекте то есть если у вас их несколько 5 g unit возьмет только 1 который нашел в класс по seo все остальные проигнорируют и может произойти такая ситуация что вы сделали несколько тонн тестовых библиотек во всех них закладываете на то что у вас есть вот эта авто детекция и тут появляется каток откуда-то извне еще другой файл g имеет платформ property в котором это все выключено и ваше extension а теперь не глобальные и все не работает и те кто пользуется библиотекой в итоге даже не понимают почему не работают они же даже не знали что это нужно что он нужен в принципе такой авто дтп вот ну вот так вот мы потихонечку подошли к самому интересному это как вот кто скажет там две самые сложные вещи в программировании да то есть одно это как назвать переменную очень сложная задача а второе как во время когда нужно инвалидизировать кэш вот у спринга в принципе есть такая же система хеширование для контекстов то есть когда вы гоняете ваши интеграционные тесты есть механизм кеширования которые будут сохранять к уже поднятые ранее контекст и в кэш чтоб мы не поднимали их дважды и все чтобы работала быстрее вот сейчас мы посмотрим как это выглядит вообще изначально у нас вот есть простой пример тут три теста про первый тест у него простая конфигурация spring будет тест кашку был пустой в контекстов мы его стартуем создаем контекст добавляем в кэш все теперь тест выполнили он зелёненький все хорошо идем ко второму тесту в этот момент spring смотрит на кэш в котором уже есть какие-то значения пытается срастить вот у нового теста конфигурация подходит ли оно для той которая уже есть кэш и если это такая же запись но они немного разные у нас там конфигурация spring будь тест который всего было поднято тут у нас до также пей в котором только определенный слайс контекста и они немного не совпадают он будет создавать еще одну запись в кэше когда поднимет контекст и запустить тест все все нормально второй тест прошел идем к третьему тесту тут самое интересное на первый взгляд он как бы вроде чуть-чуть другой по конфигурации но как отработает spring в этой ситуации он пойдет в кэш контекстов посмотрит если что-то подходящее и о abs он почему-то подумать что есть возьмет этот первый контекст даст его нам и мы завалимся потому что мы там контейнеры какие-то используем вот у нас наш тест который завалился он рассчитывает на то что мы делаем подключения rabbit in cutest контейнера что внутри внутри наш extension в extension не мы стартуем контейнер и прописываем его в спринга вы и property проблема в том что мы все это сделали мы молодцы большие контейнер подняли property прописали а после всего как того как мы это сделали нам дали контекст уже поднятые уже проинициализирован эй там все это уже проставлены другими значениями ups и все не работает и вот такая тема получается что мы в одном порядке работаем в другом заселились если бы наш проблемный тест был первым все было бы хорошо но он в последний в списке исполнения и поэтому все это не работает давайте разбираться глубже что происходит как работает spring в связке с g юнитам тут надо будет чуть-чуть посмотреть что происходит именно в процессе запуска наших тестов первую очередь 5 g unit когда начнет выполнять наш тестовый класс он будет инстанциировать все extensions то есть он отсканирует все extensions которые есть наших классах тестовых внутри на аннотации там неважно родительских классов все это найдет и будет создавать новые инстанции этих extend тут прям реально в живого и метода new он вызовет когда он вызовет этот new instance для нашего extinction орбиты мкс вызовется конечно наш статических блок инициализации это просто живого я тема здесь нет никакой магии ничего нет мы просто вызовем селенит который по контракту джавы должен быть вот вызовется static бог что произойдет дальше то есть следующим этапом 5 g unit начнет по всем extend шоном вызывать калмыки у нас там есть for call back вот он будет выполняться первым в нашем extend шине для работы с rabbit intel его не было но в спринга вам extensions конечно там очень много магии там есть call back который отвечает за обработку перед всем кодам тестовом что он делает он передает управление огромному классу такому единой точки входа тест контекст менеджера который у нас по сути он отвечает за все интеграционное тестирование springen вот что он делает он вызывает все тест execution listeners которые есть и перед на передает им вызов как бы be for all call back а вот этого из всего что там есть этих тест execution лицемеров нас интересует только вот такой небольшой весы нир который занимается дети контекстом что в нем специфичного потому что он обрабатывает аннотацию идете контекста есть когда мы в тесте пишем там что нам нужно убить какой-то контекст и делаем это через аннотацию это все от процессе c именно здесь мы в наших тестах этого не делали поэтому мы просто skip ним этот шаг и по сути ничего важного для нас здесь не произойдет сейчас следующим шагом будет обработка уже пост-процессинга тестов что происходит при пост-процессинге принципе картина довольно похожие мы опять передаем управления и spring о-го-го extension а в с контекст менеджер но на сей раз он пойдет опять по всем тест execution леса и равно будет вызывать другой call back уже спас процессинговый среди всех этих тест execution леса не раз прин голых есть один очень важный сейчас для нас это доп intense injection тест execution лицемер он сам по себе небольшой но у него очень важная задача передать вот управление к другому звену этой цепочке которая будет собственно уже отвечает за загрузку нашего контекста либо отдачу на мой спеша то есть вот такой вот корабль контрабандистов да у которого полные трюмы контекстов затишье рованных и если они там есть ну то он нам даст его оттуда если там его нету то мы будем поднимать значит все наше приложение заново создавать его контекст и вот все это кухня здесь произойдет то есть мы будем вычитывать системные property вот как раз здесь мы пойдем читать апликэйшен property файл и в которых указаны какие то настройки прочитаем системный environment вот то что мы там сеть или в static блоки да все это мы вычитываем именно здесь тут же подхватываем онлайновые property это такой вариант когда мы пишем в тесте прям аннотации тест property сурс и там указываем какую-то property ее значение это все подхватывается здесь же тут же обрабатываются конфигурационные файлы и активные proper профили в тесте которые нужны после того как мы все это соберем весь этот процесс подготовки такой пройдет мы создаем собственно спринга во и приложение будет создан новый instance spring applications в которой передадутся все эти настройки тоже такая довольно большая махина которая стартует в несколько шагов здесь у нас первым шагом будет подготовка от кружение мы примерим environment здесь происходит сети январь момент постпроцессоры все это будет здесь отработана следующим шагом будет собственно подготовка уже самого контекста мы вызовем все апликэйшен контекста нишевой зиры почему это важно потому что в принципе это второй вариант когда можно было бы защитить эти property то есть мы могли бы это сделать не в статике а сделать это в своем кастомном контексте не шил айзере тогда бы это происходило вот здесь ну по большому счету в глобальном плане это почти в том же самом месте поэтому разницы почти никакой нет ну и напоследок будет обновляться контекст тут будет дикая спринга vaio магия s beam пост процессорами и вот всей этой ерундой про которую очень любят рассказывать на всех конференциях женя борисов и кирилл толкачев кто работает продакшене со spring вам советую ознакомиться с этими видео они крайне полезны когда мы все это сделали стартовали контекст создали приложение но собственно возвращаемся к нашему хранителю кэша ну конец контекстами и он уже стоит это к себе чтобы следующий раз мы взяли готовый контекст из кэша и запустили тест на нем теперь давайте посмотрим что происходит все таки в нашем тесте вернемся к ним то есть когда вы static блоки вызывали старт контейнера и прописывали новые property даю мы вот это все сделали стартанули контейнер в property прописали где у нас этот контейнер стартовал на каких-то мха спорт может быть же тебе сию ролл сюда подписали зависит от того какой контейнер использовали после этого мы загрузили контекст если каждый пустой то мы реально стартуем контекст после этого и в этот момент обрабатываем environment и то есть мы загрузим все янв и обработаем их по-человечьи вот ровно то что там было для контейнера и собственно прогоним сам тест все хорошо все работает но что произойдет если мы получим контекст из кэша то есть мы также встать и к блоки стартовали контейнер прописали его в property все вроде поставили эти значения на которых он запустился контекст нам дали из крышам и просто скипа им вот эти два шага и не загружаем новый контекст то есть у нас контейнер стартанул property мы поменяли но никто их не читал никому как бы неинтересно было что мы там понаделали нам дали уже поднятый когда-то контекст и все а на нем ничего не работает потому что он не знает ничего о контейнерах вот что делать в этой ситуации во всей но по хорошему для начала такая небольшая памятка куда смотреть будет ли контекст одинаково для спринга то есть вот если вы пользуетесь аннотациями там spring bootes дата gp и тест любом весе и тест пересечение между ними не будет то есть контекст который подняли для одной из них не будет использоваться не из кэша вам его не дадут для другой здесь все нормально у них все аккуратно это сделано если вы пишете в тестах какие-то свои кастомные контекст configuration то есть новые файлы добавляем туда то это тоже будет считаться новой уникальной записью в кэше то есть если он конечно еще не был у запиши rowan такой вариант именно конфигурации с этими файлами это будет новая запись то же самое касается иерархии контекстов сюда же идут property но property не все property которые мы явно говорим через аннотацию тест property сурс spring понимаешь что сейчас в этом тесте будут меняться какие-то настройки новые property новые значения property может повлиять на тут конфигурацию контекста то есть то могут получиться другие бины в контексте и он естественно будет перейдет перепады мать этот контекст потому что может получиться что уже другой набор генов нам нужен вот это собственно то от чего зависит и так такие ключи вот этого кэша вот что собственно делать когда у нас происходит вот такая ситуация и у нас есть там какой-нибудь вот вейдер тест который прекрасно зеленым выглядит когда он сам по себе один запущен все хорошо но когда он в полном теста вал наборе какая-то дичь происходит и он шевелится что делать нужно отматывать назад то есть нужно идти в цепочке запуска ваших тестов назад в обратном порядке и искать тест с такой же конфигурации контекста но которые что-то там в нем мутирует то есть вот предыдущий контекст таким же предыдущий тест с таким же контекстом он что-то на делал такого на сайт эффектно ловко самом контексте либо вы рассчитываете что у вас будет новый контекст в вашем новом тесте и делаете что-то специфичные вам дали ну контекст из предыдущего теста вот если вы поймете хотя бы где это происходит и какие контекст и перекрываются один другим это уже 50 процентов принципе успеха чтобы найти в чем проблема и как то ее обойти вот может показаться что в принципе было бы проще без хеширования контекстов ну как бы это совсем не так потому что время выполнения всех тестов она на порядок хуже будет без хеширования механизм очень полезной нужно просто понимать как он работает ну и в принципе мы подходим к выводам на удивление даже уложился по времени вы видели как с помощью 5 g unit а можно реально упростить поддержку ваших тест но в нашей тестовой инфраструктуры можно сделать это удобным и для разработчиков и при этом как бы не иметь проблем с сопровождением этого кода пользуйтесь мета аннотациями extend шинами библиотека тест контейнер сыну помогает реально сделать ваше продакшен окружении в тестах все что вы там в продакшене на использовали можно поднимать в тестах рядышком и на этом тестироваться ну и нам как напоследок механизм кеширования контекста spring это очень хрупкая вещь нужно просто понимать как он устроен и куда смотреть чтобы в случае проблем и куда бежать и что делать если вы понимаете это все то вы сможете обойти очень много граблей вот ну и самое главное в принципе все это в open source и в paю request of which a request и волкам всем спасибо задавайте ваши вопросы уважаемые слушатели здрасте вопрос такое вы примерно где-то наполовину доклада рассказывали про то какой g-unit классный второй половин доклада вы рассказали про войну с технологиями с кишками вот к шоу мы всем остальным готовы работать не работает вот я так понимаю что это проистекает из этого вашего выбора инициализация встать и пользу кстати блоки всего этого добра но на самом деле проблемы и так вот static бог это по сути подводочкой к тому что вот эти проблемы с кефира ванием контекстов они сплошь и рядом то есть если вы живете со спаррингом мы ни разу не встречались такой ситуации что у вас тест сам по себе зеленый а вот в общем скайпе красный вам очень повезло то есть мой опыт показывает что вы работая со спринга вам постоянно эти проблемы они очень часто это такой вопрос а почему нельзя все это проинициализировать самом начале уж не он ли мандатом дошли до тест который нужен а сам начале запустить там скажем мангу там еще что-нибудь вот и потом уже гнать и подряд такая вот и вопрос где это делать то есть нету какого-то entry point а который бы был по контракту там для 5 g unit а например что он перед всем будет нету просто точке этой подходящий надо взять коннектом маркерный интерфейс и притом дефолтный метод конь такой год сделать ну можете попробовать спасибо у меня такой вопрос а как вы решаете проблему параллельного запуска тестов о это вот прям отличный вопрос прям вообще я понимал что я не успею все рассказать здесь как бы и даже не брал в доклад эту часть с парализации тестов пятом же unity в принципе довольно большая работа сейчас произошла есть этот вариант запускать kong оренсе тесты как бы прям лодкам конкурентно именно разные тестовые сценарии но есть большие проблемы с тем что вот вот в этом подходе один контейнер на два теста уже не за юзаешь ну ты прям вообще какой-то ужас произведет вот и хуже того тут тоже есть очень много кораблей когда конфигурации так перекрываются во первых нужно понимать что с чем вы будете пора ли лидировать чтобы прям реально не было больших проблем сопровождении этой темы и каждый новый тест у вас не файле вообще весь build ну сервер как правило мы сейчас иногда пользуемся такой штукой что просто разносим эти пакеты понимаем что у нас там допустим тесты базы данных мы в один поток поток можем вынести но параллельно с ними можно гнать например там только тест и чего-то там еще специфичного другого то есть нужно реально заранее понимать что с чем можно в параллель пустить сделать так что просто включили галочку конкуренте тест и все полетело не так не получится что это ну реально это очень сложный процесс там еще больше этих кораблей по появляется и ну можно можно это делать но нужно понимать хорошо какие варианты достигну самих тестов будут идти в параллель то есть но для каких-то сценариев да но на самом деле это сильно зависит от вашего приложения даст ли это какой-то прирост что если у вас нам большая часть тестов это именно какие-то одни и те же варианты там базы данных и вы не можете это нормально парализовать но может быть и не стоит заморачиваться на эту инфраструктуру я хотел спросить и как вы загружаете данные в базу данных для тестирования и как вы это делаете то есть используйте некие сид файлы какой-то дамп или фейковые данные и вопрос именно в том откуда мы берем эти данные как когда ставим или как мы технически загружаем это оба оба но обычно когда новую фичу там разрабатываем да мы тут зависит от того кто пишет эти тесты да то есть кто пишет функционал этот разработчикам иногда удобнее написать парочку просто сущности в коде там сделать новую вот как task был там в примере new task сделал предложил ему в билдере полей каких-то за перси stiletto в базу и там другой аннотации просто выгрузил это файл бессоновский то здесь есть extensions которые позволяют еще и экспорт делать то есть вы сделали тестовый сценарий в котором по на создавали чего-то в аннотации написали что после теста мне нужно это выгрузить вот туда виде джисона там или виде еще чего-то другого такие разные сценарии могут быть вот и потом этот файлик просто подготовленные взяли для другого теста ну естественно если нужен какой-то там поттер matching в этом во всем нужно чуть чуть чуть менять данные это сосна по составу каких-то больших там лютых массивов там для загрузки этих интеграционных тестов ну такого почти не встречается иногда нужно иногда приходится такое делать когда там отчеты например какие-то тестируются и для них нужно вот очень большой массив данных подготовить ну там как правило это да мы сначала все это с дам пили потом подгрузили для теста тут сильно зависит от задачи имена здравствуйте и спасибо за доклад сколько по времени тест все проходят о ну смотря в каком проекте но к вам и сколько ну вот микро сервис на как бы все проще поэтому как то даже не знаю вот сказать что минут за 5 можно прогнать как правило в большинстве микро сервисов такие основные сценарии если это ней эту е какое-то именно носка опыта который интересует вот в этом микро сервисе это это последовательно это да практически последовательно это вот последовательно допустим у нас там есть по сгрыз тот же самый мы его поднимаем на нем гоним эти тесты пять-десять минут это нормальные цифры для прогона во всех таких тестов их будет как бы не так мало уже в это не совсем такой прям nano микро сервис вот ну и достаточно не недолго отделите как-то эти тесты может быть как-то потому что вот этот долгий тест это быстро ты раздобыл developing не прогнать только быстрые а уже интеграционный прогнать где но прям как то вот что обязательно делаем так сейчас такого нет но в принципе пользовались том же g unity там есть система тегов можно потом в малине в билдах настроить что мы сначала делаем прогон одних тегов потом других тегов это ну вполне возможно реализацию реализовать и последнего опроса проблем были их какие-то с перестановкой тестов ну то есть например они запускаются на конюший в одном порядке где то запускаются на seo и спускается в другом порядке происходит какой-то господи ну вот собственно вот тут то что мы видели до это такое типичное очень поведение разработчику себя запустил у него все зеленое все прошло потом пошло это набьют сервер а там раз и что-то поменялось в порядке и они реально просто в другом порядке выполнились а и все зашевелилось такое да такое бывает реально часто это но она не связана иногда с тем что мы там докер не докер статика не ну то есть иногда это встречается просто из-за каких-то вещей что она люди не всегда понимают что происходит что контекст остался в кэше а мы в нем что-то взяли потом поменяли ну то есть какой то бизнес twin реально взяли сами за мутировали там после этого и на нем пытаемся дальше гнать а следующий тест уже не знает эту войну и он пылится от порядка иногда до очень много зависит runner какой-то для janet 5 ну то есть чтобы он сам переставлял которой есть возможность шафф лить по моему в суре faerie как раз малиновском можно это сделать просто там им флагом сделать shuffle вы можете сделать сейчас рандомный порядок тестов каждый раз но вы не пользуетесь то почему именно в каких-то проектах просто выставляем ясно спасибо здравствуйте я хотел спросить о выносе тесты параллели теле нет ну нося и сейчас по факту не параллель импорт практически то есть вот этот вариант парализации говорю он довольно сложный в паре проектов пробовали так делать это очень много проблем в саппорт она и но влечет за собой нужно стойкое понимание у всей команды чтобы было как можно делать как делать нельзя потому что люди ну природа такая человеческой он добавил один тест проверю он зеленый все они 100 у себя локально гнать за кормить его там в репозитории потом на seo и где-то все завалилась и мы вот это время разгребаем потом дольше независимое окружении например в сервисе есть резон их не на 2 агентах да такое можно я больше про программную реализацию то есть стандартными механизмами джимми это так мы не час такой особо не активно активно не используем по реализацию то есть у вас нет а на самом серии ну вот я честно говоря не буду врать я просто не скажу мы можем может быть где-то там час есть парализация может нет хорошо ночь будет интересно могу рассказать подход как мы это сделали ну отлично дискуссионные зоне пообщаемся все спасибо большое за ваши вопросы слушай ну к сожалению время вышло дискуссионной зоне рассказчик спасибо"
}