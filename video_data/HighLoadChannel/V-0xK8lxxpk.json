{
  "video_id": "V-0xK8lxxpk",
  "channel": "HighLoadChannel",
  "title": "Как мы сделали С++ распределенным / Игорь Сапего (GridGain)",
  "views": 511,
  "duration": 2361,
  "published": "2020-04-14T11:30:28-07:00",
  "text": "меня зовут игорь сапега я работал в компании green day я работаю в ней уже четыре года и в основном работаю над тем что связано с платформы в частности си плюс плюс сегодня я хотел бы рассказать вам как мы в нашей компании грибин сделали си плюс плюс распределенным для начала вообще тут многие знакомые с платформы и игнайт а подсекает понимете пожалуйста руке кто-то знаком большинство вижу нет но хорошо я дальше буду рассказывать что это такое в общих чертах так давайте начнем с того вообще зачем делать и при распределенном ну понятно что си плюс плюс он многими используется он хорош для многих задач многие люди на нем пишут и хотели бы продолжать писать и ну вообще кто кроме того есть большой объем кода который работает уже на си плюс плюс много лет отлаживал ся и наверное никто бы не хотел бы переписывать при этом нос сами распределенной системы они дают большие преимущества по сравнению с не распределенными то есть они дают возможность быстро обрабатывать данные большой объем и понятно что возможно многие хотели бы использовать ти плюс плюс таких системах такие системы сейчас есть они сейчас современные такие системы называются in-memory гряды если я не знаю многие знакомы с этим термином поднимите пожалуйста руки ну хорошо в общем это системой распределенной одноранговые которые как бы их основа в том что они почти все данные хранят в памяти ну или тех горячие данные они держат в памяти распределенные на большом кластере и за счет того что у нас все данные находятся памяти системы на этом как бы оптимизированы для работы с этими данными в памяти у нас получается быстрый доступ к этим данным быстро и их обработ k плюс скорость добавляется за счет распределенности таких систем в общем одной из таких систем является я пачек над которым мы работаем в гриб game и в общем то казалось бы все хорошо но есть с ними одна проблема большинству из этих систем они напас написан на java и в том числе играет оказалась бы почему это вообще проблема когда мы говорим о какой-то классической базы данных например то нам в общем-то все равно на чем он написано потому что случае необходимости мы можем просто с помощью текла доставать из нее данные класть туда и на вообще неважно какой язык там используется но в случае с янамари to the grid у нас одним из основных преимуществ такой системы является то что мы не достаем и не кладем туда данные которые нам надо обработать в основном а желаем вычисления к данным для того чтобы обрабатывать их быстрее таким образом мы снижаем объем трафика которые гуляют по сети и ну просто увеличиваем скорость обработки данных до 100 за счет того что у нас она обрабатывается на большем количестве машин и если у вас система написан на java то логично что такие вычисления тоже должны быть на java а как мы уже говорили многие люди хотели бы писать на си плюс плюс по разным причинам либо потому что но у них система написан на си плюс плюс и много уже работающего кода-либо потому что у них и разработчики которые знают хорошо и на си плюс плюс в общем разные бывают задачи как мы хотели подружить вот нашу и in memory datagrid который написан на java си плюс плюс какие есть варианты но первые очевидны которые наверное возникают у всех это мы берем и полностью пишем нашу систему на си плюс плюс наверное если у вас есть пару лет жизни и большое количество разработчиков которые могут этим заняться это для кого-то может подойти может ли каких-то крупных корпораций но в целом это не очень решение именно за счет того что вам нужно огромное количество ресурсов для то чтобы это поэтому этот вариант нам сразу откинули два других варианта которые у нас возникли это написать толстые или тонкие си плюс плюс клиентка наши уже готовый системе на java выглядели более реалистичным я не расскажу поподробнее что это такое то есть первое решение толстый клиент это когда у нас есть java но да она полностью написан на java и мы по сути делаем некую обертку на си плюс плюс над ней которая общается с ней через джиной и по сути представляет тот же и пьянь что из что и java надо только на си плюс плюс таким образом мы можем использовать си плюс плюс код дергать весь этот же что предоставляет java но до наноси + + и такая надо получается полноценный java но дай полноценный можно сказать си плюс плюс модель является частью кластера исходу мы получаем готовое решение второй вариант это тонкий клиент то есть мы не как бы сказать не трогаем тот процесс в котором запущено но до делаем отдельную библиотеку небольшую которая может отправлять посылать соединяется с кластером каким-то транспортом чаще всего себе обычный и может пересылать данные то есть такая система не будет является полноценной но дай то оно не будет считать эти алгоритмы которые есть в полноценный ноги поэтому она будет менее будет не такое большое подмножество и вне реализовано но зато у нее есть тоже свои преимущества вот если сравнить плюсы толстого и тонкого клиента то мы видим что производительность гарантии и пал на тайпе в толстом клиенте будет выше чем в тонком но зато тонкий клиенту будет гораздо меньше потреблять памяти и быстрее запускаться потому что это ну как бы небольшая библиотека которая просто льются с вашим приложением вот глядя на этот слайд я не знаю может быть кто-то предположит каким этих путей решили идти мы какие вы пошли в среднем ну в общем целом да мы тоже решили идти обоим этим путям можно сказать не среднем сделать и тот и другой клиент потому что на самом деле они не исключают как бы дополняют друг другу у нас получается мы можем сделать толстый клиент который по сути является полноценной си плюс плюс моды которые поддерживает хранение данных операции над ними и так далее тонкий клиенту может просто ленка ваться к вашим приложение для того чтобы вы быстро получали отдавали данный то есть по сути тонкий клиент может использоваться в тех случаях когда вам нужно меньше потреблять ресурсов быстрее стаптывать а толстый клиент тогда когда вам нужно хранить и обрабатывать данные на си плюс плюс когда первым образом первым делом мы решили тем не менее создавать именно толстый клиент потому что он представляет просто вот тут вот можно посмотреть что просто больше возможности предоставляет чем тонкий и когда мы решили его имплементировать первым делом мы столкнулись такими проблемами которые в общем то не связан напрямую с как бы сказать с тем что с самими особенности системы а скорее связаны с особенностями переходы с одного языка на другой и то это что очевидно что java и си плюс плюс имеет разные форматы хранения данных это что у них разные подходы к управлению памятью и то что просто банально такая вещь это все плюс плюс нет класса объектов который есть java ну и много других проблем с которым мы столкнулись именно когда имитировали тот и 5 который есть java на си плюс плюс если вот привести пример одной из таких типичных проблем это просто вот здесь у нас есть кот где мы выполняем сиквел запрос в нашей распределенной системе это примерно java то есть мы берем будем какой-то запрос select звездочка funtime и получаем курсор для резал цвета после этого мы хотим получить одну из строк этого резал цвета и java это выглядит просто как список из элементов класса обжиг ну какого то какого то типа который нам явно не известен в си плюс плюс мы такой код написать не можем потому что у нас нет типа обжиг и нам приходится выкручиваться ну вот тот же код си плюс плюс он например выглядит вот так здесь мы выполняем тот же самый сиквел за запрос и получаем курсор но результат получения следующей строки из курсора это уже не просто список значений некий класс с неким интерфейсом у которого уже каждое следующее значение мы получаем но мы должны явно указать его тип чтобы получить потому что иначе мы не можем предоставить пользователю коллекцию типов не из неизвестного нам типа короче но это довольно простая проблема их таких много там постоянно встречаются их больше довольно просто есть на самом деле разные варианты например могли сделать никакого бёрку типа и не которые уже потом пользователь мог как-то кастовать на самом деле действительно сложная проблема с которой мы столкнулись когда переходили взращивали ржавую си плюс плюс это то что у нас в джаве в нашей распределенной системе есть мощная runtime и рефлексия и плюс плюс нет даже компаниям рефлексии и казалось бы вообще почему эта проблема почему я говорю что это главная проблема и как это вообще связано с распределенными системами на самом деле эта проблема потому что из-за той самые особенности про которую я уже рассказывал что в таких распределенных системах у нас важно уметь выполнять не некие тоски задачи на но да то есть мы берем из одной из одного приложения на одной ноги отправляем нет некую jopu на весь кластер она там выполняет какие-то операции над данными и возвращает нам результат давайте посмотрим чтобы было понятно как это приходит происходит java java любая такая функция тарская это по сути является объекты обычный пользовательские и когда мы хотим ее отправить в кластер на выполнение мы просто с помощью рефлексии получаем необходимые данные о типе этого этой тоски и преобразуем это в некоторый набор байт где есть сами данные поля этого объекта и некая metadata метаданные которые потом мы отправляем через некий транспорта на другую ноду и с помощью уже рефлексии по данным этим теперь мы можем получить конструктор если условно говорить этого класса и используете реализатор просто сконструировать уже готовый объект и стэнс класса с которым можем работать как с обычным классом то есть вызывать на нем какие-то методы в частности но обычно это метод ран нам нужно запустить некое вычислении вот в принципе основная проблема именно в том чтобы получить вот этот класс все плюс плюс мы этого сделать банально не можем по той простой причине что мы не можем даже имея имя класса банально получить в руки себе методы этого класса даже если мы знаем что это за класс мы храним о нем информацию мы знаем как дите реализовывать этот объект мы просто не можем найти методы этого класса чтобы его вызвать на удаленной машине какие есть возможные решения этой проблемы вообще но я не знаю многие ли тут разрабатывают на си плюс плюс но в принципе да поднимись пожалуйста руки если можно а ну довольно много кто ну тогда первое решение которое наверное приходит многим в голову это мы берем готовое имя класса как то мы получаем его от пользователя например просим пользователя предоставить нам имя класса и там мангле моего никому определенному алгоритму и получаем имя символов да и люльки потом его находим и можем дергать вызвать поэтому первое решение которое мы рассмотрим это обман глинка иман глинка символов ну в данном случае вот действительно нам нужно какой-то от пользователя каким-то образом получить 7 класса потому что нам нужно тогда его преобразовать в символ который будет библиотеки и после этого мы можем уже неким алгоритмом преобразовать его в символ библиотеки и найти тут на самом деле есть множество проблем если вдаваться в подробности начиная с того что вообще процесс мангле нга он не стандартизирован и он может быть различным для разных и он и есть различные для разных компиляторов и более того от версии к версии компилятором тоже меняется можно конечно использовать какие-то готовые библиотеки которые это поддерживают но чаще всего вы все равно вы можете столкнуться с проблемами во-первых поддержки этой библиотеке а во-вторых возможно у какого-то пользователь будет какой-то экзотические компиляторы для него эта работа просто не будет и система станет бесполезной кроме того вот это вот то что возвращает такая функция это имя класса это прострочка если мы например поменяем какой-то namespace или имя класса или что то еще компилятор не отловят эту проблему просто всез компилируется у вас но работа не будет это конечно можно исправить до попробовать например сделал вот так тут у нас вроде бы все хорошо у нас есть какой-то макрос на машине все любят макросом тем не менее это выглядит как решение какое-то мы предоставляем даем пользователь дает нам имя класса в виде не уже дни строки обиде и готовы имени класса внутри мы можем как-то в виде какой-то нам об операции верифицировать что это действительно существующей класс и потом стринги цитировать его с помощью макроса но тут тоже есть проблемы например пользователь может написать вот так или вот так и тогда просто применив тот же самое алгоритм англия мы уже не получим тот символ под которым действительно этот объектов граница в ну скажем нет нет объекта символ этого объекта хранятся в бель-иль библиотеки тогда мы начали думать об альтернативном решение и просто решили использовать такой банальную вещь как ручную регистрацию то есть вместо вот этого всего пользуются просто явно виде просят нас зарегистрировать какой-то его класс как как функцию которую удаленная машина может дергать на этой на этой машине это решение она более как бы это сказать дальше на бумаге недостатка предыдущего то есть здесь мы не зависим от того как правильно написал имя класса пользователи если он это сделал неправильно спрос на chinese компилируется и он получит ошибкам портами ну и главное она мне нужно поддерживать man глинка бороться с какими-то странными версиями компиляторов и так далее тут все весь код полностью контролируем мы и дальше я немного расскажу как и вообще это все у нас устроено внутри вот эта функция регистр компьютеров funk она вроде как выглядит один один небольшой вызов на самом деле внутри это по сути вот такая функция если убрать все лишнее она полностью над и плитах то есть на самом деле она не делать никакие операции с данными работать только с метаданными типа то есть если смотрите она не принимает никаких аргументов кроме как plate аргумент в качестве на качество которого выступает класс который нужно зарегистрировать мы берем эту step и получаем и вот эти методом который ну как бы не особо важен наверное и после этого мы можем использовать этой пойди для того чтобы зарегистрировать в каком-то реестре для этой для этого типа некоторую функцию компьютер клеит с помощью которой мы уже можем на удаленной машине все реализовать здесь и реализовать и вызвать класс который нам нужно в данном случае если посмотреть как выглядит эта функция это вот такая вот функция которая получает просто поток байтов почитывает объект необходимые оборачивают его в некоторую обертку и в общем засовывает в реестр таким образом мы можем ну сама сама сама это обертка она просто у нее определенный интерфейс он тоже не имеет в себе никакой информации о типе в этот интерфейс позволяет просто вызвать функцию и передав туда поток выходной поток байт вы можете получить ужасе реализованный результат вызова этой функции таким образом мы получаем некоторые такой аналог рефлексии это парный на си плюс плюс с помощью теперь можем представить что там на месте вопросика у нас там есть некая реестр торцах в котором мы можем с помощью полученные мета информации найти обертку для соответствующего класса и вызвать его передав туда просто поток байт для одессе реализации объекта и получить все реализованный результаты выполнения операции таким образом в принципе мы можем выполнять просто в нашем кластере который полностью на джаве мы можем исполнять тоски и на си плюс плюс если вы зарегистрируете и просто сможете вызывать после этого мы начали делать тонкий клиент тонком клиенте были немного другие проблемы и главная проблема тонкого клиента она была никак не связано джавой потому что он находится в другом он не находится в процессе джавой он находится где-то в отдельном месте часто в в отдельной машине и общается с кластером по чаще всего пусти когда мы хотим получить какие самые распространенные операции для тонкого клиента это получение посылка данных в кластер соответственно когда мы хотим получить какие-то данные в этом кластере самое главное наша проблема в том что мы мало знаем о распределении данных в этом кластере вот допустим допустим мы хотим получить какое-то значение мы делаем get caporal дроби ну там например первой ноде и оказывается что эти данные на самом деле хранятся на другой ноги и мы получаем вот такой дополнительный прыжок с одной модель мастера на другую из-за этого у нас как бы как почему кажется один прыжок сетевой в чем проблема на самом деле вот эта операция там получить значение или положить значения она в такой системе очень быстро потому что данные в памяти вообще одну работает довольно быстро и основная задержка для такой операции это будет часто во многих случаях именно сетевая задержка и получая еще один вот этот прыжок сетевой мы сильно можем проседать по производительности полотенец и вплоть до там 50 30 процентов как можно решить эту проблему но логично что неплохо было чтобы тонкий клиент вообще знал куда слать данный знал о распределении данных в такой системе и послал запрос а именно на ту ноту на которую надо как это сделать ну проще всего было бы сделать чтобы полностью имплементировать тот алгоритм который есть в кластере который говорит о том как распределять данный к сожалению это невозможно по той причине которую я озвучивал раньше для этого по трое потребовалось бы сделать по сути полностью переписать ну написать игнайт на си плюс плюс потому что это алгоритм он на самом деле учитывает для этого надо быть частью кластера надо находиться в кольце надо обмениваться постоянно данными с другими модами и вот так просто взять имплементировать и тот же алгоритм мы не можем какому решению мы пришли как можем сделать как бы не совсем этот алгоритм но что-нибудь что значительно улучшить производительность мы пришли к такому решению которое мы назвали affinity overpass на самом деле что такое affinity что такое верно давайте об этом фильме цвет и вообще механизм вот тот которым я рассказывал который в кластере он отвечает за распределение данных по узлам то есть алгоритм жарко если угодно как мы будем распределять данные по узлам кластера а warmos это подразумевает что мы не полностью имплементировать механизм школа тонкий клиент а не узнает и каким-то образом и примите использует эти данные для оптимизации своих запросов как вообще этот механизм выглядит в общих чертах давайте расскажу каждый раз когда клиент делает запрос какой-то кластерам например на получение данных или для того чтобы положить данные кластер ему сообщает поменялись ли распределение данных предыдущего какого-то запроса если она поменялась ну то есть если она поменялась то естественно у нас данные пошли не туда скорее всего запрос они туда и у нас будет дополнительным поджог это снижение производительности но так как мы уже сообщаем об этом тонкому клиенту тонкий клиент может корректироваться получить обновление по тому как распределены данные в кластере и использовать их начать для того чтобы снизить like no se когда он получает когда он получает на индикацию о том что у нас поменялось распределение он запрашивает распределение данных не данных как бы квартир по кластеру это ну то есть эта информация благодаря который тонкий клиент может узнать куда какие данные ему посылать для этого ему нужно взять хэш-функцию от ключа и по определенному алгоритму он может вычислить где какие данные находятся до 0 для оптимизации в общем это наверное для оптимизации этих данных для оптимизации ему передается список всех каш с аналогичным распределением данных для того чтобы ну допустим мы каком-то каша это как бы но как space и в котором хранятся данные конкретные то есть как таблицы если брать аналогию стеклом если мы запрашиваем распределение для одной какой-то таблицы соответственно кластеров возвращает нам также список таблиц который имеет находят же распределение чтобы мы по десять раз нее не лазили сети для разных таблиц часто многие таблицы имеют одинаковые распределения по кластерам ну и в конце если как бы клиент промахнулся то ничего страшного не происходит запрос будет выполняться дольше но результат операции будет вполне корректным мы просто получим этот дополнительный ход по сети которого хотелось бы избежать но клиент может опять же быстро скорректироваться и восстановить и производительность на прежнем высоком уровне вот когда мы репетировали это алгоритм получили вот такие примерные результаты то есть действительности но это верилось на одном потоке то есть тут performance вырос с действительно по операциям секунду почти в два раза и это связанно с тем причинами которых я уже рассказал то есть основная у лестницы запроса это часто лестнице сетевого взаимодействия убираем один лишних о получаем рост производительности в разы это может быть по разному зависимости от того какие у вас дано если у вас очень большой дан большие данные то может быть большую часть процессор времени тратится именно начать реализацию и лекси и реализацию но в целом если у вас данный сильно огромные то прирост производительности будет заметным по итогу мы получили тонкий клиент который работает с заданными почти так же быстро как толстый и толстый клиент который может выполнять ти + + код то есть полноценные надо кластера которые могут выполнять и + + код локально работая с данными и это решение мы назвали игнайт си плюс плюс то есть можно сказать что это полноценная полноценный memory datagrid уже на си плюс плюс к которым пользователи могут с которым работать через си плюс плюс и вот такие результаты что мы хотим сделать еще неплохо было сделать в принципе если у нас есть кластер который поддерживает вычислений на си плюс плюс и тонкий клиент который может работать с данными неплохо было бы сделать еще чтобы тонкий клиент мог вообще запускать те же самые распределенные данные в таком кластере который массе + + и вот это вот планах пока этого нет но мы работаем над тем чтобы это сделать и если вас это заинтересовало вдруг кто-то хочет поучаствовать то напоминаю что проекту в общем-то open source на и если хотите мы всегда рады новым лицам новым контрибьютором не знаю если у вас просто интересовал под а вот здесь все есть все ссылки и спасибо за внимание здравствуйте спасибо за доклад я промсвязьбанк вопрос такой на тему джинны всем же известно до что он накладывает привил издержки на пиная перформанс как вы к этому относитесь далее что вы с этим делали или планируете делать и второй вопрос слышали ли вы про карбы которая в общем-то решает практически все проблемы которые вы здесь написали и если слышали то почему не выбрано спасибо да спасибо за вопрос джиной длина и это конечно накладывает некоторые дополнительные расходы естественно вызовы но на самом деле по результатам наших batch марков когда мы тестировали оказалось что это сравнительно небольшие расходы по сравнению с той же с реализации 10 реализации данных которые необходимо когда - переходом между форматами данных джаве и си плюс плюс и в принципе вообще мы стараемся минимизировать количество их вызовов через джиной в принципе пока что у нас не было проблем именно сжимаем именно с этой частью производительность в принципе вот этого решения си плюс плюс она более-менее сравнимо производительность java то есть на самом деле вот это верх это ну конечно он не минуем он виден на примерно знать на когда у нас очень быстро какая-то операция то есть действительно занимает очень мало времени тогда мы увидим какой-то константный overhead и чем быстрее операции тем сильнее он будет влиять но в большинстве случаев все таки мы не выполняем операции которые в таком кластере который будет выполняться очень уж быстро это просто действительно теряет смысл из-за того что сетевая задержка будет съедать больше большую часть вашей производительности вот то что касается карба нет я не особо не слышал об этом решении я посмотрю потом хорошо я учту это а можно я тоже спрошу я здесь спасибо за доклад вопрос по поводу зачитывают того как именно тонкий клиент узнает о распределении то есть во первых на операциях путать то есть как узнается то есть какой partition относится ключ вот и работает лет она нестандартной к пинки функцию про это может подробно пожалуйста да сейчас у нас и как я уже говорил есть большое количество ограничений которые связаны именно с этим алгоритмом по той простой причине что полная имплементация affinity на тонком клиенте потребовало бы нам сделать из него условно толстый клиент причем на си плюс плюс понятно что он будет работа не всегда если например пользоваться использует какую-то свою пользовательскую функцию для распределения данных то есть sapiente функцию скорее всего он работать не будет чаще но практика показывает чаще всего люди не используют такие функции но для случая когда они это используют у нас тоже есть планах сделать поддержку таких функций в принципе сейчас ну этот это не особо сложно надо просто представить пользуется интерфейс для того чтобы он мог имитировать свою собственную open sea функцию просто ему присутствие примите ровать не только на java на си плюс плюс ее желательно важно чтобы они работали одинаково иначе получим проблема спасибо за доклад у меня маленький вопросик по поводу толстого клиента которые вы делали этот код которого показывали как какой-то очень больной больной в плане регистрации своих функций почему бы не использовать такой шаблон ucoz ртп и просто за него полностью спрятать всю сложность регистрации этих ваших классов с функциями но смотрите в плане чего вы имейте ввиду что он больной в плане того что для пользователя как бы но это просто вызов одной функции вот именно этот вызов одной функции которую нужно не забыть сделать если сделать промежуточного посредника который в качестве шаблонного параметра примет вот этого самого наследника и внутри сделать статическую переменную в этом классе который вот этим проинициализировать это было во первых 1 . регистрации абсолютно всего во вторых you невозможно забыть но проблема тут как раз именно в статическом классе скорее всего да статическом это или нет нет нет статьи смотрите у нас если мы делаем промежуточный шаблонный класс который prime отрезается типа наследником и тогда в нём и объявляем global статическую статическое поле которое как раз и будет заниматься регистрации то есть она будет гарантированно уникальная потому что шаблоны инстанцирует каждым потомкам и это будет единственная . где будет ли регистрация делаться я понял да это надо будет где-то вызвать да я понял тогда вопрос какую стандарте плюс используйте сейчас но мы сейчас используем а к сожалению 3 standard 2003 потому что у нас есть большое количество пользователей которые не то что большое но они есть которые пользуются старыми версиями компиляторов к сожалению сожалению да жаль четырнадцатом можно было просто в одну строчку писать да я понимаю мы работаем над тем что бы перейти на новость дар скорее всего в версии игнайт 30 мы но я по крайней мере буду голосовать за то что переходить на новый на более новый стандарт плюсов спасибо добрый день и спасибо за доклад а вот по поводу толстого клиента я честно говоря не понимаю почему он клиент если я правильно понимаю что это на самом деле надо который регистрирует joe been который кто-то может на ней дернуть правильно да все правильно но в принципе так исторически сложилось что называется клиенты на самом деле это полноценная но да то есть можно назвать его сервер просто выгнать и вы найти первоначально не было вообще тонких клиентов поэтому были ноды часть из которых исполняла роль сервера а часть из которых исполняла роль клиентов но они также являлись частью топологии входили как полноценно но да и просто у них была другая роль поэтому когда делали первоначально си плюс плюс хотели сделать клиент но потом подумали почему бы не поддержать и серверную часть функциональность по сейчас это полноценно но да без всяких замечаний то есть да он так называется и старик по историческим причинам возможно стоит подумать над тем как позиционировать а по другому и 2 продолжение то зарегистрированы эти самые функции до джо бы компьют фанкшн и да как они вас названы а кто их может использовать то есть java код может их использовать или только такие же си плюс плюс ные ноты которые знают что существует вот именно такого типа компьютер action эта имплементация существует она не знает и она не может до в данный момент только такие же си плюс плюс лады но а в принципе подержать возможности использовать их из java кода это не очень сложно и например для дуэта в котором о котором вас тоже поддерживается это имплементировать но это скорее всего связано с тем что у нас есть никакие ограниченные ресурсы для для dota запросов пользователей был на эту функцию на эту функциональность она для си плюс плюс пользователей такой такое желание у кого пока не возникало если появятся запрос это мое легко и примите рамы тогда ну и последнее уточнение если у меня есть какой-то мега кластер там 128 морских нот и всего лишь пять вот таких вот тут плюсовых до 1 is not инициирует выполнение вот компьютером сундуки плюс плюс на это все автоматически выберется на каких новых существует это интрумент ации будет вызвана на них мне об этом заботиться до в данный момент ну то есть у вас автоматически у нас есть такой и пи ай которая называется класс тропе в котором мы вы можете с помощью которого признаком соцсети not у вас будет выполняться как то или иное вычисление естественно если вы будьте его используются си плюс плюс вам дастся только с up with not который поддерживает выполнение плюс плюс кода то есть не может быть такого что он придет на java ноду какую-то и не сможет выполниться верхнем спасибо большое запросов ну вы можете пообщаться в дискуссионной зоне а естественно благодарим нашего спикера спасибо и выберите лучший вопрос более все вопросы были хорошие мне понравилось наверное вопрос про про affinity то как мы ну в общем вот этого paris"
}