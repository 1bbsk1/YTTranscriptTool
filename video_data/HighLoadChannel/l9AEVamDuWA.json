{
  "video_id": "l9AEVamDuWA",
  "channel": "HighLoadChannel",
  "title": "Map-Reduce-операция длиною в год / Максим Ахмедов (Яндекс)",
  "views": 2249,
  "duration": 3129,
  "published": "2020-04-14T11:39:42-07:00",
  "text": "я сегодня по рассказываю немножко про разные задачи которые возникают при попытке написать софт который будет планировать что-то на кластер из большого количества машин давайте начнем с того что все поговорим про то чем занимается вычислительный кластер и яндекса видеть на карте яндекса они сначала большие они переваривают большое количество данных постоянно работают десятки тысяч машин например строятся поисковые базы каждый из которых требует перемолоть скажем так десятки петабайт данных только для того чтобы заходя значит на поиски яндекса вы могли видеть свежую информацию каждый день суммарно хранится порядка экзабайт а то есть от нас кончику миллиард гигабайт исторических данных и все данные надо где-то хранить надо где-то обрабатывать того чтобы их обрабатывать понятно нужно большое количество вычислительной мощности и для того чтобы это все работало для того чтобы можно было как-то это использовать необходимой инфраструктуры соответствующим я работаю над продуктом который зывается войти давайте быстрый опрос а кто вообще слышал такую аббревиатуру войти а теперь опустить руку индексу иди пожалуйста ага ага супер если люди которые слышали вот мы не очень много выступали с этой разработкам конференциях но исправляем досадную оплошность поэтому я сейчас быстро введу в курс дела значит войти это внутренняя разработка компании которая обвинять тебя много носом для разных продуктов во первых есть часть которая является распределенным сторожем и распределенным храни чем эта информация которая похожа в внешнем мире больше всего на такие продукты как лишь бы из еэсу keeper соответственно из ста копать дальше есть вычислительных фреймворк который позволяет производить вычисления данными лежащим этому распределенным старриджа и делать это в парадигме который отталкивается от мапри дьюса на самом деле понятно что со времен когда был представлен ему придется это был 2004 год en streaming шагнул вперед поэтому у нас нему придет смысле статьи 2004 года но гораздо более развитая скажем так концепция близкая близким эквивалентом является hadoop из внешнего мира у нас есть горизонтальный масштабируем реки волги сторож который позволяет играть и алтаем его нагрузку есть возможность запускать в окружении распределенным окружении запускать разный код наподобие того как это делает yarn и возможность поверх тех данных которые лежат в войти делать разные аналитические запросы средством более высокоуровневые интерфейса например языка который очень близок к sql продукт называется вой келли про него только cto рассказывалось разных внешних встречах окей еще немножко для статистики а кто из вас когда не пользовался ходу пом ха а кто им пользовался на инсталляциях больше чем 100 машин выше чем 1000 машин больше чем 10 тысяч машин огород не осталось окей на вашем тысячи были я видел в общем войти работает на кластеров тематические картинки можно увидеть изображения устроен наш кластер на кластеров довольно больших например типичный большой кластер он содержит порядка десятков тысяч машин которая непосредственно хранят и обрабатывают данные это все управляется не котом количеством служебных машин которые разделены на две категории это мастера непосредственно заведующая распределенным сторожем то есть той частью которая называется наш тюрьмы и называется сайпрус или кипарис по-русски и начните машины они хранят всю эту информацию необходимо для того чтобы понимать где находятся разные части относящийся к таблицам и есть машины которые называются планировщики или scheduler а их тоже там порядка 10 штук и про них я сегодня большей частью буду рассказывать что такое батч нагрузка которая фигурирует название моего сегодняшнего доклада эта нагрузка а обладающим свойствами а как она характеризуется тем что для нее не типичен большой трупу то есть большая просто моя способность с помощью нее можно обрабатывать так быстро данная сколько у вас были менее есть ресурсов если у вас там есть в 2 раза большего числитель на кого-то то вас ждать что ваше впечатление будет два раза быстрее первом приближении это не real time ago я нагрузка то есть эта нагрузка который может работать минуты и часы дни возможно возможно неделя и разумеется такая нагрузка она не возникает если того что пользователь заходит на веб-страницу какую-нибудь и нажимает на кнопочку дальше ждет результат вряд ли он будет ждать час пока считается какая-то операция чтобы получить в реал тайме ответ то подобное вычисление они хорошо вписываются в концепцию придешь с которой ну довольно много людей в этой аудитории в при напряжении знакомо и сорта поэтому это концепция mapreduce на вывел завоевал популярность потому что действительно хорошо позволяет раскладывать в некоторым примитивные кирпичики batch вычисления который часто возникают в больших скажем так компаниях и к моих поменьше и даже маленьких продуктов как же батч нагрузку планировать то есть что нужно сделать для того чтобы эффективно утилизировать мощности до центра кластера в котором запущенную эту которым у вас есть какое количество железа как их утилизировать большой нагрузкой необходимо давайте я проиллюстрирую как выглядит вообще к нетипичная batch нагрузка значит начинается все с того что у нас есть какое-то количество таблиц скажем раскиданных потом десятком сотен тысяч им машины в нашем кластере эти таблички каким-то образом с помощью некоторых примитивных кирпичиков не знаю какая нибудь операции типа имидж операция типа сортировки они как-то преобразовываются когда переходят одна в другую и типичная не то чтобы типичная возможные времена показано на картинке скажем какойнибудь отдельный кирпичик типа сортировки он может занимать по часам вот на стенке то есть реального времени он может занимать на скажем час времени поэтому утилизировать там сотню спу часов потому что соответственно эта операция делается с большой степенью параллельности там я не последующая операция может занимать 20 20 минут времени и тоже десятки цифру часов и так далее значит для того чтобы утилизировать но с большей параллельности с большой параллельность you фрезеровать полу время необходимо чтобы в сеть вычисляем происходить каким-то образом параллельно что мне себя в себе содержали параллельность и давайте договоримся относите терминологии я буду говорить в терминах которое свойственно нашей системе они немножко отличаются от общепринятых ходу пия возможно это будет немножко сбивать с толку на сейчас проговорю все терминологию начнем с того что видим понять операция операция это законченный логический блок который преобразовывает набор таблиц некоторые другой набор таблиц согласно некоторым принципу вариантом может быть операции сортировки выковывать плечу это может быть операция типом ap преобразования строчек там или еще какие-нибудь операции которые есть в нашей модели операция преобразовывает целые таблички и она состоит из маленьких отдельных блоков такие блоки называются джабба мин и каждый job это одна независимая часть внутри операции которые обрабатывают свою порцию входных данных и получает свою порцию выходных данных при этом job это сущность которая бежит в виде одного процесса где-то на одной машине в кластере соответственно выход операция он складывается из выхода всех гробов запущенных в этой операции схематично это выглядит как то так у нас есть процесс планировщика этот планировщик значит ему нужно запустить некоторые операцию свою операцию который преобразовывает некоторые входную таблицу в какой-то выходной он гийом разбивает на какое-то количество драбов скажем на картинке он разбил на 4 джабба кажеться которые независимо обработку свою порцию входных данных после чего эти джаббы попадают на вычислительные узлы кластера и уже независима друг от друга работают они вычитывают какие-то части входной таблицы получают к соответствующим части выходной таблица давайте поговорим про характерное числа которые связаны с джебами сколько времени работает типичный job типичный job хороший дом должен работать порядка минуту почему так ну потому что например почему не должен работать скажем одну секунду он не может работать на самом деле одну секунду потому что в распределенном таком окружении например возникает вопрос как доставить тот код который написал пользователь и которую он хочет обрабатывать собственно свои данные хочу доставить на машину на который будет исполняться этот код нужен по меньшей мере куда-то распространить могут быть дополнительно накладные расходы связаны с работой с распределенным сторожем на практике когда речь идет про batch нагрузку джаббы редко работают очень быстро они работают порядка единиц минут и стараться их ускорять дальше бессмысленно потому что большая часть времени будет потрачено на разные накладные расходы они собственно на полезную работу внутри джабба соответственно из времени работы такого типично 1 минуты получаются что типичный дом за время своей жизни успевает обработать порядка гигабайт информации и протащить через себя и как-то преобразовать типичный job опять же у нас он использует только одно ядро хотя бывают конечно и джаббы которая каким-то причинам полагаются на многопоточность внутри себя и desert больше одного драться пол значит в кластере про которые я сегодня буду говорить мне читать в порядке нескольких сотен тысяч озер и из этого всего складывается встречи занимательной арифметика если у нас есть скажем сотня тысяч ягер я типичный job живет порядка 1 минуты означает что в секунду будет происходить порядка несколько тысяч событий вида какой-то job закончился а значит освободилось освободить учить на ресурсы на этой машине а нам бы конечно хотелось чтобы в любой момент времени все ядра были чем-то заняты потому что если ядра не занята если планировщик скажем не успевает реагировать на события что освободились какие-то вычислительные ресурсы и не вовремя сообщает что дальше нужно делать с этими ядрами то получается что я др они будут заняты а значит железо которая стоит наших датацентрах она не утилизировано то есть мы теряем деньги таким образом можно ввести важное требование которое мы ожидаем от откорректирована планировщика что планировщики должн быть эффективным он должен эффективно утилизировать все те ресурсы которые есть наших датацентрах больше сейчас времени планировщик выглядит как-то так он реагирует на дикое количество событий которые возникают рядом с ним он пытается сможет оказать регистрировать от все дела у него пропадают машины из кластер и у него какие-то отдельные джаббы не работают и все происходит с такой интенсивностью что на самом деле успевать реагировать на все это действительно не тривиальная задача что можно сказать про джаббы давать еще немножко поговорим значит типичные джаббы важно удовлетворительно чем свойствам они должны быть во первых стоит лаз в том смысле что вся логика которой они преобразовывают информацию она должна быть зашито в входные данные для этой информации она не должна браться еще откуда то они доживут до термини раваны и то есть они должны выдавать один и тот же результат не зависит от того сколько раз мы их запустим и наконец они не должны иметь не должно быть свои дефектов вот совокупность этих требований она позволяет нам на самом деле запускает jabez и повторять их запуска пытаться их запускать столько раз сколько нам хочется возможность сказать несколько копий одного и того же java параллельно если нам каким-то причинам это захотелось в целом нам развязывает руки для того чтобы запускать жабы достаточно не сковывает скажем так так как мы хотим это делать а ведь поговорим про еще одно важное требование требование отказоустойчивости вот что если представляет операция операция это сколько ты джебов которые запускают примерно один и тот же код и преобразовывают входные таблицы выходные таблицы операция сама по себе может быть довольно долгой она может в отличие от джабба бежать и часы и сутки и даже недели возможны даже месяцы и конечно же за то время пока операции бежит может приключиться какая-нибудь неприятность с планировщиком с процессом планировщика например может уйти на обслуживание это же такой же код как и любой другой опере диске нужно обновлять или нужно там обновлять машины на которой работает планировщик с ним может произойти такой скажем так незапланированная неприятность например машины на которой работает планировщик может выйти из строя либо может случиться скажем так падение планировщика вызванная богам в коде эти все ситуации они случаются и в момент когда такой ситуации случается реже же не хочется чтобы операция которая бежала там неделю скажем до этого чтобы она улетела в трубу чтобы мы окончательно потеряли все что она делала все это время и что нам не хочется чтобы нам пришлось перезапускать операцию с нуля требование что планировщик должен переживать падение отключения переключение так или иначе процесса который собственно этим планировщиком заведует требуя можно нажать отказоустойчивостью наконец то есть картинка которая показывает как выглядит ситуация с точки зрения планировщика скажем если у вас запущена рядышком две операции вот они бегут бегут бегут сегодня мы будем довольно много таких картинок видеть отдельные горизонтальные отрезать это джаббы которые запущены в рамках этой операции джаббы они длительностью порядка единиц минут как я уже говорил сами операции мог быть довольно длинная скажем вот верхние операции добежала она бежала проект 2 часов 2 продолжать бежать бежать бежать бац происходит переключение планировщика связанная с тем что процесс парочка упал такой может случиться и в этот момент точнее к этому моменту автора операция бежала целых 10 часов это же мы не хотим чтобы скажем так все что она насчитала окончательно пропала и нас интересует вопрос как восстановиться из от ситуации и на третье важное требование это требование честности планировщика я много про него сегодня говорить не буду на общих чертах обрисую что планировщик он значит раздает ресурсы потребителям в том в каком смысле а значит он должен от делать в каком-то же смысле честно скажем если у какого-то потребителя больше кого-то или больше ресурсов в каких-то терминах то ему должны доставаться больше машинного времени для того чтобы работал его код скажем так как правило желающих на ресурсы гораздо больше чем этих самых ресурсов и для того чтобы раздать эти ресурсы честно то есть в моменте примерно соблюдалась желаем распределение ресурсов между потребителями для этого необходимо использовать разные сложные техники у нас используется алгоритм которые относятся к семейству флэшки джи линк но опять же сегодня про это много ведь не буду я надеюсь что когда нибудь мои коллеги которые им занимаются тоже выступит с докладом про это так что стоит картинка про честность выглядит как то так скажем разные потребители могут задавать свои пожелания еще и совершенно разных терминах и от этого становится окончательно тяжело скажем кто-то может говорить что я хочу себе значит 40 процентов всего кластера а кто-то говорит а я хочу не меньше чем 50000 лидер в 3 говорит нам не 150 видео карточек я кто-то еще приходится который там ничего не положено но я все равно хочу что-то посчитать пожалуйста дайте мне ресурса и это не тривиальна и так в чем хотим остаться от оставшейся части нашего рассказа можем построить эффективный отказоустойчивый планировщик начнем обсуждать какой-то модель который будет работать планировщик давайте начнем с того что поймем что общем должен помнить про каждую операцию вот мы видем термин термин контроллер операция которая описывает все состояние которых планировщик помнит про операцию во-первых планировщик должен помнить информацию о том что же собственно эта операция делает фактически информацию о том как операция запустилась эта информация передана пользователям планировщиком ходе запустить операцию в этой информации есть какой код нужно запускать какие таблицы мы хотим обрабатывать какие таблицы мы хотим получить на выходе скажем адреса этих таблицу нашим сторожа какие-то настройки связанности конкретной операции если от сортировка то по какому ключу например мы сортируем нашу таблицу вся совокупность ту информацию которую пользователь сообщает нам чтобы запустить операцию эту совокупность я буду называть спецификации операции планировщик должен помнить какие входные данные он уже обработал а какие еще нет и какие еще только предстоит обработать какими-то дробовик планировщик должен помнить какие выходные данные уже порождены теме джабба мир которые же прибежали планировщик должен помнить какие джаббы он на данный момент из контроллера из операции по которой идет речь какие джаббы сейчас где-то бегут если они бегут то где на каких машинах и если они бегут то какие данные не обрабатывают на самом деле вся эта информация это все часть состояния относящегося к конкретная операция вот это состояние мы будем называть контроллером и это некоторая структура данных в памяти планировщика если даже не будет знать вот всю эту информацию про операцию то он не будут состоянии как-то оркестре ровать эту операцию чтобы на дальше успешно работала чтобы несколько лет джаббы чтобы происходил какой-то прогресс более того эта информация нас совершенно не статична эта информация на меняется во времени и удобно мыслить про совокупность эта информация как про стоит машин то есть про автомат реагирующий на определенное воздействие со стороны внешнего мира какого рода бывает воздействие на прибывает воздействие такое приходит к планировщику какая-то машина кластера и говорит а вот у меня образовали свободные ресурсы у меня образовалось 5 10 и 8 гигабайт оперативной памяти не хочет ли ты запустить какую-нибудь job который может работать таких обстоятельствах тип нам не и планеты так и говорит да вот хочу давать ты запустишь вот этот вот бинарник на вход подашь таки это значит части таких-то табличек и будет все хорошо вот эта вот информация которая сообщает в ответ от спецификации уже конкретного джабба либо он в ответ может сообщить что нет значит у меня нету а всего лишь одно ядро из лишь один гигабайт оперативной памяти и сейчас никакой полезной работой поэтому он до вожди дальше может быть событие вида убежал какой-то job и это job закончил работать он мог закончить работать потому что он упал либо он мог за руку закончит работу что недоработал и во втором случае он еще наверно породил какие-то выходные данные вот эти выходные данные тоже являются частью события дальше удобно еще рассмотреть события которое звучит как мы закончили запускать все джаббы какие надо у вас больше не осталось не обработаны входных данных и в таком случае нужно финализирован операцию то есть собирать выходные таблица из всего того что породили джаббы и я еще отмечу что из вот этих трех события которые я обрисовал 2 инициируются внешним миром по отношению планировщику они приходят со стороны нот на который запускается джаббы а последние события она фактически вытекает из внутреннего состояния планировщика к планировщику понимает что какая-то операция закончила бежать то он инициирует события что операция заканчивается и таким образом подходит к логическому завершению не знаю если мы хотим какую-нибудь иллюстрацию то это выглядит как то так у нас есть контроллер значит которому вход состоит из 2 квадратиков красного и синего дальше возникают какие-то события пример пришло событие что мы хотим посуду лить дроп и мы говорим ok давайте мы отдадим синий квадратик в дроп а дальше приходится быть и что а гаджет а закончился этот джок преобразовал синий квадратик синий-синий треугольничек дальше точно так же мы schedule им job который будет перерабатывать красный квадратик раз наказать перейдет в красный кружочек и наконец операция закончится а контроллер операции таким образом претерпит последовательность из некоторого количества состояний каждый из которых получается под воздействием от очередного события я заметила что введенный нами модели есть одно очень приятное свойство а именно в нашей модели контроллеры могут жить в нескольких разных планировщиков каждый из которых фактически равноправием со всеми остальными именно я могу равномерно раскидать контроллеры операций по скажем 5 машинам на которых работают планировщик и 5 машин работать процесс планировщик таким образом у меня будет 5 планировщиков они будут независимо обрабатывать события приходящие к ним от внешнего мира если они каким-то причинам будет не успевать это делать и не будут скажем удалять средства требованию эффективности тогда могу сделать не петь машина 10 машин я получаю горизонтальную масштабируемость я дочь приятное свойство потому что она фактически дает мне решить проблему эффективности планировщика до скажем на машинах plaster а могут бежать джаббы от разных планировщиков и просто эти машины будут ходить со своими событиями к тем планировщиком тем процессам планировщика которые на них эти джаббы непосредственно поместили ok давайте попробуем вообразить какую-нибудь самую базовую реализацию планировщика самом базовом реализация может звучать так давайте держать состояние каждой операции в оперативной памяти и реагировать на эти самые внешнее воздействие ну конечно же такая реализация не только никакой критики потому что она никак не решает проблему отказоустойчивости скажем если у меня планировщик упадет оперативная память процесса это не самый надежный сторож на свете и я как же потеряем всю информацию которую меня было я потеряю формат к прогрессу чтобы даже потерять знания о том какие операции у меня бежали в предыдущие инкарнации планировщика и я не смогу даже перезапустить их то есть точки зрения пользователя это будет выглядеть как он запустил операцию пришел на следующий день обнаружил что планировщики ни сном ни духом про его операцию общение не закончил даже не знает что она на нем когда бежала это неприятно давайте с от проблемы как-нибудь поборемся нам нужно какое-то надежное место например давайте для начала спецификацию операции будем куда-нибудь сохранять вот куда можно сохранять можно сохранять скажем на диск диск это чуть более надежное стороны чем оперативная память но все равно придется решать какие-то проблемы придется решать проблему того что диски тоже выходит из строя решать проблему того что если ушла машина целиком на которой жил планировщика не только один процесс тогда мы потеряем как бы и диск который был на этой машине и чтобы эту проблему решить мы используем другую часть нашей системы который я начал который называется кипарис или say пресс и это и есть тот самый надежный распределенные сторож который мы складываем часть состояния планировщика давайте хранить спецификацию операция в кипарисе если мы это будем делать то мы сможем реализовать следующий подход когда новая инкарнаций планировщика просыпается она оглядывается смотрят какие операции бежали в учитывает их спецификации из кипариса и начинает исполнять их просто с нуля это уже кое-что мы уже по меньшей мере можем когда-нибудь теоретически эту операцию закончить на картинке выглядит как то так вот у нас была операция в не обижали какие-то джавы убежали бежали бежали нет еще не бежали мы начинаем что что мы записываем на старте операции спецификацию операции в кипарис начинает бежать к хиджабы бегут бегут бегут бац происходит переключение планировщика новая инкарнация планировщика просыпается прочитывает спецификацию той операции которая была узнает что ага у меня было тут такая эта операция жжения не знаю че я успел предыдущий своей инкарнации сделать но я все еще могу начать делать то же самое и дальше он начинает запускать те же самые джаббы то есть также по порядочку и вот трассы не доходит до успеха это решение как это работает но конечно тоже не очень практичная потому что скажем так если каждый раз когда происходит выключение планировка мы будем вынуждены не то что терять не начинать сначала считать то она чтобы могли к текущей могут потратить часы или дни работаю то это как-то неприятно нам скажем так из реальной практики характерный время который живет процесс планировщика у нас этот ну там десяток дней если там смотреть на перспективе скажем месяцев и за это время мы его обязательно либо обновим либо уровнем либо его уровне за нас когда нибудь другой поэтому нужно что-то предпринимать потому что некоторые операции вообще работает дольше чем 10 дней если операции беру работает само по себе месяц такое тоже бывает то у нее есть шанс оказаться в ситуация начинающий день сурка а именно операции бежит бежит бежит проходит переключения окей начну сначала бежит бежит бежит снова приключения и так некогда ныне добежит до успеха и будет вечно бежать нужно некоторые решения это решение в нашем случае это использовать snapshot thing мы периодически будем сохранять больше из состояния чем просто спецификацию мы будем сохранять целиком состоянии контроллера вы какой-нибудь надежное место общий день понятно скажем если у нас есть контроллер это структура данных которые мы с вами описали несколькими слайдами ранее давайте все эти данные все значит спецификацию все что сейчас есть из необработанных входных данных все что жители есть из уже порожденных выходных данных знать это все каком-то видите реализовывать скажем просто бинарным дампом каким-нибудь и класть упряжке полез отлично если теперь произойдет переключение у нас проснулась новая инкарнация планировщика то она может прочитать этот snapshot поднять точно такую же идентичную копию всех структур данных на момент когда был сделан и начать реагировать вот с этой копия есть некоторые сложный технический вопрос на этом пути а именно как же эти снапшоты будут возникать они в какие моменты будут писаться вот скажем контроллер он периоде он постоянно воспринимать кит события если это большая операцию не этом десятки или сотни тысяч рабов то контроллер будет каждый атом секунду много-много раз претерпевать какие-то изменения под воздействием событий что job закончился или там дроп нужно по schedule а если мы будем параллельно с тем как эти изменения изменения применяются пытаться писать snapshot а то мы будем читать постоянно изменяющийся структуру данных если мы не будем делать какими скажем так из другого потока то мы рискуем много чем мы можем лучшем случае получить какой то в лучшем случае получить хоть низко некое системное состоянии а в худшем но вообще получим проект по памяти и по процесс подружка упадет поэтому нужно что то придумать скажем давайте еще скажем что больших операций размер этот структур данных памяти планировщик он может быть тоже довольно большим он уже порядка гигабайт порядка 10 гигабайт как же взять и что-то сериале заводь такого большого размера если он постоянно меняется у вас такая оригинальная идея если это делать просто останавливая на время принятие всех изменений то это будет как то работать но будет не очень приятно для пользователя почему ну давай посмотрим картинки вот у нас есть скажем так линия жизни контроллера он периодически обрабатывают какие-то события он там отвечает на попытки нашу долю job какими-то ответами попытки закончит job он просто у себя сохраняет то что это job породил знания о том какие части выходных данных он породил и говорит окей а потом мы такие хорошо мы хотим начать писать snapshot означает что мы больше не принимаем каких изменений в это время к нам продолжают приходить запросы и мы вынуждены на них отвечать нет извини сейчас я не работаю я сейчас пишу snapshot я не буду тебе щас и дали джаббы и нет the job который закончил я тоже не запомню приходи потом завтра приходи это ситуация она может быть довольно долгой потому что чтобы записать там скажем 10 гигабайт состояния в распределенной тем более сторож куда-то посети куда-то на диске где-то далеко он может вполне понравится и 15 минут и 20 минут и течение всего этого времени фактически контролирует операции он будет отклонять все попытки что-то с ним делать и он не будет scheduled например ни один новый job таким образом мы довольно существенное время будем фактически простаивать этой операции и это недопустимо потому когда мы наконец отлипни мы начнем реагировать дальше как было но 10 15 минут уже во время и они были потеряны для нас так для статистики а кто знает что такое системный вызов ford ага чудесно ну начни не надо вам рассказывать что это такая черная магия которая позволяет нам раз клонировать процесс причем сохранить состояние памяти российского процесса в ребенке причем в неизменном виде ребенок будет постоянно если будет читать свою память он не будет видеть изменение которое сходит в российском процессе еще приятно что for cad довольно быстро системный вызов скажем чтобы фыркнуть процесс который и там 100 гигабайт оперативной памяти используют вам нужно то не сильно больше чем десяток секунд реального времени все происходит потому что форк реализован через концепцию копи он right если воспользоваться формам умело то можно придумать схему по страницам шатов которая не предполагает заморозки на долгое время и непринятие запрос в течение долгого времени давайте делать следующее давайте для когда мы хотим построить snapshot давайте заморозим все контроллера мы не будем принимать никакие изменения но это мы сделаем на всем небольшое время мы позовем for for код работает за буквально там 10 секунд после чего родительский процесс который остался он такой комфорт прошел все я обратно размораживаются контроллера и начинаю принимать изменения начала принимать уме и начинаешь сулить новые джаббы реагировать на окончание предыдущих драбов о чем все замечательно в это время ребенок который родился он такое ага вот у меня есть состояние родителя в которое от времени это консистентные состоянии потому сейчас они бегут никакие изменения в контроллерах давайте-ка я начну эти все контроллеры обходить писать их снапшоты куда бы то ни было и вот делать от столько времени сколько захочу не знаю потрачу на все эти большие значит контроллер не знаем 25 минут захотел потратил он их пишет пишет пишут пишет потом в какой-то момент вам заканчивает ну и заканчивать свою работу говорить скажем так хронологически это выглядит как то так время простоя относительно основного процесса это буквально десять секунд на ford форд тут и процесс пишет что-то в кипарис и делать от не знаем 10 минут 15-20 чем такое решение чревато такое решение обладать следующими свойствами простой я искала небольшой его можно повторять произвольное количество раз что можно фармить этим тоже процесс много-много раз например можно делать легче форк когда предыдущий закончил работу при такой схеме у нас все контроллеры будут получать свои снапшоты примерно одновременно а именно одновременно стенках мы делаем очередной форм и цена такого решения самая скажем так тяжел чем вам приходится платить это на самом деле двукратное потребление по памяти потому что copyright который копирует скажем так страничке памяти когда тот длинный процесс их трогает и соответственно мы хотим сохранить видимость 2 состояния в другом процессе копин райтон худшем случае нам раздувает всю память которая есть у нашего планировщика и про это надо помнить окей мы научились писать snapshot а давайте поймем как а теперь будет лодка восстановления но она не очень сложная но не есть ряд моментов которые тут приговорить скажем если у меня snapshot есть я могу из него восстановиться наверное есть риск что я только что прочитал но я не могу из него восстановиться то что он записан старой версии кода это неприятно такая ситуация он станет действительно не могу и надо стремиться что такая ситуация была редкой то есть нужно стараться сохранять совместимость иных шатов как можно чаще при минорных обновлениях и и не ломать потому что если совместимости нет то у меня нет никакого выхода кроме как сделать клиент старт и начать все с нуля если у операция нету ни одного snapshot а то тогда тоже ничего не мог сделать только клин старт но это не очень страшно потому что это на самом деле означает что операция не очень долго текущего in the бежала-бежала не больше чем те самые 15 20 минут это регулярность который меня появляются над shooter что же мы теряем когда мы просыпаемся и snapshot что-то он же на какое-то время на самом деле в прошлом основном мы теряем часть последних событий которые у нас происходили и давайте поймем что мы знаем про джаббы вот job который закончился дома до последнего snapshot и он точно никуда не потеряем это замечательно если же job закончился после последнего snapshot это мы точно потеряли информацию про турки например он выходные данные по радио с от проблем пока не умеем бороться давайте просто такие джаббы ну скажем так игнорировать будем считать что их и не было и нам придется их перезапустить их придется пересчитать snapshot попадают значит только завершившаяся джаббы и я утверждаю что это уже довольно хорошее решение на картинке выглядит как то так у меня есть значит момент когда сделал snapshot на этот момент какие-то джаббы успели завершится вот эти джаббы мне перезапускать после перри подъема планировщика не нужно потому что я про них все знаю а вот джаббы которая не завершили смотреть последний снапшоты неважно они успели завершится к падению планировщика или они бежали во время падения планировщика в 3g black сажали не теряю но таких гробов их не очень много их получается если они довольно короткие получается что я на вот этой картинке теряю отрезок порядка 20 минут реального времени прогресса если операция длинная 20 минут прогресса для нее не очень много их можно и переиграть что же про хотите чтобы длинная если же бы длинная то вообще такое тогда бывает нужно скажем утра вам может быть очень тяжелая установка в каком-то смысле начала работы которая невозможна ускорить раздробил вход на две части детина слагаемого времени работы джабба если такое job есть если он длинна если он работать не знаю час или два то к сожалению мы будем терять много картинка будет выглядеть как-то так мы несмотря на то что мы делали снапшоты исправно каждые 20 минут на самом деле мы все равно потеряем порядка продолжительности джабба аспирин порядка часа на этой картинке и продает переключения что я вынужден и вот этот job и вот этот и вот этот все-все-все их переиграть пойдем по хиджабы это плохо но к сожалению эта реальность которых приходится сталкиваться с к-рым длинными гробами к плохим это плохо длинные жабы это плохо но иногда они возникают сожалению например задача машинного обучения они не очень хорошо параллели и участке войти периодически запускаются такие операции которых бывают двухчасовые 5 часовые джаббы просто исполняющий некоторый процесс войти используется в качестве места где можно что-то запускать такого рода что же делать давайте пытаться восстанавливать и про бегущий джаббы что тоже и snapshot а у нас есть ряд проблем скажем если я я только что проснулся поднялся и snapshot а мне необходимо узнать что-то про терабайт который час бегут я могу попросить модом не сообщать о том что на них бегут хиджабы периоде что приходя ко мне с орбитами это половинчатое решение к сожалению потому что если мне придется быть и о том что для бежит то отлично я принял все знаю я его подцепил а если не придет то я оказываюсь в непонятках этот job он уже успел закончиться или он упал или он еще бежит но просто до меня не дошло это событие что же делать вот скажем на картинке если не было три джабба один из которых упал 2 закончился и породил как это вы его выход 3 продолжает бежать моменту переключения то проснувшись новой инкарнации я ну положим узнаю что-то про 3 job он придет ко мне скажет я здесь но про джаббы 1 и 2 я не узнаю ничего и что сама ужасно я потеряю вывод который док второй успел породить потому что у него нет snapshot я на надеево уже тоже нет откуда мне его взять решение напрашивается сама собой давайте попросим но до запоминать часть состояние которое потенциально могу потерять давайте попросим их придерживать события вот те самые что дом закончился до тех пор пока скажем так это имеет смысл то есть они будут придерживать все то что я могу потерять а я как планировщик буду периодически их просите послушай а вот так что проснулся и что-то я забыл что было последние 15 минут напомню я пожалуйста все события вида job закончился который я мог пропустить сколько же времени нужно держать такую информацию на нодов утверждаются что нужно вспомнить когда мы надежно вспомнить когда мы надежность запоминаем вообще что-то но я заклинаю что тогда она падает snapshot если snapshot попал события что док закончился то тогда можно смело забывать про это событие но на деле потому что я я как планировщик уже никогда не забуду про него чудесно давайте введем еще один вызов который будет идти от планировщик как надя кто говорит о том что можно забыть про какой-то job и с помощью него построим эту конструкцию на картинке в картинке выглядит как то так вот у меня есть сейчас job он бежал бежал-бежал закончился у меня текущему моменту в снапчате нет информации о том что друг закончился поэтому надо запоминает этот дуб и держит события которое она отправила планировщику еще какое то время после чего планировщик пишет snapshot все это событие она уже никуда не пропадет не пропадет и наконец планировщик говорить все пройдем нужно забывать мы the job выкидываем с надо в плохой ситуации когда происходит переключение корзинка будет чуть-чуть сложнее вот job закончился происходит переключение просыпается новой инкарнации планировщика с ее точки зрения что происходит жабам а у нас он бежит с ее точки зрения потому что она проснулась где-то в этот момент когда он еще бежал плавочек говорить на те случай напомню что там было с этим джабба она говорит да он вообще то уже закончился париж такой окей надо продолжает помнить про этот джок потому что мало ли вдруг планировки еще раз попадет какая-то планировщик делать еще один snapshot из надо вымывается этот топ такое решение фактически сейчас у нас используется такой подход давайте назову какими числа которое как-то оправдывают почему он хороший скажем так мы экономим порядка сотен тысяч лидер циpкa на больших кластеров в неделю только потому что мы делаем снапшоты и это действительно спасает действительно скажем так наносит пользу но это то что касается утилизации а есть еще один момент который касается этого как пользователь видит это все расскажем если вернуться к человеку запустил задач машинного обучения которые там типично выглядит как операции с одного джабба на несколько часов вот дать посмотрим такие операции выберем из них те которые зацепили собой какой-нибудь приключение планировщика хотят ждать что таких операций их там несколько десятков тысяч в месяц и такие операции только в среднем в экономят по 7 часов на переключениях потому что мы умеем подцеплять обратно jagged этих операций если мы этого не делали то среднем на 7 часов больше накажет такая операция приходилось бы тратить только потому что операции бежал там 10 часов и на седьмом часу жизни произошло переключение планировщика конечно же люди которые сидят и ждут я целый день терпят значит в ожидании что операция добежит они очень рады этому свойству что мы экономим эти часы жизни что же можно делать дальше ну я замечу что есть нектар количество мест которые можно улучшить эту схему а именно можно пытаться восстанавливать не только джаббы которые на самом деле бежали на последнем шорты на вечер бы которые были запущены уже после последнего snapshot это сложно потому что это требует от нас попытки восстановить а как же менялась состоянии планировщика после последнего snapshot а а я замечу что планировщик дачей контроллер это довольно сложная структура это я вот так вот на пальцах объяснил что она у неё там есть всего два воздействия и внутрь она держит только там список драбов земля на каждый раз сложнее и восстановить это пост-фактум знаю что а вот почему то моя предыдущая карнак запустил такой и такой job интересно какое последствий мутации она это сделала этого число поэтому мы еще это такое не умеем мы таким размышляем о самой даже более перспективным нам кажется другой способ который качается в том что все состояние планировщика его можно полностью поселить в некоторую persistent ную штуку в некоторых персистенции сторож скажем не периодически снапшоты делать а вот чтобы в любой момент времени состоянии планировщика где-то жила в персидском старриджа если вдруг от немножко падает то на его место встает другой фактически стекла с планировщик и просто глядя на то состояние с которым он работал продолжает его модифицировать что может спать в элис тораджа ну типа лист не сможет потому что к сожалению не для того у нас предназначен угостить немножко другая технология который называется те самые горизонтальное масштабирование кивал историк по которым мы тоже не рассказывали кажется но я надеюсь что коллеги тоже разразятся докладом на эту тему за сим я покажу последнюю картинку как это будет выглядеть как он светлом будущем и по благодарю вас за внимание потому что на этом всё если вдруг кому-то интересно разрабатывать такие штуки туда у нас есть вакансия вот всем спасибо у нас к сожалению не осталось времени на вопросы но вы можете продолжить носит пять минут может один вопрос здесь вопрос а есть вопросы дотерам расспросим меня не тоже такой сложный вопрос ты сказал про то что у вас операции для там минуты и часы дни недели вот доклад называется операцией длиной в год были настолько длинные операции было чуть-чуть художественное преувеличения самое долгое операции которые мы смогли найти текущий момент работал окажется 10 месяцев 10 дней вот и продолжать бежать вам честно про спасибо вы вначале показывали то что у вас на этом вроде уйти до называется кластере таких контроллеров несколько 10 вот во время все все презентации говорил с к вот он один потому что они я сказал в момент про горизонтальную масштабируемость процессы планировщика они друга друга независимо и скажем если у нас есть там 10 операций сейчас бегущих пять из них могут обрабатываться одним процессом 5 другим это процесс они независимы друг от друга делают снапшоты того что в них находится независимо принимают соответственно изменение от уровня кластер делят кластер то один а это хороший вопрос эту часть доклада я не стал подробно раскрыта скрывать потому что она относится на самом деле к честности и на слайде про честность там есть такое упоминание некоторого еще одного компонента наша система которая называется как он там называется он называется вид кажется resource manager на этом слайде и ресурса локатор да потом для ресурса локатор ответственна за то чтобы делить в каком-то смысле между ними кластер а дальше они уже с тем что им выделено работают до вы правильно заметили что это не была покрыта в докладе ну сожалений так выдался на 5 минут из времени так что этот летчик 4 1 носила ну собственно глупый вопрос одно а почему snapchat и почему не райта hotlog дальше через восстанавливается потому что нам нужно в этом месте реактивно и вся вот эта машинери с райта хоть логом она будет конечно медленнее чем принимать изменения в память возможно позволяет себе иногда читать не очень свежее состояние и них мы не хотим чтобы на горячем пути у нас были например походу на дисках для любого изменения снаружи опять же повторюсь это батч нагрузка batch нагрузка она для нее ok если я потеряю там скажем не знаю там два процента времени на том что буду периодически проигрывать то что из-за приключением планировщика я потерял нее важно как бы с точностью до большого порядка сколько времени сколько тепла часов я использую и то что я периодически что-то переигрываю это не так страшно но да как бы можно было бы в этом месте действительно сделать какой-то этих и блок какое то значит честную репликацию состояния контроллеров найти на несколько машин и теоретически возможно зона последнее решение последняя которое про распределён кирилла столь уж так я уже не до криков сожалению до него и он он в каком-то смысле проект а потому что под капотом у нашего кирилл истории жив в точности то что вы сказали так еще какие-то вопросы есть можно еще минутка есть а вот контроллер он многопоточный или в один поток просто чтобы вот флешка делается там хороший вопрос обработка событий одним контролем производится в один поток внутри одного процесса разные контроллеры могут обрабатываться действительно разными thread'ами скажем так параллельно но события внутри одного контроллера у нас обрабатывается в один поток и никакой необходимости не синхронизации внутренне там каких такого сложного понимания что в точности там после форка происходит у нас нету по факту for делается на целый процесс но после того как мы после барьера при котором мы останавливаем изменения всех контроллеров мы дожидаемся того что все контроллеры останавливаются это вот вкладывается в те 10 секунд которая простой возникает после чего форме весь процесс и дальше все то что я говорил можно еще вопрос да почему фриз аркан фриз а не скажем можно было сделать состояние контроллера и минута был использовать обжиг пол для того чтобы это не было много локаций и тогда не нужен был бы фриз просто прикапывал прикапываем старую версию состоянии потому что такие персистенции структуры данных они тоже дорогие с точки зрения циpкa скажем если так пытаться делать скорее всего вся обработка событий замедлится в какие-то разы а у нас не то чтобы я сейчас запас на это ну там можно было бы действительно делать так так так кто вас координирует вопросы там вопрос можно что-то не понял почему не складывать результаты job кипарис и отдавать контроллеру только ссылку на нее вот и тогда не надо будет дамп один гигабайт и заодно у нас всегда есть ли джога завершилась вот и результат и почистите и значит ответ на вопрос такой потому что сейчас кипарис не готов к такому потоку изменений как я показывал на картинке там было порядка десятков 30 машин которая таки полезно себе держат и там сейчас не такой большой простор для горизонтальной масштабируемости но в целом замены слова кипарис на слово kevin vista ридж про которые ничего не рассказывал но поверьте он у нас есть он у нас классный это рабочая схема который мы возможно когда-нибудь в будущем приблизимся так мне кажется сейчас меня будут ругать так что давайте мы закончим я сразу отвечу на ваши вопросы ну а вот а тем временем а тем временем тем временем ага нам нужны два лучших значит мне понравился вопрос про это hotlog почему бы не делать так вот давайте товарищем а вот и второй не знаю например вопрос про пир стен той структуры коллеги с первого ряда вот всем спасибо"
}