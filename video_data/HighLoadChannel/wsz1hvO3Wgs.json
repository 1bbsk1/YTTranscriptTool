{
  "video_id": "wsz1hvO3Wgs",
  "channel": "HighLoadChannel",
  "title": "Function as a Service in private cloud / Сергей Рыбалкин (Alibaba Group)",
  "views": 443,
  "duration": 3079,
  "published": "2019-05-15T02:30:34-07:00",
  "text": "всем привет да начинать меня зовут сергей рыбалкина и сегодня мы поговорим рим с вами про к про частные облака и про так как в них уживается такая сущность как системы фонтаны за сервис пока вы читаете вот этот слайд читайте на пока вы читаете эти этот слайд давайте я задам несколько вопросов во первых скажите мне пожалуйста кто здесь у кого есть production deployment над живими хорошо продакшен deployment на код ли не и вообще есть котлин в каком-то виде в продакшене так а кто использует вообще микро сервисы и у кого вот развит микро развита микро сервисной архитектура хорошо и наверное последний вопрос а кто вообще когда-либо уже пользовался решениями например amazon линдой клауд фонтаном и прочим прочим прочим хорошо вас не так много вас ну процентов 5 тут наверное тогда наверное будет интересно обо всем этом послушать давайте расскажу немножко про себя я инженер в российской команде российской аренде команды alibaba group примерно 9 лет я занимаюсь брендами и последние два года я пробую что-то делать с подлинным ну как пробую использую его в продакшене примерно год уже а до этого начинают наверно из версий 10 я как-то с ним играл найти меня может на гитхабе или в твиттере по соответствующей ссылке кроме того что я работаю alibaba group я ещё читаю лекции в м группа джаве и котле ну соответственно с недавнего времени давайте пойдем по порядку сначала я попытаюсь вам осветить вообще как мы пришли к такой концепции как фонтена за сервис в alibaba group примерно расскажу о нашей этой системе и что мы с ним с ней делаем и какие проблемы у нас мне есть у нас все начинается с данных данных у нас очень много это наверное уже экзабайт и эти данные каким-то образом процессе от сервисы сервисов очень большое количество десятки тысяч сервисов в каждом конкретном бизнес unity который занимается своими вещами своими бизнесами ко всем все эти сервисы как-то между собой общается и есть определенный битвы и через которые они ходят в друг друга или же наши фронтэнда к ним ходят фронтэнда это либо мобильные приложения либо лаптоп либо писи либо м сайты да что угодно если посмотреть сверху вниз на всю эту систему вот все эти бэкенда фронтэнда во front-end ах у нас есть android ios мобильные сайты и писи версии бэг-энда соответственно у нас крутятся вместе с андроидом на джереми там где то есть например плохо где то есть обычная java где то есть котлин или еще что-то другое с точки зрения ios у нас есть свифт и объекте все если брать уже конкретно мобильные сайты и писи то есть то что у нас находится в браузере это какой-то относительно темный лес для меня как для блендера но где-то там есть java-script если взять один конкретный сервис то его среднестатистическая картинка будет выглядеть так где то в глубине у нас есть докер на нем каким-то образом стоит джи-ви им неважно какая это либо это наша собственная эйджи m&g dk либо оракал овская либо open source на и поверх всего этого у нас каким-то образом крутится спринт boots придут позволяет некоторым образом скомпоновать части стандартного приложения которые нам нужны то есть это api например security это какие-то пас конфигурации конфигурации и еще куча куча куча всяких разных описок и поверх этого у нас есть публичный и перед которые у сервиса торчит наружу через который с ним могут общаться все общение проходит по нескольким протоколом здесь не все но то спорту в частности бывает таким это и что тебе это какой то м т или рпц и все это торчит в diy твои и все это дальше отдается другим сервисам фронтэнда или еще кому-нибудь и вот мы столкнулись с проблемой вот вы видели всю эту систему а теперь давайте попытаемся отыскать в ней именно бизнес код который пишет наш разработчик для того чтобы решать конкретные бизнес кейсы и вот он там маленький зелененький и а все вот это остальное это просто обвязка которая помогает нам работать то есть это фактически для конкретного разработчика это бойлер plate и мы лишь захотели как-то бороться с этой проблемой то есть логичное решение вот этот весь код который чуть-чуть торчит фабрикой пиа и чуть-чуть затрагивает собой spring but стартер и его как-то вынести и разрабатывать его обособленно что же получается когда мы разрабатываем такие сервисы например это у нас может быть платформа за сервис и приложение и мы контролируем именно уровень приложения мы разрабатываем сами тоски то что на от нас хочет бизнес а потом мы занимаемся рутиной которая нужна для того чтобы это все зарелизить для того чтобы поддерживать наш кластер для того чтобы решать например какие-то security проблемы и наконец последняя но тоже важный скиллинг приложение вообще-то говоря сложная штука и делать его вручную вот вообще не хочется и тратить на это время тоже не хочется кроме того есть множество сервисов которых пиковая нагрузка до или вообще нагрузка приходится на исключительно фиксированные периоды времени или периоды времени которые можно предположить вот а во все остальное время примерно мы имеем три процента цепью утилизации и вот эти три процента в среднем уходят на того чтобы на то чтобы просто собрать мониторинге с этого конкретного сервиса вот такая примерно картинка может сложиться давайте теперь посмотрим а что будет если мы пойдем в мир сервер лес и что если кто-то другой будет поддерживать за нас все эти машины а мы займемся собственно мы бы киндеры или люди которые пишут код займутся тем что действительно умеют они будут все таки писать код и тогда единственное что останется сделать им это пройти тесты которые нужно чтобы в какой-то контур вот этого сервера лоис окружении докатиться а потом и в продакшен мы выявили из кейсов при которых такой подход действительно хорошо для нас работает все началось вообще говоря с артист рации других сервисов то есть у нас есть какое-то количество функций или сервисов мы хотим каким-то образом совместить результаты их работы обратиться каждому из них и потом отдать пользователю ответ основанный на том что эти сервис нам сказали кроме того важные задачи для нас было например сделать фасады для определенных и 5 то есть у нас есть и пить но почему-то наш мобильный разработчик вот сейчас не может прямо его использовать то есть например там другие типы возвращаются или ему хочется дополнительный mapping в этой ситуации как разумно поступить мобильному разработчику либо он идет к бы кондером или monte nero сервиса и просит предоставь мне пожалуйста новый api майн тренер этого сервиса говорит ну извини у меня на месяц вперед еще расписаны тоски и ничего не может сделать и в такой ситуации именно мобильный разработчик может пойти написать свою функцию которая для него этот мы просто mapping сделать то есть там буквально пару строчек кода которые могут сэкономить ему месяц простое как же это все выглядит в итоге центральное место у нас занимает функция функция это что-то преобразовываю щи и свой input в какой-то out put в качестве входных параметров в нее поступают события и вот у нас вся обработка в этих функциях она событий на ориентирована все эти события должны в какой-то степени пройти security и должно быть понятно что у нас это событие безопасны после того как security пройдено у нас есть какой-то роутинг который позволяет доставить это событие до определенной функции определенной версия и это все как то специфицированы в свою очередь функция уже должна уметь общаться с другими функциями другими сервисами и отдавать свои результаты во все фронтэнда которые у нас есть через ветвей давайте посмотрим на точку входа в функцию собственно под здесь и далее приведена код леня здесь мы видим какой-то хендлер принимающий event id определенный контекст и возвращающий нам простое простой респон в котором говорится что все хорошо привет теперь рассмотрим вообще плюсы использования такого подхода и использования таких функций не в частном облаке а в любом то есть в первую очередь это то что наш разработчик цель которого решить определенный бизнес кейс просто перестает тратить время на то чтобы заниматься operations то есть операциями которые должны весь этот под поддерживать он получает из коробки авто с кейлин которым занимается уже платформенные инженеры у него просто все работает и наконец осуществляется платеж именно зато какую часть ресурсов ты смог утилизировать и как следствие это позволяет успешно и с большим профитом утилизировать ресурсы дата-центров а теперь давайте сразу к недостаткам то есть все конечно хорошо но новый каждый уровень абстракции привносят нам свои недостатки в первую очередь потому что поскольку система событий на ориентированы у нас наступает некий леденцы которые возможно выше чем в системах например предкам это сервис который мы привыкли и тут же возникает проблема холодного старта например если у нас нет никаких поднятых уже инстансов функции и нам нужно поднять 1 или же например если нам нужно прогреть то тот или иной instance поскольку мы все-таки вертимся в джереми ментальная проблема это количество ваших функций очень вырастет если вы начнете ими пользоваться если у вас раньше были микро сервисы и у вас по сути был такой мозг в которые приходят сигналы и которые пытаются их обработать и дальше отдать результаты то теперь у вас очень массивная связность появляется и вам с этим придется что-то делать в частности вам придется скорее всего самых первых паров если вы делаете такую систему вам придется делать полнотекстовый поиск по этим функциям делать хорошие versio не рование интегрироваться системами контроля версий нет х будет лап или что у вас там есть наконец сдвинемся уже в сторону частного облака кроме всех тех плюсов которые уже были обозначены есть следующем мы можем делать для пользователя sdk который соответствует его необходимости то есть мы в частном облаке знаем на что чаще всего обращает внимание пользователей что он чаще всего делает и как ему помочь то есть например у нас ecommerce мы часто работаем с заказами мы часто работаем с транзакциями соответственно мы можем отправить этот функционал вплоть до того что он будет находиться в sdk далее touring the link это вообще очень важная и если например мы находимся в ядре то нам бы очень хотелось знать вот например мы работаем с тем или иным заказам а что мы можем с ним сделать мы хотим знать с помощью например статического анализа или con комп лишена что вообще в данный момент временем можем написать если брать уже разработку платформы то имея частное облако единственное что для нас важно это чтобы наши клиенты были довольны но это понятие расплывчато нам важно чтобы все функции выполнялись и функции отдавали хорошие результаты не падали ну если не брать какой-то трэш холл допустимой падение функций исключая это мы можем делать все что угодно вплоть до того что мы можем написать кучу кучу кучу этих функций в один контейнер за деплоить его дамы а гребем какие-то проблемы но зато мы с оптимизируем наш сервис когда разработчик пишет какую-то функцию нашей системы мы можем используя все тулы мониторинга вообще понимать что он делает мы можем это отслеживать мы можем смотреть какие exception а у него вылетают что происходит с его кодом или может он что-то не обрабатывать что хотелось бы и дальше привносить это все в sdk и отдавать определенные alert а вот какие аспекты у нас негативные аспекты у нас исчезает если мы переходим в частные облака потенциал потенциальный лог на того или иного вендора это мы нам с этим хорошо и дальше будет житься отсутствие контроля за стоимость у нас не касается поскольку железо нашим и все под себя лакируем все подбираем и это проблему решают наши наших датацентрах и наверное самое главное для нас что было для того чтобы начать эту разработку это отсутствует разглашение нашего трафика то есть нам бы очень не хотелось чтобы например какой то оператор публичного облака знал о том сколько вообще капец нагрузка ложится наши сервисы обработки заказов на наш поезд или еще на что-либо если рассматривать всю систему фонтена за сервис то оно делится на две огромные части первое это девелопер experience это то что чувствует разработчик это через чем оперирует разработчик когда собственно реализует свои бизнес задачи и разрабатывает код и это важно потому что у вас функции очень мало кода это как вы его напишите и насколько быстро сможете в нем разобраться это очень важно и сама платформа это те оптимизации которые мы можем сделать это то как организована работа с со всеми функциями это в наш deployment эта сборка это все все все давайте начнем разговор с developer's экспирианс а самое главное на что мы смотрели когда разрабатывали эту систему это вот эти пять аспектов то есть нам важно чтобы у нас был очень безопасный runtime чтобы мы не вывалились какими-то класс каст exception номинал pointer exception нами и прочим прочим мы очень хотели и до сих пор хотим чтобы как можно больше кода умещалось у нас на одном экранчике то есть идеальная функция это так который умещается в 80 строчек кода и поэтому у нас не должно там быть бойлер plateau мы хотим чтобы было консистентная sdk то есть sdk которая хорошо и примерно одинаково работает с разными datasource сами или системами транспорта и мы хотим библиотеки в нем которые именно хороши в нашей доменной области и что важно чтобы наши разработчики могли достаточно быстро втянуться в это и выучить это если это новый язык кроме того вот еще два фактора которые наложились из-за того что наш дипломант основан на живым и то что у нас очень много объекте все и свифта то есть все это вместе подталкивает к выбору таргет языка платформы и мы несмотря на то что у нас огромный deployment на javi выбрали для этих целей котлин сейчас я расскажу вам примерно почему давайте сразу рассмотрим кейс нам нужно написать сервис который подсчитает количество продаж айфонов на наших платформах в течение последнего дня здесь примерно 20 строчек кода они решают всю выше поставленную задачу то есть нам нужно обратиться в тимол taobao и aliexpress и посмотреть сколько же в каждом из этих серверов сервисов заказов было исполнено давайте по порядку есть после не такая сущность как контракт на операторов то есть мы вы видите у нас функцию поступил ивент в этом ивенте есть определенный продукт айди это то с чем обратились в нашу функцию мы достали и to produce т.д. это позволяет нам сделать такая штука как контракт оператора контракт оператора дед записаны примерно таким образом после этого как мы видим что у нас не обязательно есть ивент в в этом ивенте не обязательно есть product айди и если его все-таки нет то функция вообще перестает иметь какой то смысл и нам бы нужно скорее из нее выйти и все это вместе то есть либо у нас есть функция либо мы уходим и либо у нас есть продукт айди либо мы выходим из функции можно легко записать в одной строчке и на выходе мы получим объект который является продуктов айди продукта и при этом это точно не нал он точно есть далее что нас очень привлекло и что нравится нашим разработчикам это возможность довольно эффективно и быстро оперировать теми или иными коллекциями последовательностями или чем ты чем-то по схожим то есть мы можем взять например наш списочек можем по нему проектироваться для каждого элемента что-то вызвать и потом получить условно говоря сумму того что будет на выходе при этом это все вот то что я здесь показываю находится в стандартном sdk подлинно и наконец общение с внешними сервисами то есть мы можем делать такие штуки которые называются dsl это позволяет нам вот в виде таких очень похожих на jison чеки кусков кода при этом полностью компилируем их обращаться например делать рпц вызовы то есть в данном случае приведён какой-то элписе вызов который вызывается для каждого элемента из нашего списка он идет на наш сервис заказов в определенную группу либо тимол либо тообал либо aliexpress и дальше отдает этот produce т.д. все это доступно и можно записать примерно в таком достаточно небольшом кусочке кода в котором у нас есть герпесе контекст там группа версия метод который будет вызван нашей функции и наконец сам рпц кол все это нам позволяет сделать такая сущность как лямда с получателем то есть по сути мы можем отдать последовательность действий которые можем потом провести над объектом который будет создан уже в этой функции теперь посмотрим на функцию внутри всей этой системы то есть у нас есть какой-то хендлер который возвращает какой-то response и нам бы хотелось общаться еще с очереди сообщений с общаться поищите типе или общаться по рпц с каким-то гид время причем все эти вызове можно оформить примерно одинаково то есть учтите piguet тычьте типе пост и рпц пол вот примерно это будет видеть наши пользователи когда будет разрабатывать код как я уже говорил для нас важно было удержать консистентной в sdk то есть здесь приведен пример того как мы взаимодействуем через http post и через р писи вызов то есть что вы можете здесь видеть то есть мы примерно одинаково декларируем куда мы обращаемся будь то это хост с путем будь эта группа и метод а дальше мы передаем в каком-то приблизительно одинаковым формате все аргументы с которыми мы куда-то идем и для пользователя как мы уже наблюдаем это примерно идентичные операции он легко переходит сочтите пи вызова на записи вызов а пользуясь случаем прорекламирую библиотечку которую мы смогли вынести из нашего закрытого мирового пан source а она отвечает вот за вот эти все эти типы вызовы которые здесь про декларированы вы можете взять оттуда ds и для весь египет гетто поста и прочего прочего там есть асинхронные вещи для асинхронной работы с http есть менеджмент connection pool а разберемся теперь с метриками которые важно снимать с рабочего окружения нашего разработчика все действия ну или большинство действий пользователей так ли на или иначе хотят совершать в какой-то в формочки где есть определенные этапы нашего релизного цикла или отправка на тот или иной тестовый контур что нам важно нам важно понять куда идет там пользователь какие кнопочки он там и про это где проводят большую часть времени потому что всё должно быть примерно в одном месте и у него не должно быть непонимание какой следующий шаг нужно сделать при рожай был разработки мы собираем результаты компиляции внутри нашего и дыре или внутри в формы это позволяет нам понять например поскольку язык все-таки поскольку код лим достаточно новый для наших разработчиков это позволяет нам посмотреть что они делают неправильно такие ошибки собирают исходя из этого можно сделать например оптимизации синтаксиса внутри нашего sdk или что-то схожее например можно добавить какие-то проверки в нашем статическом анализаторе кода и или какие-то проверки с ворден гав переместить в ошибке компиляции еще очень важно предоставлять дашборд который говорил бы о том какие exception а у нас где-то там вылетает но это поскольку у нас все таки мир живым то есть мы например собираем на лбу interception случайно там где нам не хотелось этого делать в итоге приходится переделывать api тех или иных библиотек для того чтобы это наконец стало удобно для пользователя давайте наконец перейдем к самой платформе то есть всему тому что отвечает на вопрос как предоставить пользователя тот api чтобы он ни о чем не беспокоился вот примерная диаграмма передвижение с момента того передвижения наших образов или каких-то артефактов с того момента как код был написан то есть у нас есть какой-то код который достался нам от разработчиков и у нас есть некая specs которая говорит вот у этой функции определенная версия или мы хотим все таки за таргете цена определенный базовый образ после этого идет сборка сборка может происходить разными способами то есть вплоть от того что у нас есть мы иван или грейбл build либо что то другое то есть мы собрали условно говоря какой-то jar ник после этого этот жар ник мы можем тем или иным способом упаковать в контейнер контейнера дать системе мониторинга и скиллинга чтобы это не было и там дальше происходит уже какая-то магия скиллинга что же мы тут можем и хотим оптимизировать самое важное для нас это чтобы количество инстансов функций соответствовала нашему ожидании то есть нашей условно говоря очереди ивентов или расписанию которых с которым будут вызываться эти функции если например у нас какие-то крон джаббы в данном случае исходя из этого важно чтобы у нас был как скиллинг вверх так и стилинг вниз причем стилинг вниз вплоть до отсутствия инстансов то есть стелим в d0 важно чтобы пропускная способность функций было достаточно высокая то есть если у нас высокая пропускная способность функции то нам просто не нужно в какой-то момент будет скейлится и важно чтобы у функции был функция достаточно быстро стартовала и ее не нужно было прогревать например если мы говорим данном случае про от живём для нас все оптимизации начинаются с разработки и sdk то есть что на что мы здесь можем повлиять мы можем в первую очередь повлиять на сруб ут-1 конкретной функции мы активно используем к рутины в продакшене для того чтобы предоставить асинхронная не блокирующие и достаточно простую работу с многопоточность и мы предоставляем в первую очередь поддержку асинхронного и не блокирующего доступа для наших библиотек которые мы отдаем пользователя и наконец мы очень любим бесплатная абстракции в нашем случае поскольку мы на код ли не бесплатная абстракции это онлайн класса и онлайн функции и майн класса кстати появились совсем недавно в пробной версии еще только то есть они видоизмениться могут все еще нам очень нравятся картины по той простой причине что мы не можем себе позволить запустить внутри 1 1 год живьем а например 10 или 100 тысяч thread'ов но это дорого и вообще не рентабельно хотя при этом мы можем запустить даже больше миллиона крутин на одну джи-ви м при этом я вам с немного обманул вот видите слово саспенс перед в декларации нашего метода на самом деле вот в нашей точки входа есть слово со спин которая говорит о том что эта функция может быть прервана это ключевое слово котле на если переходить на уже внутрь наших библиотек то вот на этом слайде можно увидеть то как примерно меняется с точки зрения платформа вызов рпц если мы переходим уже внутри на к рутины то есть у нас добавляется из того что тут выделено некое слово десерт которая примерно соответствует бро ми су либо какому-то фьюче и добавляется такая штука как асинхронный вызов рпц метода внизу это сущности которые дает нам подлинно которые мы можем эффективно использовать скрути нами зачем это все нужно и тогда это хорошо применять хорошо это применять в первую очередь когда у вас есть задачи которые орел баунти то есть вы чего-то долго ждете ждёте ответа или читаете пишете что-то вообще вы могли бы мне сказать что ну есть куча разных способов например давно уже придумали call бете или уже давно есть рыб java или какие то другие комбинаторы которые позволяют нам вести а синхронную работу да это все хорошо но если мы действительно заботимся о том что будет с нами делать пользователь и какой код будет писать пользователь то это все становится не очень удобно мы хотим чтобы функция в принципе ну никак почти не отличалось от обычного 1 поточного кода который где-то там будет написан на наших сервисов и q рутины нам в этом очень помогает потому что это способ писать под в императивном стиля но при этом асинхронный давайте обсудим теперь два подхода к изоляции 1 когда у нас каждая функция крутится в своем контейнере где-то там и все это билл детсаде плавится тогда у нас бил стечь эта простая упаковка jar файла стадия когда мы что-то диплом это просто разворачивание докер-контейнер а в котором этот жар farmer jar файле книжек или можешь там лежит jar файлик и еще что-нибудь тогда получается что одна функция это все еще один контейнер и у нас время старта нашего скалирования от нуля до единицы это ровным счетом время старта нашего контейнера вроде как это довольно типичная ситуация и она в многих кейсах нас устраивает то есть например если у нас есть запланированная какая-то работа например по расписанию мы заранее просто каким-то образом можем поднять нужное количество функций которые мы знаем что вытащат нашу нагрузку и все будет хорошо или если у нас есть асинхронные вызовы функции которые в которых нам не важен быстрый ответ например если условно быстрый ответ не важен например если мы делаем какой там а придешь мы потерпим если у нас еще функция будет подниматься но в случае если нам скалирование с нуля до единицы нужно очень быстро и такой подход нас не совсем устраивает и в данном случае на помощь приходит такой термин как мультитональность что это значит это значит что внутри например какого-то контейнером и по тем или иным соображениям можем поместить несколько функций какие могут быть соображения например функции которые мы туда поместили имеют примерно одинаковую природа то есть у них абсолютно одинаковые библиотеки используется внутри и мы поэтому можем объединить потому что наша наш jar-файл и наш все что мы собрали не поменяется от этого просто засунем все вместе сделаем там какой то роутинг внутренние все будет хорошо то есть у нас есть много функций которые мы можем платить в один контейнер в такой ситуации фактически скалирования до нуля у нас отсутствует то есть мы каким-то образом складываем весь вместе все функции которые так или иначе не используется а потом в нужный момент если нагрузка возрастает мы выносим так или иначе часть этих функций в отдельные контейнеры но за это отвечают уже наш модуль который занимается of those келенган ну и наконец важный вопрос вот у нас живем мир и казалось бы какой джим мир без спринга spring довольно тяжеловесная штука то есть если у нас есть таргет например функции выполняется за 100 миллисекунд то может быть достаточно проблематично подняться от нуля до единицы а потом еще отработать вызов нашей функции стандартное приложение на спринт будьте например в котором есть только в флакс или в этом весе за стартует примерно на хеллоу ворлд стартует около одной секунды если у вас в команде есть инженеры которые могут определенным образом для вас выполнить шаманство назовём это так поработать с вашим спринга вам то есть металл вера инженеры они могут чуть-чуть это все сократить но колоссальной разнице не будет но существует способ--и того как можно разогнать spring-a об этом например пишет дэйв одном из своих блок постов и вообще на последнем spring платформ слайд взят у него есть презентация то есть например можно сделать так что spring будет будет стартовать в районе 40 миллисекунд но тут все не так просто возможно кто-то из вас слышал про то что такое гравием это такая и head of time компиляция которое есть в java мире а теперь не только лег java то есть что мы можем сделать мы можем скомпилировать наш код ahead of time и потом это все за деплоить и это все достаточно быстро будет стартовать при этом мы понесем потери у нас будет очень сложный дебаг или даже отсутствие дебага мы будем нарушать джеймс пеппу и будут еще всякие разные проблемы но самое главное что скорее всего в перспективе даже приложение со spring бутон будет возможность запускать в довольно сжатые сроки покажи этого делать нельзя или вы боитесь использовать ahead of time вы можете прибегать такому мальте теннант подходу то есть паковать несколько функций внутри одной венки давайте подведу итоги services подход и фаз в частности позволяет нам очень сократить время которое проходит с момента получения требований до того как эти требования появляются уже рабочие и в продакшене девелопер experience для нас это хорошо проработана sdk консистентными sdk который может общаться со всеми компонентами нашей достаточно запутанной и сложной системы которая раньше была микро сервисной это хороший touring который позволяет разработчику быстро и грамотно дайте найти написать те куски кода которые собрать как по конструктор кусочки кода который позволят ему собственно выкатиться в продакшен побыстрее разработчик функции это человек который ориентирован на решение бизнес кейсов разработчик платформы человек который ориентирован на то чтобы у разработчика не было головной боли связанной с тем чтобы быстро запускаться и эскалировать все эти функции у меня на этом все спасибо за внимание ваши вопросы спасибо большое я совершенно не джавис но тем не менее я правильно понимаю что функции вызывают друг друга через битвы да тогда такой вопрос у вас насколько глубина вызовов в реализуется потому что сетевые задержки и все с этим связанное насколько быстро nitro это или связки спасибо за вопрос это thread'ов собственно как было сказано функции это что-то что у нас и вендре вам подход пропагандирует то есть у нас есть event который функция бросит другой функция через gateway соответственно если мы пользуемся таким подходом то скорее всего мы готовы ждать и готовы к тому что будет у нас происходить в данном случае на практике я не видел чтобы вложенность было больше пяти если я не ошибаюсь то есть этого хватает чтобы влезать в наш условный трешолд например 100 миллисекунд на вызов такой функция спасибо большое спасибо за доклад хотелось спросить насколько у вас большой хит получается на по памяти из-за того что приходится си реализовать дети реализовать данные между функциями и получается у вас на уровне платформы реализованы функции для доступа не по http и рпц а например к базам данных да давайте с конца начну отвечать во-первых базам данных по крайней мере сейчас мы не обращаемся из наших функций мы делаем это через сервисы или микро сервисы которые торчат к базам данных или какой-то их части это позволяет нам на данном этапе развития нашей платформы абстрагироваться от всех тех проблем которые принесет нам прямое общение с базами данных по поводу ограничений по и накладных расходов связанных с реализацией здесь и реализации у нас есть собственные механизмы которые вот си реализует здесь и реализует все эти винты как показывает практика вот самый вент занимает в среднем не больше одного килобайта на то чтобы это все отправить то есть нас это устраивает сейчас и пока даже развитие в эту сторону мы не планируем спасибо день добрый спасибо запрет рассказ соответственно вопрос следующий у вас когда происходит передача сообщения от одной функции другой могут произойти потери сообщений в принципе теоретически из-за того чтобы говорить что часть функций вас может быть прервана вообще какая поддержка со стороны платформа по отладке данных ситуаций у нас есть система сквозного мониторинга и треккинга всех этих событий то есть как только вы например выше откуда-то пришли в эту функцию маловероятно что вы ее вызвали сами но только если закладочных целей таких вы скорее всего пришли в нее через какую-то веб-страницы как только вы туда попали получилось так что вам вашему сообщению или вообще вашим январе еще но был присвоим третьем давай иди дальше эд отойди будет протянут вот все по всему дереву вызовов который образуется если от одного вызова другому если функция вызывает другую функцию когда мы пришли в тот или иной день твой соответственно если что-то из этого дерева или графа отвалится мы увидим это на мониторинге когда будем трекать тот или иной айди тот или иной вызов которые у нас плохо завершился ведь это образ то есть грубо говоря готова к тому что на фронт упадет ошибка мы готовы что количество ошибок упавших на фронт будет не выше чем определенный процент ну и вы будете об этом знать там еще такой забрали на вопрос ну просушил и сказали про контекст которые таскаете вот контекст безопасности у вас есть права доступа и все то куда там на слайде где было показано функция в контексте января это было показано что до роутинга у нас есть вся проверка безопасности ивентов то есть event может ли он вообще попасть ту функцию к вот инициированный конкретно вот этот вот а эта часть платформы это так скажем сервисная часть которая достается нам на данный момент в наследство от инструментов которые у нас есть в alibaba круг спасибо большое и день добрый мой вопрос насколько версии одной этой мысли у вас есть и как долго вы вы их поддерживаете простите можете повторить пассажире на слышно у вас же все функции изменяются со временем и есть в веб-версии 1 то живу функции как долго вы вы их поддерживаете как вы выводите из эксплуатации ну во-первых до версии есть в слайде который давайте покажу вам есть такая штука как specs у каждая функция в частности в ней мы можем прописать определенную версию которая имеет вот эта функция которую мы конкретно сейчас будем деплоить абсолютно не наше дело как инженеров платформы сколько версии будет у пользователя на ту или иную функцию когда выводить их из эксплуатации это их личное дело и дело их бизнеса то есть наша задача подержать versio не рование функций и роутинг на конкретную версию то есть если вы являетесь клиентом функция вас интересует либо две вещи либо вы торги тесь на lightest версию функции либо вы торгуетесь на определенную версию функция вот это все что мы так инженеры платформа должны поддержать микрофон пожалуйста с метро то есть вы вы поддерживаете все versiv функции на которые все все завязались да то есть мы знаем какие функции вообще вызываются мы знаем какие функции вызывались соответственно мы в какой-то момент сможем или возможно даже захотим ввести ту или иную процедуру депривации функций но на данном этапе развития нам это неинтересно добрый день а добрый день можно вопрос кто вас вообще порядок функции сколько их ну их меньше чем десять тысяч вот примерно такой порядок и да каждый функцию отдельный инстинкт правильно нет ни для каждой функции отдельной инстанция некоторые из них сгруппированы по характерным признакам например если некоторые из них вызывается очень редко они например попали в внутри одного контейнера вместе или по каким-то другим признакам сгруппированы так они возникают при таком масштабе проблемы с роутинга проблема с ротен дам не возникает возникает проблема если у нас внутри одного контейнера внезапно на вернулась одна из функций тогда мы соответственно рискуем тем что весь контейнеры все функции которые в нем за тепло и на просто-напросто сейчас сломается ну соответственно дамы что-то оптимизируем и мы осознаём риски с которыми мы это делаем роутинг как в данном случае работает то есть у нас есть условно говоря какой-то реестр того что крутится в том или ином контейнере мы знаем идя в этот контейнер и отправляя сообщения на него мы знаем что там будет функция которая сможет нам ответить еще такой момент у вас полностью все сделано через функции ли у вас ну то есть полностью такой подход используется ими частично нет во-первых это все еще только появляется это достаточно малая часть сервисов у нас была раздроблена на функции конечно у нас в большинстве систему микро сервисной архитектура конечно где то есть монолитная архитектура где то есть гибридная соответственно функций доля сейчас достаточно низкая по той простой причине что система появляется вот буквально только только появляется и просто еще не все во первых знают и умеет им пользоваться и что самое важное вообще говоря это сервер лес и phase technology в том числе и те что есть в panzar си они не достаточно стабильные у них не достаточно стабильной api и еще мало опыта их промышленной эксплуатации поэтому конечно все что у вас есть например я не рекомендую переносить на amazon iam дуэли в угол клауд фанкшн но частично с этим можно экспериментировать и если ваши бизнес-кейсы удовлетворяет таким условием что вы можете потерять немножко например в альянсе то можно этим пользоваться то есть главным критерием это для перевода функции какой какой вы считаете для перевода функции то есть например нам просто не интересно в том или ином сервисы заниматься поддержкой всей этой окружающей инфраструктуры например versio не раване им giovanni интересно заниматься или какими-то еще пакетами то есть мы с дальше мы не хотим заниматься всем приложениям мы можем частично вот например версиями библиотеки или чем-то еще если мы готовы пожертвовать вот всем этим то мы можем уйти и сделать функцию если мы не готовы пожертвовать например тем какая какая версия библиотеки эти сериализации у нас будет приложение то нам нельзя идти и делать функцию вот универсального критерии нет простой критерий если у вас достаточно простая задача которую нужно решить например сложить два числа то идите сделайте для этого функцию и не парьтесь по поводу все обвязки которые вас будет если делать приложение если у вас что-то сложное работающая с базой данных то возможно в данном случае функции не для вас но какого-то универсального ответа к сожалению нет да мы развиваемся в эту сторону сейчас скажите спасибо первых за доклад отсюда вопрос так мне говорят что последний вопрос или вообще надо закругляться последний вопрос вопрос на самом деле у меня два первый вопрос это как вы проверяете на стадии разработки что вызываемая функция существует ну то есть вот в вашем примере вот эти группы и имя функции там было строков задам то есть это на как это проверять мне кажется и второе как вы работаете с кэшированием вычислений то есть ваш пример про сложение двух чисел бесполезно слаживать складывать 10000 раз 2 плюс 2 это можно просто кэшировать да но конкретно с кэшированием и сейчас практически не работаем у нас есть средства например стандартного кэширования через наши внутренние проприетарный софт есть например методы которые дает нам spring для кэширования чего-то более универсального у нас нет повторите пожалуйста первую часть вопрос еще до что валидны именно когда функция собирается или когда функция de pluie ца в один из этих моментов будет получено какая-то metadata от нашего сервис discovery мы проверим что есть те или иные компоненты которым хочет обращаться функция если в какой то момент мы будем эту функцию запускать и чего-то на самом деле нет то мы упадем но в момент того как мы когда мы будем тепло и то мы будем знать что функция валидно на этапе компиляции или на этапе тепло и зависит от обстоятельств все спасибо большое за внимание спасибо за вопросы"
}