{
  "video_id": "DFmdW5UwhjA",
  "channel": "HighLoadChannel",
  "title": "Основы индексирования и расширенные возможности EXPLAIN в MySQL / Василий Лукьянчиков (Станигост)",
  "views": 1570,
  "duration": 2845,
  "published": "2017-07-29T12:57:50-07:00",
  "text": "и парень набор параграф от редактора правда что обычно свой он хранит показать а сами-то продает девочки россия назад один жевал вам мамедова реклама или вы считаете вещи просто просто возможно глава 2 полагаю танка и потому что его поступки оборвали или врубай чтобы не давать подробности и эти качества не видно это есть еда была или положен соловский я всегда идет потому что еще случайно не радикулит можешь столом все как удалить причина вы сказали нам чтобы именно вам если есть и достаточно опустили и экзар удобно перевозить запасом на они в пятую первый раз два три 4 5 вот в этом вы имеете ввиду потому что у нас здесь идет первое неравенство он как упрется на бы где бы большего на нем ограничить использование декса то есть яндекс прекращает используется на первом же неравенстве и так а именно особенностью сквер то есть он берет константу константу потом неравенства и все это последняя часть индекс который он использует поэтому собственно составляя запрос оставляя индекс мы должны учитывать так чтобы по константам было как можно больше в яндексе потому что как только он ведь не нравится он уже для дальнейшей участи отбрасывают и не будет использовать то есть данном вопросе он использует около и беженцы не сможет в случае бы between это вот хитрость сейчас как раз хотела сказать здесь есть такой нюанс когда у нас например in 01 а between 01 ну понятно что это как бы игорь ковалентной формы и но будет и диапазон и там и там но в случае когда это один в список он понимает на самом деле что это много ширине диапазона заменяет на множественное условии равенства и в этом случае он будет использовать яндекс вот это как раз не на свой стиль то есть что нам нужно смотреть как писать либо списком либо берем либо ставить больше меньше всего найти и нюансы различает вот но собственно с этим связан какой нюанс во первых два слова про избыточных индексов соответственно если нас есть яндекса яндекс обед у яндекса будет лишь на потому что случае яндекс а.б. часть по может использоваться в нем поэтому нам нужно следить чтобы излишне избыточных индексов не было самостоятельных удалять понятно это соотносится случае когда оба индекс arbitration априори не кратно там fool fool текст то естественно может быть необходим и теперь вот с этим вот нюансам на вписке если у нас условия есть в b равняется то с точки зрения мы спели так его лента как а и 0 если она занимает принимать только два значения вот и мы можем заменить то здесь идея в чем мы сможем делать более широкий индекс уникально то есть если мы например сделаем индекс на b то просто условия бы использовать не будет но мы можем в приложении сделать так чтобы она самостоятельно подставляла пропущенные условиях там небольшой возможный вариант списка вот но с этим рекомендации то сейчас поэта чем я говорю вот нас это рекомендации нужно быть очень осторожным потому что несмотря на то что при наличии списка яндекс не отбрасывается дальнейшее использование он не может быть использован для сортировки то есть только на равенство поэтому если у нас есть запросы на сортировку то таким образом нам придется запрос и перестраивать так и вот видом через union all чтобы не было списков так использовать сортировку естественно это становится не всегда возможно и не всегда удобно поэтому с данной рекомендацией можно быть очень осторожно посмотреть если расширение индекса нам например позволит сделать яндекс покрывающим но покрывающий индекс это имеется ввиду что все поля которые выбил выбираются там используется в запросе присутствует в яндексе надо сервер понимает что собственно лезть в таблицу заданными ему совсем не обязательно целиком карп обращается к индексу для формирования результата так как как яндекс более компактен упорядочена хранится чаще всего в памяти каширина это более удобно поэтому мы при составлении диксов подворье какие нам индексу используем посмотрим всегда можем ли мы как-то подобрать покрывающие дриада нашего запроса прочего покрова еще раз я просто не слышал микрофон сдадут мы там написали два selecta их объединили почему нельзя просто написать также а иную 01 b равно 5 утра бойца и как вы все нормально почему-то они нормально не будет потому что при этом сортировка не будет использована то есть в том то и дело что когда у нас есть список мы съели обрывает на пена этом но продолжает использовать яндекс но он не сможет его использовать для сортировки вот в чем он продолжает использует дальше индекс но только на равенство поэтому если у нас будет условия и 015 ордер бойцы сортировка по индексу не буду не будет использовать будет использован файловая сортировка поэтому мы заменяем чтоб у нас было равенство равенство сортировка плюс нравится нравится сортировка самом так не делает то есть это нужно будет ли явно указывать ему руками очень хитрость вот естественно в случае когда у нас там большие списки мы не не всегда так имеем возможность делать и говоря union ах вообще если это такой нюанс сервер ромашки умеет использовать пересечении индексов например у нас есть условия или как бы или и на одном столбце или на разных столбцах а может понять что мы можем прочитать один индекс прочитать другой индекс эти результаты перец пересечь обработать и уже взять данные то есть методы использования совместных индексов но как показывает практика серверах редкого точнее сервер частенько их не использует там где можно было бы использовать поэтому если вы при работе видите запрос score это как бы указание явно что возможно нужно посмотреть внимательно план переписать через union чтобы использовать целиком это отключенные возможный сортировка по ключу и такой особенной shell не любит такие дела в вещи дел хотя умение порой делает ну и пойдем дальше про яндексе случае когда они используются индексы здесь собственно есть общие мяться с предыдущими другими базами например когда индекс являются частью выражения также как аналогичный поза крис он не сможет это преобразовать сделал в простейшем преобразований поэтому если у нас вопросе один плюс один равняется 3 индекс найди использовал не будет вы должны сами и переносить если у нас индекс является частью какого-то выражения мы также должны смотреть можем ему как мисс перри образовать также по yandex вынести в левую часть в явном виде аналогично за счет того чтобы не производит преобразование это не только математически это может быть несоответствие кодировок преобразование типов это же яндекс не будет использован яндекс не используется когда пропускается первая часть когда идет поиск по суффикса но естественный бег с не будет использовать когда идет сравнение с полями исходной таблице потому что в этом случае мы сначала нужно будет прочитать запись из таблицы чтобы сравнить использовать яндекс мы таким образом не сможем когда мы я говорил перед этим упоминал про покрывающий яндекс и чем они хороши и дело в том что сейчас вернемся на момент диагноз архитектура как происходит исполнитель передает запрашивает данные условия в у хранилище соответственно может чтобы быть если у нас есть условия на несколько частей несколько позиций они все могут быть обработаны внутри самого хранилища это оптимальный вариант может быть вариант когда часть условия будет обработано на уровне хранилищ по индексу мы хранили может появиться обрабатывать строки переданы на уровень вверх сам сервер и дальше сервер будет применять дальнейшее условия отбрасывать понятно это будет более медленно поскольку будет идти передачи самих записей из хранилища исполнитель поэтому покрывающий индексы тоже если у нас а не только в применяются для тех полей которые в запросе это все равно выгони потому что мы выбираем уже потом меньше строк ну и собственно по подобной оптимизация называемый индекс конечно он по ждал имеется виду всем у нас есть яндекс на три поля a b c понятно что в таких условиях раньше мы можем использовать только часть 1 вот и собственно казалось бы мы можем самом-самом хранилище по проверить and index это у нас там есть эти значения на раньше сервер этого не делал раньше я имею ввиду до версии мужские 56 мария 253 поэтому нужно внимательно смотреть на конкретную релизы что умеет делать сервер то есть в новых версиях сервер вы вы производит поиск по первой части индекса только по колонке а выбирают эти данные и прежде чем передавать уже в исполнителю axami записи он проверяет а как бы условия на вторые части и смотрит нужно ли убирать целиком записи или нет это естественно уменьшает количество тех записи которые нужно считывать с диска вопросы и к особенность ключей в и на д.б. это то что включи вы надо бы вторично они ссылаются на первичный ключ поэтому и поэтому фактически вторичную ключевой дыбы представляет собой вторичный ключ + указательный первичный ключ стиль такой длинный не да не виду индекс имеет невидимый хвост невидимая в том плане что раньше оптимизатора и волохова своих действиях не очень учитывал в чем идет речь у нас есть праймари ключ на b составной соответственно вторичный ключ это будет такой ключ как составной ключ на црб соответственно по нему уже можно проводить поиск вот такие образы когда вы работаете с колонками и нас таблиц минуты b и делаете индекс вы должны всегда учитывать что длинный первичный ключ это может быть либо хорошо либо плохо зависимости от того какие у вас вопросы the mood потому что он будет добавляться к всем индексом вот вы здесь есть нюанс в том плане что это оптимизация будет учитываться только для фильтрации строк но понятно о чем речь идет у нас отсортированном виде то хранятся только значение вторичного ключа указательными первичного ключа не уже не отсортированы по этому длинный такой вот невидимый хвост сервер сможет использовать только для условий равенство фильтрации срок это доступно в марии 55 мастер 56 переходим к плато запросов и и оптимизаторов ключевые ограничения оптимизаторы это то что он исторически использует очень мало статистики то есть он запрашивает хранилищ данные подробнее написано что учитывайте сервер может учитывать результаты вводимых команд то есть поля the cardinal и те индекс количество строк то есть довольно-таки мало данных при чем здесь есть особенностей еще том что изначально статистика вычисляется каким образом то есть мы запускаем сервер или там делаем какую-то команду типа alter вот у нас статистика обновляется потом таблицы живет живет живет какой-то процент строк меняется под основал статистика обновляется то есть бывает данные что еще сама статистика не соответствует распределению данных вот опять же статистика каждой храните выбирает по своему вот где то больше где то меньше в последних версиях реализуется идея независимой статистике то есть статистика на уровне сервера то есть выделяются служебные таблицы в которых единым образом уже независимо от механизмов хранения собирается статистика для всех таблиц причем если пир кони 56 это сделано только для индексов у них vdb то в марии 10 вашей дальше и собирает это тоже для не индексированных столбцов за счет чего оптимизатор может выбирать более оптимальные планы выполнения поскольку лучше понимает распределение данных оптимизатора не учитывает особенности хранились в плане что когда мы передаем запрос заданными в хранилище понятно что например в поезд по вторичному ключевой db будет идти дольше потому что мы пройдемся по вторичному ключу получим указатели на первичный ключ возьмем эти указатели пойдем за данными то есть у нас будет двойной проход например в мае сам это будет сразу же указать или непосредственно на сами строки за счет подобных нюансов относительную быстродействие тех или иных вопросов обращен может обращаться в одновременно к разным хранилищем оптимизатора не учитывает он не учитывает очень многие вопросы связанные с оборудованием то есть какие данные наса кашированные какие там буферы вопросы метрики то есть понятно оптимизатор выбирает наиболее дешевый планшет такое дешевый пласт точки зрения оптимизатора это с точки зрения оптимизатора план который имеет наименьшую стоимость вопрос стоимости это некоторая условность которая может не совпадать с нашими представлениями ней опять же сложность выбора это когда много таблиц и нужно их по-разному перемещатель смотреть и еще он использует правило то есть он например видит матча и понимает что нужно использовать файл текст индекса используют его причем не ипаться несмотря на то что у нас в условии может быть там к условию на первичный ключ который однозначно выдаст одну колонку будет использовать первичный ключ и здесь есть еще такой нюанс указанные две записи с нашей точки зрения эквивалентно вот ну с точки зрения сервера маркер нет в случае когда а больше 0 и меньше 0 он будет использовать поиск по диапазону а случай когда мы напишем то же самое через between он может это преобразовать в список и услуг использовать условие на множественные равенство какие нюансы не позволяют писать запрут здравый смысл с другой стороны удобна тем что повышает востребованность специально обученных людей по оптимизации мой стиль до вопрос но лучше не раз потому что в этом случае оптимизатор будет больше вариантов выбора потому что случае когда не нравится большего сразу вы раньше а тот он еще посмотрим может так может так и что выгодней но коротко как работает оптимизатора он проверяет запрос на тривиальность то есть может нам и вообще сделать запрос опираясь только на статистику индексов вот может быть мы запрашиваем отрицательное значение для колонки ади которые определенно положить сразу понимает что за запах мы запрашиваем за пределами диапазона это очень эффективный вариант с точки зрения быстродействия вот выбирает самый дешевый план казалось бы на основе предыдущего шнурки внезапно может делать очень мало вещей на самом деле виду когда он здесь мы говорим про преобразование запроса математически промерзания он еще применяет различные своей техники то есть например он под запросы может либо наоборот ухудшить как в старых версиях и сделок независимые зависимым или наоборот улучить как новых ты список на самом деле быть эхо тех некоторые делают очень велик это собственно начало таблички из документации марии db и нужно знать что скрывается за всеми этими словами в этом плане рекомендую смотреть документации на марии д.б. поскольку она снабжена понятными картинками иллюстрациями где можно понять только по картинкам что к чему относится ну и как вы уже влияет на оптимизатор мы можем переписать запросы переписать запрос это либо использовать эквивалентную форму записи то есть цветам например о заменить на union подзапрос имеет на join либо же переписать запрос кардинально разбив на части записали на какие не данные в промежуточный таблицы временные или же вообще не нормализовать таблицу избавиться от жернов индексы мы можем либо добавлять необходимые индексы либо смотреть можно достаточно обновить статистику подсказки оптимизатору и из форсы гнарз индекс то есть можем ему явно указать какие индексы стоит использовать соответственно для каких пиратством для сортировки для группировки прочего старой join это мы можем задать жесткий порядок объединение таблиц joint шаблон не перебирал различным вариантам и например за им какие-то особенности нашего распределение данных и знаем что нужно дело в таком порядке явно это указано optimizer switch это собственно включение и отключения вот этих вот всех конкретных методик оптимизации добавочных через эту переменную ну и последние две переменные они определяют как сервер выбирает оптимальный план плане шаг перед перебирает во все возможные варианты или отбрасывают понятно когда у нас много таблиц janitza он не будет несколько миллионов если точнее шел будет низко миллионов перестановок анализировать он может уйти на четверть часа в задумчивость а потом за долю секунды выполнить то есть такие ситуации случаются и поэтому с эти переменные по умолчанию не ограничивает время выполнения что приводит к тому что план может выполнить но быть выбран не оптимально и с точки зрения когда мы производим оптимизация может в плане тестирования изменить эти переменные чтобы он выбирал все варианты и посмотреть может быть более оптимально будет выбрав стер controls это страшное слово которое напрочь убивает оптимизацию на практике идея в чем мысли у нас есть запрос слиммит мы можем включить ключевое слово в запрос и серое нам при этом даст в том числе в ответе и общее число которое было бы выбрана безлимитно но это удобно кантри когда мы делаем pagination там странице вот этим грешат особенно все автоматические системы это очень плохо потому что запросы на аккаунт мой съели умеет оптимизировать очень хорошо но опять же в сложных случаев когда у нас там join и и группировки прочее отдельно посчитать количество строк мы можем переписать запрос также учесть объединений join of no tanto и мне потребуется сейчас группировок тоже чтобы получить ответа в общем количество страниц и то есть запрос с аккаунт будет проще и сервера использует на один запрос только один метод когда мы добавляем фанат рос он используя решает две задачи они методом то есть он это на самом деле выбирает все стройки как еслиб небыло лимит переносят их и сохранившего тоски сами данные все длинные те записи считает отбрасывая читает отбрасывать лишние то есть очень плохо поэтому здесь нужно понимать что тоже каунт звездочка он не считается обе строки тоже если в худшем случае муха нужно просматривать просто их просмотреть факт наличия строки не передавая данные в читалку на таком уровне нужно знать детали чтобы понимать иначе просто смотреть на explay но будет не очень осмысленно ну и недостатки celine они следуют из недостатков оптимизатора бывает случай когда он вообще пишет что-то не то что делает выдает очень мало информации и когда мы говорим explain что он не выполняет запрос только составляет план в старых версиях он выполнял from под запрос потому что фронт запросам перед материализовал во временную таблицу если они тяжелые собственно время занимала был gtr гораздо дочери на выполнение этих фронта запросов и была тоже такая такой нюанс а коллизия с тем что фро под запрос у нас может содержать пользовательскую функцию которая будет менять данные тогда самый кто это же бы менял данные непонятно зачем это нужно но на практике люди могут придумать вообще странные вещи вид explain можем сделать использовать ключевое слово портишь им тогда он будет показывать какие секции используют наш запрос ключевое слово x-men тот удобна тем что он при этом у формирует sql запрос который восстанавливает из плана выполнения это не исходный стиль запрос исходных пели запрос преобразован в план а потом из плана уже оптимизаторам синтезируется новый запрос который содержит ряд подсказок то есть может по ней понять что наш там происходит формирование времени таблицы с ключами каширования каких-то кусков запроса вы все эти нюансы хорошо описаны в документации и они помогают понять что делает сервер как преобразовывает наш запрос и собственно explain простейшего запросам и простейшим был бы select единичка тогда бы тут все поля были нам здесь нужно смотреть на следующие на тип доступа но который используется в первом случае он это идет сканирование всей таблице во втором случае и крест то есть это поиск по ключу непосредственно вот формирует одну запись нужно смотреть количество строк которые он ожидает учитывать то что это некая условность в позе был кейсов и те ключи которые сервер планирует оптимизатор использовать с точки зрения его условий канавы и ордер buy прочей и это тот ключ который он выбрал причем возможен вариант если у вас например possible окей бал в значении кей стоит какой-то ключ и это происходит всех случаях когда например у нас select from таблицы никаких условий войне оптимизатор вид шока вы вроде какие ключи и спорт не надо а потом смотрит что столбцы являются частью включая в принципе можно и их выбрать именно по индексу это доделать покрывающий индекс поэтому может получить старше possible кейн алкей покрывающий индекс это значит что он собственно будет использовать именно индекс кейлин это к длина индекса который он использует на составной длины индекс глядя на киле ну можно понять какую часть индекса он использует мы так как у нас уже остается мало времени давайте мы не будем подробно разбирать все возможные варианты это в документация песчаная а остановимся на знаете зачем вот на таком интересном примере как читать сложный запрос вот у нас есть пример но понятно что когда у нас виден explain он формирует по одной строке для каждой таблицы которые встречаются в запросе и исполняет запрос в той последовательности в какой выводится таблица то есть мы можем смотреть на основе сразу принимает шила выбран последующей порядок доступа к таблицам сначала убирая таблицу сети потом умирает таблицу кантри здесь все просто но когда у нас есть такое сложно навороченный explain который включает разные unions фронт под запрос и прочее и выводятся длинные простыня возникает вопрос как ее читать самом деле идея очень проста мы просто нумеруем все select и которые у нас встречаются нашем запросе и этот номер это серег то будет соответствовать номеру идентификатора который в x-plane я здесь выделил разными цветами для того чтобы было понятно сразу глядя на запрос какая часть к чему относятся второй нюанс мы можем смотреть на номера вот например шо номер шесть dropped это у нас запросов ропот запрос и следующий идет с большим идентификатором это означает сразу что в тоже относится в том же как нам уже под запросу frome то есть актов в тоже временную таблицу будет пойти и поесть глядя только на delphi которые уже можно сделать много выводов но не эдисона и удобство это в том что здесь когда я говорю что строки выполняется последовательно самом деле когда у нас есть такие вещи как производные таблицы это не совсем так то есть такие запросы с юными удобно считать каким образом у нас и union 14 это означает что у нас строки с первой по четвертую относятся к одной части и не нас 4 по последнюю ко второй частью то есть взгляде можем посмотреть последнюю строчку перейти вверх вот и так разбивать запросу сейчас сложного здесь нет единственно нужен навык есть утилиты которые сразу строят графическое представление каплей на но мы их рассматривать не будем тем более что в случае сложных запросов их тоже не так-то просто понять это на любителя но это тоже мы искали work bitch делает утилита утилитах матки продолжается описание explain restart explain пример когда explain врет а вот у нас есть запрос с под запросам части по запросу нас независимой тем не менее маскер дома моря дэвы и 5 прим если 56 этих запрос очень часто выполнил как зависимые и мы видим тип запроса зависимы запросов с другой стороны мы видим type индексов к вере это означает на самом деле запросы под запрос не выполняется заменяется на функцию просмотра индекса то есть эти строчки мир снова конфликтуют они горят на противоположных вещах и возникает вопрос а собственно что же на самом то деле там происходит поскольку explain выдает противоречивой информации тогда мы можем сделать про fallen запрос вот и посмотреть в случае когда запрос выполняется зависимые как справа у нас часть исполнения запроса передача данных будет многократно у дублирована случай когда запрос выполняется независимо эти значения дублироваться не будут кроме того профайлинг удобен как раз для определения таких нюансов там если бы блокировка то есть explain у нас может быть хорошей на вид то есть мы смотрим вроде там индексы используются количество строк он перебирает мало выполняется долго тогда мы можем запустить профайлинг и посмотреть может он передает большие данные ли он долго там делает статистику то есть выбирают план или и ожидает или еще что-то а сортировка про сортировку что это указать следующий момент когда у нас ордер buy limit большое число 10 это очень плохой у нюанс потому что сервер будет выбирать все десять тысяч строк плюс еще 10 потом 1001 отбрасываете только 10 на выдавать такие вещи надо каким-то образом менять либо например айди больше 10000 лимит 10 то есть когда у нас у всех большое число с точки зрения того что делает террор это плохо нельзя использовать ордер buy right потому что это структура делает копию всех наших данных загоняет во временную таблицу добавляет туда еще один столбец куда записывает restart функции red ipad'а файловую сортировку всего этого огромного массива поэтому если мы хотим выбрать случайную строку ордер buy red можно применять лишь на небольших объемах данных на больших это сразу убьет всех производительность гроб группировка по умолчанию делает и сортировку поэтому если нам сортировка не нужно мы должны указать явном виде ордер buy на уши нам не нужно сортировка но и про сортировку мы говорили еще в начале когда про индексы как она используется что паз последовательный нужно смотреть штука бы из у нас есть своя join сложный запросу сортировка будет использовано в том случае если в условии сортировки только столбцы первой таблице указана ну у нас есть таблица дисков есть таблица машин интернет-магазин автозапчастей и мы хотим передать показать клиенту 10 наиболее дешевых комплектов то есть как шины каким-то диском сочетается и выбрать наиболее дешевые комплекты понятно что запрос хлопнули просто движением и сортировку производим по вычисляем упор несчастную как бы и по индексу сделать ничего не сможем вот то есть мы видим что полное сканирование первой таблице плюс выбираются данной из порой то есть никаких добавлением индексов мы сделать здесь ничего не сможем в таких случаях нужно смотреть как мы можем переписать запрос в данном случае мы можем сделать хитрость тов это эквивалентно 10 самых дешевых колес плюс соответствующим диски прямая 10 самых дешевых чем при соответствующей калью колеса понятно что это некая условность поскольку это не совсем эквивалентный можно подобрать такой раз приди не данных когда это не будет выполняться ну так какое значение но на практике как правило этого может не произойти а вот и если нам например так уж важна точность мы можем усложнить запрос в явном виде и мы увидим что план несмотря на то что он стал гораздо больше но каждый раз он выбирает по индексу и сортировки внутри нее происходит небес using файл сорта беспалова я сортировки а конечная строка using файл сортом небольшое число значений собственно основной основные стратегии когда мы видим сортировку посмотрим можем ли мы как-нибудь избавиться от файла и сортировки загнав ее внутрь будут запроса если не можем то можем ли мы как-нибудь ограничить количество строк которые мы где вынужден делать файлом сортировкой мы здесь еще стоит обратить внимание на то что как бы самих частях union я еще делал вложенный frog под запрос не сортировку переносил вглубь это сделал для того что если бы этого не сделать то сервер ошибочно не будет использовать файлы в сортировку то есть отдельно без части union диски + колеса сортировка сделает по индексу а внутри он уже например не поднимались нужно учитывать что optimize таких вещах сложных может почему-то ошибаться и следить за этим но и продолжение правдой боли мид запрос который делает wordpress вот собственно большинство проблем с производительностью это как раз вот такие вот запросы ужасные где во первых что здесь мы уже видим что у нас серый выбирает абсолютно все записи это все текстовые строки сортирует этот большой массив и в конечном счете выдает нам только 3 записи при этом естественно здесь будет using файл сорт по огромному количеству записей так как мы не можем использовать способ аналогичный предыдущему то есть уменьшить количество строк и для сортировки мы можем уменьшить количество ширину с записи для сортировки и сначала отсортировать выбрать на первом этапе не все они сами записи оттока идентификаторы то есть разбить запрос на две части то есть мы делаем временную таблицу где выбираем только идентификаторы вот при этом естественно глядя на это запрос мы видим что например группировка в этом запросе совершенно нужно потому что возможно как бы дублирование удаляются условиям категория один равняется один поэтому когда мы переписываем запрос мы естественно лишние группировки прочие вещи убираем в этом случае у нас тоже будет файлами сортировка на файлами сортировка на меньшем объеме данных вот а потом уже выборов 3 дентифик отару мы собственно получим конкретные записи и когда у нас остается using файл сорт мы должны смотреть еще где делает эта сортировка в памяти или на диске то есть с помощью шел статус мы можем определить запись означает что в процессе файлом сортировки сервер 95 раз промежуточные результаты сбрасывал на fine их диск естественно это очень долго если мы увеличим значение буфер says то увидим что он делает таким образом мы можем подобрать это значение и рекомендует его устанавливать в рамках сессии они делать глобальному по умолчанию потому что она выделяется для всех соединений хотя как показывает эксперимент это не совсем так то есть если мы возьмем нагруженный северах где там 101 временных запросов сделаем сделаем буфер сайт по гигабайт у нас тем не менее памяти снизу живется в случае когда у нас есть несколько неравенств мы можем что сделать мы можем использовать секционирование то есть например если у нас таблица разбита на партиции по значению поля а то тогда соответственно первое неравенство будет использована сервером на уровень этапе определения того какой секции обращаться уже самые секцию можем использовать яндекс из двух частей т.п. ну или же исключить одной из условий путем при переписывании запрос каким-то образом но и последняя коротко пешего улучшение explain которые доступны в последних версиях на самом деле здесь можно отметить только лишь она лай стоит момент это аналог того что в пост грин плант после выполнения запроса но это только в марии 10 1 который еще байта из того что здесь нас может интересовать отошел explain который позволяет в мария опять же нужен стабильных версиях загонять сам explain записывать влог медленных запросов это удобно потом прям на при анализе чтобы нам не вызывать потом отдельно собственно будет записан explain в том соединений который выполнял а ну и собственно это можно закончить поскольку время у нас уже вышло вот все вопросы которые вас на то появится по данной теме вы сюда можете задать мне на форуме шкиль info вот но сейчас вопрос который у вас есть непосредственно добрый день спасибо за доклад вопрос такой вы не упомянули хэш индексы и full текст индексов докладе в каких случаях нужно использовать хэш индексы в каких случаях утихнут экспонент а вернее вопрос такой насколько хорошо не работает с кириллическим июне кодом а не нужно смотреть зависимости от того какой у вас условие например те же хэш и индекса не использую только на равенство они не могут использовать для условен и неравенство они очень быстрый собственно оптимизатор когда выбирать возможные ключи на используем первым делом смотрим вообще может ли он использовать хорошенько и всегда дает и предпочтение я здесь и сейчас на эти нюансы не рассматривал поскольку у нас нет они не пятидневный курс отмазки собственно фил текст индексы работает хорошо майский удачно но опять же времени описывать все нюансы у нас здесь нету поэтому я касался только отличие by three индекса который характерно для майский сравнению с другими вас еще вопроса тогда спасибо за внимание"
}