{
  "video_id": "nEtE0B1qt_w",
  "channel": "HighLoadChannel",
  "title": "Как прикрутить SQL к чему угодно при помощи Apache Calcite / Роман Кондаков (Querify Labs)",
  "views": 1460,
  "duration": 2800,
  "published": "2021-10-04T02:28:54-07:00",
  "text": "начну для начала небольшого немного бэкграунда обо мне сейчас я работы в компании квари файл abs и мы там консультируем другие компании которые создают свои судьбы д по теме как им правильно прикручивать этот самый кальцит к своим системам до этого немножко поработал в яндексе и там я занимался индекс говорил им пейджем а ещё до этого я работал в компании great game и там мы делали распределенный распределенный движок секула для apache игнайт и вот собачьи игнайт я бы хотела начать этот рассказ давным-давно apache и игнайт был распределенным кошон то есть это такая большая распределенная хэш mapi на которой можно было что-то положить по ключу и что-то оттуда забрать как бы все это работало прекрасно быстро но многие наши пользователи хотели бы делать что-то еще со своими данными которые лежат как найти например и проводить какую-то аналитику ну во всем все то что умеет мы привыкли делать при помощи square и соответственно в один прекрасный момент родилась идея этот самый сколько копать фигной ту прикрутить первая попытка была сделана при помощи маленькой такой базы и чту это легковесная база написанное на джаве мы ее немножечко подшаманили и научили работать с игнайтом то есть как то выглядело со стороны каждая нота игнайта каждая нота кластера поднимают внутри себя эту базу я чту и когда секундный запрос приходит на игнайт он сначала попадает в эту базу мечту и что его парсит оптимизирует начинает исполнять но исполняет она не по тем данным которые лежат базе и чту а исполняет по тем данным которые лежат базе игнайт отогнать научился своим свои данные скармливать вычту так это работало в рамках одной ноты но так как на эту нас распределенная система это много может быть много нот то надо было придумать как исполнять распредели эскиз qu'elle распределена распределена это выглядело следующим образом вот у нас на слайде есть небольшой кластер который состоит из трех нот две ноты с данными такие бочки и клиентская но да и в каждой из них поднят инстанции что и когда мы хотим выполнить конь запрос например посчитать среднюю зарплату по предприятию the apache и игнайт бил этот запрос всегда на две части первая часть называлась map запрос она исполнялась на нотах где лежали данные и вот чтобы почитать среднем и получается в этом запросе считали сумму зарплат и количество сотрудников ну понятно почему не читали средняя потому что средние на каждой ноги мы из этого потом глобальное средняя никак не не сможем вытащить ну так вот результаты мы об запроса отправлялись на какую-то одну ноту на клиентскую данном случае откуда запрос приходил и там по этим по результату по по результатам от запросов мы проходились еще одним запросом который назывался review запрос и он уже считал результат всего распределенного запроса то есть мы считали суммировали все зарплаты которые пришли со всех нот считали общее количество сотрудников делили одно на другое ну и нас получился получалось общая по кластеру средняя зарплата то есть то что мы хотели но легко понять что у этой схемы есть свои недостатки допустим запрос делился только на две части они каждый запрос как выясняется можно разделить на две части так что бы его можно было выполнить сразу распределена за два прохода вот например такой запрос когда мы хотели посчитать как и хотели выбрать всех сотрудников у которых зарплата равна средней зарплате чтобы это сделать надо было во первых посчитать среднюю зарплату да и заполнить ее в каком-то exe а затем выбрать всех сотрудников который зарплата равна этому иксу но в apache и игнайт каждый этих запросов еще бился на две части да вот на эти части редис часть за которую мы говорили на прошлом слайде то есть получалось всего 4 ну запроса то есть 2 2 2 map и 22 редис и apache и игнайт такого выполни к сожалению не мог потому что но только один map и 1 reviews допускается и мы начали думать а как же нам эту ситуацию исправить были разные варианты мы думали может быть усовершенствовать текущую архитектура как-то но здесь есть свои минусы потому что и чту на котором базировался сиквел apache играет он в принципе не предназначен для распределенного исполнения и попытки усовершенствовать эту тачку это выглядело бы как попытка улучшить какой-то хак что не всегда хорошо второй вариант был это написать свой движок сигнальный с нуля это интересная задача потому что ну мы все инженеры нам нравится решать сложные интересные задачи но к сожалению здесь есть недостаток что во-первых это очень долго это очень трудоемкая задача этот человека десятилетие работы и результат совсем не гарантирован потому что ну что-то делали-делали могли поток сделать что-то не очень хорошие руки у нас мало ли кривые и был третий вариант как исправить сиквел это поискать готовые решения ну образно говоря взять там postgres вытащить из него оптимизаторы как-то прикрутить его к нам но слава богу по сгрыз нам потрошить не пришлось потому что нашлось такое готовое решение которое называется apache и кальцит апачи кальцит сам себя позиционирует как фреймворк для создания секундных баз данных что это значит это на что при помощи почти кальцит можно взять любую носик вольную базу данных добавить ним кальцит и получите волшебным образом магическим совершенно секундные базу данных и вот сегодня я хочу рассказать как мы напали на примере игнайта прикручивали секунд при помощи кальцита из чего кальцит состоит и какие там есть нюансы в распределенных системах если вы если вы если ваша система распределяя вы хотите завести в ней сиквел ну вообще паттерна использования концы the data довольно прост когда у вас есть запрос вы его отдаете кальцита кальцит его каким-то образом там парсит оптимизирует и на выходе из кальцита вы получаете план запроса то есть план виде реляционного выражения которое вам надо исполнить да вот мы пытались его исполнять выгоняйте но фактически этот план можно исполнить где угодно здесь 2 больших задач и первая задача это научить кальцит делать тот план который вам нужен а вторая задача это научить вашу вашу систему этот план исполнять вот собственно про это и я сейчас расскажу для начала хочу сказать что кальцит это довольно зрелый продукт несмотря на то что он не на слуху у широкой аудитории на самом деле он используется огромным количеством вендоров которые делают базы данных например apache и хайфа апачи fling drill и так далее огромное количество коммерческих вендоров его использует то есть это вполне себе взрослый продукт который подходит для production ради решений внутри кальцит состоит из огромного количества компонентов но чаще всего используется вот эти первый компонент называется парсер да когда строка стекольного запроса приходит она попадает в партер и парсится им в абстрактной осинка синтаксическое дерево или в терминах кальцита это сиквел но до затем это дерево валиде руется на предмет правильности составления и конвертируется в революционное выражение или well not в терминах кальцита после чего это авиационное выражение попадает в оптимизатор и оптимизатора его там как-то перерабатывает оптимизируется на выходе мы имеем план вот который нам надо будет исполнить разные проекты могут брать разные части разные компоненты кальцита ну обычно чаще всего использует все три некоторые используют свой парсер там не который использует свой оптимизатор но большинство все-таки вот эти все три потому что они в кольце тяни уже подогнанных друг подруга и вам не надо там особо нечего допиливать парсер носят поподробнее пройдемся парсер берет строку с запросом и превращает и абстрактно синтаксическое дерево это похоже на то как мы может быть помните в школе разбирали предложение по составу там подлежащее сказуемое здесь примерно тоже самое только вместо подлежащего и сказуемого у нас только какие колонки мы должны выбрать какую операцию выполни там select или апдейт откуда взять данные из каких таблиц что джо нити как какое условие расспросив запрос мы его конвертируем конвертировали циона и выражение здесь происходит довольно важная вещь именно здесь происходит переход от декларативного секула да когда мы говорим дай нам данные которая так то отсортированный из таких the tablets так-то джунён и переход а декларативного к императивном у реляционного у выражению которое говорит чтобы получить свой ответ на свой запрос сделай сначала следующие отсканирует табличку там сотрудниками департаментами затем с джой не эти таблички затем отфильтрую строчки которые нам не нужны и оставьте о коте колонки которые мы запрашивали принципе все это рабочий план который мы можем исполнять но есть нюансы наверняка многие заметили что план этот не оптимален потому что у нас фильтр находится вверху то есть воплощается берем джон нем все таблички целиком и только потом отфильтровываем не нужны хотя гораздо оптимальнее было бы сначала сделать фильтр отфильтровать откинуть лишние колодки потом уже оставшиеся строчки между с тобой женить ну и то же самое с project am просто мы тащим все колоночки у все самого низу дерево до самого верху съедаем ненужную памяти этими и ненужными колонками хотя могли просто взять самого начала прочитать только те колонки нам нужно которые нам нужны для таких целей для для того чтобы улучшить реляционные выражение служат оптимизаторы оптимизаторы в кольце те конфигурируются при помощи правил правило это такое правило модификации реляционного выражения которой как-то переписывать это дерево на эквивалентное правило в calcetin это обычная классики в java который состоят из двух частей первая это паттерн это то на что это правило срабатывает автора эта трансформация это что провела с деревом выполняет то есть оптимизатора он бегает по дереву образно говоря и ищет знакомая паттерн эти паттерны правил в которой в нем сконфигурированы и когда он находит ну например фильтр над joy нам когда он находит совпадение он вызывает трансформацию и фильтр у нас уходит под join в кольце те в кольце есть два оптимизатора первый называется эвристические head планер он его достоинство в том что он быстрый тоже он привет применяет правило пока видит паттерн и выведет совпадение то есть пока от псевдокод есть пока можем применить мы применяем правило он содержит такие это нельзя на это скорее фичи скажем если например у нас есть 2 правила которые противоречат друг другу например одно правило двигает там фильтр вниз а другой фильтр вверх двигает то эти правила будут зациклиться пусть они будут несчастный фильтр туда-сюда гонять до бесконечности поэтому когда вы конфигурируете эвристические optima оптимизатор правилами вам нужно строго их отбирать чтобы они друг друга не отменяли этот планер используется для всегда optima оптимальных преобразования например там ну или почти всегда оптимальных о преобразовании например де корреляция запроса или или там нуждам фильтров и и project of 2 планер которой есть оптимизаторов в которой и скользить и он более интересный и the cost buy stop theme затар и он называется вулкана планер cost bass это означает что учитывает касты деревьев каждому дереву оптимизатор присваивает некий cost это такая скалярная величина которая говорит что чем ниже куст тем дерево для нас оптимальная тем проще его будет исполнить и задача это оптимизатор найти как раз дерево с минимальным custom внутри он работает немножечко по-другому не так как и веристический баннер он не переписывает дерево на месте вместо этого он сохраняет все модификации запроса вот все все все что провела там переписали он сохранит все эти переписывания все эти модификации и сохраняет их в специальной структуре которая называется мимо мама себя представляет следующая скажем если у нас есть какое-то дерево на фильтр и project и у нас появился какой то еще один оператор например join который эквивалентен project у эквивалентен да значит то что он отдает абсолютно те же строчки тот же результат что и project в таком случае вулкана планер помещает их в один класс эквивалентности который называется с то есть все что находится в одном сете она отдает один и тот же результат несмотря на то что это разные немножко разные операторы ну и соответственно фильтр тоже имеет свой сет и так как все что находится классикой валентности отдает один тот же результат то нам не важно что будет дочерним узлом у фильтра мы говорим что у фильтра дочерний узел это сам сет то есть может быть теоретически любой узел подойти на подойти на должность как раз от поставщика данных для фильтра оптимизатор запрыгну знает cost у каждого узла то есть например прожить там он условно 10 у joy на 30 и оптимизатор помнит самый лучший cost для каждого сета то есть вот project нашем случае побеждает собственно когда мы получается про оптимизировали дерево у кота мы когда мы применили все правила оптимизатор выбирает из каждого сета лучше победитель в каждом сете из него строит новое дерево которое является оптимальным планом когда провела там применяется тоже немножечко по-другому когда мы применяем правило вот фильтр project run это правило которое меняет фильтр и project местами и вот когда мы пытаемся поменять фильтр и project то мы просто добавляем в этом м а наша новую наша новая нашу новую конструкцию обратите внимание что новый project попал в тот же самый сет что и фильтр это происходит потому что правил такой инвариант он переписывает дерево на идентичный на идентичную конструкцию нато то что дает тот же самый результат поэтому фильтры project попали верхние в один и тот же set а вот нижний фильтр попал в свой другой сет потому что он отдает не то же самое что и секс слева с project am ну что сет слева отдает данные от projection и но не отфильтрованы asset справа даю данные отфильтрованные но нет projection и поэтому они в разных собственно категориях и находятся кроме того вулкана планер используется для физического планирования то есть физическое планирование кальцит она является коз bass оптимизации физическое планирование это когда у нас есть какое-то какое-то логическое выражение реляционной например берем две таблички janym их и получать какой-то результат но как мы joy ним вот этот наш джон ничего не говорит мы можем есть разные алгоритмы join a есть там хэш join есть мер join есть место тут join так вот чтобы понять каким алгоритмом выполнять за ну вот этот наш конкретный join мы должны как раз вот провести это физическое планирование пусть наша система умеет исполнять хэш join и тогда мы добавляем в кальцит правило который называется хэш join рун и которая переписывает это наше изначальное дерева на дерево в котором верхнем узлом является хэш joy если наша система умеет исполнять мер join the мы добавляем правило которое переписывать логический join на уже конкретно физическую на конкретную презентацию с мертв join now my joy на наверняка вы знаете есть такое требование что входы этого join a должны быть отсортированы по ключам по которому джонни ну такой алгоритм и соответственно надо добавлять в этом месте сортировку то есть вы должны правильно отсортировать наши строчки наши входы и когда физическое планирование завершено оптимизатор оценивает каждый план то есть он каждому узлу проставляет какое-то значение там один узел дороже один дешевле поэтому это дерево целиком получать какой-то и итоговую стоимость да и вот смотрите здесь у нас получилось так что мертвая несмотря на то что сам по себе мир джон стоит там дешевле простая операция там не надо строить хэш-таблицы никаких получается так что хижину выиграл все и велел выиграл потому что нам пришлось сделать дорогую сортировку на входе то есть можно подумать что хэш join будет всегда побеждать мер join и в оптимизаторе это на самом деле не так потому что вместо того чтобы делать сортировку искусственно бывают такие случаи когда у нас данные уже отсортированы так как нам надо например у нас есть какой-то какие-то индексы сортированные если мы будем по этим эти индексы учитывать то данные уже придут в том порядке в котором нам надо и оптимизатор должен как-то учитывать то что надо ли ему вставлять сортировку в этом месте или не надо для этого в кольце те существуют так называемые трейд вместо того чтобы говорить о том что нужно сортировка мы можем сказать мы хотим чтобы левый вход join a был отсортирован по иксу а правый вход был отсортирован по игреку вот это вот как раз сортировка называется trade в терминах кальцита это просто физическое свойство физическое свойство узлов так что у тони старка даю данные отсортированы определенным образом и соответственно в сет и слева и справа попадут и просто отсканированные данные и с последующей сортировкой и также попадут наши индексные сканы которые сортировки не нуждается и кальцит тут уже будет опять таки высчитывать у всех каст и смотреть сколько каждый оператор стоит и в конце он выберет победителем и здесь уже победители может оказаться наши индексной сканы соответственно избежали дорогой сортировки и мир joy но у нас победил ну вот так примерно это очень кратко только которая как работает оптимизатор в конце ти скажем но и получается все мы научились мы понимаем как она строится планы в конце ти мы получили какой-то готовый план но нам мы же база данных нам надо нам не сам план нужен мы должны отдать результат пользователи то есть мы должны что то сделать планом чтобы пользователь получил тот результат который он хочет и для этого существует такая штука которая называется runtime runtime умеет понимает план и умеет его исполняет то есть он видит план и начинает читать данные читать таблички который нам нужны он умеет фильтровать там как-то агрегировать joy нить и так далее то есть в общем это та штука которая в конце концов выдает нам нужно результат запроса как можно сделать runtime но среди когда кальцит нам подготовил запрос в виде дерева виде плана этот план похож нa на некую программу наверное да на каком-то своем языке программирования а как можно исполнять программы можно программой интерпретировать например вот в базах данных очень часто встречается такая интерпретация при помощи итераторов когда каждый узел этого дерева плана мы превращаем в итератор например итератор скана это просто такая сущность которая умеет читать данные из таблицы и отдавать их куда-то дальше итератор фильтра умеет брать данные снизу с от нашего скан а потом он применяет к этим данным какой-то предикат если предикат сказал что труд то есть что строка удовлетворяет предикату мы отдаем ее дальше если строка не удовлетворяет предикату мы просто проматываем и и дальше пока не найдем следующую которая подходит под наш перетекать ну и самый верхний итераторы the project он просто но оставляя только те колонки которые мы запрашивали в запросе это один из подходов при помощи итераторов это интерпретация запроса бывают другие варианты можно сделать куда генерацию то есть можно вот это дерево превратить в код на каком-то языке и и начать его исполнять это другой подход бывает комбинации этих подходов да когда например ну когда генерация может длиться довольно долго если у вас очень существенно такой сложный запрос развесистой там могут быть там секунды там и так далее вам хочется начать быстрее его исполнять и некоторые система делают так они сначала строят это дерево из операторов и в фоне пытается скомпилировать этот запрос при помощи когда генерации и вот запрос начинает исполняться итератора my интерпретироваться а потом когда у нас появится готовая программа готовый как это генерирует код переключение правда исполнении плавно переключается на этот раз кода генерирование движок ваш того он в принципе быстрее чаще всего также бывает для исполнения используется всякие всякое железо например цепью или там f и j какие-то то есть тут довольно широкая фантазия разработчиков баз данных и очень часто используется векторной инструкции процессоров потому что это позволяет очень быстро обрабатывать данные особенность вас данные хранятся в колонном виде так мы все мы научились исполнять план но проблема в том что мы научились восполнять на одной ноги в рамках одной одного узла в рамках одной например живым ну и план можем исполнить но apache и игнайт это распределенная система и поэтому мы должны уметь исполнять план распределена что это значит это значит что от если у вас есть какой то запрос например от простой до фильтры scan результат этого запроса мы должны отдать какое-то клиентское приложение например тот же бибиси драйвер а этот же device драйвер он исполняется на ком-то одном клиентском узле в то время как нижняя часть дерева скан она исполняется где-то в кластере где где лежат у нас данных где-то там по нодам то есть получается 1 через дерево должно исполниться в одном месте другая часть дерева исполнится в других местах но если вы посмотреть на картинку дают снизу у нас кластер с данными сверху клиентское выражение то мы можем например попытаться это сделать так доска скан всегда железная исполняется на тот анодов клиентские детское приложение всегда ждет данные на клиентском узле фильтр мы можем исполнить например тоже на клиенте ну тоже может исполнять но нам нужно как-то эти данные отправить по проводам или еще как то для таких случаев в кальции есть такой оператор который называется x-range exechange он никак не меняет данные у там них не фильтрует ничего он просто меняет распределение в кластере этих данных и вот если мы посмотрим этот запрос на этот план до что она сначала читаем данные потом отправляем их на клиента там их фильтруем это наверняка не самый лучший вариант потому что мы получается отправляем в сет абсолютно все данные что у нас лежат кластере и только потом на клиенте их фильтруем мэр разумнее было бы сначала данной отфильтровать оставить только те данные которые нам нужны и отправить их уже на на клиента поэтому наш вкус best оптимизатор должен учитывать вот эти кастинги он должен понимать где их стоит ставить их не стоит ставить как как этот наш курс быстро оптимизатор поймет что надо учитывать еще и распределение данных это делается тоже при помощи trade of вот когда мы говорили о сортировке сортировка это трейд это физическое свойство данные что данное сортированы определенным образом так вот распределение данных это тоже trade это трэйд который говорит о том что данная раскиданы каким-то каким-то образом по кластеру и оптимизатор с этими тратами умеет работать вот скажем если у нас вверх верхний узел исполняет имеет trade сингл то есть он исполняется на одной ноте всего а нижний узел имеет трейд распределение хэш то есть данные как-то партиции раваны по там хочу первичного ключа то задача оптимизатора определить какой трек должен иметь и фильтр да и куда это ты раньше мы должны воткнуть происходит до примкнул если упрощать то происходит таким образом то что оптимизатор просто пытается ставить texet не везде где только может например он может вставить как здесь после фильтра а может ставить перед фильтром и соответственно после того как все варианты рассмотрены он начинает выбирать оптимальный из них это тоже происходит при помощи костов то есть каждому оператору назначается кокос то есть например прочитали 100 строчек отфильтровали оставили десять строчек и и ксении джим по проводам передали десять строчек а вот правый план он будет такой снова прочитали 100 строчек эти же 100 строчек отправили по сети и там уже где-то на клиенте отфильтровали 10 ну как бы очевидно что слева план поудачнее вышел так ну принципе мы теперь понимаем как исполнить мы понимаем как получить план мы понимаем как его исполнить в рамках одной ноты и мы понимаем как исполнить этот план распределена при помощи кощей собственно благодаря тому что мы вот это сделали мы можем вернуться к нашему первому запросу на которых от которой apache кальцит apache и игнайт изначально не мог исполнить да где мы хотели найти всех сотрудников которые получают ровно среднюю зарплату теперь игнайт такие запросы исполнять может без всяких переписывание запроса и кальцит нам даст примерно такой план на этот запрос мы сканируем табличку сотрудниками мы считаем локально на каждой ноги агрегаты сумму зарплат на каждой ноги и количество сотрудников затем происходит так называемый синглтон exechange синглтона вещь это ощущение который стягивает все данные на одну ноту и вот я красненьким отметил это все же все что красненьким она исполняется на одной ноги на какой-то все что черное исполняется в кластере распределена так вот эти данные все приходят на одну ноту там мы их до агрегирует то есть мы считаем сумму всех зарплат по всему к мастеру и количество сотрудника по всему кластеру делим одно на другое и полученный результат соответственно будет вот этим средним средней зарплатой по компании этот этот эту среднюю ну тут циферку 1 удар со средней зарплатой мы отправляем при помощи бродкаст excel-g обратно на все ноды то есть на все надо ушла вот это наша как бы табличка с одной-единственной цифрой со средней зарплатой и там из-за на вас конец сканируем с табличку сотрудников и join ним вот эту нашу маленькую табличку со средней зарплатой jonim с табличкой сотрудников и там где джон джон по равенству выдает true то есть все что дает join это как раз будут те сотрудники которые получают ровная вот эту нашу среднюю зарплату и мы этих всех сотрудников снова сингл там exin джим вернули на клиента получается исполни распределен на собрали данные посчитали что то раскидали что-то 5 посчитали и снова собрали такая довольно сложная довольно сложно исполнении получилось но с calc и там это оказалось сделать гораздо проще чем с тем же и чту так и в чем прелесть кальцита том у самок основная прелесть она заключается в том что кальцит создавался как раз таки для кастомизации для того чтобы использовать в разных проектов он очень-очень хорошо настраиваем настраивал настраиваемый это значит то что мы можем добавлять свои реляционные выражения да если вам незнание нравится стандартный фильтр который и скользить это мэри джейн вы можете сделать свой вы можете добавлять свои правила переписывания этого реляционного дерево как угодно вы можете переопределять касты в своих или устроенных операторов ну например если вы знаете что вашей системе по какой-то причине хэш join будет исполняться там долго то что внуки он сложнее тяжелее чем virgin то вы можете просто ухожу на уменьшить cost и мир джона уменьшить кости мир жаль будет чаще выбираться как победители в плане вы можете добавлять там свои метаданные например скажем если у вас в таблице есть например уникальная колонка и по этой уникальной колонке у вас есть какой-нибудь фильтры по равенству то можете сказать что ой вы знаете минут уникальной колонка фильтр по равенству результатом результат это фильтр будет всего одна строка то есть вы можете очень точно оценивать кардинально sti ваших ваших планов и благодаря этому получать но очень-очень хорошего очень качественные планы так секунду пролистал полезные ссылки полезные ссылочки еще хотел рассказать есть сайт проекта кабатчик кальцит там есть немножко документации но вообще в корсете проблема с документацией всем приходится все кто у него входит приходится читать код скорее всего то есть есть какие-то презентации есть какие-то блоге но на самом деле это информация очень разрозненно то есть какое-то какого-то единственного хранилища централизованного с технической документации корсете к сожалению нету но чуть-чуть есть вот на сайте apache иском есть замечательная презентации с примерами кода накрутите если вы решите попробовать сделать ну какой то свой прототип чик то я советую вам начать с этой презентации потому что там очень хорошо описывается всех баб базовой api кальцита там что такой тренд и что такое правило и так далее есть также полезная статья про кальцит на архив на архиве это и white paper кальцита где создатели и где его создателей основные пользователи рассказывают историю из кейсы и так далее то есть в общем то все что вам нужно знать находится в этой статье и если вам интересно разобраться с работой оптимизатора cost bass а он там довольно интересно работает вот есть пара статей чик про так называемый вулкана к skates фреймворк там очень подробно все расписано и очень интересно это все читать так но я закончил вопросы итак у нас не так много вопросов так в онлайне есть ли у нас вопросы коллеги ну давайте первый погромче поближе да спасибо спасибо роман доклад очень интересно подскажите во что низко вопрос первое что он транслирует код при год генерации это хищный год с векторизации этот же год в котором парни электризации в в кальции есть встроенный встроены так называемые ну в общем движок для кода генерации он транслирует все все в java вый код при помощи джанино компания там используется такой то есть если вы используете кальцит из коробки то вы можете генерить код на джаве вот на других языках вам надо будет что-то уже самим делать там llvm какой-нибудь прикручивать спасибо а что касается клиентской и серверной части когда мы говорим про исполнении чего-то на нотах исполнении чего на горке в исполнении чет на клиенте то есть получается кальцит нужно будет ставить во все три эти компоненты как это работает не обязательно вы можете например сделать какой-то централизованная ноту которая будет просто заниматься планированием запросов и эти запросы отправлять в классно чтобы не там как-то исполнялись либо в го почти гнать мы сделали так что каждая нота сама себе умеет все она умеет и планировать запросы исполнять их то есть тут как как он будет угодно просто кальцит умеет рожать план вы можете это делать в одном месте можете делать на любой нодди кластера как угодно спасибо можно всегда вопрос спасибо большое за доклад о такой вопрос согласен тоже в продакшене или это пока только готовя мышках готовится в в этом году к релизу то есть она работает там уа аль альфа а вот вы вообще выпилили h2 и лепечет вопрос-то остался на каждой ноги но она теперь такой симбиоз что в итоге хранилищем то является по итогу от качества планируется отказаться сейчас как бы можно исполнять пока еще последних версиях игнайта там вычету еще можно исполнить а что вместо и чувства то есть просто свое написали что-то да мы написали свой движок исполнения а как мигрировать с одного на другое ну там это очень тяжелый вопрос на самом деле потому что есть несколько вариантов для миграции но мы рассматривали например можно было попытаться сделать подобрать синтаксис и счету той чтобы кальцит понимал синтаксис сочту и мог парсить запрос ведь но тут тоже если проблема потому что планы запросов поменяется довольно существенно пользователи они уже за точились на планы даже станки это план и плохие выбирались они уже на них рассчитывают и это был один из вариантов а второй вариант которые мы по итогу выбрали у нас планируется выход apache и гнать 30 в котором будут будет сломано обратная совместимость то есть мы короче вот такой хардкорный вариант мы скажем что надо делать ребят новый запрос если вы хотите на новой версии перейти performance есть какой-нибудь ну замеры какие то что все это вообще стоила свеч сам самый главный performance это состоит в том что имейте ввиду время исполнения запросов время предпри примерно на уровне осталась единственной самое главное что поменялось что вам не надо разбивать какие-то ваши крупные запросы на маленькие чтобы испании по частям раньше кольца кальцита и игнайт мог исполнять только определенные классы запросов там какие-то небольшие там две таблички паджоне там что-то создавать сейчас вы можете написать там полноценный olap запрос и игнайт и вас может исполнить который раньше он вообще в принципе не мог никак не каких условиях получается вы какой-то свой под синтаксис сквер взяли или все-таки стандарту на котором вы основываете к себе возьму взять допустим oracle запрос который стандартам 2001 и выполнить его на новом бабочек на ит кальцит чем хорошим позволю во-первых он понимает разные синтаксис и вы можете настроить кому какой хотите можете там postgres понимать что он упал за гусарский сим синтаксис понимал можете там масик вольный но у нас просто взяли стандартный а почти гнать потому что ну де-факто пачек дать становится таким сильным стандартом в мире а там больших данных там что все его прикручивают скажем этот синтаксис будет поймать там все больше больше проектов то есть возможно это будет много когда-нибудь новый стандарт поэтому взяли как и стандартный в конце тоски спасибо большое обряд рядом был вопрос спасибо винить меня вопрос от ленивого разработчика я вижу что есть адаптер для работы с парком но не очень понятно сколько того хорошо все работает и вообще насколько много проблем и первый вопрос а второй вопрос про план выполнения я так понял что я могу его один раз составить и дальше уже просто повторно исполнять и исполнитель регламентные запрос один и тот же что происходит если у меня конфигурации мы вот стенд меняется то есть и туда узлов добавил план остаются или нет спасибо смогу если вы спланировать один раз запрос то это ваши правила вы можете либо его переиспользовать но за каши ровать например да этот этот план и потом его переиспользовать вы можете этот качанова лидировать например когда у вас данные сильно поменялись ну например там табличка выросло в десять раз соответственно скорее всего такой не другой запрос может быть оптимальнее то есть вы если вас данное меняется вы просто этот качанова лидируете ну или конфигурация кластер на при поменялось тоже вы можете его лидировать кэшей заново спланировать запрос с нуля а первый вопрос про spark был не очень понял с парком goose parka свой оптимизатор спарка своя система то есть фактически нет и есть адаптер да я честно скажу я адаптеры не ковырял там есть адаптер и как манги к там спарку носик очень много чему кальцит умеет строить планы и отправлять их как раз у spark мангу и так далее как это работает я не проверял потому что но мне было интересно вот своем завести с игнайтом вот так у нас там вопрос давайте коллеги еще пару вопросов и переходим после этого в дискуссионную зону спросить кальцит может не только select и и вообще весь да вы можете сконфигурировать любой свой синтаксис вы можете написать свой короче эта часть она конфигурируемый то есть вы можете использовать либо стандартные портьеры в calcetin они умеют основной команды делать там select и и так далее ну вот selecta не умеет все делать а вот дима или деле ограничена на то что обычно 1 или 0 как минимум недель он очень часто ученика основные для каждого продукта и поэтому продукты которые используют кальцита они как раз парсеры где деревья недели они пишут сами фактически вам просто надо добавить делать это в ходе вы добавляете просто файл с грамматикой которую вы определили для своего неделя и добавляйте обработчик как раз в ваших ваших команд то есть вам в обработчик придет так пришел какой-то create ебал и вы там начинаете кайта сколько код исполнять который инициирует создание таблицы допустим я победил грамматику for my bags on a lower а затем анти лером обучил анти лером получил parser и затем что а кальцит умеет работа с анти лером или conti кальцит напрямую работать с нотация баксан ауры плохо было слышно изменяем кальцит напрямую работать с анти лером с обработчиком антиверо а либо кальцит работает сам парсит нотаций боксу на ура и собственно дальше уже стоит пару он не интеллект не интеллект используя тонну похожую штуку java se si вот просто будут для него грамматику создаете джерси этот партия просто вам выдает синтаксическое дерево как раз построена по вашей грамматики а что с ним делать это этого уже должны сами делать что как кальцит про вашу грамматику ничего не знает он просто своим партером распахивал что что-то получил поэтому ваша задача понять что с вашим этим деревом надо сделать понятного zvereva будет критий был там у него будет имя будет там в колонке и так далее даже сами достать эти колонки достать это имя и в кластере там регата запустить задачу создания таблички так у нас был последний вопрос так давайте вот яркий участник папа поближе погром же вопрос вопрос такой весь этот планер это все прекрасно но его ценность будет в том как он сможет обрабатывать сложные вопросы связанные с оптимизацией размера таблиц сложности запросов литве например попытка угадать сколько после фильтра выйдет до строк для того чтобы потом какие-то сделать применить тот или иной вариант вот все эти планеты во всех базах они собственно чем он лучше тем базу лучше то есть то что вы рассказали это основные вещи а потом их надо наполнить какими-то у вас есть представление как это делать потому что иначе это будет сложно использовать да коня конечно есть вы абсолютно правильно сказали что вот вот эту задачу про оценку кардинально кардинально stick о которых говорили да сколько после фильтра останется строчек это вообще говоря большая научная проблема что никто не знает сколько останется строчек пока ты исполнишь запрос за даже если у вас есть хорошие статистике там гистограммы и так далее все равно точного ничто не может сказать и чем прекрасен кальцит тем что ну во-первых изначально в нем есть все эти так называемые статистике то есть вы можете примерно оценивать кардинально sti но сразу скажу что в корсете они довольно примитивно сделаны то есть а не знаю например если у вас фильтр по равенству он считает что он по моему 10 процентов строчек ставить только после после фильтра но хорошая сторона в том что все это кастомизируемый вы можете просто обирает у тьме . метод который считает cardinal ность фильтра и как-то самому уже посчитать как вы считаете что будет лучше то есть вы можете самостоятельно взятие там наворотить кальцит какими-то своими оценками кардинально стиле чем то еще то есть это расширяемая система и в этом его прелесть я не ответил и так роман теперь выбери пожалуйста лучший вопрос ну мне мне понравился последний вопрос про кардинально стёпа что это действительно большая или передадите участнику большая проблема вам полагается книга за лучший вопрос и так спасибо большое романа давайте поблагодарим его спасибо от подарок от наших организаторов спасибо"
}