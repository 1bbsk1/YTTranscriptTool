{
  "video_id": "K5-ODFOUvkE",
  "channel": "HighLoadChannel",
  "title": "Чем заняться вечером, если я знаю сколько будет ++i + ++i / Андрей Бородин (Yandex)",
  "views": 5270,
  "duration": 2100,
  "published": "2018-08-16T04:59:04-07:00",
  "text": "меня зовут андрей бардин и обычно на первом слайде мы пишем должность но вот применительно к этому докладу у меня много должностей ну да во первых я разработчики индекса но кроме того я веду курс алгоритмов и структур данных в екатеринбургском филиале школы анализа данных яндекса ну и вообще мне нравится учить студентов мне нравится делиться знаниями и я доцент уральского федерального университета и в этом докладе мы поговорим про алгоритмы но из из названия многие могли решить что у нас будет до клапан define бехер и нет мы не будем обсуждать он define ресивер и строго говоря доклад не совсем про open source доклад про некоторые характерные черты свободного программного обеспечения некоторые характерные черты алгоритмов лен используемых в общем и целом доклад про велосипеды в такие красивые замечательные быстрые велосипеды дело в том что многие крутые проекты создаются для замены чего-то уже существующего и общепринятого из глубины времен можем вспомнить какие-то назад empire of computer мы можем вспомнить зубы депо сгрыз которой вообще-то говоря является пост ingress ну и название си плюс плюс сама за себя говорит то что это тип + + ну и яндекс это это на за индекс почему так происходит ну мне кажется что так происходит по двум причинам ну понятно что каждую идею нужно кому-то развивать это должны быть люди посвященные этой идее с одной стороны изобретатели оригинальные идеи зачастую в версии 2 проекта поддаются эффекту который известен внуки как effect 2 системе фредрика брукса они хотят устранить все все проблемы они хотят выгрести все баги они хотят сделать идеальную систему и это часто становится непреодолимой непреодолимым препятствием с другой стороны есть люди которые посвящены посвящают достаточно энергичные талантливые люди которые посвящают свою энергию эксплуатации новых идей постоянно вот в духе стартапов и но эти люди тоже уходят от идеи которые уже кем-то реализована и остаются специальные люди с характерным складом характера который позволяет довести проект до успехом и это зачастую непросто если мы посмотрим список амбициозных пугающих идей пула грэма и с 2012 года мы увидим что он предлагал новый поисковик новый e-mail замена университетом замену голливуду замену apple это это все проекты которые должны что-то уже существующие сместить но оригинальные изобретатели сделать этого к сожалению не смогли или или или не еще не могут или уже не смогут в итоге такими проектами должны заниматься специальные люди которых ну можно шутливо называть велосипедистами но на самом деле то есть в этой черте характера именно один из важных ключей к успеху и надо понимать что хороший велосипедист он не всегда инженер даже если он работает над технической системой дело в том что ну инженеров например у инженеров строителей есть уголовную ответственность за отступление от госта правильный инженер при необходимости вычислить объем мячика берет справочник мячиков и ищет объем мячика там с другой стороны хороший велосипедист он не всегда ученый ученые должен быть усе rowan на 1 важная идея и должен в эта идея дойти до идеала он должен разобраться в ней полностью совсем хороший велосипед должен поехать это вот ключевой вопрос успешного проекта и вот это черта характера людей которые делают проект и успешными приводят к тому что когда проект уже успешный вообще говоря в нем можно найти много работы для учёного и для инженера или даже если это один и тот же человек и эти знания которые могли бы помочь многим открытым проектам которые созданы такими людьми они зачастую есть библиотеки они доступны в принципе каждому почему стоит заняться именно вам этим вот может быть прямо этим вечером ну это весело это интересно как вообще у меня все как я начал заниматься подобными вопросами я приехал два года назад на пиджаком там мне организаторы помогли собрать под газ до этого я очень много играл и человек в онлайн игры с тех пор у меня в стиме 0 то есть каждый вечер я вместо того чтобы что то поиграть я ну почти каждый вечер я открываю и думаю у меня еще к столько классных идей которые надо попробовать написать какую-нибудь пачек там вот и просто невозможно остановиться и меня не было плана так делать но так сносу ну само собой получилось с другой стороны недавно вот у меня случилась такая ситуация что мне нужно было написать резюме я с удивлением обнаружил что моим резюме но есть строчки посвященные тому что я учился там в сильной школе что я закончил университет что у меня есть ученая степень и это все заняло сильно меньше того пространство которое я посвятил описание тех вещей которые я сделал open source и вот ну именно поэтому стоит браться за сложные вещи в открытых проектах за которые просто еще пока никто не взялся ну а если говорить серьезно зачем это нужно компании то в общем и целом смысл сводится к тому чтобы просто выполнять если если ваша компания предоставляет сервис на основе открытого программного обеспечения рано или поздно вам может понадобиться фиксит баги в открытом программном обеспечении было бы классно если вы потренировались своих разработчиков заранее чтобы они познакомились исходным кодом посмотрели чем тут можно помочь что какие слабые места и какие сложные для понимания места именно поэтому сложно стоит браться за сложные вещи кроме того когда ваши разработчики не могут исправить ошибки нормальная ситуация вы обращаетесь к комьюнити и комьюнити от вас ожидает что вы тоже участвуете в разработке программного обеспечения потому что это в направленный поток вот ну и как мы видим что точка зрения отдельного разработчика что точки зрения компании ведут к тому что нужно браться за сложные вещи но достаточно распространенные вещи в которых может помочь просто инженерная и научная работа ну и таким наиболее подходящим примером в данном случае мне кажется хеш-таблица которая ее хочет написать каждый разработчик программного обеспечения чтобы просто попробовать как ее описать поэтому оно много где есть в велосипедном видео на есть не только в библиотеках она есть и реализована во множестве открытых проектов в качестве по ними можно взять хэш-таблицу engine x прямо зайти накид hub можно даже прямо сейчас это сделать найти там папочку core в папочке корм на идти по бачку ngx шерсти и посмотреть что код который там находится что такое хэш таблица на всякий случай скажу но я уверен что все про нее слышали много много раз хэш-таблица это ассоциативный массив который позволяет выполнять условным быстрый поиск по ключу и основной вопрос в версии скажем так хэш-таблицы это способ которым разрешаются калязин на слайде вы видите разрешение коллизий при помощи связанного списка это наиболее понятный и часто используемый способ но к сожалению у него есть ваш кейс когда коллизии выстраиваются в длинную цепочку и лука по хэш таблицы выполняется неэффективно если мы посмотрим на хэш-таблицу engine x мы увидим что в этой хэш-таблицы есть два параметра которые задаются при конфигурировании это размер отдельного пакета и количество максимальное количество пакетов которое будет использовано в построенной хэш-таблицы тут надо сказать что у ынджон x есть важная часть философии которая говорит о том что максимум работы мы сделаем при старте главное чтобы хэш-таблицах и все узлы включая хэш-таблицу быстро работали при штатной работе соответственно код который создает хэш-таблицу индекс он оптимизирован они очень хорошо ну на сказать на прямо посмотреть код здесь мы видим код создающий инициализирующий хэш-таблицу который получает все ключи и все значения которые будут использованы то и хэш-таблицы и параметры которые мы задали в конфигурационном файле джинкс в вообще engine их используют порядка 20 различных хэш-таблиц для разных своих значений и для каждой из хэш-таблиц вы должны указать это значение в конфигурационном файле максимальное количество пакетов и максимально длину одного пакета далее у нас происходит такая вещь как поиск реально используемого размера хэш-таблицы и если вдруг нам не удалось подобрать размер который удовлетворяет параметрам которые были заданы в конфигурационном файле engine x не запустится ну выполнение на там прекратится то есть это касается каждой из хэш-таблиц рассмотрим поподробнее по алгоритмом подбора размера хэш-таблицы сначала выберу рассчитывается минимально возможное количество bucket of хэш-таблицы исходя из того что каждый баки заполнен полностью ключами и поиск реального размера хэш-таблицы начинается прямо вот от этого значения но если вдруг пользователь сконфигурировал систему так что у него большое максимальное значение в данном случае взята 10 тысяч и это значение прямо защита в коде 10000тысич а и стоят все вокруг это строчки подсвечены должен быть если количество элементов больше 10000 что мы стартуем не с минимально возможного значения с максимально возможного -1000 ну это такая оптимизация что давайте тогда искать другого конца если все-таки пользователь решил создавать большую таблицу и далее для каждого возможного и за размеров хэш-таблицы перебирается построение все и хэш-таблицы и расчет размера ключей которые попали в каждый пакет и если для определенного размера масса нашлось коллизий больше ушло столько к лизе что они превысили размер пакета то мы просто переходим к рассмотрению следующего кандидатов размеры при помощи прямо вот gutu ну видно что код можно было бы улучшить но это все как могли вы быть косметические улучшения что хорошего в этой реализации это кэш локальная реализация то есть поиск в этой хэш таблица с параметрами по умолчанию это двигаешь линий это очень хорошо показатель на самом деле и ему стоит стремиться многими библиотечным реализация кроме того если вы задаете минимально возможные если вы не конфигурируете хэш-таблицу 10000 элементов вы получите минимально возможную хэш-таблицу из всех которые существуют но вы будете перебирать много значений в которых точно нельзя найти нормально работающую хэш-таблицу из минусов неэффективны неэффективны и алгоритме инициализации но это минус который в общем минусом считать нельзя в условиях принято философии gemix но у вас есть два параметра которые временами у вас будут останавливать запуска сервера что может быть совершенно неприемлемо если ваши конфигурационные файлы пишутся скриптами пишутся каким-то образом автоматически вы можете получить эту проблему неожиданно мощью и в каких-то условиях которые ну в общем как в которых бы не хотели бы получить эту проблему и вот от конфигурационной части хотелось бы уйти и у нас есть множество алгоритмов которые описаны в науке которые обеспечивают похожие свойства но не требуют конфигурирования если вы выполните поиск по вот этой теме то первое что вы найдете это самая камин дуем алгоритмы так называемый fps хэширование алгоритмов алгоритм фридмана и его товарищей который по сути делает двухуровневые хэширования это рандомизированы рандомизированные под подбор двухуровневое хэширования которые гарантируют отсутствие коллизии казалось бы алгоритм должен получится не хуже но на самом деле в реализации вы получите от 4 до 5 кыш линейно поиск что ну в руках у жида чем 2 к ширине у существующих реализации и на самом деле это алгоритм сложный то есть вам придется доказывать моим тренером что этот алгоритм действительно то что надо потому что код ведь потом придется поддерживать не вам если вы будете предлагать кому-то патч не только вам в качестве альтернативной реализации можно было бы рассмотреть и каширование кукушки это значительно более простой алгоритм который обеспечивает поиск при просмотре 3 кашле ней и он стоит в следующем для каждого ключа который мы вставляем хэш-таблицу у нас рассчитывается 2 разных хэш-функций и в 2 разных ешь функции определяют два разных пакетов которых может находиться элемент и мы выбираем один из пакетов в котором элемент размещаем потом приходит следующий элемент у него точно также считывается 2 хэш-функции но одна из них уже занято соответственно элемент занимает оставшееся свободное место и в определенных случаях вам приходит новый элемент для которого заняты оба пакета на которой он претендует ну и в таком случае вам нужно просто один из элементов разместить перенести во вторую свою ячейку это может быть достаточно длинное переписывание между бакетами и такой алгоритм при нахождении цикла при переписывании элементов ice bucket of baked просто при переходе потому что хэш-таблицы должна быть увеличена это хэширование называется кэшированием кукушки потому что вы за переписывание элементов между багетами напоминает поведение кукушки в естественной среде обитания плюс этого алгоритма в том что переписывать надо минимум строчек кода но после придется добавить еще одну хэш-функцию ну вот собственно тут мы приходим потому что эти задачи я предлагаю студентам чтобы получить баллы ну за эту работу я предлагал порядка 200 50 баллов и пока что людей которые начали заниматься этой задачи нету сожалению что-то 250 баллов это примерно месяц домашних работ по курсу алгоритмов то есть на самом деле мы расчитываем что человек работает 21 таким курсом порядка 6 7 часов в неделю ну приличное время на самом деле вот ну то есть были люди которые заинтересовались тем и и разобрались как вот пока не начали писать это кстати будет касаться всех тем которые предлагаем есть более сложные вещи ну например такой сильно более сложные вещи будет являться любая любой lock free алгоритма и вообще любые вещи которые связаны с мульти трейдингом или какими-то сложными фиксирующими структурами ну вот некоторое время назад в полисе в 96 у нас была такая известная проблема которая называлась про крыло контингент суть в том что у нас есть разделяемый ресурс который называется прогрей и он защищен известной структура reader райтер лак и при фиксации транзакции зачастую райтеры не могли попасть в лоб и это снижало производительность системы мы сообщества вот подвеса решила эту проблему каким образом один из райтеров получивший таки эксклюзивную лакировку просто фиксирует все транзакции которые находятся в группе с ним но вообще говоря это проблема она такая достаточно общее ее можно было бы решать на один уровень выше на уровне самой лакировки то есть в научной литературе известный эффект raider старейшин связано с тем что множество райтеров должны каким-то образом действовать неконкурентна а согласовывать свои стратегии при занятии металл экспо ужин механизмов на самом деле конечно это тема не новая впервые она дату будет совсем сложно прочитать она впервые и поднимал брюшном жан в девяносто седьмом году ровно 20 лет назад он прочитал умную книжку по unix у и прямо оттуда скопировал параграф написал что есть рай текст relation его надо чинить и с тех пор раз в пять лет сообщества возвращается к этому вопросу но пока никто не приступила к собственно купили описанием этого механизма наибольше наиболее полезным источником информации наверно будет являться доклад dont stop the world такая шариковы spajic он если вы скачаете презентацию тут будет ссылка на его доклад ну за эту задачу мы даем условно 300 баллов на самом деле за такую задачи вы готовы дать все баллы которые есть потому что это задача оно восходит такое достаточно старый математические традиции давайте студентам гипотезу к lacie порешать или если их если кто-то говорить мотивируете математическими законами удивительные языки физики то мы хотим что-то типа поправки ван-дер-ваальса когда студент просто не знает что сложной задачи и и сделает но тем не менее это задачей которая требует такого научного подхода кроме того она требует достаточно большое количество железа которым студенты не располагает но в принципе если кто-то соберется серьезно заниматься этим вопросом подготовит какой-то код для тестирования думаю что в яндексе мы найдем способ помочь человеку именно с железом почему нужно железо потому что оригинальная проблема про грейлок intention не воспроизводилась на 32 ядрах то есть нужно сервер по мощнее чем 32 ядра in лэптоп уже как бы вообще не вариант ну это из-за таких гипотетических сложных задач которые можно заниматься вечерами есть вещи более простые которые связаны с тем что нужно уже стандартный подход применить в тех местах где он еще нестандартным это сэр энтони hour когда он работал в янгу над машинным переводом он изобрел быструю сортировку это очень распространенный алгоритм сортировки он сейчас изучается в любом курсе по алгоритмам и он легко пишется он легко тестируется он ну ладно не легко но тестируется нормальному единственно его проблема в то что иногда он сталкивается с худшим случаем так называем киллер sequence последовательностью которой вызывает квадратичную сложность сортировки у этого алгоритма кажется что это последовательность которая должна встречаться редко но она часто бывает в под последовательностях которые вы сортируете и то есть чем больше количество данных вы сортировки тем больше с какой-то вероятностью внутри общей последовательность есть это подпоследовательность и эта проблема известная она довольно давно вечное решение одно из решений называется интроспективной а сортировка и суть состоит этого алгоритма состоит в том что при достижении определенной глубины рекурсии в сортир в коде сортирующие вы просто делаете fall back на другой алгоритм сортировки у которого который в среднем хуже работает чем picsart но вот именно с у него нет вождь кейса вы можете посмотреть реализацию интро сорта например в std тесто до 40 сейчас будет интро сортам либо можете посмотреть ее реализацию в тут найти там достаточно хорошо оптимизированы реализации ну другой альтернативы является тем сорт и например в подписи уже есть шаги в сторону тем сорта ну в том коде 93 года которые там используются там есть эти шаги то есть шаг состоит в том что мы сначала перец сортировкой проверяем они отсортированы последовательность уже за нас если отсортирован то и не делаем ничего это основа идеи тем сорта этим сорт старается использовать от заранее отсортированные подпоследовательности когда вы работали над алгоритмом сортировки в основной памяти в субботы на понимать что это не то что выполняется когда вы добавляете ордер баев свою сколь выражение то есть сортировка стану в основном в суде выполняется с помощью специальных алгоритмов внешней сортировки которые работают могут переключиться на работу с диском и сортировка служит для решения множества служебных задач но тем ни менее улучшение алгоритма сортировки может привести к общему повыше повышению производительности системы но среди предложенных вариантов не перечислен mais quel потому что после того как мы задались этим вопросом в воздухе может не после этого ну просто совпало хочу что в апреле они путь в москву или подчинили себе сделали с тодес использование стадо сальто и интроспективной сортировки в москву или в мария по-прежнему quickstart в подписи у нас был очень такой толковой студенты который хотел этим заняться но нам на программе google summer of code не хватило одного слота и пока что он к этой теме не возвращался я думаю что не будет до следующего лет то есть поле в принципе открыто желающие могли бы попробовать что-то сделать в этом направлении ну мы условно даем 180 баллов это вроде как три недели работы человека три недели работы над проектом вместо изучения вместо сдачи домашних работ по курсу алгоритмов но 180 баллов можно получить за каждую судьбе форков у нас много ну и вообще разных свободы много ну и последний проект и которым я расскажу это достаточно близко и мне р дерево тут снова будет фотография тоже сэра срн танин гутман изобретатель р дерева и структура данных которые используются в дело информационных системах для различного поиска ближайшего соседа для быстрого получения его информационных данных вот именно по какой-то локальной области данных ну короче это индекс это сбалансированное дерево которое использует и иерархию вложенных повелел топов ну в случае с двумерным случаем это вложенные прямоугольники нас строится из за ряда довольно простых алгоритмов и было предложено 38 четвертом году реализация р дерева есть в движке myisam и это ну короче slim такую реализацию сдавали студенты я бы сказал что это очень круто нет в смысле не знаю как сказать в общем хорошая реализация она сделана прямо так как задумал автор сэр энтони нe готтман строго по бумаге насколько строго гутман не мог решить между двумя алгоритмами выбором вставляемого под дерево по площади ограничивающего прямоугольника и по периметру ограничивающего прямоугольника и описал два алгоритма один другой авторы движка myisam сделали оба один закомментировали то есть они тоже не знали какой правильный ну это их не остановило они сделали так как надо было сделать они последовали за учёными ну доверились ученым скажем так и в принципе это работает работать достаточно давно и работает так что в именно дебит тоже захотели создать реализацию дерево но они ориентировались ну я конечно так могу судить только по коду но мне кажется что они ориентировались не на год мы ориентировались на авторов мой зам потому что функции называются очень похожи но вызываются немного не так как надо вот там встречаются странные вещи например вот внизу кода вы можете посмотреть что происходит защита от переполнения но сбрасывается минута здесь значение по которому защищается на другое значение как так получилось не до конца понятно зачем так получилось ну комментарий есть но он не объясняет почему мы здесь сбросились них дабл максов до был макс пополам кроме того в этом коде вот это был код вставки элемента в r дерева и мы при этом проходим по дереву сверху вниз от больших прямоугольников к маленьким и нам нужно выбирать куда мы вставляем в этом коде используются некоторые условия не полностью соответствующие гениальные задумки то есть у нас есть функция которая вычисляет необходимое увеличение площади прямоугольника покрывающего данные она возвращает не только увеличение но и саму площадь под параметры серия но авторы фенотипе не стали использовать этот возвращаемый параметр него просто игнорировали по идее нужно было сделать что нужно было в случае равенства увеличение площади выбрать под дерево с минимальным ирия но это вот условие не попала в в условия которые нужно было использовать ну и кроме того в ходе можно найти вещи что код тестировался и находили edge кейсы то есть например такой кейс когда все вставляем ее данные находятся на одной линии при этом у вас увеличение площади а не нулевые потому что все данные выровнены и но правильнее было бы сделать fall back к выбору по по периметру но тем ни менее инженерами и на тебе они решили просто приравнять моли в данном случае k-001 ну чтобы 0 не получилось и сравнивать длины вот это тоже можно исправить просто прочитав бумаги которым 30 лет сейчас ну она сказать что р дерево это не единственный пространстве на яндекс то есть на этом слайде показана история многомерных методов доступа к многомерным данным до 96 года почему-то 96 года потому что дальше произошел комбинаторный взрыв их стало еще больше и вообще можно было бы выбрать что-то такое более актуальное более совершенная и я бы рекомендовал перейти к реализации revo эстер star 3 норберта бекмана и бернардо де гира of авторы этого индекса они охотно общаются по емейлу охотно отвечает на вопрос единство что вы не сможете применить их исходный код потому что он ну он написан в исследовательских целях это не production код который можно просто скопировать вставить отправить pull request и быть довольным придется работать довольно много и придется переписывать какую-то инфраструктурную вещь ну и мы говорим о том что исправить неточности это меньше чем 2 недели а вот написать индекс почти с нуля это хорошая задача за которым собственно тоже можно было брать сколько угодно баллов ну где взять инструменты наверное я бы порекомендовал если вдруг вы еще не заинтересовались алгоритмами записаться на курс алгоритмов и структур данной школы анализа данных вы можете посмотреть видео-лекции и вот про сортировку там и хэш-таблицы вам там расскажут очень подробно и с множеством математических деталей конечно которая сейчас пропустил наверное классическим трудом по этому просто является алгоритма корка румяна книга по алгоритмам кармана и его коллег ну также можно порекомендовать книжку и shot который тоже присутствовала сейчас в магазинах ну и несколько важных вопросов во первых если вы собираетесь что-то делать напишите в рассылку проекта скорее всего до вас кто-то занимался вопросом есть какие-то подводные камни которые вы еще недооценили то есть вот те проекты про который я говорил ну у них тоже конечно он надо писать рассылку если вы собираетесь что делать но не стоит ограничиваться только ими вы можете найти интересные исследовательские задачи почти в любом проекте и первое что нужно сделать узнать что было сделано до вас и когда вы написали в рассылку проекта это тоже еще не время короче после того ка вы написали в рассылку проектом нужно еще проверять почту и дождаться ответа из рассылки возможно технология которые вы хотите предложить доработка алгоритма который вы хотите предложить в принципе нежелательным тренерами ну и для сохранения мотивации крайне желательно писать о том что вы делаете мне по крайне мере регулярные посты друзьям о том как я тут в круче вы и какие то функции там пенальти функции очень такое там биты как передвигаю сильно помогали сохранить мотивацию и вечерам вечером перекрутится не то мне в counter-strike с quake ома в джесси и вот все такое чтобы я хотел чтобы закону какие вы я хотел чтобы вы сделали выводы из этого доклада в любом достаточно большом открытом проекте есть место для человека который готов разобраться в сложном алгоритме и готов писать хороший код поэтому стоит искать и тратить на это время потому что это будет полезно вам это будет полезно миру ну а на этом я предлагаю вам сегодня вечером взять же сиси что-нибудь собрать и что-нибудь немножко по модифицировать поискать интересные места может быть вы захотите реализовать что-то из тех идей про которые я сегодня говорил я спасибо давайте перейдем к вопросам кого-то есть вопросы если что пишите мне в телеграмм это такая штука который можно делать вместе ну я думаю тогда концу вот вопрос вопрос полу того от хэширование алгоритм добро пушкин помощь им как будет происходить поиск элемента когда вот была вставка в c вот и в 1 и 2 позицию уже была занята поэтому и передвинули а мы передвинули а в во второй bucket а то есть когда мы ищем а у нас есть два пакета которая нам нужно проверить если ни в одном из этих пакетов нету то поиск неудачны то есть вот такая ситуация то что мы можем таким образом потерять там нет мы просто не построим хэш-таблицу в которой они находятся в одном из своих двух возможных bucket вот то что о чем вы говорите это тоже отдельные интересные виды хэш-таблицах называется хэш таблица с открытой адресацией которые предполагают необходимое смещение после ключа после выбранного похожу баке это просто до тех пор пока вы не подходящее место они быстрее строятся чем хэширование кукушки но они значительно менее кэш локальные потому что менее кэш локально в худшем случае кукушка вам гарантирует честные тыкаешь линии ничего лишнего однако шли нет ну ладно сейчас не будем считать вот я понятно ответил или может что-то еще конкретизировать ну хорошо вроде венца я думаю можно еще раз поапладировать спикером"
}