{
  "video_id": "1tNfKI03qRU",
  "channel": "HighLoadChannel",
  "title": "Миллион WebSocket и pub/sub / Сергей Камардин (MailRu Group)",
  "views": 15115,
  "duration": 3249,
  "published": "2018-01-16T13:11:02-08:00",
  "text": "меня зовут сергей комардин я работаю программистом в команде почты mail.ru и сегодня я хотел бы рассказать вам историю о том как мы написали и запустили в продакшен систему уведомлений или систему обмена сообщениями между сервисами mail.ru и конечными пользователями мой доклад состоят из двух частей первая часть такая боль больше архитектурной наверное про то как это все работает логически вторая часть более техническая о том как мы какие оптимизации мы применяли какие какие проблемы решали и что из всего этого получилось собственно вторая часть немного праязыка но я как бы старался в детали языка и привязываться к языку избегать собственно для того чтобы вообще начать наш разговор наверное стоит дать какие-то общие совсем определения и начнем мы естественно за ключевой ключевого понятия разговора это состояние события что такое состояние состояние это вообще любая хранимой информация программы которая нужна для ее работы которая со временем меняется событие это всего лишь информация об изменении состояния скорость реакции на события как и отсутствие реакции на какие-то события имеют свою цену иногда важно реагировать на какие-то события но это может быть дорого и точно также можно не реагировать на другие события и это тоже будет дорого например если вы будете очень медленно реагировать на пришедшее письмо в почте или на пришедшие сообщение в любом из мест anger of это будет дорого с точки зрения удовлетворенности пользователей поэтому как бы всегда нужно искать золотую середину переходим к почте какая информация является состоянием вообще в любом почтовом сервисе сервисе обмена сообщениями ну в первую очередь это количество писем в ящике какие то возможно флаги этих писем пометки о прочтении удаление и так далее ну и безусловно срок жизни сессии пользователя то есть это вообще относится ко всем возможным приложением как работала до нашего погружения в мир websocket of и программирование нога браузер по старой-доброй технологии которая называется еще теперь полинг спрашивал сервера наличие каких-то изменений в ящике пользователи он занимался этим каждые две минуты таких запросов у нас около 3 миллионов в минуту или 50 тысяч запросов в секунду что важно 60 процентов ответов на такие запросы были со статусом 304 то есть символизировали то что в ящике то ничего не изменилось как бы это наверное не очень хорошо и нам есть есть что оптимизировать и попросту не гонять трафик как мы хотим это сделать хочется чтобы сервер сам отправлял уведомление об изменении ящиков пользователей тогда когда это действительно происходит и стоит вопрос как мы это будем делать идеологически мы выбрали такой шаблон проектирование он называется publisher суп скрайбер применяется как внутри программного кода так и между сервисами нами все знают даже такое pops up если кто не знает вдруг издатель отправляет то есть есть два компонента издателей подписчик и какой-то третий компонент между ними который управляет сообщениями между этими компонентами издатель определяет какое-то множество событий которые он будет класть в этот третий компонент подписчик подписывается на какое-то подмножество этих событий опять же через этот третий компонент такой третий компонент называется шины событий место чп брокер или левин channel разные имена схематически резюмируя старое и новое поведение у нас есть 3 компонента все архитектуры абстрактно сторож так называемый сторож это хранилище ящиков пользователей по сути да то база данных где все это хранится есть какой-то сервер фронт-энд api который работает с браузерами с приложениями с вэбом но есть браузер старая схема работала так браузер посылает ешьте запрос на пи а приведет сторож сторож отвечает либо 304 либо 200 в своем формате и api отвечает браузеру новая схема выглядит так мы вводим по сути два новых компонента то есть api и он остается как бы open у выполняет совершенно другую функциональность и совсем новый компонент это басы лишены событий браузер устанавливают в соке соединения с api и в какой-то момент посылает подписку на какое-то событие я хочу получать уведомление об изменении какого-то ящика api или websocket сервер сохраняет эту подписку в какой-то своей внутренней структуре и отправляет похожую подписку в шину шина то же самое делает у себя и все система как бы работает в какой-то момент сторож получает письмо на ящик браузера и посылает просто события о том что на таком-то ящики приду снова письмо шина мотивирует его по своей вот этой внутренней структуры и понимаешь что это событие нужно отправить вот этой вот ноги api та в свою очередь отправляет потоки ту события в браузер как вот владимир передо мной рассказывал ваши архитектура не очень хорошие если вы не задумывались scalability до о масштабировании то есть посмотрим как это могло бы быть если у нас было много серверов тыс у нас простое линейное как раз масштабирование горизонтальная у нас много-много стара j много много серверов api и много шин браузеров тоже много он просто сейчас давайте будет один все то же самое websocket подписка api сохраняет у себя подписку браузер устанавливает соединение только с одной ноты websocket сервера но в обсудит сервер в случае с несколькими шинами подсылает подписку на все шины это нужно для того чтобы сторож который посылает ивенты об изменении ящика мог каким-то образом сортировать эти уведомления и не не слать весь поток уведомлений по всем всем всем ящиком на одну шину и не завалить ее достаточно в нашем случае это даже можно сделать просто с помощью round robin а то есть даже не сортировать ничего вот пример того как сторож посылает в какую-то из шин события точно также matching и точно такое же давление было в соке это ну и так же с другой ноги я уже несколько раз сказал что его пи и в шине есть некая структурка которая позволяет хранить подписки пользователей и каким-то образом определять в какое соединение отправить то или иное событие хочется сказать пару слов об этих структур к хвоща подходах маршрутизации событий существуют такие основные на мой взгляд три стратегии это flooding так называемый и гаси pink это стратегии отправки пакетов грубо говоря мультика стану в том или ином виде то есть в афлубин где мы отсылаем события все многом какой-то подгруппы и каждая нота уже сама решает обрабатывать и это событие или не обрабатывать то есть посылать грубо говоря это событие в websocket если у нее вообще такой клиент или нет гости pink почти то же самое заключение того что мы посылаем пакетик какой-то там одной ноги или 2 нодом они в свою очередь своим соседям те своим соседям и таким образом они распределяют все пакетики и какая-то но до находит нужный ей пакетик среди этого флуда минусы наверное очевидно это во-первых много сетевого трафика во вторых достаточно большая задержка между публикации события в шину и и доставкой конечному пользователю но есть классический наверно способ фильтр фильтрация его мы выбрали то есть грубо говоря shinee всегда знает какое событие какому connect у нужно отправить то есть однозначно может определить это без разбрасывание пакетов фильтрацию можно реализовать разными способами можно взять базу данных и сохранять все подписки туда можно написать какое то свое дерево сугубо предназначенная сугубо для вот таких вот задач роутинга мы выбрали вот первый способ то есть дерево в памяти важный нюанс что при таком простом методе фильтрации с деревом нужно учитывать что издатели публикуют полный набор параметров ну допустим у нас есть события которое содержит параметры a b c издатели всегда публикуют все эти три параметра а под подписываться можно на любые можно вообще без параметров подписку сделать тогда мы будем получать вообще все события с любыми значениями этих параметров можно по какому-то одному ну и так далее то есть это по сути такой к вере кайри фильтр вот так выглядит дерево маршрутизации у нас вот в памяти ну грубо говоря обобщенно я сейчас покажу на примере как как мы отфильтровываем событие на примере вот например пришедшего события от тораджа да там написано 2 это publisher грубо говоря очень чат и события которые он издает и какие-то мета-данные на нашем случае это e-mail мы идем с корневого элемента чисел ки в квадратных скобочках это дескрипторы соединений скажем какие-то adige ники соединений в которой мы потом это событие спроектируем мы идем с корня видим что там есть какой-то отчаянный подписчик под номером один который хочет получать вообще все события от всех издателей записываем его дальше видим фильтрацию по емейлу находим соответствующего подписчика по цифры 8 тоже самое ну и я думаю всем примерно понятно да схема работы то есть вот как раз пример того что подписчик под номером 8 подписался только по емейлу подписчик номер два подписался на сторож дано всей wanted старриджа и подписчики 37 на всей ventas тораджа event женщину есть совсем детальные подписки которые вот содержат весь путь все параметры события таким образом мы вот отфильтровали получили получили список коннектов которых который мы отправим в итоге вот этого уведомления теперь провод websocket про этот канал который устанавливается между браузером и frontend сервером пару слов высоких это бинарный двусторонний протокол общение между сервером и браузерное на все в курсе то тут услышал про пса кит все отлично это не буду это деталях рассказа кто кто использовал востоке вообще не интересно ну тогда там цифры до 2011 год россии поддерживается почти всеми современными браузерами ну точнее все минусы головками и http он использует только для апгрейда после http апгрейда мы работаем с каким-то берн бинарными фреймами внутри внутри тисе пи соединения они бывают 5 видов это пинг-понг для определения живучесть и соединения и клаус фрейм для сигнализации о том что соединение закрывается по инициативе какой-либо из сторон стоит отметить что в случае отправки например одной стороной фрейма клаус другая сторона по протоколу должна ответить таким же фреймом в таком случае считается что соединение закрыто нормально но есть два пользовательских типа фреймов этот текст и buy на ли оно понятно все тоже видели до эту картинку все руки принимали знают то есть спецификация фрейма как вообще фрейм выглядит на самом деле основные три момента до это как раз четыре бита держит тип фрейма длина может быть вот 7 бит до 64 бит то есть можно посылать гигантские пакетики можно их фрагментировать кстати но и просто данные теперь несколько слов о том с какими мы столкнулись особенностями когда реализовывали все это дело на сервере chrome вот как я сказал дал там туго и клаус такой хан шейк происходит вот chrome не дожидается ответного клаус от сервера и сразу рвет соединения то есть в принципе это по сути ничего страшного но если вы например каждый раз пишите ошибку да там на какое-то закрытие или отправку ответного клаус фреймов соединения вы можете весь лоб и списать такими сообщениями поскольку фронда большинство у нас дальше firefox периодически посылает pink фреймы ожидаю в ответ pong это нормально но кроме firefox это этого не делает никто грубо говоря если вы реализуете веб-сервер на таком низком уровне с фреймами да вы все-таки должны подумать о том что pink нужно как-то обрабатывать ну и самое интересное интернет эксплорер периодически посылает pong фреймы вот но это кстати да не противоречит спецификации там есть такой пункт что пир может посылать панги типа как бы независимо от входящих пингов вот но кстати был баг в какой-то версии 9 или 10 что интернет эксплорер не дожидаясь ответного pink фрейма закрывал соединение говорил что оно неправильное вроде пофиксили вообще трудности вот этой схемы даст с нашим высоким сервером и websocket ими вообще практически на 90 процентов трудностей были связаны с тем что нас 3 миллиона живых соединений на самом деле до доклад называется миллион но в итоге оказалось три и время жизнь этих соединений она совершенно непредсказуемо какие-то соединение живут несколько секунд какие-то могут жить несколько дней и самое наверное страшное в этом то что мы не можем просто например взять и упасть если что-то нас пошло не так да или клиенты которые реализуют подсоединения к нашему websocket сервер серверу должны тоже не быть чуть чуть более умными чем просто там перри подключаться при каждом разрыве противном случае мы просто можем себе извиняюсь можем принести себе много головной боли с так называемым сел в видосом или просто dido сам самих себя да там ну например у провайдера у какого-то из провайдеров больших прорвал провалить все connect и то есть например 500 тысяч сокетов которые у нас были установлены получили там и роста или еще какие-то ошибки и разорвали соединение начинают ломиться все при подключаться если у нас например в websocket сервере какой-то баг или там какой то есть battle.net который не позволяет обрабатывать сразу такой обширный поток мы можем начать грубо говоря ну либо вообще vdo благодаря вставать либо начать жестко тормозить а будут приходить еще новые соединения которые там по старым они получают например пингов или там рвутся как неактивные ну и так далее мы так друг друга сами себя наваливаем такую лавину соединений и как то с этим нужно жить с я там дальше расскажу немного в технических деталях как мы с этим боремся и какие приемы используем собственно да вот теперь отправились light go еще один опрос кто знает что такое язык о отлично вообще кто кто пишет тоже супер а кто хотел бы написать сейчас большинство новички разработчики да просто что просто такой тренд не знаю с чем он связан действительно много pitch разработчиков приходит на горе не в укор лишь пи как языку собственно для тех может быть кто не поднял руки на первый вопрос кто не слышал да вкратце двух словах что это компилируемый язык статической типизации в нем из опа и столько структуры интерфейсы то есть нет классов и наследования что в принципе не мешает вам разрабатывать в парадигме и в нем есть garbage collector то есть выделение памяти по идее происходит автоматически и сборка их тоже освобождение памяти ну и самое главное самое главное отличительная черта которая выгодно поднимает этот язык для решения подобных задач это то что в нем есть какие-то примитивы языка которые позволяют работать в конкурентном в конкурентной парадигме программирование то есть это канал и игру тины канал это опять же кто не знает это просто по сути pipe и до в которой мы кидаем сообщение с другого конца его вычитываем или очереди хочу можно назвать так совсем грубо ага рутина это просто какие-то внутренние легковесные 3d горан тайма но поскольку все знают гай большинство из вас пишет на нем или хотела бы написать давайте попробуем разобраться как вот мы бы решали в лоб эту задачу то есть обработку в соке соединений работу с ними в таком объемном при такой объемный нагрузки в три миллиона соединений ну у нас есть пакет нет да стандартной библиотеки в ней в этом пакете есть такой интерфейс как соединение con там есть еще дополнительные методы но мы будем работать только с двумя простыми рид в райт на все наверно понятно определим какую-то структуру канал нашем случае это websocket канал естественно он содержит себе внутри это так называем приватное приватное поле с tcp соединения что мы хотим делать с этим соединением в первую очередь конечно мы хотим отправлять в это соединение какие-то пакеты определяем собственно pipe или очередь или правильно говорите канал пакетов исходящих ну и начинаем инициализировать как-то нашу структуру определяем конструктор что-то там какие-то поля устанавливаю и самое главное мы запускаем 2 га рутины reader и в райтер нам понятно да что что а не буду делать то есть трейдер будет читать из соединения райтер будет писать сведениями прежде чем перейти к их реализация стоит отметить что картины в используются так и начинают естественно используется такое начинают с 4 килобайт то есть на стек 2 га рутину нас уходит уже 8 килобайт на одно соединение если учитывать что у нас 3 миллиона живых соединений то это 2 4 гигабайта едем дальше риттер естественно чтобы как-то сократить количество си сколов да на чтение не читать там по 10 байт или поступает мы будем каким-то образом буфере zerowatt чтение соединения это еще 4 килобайта ну если не устанавливать какие-то кастомные цифры и дальше мы бесконечном цикле начинаем каким-то образом там читать входящие пакеты и обрабатывать их стоит запомнить вот это место потому что к нему мы еще вернемся на следующих слайдах чуть-чуть по оптимизируем еще там то есть в данном случае go просто заблокирует нашу грудь и ну и пока не появятся байтики входящих пакетов ничего не будет происходить слайдером почти тоже самое но точно также буферизируется запись в канал в соединении чтобы сократить количество си сколов опять же берем 4 4 килобайт ней буфер и уже и тонируем ся по нашей очереди или нашему пайпу или нашему каналу out и ждем потерь пакетики которые мы хотим записать в соединении ну и каким-то образом пишем также грудь и на блокируется понятно да если нет исходящих пакетов уже сорок восемь гигабайт памяти до 44 это стек 442 буфера за без чтения дальше посмотрим на также встроенную в стандартную библиотеку ищите типе и нам же нужно как-то принимать сначала с тебе запросы да вот которые хан шейков great то есть мы воспользуемся стандартной либо и установим какой-то маршрут в данном случае ws и передаем какой-то call back в call back на получаем 2 структур ки точнее одна интерфейс 2 структура первое это интерфейс записи ответов 2 это непосредственно сам request который пришел к нам стоит также учесть то что на response райтер у нас есть буфер тоже равны 4 килобайта когда мы будем писать ответ внутренняя библиотека тоже не хочет платить и сколы и request нас также буферизируется точки тени и самого request а также буферизируется четырьмя килобайтами и получив этот запрос мы можем каким-то образом взять какую-то пока что реализацию websocket а за грезится с помощью какой-то библиотеки стоит отметить что это зависит от библиотеки но так или иначе скорее всего вы будете сохранять в каком-то в своем канале как как минимум request потому что он содержит заголовки cookies и прочую информацию которая вам возможно будет нужна в процессе работы с соединением но может быть и даже врать буфер будет сохранён если если все написано неаккуратно таким образом уже семьдесят два гигабайта семьдесят два гигабайта на три миллиона соединений это с учетом того что мы не сделали ничего то есть он просто обрабатываем 3 миллиона соединений которые ничего не делают ничего не пишут точно никакой бизнес логики мы не сделали это кажется многовато такие вот ленивые уже толстые как как это все можно с оптимизированной верно стоит учесть что наши демоны работают на linux и также учесть один самый важный момент что в основном соединение наши бездействует то есть они очень редко пишут байтики нам и мы достаточно редко в них пишем то есть по сути вот эти все буферы которые мы там на лации равале вот эти все грудь инны ридеры в райтер они по сути нам не нужны потому что они просто тупо стоят и ждут когда кто-то нам что-то напишет наконец в linux есть но уже слышали до на предыдущем докладе очень интересным есть такая утилита которая называется и пол она позволяет работать событиями ввода-вывода то есть грубо говоря мы подписываемся на входящие байтики в соединении получаем какой-то ивент когда они придут я просил в риддере запомнить вот этот вот цикл до когда мы блокируем ся на чтение и ждем входящий байт а вот эта грудь и на в данном случае заблокированы она просто ничего не делает буферы где-то там выше салат ирован как работает вообще go runtime в таком случае когда мы говорим can ride вызывается ну какая-то внутренняя функция greet я ее попытался сильно сильно упростить но суть суть сохранить оно вызывается с какой-то внутренний структурка и соединение но и с аргументами вашего вида все что она делает она просто делается скол рид на файловый дескриптор и сокета соединения и передает туда буфер в которой нужно прочитать если syscall возвращает ошибку ошибку он может вернуть скорее всего ей again или е вот блок если socket у нас не блокирующие афгане не блокирующие the runtime вызывает внутреннюю функцию которая называется пол weight и передай туда какой-то там дескриптор для пол на самом деле называется пол дескриптор ну как можно догадаться это дескрипторы пола в линуксе и хочет ждать там каких-то ивентов на чтения то есть runtime блокируют нашу грудь и ну куда ты и откладывает и говорит там вызовите меня я разбужу и разбужу эту рутину когда будут данные вот в этом коннекте дар приземные соки это не блокирующий уран там ползает на linux сделан с помощью пол вопрос почему бы нам не сделать то же самое поскольку пока что runtime не предоставляет нам такого и пи ай йаран . хотя там есть на самом деле и шью языке go от берет фицпатрик который контейнер г он примерно похожим вопросом задавался можете поискать то есть суть известно проблемы но пока этого всего не реализовано мы запилим свой пол инициализируем канал я здесь не буду писать как мы реализовали и повод по сути просто подвязка над системным вызовом как мы как мы его будем использовать основная идея выглядит так что мы передаем в и пол наше соединение и предан просто call back который будет вызван когда в соединении появятся данные для чтения мы работаем только с входящими байтами мы не используем там возможность записи в соединением то есть если говорить про конкретные флажки то это неполный ну и болван shot то есть и полный как раз говорит о том что мы хотим получить уведомление о том что в соединении есть данные для чтения и пол ван shot позволяет нам исключить конкурентные вызовы нашего камбэка в тот момент когда мы ещё не закончили читать первую порцию данных то есть для того чтобы на самом сделать сделать вот этот вот этот вызов рисуем то есть мы нас в наш call back вызвали в соединении получились данные мы что-то с ними делаем и это гарантирует нам то что нас никто не прервет новым вызовам ну а что же мы будем делать мы по сути делаем то же самое что мы делали в риддере дано только не в бесконечном цикле один раз мы берем какой-то буфер естественно его можно переиспользовать можно создавать новые это уже детали и читаем и соединение хотя бы один пакет может прийти несколько пакетов сразу то есть это стоит учитывать мы вызываем эту функцию в калби кино и пол прочитали пакет вернули соединение в и полу ждем следующих ивентах кажется просто записью на самом деле еще проще мы всегда знаем когда мы хотим отправить пакетик пользователю поэтому там нам не стоит запускать в райтер сразу и и всегда и тренироваться по очереди вот это водоканала пакетиков исходящих мы можем запустить в райтер только тогда когда в этой очереди что-то появится на примерно так то есть у нас какой-то methods and packed мы просто там основе по какой-то логики там синхронизации проверяем что не запустили или мага рутину в райтера если не запустили туда войти к ее запустим а потом положим в очередь на отправку наш пакетик в райтер этот этот пакетик там прочтет а может быть просчет еще другие пакетики из которые пришли из других мест до из других грудь in ну и потом через какое то время просто перестанет работать выйдет следующий раз к мы откроем пакетик он снова заспавнится и и так далее то есть мы не держим буфер на соединение в которой мы ничего не пишем мы не держим просто так салат ированный буфер 4 килобайта на каждое соединение тогда минус сорок восемь гигабайт надвига рутины и на два буфера но в этом есть один нюанс как мы будем себя вести если вот у нас есть 3 миллиона соединений и все они вдруг ну вот например за дисконект или и при коннекте ли снова или все они по какому то вдруг там событию решили нам что-то написать то есть мы возвращаемся к нашей первой до проблеме что у нас будет опять три миллиона га рутин запущена потому что в каждом соединении появились данные 3 миллиона будет буферов 3 миллиона буферов на чтение на запись но не чем мы на самом деле получается при таком кейсе не сделали решение до этого то что еще сказал решение the pool грудь им мы можем запустить какое-то количество фиксированной грудь in которые будут писать в соединении читать соединения и они же будут аллоцировать буферы на чтение на запись и и все то есть грубо говоря пол worker of элит red bull да если там не в терминах бы два метода допустим есть шидал который выполняет просто функцию на одном из worker of в одной из грудь in и schedules тайм-аутом то же самое но с тайм-аутом как бы выглядел наш код например с и полом при использовании пула вот так мы создаем пол какой то мы можем его взять глобальным то есть еще 128 грудь и на все приложение или 128 грудь и не только на чтение тоже зависит от разных предпочтений но суть в том что мы на каждое событие о поступлении данных в соединения мы теперь не начинаем читать из соединения сразу а говорим что давайте мы прочитаем из этого соединения вот когда там какой-то из маркеров будет свободен и только потом мы рисуем connect то же самое с отправкой то есть было у нас вот так мы на каждую отправку вспомнили новую грудь и ну отправляли в этой грудь и не пакетики а вы тут так то есть мы изменение практически не какие-то минимальные но таким образом мы строго лимитирует количество буферов которые мы ассоциируем на чтение на запись то есть если 128 запросов пришло то 129 будет ждать пока какой-нибудь из них либо почитается либо запишется в соединении и 129 буфер никогда не будет салат ирован понятно да всем пока как-то так это и усыпил и вас последняя оптимизация наверное которая помогла нам после и пол существенно снизить потребление памяти где-то в три раза это так называемые мы ее так назвали zero копий апгрейт то есть вернемся к немножко websocket ом и качестве te pido вот так выглядит стандартный запрос на абгрейд соединения там заголовки всем наверно известны более менее но по протоколу это просто websocket специфик заголовки то есть какой-то ключ версия там и так далее что если зная вот что наш сервер на самом деле обрабатывает только websocket и да мы не обрабатываем какие-то другие там rest api и так далее зачем нам вообще использовать по сути стандартную библиотеку вот вот этот вот код потому что во первых там как я уже сказал 4 килобайта чтения 4 килобайта запись + request когда заполняется входящим запросам он лоцируют еще например несколько map ну как минимум одну на заголовке до копирует туда ключи заголовков потом на каждой ключ заголовку он создает массив значений из одного обычные элементы туда же копируют эти строки значений и сносим все вот это вот нам по сути если нам это не нужно то мы можем это выкинуть и написать свой простой сервачок будем слушать какой-то тисе пи socket на каком-то порту и сами принимать соединения но стоит тогда вопрос а как на вот это вот все вычитывать все эти заголовки там за парси и так далее ответ что наступило время запилите свою либо потому что что в год существует две реализации в об sucked это горилла websocket и x над websocket и они в принципе неплохие обе им ее хобби пробовали но они не позволяют применить вот эти все оптимизации про который рассказывал прямо с самого начала потому что они предоставляют более высокоуровневой api они сами тома лоцируют буфер сами его держат на ваше соединение то есть не позволяют вам достучаться до него в максимум можете управлять размером этого мусора ну и плюс они не позволяют как раз используют зиру copy of grey то есть я не видел по крайней мере реализации такого апгрейда соединения и чтения заголовков без копирования поэтому пришлось до реализовать свою библиотеку которое будет обладать чуть более низкоуровневым api плюс обладать возможностью проводить зиру копия great собственно это уровня название пакета из особенностей она вообще не работает с интерфейсом соединения работает только с и у редактор это два интерфейса стандартного пакета и о которые имеют соответственно каждый по одному методы в райт то есть это в принципе позволяет вам написать любые обертки над соединением да вы можете писать фреймы непосредственно прям сразу в соединении без буферизации если вам не страшно за syscall и либо вы можете там применять какие-то обертки над вообще туда же стримить запись фреймов шифровать их и так далее и библиотека не будет вам мешать это делать просто чуть более низкий уровень api ну да она проходит авто бант из юты то набор тестов на реализацию эры все по бенчмаркам там вот бенчмарках тестируются два метода апгрейда то есть там есть метод апгрейда в библиотеке из используем стандартного http да то есть вот с этим с request вам с кучей аллоцирование хм об ее строк и есть метод для апгрейда просто голову соединения ну вот результат я думаю очевиден до что у нас 0 локации потому что мы не копируем никакие заголовки мы ничего не делаем мы проверяем на лету то есть мы прочитали строчку заголовка с морем охает acer websocket кей он должен быть таким-то таки такой оки и дальше пошли то есть мы ничего не копируем вообще конечно если вам нужно для вашей работы как я уже говорил может быть какие-то заголовки или какие-то кусочки кук то естественно вам все-таки придется их скопировать в какую то там свою вот эту структуру channel или что то в этом духе но так вот в голом виде это не не приносит вообще локации никаких минус 2 4 гигабайта то есть мы освободили те семьдесят два гигабайта ну плюс-минус которые пожирали наши три миллиона соединений теперь можем их используют для какой-то своей там внутренней логике последняя и как бы резюмирующий а техническую часть я говорил что у нас часто были diedas и но они действительно нас были частые на самом деле тут локи частые грейс кондишен и часто то есть с большим соединение с большим количеством соединений это сразу оголяет все ваши проблемы в коде риф логики и так далее так вот чтобы решать будут локеры из это не поможет а если решать проблему с каким-то валом подключающихся соединений то наш вот этот вот пул и наша возможность принимать и не принимать соединение собственно ручно приносит тут вот фичу что мы можем отклонять просто соединение то есть если пул наш забит до и мы не можем зацепить новое соединение ну например да мы знаем что пул сейчас он занят под завязку то мы просто его не отсыпьте мы например если у нас и jinx перед нами стоит он просто переходит к следующему апстримом и просто не принимаем соединение просто иллюстрация того что сейчас сказал мы берем библиотеку на библиотеку ws слушаем тисе пи socket и пытаемся за schedule ить какое-то действие в нашем пули или пули с тайм-аутом ну например с миллисекундам тайм-аутом просим выполнить вот эту функцию в этой функции мы делаем как и раньше акцепт и соки то получаем соединение и апгрейде мся на него оглядимся на websocket без копирования всего и дальше если полном возвращает ошибку это значит что сейчас наше приложение в пиковые нагрузки по конфигурации и по крайней мере пула где можно сделать такой вот мы просто например делаем slip как в принципе делает и стандартные http server когда он получает какие-то ошибки например ту ныне open sockets open files мы просто ждем когда может быть через миллисекунду состояние изменится и наш пол освободиться и мы сможем принять новое соединение резюме что при большом количестве соединений до или малом количестве машин на которых вы можете запускать сервер и стоит оптимизировать основные вещи про которые рассказал как минимум то есть не запускать грудь in и на каждые ряды на каждый в райт стараться по крайней мере этого не делать использовать пул крутим пул worker of в город и делать крайне удобно с использованием каналов и грудь in это вообще там 30 строк кода а польза очень много ну и как главное решение от проблем иди до суда тоже рутин пул спасает просто не принимаем больше там какого-то количества соединений и того событийная модель вот самого начала до как мы спроектировали запустили она приносит несколько плюсов в первую очередь один из которых это с точки зрения бизнеса и пользователей да это супер интерактивный интерфейс и не только в бинго витал в любых приложениях которые могут общаться с вами по websocket до или по любым другим протоколом предлагать пользователям новые новые функции например сделать ну я незнаю будет это я не будет в почве например сделать такие же уведомления знаете как местом жирах там пользователь отвечает вам на письмо и 3 точечки пишут такие ну что как бы гораздо более интерактивный интерфейс и не только интерфейс но и вообще какое-то поведение вашей пошли системы но и с точки зрения технических плюсов самый большой архитектурный плюс события и в частности попса позволяют вам очень сильно понизить сопряженность компонентов упростить архитектуру и интеграцию между ними то есть у вас есть жена у вас есть сервисе ну немного цифр как как сейчас это работает у нас 3 миллиона живых соединений 30000 уведомлений в секунду только от системы сторож да вот это хранилище ящиков 9 тысяч из них доходит до пользователей 9 тысяч пользователей в секунду узнают о каких то изменениях по и полотна пример тоже 75000 событий на чтение в секунду и одна тысяча апгрейдов на websocket кстати вот в пиках например когда у нас сорвались соединения или там провайдер подобно ли еще по какой то причине мы падали у нас доходило там до 10000 апгрейдов в секунду и вот последние последней версии там зиру копия об греет со всеми этими делами они в принципе уж и легко справляются с такими всплесками ну и вот до финальной анальная строчка что в ходе оптимизации по памяти у нас количество килобайт на соединение сократилась 60 до 10 это в принципе не все можно еще кое-где подтянуть поясом на этом все спасибо может быть вопросы если время есть вас раз добрый день спасибо за доклад вот больше всего про высокие ты все-таки беспокоит вариант это досок и так говорите что как как вы от этого справляетесь или там знаете какие-то методики борьбы с ddos балема именно в websocket и именно в псаки то есть со стороны java скрипта вами нет странноватых со стороны плохих парней которые приходят и начинают вас заливать этими фактами на со стороны плохих парней ну во первых есть какой-то red limit внутренней на количество коннектов или количество пакетов от одного соединения то есть если этот рейд лимит превышается другая просто счетчик то мы можем там игнорировать пакеты либо просто закрыть соединение но какие-то действия предпринять вообще наверное стоит больше говорить не о плохих парнях о том как самим нам не стать такими плохими парнями чтобы не сзади досить себя если говорить про сервер я попытался рассказать да что мы там ограничиваем количество соединений и так далее клиенты до в частности в джесс тоже какой то хотя бы примитивную логику должны иметь что если например мы сейчас от коннектим всегда говорим new websocket и получаем там 502 или еще какую то ошибка то не нужно сразу же пытаться перед от конектится или даже через 10 секунд может быть не надо какие-то такие простые вещи если не получилось пять раз за коннектится давайте пока не будем там через час попробуем что то такое то есть я правильно и вы в потоке ты использована функциональности которые не критичны на который можно если что отключить покажи домику у нас как система сейчас работает да в принципе вы правы то есть у нас есть сторож есть websocket сервер клиент перед устанавливать соединение pvp сокету и дальше синхронизируется со сторожем пастором http вот получает какой-то там ревизию или что то в этом духе и дальше работает tab сокету то есть если соединение рвется с высокий там он переключается на старый там полинг если не рвется то он работает в рамках websocket а то есть в принципе естественно всегда должен быть план б и если высоких вдруг заблокирован например был блокировщики рекламы на mail.ru блокирует выпсуке то то есть они просто не работают поэтому нас должен быть какой-то механизм для сохранения 2 самого спасибо спасибо за доклад очень интересно несколько вопросов каналы вы используете буфере zero ван и данном случае prime канал ну да вы имеете сюда отправку нет каналы channel и тогда там несколько членов один финал это исходящие пакетики в гриву имеете ввиду да да да да да он конечно буфере zero wanna do и вот это вот которая библиотека на свободного доступа на гитхабе лежит и один вопрос такое архитектурный вот вы нарисовали у вас там есть какие-то api какая-то шина и база данных какая-то если вам нужно сделать какие-либо действия но то есть пользователь подписался но в данный момент например он не онлайн если вам нужно послать не знает том какие уж сообщения тогда ему кинуть на мобильное устройство если он по этой почте вы в какой из частей это делаете но сейчас сейчас такого вообще нету то есть если пользователь подключился подписался а потом разорвал соединение мы просто удаляем все подписки отовсюду если он получил новое письмо но грубо говоря то и он не подключен он дал ему не кидайте туда мы ничего не кидаем потому что ну то есть это можно реализовать но сейчас мы поскольку работаем только с вэбом мы пока с мобильными не работаем то фильтрация происходит на первой стадии в шине то есть top очки дают уведомления что вот такой-то ящик изменился в шина смотрит на у меня типа такой подписки нету все просто где в ну да спасибо что попробуем вашу библиотеку спасибо платно из кондишен во-первых какую жену вы используете машину смысле какое это ваша собственная на наш собственный счет наши собственные тем он который содержит себе там какое-то деревца там и второй момент наша библиотека на шифр он и соединения поддерживает шифрованные соединения но это такой вопрос это не задача библиотеки то есть соединить этим у нас anjing стоит перед нами то есть он весь трафик шифруется да да да он просто боксирует то есть всс устанавливается can джинкс и джинкс устанавливает уже в спрос соединения и понял значит пару вопросов используя сильва какой-то стандартного попса потом 100 мб или что то другое ли у вас собственный протокол и второй вопрос как у вас работает вот клиент отключился да он не получает никаких сообщений то есть но он подписан вот эти все чем же они никуда не уходят потом подключается снова как вы реализуете отправка ему текущего состояния да спасибо значит первый первый вопрос про мы используем собственный протокол у нас можно сказать чуть чуть чуть заточен под собственную предметную область у нас во первых бинарный вот эти стены tefal ki ходят в бинарном виде и содержит какие-то там примитивные заголовки и мета информацию то есть он в принципе расширяем но стандартно никакой общем они использовали потому что это только внутри сервисов пока что нет потому что он и так занимает там байты то есть там циферки циферки и порой по рации то есть у нас все ключи это числа на самом деле и единственные байты которые мы шлём это e-mail то есть как как есть чтобы мочить понимаю все остальное там вентс publisher это все это коды просто цифры вот что касается того как вы спросили как происходит когда он но нет мы стоит стоит не отдаем то есть вот sockets сервер нужен именно для того чтобы отправлять уведомления когда клиент приходит например браузер да вот он открыл открыв почту он устанавливает соединение с websocket он с высоким сервером подписывается говорит посылаем не все уведомление и потом сам идет восстанавливает стоит напрямую к другому да да почти теперь получает айди ревизии что вот такой то там такой-то такой-то хэш ящик и сейчас а дальше уже работает потоки то есть торт шлет грубо говоря div вот и если коннектор лед это он просто идет получает стоит но и дальше там зависимости удалось ему перед перепад соединиться либо он дальше начинает постоянно ходить стоит такая схемка давать осуществляете ли вы какой-то контроль за выпадением вот этих сообщений то есть вот я послал сообщение подписку до клиент допустим это сообщение пропала вот как ли клиенту на вас знает что сообщение пропал по дороге в сообщении на подписку или уведомления от тораджи сообщений который уходит от сервер на клиент он же нет клиент не знает он узнает это следующем уведомлением то есть если например он потерял одно уведомление там было ревизия один там присылать на самой два числа старая ревизия новая ревизия вот потом приходит новый пакетик он смотрит а у меня типа старая ревизия 0 сейчас а мне прислали что там старой ревизией 1 а сейчас 2 он понимает что он потерял один пакет и то есть пока он не получит следующим видом ли она в курсе да у нас пока не отсылайте никаких орбитах информирует есть там да есть идеи по там ри transmit какой-нибудь вкрутить что вы там выборочном и похожим проекте мы их орбиты посылаем что 15 секунд и где идет информацию по последним ревизию ну да в принципе была такая же похожая идея просто у нас еще наверно проблема в том что мы не можем систем может быть много и не понятно кто должен вот эти состоянии периодически пушить пользователям то есть разные системы либо точно не хочется хранить состоянии множество систему себя где у дага гарантии стопроцентной не доставки нет сергей в нем просто общего характера почему гол то есть вы перед тем как подходили к решению задачи вы рассматривали другие варианты например питон году мантру на самом деле была статья холивар на и на хабре там мы выбирали как раз между но гсг скала и раз вот выбрали go как раз потому что во первых порог вхождения достаточно мал то есть на нем реально очень удобно писать и очень все всего много все есть вот ну и нам самый большой плюс он позволяет очень сильно вот такие вот оптимизации применять потому что но джесс например он прикольная технология и там нас есть какие то там даже сервисы но на джесс но он не позволяет если что вот взять там закопаться поглубже запилить чтобы свою ну вообще в почте у нас много перлайн новости то есть на тон на другом сложновато было бы это писать вот поэтому выбрали вам здрасте вопрос где не вижу вопрос такое вот допустим клиенты открыто несколько вклада почты ну достаточно часто кейс вы каким-то образом тайти синхронизировать события которое приходит через он сторож например чтобы держать один конверт с браузера или вы забиваете из каждой вкладке камень сейчас мы забиваем работаем с каждой вкладкой на самом деле это мы считали статистику вот именно такого поведения где-то 10 процентов или даже меньше пользователь открыл у которых открытом две вкладки то есть три вкладки открыта совсем тому какой то там трех процентов или так далее то есть в принципе мы у нас задачах есть мы планируем использовать одну вкладку делайте и как мастер вкладка и она дальше там через какие-то вещи типа там local storage да или что то еще будет распространять эти винты то есть экономить количество коннектов но пока что это не является как бы такой нашей первостепенной задачей по оптимизации вообще до такой вопрос есть спасибо ищите маленький вопрос а вот смотрите вы говорили что писали ли вы сами для работать такая ситуация ну наверно у кого тоже возникало не проще ли до перикле бута и залезть исходники к уже готовы ли вы допилить ее под свои нужды или вот проще проще однозначно проще но например что касается гориллы то я даже открывал помню то ли и шьют али pull request и говорил что вот у нас такая эта ситуация там вас классная либо не хочется писать свою давайте мы вынесем там вот эту функциональность сделаем кастомизируемый не ответили что нет говорится наша целевая аудитория не будет использовать и пол и так далее ну не будет и не будет окей действительно я пытался не получилось спасибо дорогие участники к сожалению время лекции подошло к концу дальнейшее обсуждение вы можете произвести в к переговорных комнатах рядом с нашей аудитории спасибо"
}