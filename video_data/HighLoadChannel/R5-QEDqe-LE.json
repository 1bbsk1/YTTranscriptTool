{
  "video_id": "R5-QEDqe-LE",
  "channel": "HighLoadChannel",
  "title": "Языки программирования: прошлое, настоящее и будущее / Дмитрий Завалишин (ГК Digital Zone)",
  "views": 11252,
  "duration": 3111,
  "published": "2023-04-28T06:21:29-07:00",
  "text": "сегодня буду говорить на самом деле не очень про программирование у нас будет та часть которая посвящена вот сложным шестеренком там где-то в глубине внутри но в целом я не очень про это хочу поговорить о смотрите маленькую вводную дам вот еще до начала того как я там слайды начали стать Ну вы наверное знаете да что там скажем нашей стране сейчас уже ездят комбайны которые собирают зерно без участия водителя автоматизированные там когнитив там у Яндекса есть этот автомобили которые доводят такси людей без водителя это уже работающие технологии Да заводы управляются автоматизированными системами А в более традиционных бизнесах тоже э вот участие эти системы Вот это Ключевая вещь которую я пытаюсь сейчас сказать она звучит довольно просто если вчера информационные системы были костылями помощниками элементами которые улучшают работу традиционных бизнесов в принципе если их выключить и убрать то ничего страшного не произойдет то на сегодня изменение Ключевое на сегодня эти системы информационные системы являются ключевыми элементами бизнес-процессов и без них современные бизнес-процессы вообще совсем полностью не имеют смысла влияние того что мы с вами делаем на реальную жизнь перестала быть приятной полезностью перестала быть помощи и стала той частью без которой это вообще невозможно Что изменилось в силу этого изменилась требования бизнес что ли требования к тому что мы делаем и изменился изменилось влияние информационных систем на жизнь на самом деле Вот я тут как-то разговаривал с коллегами которые занимаются тематикой госуслуг Да ну вы наверное знаете что российские госуслуги одни из лучших в мире и это опять же тоже уже перестало быть приятной полезностью которая просто экономит нам час где-то там в состоянии в очереди это превращает страну вообще в страну автоматизированную в которой эти системы являются ключевым элементом и вообще на сегодня такая конкуренция по взрослому большая конкуренция в мире это конкуренция модель управления А значит конкуренция сложных критических больших it-систем которые являются на сегодня прямо носителями глубокого знания это не только Machine Learning и всякие системы на базе АИ это и более традиционные системы так вот Я сегодня постараюсь быть одновременно программистом и бизнесменом И постараюсь посмотреть на языки программирования и изнутри на те шестеренки из которых они состоят и снаружи потому что наши сами жизнь перестала быть нашим внутренним делом это дело всего мира человечество вот и опять же такой маленький дисклеймер это огромная тема на самом деле языки программирования это просто бесконечное пространство я сознательно некоторую часть вещей прямо исключил из рассмотрения например сегодня вообще не буду говорить про функциональные языки программирования там чуть-чуть капелька и зацеплю Пару слов про них скажу Вот и вообще в целом сильно в глубину не полезу Хотя в общем-то могу и если время останется нырну туда я сам пишу с 1985 года я писал на всём Что движется по сэндлерах почти всех машин которые вы знаете и не знаете хотя бы там несколько строк написал и я писал системы которые работают самой маленькой из того что я сам написал работала на машине у которой 32 байта оперативной памяти да А самое большое из того что моя компания написала работает на машине у которой 256 ГБ оперативной памяти И поверьте они там не исключают эти 256 ГБ это прямо вот только в путь серьезной нагруженной системы Так что Ну некоторые такой спектр того что бывает у меня в башке есть я сегодня буду говорить про разработку только очень крупных систем больших масштабных вот то что вот сейчас передо мной рассказывали Да это вот цель такая область определения про которую буду разговаривать стартапы маленькие какие-то проектики для себя это все в данном случае не очень интересно потому что там Нет критичности которая вот как я сейчас говорил меня большому счету волнует чтобы примерно понимать Где мы находимся и какова вообще карта мира Вот это уже устаревшая карта языков программирования которая существует в нашей с вами Вселенной это по-моему по 2007 год там на самом деле вы понимаете внизу еще примерно Ну 1/5 примерно еще родилась и вы отлично понимаете что вот это все родилось не просто так вообще говоря люди когда создавали каждый следующий язык на этой картинке какая-то причина за этим стояла что-то их драйвело я там чуть позже покажу Чуть более интересное это это понятно это картинка для привлечения внимания чтобы понять Вообще где мы находимся как всё плохо на самом деле Хотя если бы честно то здесь язык все представлены в виде там например трёх инкарнаций которые не так уж сильно по-честному отличаются Но где-то это отличие более серьезное скажем там если возьмём какую-нибудь Еву или C Sharp то у них отличия по версиям существенно более важны для с точки зрения программиста с точки зрения парадигмы в которой они вообще живут а попробуем поговорить про то как вообще сравнивать языки программирования к вообще моя модель того почему они бывают хорошие Почему бывают Плохие у кого здесь есть любимый язык программирования вот смотрите Спасибо что вас мало Честное слово Почему Потому что вот посмотрите на это здание вот представим себе человека который его проектировал Да и к нему приходит заказчик говорит Ну ты из чего будешь строить здание он такой говорит Ну вообще дерево люблю Ну странноватая модель Да вообще говоря люди которые занимаются инженерией строят мосты заводы там самолеты у них есть внутри некоторые инженерии Есть такое слово страшное техника экономическое обоснование это когда люди говорят сделать надо вот так и так потому что будет дешевле прочнее И вообще у этого будет какое-то какие-то свойства которые мы целимся вообще есть такая штука Как Total cost of Это стоимость это те деньги которые ему понесём в течение там не знаю условных 5 лет на создание эксплуатации и развития системы которая является вообще говоря базовым критерием для того чтобы выбирать А как из чего мы будем эту систему делать вот эту общую картину Я пытался разбить на некоторое количество вещей одну Кстати забыл я уже немножко Вот это все рассказывал китайцам на Huawei конференции там присутствовал очень умный мужик тормацев ректор иннополиса у меня прям из зала сказал стоимость обучения забыл действительно стоимость обучения забыл это тоже факторов Вполне себе значит стоимость начальной разработки начали писать систему написали первый код он ожил запустились вот это вот оно я потом про это ещё отдельным чуть-чуть поговорю с поддержке и модификаций понятное дело производительность программы тоже все понятно надежность создаваемого кода это очень сложная штука муторная неприятная Хотя опять же вот на этой конференции Про это много говорили есть много докладчиков которые говорили именно про параметры надежности в принципе их тоже вполне себе можно специфицировать но так в целом Мы в общем грубо как-то понимаем Да это там некоторые там количество фейлов на единицу времени что-то вот из этой вот области экосистему я вписал сюда она не является прямой метрикой на самом деле Да но она влияет на всё вышеперечисленное и для меня это очень важный фактор потому что языки давно перестали быть языками на сегодня язык - это не только сам язык и компилятор а огромное количество инструментов которые находятся вокруг него встроенной в него являются неотъемлемой частью процесса который вы получаете начиная программировать на этом языке если у вас нет латчика то языка программирования не существует Но это банальная вещь но дальше вокруг этого есть ещё огромный Спектр инструментов которые катастрофически влияют на стоимость разработки и вообще на Вот все вот эти параметры ещё раз подчеркнул сюда надо писать ещё Learning curve Хотя в целом Я исхожу из моделей что мы с вами живём в мире когда разрабатывается большая сложная система и люди которые делают вообще говоря знают инструмент на котором они собираются работать поэтому наверное в моей картине мира она не возникла а вот это более интересная картинка Почему более интересная потому что на ней в отличие от предыдущей здесь меньше языков Но они такие по реалистичнее немножко что ли набор но здесь еще подписаны вот на этих вот строчках подписаны драйверы которые привели к созданию нового языка при этом отталкивался он от какого-то предыдущего языка Ну вот там не знаю там шикарные лазер не работает контроль появился потому что Microsoft не смог с сыном договориться про то чтобы я его использовать у себя так как он этого хочет странный драйвер Да ну и такие существуют большинство драйверов изменений которые мы здесь видим они находятся условно в нашей с вами области определения это программерские драйверы это парадигмы которые встроенный язык это какие-то прямые возможности востребованные программистами которые позволяют нам на этом языке делать быстрее проще сильнее использовать его более качественно То есть все же на самом деле в основном вот эти вещи являются внутренними драйверами которые находятся внутри нашей с вами вот этой программерской экосистемы внешних драйверов здесь не так уж много хотя на самом деле в целом тут надо чуть-чуть в сторону дарвинизма вернуться понятно что выживают сильнейшие Да и в целом если смотреть на языки программирования чуть-чуть вот так поднявшись над ними взлетев понятно что выживают те из них которые экономически сильны потому что на них делают успешные проекты эти успешные проекты выживают программисты которые там жили нарабатывают компетенцию переходят следующие проекты Поэтому в целом вокруг этого существует Конечно вот Верхняя картина верхний уровень именно экономика того что делается на этих языках программирования вот Хотя если смотреть на совокупность факторов то конечно же есть куча вещей которые являются такими в неэкономическими у меня как-то был спор сильвестеголовищем который разработчики кендасовского поиска Да вот я ему говорил что Слушай ну по ХП это же ужасная Кошмарная Это же жуть просто а не язык программирования но хуже же придумать Нет ну пела наверное хуже да можно можно придумать хуже Но не сильно как бы да превзойти уже тяжело на что мне силович сказал ну подожди ну на нём же написан Facebook и это же как бы вроде бы критерий да да Но нет почему Потому что когда мы с вами говорим про экономику разработки программного обеспечения существует такая тонкая штука есть экономика есть другая экономика они очень разные вот есть экономика компании которая занимается заказной разработкой моя компания это очень жесткая экономика у нас все действительно прямо четко вписано Вот деньги которые мы получаем от заказчика Вот фичи который мы выкатываем раз в месяц вот язык программирования который позволяет или не позволяет это сделать который приводит к большому количеству багов маленькому количеству багов это очень жёстко там вот в нашей картине очень жёстко поэтому например мы отказались вообще от разработки на языке заказные разработка России это дикий Кошмар с точки зрения экономики нам это очень хорошо видно А вот например Яндекс - это нифига не видно почему Потому что в экономике Яндекса которые на самом деле это экономика которая пока с баннера или там какого-то другого рекламного продукта получения и денег за них и вот этот вот поток денег который рекламный Яндекс - это рекламная компания Да не программистская рекламная вот программирование в этой всей картине это он малое и с точки зрения экономики всего Яндекса не так Сильно критично Сколько стоит разработка с одной стороны а с другой стороны очень высокая нагрузка на сервера и специфичность вещей которые делают позволяют например программировать на C потому что в этом случае у нас там с вами есть 10 тысяч машин и если мы на один процент скинем затраты на производительность кода то есть машина можно выкинуть это вполне живые понятные деньги на больших масштабах начинают играть другие вещи я про это чуть дальше скажу вот эти вот наши с вами факторы которые я сейчас есть написал они по-разному работают в разных моделях бизнеса в разных моделях разработки в разные картине мира в которой мы с вами живем и по-разному драйвят финальные решения теперь чуть-чуть к тому как эти факторы влияют на реальный выбор одна из типовых проблем которые я лично вижу когда я рассматриваю то что происходит на рынке и зачастую эмоциональные телодвижения программистов выбирающих инструмент выглядит так вот на этом языке писать проще то есть разработчик существенной степени пытается снизить свои личные транзакционные издержки на процесс написания кода беда заключается в том что во-первых он оценивает еще чуть-чуть не то что надо бы во-вторых потому что даже если попробует оценить более правильно ему это будет тяжело Дело в том что мы сами очень сильно переоцениваем затраты на начальную разработку софта и очень сильно недооцениваем затраты на его развитие и поддержку на самом деле соотношение между ними совершенно катастрофическое если попытаться заглянуть в эту картину Чуть более детально то окажется что там все ужасно Дело в том что написание программы это на самом деле наверное единицы процентов от всего жизненного цикла того что с ней происходит потому что описание программы на самом деле это совсем-совсем короткий период времени когда коды вообще нет прям совсем нет мы только вот сейчас вот сели и как правило придумали какую-то очень примитивную базовую реализацию системы которая реализует то что мы хотим И мы сразу вообще говоря предполагаем что наверное потом будет модификации поэтому пишем ее схематически упрощенным это катастрофически маленький участок процессы разработки А вот модификации программы занимают просто невменяемы огромную часть жизненного циклах когда разговаривали вспомнил что совсем недавно ну там не знаю не там 10 лет назад недавно моя жена в реальном Проекте в реальной большой компании в России модифицировала код на Называется он же вообще умер кажется до того как мы все сами до того как я еще Родился он еще должен был умереть он дефекты присутствует используется мало того там наверное треть вот сидящих в зале завязаны на транзакции которые до сих пор работают на языке Кабул вы не знаете почему я вам не скажу но это факт жизненный цикл софта огромен модификации Это основная часть работы которая вообще с программой происходит все остальное практически не буду говорить неправильно стоимость разработки не существенно вообще стоимость модификации является основным и главным критерием Ну ладно это банальный слайд просто еще раз про модификации значит попытаемся с вами посчитать А сколько на самом деле стоит разработка программы этот самый Тотал умершип из чего он складывается как он устроен понятно что в него входит стоимость начального написания понятно что в него входит стоимость поддержки развития программы умноженное на время жизни программы причем время жизни можно спокойно брать за 5 лет вообще говоря можно брать за 10 есть вещи которые живут дольше в эту самую стоимость входит количество железа которое нам с вами потребуется для эксплуатации софта и здесь начинает играть фактор производительности Потому что если система раскатывается на большую нагрузку фактор производительности очень очень значим если нагрузка маленькая то там не знаю ваша система работает на одной машине но плохо на двух то вообще говоря существенной степени на фактор производительности можно наплевать это кстати говоря Вполне себе видно если посмотреть на историю развития языков программирования то какой-нибудь там опять же тоже самое который вообще говоря позволяет писать программы очень высокопроизводительные со страшной скоростью выдавливается другими языками которые на первый взгляд катастрофически менее эффективные по производительности но по другим факторам они начинают его двигать хотя на самом деле если посмотреть то серьезные вещи типа там той же Java или того же си-шарпа по производительности очень серьезно развиваются на самом деле все давно догнали и в этом месте являются довольно универсальными инструментами Вот но опять же языки типа питона и даже того же самого PHP существует до сих пор живут и понятно что драйвер стоимости разработки и драйвера стоимости эксплуатации в этом месте как-то балансируется Хотя мне очень понравилось Я вот до этого не знал на водокладчика в конце заметили вы нет Был Была надпись компилятор из ПХП все Плюс я прям заужал вот это вот это тоже на самом деле некоторые данность современного мира когда сам по себе стартовый язык может оказаться не настолько существенной частью потому что существует какой-то путь прокатить его в какую-то более эффективную модель мира а стоимость железа я про это по большому счету уже сказал Вот давайте дальше стоимость разработки про это Я тоже говорил еще раз скажу два слова здесь про экосистему стоимость разработки а главная стоимость поддержки очень сильно упирается в экосистему потому что здесь у нас возникает игра которая связана не с написанием кода А с верификацией качества работы выявлением проблем выявлением возможностей по развитию и увязкой этого самого хода с инфраструктурой на сегодня как бы на сегодня не существует программа которую мы написали и запустили И вот она такая одна счастливая работает без окружения если посмотреть опять же презентации которые здесь звучат сегодня то видно что современное программирование программирование компонентные связанные в очень сложную многогранную среду в которой всё это живет причём в ней существует не только сам код и его взаимодействие существует в некоторые внешние по отношению к нему инструменты как инструменты времени разработки так инструменты времени эксплуатации которые требуют привязки с этим ходом какой-то семантикой семантическое взаимодействия между ходом и вокруг него инструменты разработки уровня системы для проведения статического анализа хода в такой традиционной разработке они может быть не так уж критичны а если мы скажем сами зайдем в такую область как написание софта для гражданской авиации А там жесточайшая вообще говоря требование к качеству к надежности кода то там верификация сорта с помощью статических инструментов анализа это прям необходимость поэтому существенным фактором выбора инструмента в таких областях является как раз инфраструктура а стоимость развития чтоб плохо со стоимости развития это тоже на самом деле зачастую не осознается дело в том что я не знаю Был ли у вас такой момент в жизни У меня это прям было вообще у меня был случай когда я дорабатывая систему сел и написал некоторую новую подсистему и через три дня написания ее понял что месяц назад я ее уже писал она где-то в ходе лежит я просто вообще забыл что она реализована существует Но только достать из правильного места и засунуть ее подсоединить правильные места это вообще запредельный случай но ситуация когда вы месяц что-то разрабатывали потом переключились на другую часть кода потом вернулись доработать этот момент и поняли что вы вообще не в дуплеете что вы там писали почему это так сделано Кто этот человек Зачем это делать Так спроектировал это совершенно обычные вещи и это даже вы сам когда другой человек который читает ваш код то масштабы его не понимания происходящего с фантастичной у нас в моей компании Был случай когда нас выперли из некоторого проекта туда притащили дружескую компанию которая взялась зарабатывать наш код она значит там год поработала потом все поняли их выгнали нас вернули обратно и значит мои разработчики потом мы сидели обсуждали А что там изменилось Да И вот по тому что эти люди там пытались писать было видно был виден масштаб не понимания инфраструктуры которая сделана и масштаб э трудности въезжания новой команды большой продукт в котором Ну налажено некоторые инфраструктура Да а доработка кода это на самом деле детективное исследование расследование происходящего в этом коде это огромное трудоёмкая процедура и от языка она очень сильно зависит вот Существует очень такая выраженная тенденция которая сегодня звучит так сторы языки программирования очень сложные на них трудно писать нам очень много слов мы бедные несчастные у нас лапки поэтому тип переменной перед именем переменной Мы пить не хотим нам надоело сделайте нам пожалуйста язык программирования который будет выводить тип автоматически Это же не сложно да это правда не сложно компилятор конечно же отлично знает каков тип этой переменной и конечно же может за вас его вывести вот сейчас немножко нырнём чуть-чуть туда вот прямо под капот на капельку значит что мы с вами сделали одну простую вещь с вами было написано там не знаю Поинт п Point это класс поэта переменная равняется там не знаю что-то там что-то там точка Get cordinates мы откуда-то получили координаты чего-то положили в переменную банальное тупая строка с которой все понятно Если вы открываете этот код и вы его не понимаете то вы там с контролом кликаете на этот самый класс Point заглядываете в него и примерно понимаете что в нём может быть что в нем быть не может если вы писал нормальный человек с нормальной инкасуляцией вы понимаете что переехать в эту переменные могут только вот такие вещи так-то верифицированные и делать с ними можно вот только вот этот вот теперь мы попробуем выкинуть слово Поинт Казалось бы почти ничего не изменилось только теперь когда вы читаете P равняется что-то там гет-координации да Ну хорошо Да мы Все мы сами реальные люди понимаем что где-то координация - это наверное всё-таки что-то там такое связанное координатами но Бывает Хуже Понятно бывает что по именитые методы не так уж Всё ясно дальше Вы должны Что сделать Вы должны нырнуть откуда оно пришло и посмотреть о чем там делает А он это тоже откуда-то берет вы пошли дальше А дальше это с чего-то собирается Хорошо если это Point А если это Например Ну не знаю элемент АСТ дерево компилятора который является там сущностью которая транслируется в операцию которая исполняется на процессоре то я правда это делал на языке в котором нету строго типизации которые программист писал вот так вот когда вообще говоря сущности собираются где-то там куда-то прилетают для того чтобы понять что происходит вот в этом объекте в этом в этой функции нужно проводить расследование которое занимает там 2-3 часа и даже нет Ужасно даже ужасно не то что вместо того чтобы просто прочесть одну строку и сразу понять третий 2 часа ужасно то что на самом деле вы не в состоянии вычислить все пути поступления этой информации в эту точку И когда вы начнете модификацию программы Вы обязательно потеряете о какой-то из путей потеряете какой-то краевой случай на котором эта штука принимает данные про которые вы почему-то не подумали про модификации программа ваша взрывается я выскажу некоторые злой тезис который звучит примерно так компилятор может найти ошибку в программе только при одном условии при условии что вашей программе есть достаточно избыточности то есть какая-то вещь повторена вами несколько раз и эти несколько раз можно сравнить вы недочеты в этом сравнении компилятор может указать вам на ошибку если программа пишется таким образом что избыточности в ней вообще нету то есть вы компилятор позволил вам выкинуть всю возможную избыточность и не писать там не знаю типы или какие-то другие спецификации там где этого можно не делать то вы потеряли в надежности в скорости разработки программы и как итог стоимости развития этой самой вашей системы это вот тот тренд который на сегодня в языках программирования очень четко выражен и в которой я лично не верю Я считаю его мягко говоря вредным производительность кода Здесь тоже существует некоторые более-менее реальная картина и некоторые поверья поверье связано с вот с чем значит Ну понятно что у нас с вами существует условно три класса языков это старые добрые классические статические компилируемые языки есть Кстати новые и добрые языки например сознательно пошёл именно в эту модель фактически компиляции Хотя это очень новый язык Ну понятно его на самом деле делали люди которые делали C поэтому в общем вот некоторые В смысле э Хмм Для них этот язык это возможность показать миру что вот старая гвардия всё-таки ещё может и они довольно как мне кажется довольно сознательно некоторые вещи так выраженные игнорируют вот Ну так или иначе значит статические компилированном языке написали исходник прогнали калькулятор получили бинарный код который исполняется прямо на процессы динамически компилируемая делятся на два класса потому что и Ява прямо очень выражено в этой стороне по очень простой причине там параллельно фантастически сильная команда компиляторщиков которые делают катастрофически крутой продукт Ну и некоторые там языки которые условно все остальные языки современные которые развиваются тоже конечно же в парадигме либо интерпретации либо Jet компиляции которые идут в эту же модель но по качеству компиляции очень сильно отстает Ну и есть еще некоторые там несчастные слои язычков которые сделаны на коленке типа Простите Господи лоа про который даже никто не пытается думать в терминах их быстродействие они где-то там на полу валяются никто их не ест но тем не менее они есть и где-то в какой-то ситуации они тоже решают какие-то проблемы Вот Хотя опять же вернёмся к вопросу компиляции По ХП в ситу всё возможно и и Нижняя строчка можно вытащить верхнюю Лигу Значит вот в этой картине верхние две строки находятся в одной Лиге на сегодня понятное дело с плюсом и со всем что там вокруг него находится это языки одного класса производительности Причем на самом деле есть ситуация в которых вот вторые выигрывают во-первых что тоже на самом деле некоторым поверьям Ну не отвечает Вера гласит что статический компилятор - это олдова правильно олдскульно очень эффективно А вот все модные значит вот эти вот самые двухфакторные системы они так не работают Хотя честно вот знаете я как-то даже разговаривал с людьми которые в это верят и спрашивал Скажите а вы правда верите что если взять все компилятор распилить его на две части и вторую запустить отдельно только качество кода ухудшится мне непонятно почему я должна произойти мало того можно показать почему оно улучшится тем не менее кликер действительности работает значит тем не менее Существует еще одна важная вещь которая все-таки оставляет си вот самый-самой Высшей Лиге Я честно скажу я очень не люблю этот факт я считаю что программировать на языках статические компилируемых уже наноси вообще грешного плюс чуть-чуть менее грешновато но тоже это неправильный язык для прикладной разработки но тем не менее факт остается фактом есть ситуации в которых именно эти языки позволяют выжить если совсем до конца Вот то что на всем остальном трудновато здесь Всегда возможно что происходит если мы говорим про любые языки управляемые памятью Джава США все современные языки кроме си и го то все переменные это просто 3264 бита в памяти больше ничего переменные у всех остальных современных языков это что-то плюс хедер этот самый плюс хеггер не так уж дорого стоит на самом деле но если программист немножко не понимает что он делает то Это может очень больно прилететь потому что количество этих кодеров при неправильной поставке программы может увеличить объем данных там в два в три в пять раз и это к чему приводит тому что у нас с вами рабочее множество перестаёт помещаться в конечно процессоры и производительность сразу так падает там на три на два-три порядка вниз вот на самом деле это всё лечится на самом деле если понимает Как устроена структуру данных то это и наяве на шарпе тоже также совершенно лечится Ну условно говоря нужно просто перейти от э структуры данных сложных юридических к- к таким тупым массивам И это всё сильно лечит на самом деле и на сито уже можно сделать очень большую ошибку Если вы очень кстати интересная вещь знаете что по процессору Эльбрус все знают что Эльбрус Да вот по нему вышла офигенная совершенно книжка которая посвящена оптимизации по Эльбрус и Интересно читать не только Эльбрус потому что это вообще очень хорошая книжка по оптимизации сишного кода так вот там прям выкатывается очень простая картинка Если у вас есть массив структуры вы собираетесь бежать по одному полю этой структуры то вам очень плохо потому что это поле в памяти расположено С шагом размера структуры в кэш всё это нифига не влезает и это все работает ужасно медленно Превратите массив структур в структуру массивов и всё сразу начнёт работать быстро я это к чему потому что на самом деле языки не так же виноваты если мы сами понимаем что происходит в памяти процессоре то мы можем выкатывать высокую производительность если не понимаем никакой язык нас в этом смысле не спасёт значит Горбач коллектор опять же классические языки с ручным управлением памяти разработчики которых не привыкли говорят ужасно он тратит много времени вообще программу устанавливает Да куда это годится догодится на самом деле во-первых на самом деле если мы говорим с Вами про хайлоуитные системы то вообще-то на самом деле пуфик у нас кнопка программы потому что у нас с вами работают огромное количество параллельных сервисов но один из них там с какой-то вероятностью притормаживает напором или секунд не очень-то это страшно Но и это на самом деле не происходит современно вообще то что происходит в области коллекторов Прогресс который там происходит он совершенно фантастический чтобы вы понимали существует гербович коллектор который нормально собирает мусор на оперативной памяти размером в 1 ТБ оперативной один ТБ и всё это живёт то есть там э ситуация на сегодня настолько хороша что в принципе там Если действительно надо было предмет для разговора сегодня Ну наверное совсем нету Хотя опять же хардкорные разработчики что-то там про горы бочколлекта знают Но если скажем Там пять лет назад разработчикам на яве рекомендовалась немножко думать про то как происходит Горбач Коллекшн И что там внутри под капота то сегодня прыгаемся вообще Перестаньте Перестаньте париться Перестаньте думать и в листики которые находятся под капотом лучше чем вы сами и правильно все сделают вообще даже не заботьтесь с моей точки зрения этот блокер давно уже не существенный Значит теперь я про это уже говорил считалось что статическая компиляция даёт очень качественный код а динамическая жидкомпиляция это такой пасанок который Ну как-то пытается догонять по Пашку Ну в общем Бедненький несчастненькие где-то он там минус Минус Там 50%. вообще не так давно уже на самом деле тесты на вместе показывают соотношение скорости в плюс минус 10 процентов обращаю внимание плюс-минус есть ситуация в которых джиперы сильно эффективнее чем статические компиляция они связаны там много вещей если вам это интересно то это отдельный предмет для изучения но я подсвечению моментов момент первый статической компиляция в том же самом себе выполняется по файлово поэтому глубина оптимизации которая может себе позволить компилятор это глубина оптимизации одного метода или если Вам сильно повезло то метод плюс какой-то заинлайнен и руками метод который тоже почему-то видит что происходит там в том же самом же время программа вторая фаза компиляции исполняется когда программа уже работает код весь загружен в память весь полностью виден второй фазе компилятора и компилятор может например делать инлайны на глубину до восьми вызов методов внутрь поэтому кстати говоря там например наяве написать какой-то бешеное количество гетеров в классах это страшно они все сворачиваются янлайница полностью автоматически даже если они там пятикратные во внутрь эти Гетеры которые там гетерог гетерог Гетеры от Гетеры Вот Но что самое важное что этот инлайнинг приводит к тому что компилятор начинает видеть программу на всю глубину и он начинает например делать такие вещи как сворачивание константных выражений там где традиционные языки это вообще не могут потом простой пример цикл в котором вызывается метод и в этот метод передаёт константу метод сам по себе мгновенно превращается тоже в константы Все вычисления в нём которые были параметризованы и до этого были от переменной внезапно стали от константы компилятор видя всё это на полную глубину сворачивает полностью вычисляет этот метод и полностью выкидывает его из процесса э кода генерации подставляя вместо него константу после чего вполне возможно что и цикл может быть свернут полностью ремонтном выражении то есть полностью аннулирован или по крайней мере очень сильно упрощен с точки зрения кода генерации уже то что мы из цикла выкинули вызов метода это прям очень ощутимое влияние на быстродействие эти вещи невозможным статики возможны в динамике еще одна смешная вещь про которую просто разговаривал с ребятами которые разрабатывает компилятор вот этот самый джитовский второй фазы и разговор был такой я говорю Слушайте мужики но это этой теме уже 100 лет что там делать потому что уже сделано вот смотри ты давно разговор был лет 10 назад Вот смотри Значит мы загрузили код запустили его все же знают да что в процессе есть методы оценки куда условный переход идёт чаще направо или налево да в компиляторе можно на джант условно И повесить прямо маркер который проверяет считает по нему статистику он сейчас чаще срабатывает или чаще не срабатывает Значит все мы можем подсказать компилятору сказать Вот этот If Скорее всего будет не срабатывать и компилятор статический развернет его таким образом чтобы не срабатывание было проходом хода насквозь а срабатывание дорогое это был условный Джамп но дело в том что иногда мы можем это предсказать стабильно и окончательно а иногда предмет этого срабатывания зависит от фактических данных которые поступают в систему и вот на этих данных оно чаще Идёт направо На этих данных идёт чаще налево значит джитолые механизмы могут врантаймно смотреть на очень важные кусочки кода опять же врантайме система реально знает какая часть кода исполняется многократно и Может её очень сильно на ходу инструментировать и анализировать Может выявлять на ходу ситуации в которой Jump отрабатывают плохо статистика обратная и перекомпилировать код на ходу под реальные данные повышая быстродействие конкретных участков хода и это может происходить многократно то есть система гоните у нее пошли одни данные код скомпилировался вот так полетели другие данные детектировалась другая картина мира выявились некачественные куски кода и они перекомпилировались под существующие новые данные Ну и там есть еще целая куча совершенно банальных вещей вот такие как опять же там когда мы пишем на сито Мы в общем должны явно говорить У нас виртуальный метод или статический виртуальные Но поскольку компилятор де-факто знает есть ли у этого метода вообще альтернативы или он реально во всём дереве классов единственный он может его заменить на статический runtime просто проанализировав картину мира таких вещей довольно много значит про надежность Я уже пару слов про это говорил и сильно в это дело залезать не буду но вот одну вещь скажу Значит на самом деле удивительно вот что существует такая штука тоже самое как аннотация что это такое Это когда мы про какой-то кусок кода что-то говорим это что-то на самом деле в рантеме вообще не компилируется кода не вызывает и на программу влиянием не оказывает Но это что-то может являться каким-то входным входной информации для внешней системы простой пример мы сами сделали какую-то систему через ОРМ Хотим её закатить базу данных автоматом сгенерить бы не база данных автоматом сгореть код который там пишет и читает Да вот такими аннотациями можно маркировать подсказки вторичным системам объясняя что в ходе на самом деле происходит Ну там не знаю строить ли индекс поэтому объекту или не строить или вообще например в этом в базе не записывали Нет честно сказать очень удивительно что эти вещи не перекочевали из Европы все остальные языки программирования потому что с точки зрения как раз интеграции кода с остальным миром это фантастические э-э эффективная вещь которая прямо на порядок может изменить качество работы разработчика хотя на самом деле конечно же во многих языках это присутствует как некоторые там комментарии с э трактуемым значением Да которые компилятор просто игнорирует потому что они комментарии а содержимое их внешними системами трактуется используется как аннотации в некотором смысле но будучи комментариями они не проявляются синтаксический и у нас нет возможности убедиться в правильности этого самого отдельно скорее для себя чем для вас я сделал такой списочек вещей которые катастрофически влияют на надежность часть из них это ну условно мой личный опыт или там Опыт моей компании часть это взгляд на жизнь из тех частей мира где очень критично качество программы тоже самое разработка софта для гражданской авиации Мы немножко участвовали в проектах там вообще Вы не представляете какой уровень требований к разработке кода причем для военной авиацентр таких требований нет Попроще а вот Гражданская является существует требования к тому что делается и например там пишут Да но макросы использовать нельзя вообще дифальный можно вот Единственное что можно это дефайны конкретных констант Всё значит строго типизация я пару слов про это сказал Почему типизация обязаны быть строгой и на а-а современные вот эти все ловушки в виде можно опустить вестись не надо это боком выйдет запрет на нервные преобразование это тоже вот я когда появился c++ Я вообще плакал как ребенок я это было фантастически хорошо потому что все хищники понимали что язык-то общем тяжеловат старый неудобный я сама вещей давно уже понятно что объектное программирование это правильно Да И вот приходит все плюс и в нём всё это есть а ещё можно плюсик переопределить и для типа строка написать строка плюс 40 и как тебе хорошо боже мой Да а потом приходит такая Ява говорит так нафиг нельзя больше переопределять эти самые плюсики и минусы какие-то такой думаешь что дураки что ли Ну было же можно Почему понятно почему на самом деле огромное количество неявной информации в ходе это жесточайшая неприятность Потому что когда вы читаете но вы не понимаете что происходит это это настолько тяжело с точки зрения поддержки что масса вещей которые из плюса были выкинуты и более там новых языках явно не делаются это понятно почему значит запрет на структурные объекты без явно описанного типа это вот тоже современная мода на то чтобы взять какой-нибудь тапу мне очень накидать там Да куда-нибудь его переслать и там тут же мы знаем что мы кинули тут же мы знаем что мы приняли да А если пришло злой человек то пусть сам страдает и разбирается и понимает что мы здесь накидали почему это принимаем нельзя Можно будет больно экосистема Вот про это вообще хочется сделать отдельную презентацию я про это тоже там уже много раз говорил настолько много всего опять же там приведу простой код там э-э в некоторых современных вещах типа там тоже самого джабского рантайма Вы можете отладчиком подключиться дистанционно к работающему на сервере э-э системе Да и не просто посмотреть и там сделать отладку по шагам пройтись А можете посмотреть например на структуру памяти частоту горбачков эклекшена и снять некоторые внутренние метрики процесса которые там есть которые собираются энджинами вот этого самого ранта его вот ценность этого на самом деле трудно преувеличить потому что все мы знаем что система На тестах системы в бою это вообще две разные вещи как бы хорошо тесты не сделали все равно приходится разбираться что происходит в боевой системе пара слов про прошлое у меня совсем мало времени прошло говорить не буду но вы все и так без меня знаете будущее что будет языками программирования smp это современные машины в которых несколько равноправных ядер процессора это мёртвая система их больше не будет потому что понятно что скорость процессора сама не растёт растёт количество ядер количество ядер больше там условно тысячи растить нельзя поэтому мы с вами обязательно придём вот к этой модели Она уже была давно она снова вернётся это не униформенная система доступа к памяти когда несколько разных ядер свою память видят близко чужую и далеко они тоже видят далеко это означает что языки програм мы не должны уметь генерировать представление о том Какой код какой памятью наиболее тесно связан и диплоить код таким образом чтобы это связанность была осознанно системой дипломмента и правильно раскидана Нам реальную систему на которой все это работает значит понятно что статическую компиляцию я Катастрофически не верю она умрет И в общем все что существует на свете будет жить компилировано Я думаю что изгорович Collection тоже относится понятно что будущее это система слабо связаны То есть это условная микросервиса как бы как бы это не было реализовано поэтому на самом деле языках программирования будет расти та часть которая развернута в сторону генерации интерфейсов длинного взаимодействия отчасти попытки делать это в языках существовали Там многие языки встраивали в себя какие-то методики там ремонт метод invication но в целом пока не пошло Наверное потому что в основном они были завязаны на один и тот же язык сам с собой опять же Мы все знаем что современная система сильно гетерогенные написаны на разных языках программирования поэтому какая-то тема с тем чтобы породить дешевые и эффективные инструменты внешнего взаимодействия из языка которые тем не менее на язык не завязаны это это такая правильная вещь которая будет вырастать Хотя это очень трудно сделать я пробовал понятно что всего этого есть исключения понятно что я сейчас говорил про очень тяжелые и сложные системы понятно что есть терпение вещи которые меня когда в прошлый раз рассказывали сразу спросили вас стартап Ну как бы Вася знает там не знаю Ну еще мы теперь Напишите пожалуйста Просто когда старта превращается из стартапа в реальной большой серьёзный бизнес в котором вы начинаете отвечать за условные сны того что вы делаете то весь этот вот зоопарк который вы написали до этого момента надо аккуратненько выкинуть и написать его серьёзным образом по-новому таким образом чтобы вы понимали что инструмент на которых вы разрабатываете действительно качественные действительно позволяют вам система поддерживать и развивать к чему есть лапша очень давно у нас Лапшина великий человек который написал на ирланде систему видео стриминга российскую реально очень крутую большую в которой работает на огромное количество клиентов когда с ним разговаривали самом начале проекта я говорил ну не пиши на ирланде это ужасно ты не сможешь найти программистов он написал на ирланде компания успешно есть исключения они зачастую опираются на людей оркестров которые сами в одиночку могут сделать много Ну там не знаю если я в одиночку Сяду я могу черта лысого просто вот в одиночку написать я очень эффективно и программист Но когда я отойду на шаг вправо то кто это будет потом поддерживать Непонятно вообще поэтому все такие вещи они завязаны на одного конкретного человека Я понимаю так что времени закончилось мне осталось целая одна минута Ага тогда у меня есть специальный доклад слайд для тех кто опоздал на доклад это конечно вранье Но как это сказка ложа в ней намёк наверное в общем по большому Фантом хотел сказать если вы не знаете какой Фантом вам не интересно но если вы знаете то мне казалось важным про него сказать здесь почему Потому что вся идея операционной системы Фантом она проистекает вот из того что я сейчас рассказывал мысль стоит за этим Примерно вот какая Значит сам по себе язык программирования на самом деле уже поздно менять по большому счёту и критичность изменений э велика но есть ещё вещи которые находятся за языком программирования одна из них это среда исполнения так вот внезапно вот идея операционной системы Фантом заключается вот в чём если программа поместить в условия в которых Она никогда не заканчивается не по своей воле то есть не существует для неё там система перегрузили программу убили потому что никак иначе нельзя да то возникает некоторые новая картина мира в которой некоторые вещи становятся внезапно очень простыми разработка внезапно ещё более дешёвые и эффективной То есть программер может вообще забыть задачу записи стыд а программы на диск совсем Почему Потому что в такой среде любая переменная семантически является файлом вы положили в нее данные они там лежат всегда поскольку среда гарантирует вам что остановка операционной системы программа просто ставит на паузу и предоставите систему программа просто продолжает ехать дальше отсутствие потребности в реализации высвобождает огромное количество ресурсов и на самом деле очень сильно меняет сознание Я когда несколько строчек вообще несколько простых программ под такую среду написал Выяснилось что некоторые вещи которые в традиционной жизни э занимают миллионы строк кода могут вместиться в три простой пример выглядит Так у нас с вами есть датчик температуры который присылает отчёты мы их показываем рисуем график в традиционной системе Чтобы это сделать поскольку система возможно остановиться перезапуститься то данные нужно сохранить в базу данных Значит вам нужен брокер сообщений вам нужна с OBD вам нужна интеграция между ними нужно получать отсчета класть базу данных вытаскивайте из базы данных рисовать график Вот примерно картинка системы теперь что происходит если мы пишем в инфраструктуре с персистентной памятью вы пишете один цикл на три строки в котором одна строка получить данные а вторая строка поставить точку на экране и всё а потому что система персистентная точка на экране будет стоять всегда её просто не перерисовывать вот э-э в этом смысле некоторые смена парадигмы которая находится там за языком программирования может приносить катастрофические изменения Я считаю что вот существенные изменения которые до этого случились это принесение той самой менеджмент памяти и исключение адресная арифметики из резьбового программирования следующий серьёзные изменения которые появилось это рыбачка alection который очень сильно развязал руки с точки зрения структуры данных работы с ними и следующие изменения которые последует дальше это персистентная оперативная память по-моему так Дмитрий Спасибо большое друзья традиционно спикеры выходят из зала оказываются в дискуссионной зоне я вам хочу Дать маленький совет на весь день вперед Если Вы опоздали чуть-чуть на доклад не стесняйтесь проходить вперед всегда есть свободные места даже когда зал битком памятные призы спикеру традиционно"
}