{
  "video_id": "Cs0CJPEQawA",
  "channel": "HighLoadChannel",
  "title": "Бэкенд на NodeJS. Опыт Bolt / Юрий Гавшин (Bolt)",
  "views": 8411,
  "duration": 3024,
  "published": "2019-12-05T13:01:43-08:00",
  "text": "меня зовут юрий гаршин я работаю в компании болт я вам расскажу о но джесс расскажу как как у нас построен backend расскажу как мы его разрабатываем и как мы его тестируем кто из вас слышал о компании болт до этой конференции два человека это это уже неплохо я расскажу кто мы такие мы являемся платформой для предоставления транспортных услуг в первую хотим предоставлять удобные услуги предоставляем удобные услуги это мы начинали с такси в 2013 году в 2016 году мы начали оказывать услуги частного извоза это машина это также мотоциклы например в африке с 18-го года в прошлом году мы начали оказывать услуги аренды электросамокат of в этом году мы планируем открыть сервис доставки еды имя у нас не так давно поменялось кто слышал о такси фай до этой конференции уже уже лучше мы на раньше назывались taxify до февраля 2019 года но из-за того что расширилась портфолио наших сервисов нам старое название больше не подходила и мы решили поменять поменять название на болт с английского с приводится английского означает не только собственно болт это так же означает как глагол это быстрое перемещение а как существительное это это молния мы верим в электрический транспорт мы быстро и удобно перевозим людей с точки а в точку б чтобы вы понимали примерный размер компании и где мы работаем мы работаем более чем в 30 странах в основном это европа и африка но также мы присутствуем например мексике и австралии у нас более 25 миллионов пользователей у нас почти 1000 сотрудников более 100 инженеров у нас 4 инженеринг хаба это в основном основной инженеры копеечку это таллин но также у нас есть инженеры в румынии у нас есть в польше а также в швеции здесь компании очень часто сравниваются по капитализации и чтобы примерно понимали и могли сравнить нашу компанию с российскими компаниями то год назад наша компания была оценена в миллиард долларов это сравнимо с wildberries и авито по по размеру несколько лет назад мы были совсем маленькими но сейчас мы находимся в топе самых быстроразвивающихся стартапов и за те два с половиной года что я работаю в компании у нас все показатели повысились более чем в 10 раз и bag and как как любой продукт он не работает в вакууме он работает определенной целью чтобы выполнять какие-то бизнес бизнес задачи и у бизнеса есть определенные требования главное требование со стороны нашего бизнеса это быстрый выход на рынок например аренды электросамокат of мы вывели на рынок за два месяца от решения да реально ездящих самокатов парижу обязательно отказоустойчивости упругость отказывай устойчивость это то что когда мы сделали сервис который начал работать он должен продолжать работать под упругостью мы понимаем то что если вдруг этот сервис падает по каким-то например инфраструктурным проблемам все равно окружающей сервиса должны продолжать работать если этот сервер поднимается то все что было не не доделано должно быть доделано и все должны дальше продолжать работать как ни в чем не бывало разум яйца высокие нагрузки нужно масштабируемость масштабируемость по количеству заказов по количеству пользователей это водители это обычные клиенты которые собственно пользуются нашим сервисом также очень важно масштабируемость по сложности по количеству сервисов потому что продукт развивается расширяется добавляется новые сервисы но все равно старые сервиса должны продолжать работать и также эти старые сервисы должны работать сообща с новыми сервисами поэтому масштабируемость количеством сервисов и инженеров тоже очень-очень важным поговорим о стыке технологий базовые технологии это мы работаем в весе тэц-2 это рад shift для аналитических данных которые объединяют несколько данные из нескольких баз основу нашего технологического стыка является но джесс но также у нас используется например php в бэг-энде у нас используется engine как балансира у нас как база используется maersk oil и ее аналоги мария dv перка на мы используем а в снс и стс как как очередь которая понадобилось с повышением объемов также с повышением объемов наши файловые системы больше перестали справляться мы перешли на хранение файлов и частично бинарных данных в с3 разумеется с ростом нагрузки обязательно использование кеширования мы как все используем редис для сервис discovery которые у нас есть для локинга мы используем от сидим часть технологий пришла к нам вместе с какими-то функциональными требованиями или проблемами одна из проблем это борьба с фродом нас хотят обмануть и клиенты и водители и нам понадобилось искать связанных людей которые между собой как-то связано не только напрямую но и через через удаленные связи у нас был написан код на иск о или но он работал очень медленно и и все равно забрал огромное количество ресурсов мы перешли на наверху джей который который мы используем который мы очень рады и всем остальным советуем вместе с сервисом электросамокат of к нам пришла технология young youth эти электросамокаты должны нам присылать gps координаты и бэкон должен посылать команды на то что по ней учились и и облучились машинное обучение никто сейчас от этого без этого не может работать мы нам это тоже понадобилось все библиотеки которые написаны для машинного обучения это питон поэтому компанию команда data science работает с питоном модели который является результатом работы команды то сайнс генерируется в куб все или си плюс плюс который мы запускаем опять же из-за вас крис ну джесс кода с помощью боингов также с ростом нагрузки с ростом сервиса появилось три потребности в отдельной команде как карт чтобы уменьшить зависимость от того же самого google команда ребята используют джаву в apache spark чтобы подготавливать данные и srm используется собственно для просчеты маршрутов ты поговорим собственно о виновники торжества но джесс вкратце это среда выполнения джаваскрипт построена на основе библиотеки любви и движка java script v8 от google тот же самый которая используется в хроме сыну джесс используем очень хорошо на пир сделанные асинхронные события ввода-вывода и а перед здесь очень важно важно заметить что операцию сетью являются действительно синхронными на уровне вызовов операционной системы но операции с файлами а также операции с dns которые требуют доступ к файловой системе они используют пул потоков как любой интерпретатор java скрипта но уже с используют цикл событий в одном потоке собственно на нём я хотел бы немножечко более детально поговорить это цикл который разделен на этапы в каждом этапе есть своя очередь обработчиков событий колтаков и также внутри внутри этих этапов работают микро задачи одна из популярных микро задач которые используются очень во многих проектах является процесс никс дик но ее на самом деле очень не советую использовать и мы вам ее не советуем использовать дело в том что если вызывать микро задачу текстик в другом в другой микро задачи на кости к это означает что ваш код никогда не выйдет из из собственной то по означает что пока вы вызываете ник stick в другом на их стеки вас не происходит операции ввода-вывода означает что ваш сервис не получает данные и ничего не отдает вместо этого правильно использовать с этой медет это правильная команда которая действительно делает так что тот колда который вы придаете как параметр все-таки my death он действительно срабатывает в правильном месте он дает операциям ввода-вывода произойти то есть процесс ник stick имеет место быть есть определенные вещи для чего он нужен но в среднем для обычного программиста процесс ник stick не должен использоваться здесь также еще важно сказать что реализация ник stick в браузерах и внутр с до 11 версии но лучше с отличались и но начиная с 11 версии но джесс они не теперь стали работать нормально одинаково разница не такая большая но важно важно об этом знать когда пишется код но джесс и используя java-script обычный кот все-таки не не состоит из одной линии из одного действия у нас есть несколько действий если нам нужно совершить несколько действий подряд то так выглядит то что называется call back hell или лестница к албаков как кто называет дело в том что на самом деле вот этот вот кусок кода который проверяет на ошибку на самом деле должен был быть в каждом из этих колпаков я его просто не поместил сюда чтобы все-таки код поместился на слайд но начиная с 7 версии ноды появилась возможность такая как объявлять функция синхронными и вызывать такие асинхронные функции с помощью ключевого слова его из за этого получается код красивым получается читаемым он выглядит синхронно но работает в реальности асинхронно более того очень удобно использовать эти структуры языка для того чтобы вызывать вызывать код параллельно и ждать когда обе части закончится и тогда продолжать собственную execution кода очень полезно переходить столбиков на sing a weight код действительно становится более читабельный дело в том что писать какие-то iv стоит над используя кубики очень непросто те же самые циклы проходят через синхронную рекурсию это не очень легко читать но есть определенные подводные камни при переходе один из самых больших наверное подводных камней это разница в обработке ошибок дело в том что в отличие от браузеров которые при выдают просто красную строчку в логе но до падает если внутри колпака происходит ошибка осинка weight наоборот он использует активно ошибки если код который находится асинхронный код асинхронная функция если все в порядке он делает re-therm если какая-то проблема он делает траву соответственно если их вместе соединять то здесь нужно понимать что их опасно смешивать нужно очень аккуратно это делать нужно если вы это делаете то внутри call гаков обязательно все вызовы к синхронные функции оборачивать втрое кетч другая опасность это рекурсия дело в том что колда код изначально написан используется так что если вам нужно написать цикл вы делаете рекурсивный синхронный вызов этой и той же самая функция с новым индексом или что-то такое или вас очередь какая-нибудь массив и вы делаете асинхронный асинхронный вызов с помощью сетами дед я очень надеюсь что вы делаете вот это media это еще раз повторюсь процессных stick плохо работает не так как вы ожидаете но дело в том что вызов асинхронной функции с помощью away the не является полным аналогом сытыми дед дело в том что если содержание этой функции является абсолютно синхронный то вызывается код обычный кот синхронной и мы получаем переполнения стека причем переполнение стека которая зависит от размера массива которые мы обрабатываем это означает что мы можем в тестировании что у нас все в порядке а в лайве больше массив и сервис падает написание на java скрипте я думаю те кто имеют опыт знаю что там нет нет никаких типов и это это боль здесь на помощь приходит typescript по этап street позволяет сказать что параметры и то что возвращает функция имеет определенный тип в данном случае у нас число передается как параметр и возвращается promise то же самое что java фьючерс возвращается определенный тип объекта с со свойством айди который является тоже числом так что же такое typescript typescript это язык программирования и компилятор который сам тоже написано на typescript он код typescript компилируется в код java script и он добавляет java script у мощную статическую типизацию которая по силе сравнима с типизацией этой же самый java например он дает возможность проверять типы во время компиляции они в то время когда вы когда вы собственно запускаете код тот же самый и дает помогает вам говорит что у вас что у вас где есть также силы typescript а в том что он умеет выводить типы это означает что вы можете сказать просто accounts имя переменной и в большинстве случаев если то что вы вызываете типизированный компилятор сможет вывести тип и потом проверять этот тип на на то как вы его используете опять же это из-за того что typescript это настройка над java script есть тип и не который приводится к любому типу и любой тип может завестись к типа и не это означает что эти объекты этого типа вы можете использовать также java скрипте вызывать как функции использовать как объекты как как вам нравится если сравнивать typescript и java-script если отвечать на вопрос а стоит ли писать код на java скрипте если есть typescript коротко наш ответ не стоит потому что typescript во всех смыслах лучше чем javascript у него строгая типизация у него есть типизация там где надо если вы не хотите сейчас типизировать это это можно сделать потом если у вас изначально объект это действительно может быть чем угодно вы можете использовать и не это разумеется сразу дает упрощенный рефакторинг здесь не нужно наверное особенно объяснять очень интересно и очень важная функция это то что можно использовать новые функциональности старые среди исполнения тот же самая sing a weight можно использовать и в ноги до 7 старых браузерах если сделать таргет компиляции на более старый стандарт java скрипта он генерирует код который будет работать так же как как новый код он симулирует возможность среды исполнения очень важно то что у него обратная совместимость это означает что вы можете любой java script file ты ревновать в typescript у вас то сразу будет работать просто все что у вас будет приниматься будет типа и не все функции будет возвращать они это позволяет очень поэтапно переходить с java скрипта на typescript это означает что вы можете переходить по линиям по по файлам по папкам как вам угодно как только мы впустили typescript мы сразу начали приводить все наши сервисы с java script на на typescript это действительно был очень гарду альный переход мы относительно относительно быстро но очень виртуально без без такого что кто-то кого-то пушил что нет я вот не могу дальше двигаться пока то что то не поменяешь очень и очень комфортно если смотреть связку но джесс и typescript то у неё есть очень большие плюсы это это просто то сам язык java script и typescript простой на нем пишут много много людей много программистов его знают typescript вводят типы поэтому уходят проблемы не типизированных ниццы хронизации потоков один поток общеизвестно java скрипта не нужно просто синхронизировать память потому что потому что к ней может иметь доступ только один поток исполнения в реальность но джесс работает с высокой скоростью низкая латентность you если мы говорим о функциях ввода-вывода что и сегодняшних сервисах очень важна собственная основная нагрузка здесь поддерживается нативной асинхронность на уровне операционной системы которой удобно пользоваться как видели код читаемый код легли выглядит синхронным поэтому здесь очень важно что это действительно удобно пользоваться в тех случаях когда вы обрабатываете большие объемы данных обязательно используйте потоки стримы которые позволяют обрабатывать байты обрабатывать объекты в каких-то случаях вы без этого не можете если у вас приходит какой-нибудь 10 гигабайтный файл мы изначально не можете его загрузить в память и и только тогда начать обрабатывать вам его нужно обрабатывать по кускам для этого есть streams последняя но далеко не самое неважное это то что общий возможный язык работы с между фронтенда и back in dem особенно это полезно в проекты где full stack тогда более того можно написать некоторые библиотеки которые работают и там и там и соответственно программист который приключается с одной части кода на другую может писать на удобными ему языке минусы но уже с разумеется есть но здесь наверное единственный минус а котором стоит серьезно говорить это то что мы не можем запустить два куска синхронного кода чтобы они запускались абсолютно одновременно есть есть такое ограничение но это ограничение любого любой системы которая использует event лук тоже самое у питона всех для этого из лекарство можно разбивать эти долгие циклы используя сетами дед еще раз напомню не процессных stick именно с этими дед есть возможность запускать сэмплеры новые экземпляры сервиса в новых под процессах начиная с версии 12 появились такая вещь как worker и это можно запускать цикл и циклы событий в одном процессе которые могут между собой общаться с помощью общей памяти но все равно доступ к памяти у них происходит в одном потоке потому что тогда они передают между собой сообщение они не проходят по границе процесса но все равно отделается копия из одного цикла событий в другой цикл событий в общем то это означает что на но джез не создать монолитную систему но минус ли это наш ответ нет на соответствует а скорее плюс потому что но у джесс форсирует программистов писать не слишком большие сервис и потому что если программиста пишет слишком большой сервис он наткнется пьется собственного ограничения но у джесси все программисты наджис собственно об этом знают это как результат мы получаем компактный контекст сервиса легко понять что он делает так же но уже с из-за тех же самых ограничений форсирует запуск нескольких экземпляров одного сервиса это также заставляет людей понимать то что они не могут записывать в память и хранить в памяти то что может понадобиться другому запросу который придет на другой экземпляр это сразу автоматически дает отказывай устойчивость потому что у нас много-много инстансов и сразу дает масштабируемость потому что сам код всегда пишется вне зависимости от того на одном процессе или worker и используется или кластера используется все равно ваш код работает как как маленький процессе кк поэтому у вас все написано так что вы можете добавить хоть десять хоть 1000 процессов что вы уже упрётесь в инфраструктуру баз данных и всего остального но не в них проблемы самого критично то есть другими словами но у джесс форсирует собственно микро сервисную архитектуру поговорим о сервисах болт у нас их больше двухсот у каждого сервиса от 3 до до 6 экземпляров у нас 70 баз данных опять же мы используем о больше уже больше двухсот скорее всего сейчас уже даже больше 300 виртуальных серверов и dc2 на нем о них у нас работает инфраструктура те же самые базы данных редиса и также на на этих инстинктах работают и собственно сервиса мы сортируем наши сервисы это нормальная практика сортируется обычно инфраструктура и сервисы по регионам этим достигается действительно и масштабируемость этим достигается собственную локализация проблем если у нас африканский регион не работает то европа у нас все равно продолжает работать из особенностей то что у нас сегмент лишь арт сервис они всегда равен сегменту база сделано это для того чтобы была возможность при создании сервисов мы допустим выводим какую-то новую страну и мы думаем что возможно она будет очень хорошо работать но мы не хотим пока для нее выделять новую базу потому что есть определенные оверхед с инфраструктурой на на новые базы по этому мы можем создать сегмент сервиса сервисы будет работать с одной базой у них будет определенный ключ по которой мы не будет разделять кто что обрабатывает и если случилось так что новый сервис а в новой новом регионе взлетел мы делаем копию бас переключаемых и в течение секунды у нас получается sharding начинается впадать между сервисом и инфраструктурой и мы получаем полноценную масштабируемости новую вокализацию локализацию проблем у нас не используется как таковые девы сегменты divage орды дело в том что в сервис и общаются между собой и на данном этапе мы видим что нам важнее чтобы у нас сервиса между сам задержка между между сервисами было меньше для нас это важные мы используем его с global network для того чтобы задержки и скорость между нашими клиентами и боккен дам все равно было была хорошей пока это отлично работает нам не требовалось искать каких-то альтернативных альтернативных решений то есть у нас де-факто microserver снова архитектура микро визита в скобки потому что сервиса все-таки на среднего размера большими как я уже говорил не дает нам писать но до маленькими не дает нам писать здравый смысл потому что эти сервисы будут общаться между собой и уехать на общение между ними не будет стоить выигрыша вот-вот уменьшенного контекста маленького сервиса мы для для отделения локализации проблем разделяем сервисы на интерактивные и фоновые и разумеется у нас доступ только к одной базе только к своему кашу сервис не существует вакууме он всегда общается с какими-то другими сервисами в основном у нас это синхронные вызываю в и пианино синхронные по логике они по имплементации но мы достаточно активно переходим на асинхронное общение между сервисами через очередь сообщений по крайней мере в тех в тех местах там где это позволяет позволяет бизнес и технические требования при таком количестве сервисов очень важно централизация централизация всего что вы можете смотреть на систему целиком а не на отдельные сервисы для этого у нас собственно есть сервис discovery и как только новые instance нового сервиса или новый из-за существующего сервиса поднимаются сразу за работают процессы которые подключаются к этому сервису и начинают брать оттуда информацию до они берут оттуда логе они делают них поросята них структурирует и записывают власти ключ и с помощью киба на можно посмотреть их проанализировать блоге или того же самого engine кс тоже идут в этот же самый ластик search очень схожий структуре это означает что можно проследить путь путь всех вызовов которые были сделаны с в одном в одном в одном view также берутся метрики наш фреймворк который мы написали дает определенное количество метрика технических метрик какие-то метрики кастомные пишут программисты для каждого сервиса отдельно какие-то метрики бизнес они все скачиваются сервиса добавляются prometheus графона де факто стандарт хотел бы особенно ответить активный мониторинг когда не нужно собственно девелопера или работу работнику инфраструктуры сидеть перед монитором и ждать когда что-то станет не так с графиками он можешь спокойно работать и если как какие-то проблемы возникают к нему приходят сообщения в slack для нас м.с. мы в коде используем калдауны рс это означает что если происходит какая-то проблема и есть возможность идентифицировать сервис или папку в котором в котором находится файл или сам сервис то это сообщение будет адресная той команде который отвечает за этот сервис то есть сообщение приходит не не дежурному тем людям которые могут реально что то с этим сделать мы используем для собственно активного мониторинга типа лед графон alerts потом сервис посылает это на флаг или на на sm с как я уже говорил собственная разработка бэг-энда мы работаем все инженеры работают в одной git репозиторий у нас есть написаны свои инструменты для того чтобы можно было одновременно безопасно делать релизы разных сервисов которые контролируют что если две команды или два человека начинают какой-то релиз который не конфликтуют между собой они спокойно проходят если происходит к конфликту они встают в очередь между собой очень важно отметить что из за того что мы используем typescript за того что сам typescript написана тоби скрипте мы можем вызвать анализатор кода и мы мы это делаем для того чтобы используя абстрактные синтаксические деревья сгенерировать код для для реальных клиентов которые общаются между собой по этой или по очереди это означает то что если добавляется какой то какой то новый 5 им очень просто воспользоваться из другого сервиса то есть сразу генерируется клиенты подписчики то есть если вы захотите воспользоваться чем-то из другого сервиса это принципе несколько несколько строчек кода и мизерные изменения в в конфигурации еще одна важная особенность то что у нас как документация в первую очередь используется код как я говорил мы у нас очень быстрый процесс разработки мы у нас многое может поменяться за за несколько дней неделя тем более месяцев поэтому мы стараемся писать документации как можно меньше но писать код так чтобы он уже себя себя документировал то есть если какая-то возможность что-то сгенерировать skoda мы это это делаем особое внимание хочется указать на то как как мы тестируем потому что одно дело написать какое то изменение в ходе другое дело сделать так чтобы это изменение в коде работало хорошо правильно я делала то что вы хотите чтобы это делала у нас нет совсем нет какие команды для тестирования бэг-энда ни одного человека чистого к имею нас нету у нас все программисты сами пишут тесты у нас эти тест запускаются с помощью докер образов контейнеры поднимаются это происходит и локальное дженкинс одинаковое окружении докер контейнеры есть у нас для всего что мы используем для баз данных для ради сына f и j для вас есть свой докеры матч в котором можно использовать в с с с с с с с с 3 то есть все работает также как как будто если это работает в офисе мы делаем тест и прогоняем все тесты на каждый камень то есть все юнит интеграционные все тесты нас происходит на каждый коммент из за того что у нас есть где это запускать прямо прямо в дженкинс это означает что мы это делаем до релиза обычно программист что-то делает что-то меняет делает commit push это подхватывает и сразу запускает тесты то же самое происходит во время релиза после того как мы делаем релиз branch туда мер джим а наша фича branch результирующий код тоже проверяется точно также всеми же этими же самыми тестами то есть не нельзя зарелизить пока пока тесто не прибегут пока ты не увидишь что с тестами все в порядке поговорим о видах тестов они они разные у нас и немного фокус смещен немного нестандартную сторону у нас в основную основное количество тестов компонентные компоненты имеется ввиду out of crows с это означает что мы тестируем сервис как как secu ты был как процесс мы его запускаем и гоняем тесты на том что можно то что можно вызвать у нас есть системные это когда мы тестируем всю систему вместе когда мы поднимаем все сервисы и они работают как обычно и модульные у нас тоже присутствуют ну наша пирамида тестирования она необычная можете удивиться посмотрев на эту пирамиду тестирования но я вскоре объясню почему она именно такая модульный тест junit тесты у нас составляют наименьшую часть тестов и мы используем их только для разветвленной очень компактные логике которая у которых нет внешних зависимостей и дело в том что опять же из-за особенностей нашего нашего бизнеса того чтобы быстро развиваемся мы не можем себе позволить очень много времени тратить на изменения на изменения тестов если мы меняем какие-то внутренние вещи в сервисе поэтому мы относимся к компонентному тестирование также как другие относятся к модульному к unit тестирование это как я уже говорил мы запускаем это без с минимальными изменениями кода на уровне http мы мог запросы которые уходят другие сервисы это могут быть внутренние сервисы могут быть внешние сервисы и также у нас есть возможность вызова в тот делать тоже внутренние вызовы определенные например мы можем запустить какую-то фоновую задачу или мы можем стимулировать то что нам по пришло сообщение из из очереди опять же генерирование код для тестов выглядит это так что когда вы смотрите на наш код компонентных тестов он в принципе выглядит как модульные тесты это создается какой-то объект у него вызывается какие-то какие-то методы которые реально идут в реальный процесс происходит общение с базы и так далее то есть все все работает как как в реальности есть это вот такое возможность запустить как юнит-тесты но этого для тестирования сервисов отдельно недостаточно потому что сервисы работают также с внешними сервисами с сервисами оплаты гиа или еще чего-то здесь у нас есть специальный вид тестов где у нас луковица все-все вылетающие запросы кроме тех которые идут на внешние сервисы например сервис оплаты мы тестируем именно таким образом потому что там очень сложные взаимодействия и мы потратили слишком много времени на написание букв для этого и ноги были бы на самом деле не релевантны мы на самом деле нашли несколько серьезных проблем которые бы нам ударили попала еву как раз с помощью тестов которые приходили на stay джек январь менти и новые версии проблемы в новых версиях были как раз замечены с помощью вот таких вот тестов также не надо забывать микро сервис на архитектура много сервисов работают вместе поэтому некоторые сервисы работают вместе больше чем с остальными для этого нас тоже есть специальный вид теста где можно поднять группу этих сервисов которые между собой будут работать как обычно не нужно ничего мог ать а все запросы которые выходят за пределы этой группы animal каются последний вид тестирования но наверное один из самых важных видов тестирования которые у нас есть это то что у нас системное тестирование означает то что мы запускаем все сервисы вместе все все больше более 200 сервисов взлетают вместе вы работают на локальной конфигурации но больше никаких других изменений собственно нет проверяется корректность совместной работы сервисов и на самом деле вот эти сервисы являются одними из самых важных и самых стабильных в плане изменения кода этих тестов сервисов потому что мы можем переписать систему можем какой-то сервис убрать какой-то сервис добавить между другими сервисами как раз вот эти вот системные сервисы следят за нами чтобы мы тут код который мы написали равно продолжал работать опять же не скажу наверное ничего нового что если вы протестировали компонент сервис или там unit-тест написали если они работают это все таки не гарантирует что у вас работает вся система вместе и вот собственно системное тестирование позволяет быть уверены в том что вот эти вот большое количество команд который вместе одновременно tasty брились от у нас для нас нормально имеется несколько десятков релизов в день с от разных команд поэтому без этого мы бы просто не как никак не выжили еще одна один скорее совет наверное то что в эти системные сервисы желательно чтобы они как можно меньше зависели от от внешних внешних каких-то сервисов потому что у нас все еще часть системных тестов зависит от внешних сервисов это является основной причиной того что тесты падают тесты все-таки надо стараться делать стабильными и здесь лучше перенести эту часть проверками этой части логике на компонентные тесты где будет видно что если у вас сломался этот тест вы можете посмотреть на него и видеть что на самом деле payment провайдер не работает вкратце в заключение хочу сказать что подвести итоги что но у джесс хорошо подходит для для микро сервисов для архитектурами к сервисов из-за того что он очень хорошо эффективно работает с сетью typescript творить чудеса снова джесс когда не нужно работать сначала скриптом когда есть нормально язык программирования на которой можно писать менять код это очень дорогого стоит и последняя но опять же наверное мне кажется самое важное это то что на самом деле архитектура процесс разработки а тем более процесс тестирования в принципе еще более важно чем выбранная вами технология у вас может быть волшебную технология но дело в том что если она если вы не ее неправильно разрабатываете и и не тестируете и перед выбором life уже ничего не поделаешь вы можете связаться со мной по по почте через telegram если вас заинтересовал болт как работодатель заходите к нам на сайт ищите вакансии подавайте заявление спасибо за внимание юрий спасибо же знакомства в благодарны за то что так нам приехал официальный документ и даже подарок благодарю спасибо с первого ряда человек не мгновенно поднял руку вот за реакцию просто он получает вижу второй ряд потом вижу по центральным проходом привет спасибо за доклад на сколько я понял вы использовать ему на репу да и где все сервисы лежат то есть ли у вас какие-то общие not модуль с которые используют но разные проекты то есть вы храните там или какие-то нижней репозитории ну это счет что снуд module is not мудрость у нас сделано так что у нас на самом деле есть у нас получается гибрид муна репа то есть не так что у нас абсолютно абсолютно весь код в одной репозитории мы сейчас говорим именно о код о коде которые пишут собственно обычные разработчики которые пишут бизнес-логику он у нас вот в монрепо на данном этапе у нас общий но вот модус между ними но у нас мы используем typescript 3 он позволяет вот эти вот все сервисы разделять так что они физически не могут ничего взять из других сервисов и в общем-то наш долгосрочный план на то чтобы разбить чтобы у каждого были свои свой так и джейсон со своими ле пен давности и так далее но пока из за того что у нас есть тесты из за того что у нас есть наш вот этот вот определенный процесс определенные утилиты которые позволяют подконтрольной все релизе пока это все работает очень и очень хорошо и самое главное что очень легко вносить серьезные изменения то есть мы на самом деле уже сделали за год из на десяток серьезных изменений из того что все лежит в одной репозитории можно в один момент взять сказать что ладно ну вот первую половину дня не releasing сделать изменения и работать так что есть свои минусы но есть свои серьезные плюс и так ребят нам нужно будет время еще на закрытие зал а вот есть второй вопрос 3 4 и я скажу пару слов 1 раз спасибо за доклад и отдельное спасибо за фраза зачем использовать же а скрипка есть нормально язык программирования вы упомянули тесты который мог вы запросы как эти запросы собственном укрыться если инфраструктура для записи то есть просто добавили вход запрос да и запустили тесты 1 м она записалась на диск упала сейчас проявляется или же вы добавляете входа запрос и сами же ручками пишите в тестах что ему что должно чем возвращаться чтобы он проводит про гнался и если есть запись только кину в сторону каких технологий стоит посмотреть чтобы она работала какие про всякие там вообще какое решение лет мы не записываем то что то что прилетает опять же из-за того что мы используем компонентные тесты как юнит-тесты это означает что если вы начинаете писать тесты пишите его так что вы говорите что вот я начинаю вы запускаете у меня он заваливается потому что у меня мог я и не замок у какой-то какой то вылетающий запрос посмотрели что до вылетели написали это не совсем правильный подход да это может быть быстрый подходы написание самого теста но тогда когда кто-то из наших программистов так делал обычно мы получали больше проблем от этого потому что там проверялись не те вещи которые реально нужно проверять еще один вопрос и компактный ответ добрый день спасибо за доклад вы его тут уже упоминали это использовали такое очень хорошую фразу мы используем typescript потому что там такая же классная система типов как джаве ну почти такая же вам наверняка часто задают вопрос ну почему же вы не используйте java если там такая классная система зачем мы взяли то что не предназначена для типизации начале это типизировать he was были аргументы аргументы были легковес насти именно в работе с асинхронными т.е. допустим та же самая java у нее есть пул запросов если вам приходит запросов больше чем размер пуго + 1 развить большим размер пола то тогда если у вас все эти вопросы идут долго то ваш t + 1 запросам стоит у нас другой подход там больше зависит от количества памяти и ресурсов и поддержки количества соков операционной системы со своими ограничениями но вот именно для того чтобы вот перебрасывать байты от одного сервиса к другому но дано действительно очень хорошо работает с минимальными задержками и оверхедов возможно подробности вы сможете дискуссионную звание щедро ложитесь на последний вопрос ведь другом спасибо за доклад не такой вопрос нас тоже принципе примерно похожее инфраструктура и использовать и ли вы какие-то ска уровне во фромборке для работы с реальными задачами например на какое-то админка или еще что-то или вы пишете опять же как российской то и к нему же ваш фонд м входит через носить какие фигурки но экспресс грубо говоря уже достаточно простое низкоуровневой daleks экспресс мы используем но это наверное один из немногих фреймворков которм активно используем то есть в основном мы именно фреймворк часть мы пишем мы пишем сами сделали того чтобы допустим создание сервиса очень простое пишется грубо говоря один файл у него пишется какие and point и то что все сгенерировано все клиенты сгенерированы поэтому поднять новый сервис новый сервис из-за этого очень просто автоматически приходит мониторе клонирования discovery и так далее ну возможно сможете уточнить это все еще леску сезоне друг другом юрий какой вопрос понравился больше не поджав обязана ходи как тебя звать где работаешь чего продал спросил меня зовут федор и я работаю в корпорации сибирское здоровье вопрос про not я задал потому что у меня есть очень небольшой опыт работы с этим инструментом и но это очень прискорбно опыт работы и я бы не стал так никогда делать и начинать разработку микро сервисов под какое-то высоко нагруженное приложение на ноги с нуля ну вот лично я бы не стала я понимаю что люди есть другой опыт другое мнение но мой опыт в этом отношении скорее отрицательно чем положительный поэтому меня стало интересно почему серьезная компания серьезными ресурсами выбрала именно такой инструмент спасибо"
}