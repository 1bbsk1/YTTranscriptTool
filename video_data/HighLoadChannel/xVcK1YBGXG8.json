{
  "video_id": "xVcK1YBGXG8",
  "channel": "HighLoadChannel",
  "title": "Разработка Rich Text Editor: проблемы и решения / Егор Яковишен (Setka)",
  "views": 2795,
  "duration": 3444,
  "published": "2018-01-16T13:31:36-08:00",
  "text": "Всем привет. Меня зовут Егорий Ковишин. Я работаю в компании Сетка. И сегодня расскажу про разработку визуальных редакторов, то, что называется Richте Tex Editor, про проблемы и решения, с которыми, собственно, предстоит приходится сталкиваться и какие решения предпринимать, чтобы эти проблемы решить. Ну, я так понимаю, что на самом проблемы не очень распространённы, су по размеру аудитории, но тем не менее поделюсь тем, что удалось узнать за последнее время. Итак, начало в двух словах, собственно, про опыт. А мы, Сетка, занимаемся разработкой продуктов для медиакомпаний, для онлайн СМИ, проще говоря, ну, не только для СМИ, в том числе для блогеров, для самых разных компаний. И мы сделали редактор визуальный, достаточно крутой, который позволяет делать многоколоночную вёрстку, гибко настраивать стили под каждое издание, где он используется, делать адаптивную вёрстку, то есть как по десктоп, так и под мобай, вставлять различные кастомные там блоки CSS JS. Всё сразу на лету смотреть, как оно работает. А и мы выпустили это в качестве плагина для WordPress. Собственно, любой может его установить, воспользоваться. И посты в нём получаются примерно такие. Это вот, в частности, посты на сайте The Village, поскольку мы как компания родились из издательского дома Look at Medдиia. Это сайты такие, как Village, Werзи, Фурфур. Наверняка вы многие из них знаете. Вот там несколько примеров по вёрстки тех постов, которых в редакторе можно сделать. Там это и как и какие-то рядовые посты, новости, так и спецпроекты. И всё это суммарно, то есть посты, свёрсанные в этом редакторе на разных изданиях, ежемесячно генерят там порядка 20 млн просмотров. Просто чтобы вы понимали масштабы тех проблем, с которыми приходится сталкиваться. Итак, поехали. Текстовые редакторы, собственно, сами как жанр программного обеспечение появились очень давно. Наверное, там для многих это даже вообще первый софт, с которым они столкнулись в своей жизни. Кто-то, может быть, застал там MSDOS такие первые редакторы. Очевидно, что все видели блокнот Notepad в разных его исполнениях. Microsoft Word тоже уже много версий пережил. И в том числе, а, есть какие-то более специализированные программы, например, как Идизайн для действительно сложной вёрстки журнальной. Но это всё у нас на десктопе. Это такое классическое по, которое работает в операционной системе, как, собственно, десктопный софт. А что у нас тем временем в браузере происходит? А в браузере у нас следующее. Во-первых, есть просто-напросто текстерия, то есть это блок, куда можно написать текст. Он работает абсолютно везде, кроссбраузерно, отлично, но есть проблема. Никакой стилизации и уж тем более сложной вёрстки вы в этой текстере никогда не сделаете, потому что это просто поле для ввода текста. Оно там чуть сложнее, чем текстовый инпут. И есть энное количество того, что называется Reichте Editor. Вы наверняка с ними сталкивались на разных сайтах много раз. Вот некоторые классические такие представители, как Тайне MCE, Citor, Лиitor, их ещё довольно много разных. И у всех у них есть так называемые, как я называю, родовые проблемы. Какие, например? Во-первых, практически во всех не соблюдается ключевой принцип, который называется визивик. What you see is what you get. То есть то, что вы видите в этом редакторе, та вёрста с которой вы работаете, как правило, это не то, что потом вы видите на сайте. То есть в редакторе вы работаете с каким-то окошком маленьким там фиксированного размера, что-то в нём делаете, там что-то происходит, а потом на сайте всё совсем другое. Там, как правила, уже какой-то шаблон, там может быть уже и десктоп, и mobile responsive, какие-то другие блоки и так далее. Это номер один. Далее, функций в таких редакторах, как правило, либо очень мало из серии там Болт Италик, выравнивание текста, либо очень много. Пять строчек кнопок, в них невозможно разобраться, они непонятно как работают и так далее. Из-за этого, как правило, такие редакторы сложно подружить с уже существующим дизайном сайта, который был там утверждён арт-директором, свёрстон, он работает, и вам нужно как-то вот этот редактор подружить таким образом, чтобы можно было всю эту красивую вёрстку в нём делать. Это, как правило, довольно сложная задача. А обычно эти редакторы не особо кроссбраузерные, особенно что касается EA и Safari. Там много проблем, которые связаны в первую очередь с браузерами. И общая такая проблема, что редакторы, как правило, создаются как инструменты общего назначения. То есть, как правило, RТx Editor - это, на самом деле, инструмент для перевода каких-то визуальных блоков в их HTML-код. Ну, и CSS для тех людей, которые по какой-то причине не хотят или не умеют это делать. Есть ещё масса других проблем, которые можно долго перечислять. Например, что HTML-код в таких ретаграх, как правило, очень сильно санитайзится или, наоборот, не санитазится вообще. То есть либо вы не можете ничего сделать, либо это потенциальный XS. Оттуда же растут проблемы с SEO. Далее, сейчас мы видим, например, что на наших сайтах более 50% трафика, ну, где-то 50 на50 - это мой, а, как правило, такие редакторы позволяют верстать посты только под десктоп. И как они потом морфятся в мобилку, вы не знаете, верста это и так далее. Проблем действительно много. Итак, вот наступил какой-то такой момент, и вы по какой-то причине решили сделать свой собственный редактор. Номер один. Не делайте этого. Интернет пистрит просто вот такими постами, где написано: \"Пожалуйста, не стоит этого делать, потому что это, скорее всего, не получится\". Потому что есть масса ограничений, которые вас остановят для того, от того чтобы сделать действительно хороший продукт. В частности, это скриншот сок Overflow, где один из разработчиков SEки Editor, это один из, ну, таких крупных редакторов, пишет, что мы уже 10 лет это делаем, у нас до сих пор там тысячи is и, к сожалению, мы не можем достичь хорошего результата не потому, что разработчики плохие, а потому, что браузеры плохие. Тем не менее, вы всё-таки отвергли все сомнения и хотите сделать свой редактор. С чем вам предстоится столкнуться с какими проблемами? Во-первых, нужно разобраться, как редактировать, собственно, контент на веб-странице. Во-вторых, как его хранить, как быть со стилями. Это такие ключевые проблемы, с которыми приходится сталкиваться, и как расширять функциональность этого редактора. Вот, собственно, про это мы сегодня и поговорим. Так, по порядку. Как редактировать контент? Значит, исторически для этого браузеры нам предоставляют следующие возможности. Во-первых, у объекта документ есть такое свойство, которое называется дизайн mode. Оно существует очень давно, наверное, ещё с конца девяностых годов, было реализовано ещё там в первых версиях Интернет-экс Exсплоorра. Когда это свойство переключается в режим он, то вся абсолютно вся страница, всё боди становится редактируемым. То есть вы можете поставить курсор в любое место, стирать, удалять текст. Ну, естественно, он никуда не сохранится, но тем не менее вы можете как бы его редактировать. А проблема основная с этим заключается, что, как правило, вам не нужно редактировать всю страницу. Вы хотите редактировать какой-то определённый блок. И для этого было придумано, по сути дела, ну, продолжение этой истории атрибут, который называется content editable, который тоже можно переключить в режим включено, и тот контент, который находится внутри этого блока, становится редактируемым. По сути дела, именно таким образом сейчас сделано абсолютное большинство визуальных редакторов. И наш не исключение. Также есть такая пишка, которая называется document exact command, специальный метод, который позволяет к выделенному участку текста применить какую-то браузерную команду. Давайте про каждый способ пару слов скажем. Значит, во-первых, про дизайн mode. Вот можно нагуглить, даже, если погуглить, такие восторженные комментарии, там десяти-пятнадцатилетней давности, люди в восторге на форумах, типа античата пишут: \"Ой, как классно, я нашёл такую здоровскую команду, и можно вести в браузере и любую страницу редактировать\". Люди там с радостью редактируют сайты Microsoft, Google и так далее. Всем очень нравится. Вот такие можно найти всякие твиты. Но, как я уже сказал, способ несовершенстный. Несовершенный, потому что всю страницу вам редактировать, как правило, не нужно. То есть, по сути дела, единственный кейс, когда это применимо, я говорю про дизайн modд - это когда у вас редактируемая область лежит в Айфрейме, и вы действительно хотите именно этот блок целиком сделать редактируемым, но таких ситуаций не очень много. Следующее. Content editable - это основная, по сути дела, сейчас браузерная опишка для создания редактируемых блоков. Вы переключаете в режим true, и всё, что внутри этого блока, становится редактировам. Можно поставить курсор, писать, удалять там и так далее. Но есть основная проблема, это то, что по сути дела каждый браузер реализует пользовательские действия в этом блоке по-разному. Вот смотрите пример простейший. Вот мы имеем editable блок, включили true, он стал редактируемым. И дальше я ставлю курсор после запятой, вот после слова hello, запятая, и нажимаю кнопку Enter. Что происходит в Хроме и Safari? У нас создаётся внутри новый div. В нём неразрывный пробел, оставшееся слово World, а, например, в Фаефоксе перенос строки BR. И таким образом вы как бы никогда не знаете, а что же там вообще произойдёт. вы никак не контролируете ситуацию, потому что каждый по-разному. И следующая опишка, которая называется Exact Command, такой метод, она позволяет к выгодненному участку текста на странице применить какую-то браузерную команду. Таких браузерных команд фиксированное количество, они имеют название типа bolt, font size, формат текста и так далее. И эта пичка тоже существует уже очень давно, и она крайне нестабильна. Где-то она работает, где-то она не работает, где-то она ведёт себя по одному, где-то по-другому. И вот наглядный пример. Допустим, вы опять же в том же самом примере выделили слово hello и выполнили exact common bolt. У вас это обернулось в теге B. Какие тут понциальные могут быть проблемы? Ну, во-первых, может быть, я хочу не B, а стронг, меня сеошники попросили. Или, может быть, я хочу к этому тегу B ещё потом какой-то класс на него навесить. Соответственно, мне придётся какое-то дополнительные действия делать. Ну ладно, бог с ним. Б ещё не так страшно. А если я хочу, скажем, какой-то шрифт сделать большим там заголовком, я выполняю браузерную команду Font size, передаю аргумент семь, то есть прямо большой хочу сделать. Что она делает? Но она так и делает. Она вставляет тегфон, который мы уже не видели на сайтах чёрт знает сколько, и делает его седьмого размера. Да, визуально это о'кей. С точки зрения кода и после следующей поддержки этой истории, это вообще ни разу не о'кей. Соответственно, разные браузеры генерируют разный HTML в Content Edit областях. Exact тоже работает не везде, не всегда и по-разному. И вы не контролируете ситуацию, не знаете, что происходит. Соответственно, редактор получается неполноценный. Вы никогда не знаете, что же он выдаст наружу. Соответственно, вы не можете к этому стиле правильно применять. Вы не знаете, как это парсить, как это на SEO повлияет и так далее. Вот, в частности, есть даже уже такая христоматийная статья, называется White Content Edit is terrible. И там разработчики медиума, если не ошибаюсь, описывают, собственно, почему content IT был плох и что с этим делать. Итак, а какие есть альтернативные способы, как можно редактировать контент на странице, избегая этих проблем? Есть способ сделать свой редактор на канвассе. Такие примеры даже есть. Но это, по сути дела, вам нужно взять и в области вашего редактора перезобрести весь рендеринг текста, курсора и так далее, и так далее. Мы сейчас увидим, что на самом деле много из этого и так приходится делать, но в случае с канвассом вы по сути дела работаете с текстовой областью вообще как просто с картинкой. И это, ну, уж прямо совсем сложно. И скорее всего, а вы огребёте такое количество проблем, что это будет неблагодарно. И второй способ, который чаще всего как раз исполнит используется на практике в практически всех современных редакторах и в частности у нас, это связка content editable области и хранение состояния, то есть стейта документа на основе тех действий, которые в этой области происходят. Как именно? Вот у вас есть Editable область. В классической, э, в классическом её использовании. Вы ставите курсор, пишете какой-то текст, у вас контент меняется. Соответственно, меняется, как мы уже узнали, он непрогнозируемый в зависимости от браузера, от ситуации и так далее. Что делаете вы? По сути, это подход, который в реакте называется controlled input. Когда вы что-то пишете в input, у вас это сразу там не появляется. У вас сначала меняется state, а потом этот жепут перерендеривается на основании изменения этого стейта. Так вот, вы ставите курсор в editable область. выполняете какое-либо действие, допустим, на клавиатуре или ещё как-то, у вас это действие перехватывается, изменение этого Editp области не происходит, а вместо этого меняется стейт вашего документа или редактора в зависимости от того, что именно произошло. Допустим, вы а также поставили курсор и нажали Enter. И редактор понимает, что, допустим, надо вставить перенос строки. Или если у вас в этот момент был выделен не текст, а какой-то объект в редакторе, например, картинка или ещё что-то, то надо произвести какое-то другое действие. То есть вы таким образом становитесь полноценным хозяином того, что у вас в редакторе происходит. Можете полностью контролировать все действия, отменять их, какие-то другие выполнять и так далее. То есть все действия перехватываются и происходит изменение стейта. Затем уже рендер того, что происходит в самой Editable области. Ну, по сути дела, это такой подход, который сейчас используется, наверное, во всех компонентах, вообще современных фронтн приложениях. Что в этом стоите может храниться? Ну, во-первых, сама модель документа, контент. Мы сейчас поговорим о том, какая она может быть. Это текст, картинки, какие-то эмбеды, разделители, всё, что у вас угодно. У нас, допустим, там хранятся такие вещи, как сетки, потому что у нас, э, вёрстка во многом построена на сетках многочных. Далее, это позиция курсора. куда вы поставите курсор. Желательно это запомнить, чтобы это можно было возвращать в снапшотах, хранить это как-то реализовать и так далее. Выделение текста, мы сейчас поговорим об этом чуть подробнее. И, в частности, UI-редакторы, то есть, например, какая панель у вас сейчас открыта, что активно, что неактивно, там, в каком вы режиме находитесь и так далее. Таким образом, вы можете это всё хранить как state, например, как red state или там OBК, что угодно, и работать со своим редактором как с приложением, которое вот этот стоиate меняет. Вот, например, есть такой редактор, который называется Draft JS. Это продукт Facebook, он сделан на Реакте. И вот можно там увидеть, а как они хранят стоит своего редактора. Вот здесь, наверное, более-менее видно. Там две строки в редакторе. Первая строчка и вторая строчка. И вот справа они представлены в таком Jonдобном виде объекта. По сути дела у них есть атрибуты, там текст, у каждого есть свой уникальный ключ ки. Они могут быть стилизованы, не стилизованы и далее. Но больше всего дальше всех в этом вопросе пошёл Google Docs. У них задача была нестандартная. И мало того, что нужно было сделать редактор, им нужно ещё было сделать многопользовательское редактирование. Это означает синхронизация изменений. а мультикурсор и все прочие вот эти сложные штуки, которые вообще лежат за пределами возможно, ну, за пределами вопросов разработки редактора. Что они сделали? Они также отслеживают все ивенты, которые происходят на странице в специальном Айфрейме, который вообще находится далеко-далеко за пределами экрана. Вот здесь, наверное, более-менее видно, что этот у него координата топ -10.000 пикселей, высота у него всего один пиксель, и он находится где-то очень-очень далеко. используется только для того, чтобы перехватывать, что у вас на странице происходит. В частности, вот видите, там content edit true, и внутри ничего нету, там только спан с пробелом. То есть это такой служебный абсолютный инструмент. И Google Docсу для того, чтобы решить все его задачи, которые они перед собой ставили, пришлось, по сути дела, перезобрести вот весь движок рендеринга текстового редактора. Вот смотрите, на этом слайде здесь показано выделение текста. И мы можем видеть, что на самом деле это не стандартное выделение силами операционной системы, а это тоже специальный див, который называется он Kick Selection Overlay. У него есть background color, opacity и прочие координаты. То есть это по сум дом обёртка, которая представляет собой выделение. Если вы попробуете там поиграться с выделением, посмотреть, что происходит в инспекторе, это так. Мало того, у них даже курсор, который вы ставите в то или иное место текста, вот у меня, допустим, курсор сейчас стоит перед словом вы, там сверху видно этот курсор - это тоже див, у которого там ширина, наверное, один или два пикселя, высота с строчку и к нему применены определённые CSS-свойства, которыему позволяют мелькать каждую там полсекунды. То есть курсор - это тоже HTML-элемент, он не нативный. Таким образом, на странице может быть одновременно пять курсоров, если её редактирует пять человек. И тут мы переходим, собственно, к следующему вопросу. Если мы редактируем контент таким образом, что у нас он весь хранится в стейте, как нам его хранить? Традиционно у нас контент, который отображается на веб-странице, хранится в виде ХТМ. У этого есть свои плюсы. Во-первых, такой контент легко показать в браузере, потому что если вы покажете в браузере JSON, он отобразится, ну, как JON. легко изменять его без редактора. Если по какой-то причине редактор у вас отвалился, не работает или ещё что-то, вы можете всегда это HTML взять и подправить так, как вы считаете нужным, если вы хотя бы немножко его знаете. Далее, скорее всего, сейчас HTML-код хранится именно так, в вашей базе данных, в вашей CMS, там и так далее. И что тоже немаловажно, другой код, например, какой-то индексер или плагины, они приучены работать, скорее всего, тоже с ХТМом, а не с вашей структурой, которую вы придумаете. Но есть и минусы. Во-первых, как мы уже знали, разные браузеры выдают разные HTML из content editable областей. То есть мы не можем быть уверены, что мы получим на выходе. А там могут быть совсем страшные вещи. Там могут быть и дивы, и пэшки, и вообще много разных вещей. Такой код сложно экспортировать в другие форматы, которые сейчас становятся достаточно востребованны. Например, Facebook Instant Articles, какой-то JSON. Например, вы хотите, чтобы ваш контент на вебе отображался по одному, а также он улетал в какое-то мобильное приложение. Также он, допустим, для скачивания в PDF должен быть доступен и так далее. И контент такой сильно связан с его оформлением при помощи таких HTML атрибутов, как style к соответственно, если вы хотите решить эту задачу, вам нужен свой формат. Как его сделать? Во-первых, нужно декомпозировать на сущности то, с чем вы работаете в редакторе. Скорее всего, у вас будут примерно вот такие классические элементы любого текста: заголовок, параграф, картинка, комментарий, какой-то имбет, сетка, в зависимости от того, какой редактор вы делаете. В частности, если мы говорим про редактор кода, там будут свои сущности. Если мы говорим про графический редактор, там свои. Надо понять, с каким контентом вы работаете. Далее, это нужно представить в виде некой структуры. с типами, атрибутами, которую потом вы можете, с которыми вы можете потом работать. То есть это, по сути дела, структура вашего стейта, контент стейта. Вот на этом слайде мы видим, что, допустим, есть элемент параграф, у него есть определённый контент, и первые четыре буквы с нуля до трёх у него отформатированы в полужирном формате. И, э, такую структуру, такой такой формат документа можно отредерить как угодно. Вы можете это отрендерить в playтек без какого-либо оформления, в HTML, выгрузить в PDF для, скажем, там, печати или сохранения, в JSON, в RSS, там, как угодно. И что немаловажно, такую структуру можно в редакторе отображать по одному, допустим, с какими-то элементами редактирования, дополнительными там кнопками и так далее, а снаружи совсем по-другому. Таким образом, вы как бы опять же становитесь полноценным хозяином того, что у вас с контента происходит. Вы можете задать тут полноценный, ну, такой нормальный ожидаемый вопрос. Послушай, у нас, скажем, контент хранится в ХТМле уже там много лет. У нас какая-нибудь CMS своя там, не знаю, Bitrix, WordPress или на своём фреймворке что-то написано. Ты нам предлагаешь это всё забыть и, значит, придумать свой формат и потом весь код переписать, чтобы он с ним работал. Очевидно, что как бы мы делать этого не хотим, потому что непонятно какую пользу это с точки зрения бизнеса принесёт. У нас, на самом деле, проблема была та же самая, когда мы внедряли редактор на наши сайты Village и так далее. Большая, а, доля Legacy кода, уже там тысячи постов свёрстанных. Как с этим быть? Есть определённый workра. Хранить данные в том виде, в котором они есть уже. Ну, скорее всего, это HTML. При загрузке в редактор парсить их и превращать в ту структуру документа, которую вы придумали, и работать уже с ней. А просто когда вы сохраняете обратно в базу данных, реализовать это обратно, ну там, скажем, в HTML или как надо хранить и сохранять это так, как есть. В частности, мы сейчас делаем вот так. А, но в нашем случае это ещё обусловлено тем, что мы, редактор, делаем инструментом, который работает в разных средах. Я сегодня об этом буду ещё говорить в других CMS, на других платформах. И мы как бы, скорее всего, не имеем права навязывать им свой формат хранения данных. Нам нужно работать с тем, что есть. Дальше, как работать с пользовательским вводом. Давайте вообще поговорим о том, какой какие бывают виды пользовательского ввода на вебе. Ну, очевидно, это клавиатура, самая простая, старая добрая клавиатура, но она бывает ещё и виртуальной. Помимо этого, есть контекстное меню. Вы можете выделить какой-то кусок текста и производить на него определённую операцию. Неотъемлемая вещь, которая в контекстном меню обычно всегда есть - это такие операции, как copypast. Причём они могут выполняться из контекстного меню, которое там правой кнопкой вызывается на контенте. Бывает контекстное меню, которое а в операционной системе где-то там сверху живёт. И ещё и шорткатами можно копий сделать. Далее есть операция DragonDrop. Далее есть голосовой ввод, который становится сейчас у тебя более и более популярным. Кtation и всякие умные помощники. Есть рукописный ввод, который актуален, скажем, в каких-то азиатских странах. Когда вы что-то рисуете, это превращается в понятный символ и потом уже попадает в редактор. Есть автокоррект и автоподсказки, которые есть у каждого в мобильном телефоне. И что вам с этим всем делать? Ну, понятное дело, что ваш редактор не обязан поддерживать абсолютно все эти способы ввода, скажем, скорее всего, там при помощи голосового ввода, но всё-таки мало кто ещё сейчас будет вводить какой-либо текст, но тем не менее это надо учитывать. И браузер нам для этого предлагает такой зоопарк различных API. Почему? Потому что у диб областей нет, к сожалению, какого-то единого события change, на которой можно подписаться и точно знать, что именно там происходит. Есть несколько ключевых, при помощи которых можно вообще хоть как-то с этим всем работать. Хотя подчеркну, практически в каждом посте, и мой рассказ не исключение про создание визуальных редакторов подчёркивается, что ситуация с API браузерами плохая, и делать это всё трудно. Приходится много костлей впиливать. Итак, пару слов. Selection API, который позволяет работать с выделением на странице. Он нам выдаёт два события полезны: Select start и selection change. А, соответственно, select start срабатывает, когда мы начинаем выделять какой-то участок текста на странице. И selection change срабатывает каждый раз, когда это выделение меняется. Причём, что полезно, оно срабатывает не только, когда оно меняется при помощи курсора, но и, скажем, когда вы там Shift и стрелки нажимаете или Command A, Ctrl A нажимаете, всё выделяется. Это это событие срабатывает, это удобно. Далее, после того, как выделение на странице изменилось, вы можете считать, что же, какой участок текста сейчас выделен. Для этого есть метод, который называется get selection. Он возвращает объект selection, у которого есть определённые полезные свойства, которые с которыми можно работать. В частности, там есть объект выделения, у которого есть два свойства: Encore node и focus node. Я написал тут offset note, на самом деле focuse. А note - это та нода, на которой выделение началось. И Focus Node - это та нода, на которой выделение закончилось. У каждой из этих нот может быть свой офсет. Допустим, вы начали выделять на десятом символе первого абзаца и закончили выделять на пятом символе третьего абзаца. Таким образом, вы можете понять, что же именно выделено сейчас у вас на странице. Вот, например, смотрите, это сайт Frontend conf. Я здесь выделили текст, начиная со слова дизайн и заканчивая мобильные сайты и считал текущее выделение, посмотрел, что именно. можно увидеть, что а и focus у меня оба текстовые ноды, и уde равен одинати. Слово дизайн начинается на одиннадцатой позиции верхнего абзаца. И осай у focus равен 15. То есть мы вот чётко можем понимать, что мы сейчас выделили. Sлеction API поддерживается достаточно хорошо везде. Им вполне можно пользоваться. Там есть определённые проблемы, но в целом он достаточно стабильный. Следующее клиборд API. Вот здесь проблем действительно довольно много. В частности, мы на следующем слайде вот чуть забегая вперёд, увидим, что, видите, нам сообщает, что везде есть какие-то звёздочки, какие-то помарочки, что-то работает нестабильно. Какие основные особенности? Ну, API предлагает нам энное количество событий, которые можно подписаться и с ними взаимодействовать. это копирование, вырезание контента, вставка его и всё, что происходит как бы чуть-чуть до этого, beр. И мы можем самостоятельно вызывать некоторые из них. Но тут есть очень много secюurity соображений, которые нам блокируют определённые действия с буфером обмена. В частности, что можно сделать, если пользователь сам инициировал, например, копирование, то есть нажал там Ctrl C или нажал, скажем, правка копировать, происходит событие копирования, и в этот момент мы можем вмешаться и выполнить определённые небольшие действия. Какие? Мы можем изменить содержимою буфера обмена, можем запретить, и мы можем изменить, например, алгоритм вставки. Если что делает pas, то мы можем вставить как-то по-своему, не просто вот там в тот, э, в ту в то место текста, где стоит у него курсор, а как-то так, как мы захотим. Чего нельзя сделать? Нельзя инициировать а операцию с буфером обмена, если человек этого сам не хочет. Почему? Ну, достаточно очевидно, допустим, вдруг у человека в буфере обмена пароль или номер кредитной карты, а мы такие: \"Раз сделаем йст, куда-нибудь это сохраним, отправим и так далее\". Не секюрно. Поэтому, если человек сам не вызывает, не инициирует это событие, мы тут вмешаться никак не можем. И то, о чём я сказал, что поддержка ещё пока хорошая, но везде есть определённые ограничения. И тут как бы есть интересный сценарий. Допустим, вы в вашем редакторе хотите реализовать а копирование не просто текста, а какого-то сложного объекта. Как это сделать? Для этого есть пример трела, которым мы, кстати, воспользовались. И в нашем редакторе тоже сейчас покажу, как они об этом открыто пишут наг Overflow и работает следующим образом. Надеюсь, у меня сейчас видео нормально сработает. Нет, надо здесь, видимо, сделать. Да, вот смотрите, а оно будет по кругу крутиться. Я подскажу. В Трела есть такой сценарий, когда вы наводите курсор на какую-то карточку, просто наводите, нажимаете Command C, потом наводите курсор куда-то в другое место и нажимаете вот здесь Command V, и эта карточка в это место вставляется. Как это реализовано? А, повторюсь, они об этом открыто пишут. Реализовано следующим образом. Они отловили такой паттерн поведения. Когда человек нажимает кнопку Command или Ctrl в случае Виндоуса, то есть большая вероятность, что вслед за этим он нажмёт C, чтобы скопировать. Соответственно, при нажатии Command, что они делают? Они создают за пределами экрана невидимую текстерию, кладут в неё код того элемента, который человек хочется копировать. Ну, представление кода остаётся целиком на их усмотрении. Это может быть HTML, там JSON, что угодно. И ставят туда фокус. Когда человек нажимает C, то у него копируется тот код, который находится в этой текстерии. И когда он потом наводит курсор куда-то в другое место и нажимает вставить, они перехватывают события вставки, понимают, что ага, он скопировал содержимое карточки и реализует свой алгоритм вставки, который в данном случае вставляет это, а, в тот список, на который у него наведен курсор. Ну вот, в частности, как мы это реализовали у себя похожим образом. Вот у нас есть составной такой объект, картинка, два параграфа. Копируем через контекстное меню в этом случае. Потом переключаемся вообще на другую вкладку, где тоже открыт редактор. Вставляем. Готово. Вот мы вставили сложный объект. И что ещё надо сказать? что есть отдельный тип событий API, что называется Composition events. Мы на самом деле в нашей вот западной культуре не очень часто с ними сталкиваемся, потому что они во многом, а, ну, точнее конкретно, наверное, в российской культуре, потому что они во многом связаны с диакретическими знаками, они во многом связаны с различными иероглифами, которые несколькими там действиями составными вставляются, и они связаны с такими новыми способами ввода, как голосовой вод и так далее. В двух словах, как они работают. Если, допустим, вы хотите вставить какой-то символ с декретическим знаком, там на том же Маке, как вы делаете? Вы нажимаете, например, Alt и кавычку апостроф и потом нажимаете, скажем, букву А, и они у вас склеиваются в один-единый символ А, с диакритическим символом. И это всё вызывает сразу несколько событий. Composition start, когда вы начинаете вот этот процесс композиции как бы одного символа из нескольких. Composition update, когда происходит каждое обновление, каждое вот добавление какой-то составной части этого символа и composition end, когда сформирован готовый целый символ. Также может, например, работать и голосовой ввод. Вы наговариваете текст, браузер его, а декодирует, превращает в строку, происходит composition update. Когда вы завершили говорить, то происходит composition end и появляется финальная строка. Также, соответственно, тут надо сказать, что все эти действия ещё неплохо бы иметь возможность отменять и повторять, то есть действовать, делать андуриду, такой привычный патрон в любом текстовом редакторе. Но системный механизм нам уже не подойдёт, потому что, напоминаю, мы храним всё в стейте, а он не обновится, если сработает стандартный системный механизм отмены чего-либо. Соответственно, а тут уже надо перехватывать просто нажатие таких кнопок, как Command Z, Ctrl Z, и реализовывать свой механизм Undри, который, как правило, основан на хранение сNпшотов Стейта. У вас появилось какое-то действие, сохранили Snapпшот, соответственно, потом имеете возможность к нему вернуться. Там то, что, скажем, пропагандирует RedКС в своей философии. Следующий важный момент, как быть со стилями. Вот у вас есть формат документа, вы научились его редактировать, но это уже есть ещё свои стили, и тут всё не так просто. В чём проблема? Значит, у нас, по сути дела, редактор - это компонент. Он сам по себе малопригоден. Он живёт в какой-то среде, как правило, в какой-то админке. У редактора есть свои стили, его UI, панели, кнопки, там, размеры и так далее. Повторюсь, этот редактор живёт внутри какого-то приложения, например, CMS. У этого приложения тоже есть свои стили. И внутри редактора живёт сам пост, который вы редактируете. И у поста тоже есть свои стили. Они могут быть совсем разные, потому что, например, вы можете в одном и том же редакторе верстать посты там с разными фирменными стилями. Нам нужно как-то всё это друг от друга изолировать. При этом мы помним, да, что CSS правила у нас живут в глобальномсе. Порядок их применения определяется их специфичностью селекторов, а нам при этом всём надо гарантировать то, что мы называем Vivвик, то, что у нас в редакторе, тоже потом и на сайте. Как это всё решить? Вот, допустим, пример с Вардпрессом. Мы видим админку Вардпресса. Вот вся эта большая серо-белая область. В ней внутри живёт редактор. Это вот конкретно наш случай. Мы это как плагин поставляем, который вот отдельной вкладка Сетка диitр там появляется зелёный зелёный участок - это редактор. И внутри редактора ещё и живёт пост синий. И у всего этого своих стилей. Как сделать, чтобы они друг на друга не влияли? Вот, в частности, абсолютно реальный пример CSS из вадпресса. Мы видим, что для всех заголовков H2, которые лежат внутри блока с ID пост STF, сдаются определённые правила. А мы помним, да, что селекторы, у которых указан ID, в данном случае поств, они имеют очень большой вес, который перебить можно, ну, по сути дела, только таким же образом или ещё более сильными инструментами. Как именно? Итак, что нам нужно изолировать? Мы хотим изолировать редактор от внешней среды, пост от редактора и внешней среды, внешнюю среду от всего этого. Тут уже проще, потому что мы контролируем тот CSS, который мы пишем. И в некоторых случаях мы ещё и хотим шаблон сайта резолировать от того поста, который в нём находится. Например, поскольку мы поставляем наш продукт, а как с возможностью конфигурировать стили поста отдельно от сайта, то стили шаблона, сайта и стили поста не должны друг с другом конфликтовать. Итак, что делать? Ну, собственно, есть три, наверное, основных способа, как каким образом это можно решить. Можно всё заресетить и применять абсолютно определённую систему нейминга. ваших классов. Ну, в данном случае это можно заметь на что угодно. БМ как самый распространённый вариант. Далее можно положить всё вframe. Тут уже более железобетонну защиту, но со своими недостатками. И можно всё упрятать в Shadow Dome и Custom Elements, но тут есть очевидный недостаток. Пока ещё плохая поддержка браузерами. Вот, например, смотрите, тот CSS вордпресса, который я показывал, мы хотим его перебить. Единственный способ, как нам это сделать при помощи селекторов - это задать селектор с таким же весом, то есть в данном случае My Editor, и задать там свой стиль. Либо мы встаём на скользкую дорожку inлайн стиле импортантов, но мы тогда вступаем в войну с самим собой, потому что в дальнейшем у нас начинаются постоянные войны со специфичностью. Мы, допустим, задали какой-нибудь селектор с ID, у него же там important. И чтобы потом нам же переопределить этот стиль, допустим, мы применяем какое-то там свойство к элементу в посте, там какой-нибудь отступ, нам нужно, соответственно, постоянно придерживаться вот этих же селекторов. И у нас размер файла начинает дико раздуваться, потому что у нас везде вот это повторяется. Понятно, что там помогает и так далее, но всё равно. И что самое важное, это не даёт стопроцентной гарантии, потому что на каждый хитрый селектор найдётся ещё более хитрый селектор, который его перебьёт. Далее можно всё положить вframe. С одной стороны, это хорошо, потому что у вас теперь всё точно изолировано и CSS. С другой стороны, это постоянный барьер. Вам нужно постоянно будет обмениваться сообщениями между внешней страницей и внутренней. А и просто так это уже не сделаешь. И, например, есть такой популярный проблема касательно именно визуальных редакторов, что айфреймы сами по себе не будут адаптироваться под высоту того содержимого, которое в них находится. Да, можно отслеживать, постоянно менять на лету размера Айфрейма, но это как бы одна только из тех проблем, которые есть. И самый, наверное, классный, хороший подход, которого все очень ждут - это использование Shadow Dom и customм элементов, когда можно будет свой редактор как компонент положить на страницу как custмко компонент, внутри у него будет, соответственно, shadow root, и всё там будет изолировано полностью. Вот это было бы очень хорошо, но пока что нас от этого ограничивает, от этого светлого будущего вот такая ситуация. Shadow Dom нормально поддерживается только в определённых браузерах. С кастоми элементами та же самая история. И пару слов ещё про адаптивную вёрстку. Напоминаю, что у нас очень высокий сейчас процент мобильного трафика, и он в мире будет везде только расти. При этом верстаем мы на десктопах, как правило, но хотим видеть, как это выглядит на мобилке. Мы не хотим вручную, как правило, всё адаптировать, мы хотим, чтобы оно сразу работало. Но если мы делаем особенно какую-то сложную вёрстку, мы хотим понимать, а что же там вообще на мобилке хотя бы посмотреть? И также, может быть, что-то ещё и подтюнить. Вот, допустим, как это решили мы у себя. У нас есть специальный режим превью. работает он там что-то происходит. А, там всё происходит, да. Мы нажимаем, открывается режим prev. Можем посмотреть, как наш пост выглядит на зеспе, а потом переключиться в режим mobile и посмотреть, как на мобайле. Как это сделано? Мы на Литу генерируем два айфрейма, у каждого из которых есть определённая ширина. Один, соответственно, под десктоп, другой проile, под mobile. В неё грузится та реальная ЦСэска, которая же применяется потом и на сайте, тем самым обеспечивается визивик. Но, соответственно, из-за того, что Ифрейма размер, ширина его ограничена, то к нему применяются мобильный media queries. И таким образом мы можем видеть а тот реальный результат, который потом будет на мобилке. Ну и, соответственно, при каждом нажатии вот кнопка кнопки входа в этот режим preview мы генерируем нужный контент и кладём его в Wi-Frame. Происходит это довольно быстро. То есть у фрейма нет никакого какого-то конкретного srcмента. В нём просто программно его контент меняется каждый раз. И последний момент, как же расширять функциональность. Вот вы написали редактор, у вас ядро есть, и у вас постоянно какие-то новые фичилы. Что с этим всем делать? Тут такой более как бы архитектурный момент без каких-то конкретных, ну, каких-то воркундов на основании нашего опыта. У редактора обязательно должен быть публичный API, чтобы вы на основании этого могли реализовать какую-то систему плагинов. Естественно, это всё должно покрыто быть документацией. В частности, что должен позволять делать этот API? Естественно, получить контент из редактора и при необходимости его там изменить. Должна быть какая-то система событий. Допустим, что-то вставили в ваш редактор, курсор передвинулся и так далее. Но если вы, а, редактор стоите по такому принципу, как я уминал, упоминал в начале, что все события отслеживаются и влияют на от state, то, скорее всего, у вас в это уже уже всё есть. И также редактор должен иметь возможность интегрироваться с той внешней средой, куда он попадает, например, чтобы реализовать загрузку файлов в ту CMS или там ту систему, где он живёт и так далее. И система плагинов. Если вы построили редактор по принципу actionтов и стейтов, то по сути дела каждый плагин у вас, если говорить терминологии редакса, то это набор actions, то есть экшенов, которые он может производить с этим стейтом, и набор редюсеров, которые на этот стейт влияют. Несколько примеров плагинов, например, проверка орфографии или типограф или интеграция с какими-то внешними сервисами. Также есть ещё масса-масса других моментов, о которых надо думать при разработке редактора. Рассказывать о них можно очень долго, поэтому я их просто по пунктам перечислю. Например, вставка имбедов через оже вопрос санитайзинга HTML-кода. Когда вы вставляете какую-то ссылку, например, на YouTube или Facebook, она у вас превращается в бет в вашем редакторе. Реализация вашего контекстного меню, которое опять же такой привычный инструмент в любом редакторе. горячие клавиши, как ваши собственные, так и какие-то реализации системных действий, режим редактирования HTML и CSS для каких-то отдельных элементов, метасущности в редакторе, например, комментарии на полях, как в Google Доксе. Туда же идут возможность сделать анимации, допустим, если ваш редактор продвинутый, как Ready Mac там или Тильда, которая позволяет это сделать. работа в оффлайн-режиме, то есть сохранение, допустим, контента где-то на стороне браузера, потом разрешение конфликтов, запуск, остановка, редактора при помощи IP. Вопросов очень много разных. Теперь пару слов заключения о том, что нас вообще ждёт. Ну, во-первых, нас ждёт Web Components, который позволит решить вопросы с изоляцией, в частности, стилей на странице, что было бы очень хорошо. А если говорить конкретно про опишки, касающиеся редактирования текста, то сейчас в разработке есть такая спецификация, как input events, которая позволит многие вопросы решить. Она вводит для editable областей такие события, как input и before input. И у них будет подробное описание, что же вообще происходит. Например, что происходит? Insert, там, вставка текста или замена определённого текста, например, при помощи автокоррекции или удаление, форматирование. Также дополнительные свойства будут позволять понять, допустим, если это форматирование, то какое именно форматирование применяется? Можно будет получить контент, который меняется в режиме там playтекста или HTL. В общем, это гораздо более богатый IP, который позволит редакторе сделать по-нормальному. Более того, что самое интересное, даже в комментариях к этой спецификации а пишется, что всё равно это ещё не идеальное решение и что можно сделать ещё лучше. Поэтому приглашается всех разработчиков поучаствовать в этом процессе. Это я к тому, что разработка RichтекTдиторов такая достаточно нетривиальная штука. Итак, подвожу итоги. Используйте content editable. Сейчас это, наверное, наилучший инструмент для того, чтобы создавать редакторы. Отслеживаете события, меняете state и обновляете ваш редактор. Не храните данные в дом, но это касается, наверное, вообще любого приложения, только редактора. Как хранить данные? Определитесь сущностями, с которыми вы работаете. Продумайте структуру того самого стейта и напишите код, который будет его реализовывать, дерелизовывать в те форматы, которые вам нужно. Как быть с ЦСом? Редактор у вас живёт во внешней среде. Это не обязательно, но часто это так. Соответственно, вам нужно заранее подумать про изоляцию ваших стилей. Соответственно, ес либо кладите всё врейм, таким образом вы защитите его от внешнего мира, но тогда вам приходит придётся реализовать транспорт между айфреймами и внешней средой. Либо резейтите, ощущайте всё, что вам нужно. Это может быть не просто. Мы сейчас делаем так. Мы не кладём Wi-frame. Продумайте заранее модульную архитектуру IP, возможность написания подключения плагинов. Вот несколько примеров хороших примеров редакторов современных. Это Quill от Sales Force, который, в частности, использует Telegram для своих постов. Draft JS от Facebook, Trix от Basecamp, а Google Docs, iCloud Pages, есть ещё некоторые, но это вот, наверное, то, что сейчас так на острие. Пожалуй, это всё. Спасибо, что вы были. Так-то что-что. Да. А можно я пока вопрос задам? Ну, во-первых, небольшое дополнение. Я видел редактор, который на канвасе сделан. Это как раз редактор документов от mail.ru. Ага. Вот. И они даже очень долгое время сидели не без поддержки рейтина, потому что этот редактор ещё на ретину было сделать безумно тяжело. То есть он на самом деле был супербыстрый, но как только его переделали под ретину, там куча всяких проблем возникала и тому подобных. У. А, а вопрос у меня следующий. Сейчас многие отказываются от подхода, ну, ээ, старого вот везевик, который был с полным редактированием, потому что, ну, это как бы такое устаревший подход, на самом деле такой функционал не нужен многим, да, и упрощают и часто предлагают ээ контентчикам использовать, ну, визуальный редактор блоков каких-то, который перемещается, а для форматирования текста, ну, либо делают простой визивик, совсем примитив. в котором, ну, сложно что-то натворить. И его, в принципе, ну, за недельку такой можно написать, в принципе. Вот самыйсамый простой, примитивный. Вот. Ну, конечно, да, тут куча всяких проблем рассказывалась, да, и чтобы даже от них уйти, иногда заменяют на маркдаун или ещё что-нибудь. Вы не думали о таком? Просто это, ну, это реально очень тяжело такое и делать, и поддерживать. Тут, наверное, зависит от задачи. У нас просто ситуация такая, что мы работаем на рынке изданий, которым часто очень важно сильно адаптировать под себя фирменный стиль поста настроить, например, там условно, там вот у нас клиенты там типа там афиша, например, и так далее. А у них это там всё нарисовано, согласовано, подчиняется какому-то общему фирменной стилю даже не одного издания, а может быть целой группы изданий. И часто им недостаточно каких-то шаблонных компонентов. Хотя у нас в редакторе есть такая сущность, как снипеты. Это возможность, собственно, сохранить какие-то блоки, чтобы потом их вставлять. Вот так что бы ответы да, и нет. С одной стороны, мы сами стараемся поддерживаться, придерживаться такого подхода, что мы не позволяем менять больше, чем позволяет редактор. То есть, например, у нас там фиксированный набор цветов, который задаётся предварительно, фиксированный набор отступов, нельзя сделать девяносто шестой шрифт и так далее. С другой стороны, делать только блоками не всегда это настолько гибко, насколько требует среда. Вот в двух словах, наверное, так. Ну, просто обычно, если мы говорим об адаптивном дизайне и прочем, там как раз подход с блоками очень хорошо работает, потому что как бы там не не раскидали объекты, да, можно заранее всё всё продумать для блока, и он садаптируется всегда стопроцентно. А когда очень много кастомного, да, непонятно, где может что-то сорваться, вы с таким не сталкивались. Тут смотря, что понимать под блоком. В принципе, у нас в редакторе и так всё является блоками. То есть есть, например, блок параграф, он лежит в блоке колонка. Колонка лежит в блоке сетка. А если эта сетка, например, четырёхколоночная на десктопе, то на мобилке она выстраивается в одну там, а колбасу такую вертикальную. Ну то есть в принципе мы, наверное, примерно об одном и том же говорим, мне кажется. Ну просто у вас это всё в виде такого простого редактора сделано, ну который более-менее понятен. А мы просто себя позиционируем всё-таки, наверное, не как вот pageйбиilder, который позволяет из кусков там из блоков составить страницу, а именно как редактирование того, что вот называется post body. И там вот всё-таки такой блочный подход, он не всегда там иногда нужна тонкая настройка, типа выделить кусочек текста, к нему что-то применить там и так далее. Вот не хватало этих примеров, на самом деле в докладе, наверно. А у меня вопрос по поводу Андуриду, да? А в случае, если редактирует только один человек, то там всё просто. Снапшоты, хлобысть, хлобысть, всё просто. Если редактирую сразу несколько человек, тут уже снапшотами не обойтись просто. Это, наверное, вопрос к команде разработчиков Google Docs. У меня, честно говоря, нет на него ответа, потому что вы не реализуете. Они шлют на сервер тамарные изменения, там синхронизируют и выкатывают назад. Если есть конфликт, они его самым каким-то тупым способом решают. Ну там пере перетирают, то есть там ничего какого-то супер, ничего нету, но работает. У них действительно за счёт того, что всё очень быстро обрабатывается, прямо мгновенно, да, оно хорошо работает. И то же то же самое у них в оффлайне, да, даже если вы в оффлайне что-то редактируете, он тоже сохраняет эти томарные изменения, потом пытается их наложить. Если в разных частях документа всегда вообще никаких проблем нету, да, если в одной части, э, по-моему, если там создаётся какой-то прямо реально конфликт, он создаёт копию документа ещё одну на случае, чтобы там, насколько я помню, бывают ситуации, когда элемент контента лочится под одного из участников. Да, ну, я имею в виду именно с оффлайновым. По-моему, если потом в онлайн вернуться, он ещё копию документа создаст другой и напишет, что где-то конфликт. По-моему, я такое видео поведение, хотя очень редко такой сталкиваюсь обычно. очень классно отрабатывает. Ну да, я, собственно, читал и слышал, что они работают с дифами, но это вот как бы уже, наверное, к вопросу про децентрализованные приложения и синхронизацию изменений. Вот, да, как раз я про это, что это уже как былеel, когда вы решили все вот эти проблемы, тогда можно подумать о том. Следующий вопрос. А скажите, пожалуйста, как вы используете contentт editable, а для того, чтобы отслеживать поведение пользователя, то есть а он же находится где-то за пределами экрана, то есть его не видно. Как вот этот в нашем случае он находится на экране, то есть у нас, э, редактор - это реальный контент editable. Просто любое действие, которое в нём происходит, оно нами перехватывается и обрабатывается так, как нам нужно. А, тогда понятно. А может быть, тогда подскажете, как это делается в Google Доксе, потому что это уже, мне кажется, второй вопрос команде Google Docs. Настолько глубоко нет, трудно сказать. Ну в Google Docs там самое главное, им, самое трудное по большому счёту - это считать положение курсора. Да-дада. То есть они решают, они математически решают эту задачу. Дадада. Вот. Потому что всё остальное ерунда. Все события можно перехватить просто со страницы без проблем. Главное посчитать, куда ты ткнул, в какую бук, между какими буквами ты, грубо говоря, попал. Вот. Ну и, соответственно, отсюда уже, если ты это сделал, если ты это посчитал, там разные модели могут быть. Ты можешь взять тот же шрифт, сделать shadowди некий скрытый, да, поместить туда посимвольно начать добавлять вот то, что у клиентаби, ну, как бы видимо вбито и считать, соответственно, как бы э в каком где где твой курсорчик находится, где это нужно положить, да? Да. Где это нужно положить, дада. Вот. Ээ то есть ээ от меня вот я вопрос взялся задать. В принципе, как бы будет несколько вопросов, как от человека, который написал для нашей системы там ещё в 2005 году редактор, и он полноценно сейчас там сотни тысяч наших клиентов, в принципе, они его используют. Э-э, вот, э-э, первое, первый такой вопрос, что а не думали написать именно как не проводили ли спайк на тему вот сделать так, как сделали Google Talk, чтобы не иметь проблем мм с контентаable ээ вот тех, что они реально есть? Не, не, грубо говоря, чтобы не надо было вбивать кучу костылей ээ под разные браузеры, потому что костыли они до сих пор и остались. Да. Дада. Да. Вот. То есть не делали вот такой спайк. А вопрос понял. Значит, думали об этом, но причин две. Во-первых, продукт сам достаточно молодой где-то вот конкретно этой последней версии, где-то полтора года. Вот. И команда совсем небольшая именно разработческая. Мы как бы не осилим просто такую штуку, даже если бы захотели. Я Ну я вот редактор один написал, да. Ну, честь вам и хвала. Ээ, правда, до сих пор приходится вбивать вот эти дурацкие костыли. Следующий вопрос. В принципе, как бы вы вскольз упомянули, но на самом деле, насколько я понимаю, вам тоже приходится, что с с селектами костыли там есть под разные браузеры, правда, сейчас, слава богу, Е там, ну да, мы поддерживаем Е11+, поэтому у нас попроще, да. Вот, ээ, вот немножко не раскрыта тема с копипастом, на самом деле. Что вы делаете с тем контентом, который пастится, соответственно, с других ресурсов, предположим, ну, с других сайтов, там, с кучей, то есть, в принципе, грубо говоря, там всё равно жёсткие фильтры и Да, да, конечно. Ну, а как ещё? Да, то там потому что, допустим, там в том же самом Safari, да и не только, там иногда пролетает вообще человек выделяет абзац, но когда его вставляет, там пролетает огромный кусок HTML-кода с метатегами, там, с HTML иногда и так далее, и так далее. Я имею в виду с тегом HTML. То есть, по сути, прилетает маленькая веб-страница. Естественно, в таком виде это не вставишь. Мы, естественно, это санитайзим. Вставляем те вещи, которые нас для нас важны. Это, как правило, абзацы, ссылки. То есть вы вы не делаете полную вычистку, например, как тот же Google Doc? Полную нет, потому что, допустим, нам важно, чтобы у нас редакция там скопировала четыре абзаца со ссылками с другого сайта, вставила, чтобы они вставились в очищенном виде, но чтобы, например, ссылки сохранились, разбиние на абзац сохранились. Угу. Также мы хендлим ставку из ворда, например. А вопрос, а почему всё-таки отказались от метода изолирования через фреймы? А на том этапе, когда начинали делать, посчитали, что вот этот барьер между внешней страницей и тем, что внутри, будет не очень удобен. Ну то есть, в принципе, у меня, например, реально, ну тогда, когда я начал делать, там только вариант был и фреймгу, то есть дизайн mod и и фрейм вперёд. Да, мне пришлось, соответственно, сделать не так, как все редакторы были. У меня именно был идея там сделать визивик, сделать не как у всех. Поэтому у меня реально считаются размеры. нет никаких бордюров. То есть у меня на странице там редактируемый области, соответственно, туда просто ставится курсор и начинается редактирование. То есть ээ в принципе ийм считает сам себя размеры. Иногда, конечно, если человек там Enter там нажмёт, соответственно, будет его держать, это будет некая задержка, она будет видна, но таких синтетических случаев их не так много, на самом деле. С другой стороны, ИФрейм позволяет вообще не париться насчёт изоляции. Я понял. Ну, мы как бы на самом деле на тот момент решили, что всё-таки, наверное, больше в этом минусов, чем плюсов. Хотя есть один большой, очевидный плюс изоляции. А мы как бы сейчас по сути, наверное, дождёмся уже, когда Шедом у нас начнёт нормально поддерживаться. Ну, в принципе, да. То есть единственное как бы то, что у меня решалась задача ещё у нас люди могли в ЦМЭСе как бы полностью свои ЦСы писать, и поэтому там человек в принципе мог нафиг там Да, я понимаю, всё, что угодно сделать с редактором, то есть через там CSС. Вот. Ладно, спасибо большое за доклад, спасибо за полезные комментарии. Так вот, а у меня ещё маленький вопросик. Да. А правильно ли я вас понимаю, что когда у вас на весь экран, ну или на ту область, которую вы редактируете, открыт вот этот вот элемент с с параметром editable, вы перехватываете всё до того, как там что-то поменяется средствами браузерами, и вам реально удаётся вот прямо все события перехватить до А значит, могу сказать так, мы перехватываем практически всё, но некоторое мы как бы синкаем в обратную сторону. Например, когда человек просто там стрелками переставляет курсор налевонаправо, то мы и не перехватываем это и не не выставляем потом курсор. Мы делаем наоборот, мы как бы просто а когда нам нужно считать положение этого курсора, мы его считываем. То есть некоторые параметры мы храним в Томе пока что, но потихонечку от этого избавляемся. Просто некоторые достаточно сложно реализовать кроссбраузерные и так далее. Я тому, что вы, например, нажимаете какую-то кнопку, пишется буква, и, соответственно, вот этот момент вы отлавливаете до того, как она реально нарисуется. Передела конкретно с написанием букв. Нет, мы это делаем по событию, как правило, Kup, когда буква уже вставилась. То есть, по сути, вы её один раз нарисовали браузером, потом поменяли. А за счёт того, что повторно? Нет, мы её не отрисовываем. Ага. Так. М. А так всёбо время вышло. Не, я извини. Давайте просто сейчас всё закончим, вы подойдёте и спросите у докладчика. Ну давайте, да. Так вот. Всем большое спасибо, кто до последнего доклада досидел. Большое спасибо докладчику. Спасибо. на этом"
}