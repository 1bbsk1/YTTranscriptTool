{
  "video_id": "-k-fOdaaN4o",
  "channel": "HighLoadChannel",
  "title": "Быстрый старт iOS приложения на примере iOS Почты Mail.Ru / Николай Морев (Mail.Ru)",
  "views": 897,
  "duration": 3004,
  "published": "2017-04-22T14:47:49-07:00",
  "text": "это email client позволяющий работать с любыми почтовыми ящиками не только с теми которые заведены на mail.ru и мы существуем истории с 2012 года хотя история разработки приложения немного дольше и уходит корнями в приложении агент mail.ru практически все это время мы находимся в районе 30 позиций в рейтинге самых популярных бесплатных приложений в русском сторе и в районе 1 2 позиции в разделе производительность сегодня речь тоже пройдет провод производительность но не совсем про ту для международной аудитории мы делаем то же самое приложение немножко с другим дизайном под названием e-mail и наши пользователи иногда это замечают я сегодня буду говорить о нашем опыте работы по ускорению времени запуска приложения и чему он нас научил наши пользователи вообще в принципе постоянно нам указывают на какие-то проблемы с приложениями и говорят о том что для них действительно важно вот некоторые примеры отзывов об истории к тому же данные аналитики которые мы собираем также подтверждали наличие проблемы с временем запуска вот здесь мы видим что для большинства пользователей время запуска было порядка четырех секунд даже немножко больше поэтому в последнее время мы решили больше внимания уделить именно качество продукта они новой функциональности мы начали увеличивать покрытие тестами начали работать над уменьшением размера приложения на доп темизации скорости запуска над оптимизацией использования сетевых ресурсов кстати если вам интересна тема про сетевые ресурсы мой коллега даниил румянцев на недавнем недавней встрече coco hut сделал доклад про это к сожалению видео пока не выложены но если что можете подойти ко мне я помогу найти эту информацию сперва давайте посмотрим как же мы пришли к актуальность этой проблемы как так получилось что проблема со скоростью запуска стал у нас волновать возможно вы перечисленные факторы сможет сможете сопоставить со своим приложением и понять а вообще стоит ли этим заниматься ну самое первое это то что нашего приложения такой сценарий использования что пользователи запускает его по многу раз в течение дня и естественно при этом если приложение запускается медленно это всех раздражает вторая причина очевидный ответ на очень многие вопросы разработки так исторически сложилось проблему с производительностью я бы отнес к но кораблем которые называют техническим долгом эти проблемы накапливается постепенно по мере добавления новых на функциональности незаметно для всех а бывает и так что даже умышленно чтобы ускорить время разработки думаю всем знакомы такие ситуации по этой причине вряд ли имеет смысл заниматься оптимизации скорости запуска если у вас ваше приложение запускает не так часто ну и еще одна причина отсутствие постоянного контроля за производительностью процесс накопления технического долго как мы все знаем он естественен и приложение постоянно добавляется новый код способный повлиять на скорость запуска часть этого кода действительно необходимо выполнять процессе старта это такие вещи как настройка библиотеки логирования запуск библиотеки для отлова крышей и так далее а часть получается что добавляется в процесс запуска случайно то есть по недосмотру например мы в нашем приложении на старте так исторически сложилось что мы настроим внешний вид для всех экранов приложения даже если они непосредственно в самом начале не показываются ну и все это осложняется тем что каждый раз время старта увеличивается на очень незначительную величину и это ухудшение невозможно заметить при ручном тестирование и даже если мы будем использовать специальные инструменты типа профайлер а мы не сможем мы можем не заметить это ухудшение потому что погрешность при изменениях профайлер будет больше чем сделанных учение вот такой график скорости запуска мы построили за последние несколько месяцев он именно как раз показывает эту проблему как постепенно по чуть-чуть скорость запуска все увеличивается и увеличивается с каждым новым коми там этот график это был один одним из результатов одним из результатов проделанной нами работы по улучшение скорости запуска и дальше я расскажу как и вы тоже можете построить такой график для своего приложения но сначала поговорим о том как построить сам процесс работы над улучшением скорости запуска всем известно что главное правило оптимизации позже временная оптимизация корень всех зол поэтому прежде чем начать нужно определиться с главными вопросами что именно мы оптимизируем как пользователи почувствовать эффект от нашей оптимизации как вы поймете привело изменение к поставленной цели или нет и вообще неплохо бы сперва убедиться в принципе возможно ли оптимизация и какое максимальное значение на который мы можем улучшить скорость запуска потому что скорость может зависеть не только от вашего кода но и от каких-то внешних факторов на которые вы не можете повлиять ну начнем отвечайте на эти вопросы что мы оптимизировали мы выбрали для оптимизации основной сценарий запуска наиболее частый это когда приложение выгружена из памяти пользователь до этого уже залогинен свою учетную запись и при запуске попадает в список писем в папке входящие вот примерно так это выглядит далее эффект который должны почувствовать пользователя в результате всех оптимизации пользователя пользователя должно попасть ощущения тормозов на старте чтобы этого добиться мы заходим с двух сторон мы конечно пытаемся уменьшить само время но кроме этого мы и пытаемся улучшить субъективное восприятие времени старта здесь я буду говорить только технической части как мы улучшали время но в моей статье на которые ссылку я дам позже вы можете и найти несколько приемов они субъективного восприятия далее как измерять что оптимизация дала эффект ну в процессе работы над оптимизации процессе когда мы пытались найти места которые нужно оптимизировать ну и конечно же использовали так профайлер для оценки общего эффекта от сделанного изменения мы использовали логе встроены в приложении почему мы не использовали тайн профайлер потому что ну если вы в приложении какую-то маленькую часть вырезали там за оптимизировали умирали какой-то код далеко не факт что это повлияет на общее время старта ну и естественно чтобы измерение были максимально полезными мы все измерения производят на самым медленным устройстве которые у нас есть и ни в коем случае не на симуляторе и ответ на последний вопрос а какой в принципе пределов оптимизации возможен мы получили следующим образом мы создали простое тестовое приложение с минимальной функциональностью которая ну буквально шаблон single view applications к воде да и добавили туда экрана заголовком и список писем и несколько ячеек который имитирует список писем и на этом приложении мы измерили время которое ну ниже которого мы в принципе не сможем оптимизировать и мы поняли что в принципе порядка 2 секунд теоретические возможности для оптимизации у нас есть далее перейдем к оптимизации непосредственно начнем с первого этапа запуска первый этап это время которое проходит от нажатия на иконку приложения до передачи управления нашему собственному коду на самом деле на этом этапе очень много всего происходит и он вполне может занять ощутимое время плохая новость заключается в том что по первому этапу в и никаких почти никаких данных в профайле увидеть не сможете но хорошая новость в том что все таки есть некоторые возможности повлияет на это время на в dc в этом году был отличный доклад про первый этап на котором очень подробно рассматривалось что именно здесь происходит и давались рекомендации что мы можем сделать с этим что здесь происходит и и загружает исполняемый код приложения в память производят над ними необходимые манипуляции сдвиг указателей которые есть в нашем приложении выполняет привязка указателей к внешним дней отёкам выполняет проверку подписей всех исполняемых файлов и затем выполняются методы лоты статический конструкторы это самый первый код который именно уже наш к тайнику от операционной системы вот для примера я привел диаграмму как это выглядит в нашем приложении какая разбивка по различным этапам ну для своего приложения в то же самое те же самые данные можете получить с помощью переменной окружения de wilde и принц статистика в xq1 соответственно чтобы ускорить первый этап основная рекомендация уменьшить эти этапы как же это сделать это прямо я вырезал слайд из доклада на vdc который вкратце суммирует все рекомендации чтобы приложение работало быстрее вам просто нужно делать меньше вещей в приложении какие ещё рекомендации сокращаем количество динамических фреймворков которые вас приложения есть почему потому что они загружаются намного медленнее системных фреймворков загрузка системных динамических free навыков уже заранее оптимизированную в операционной системе и в качестве оптимального количества собственных динамических фреймворков приводятся число 5 ну в нашем приложении у нас всего один динамический framework и главным образом мы его добавили для того чтобы шарить год между различными extend шинами и чтобы сократить размер приложения чтобы этот год не дублировался но в принципе если если мы думали только в скорости запуска мы могли бы в принципе отказаться от динамических рынков кстати если вы используете свирт и то он добавляет сразу несколько собственных динамических framework of которые тоже считаются в этот этот лимит то есть получается что использование свифт добавляет определенные оверхед и на старте на этапы которые здесь отмечены как и basic sap binding алекс abs влияет количество символов объекте все в вашем приложении поэтому здесь основная рекомендация которая давалась в докладе это писать большие классы и писать большие методы или переходить на свяжет где все три создаются статические не нужно делать эти этапы или по-крайней мере они сокращаются естественно 0 уже существующего большого приложения это не очень полезная рекомендация потому что придется делать большой факторинг перед тестировать заново кучу кода да и вообще читаемость кода естественно снижается при этом поэтому даже для новых приложений я бы не рекомендовал такой способ оптимизации второй этап когда мы уже получили управление операционной системы здесь у нас уже больше простор для действий потому что мы можем свой код как-нибудь поменять и естественно для исследования здесь мы начали использовать тайн профайлер кстати хотел узнать как много здесь союз разработчиков можете поднять руку отлично видимо тут как раз собрались все ее с разработчики которые на этой конференции есть поэтому так мало людей так ну и не буду объяснять что такое than the fire time профайлер конечно очень крутое мощные инструменты он нам очень сильно помог но вот здесь я перечислю несколько проблем или недостатков которые он для нас решить не смог первые мы не нашли в приложении каких-то явных узких мест которые можно было бы просто выпилить и сразу бы все улучшилась это известная проблема разработки под названием равномерно медленный код и принципе оно является следствием правильного подхода к разработке когда мы сначала пытаемся сделать работающий хорошо читаемый код а потом уже думать об оптимизации и еще одной причиной такой проблемы могут быть сами особенности использованной платформы например вот здесь мы видим что накладные расходы на вызов методов от джипси уже занимают достаточно ощутимо и время вторая проблема тайн профайлер а в некоторых случаях мы путаем профайлер и можем увидеть вот такие вот тяжелые части дерево вызовов но проблема в том что по ним не всегда можно понять какой именно в юшки относятся определенный вызов какой именно части приложения и такое наблюдается в основном при ну когда мы анализируем layout или загрузку вьюшек esxi бав в кассе бах тоже может быть довольно сложной иерархии и не всегда понятно какая в юшка там медленно загружается следующая проблема провалы на графике использования сепию в идеале конечно же чтобы все очень быстро работала главный тренд должен быть постоянно загружен на сто процентов там постоянно должно что-то выполняться но на графике мы всегда видим провалы они могут быть небольшие или более крупные и time профайлер нам практически ничего не говорит о том из-за чего они возникают что при к ним приводит но основных причин здесь может быть 2 во-первых сама последовательность запуска может быть выстроена таким образом что происходит ожидание завершения какого-то действия которая задерживает остальные этапы запуска но в принципе она не для всего нужно ну например мы пытаемся открыть базы данных и только после этого продолжить иные действия да при том что какие-то из этих действий могут не зависеть от базы данных но еще одна проблема которая к этому может приводить к провалам это асинхронные операции ввода-вывода как очевидные когда мы работаем с файлами или когда сторонние библиотеки работают файлами так и менее очевидные так некоторые вызовы системные в ездока общаются системными процессами по экспрессии и в эти моменты тоже могут возникать такие провалы но примеры таких вызов эта работа с течение нам работа стать едием проверка запрос к permission of на доступ к фото или геолокации еще одна проблема time профайлер а про которую я уже упомянул ранее это то что в нем сложно понять общий эффект от оптимизации из-за того что разброс измерений может быть довольно большим вот это вот я делал измерения на одном и том же приложение без каких-либо изменений и мы видим что от запуска к запуску время варьируется очень сильно на что еще можно обратить внимание при поиске мест для оптимизации профайлер нам дает очень много полезной информации но психология наши устроено так что очень легко попасть на ложный след во время анализа мы склонны скорее больше внимания уделять тем местам которые ну не тем местам которые действительно занимают много времени и могут дать большой выигрыш а тем которые нам очень легко заметные понятны и которыми нам в принципе интересно заниматься например я в процессе поиска мест для оптимизации нашел такое место где обращение к пейс борт на этапе запуска занимали ну аж целых 20 миллисекунд я начинаю думать а как мне избавиться от этого всего может быть заменить возможно что-то другое там но по хорошему нужно посмотреть на проблему на уровень выше и понять для чего мы в принципе это делаем но в нашем случае это делалось в процессе отправки статистики о запуске приложения и в принципе мы можем эту отправку статистике просто перенести на немного более поздний этап и функционально от этого мало что поменяется ну естественно мы в первую очередь хотим сократить объем работы над главным трендом и на него в первую очередь обращаем внимание но фоновый трейдов тоже не стоит забывать и потому что возможности распараллеливания аппаратные не безграничны и в частности мы столкнулись с такой ситуацией когда одна из библиотек которые мы используем инициализируем на старте сразу же уходила фоновый трек и там как как какую-то работу выполняла и мы поначалу даже не смотрели что она там делает но потом решили просто ее отключить и посмотреть что будет и это дало довольно значительный эффект еще в тайм профайлер и в глаза бросается первую очередь то что большая часть времени расходуется на отрисовку юар и layout но ест рейсов не всегда понятно на что именно в его и это время расходуется потому что там присутствуют какие-то странные системные вызовы непонятные там серии рендер что-нибудь и эти вызовы в принципе могут относиться к чему угодно к любой отрисовки на экран но практика показывает что самая прожорливая в ей это отрисовка лейбл из-за того что их относительно сложно рассчитывать их размер и отрисовывать и любые картинки потому что их нужно читать с диска иди кодировать поэтому из всего вышесказанного следует вывод что если вы хотите сократить время запуска делаете все операции максимально ленивы что это значит не создавайте не настраивайте никакие экраны и вьюшки если они не будут не будут показаны сразу же после старта вообще пожалуй это самый действенный способ ускорить существующие большое приложение где нет явных был . ну например что мы и сделали ленивым своем приложении мы сделали ленивый загрузку картинок в процессе настройки внешнего вида для второстепенных экранов мы убрали промежуточный экран запуска мы убрали создание фоновых экранов которые находятся в боковом меню и много дорогого по мелочи принципе это правило относится не только к ю ай но и к любой логики к любому коду если какой-то менеджер или действия нужно инициализировать на старте приложения подумайте они взяли его отложить на момент появления основного пользовательского интерфейса возможно с точки зрения функциональности не будет никакой разницы ну и пару слов такой спорной теме как создание юрьев интерфейс билдере или в коде как ни странно пасе бы обычно не является проблемой создание аналога аналогичного ей в коде выполняется совсем не значительно быстрее а бывают случаи когда даже медленнее вот здесь приведена ссылка на довольно старую запись в блоге где это сравнение проводилась вы можете при желании скачать там тестовый проект правда потребуется приложить определенные усилия чтобы его перетащить на последнюю версию xcode и потому что это писалось в 2010 году и вы можете сами посмотреть а что выполняется медленнее что быстрее вот вывод принципе чтение и запись на флеш-память на современных устройствах происходит очень быстро это единицы или десятки миллисекунд поэтому не всегда стоит над этим заморачиваться но бывает так что ваш или сторонней код злоупотребляет этим и открывается слишком много файл на запуске например мы обнаружили такую проблему с фреймворком аналитики флоре и с нашим собственным кодом где мы за рожаем картинки для настройки внешнего вида приложения time профайлер вам не покажут такие места в темпл файле вы в лучшем случае вы видите небольшие провалы на графике сепию но вместо этого вы можете использовать и другой инструмент а ее activity который вводит список всех операций ввода-вывода и имена соответствующих файлов по именам потом довольно легко восстановить какая часть приложения этот файл читает ну аналогичную информацию можно получить и не только инструмента мои activity но и простым breakpoint там на функции опыт случае с системными парами орками и экспрессе о котором я говорил раньше можно отследить обращаю внимание на провал и на графике secu и смотря на в профайле открываете with holes in плз где список всех спектра рейсов и смотрите какие вызовы предшествовали провалу так вы можете понять какой вызов приводит к этой задержки когда time профайлер не дает достаточное количество информации раньше приводил пример своя у там и в таких случаях вы более подробную информацию можете получить с помощью свезли нга методов а я отобью со всех классах ну что такое svetlanka пояснять не буду наверно и объекте все нам это довольно легко позволяет делать за свезли на и методы его яйца views мы просто вставляем логирование сколько времени занял этот вызов и выводим в консоль еще указатель на объект над которым я вот производился после этого мы все это копируем вставляем в табличку в вы лжецы и можем анализировать если после такого logo мы не завершаем приложение выходим в отладчик ставим на паузу мы можем показателем примерно понять какие вьюшки дольше всех воя учились способы поиска оптимизации которые я выше описал имеют большой недостаток они не позволяют уверенно ответить на вопрос привело ли привела привело ли небольшое изменение к улучшению в целом потому что последовательность запуска в большом приложение может быть довольно сложный это переплетение разных call back of на разных потоках и так далее и то что вы в одном месте где-то что-то убрали это может либо перенестись на более поздний этап загрузки либо вообще не даст никакого улучшения потому что это за этот момент заменятся просто ожиданием выполнение каких-то действий но и особенно ярко эта проблема проявляется когда исправление улучшений дает довольно небольшой выигрыш поэтому мы приходим к необходимости автоматизировать запуск измерения времени стартом и выполнять большое количество замеров чтобы по какому-то медиальному времени более точно сказать но нивелировать ошибку измерений конечно же использовать time профайлер для этого не вариант так как его сложно оптим автоматизировать да и такой большой объем информации которую она выдает в принципе не нужен для этой задачи поэтому в самом приложении мы добавили отладочные логе которые вводят в консоль и в отдельный файлик время различных этапов запуска вот примерно так эти логе выглядят мы здесь выбрали некоторые ключевые точки критического пути запуска приложения и в этих точках мы вводим абсолютное время вот начала запуска и время с предыдущего это то мы использовали такие логин не только впоследствии для автоматизации замеров но и в ходе поиска места для оптимизации в дополнение к тайн профайлер а потому что иногда бывает полезно просто получить представление о том какое время занимает более крупные этапы выполнения приложения так мы можем понять какому этапу нужно уделить больше времени в тайм профайлер и и по таким логом можно даже строить вот такие вот красивые диаграмм ки в google sheets которые наглядно все показывают например вот эта диаграмма показывает как или распределилась время различных этапов после одного сделанного изменения то есть без таких измерений вы могли бы подумать что вы сделали какое-то улучшение на самом деле оказалось что время просто перерос поделилась ну или вот такие вот диаграммы которые показывают последовательность различных этапов в приложения и по ним можно подумать а какие места мы можем распараллелить где у нас не нужные зависимости между этапами запуска и так далее поговорим об оптимизации в сообщество разработчиков очень много говорится о continues on the grey шанти диди и других полезных практиках непрерывного контроля за качеством приложения но почему-то очень много мало информации о том как контролировать именно производительность вот мы попытались восполнить этот пробел и одним из главных достижений проделанной работы мы считаем систему которая позволяет нам непрерывно контролировать время запуска в ходе разработки имея такую схему мы решаем основную проблему которая и привела к необходимости заниматься этим вот с помощью такого графика мы теперь можем чётко видеть насколько то или иное изменение повлияло на скорость запуска и можем принять необходимые меры виде эти сигналы теперь время фидбэка сократилась очень сильно если раньше мы получали обратную связь от пользователей что что-то медленно работает то сейчас мы это очень наглядно видим ну и естественно вот использование такой системы также как и многие другие полезные практики в разработке польза такого подхода начинает быть видно только по мере эволюции приложения в самом начале вам может быть непонятно зачем это нужно расскажу как это технически реализовано вкратце на каждый камень запускается задач на дженкинс она собирает приложение в релизной конфигурации с включенными профайлинга вы и налогами и автоматическим завершением приложения на последнем этапе когда мы считаем что приложение полностью запустилась это сборка запускается двести семьдесят раз на специально выделенном под эту задачу устройства на данный момент у нас это iphone 5s на ios 9 и вас наверное возникнуть вопрос откуда взялось это число 270 ну очевидно что для уменьшения погрешности это число должно стремиться к бесконечности но тогда каждый балаган будет занимать бесконечное время поэтому мы сделали 10000 замеров и посчитали необходимое количество запусков по формуле определение объема выборки для нормального распределения с ошибкой около 10 миллисекунд из за этого у нас на графике там все немножко как скачут из стороны в сторону кстати если мы вернемся графику мы можем увидеть момент когда мы переключились с 10 замеров на 270 замерам можете сказать где он что да это ступенька вот эта нижняя линия показывает минимальное время запуска из всех запусков соответственно когда мы увеличили количество минимальное стало меньше и далее когда мы сделали это 270 запусков мы обрабатываем данные по всем запуском рассчитываем их статистические характеристики и затем сохраняем их в influx тебе и затем по ним строится график в графа конкретные примеры скриптов как это все делается вы можете потом посмотреть мои статьи там на самом деле ничего сложного тамбовской ты буквально из 10 строк и расскажу здесь только основные моменты какие инструменты мы для этого использовали как вы все знаете о ios это закрытая система поэтому для автоматизации таких задач как автоматическая установка автозапуск получение результатов работы с устройство есть на самом деле два варианта мыли бы можем использовать мы можем работать недокументированных юсб порта колам который сама apple использует в своих приложениях либо мы можем просто поставить джейлбрейк и как белые люди ходить на устройство пояс с вич и запускать приложения выполнение одной команды мы конечно же остановились на последнем варианте потому что намного проще и надежнее гибче нам не нужно привязывать тестовый телефон к конкретному слыву подключать по юсб телефон просто лежит на столе одного из разработчиков и с любого из своего в дженкинс мы можем запускать на нем измерения ну или если разработчику потребуется что-то запустить он просто берёт и запускает подводные камни такого подхода которые выявились после некоторого времени эксплуатации да теперь мы можем видеть что на каком-то этапе разработки скорость запуска увеличилось но к сожалению не всегда момента скачка совпадает именно с тем коми там где ухудшение произошло это происходит из погрешностей измерений и из-за различных внешних факторов на устройстве в этот момент могла могло выполняться какое-то какой-то системный процесс или еще что-нибудь что мы пока не знаем даже если мы определили к митр которым произошло ухудшение то чтобы его исправить это не так просто все равно приходится проделывать какую-то исследовательскую работу в профайле ри проводить эксперименты сравнения и анализировать код конечно хотелось бы иметь какую-то методику позволяющую без особых усилий увидеть в каких именно местах изменилось поведение в ран тайме приемлете коммита что-то вроде гибрида time профайлер и div но нам пока такой инструмент к сожалению не известен и бывает и так что производительность ухудшается из обновления какой-нибудь сторонние библиотеки и здесь мы уже мало что можем сделать при числе сталь основные выводы которым мы пришли по итогам всей проделанной работы и которые я попытался донести своем докладе мы должны замечать проблема первыми до того как это сделают пользователи все аспекты оптимизации необходимо формализовать перед тем как мы начинаем работать иначе мы можем оптимизировать не то что на самом деле нужно оптимизировать или думать что мы что-то улучшили хотя на самом деле улучшение не произошло time профайлер очень крутая вещь но не всегда его достаточно и нужно использовать и другие инструменты как поставляемый план так и самописные типа связали нголо я отобьюсь ну и естественно контроль за производительностью приложения должен стать частью процесса continues on the creation заключения расскажу вам о результатах проделанной работы с продуктовой точки зрения не с точки зрения разработчика сейчас будет видео готовьтесь вот запуск приложения до и после изменений видео замедлено в 2 раза для наглядности и мы видим что стало лучше хотя и незначительно но лучше еще раз сложно на самом деле посчитать цифра ускорения которые мы достигли по итогам всех работ так как работа растянулись на продолжительный срок параллельно вливались другие не связанные с этим задачи и к тому же методика измерения вырабатывалось по мере того как мы это все делали поэтому исходных цифр нет но приблизительно и сравнение до и после показывает что примерно на 30 процентов нам удалось сократить время запуска есть еще вот такая красивая статистика от наших аналитиков которая показывает что количество пользователей у которых запуска произошел менее чем за две секунды увеличилось в десять раз за это время может показаться не совсем очевидным как это увеличилась 10 раз если вы улучшили всего на треть но если мы посчитаем среднее взвешенное среднее по всем группам пользователей то тоже получится примерно улучшение на 40 процентов что совпадает с данными time профайлер но и самые важные показатели для мобильных разработчиков retain шин и удовлетворенность пользователей тоже немного улучшились вот показатель тэн шона и негативные отзывы в истории хотя и сложно делать выводы из таких незначительных колебаний но нам кажется что работу по ускорению тоже внесла вклад все о чем я не успел рассказать о сегодняшнем докладе вы можете посмотреть мои статьи на эту тему спасибо за внимание если есть вопросы буду рад на них ответить добрый день спасибо за доклад вы сказали что кроме технических доработок есть еще некие визуальные или такие субъективные моменты можете в двух словах еще один и сказать ну его видно прямо вот на этом видео которое я показывал если раньше мы отображали заставку с логотипом mail.ru на старте то сейчас мы показываем некие очертания пользовательского интерфейса и за счет этого кажется что все запускается немного быстрее этот такой основной момент ну возможно но это не вся здравствуй а спасибо за доклад а вот вы говорите что у вас не существует или вы не знаете методику по связыванию вот где вот этот график красивый на черном фоне из grafana был папа связыванию изменений в скорости запуска и каких-то комментов в коде а вообще вы используете немножко из сторон не вопрос используете ли вы какие-то статические анализаторы и например там только такие вещи как sonar кьюб как агрегаторы статических метрик года по наши мне кажется это как раз тот инструмент который если вот эту штуку к нему как-то в виде плагина привязать вот эти данные то можно было бы напрямую связывать с изменениями в коде спасибо за вопрос очень интересный ну и статического анализа мы только прогоняем по стандартный статический анализатор на каждую итерацию вот про этот инструмент по которой вы говорили я не слышал раньше спасибо посмотрю на него спасибо за доклад хотел узнать вот стоимость вот этой оптимизации всегда важна стоимость разработки да сколько это заняло человеческих ресурсов и собственно непонятно вот числовой показатель то есть насколько но насколько вы сказали 30 процентов а вот для пользоваться только пользователь стал ждать загрузки ну примерно понял вопрос но с точки зрения человеческих ресурсов это заняло примерно два месяца у полутора разработчиков вот так вот так и насчет второго вопроса ну вот данные аналитики они очень нехорошо это все показывают вот эти вот тут видно как изменилось количество пользователей у которых скорость зап но запуск приложения занимает то или иное время то есть сейчас большинства пользователей это менее чем за две секунды происходит спасибо за доклад я хотела спросить просто такой интересный вопрос вы говорите что запускайте 270 1 тест и это запускается на каждый коммент а сколько по времени занимает примерно все это тестирование это действительно запусков но один запуск вместе с накладными расходами на забор данных занимает примерно 45 секунд соответственно вы можете умножить 5 секунд на 270 по-моему там что только вот полчаса получается просто в очереди копится или у вас есть несколько давай saw которая параллельна у нас сим несколько слоев которые используются в основном для прогона тестов и да иногда возникает очередь ну вот так спасибо вопросы есть тогда в принципе можем заканчивать всем спасибо"
}