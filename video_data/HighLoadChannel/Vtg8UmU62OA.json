{
  "video_id": "Vtg8UmU62OA",
  "channel": "HighLoadChannel",
  "title": "Из pytest в Go. Тестовое окружение на фикстурах / Тимофей Кулин (Яндекс, YDB)",
  "views": 137,
  "duration": 2446,
  "published": "2024-10-29T02:48:12-07:00",
  "text": "сейчас я приглашаю на сцену Тимофея для того чтобы рассказать нам про тестирование и тестовое окружение Привет Меня зовут Тимофей кулин в Яндексе Я работаю с 2018 года последние несколько лет работаю в команде занимаюсь клиентскими библиотеками сегодня расскажу про свою личную разработку пару лет мне пришлось программировать на питоне в частности имел дело с тестами с библиотекой тест И там мне очень понравилась концепция фикр когда собственно Ты просто получаешь то что тебе нужно и тест остаётся чистым лаконичным Итак о чём я сегодня буду говорить я буду говорить о объёме служебного кода о соотношении служебного кода и полезного кода то есть того кода который несёт смысл при его чтении я буду говорить о принятых решениях И в частности о том как библиотека используется как это выглядит в конце о ЧМ я не буду говорить я не буду говорить овни то есть есть разные подходы в создани тестовых окружений например там на тест ситах там другие библиотеки Каждый выбирает тот способ который ему нравится и сегодня мы не будем их особо сравнивать я не буду говорить о производительности кода потому что производительность самого фреймворка для подготовки окружения обычно не важна и я не буду говорить о методиках тестирования То есть если вы хотели услышать что-нибудь из этого то можете пойти выбрать какой-то другой доклад Итак давайте посмотрим на простой тест этот тест не несёт большого смысла он сделан так специально для того чтобы показывать общую идею и не отвлекаться на смысл тестируемого кода Что делает этот тест сначала подготавливается тестовое окружение это временная папка затем мы проверяем наш смысловой код это создание файла проверяем файл создался успешно или неуспешно и собственно в этом тест заключается Вот полезная часть теста то где мы проверяем создание файла остальной код служебный возьмём похожий тест с созданием папки У нас есть тоже самое тестовое окружение то есть временная Папочка в которой мы работаем итем уже сам полезный код теста Обратите внимание что примерно половину объёма теста занимает служебный код вот он и в идеале хотелось бы сделать его минимальным или избавиться совсем Итак я уже упоминал что мне понравилась библиотека тест и Давайте посмотрим как тоже самое делается вте Вот те же самые два теста на один экран и осталось свободное место как это получается получается это за счёт фикр Обратите внимание что в качестве аргумента для теста указан параметр фолдер рядом объявляется функция фолдер и она будет служить фикстуры библиотека составля фик смет по их и перед выполнением теста выполняет код фикстуры получает оттуда значение подставляет в тест в качестве значения аргумента После выполнения теста выполняет оставшуюся часть фикстуры после yd которая собственно выполняет очистку теста и получается что внутри самого теста у нас Остаётся только смысловой код ни кода подготовки окружения ни кода его очистки читать такой тест намного быстрее намного проще и понятнее Итак что же такое фикстуры и что они дают во-первых мы пишем меньше кода в коде теста то есть потом при чтении этого кода нам приходится меньше читать у нас больший контекст получается в памяти и проще понимать то что написано заранее готовое известное тестовое окружение и пользуемся Им просто как готовым То есть если нам нужна временная папка мы говорим Дай нам папку и работаем с ней как с чем-то Ну как с данность нам не нужно думать о том как её создать и о том как её потом Удалить собственно В этом заключается е одна Рона что фикстуры могут под окружение забо создали какие-то ресурсы фикстуры как могут выглядеть фикстуры в го Я разработал библиотеку фн о которой сегодня и буду говорить и на ней буду показывать примеры она реализует подход с фик в Go Итак вот тот же самый тест на создание файла с фикстуры Обратите внимание на объём служебного кода две строчки даже меньше всё остальное - это полезная нагрузка и похожий тест с похожим окружением используется та же самая фистулу кода чуть меньше двух строк всё остальное - это полезная нагрузка А здесь можно наглядно посмотреть объём теста в том случае Когда мы готовим окружение внутри теста и когда используем фикстуры в данном случае он отличается примерно вдвое объём служебного кода объём служебного кода Итак теперь Давайте посмотрим Ну на пример самой фикстуры Здесь представлен код фикстуры фолдер которая сначала создаёт временную папку и потом её удаляет код по очистке окружения то есть по удалению временной папки включен уже в саму фикстуры дальше библиотека работает следующим образом Когда будет вызвана Фира Е код код запустится ровно один раз и после завершения теста вызове код очистки об этом в самом тесте тоже думать не нужно то есть тест не знает ничего о том как подготавливать окружение как его за собой очищать и нужно ли это делать вообще всё вынесено наружу Итак Ну мы посмотрели какие-то простые примеры э на них можно показать что такое фикстуры в принципе теперь Давайте посмотрим Ну пример поинтереснее здесь происходит тестирование перевода денег с одного счёта на другой этот код выложен в гитхабе он рабочий его можно посмотреть потестить погонять Итак здесь у нас есть три фикстуры фикстуры accs и фикстуры ID первое подготавливает базу данных и создаёт объект репозитория метод которого мы потом вызываем две вторые фикстуры создают два разных счёта с помощью которых и происходят операции Итак что же здесь происходит для начала запускается доке контейнер с базой данных после этого там создаётся таблица accs она заполняется создаются счета Боб создаются счета Алис после этого вызывается метод который мы Тестируем и собственно выполняется код теста а потом могут выполняться другие тесты здесь есть два типа фикстуры фикр с созданием счетов работают только внутри теста то есть счета будут удалены После выполнения этого теста а ACC она создаёт нечто более глобальное что хочется переиспользовать между разными тестами для того чтобы не тратить время на инициализацию каждый раз и таблица accs и доке контейнер будут удалены только после того как выполнятся все тесты в модуле позволяет экономить время особенно когда тесты запускаются часто например ну при отладке на машине разработчика А и можно обратить внимание что опять же здесь большая часть кода она полезная а служебный код есть одна строка для подготовки а а сами вызовы фикр они интегрированы в код теста и являются не только служебным кодом но и его осмысленной частью то есть в любом случае нам как-то нужно было бы получить номер одного счёта номер второго счёта и получить репозиторий чем собственно фикстуры и занимаются не занимая дополнительного места а я вам показал как можно использовать фикстуры и теперь Давайте опустимся немножко вглубь Яка покажу как фикстуры э сделаны изнутри э как они создавались и какие решения принимались по ходу реализации Итак М допустим в самом начале э когда я подумал что классно было бы иметь фикстуры в Go возник первый вопрос А как их использовать например весь код уже написан а всё работает м но применять как первой мыслью было пойти По стопам пате и сопоставлять фикстуры с аргументами по именам параметров но к сожалению го не предоставляет такой возможности то есть ну это возможно с кода генерации это как усложнит разработку так и потом повысит вход на использование библиотеки потому что каждый раз код нужно будет генерировать при изменении тестов был вариант использовать специальную структуру то есть мы можем создать структуру натравить на неё какую-то функцию функция через reflection поймёт имена полей найдёт заранее зарегистрированные функции и таким образом сможет сопоставить одно с другим вызвать функции Здесь тоже есть проблема Проблема следующего рода она уже не совсем Техническая она уже в вопросах удобство когда мы пользуемся фикстуры вте то это уже популярная библиотека широко распространённая её поддержка есть в средах разработки То есть можно просто щёлкнуть по имени параметра и среда разработки перекинется вас на код фикстуры очевидно что для новой библиотеки никакой поддержки в средах разработки нет и поэтому вариант работы через поля структуре Нарек он был под такой некой магией то есть структура как-то заполняется Но что именно при этом происходит Какой код вызывается непонятно а и в конце э Я пришёл к решению сделать фикстуры простым вызовом функции А вызов функции достаточно прост Э он не несёт в себе никакой сложности для понимания и позволяет А без дополнительной поддержки э со стороны сред разработки понимать что за функция вызывается То есть можно опять же по функции кликнуть и посмотреть какой код будет работать а следующим вопросом был было разделение обязанностей то есть что нужно оставить снаружи в библиотеке А что внести внутрь фикр чтобы это определял разработчик А здесь тоже есть масса вариантов например работа с кэшем можно предоставить некий интерфейс как работать с фурами Ну допустим кэширование повторное использование результатов будет уже в области ответственности разработчика фикстуры и например обработка зависимости в каком порядке эти фикстуры вызывать вопросы синхронизации Например если фикстуры будет вызвана несколько раз параллельно то кто должен обеспечивать гарантии того что код будет работать правильно код по созданию объектов код по его очистке А естественно для удобства использования хочется максимум всего оставить в библиотеке А на программиста оставить самый минимум то есть чтобы программист при своей работе писал только то что ему нужно и поэтому практически ВС что можно вынести оно вынесено библиотека не может знать как создавать объект и не может знать как его чистить всё остальное можно сделать один раз в общем коде что собственно и было сделано следующим вопросом стал вопрос хранения состояния уе свойство результат ВС время один и тот же То есть можно внутри одного теста вызвать ту фикстуры фолдер который упоминалась два раза три раза четыре раза и внутри одного теста это будет всё время одна и та же Папочка Но если вызвать эту фикстуры из разных тестов то папочки уже могут отличаться при этом бывают фикстуры с тяжёлыми зависимостями Например если нужно создать базу данных в Облаке или запустить виртуальную машину такие фикстуры хотелось бы кэшировать результат выполнения между тестами чтобы виртуальную машину создать один раз и переиспользовать её во всех тестах для того чтобы сделать такую штуку нужно как-то шарить состояние между тестами и собственно здесь конкурирует два подхода подход первый это локальные переменные То есть я внутри теста объявляю переменную туда что-то записываю и в ней храню состояние это удобно с точки зрения разработки фикр Точнее с точки зрения разработки библиотеки Фин но не позволяет шарить состояние между разными тестами есть второй подход использовать глобальное состояние и глобальный кэш в этом случае передавать полученные на предыдущих тестах значения между тестами Ну достаточно просто Однако тут возникают сложность разработки самой библиотеки когда мы используем глобальное состояние то у нас в тестах одни тесты начинают влиять на другие тесты и они получаются неизолированные писать такие тесты неудобно следить за глобальным состоянием сложно и поэтому я решил эти два подхода объединить и взять лучшее из каждого при инициализации тестового окружения создаётся локальная структура Вы видели в коде она возвращается через метод внутри этой структуры есть указатель на глобальное состояние при этом глобальное состояние само по себе в виде этой глобальной переменно ни в коде используется оперирует только указателем внутри структуры ФТ что это позволяет с одной стороны мы можем использовать глобальное состояние и передавать его между тестами переиспользовать результаты тестов а с другой стороны при разработке самой библиотеки Это позволяет внутри каждого теста создать своё состояние своё окружение и использовать его без влияния одного теста на другие А дальше как создать собственно т а здесь м так сейчас секунду а при создании ФТ хотелось достичь нескольких целей во-первых объём служебного кода должен быть минимальным в самом идеале отсутствовать вообще во-вторых хотелось сохраниться вместимость со стандартной библиотекой чтобы не нужно было отказываться от привычного и нативного подхода в простых тестах сохранить совместимость со сторонними библиотеками вроде мов Test и так далее которые уже могут использоваться которые удобны и хочется продолжить иметь возможность продолжать их использование и при этом пользоваться фикстуры для создания самого окружения в результате пришла мысль что тестовое окружение состояние будет создаваться вызовом одной функции и эта функция будет принимать под интерфейс от тестинг для контекста стинт - это интерфейс объявленный стада библиотеке и он содержит общую часть между методами тестов и бенчмарком А когда мы принимаем под интерфейс то есть только небольшую часть этого интерфейса а получается что э в качестве вот этого окружения можно передавать не только стандартный тестинг Т или тестинг B но можно передавать и объекты созданные другими библиотеками для тестирования которые например могут иметь более удобное логирование или Ну другие дополнительные функции Чуть позже я покажу из чего этот интерфейс состоит а следующая задача - это различие экземпляров фикстуры между собой есть задача различать два запуска одной фикстуры внутри одного теста в разных тестах могут быть запущены разные фикстуры и как-то нужно их определять для того чтобы понимать то ли выполнить этот код то ли взять готовое значение из кэша и если брать значение из кэша то какое А в результате для того чтобы идентифицировать фикстуры используется некая структура которая содержит в себе во-первых скоп в течение которого действует кэш фикстуры скоп может быть либо в пределах одного теста то есть после теста у фикстуры вызывается код очистки её значение потеряется из кэша либо пакет То есть первый раз при вызове фикстуры будет произведена инициализация будет вызван её код дальше результат сохраняется и дальше переиспользование теста из которого фикстуры была вызвана а дальше используется имя функции оно берётся из стека вызовов и имя файла в котором функция находится тоже берётся из стека вызовов функция па позволяет реализовать фикстуры с параметрами такая фистула например при переводе при тестировании перевода денег с одного сч на другой Когда нам нужно создать Жих объекта но сами объекты должны быть разные при этом фикстуры сохраняют за собой то свойство что если её вызывать несколько раз с одними и теми же параметрами то результат выполнения будет всегда один и тот же это гарантируется библиотекой И для этого используется как раз свойство params и единственное требование к параметром фикстуры то что их должно быть возможность реализовать этому требованию удовлетворяют как стандартные типы Ну примитивные так и большинство структур дальше встал вопрос с параллельным выполнением фикстуры у параллельности здесь есть два типа первый тип - это параллельный вызов из разных тестов То есть вы можете воспользоваться несколько тестов запустится одновременно и будут дёргать одни и те же фикстуры но здесь в целом всё достаточно просто у фикстуры будут разные ключи и они будут различаться в случае если это тесты Ну если фикстуры локальные для теста а Если дёргается параллельно несколько фикстуры со скопом пакета или дёргаются локальные фикстуры но несколько раз внутри одного теста а то Библиотека должна гарантировать что код фикстуры будет вызван один раз и все вызывающие получат одно и то же значение и собственно здесь используется такая двухуровневая Синхронизация во-первых это Ну обычный юкс для доступа к словарику и во-вторых для каждого значения ключа той структур которая была на предыдущем слайде есть отдельная синхронизация через S именно она гарантирует что фикстуры конкретная будет вызвана ровно один раз а Следующий вопрос - Это очистка глобального состояния А мы сделали фикстуры она запускает тяжёлую виртуальную машину всё переиспользовать быстро когда её удалять а нужно отловить момент выхода из всех тестов и с этим помогает функция это тоже стандартная Ну стандартный интерфейс для тестирования функции и здесь достаточно вызвать один пер из F он сам инициализирует глобальное состояние и сам запустится в тот момент когда все тесты будут завершены и внутри фикстуры об этом думать не нужно фикстуры что для глобального кэша что для локального выглядят одинаково А и собственно реализовано это через создание виртуального теста то есть тот хел под капотом создаёт виртуальный тест и этот виртуальный тест реализует как раз тот под интерфейс который нужен для создания окружения это вот как одна из тех особенностей которые позволяют в дальнейшем использовать фикстуры с сторонними библиотеками а нужно реализовать несколько методов которые уже объявлены в стандартных тестах И после этого виртуальный тест может быть использован эта же техника применяется и внутри а НВА для того чтобы глобальное каширование локальное каширование внутри самих фикстуры выглядело одинаково и не нужно было об этом задумываться а в ходе уже использования библиотеки Я заметил что время от времени повторяются ошибки которые похожи друг на друга и начал встраивать в библиотеку защиту от тех ошибок которые можно определить автоматически например при копировании кода достаточно просто два раза вызвать создание окружения внутри одного теста или Ну и от этого Собственно уже есть защита есть Ну другие ошибки которые могут возникать с использованием фикстуры И постепенно они тоже встраиваются вторая по популярности в моих проектах ошибка это очень легко забыть проинициализировать Вот то глобальное состояние из чтобы происходила очистка тяжелых фикстуры после завершения всех тестов и эта ошибка тоже сейчас определяется автоматически Дальше можно встраивать Другие диагностики например фикстуры с бесконечной рекурсией или использование фикстуры с неправильными скопами одна внутри другой это в планах на будущее технически релизу дошли Итак а призываю вас использовать фикстуры делать свой код тестов проще понятней голосуйте за доклад и задавайте вопросы Я готов на них отвечать супер спасибо большое за доклад Есть ли вопросы Если есть вопросы Пожалуйста поднимайте руку к вам подойдут с микрофоном для того чтобы Вы могли их задать также не забывайте что можно задать вопросы в чат их зачитаю и тоже на них мот получить ответ теперь вопрос да Здравствуйте Василий Романов ВК Я правильно понял что основной смысл вот разработки этой библиотеки - это оптимизация тех тяжёлых как раз операции с поднятием контейнеров инициализации базы таблиц вот то что было как раз показано в примере с аккаунтами основных левом щение кода теста чтобы в НМ осталась только смысловая часть и вторая цель Да это переиспользование тяжелых конструкций чтобы сэкономить время на тестовых прогона спасибо супер спасибо Как вы видите я теперь стою с блокноти потому что доверять мое памяти по вопросам нельзя вопрос в первом ряду Спасибо большое за интересный доклад вопрос в следующем Можно ли из фикр использовать фикстуры наме меня фикстуры по инициализации базы которая собственно говоря там реквизитам собственно поднятия инстанса базы чтобы это всё не расписывать в тестах а внутри самих фикстуры да Отличный вопрос Это можно делать и как раз вот в тестовом примере на который есть ссылка вот H 2003 там это используется например в фикстуры accs используется фикстуры для подключения к базе данных wb фикстуры для подключения к базе использует у себя фикстуры для поднятия докер контейнера это всё правильно работает в цепочке и потом правильно очищается в обратном порядке супер спасибо вопрос из первого ряда Алексей Мясников Яндекс собственно мы коллеги но о пакете я знал но вопрос возник сейчас вот из двух целей которые фикстуры Ну имеют в себе заложены да кажется что одну из целей решает стиф SU то есть вот поднять поднятие там тяжёлого окружения и очистка за собой а вторая часть - это вот ну собственно фикстуры вот эти вот методы как будто бы не решает пакет фй собственно вопрос не было ли мысли прийти с порек в проект testify и как-то там улучшить эту часть А спасибо за вопрос как я уже говорил в начале это то о чём я не буду говорить Есть разные методы к созданию тестовых окружений testify и тестс - это один из них я думаю что аналогичные решение Как можно было ещё поступить можно обсудить В дискуссионной зоне это не для сессии вопрос-ответ пожалуй вопрос Следующий вопрос да спасибо за доклад Вопрос такой ваш коллега вот только что сказал что он тоже слышал о вашем пакете А вы его уже как-то внедрили к себе там в команду может или пока просто домашняя разработка А да сейчас он сейчас финов используется у нас при тестировании wdb голы из ДК тогда мне просто интересно а как вот те кто гофер кто не сталкивался с фикстуры в питоне восприняли вот такой подход как они его Пожалуй я не могу отвечать за других людей негатива Я не видел А ну Ну просто было интересно спасибо супер Спасибо ещё один вопрос А спасибо за доклад Вопрос такой вот вы говорите Вы автоматически там мы описываем создание фикстуры но автоматически идёт её удаление Можно ли изменить этот механизм как-то его обойти потому что иногда я хочу её в дальнейшем использовать Да и описать свой клинап Как я вижу Пока не было такой возможности То есть это происходит в бэкграундер ли описывается самостоятельно То есть ты когда пишешь фикстуры есть два варианта её написания во-первых можно сделать фикстуры без клипа То есть она что-то создаёт но потом ничего не удаляет это Например может быть какой-то объект в памяти или когда фикстуры полагается на другую фикстуры которая сама за собой почистит например при создании таблички можно её потом не удалять потому что потом удалится вся база данных то сам код очистки пишется внутри фикстуры Сейчас я покажу это на примере так собственно вот Обратите внимание здесь написан код очистки то есть код очистки определяется разработчиком фикстуры библиотека это кастомного кода очистки ответил ли я на ваш вопрос передать Т например напрямую Да и описать ей чтобы я мог управлять потом совсем в конце нельзя ещ можно и так то есть вот в окружение Одним из методов можно получить исходный объект теста и делать с ним всё что захочется понял спасибо спасибо вопрос задних рядов Здравствуйте Анна компания Мой офис У меня вопрос А вы вы в ходе доклада утверждаете Что для того чтобы у вас всё работало фикстуры при при определённых параметрах от них и тех же должна возвращать один и тот же результат верно а я сказал почти это а это свойство фикстуры которые используется в ПТС и это свойство а обеспечивает библиотека кнф то есть разработчик фикстуры не должен об этом думать так фикстуры вызывается после этого библиотека запоминает была ли фикстуры выполнена успешно или вернулась ошибка И после этого любой вызов этой же фикстуры вернёт то же самое значение или Ту же самую ошибку и это уже на плечах библиотеки а но все хорошие тестировщики знают для что для хорошего покрытия тестом для того чтобы протестировать различные входные данные нужно вводить псевдо рандомизации по времени по входным Мет точнее параметрам которые будут использоваться в тестах Как вы вводите псевдо рандомизации в ваших фикстуры возможно ли это ну это не является задаче фикстуры задача фикстуры подготовить тестовое окружение Спасибо большое ещё один вопрос В центре зала Да здравствуйте Спасибо большое в одном из слайдов было написано что вы предусмотрели защиту от двойной инициализации Подскажите не является ли это таким двусмысленно проинициализировать А ему это не дадут сделать или наоборот может быть от этого не стоит защищаться Потому что если человек два раза инициализирует это в корне неверно и нужно наоборот заф и не допустить такого вот и написать ему об этом а именно по второму варианту это и происходит то есть когда происходит инициализация два раза это в корне неверно потому что тест один и окружение У него одно если нужно другое окружение То это другой тест собственно при попытке создать окружение второй раз из одного и того же теста будет фейл этого теста супер спасибо Есть ли ещё вопросы в зале ещё один вопрос Здравствуйте спасибо за доклад У меня вопрос касается клинап в случае когда тест упал То есть он будет вызван автоматически или есть какая-то специальная логика её можно описать как-то руками То есть если у меня есть тест допустим базы данных и у меня вот он упал я хочу посмотреть что там осталось в базе данных и в том же случае как в вашем примере с созданием директории да Отличный вопрос код клипа будет вызван автоматически если нужна какая-то логика например вы не хотите чтобы кли происходил при сленом тесте То это можно заложить уже в код самого в зависимости от этого выполня код супер спасибо Есть ли ещ вопросы в зале ещё один вопрос Здраствуйте ри изт Меня интересует почему вы не используете интерфейс в своих фистулой вопро Это для например библиотека имеет Ну может создавать свои объекты которые частично повторяют интерфейс тент И если бы я использовал просто тестинг Т то такие объекты нельзя было бы вернуть та же самая проблема с бенчмарка бенчмарки и тесты во многом похожи и хотелось бы уметь создавать окружение не только для теста но и для бенчмарка если использовать то функционал ограничивается только тестами Ну просто на уровне типов супер Есть ли ещё вопросы в зале похоже Вопросов нет одну минуту я проверю чат давай нет в данный момент нет вопросов в чате там есть вопрос на обсуждение который можно вынести на дискуссию но к сожалению Как именно вопрос Это невозможно сформулировать а большое спасибо давайте выберем вопрос который вам больше всего понравился для того чтобы подарить подарок от Яндекса Да отлично тот вопрос который на дискуссию вполне можно принести выши и обсудить на гитхабе А вопрос э Давайте ещё раз я вспомню темы вопросов можеш зачитать пожалуйста конечно мой почерк особенно когда вслепую пишешь очень интересно Если другой человек смог это прочитать Если я смогу это прочитать будет успех у нас был первый вопрос про цели использования после чего про вызов фикстуры из фикстуры А был вопрос про использование стий вместе вместо было был вопрос о том как восприняли вообще использование пакета использоваться ли он сейчас где-то ещё как обойти удаление фикстуры Если тебе это не надо как выз фикстуры из фикр фикстуры из фикстуры Не уходите пожалуйста из зала Мы хотим Подарить вам подарок а для подарка от Газпромнефть от нашего партнёра а для подарка из газпромнефти Пусть это будет Вопрос с очисткой фикстуры в случае фейла теста очистка фикстуры в случае фейла теста Не уходите тоже пожалуйста Мы хотим Подарить вам подарок Большое спасибо за доклад Большое спасибо за вопросы это было круто Мы хотим вас тоже поблагодарить и Подарить вам подарок от нашей конференции Приходите к нам ещё рассказывать доклад Вау Давайте Поа подию"
}