{
  "video_id": "u-1r6hVu-xE",
  "channel": "HighLoadChannel",
  "title": "Версионирование данных. Теория и практика / Максим Тремпольцев (Mail.ru Group)",
  "views": 3052,
  "duration": 2182,
  "published": "2021-10-04T02:45:36-07:00",
  "text": "добрый день очень рад вас всех видеть давайте начнем начну я с базу вардов в нашем деле без них никуда и 1 бозор будет это дельта warehouse сам термин появился еще в прошлом веке после публикации статьи борей давление пола морфи и в этой статье рассказывалась описывалось архитектурная модель для хранилища в которые стекают данные из разных источников вот такая вот в общем история так не туда нажал так вот что такое дтл house какого-то четкого определения этому термину я не нашел но если почитать различные книги статьи как вот например на сайте в oracle а то становится понятно что до этого и house хранилища данных служит для allow для централизации и консолидации данных из разных источников исторических данных особо хотел бы отметить и это слово исторических потому что именно про это я чуть позже ночную рассказывать так опять не туда выглядит архитектура архитектура до этого rehau с примерно таким образом то есть есть какое-то количество разнообразных источников из этих источников данные по определенному процессу которая называется этель что означает извлечение трансформация обработка и сохранения данных это все в какое-то большое хранилище попадать следующим уровнем над этим большим хранилищем стоят какие-то витрины данных кончились который уже конечный пульт получает доступ к нужным ему данных цепью аналитики майнинга данных репортов и так далее мне довелось поучаствовать в разработке да это warehouse начиная с ядра инвестиционного бизнеса альфа-банка который уже на холоде рассказывал владимир drinkin' поэтому тех кто интересуется направлю посылки посмотреть его доклад очень интересный и вся эта история она оформилась в виде тарантул datagrid про который сейчас не буду рассказывать скажу только что в процессе мы реализовали 2 2 типа versio нирования данных из cydia type 2 из сидит type 4 что это такое а что такое этой сиди если эту аббревиатуру расшифровать получается слова лечением дименшенс термин этот был введен насколько я знаю ральфом ким балом в своей книге которые уже там три переиздания по моему пережила дыры house тулкит что он означает этого собственно механизм для отслеживания изменений в данных причем даже не один механизм а несколько да в этом термине есть такое слово слову ли то есть медленно какие-то изменяющиеся данные в самой книге я не нашел ответа на что такое слово ли четкий какие-то критериев нет поэтому будем считать что какие-то данные которые изменяются быстро например эта информация с какого то датчика это быстро изменяемые данные а например изменения адреса пользователей или изменения информации о состоянии сделки это слово ли то есть наша история типов среди всего встречается 8 причем базовых типов 5 остальные являются комбинацией этих пяти типов причем на самом деле комбинаций может быть произвольное количество здесь можно отталкиваться собственно от своей задачи и реализовать с помощью базовых вот этих вот типов любую задачу самого правильного какого-то единственного правильно лучшего типа нет потому что в одной и в одном сценарии тип может показывать им хорошо а в каком-то другом сценарии наоборот показывает все они очень хорошо начнем самого базового типа это сидит type-0 этот тип означает следующие данные не изменяются то есть если произошло какое-то событие или какой-то факт зафиксирован то все эти данные они остаются неизменными ну и соответственно тут никак не идет речи об обстреле отслеживание каких-то изменений следующий тип и тип 1 это то что мы видим в суды общего назначения то что там а из коробки стратегия которая там есть то есть просто охраняться актуальные данные если мы делаем обновление каких-то данных то просто старые перри затираются но вами и таким образом мы всегда имеем лишь последний вариант какое-то актуальное состояние в терминах тарантула реализовывается это довольно тривиально то есть есть у нас формат таблицы создаем таблицу создаем первичный ключ и в общем-то используем функции такие как дед insert апдейт в общем-то код довольно очевиден наверное комментариев не требует единственное что хотел бы здесь отметить то что в таблице хранятся данные в плоском виде и для этого здесь есть такая функция как флотам и функция апдейт она на вход принимает список обновляемых полей дальше для других типов я реализую такие же функции в такой же семантикой подведем итог небольшой очень просто для реализации нет никакой избыточности никаких накладных расходов но минус очевидно это то что не сохраняется история со вторым типом в плане вы все хорошо то есть здесь мы имеем полную историю и достигается это тем что мы добавляем еще одну колонку с версией и каждое обновление данных это создание новой записи в примере на экране вы соответственно видите что здесь изменился адрес и мы видим теперь две записи старую и новую с другой версией опять же на tarantul это рис реализовывается довольно просто так же у нас есть формат таблицы где мы видим что появилось еще одно поле вершин создается индекс единственный момент что индекс в первичный ключ кроме самого идентификатора мы добавляем еще версию тарантул позволяет это сделать и таким образом пара из идентификаторы и версии для нас решает проблему уникальность первичного ключа при обходе данных тарантул также позволяет не указывать полностью индекс поэтому мы можем указать только идентификатор и получить итераторы пройтись по всем записям которые имеют такой идентификатор то есть получить таким образом всю историю здесь в общем так вот тоже довольно мне кажется очевиден единственное что вот когда нам требуется получить всю историю мы по таблице перемещаемся как я уже сказал по индексу не указывая версии таким образом получаем все записи функции вставки и обновления выглядят также довольно просто единственное что мы здесь видим это то что мы обогащаем поле версия каким-то значением но в данном случае вот мы берем время не обязательно в качестве версии использовать время но я считаю что использование времени дает ряд преимуществ первый это исторические срезы мы можем посмотреть на то как база данных выглядела в какой то момент времени просто выбрав все записи у которых вверх падает в нужный нам диапазон ну и таким образом увидеть как вот она выглядела на тот момент второй небольшой бонус но приятный это то что если им использовать время которое получаем на сервере то мы получаем какую-то устойчивость конфликтом рипли кации при нормальном работе систем при нормальной работе системы у нас данные идут на мастер от мастера нее уже потом копируются на реплику таким образом происходит репликация если же вдруг в случае и какая ситуация может возникнуть в случае асинхронной репликации если у нас пропала мастер по каким-то причинам например кто-то споткнулся о кабель то возможна такая ситуация мастер получил данные успел и куся сохранить но не успел их от реплицировать нарушилась связано с ним система понимает что пропал мастер выбирается новый мастер и на него приходят те же данные таким образом мы получаем и на мастере на реплики независимо друг от друга сохраненные данные после того как восстановится связь с мастером пойдет процесс обмена данных чтобы и мастер и реплика имели полный набор данных и вот здесь в такой ситуации мы можем получить и конфликт репликации которые потребуют вмешательства то есть придется приложить какие дополнительные усилия для того чтобы починить систему в случае если мы будем генерировать время на сервере использовать его как часть первичного ключа то у нас будут разные индексы мы такой с такой проблемой не столкнемся вероятность этого будет очень мало и можно будет пренебречь подведем итог по второму типу и имеем полную историю метод довольно прост в реализации очевидно присутствует какая-то избыточность и самый большой для меня нет второго типа это проблема с запросами которые не содержат первичный ключ здесь нам будет не достаточно пройтись просто по какому-то индексу и получить данные нам нужно будет проверять являются ли эти данные последней версии из-за этого все такие запросы они достаточно низко производительные есть вариации в плане реализации второго типа например добавляет еще одна колонка которая указывает на той являются ли данные является ли эта запись актуальной или это какая-то к запись частично такой подход помогает решить ту проблему который озвучивал с медленными запросами но при этом появляется другая проблема и теперь при обновлении версии нам приходится и делать вместо изменения одной строки нам приходится модифицирует две строки подход этот имеет тоже плюсы-минусы понятно плюс опять полная история минусы избыточность и теперь у нас уже страдает производительность при обновлении данных я встречал также в интернете упоминание о других способах реализации второго типа например вместо одной колонке с версией используются две колонки это начало времени жизни версии и конец времени жизни версии честно говоря мотивации и мне не совсем понятна и объяснение не нашел зачем это делается единственно что могу предположить что для людей критически важно заодно чтение видеть время существования какой-то версии друг других в общем я не могу придумать плюсов от этого также встречал варианты реализации где помимо start and у нас добавляется еще и колонка corinth ну здесь я могу придумать интересный бизнес кейс именно можно записав в corrente труд то есть показав что это актуальная версия таким образом завершить время жизни какой-то последовательности возможно в каких-то кейсах это будет важно соответственно плюсы можно завершать жизненный цикл серии изменений без удаления но и минусы понятно опять же нам нужно обновить не только запись версии но еще и предыдущую запись снять флажок о том что она была активной 3 возможно нам захочется избежать дублирования информации которая не изменяется допустим у нас меняются только одно два там три поля из какого-то большого количества полей здесь можно использовать третий тип он говорит о том что для изменяемых значений можно добавить еще одну колонку соответственно мы добавляем еще одну колонку например вот email old email и при обновлении версии соответственно мы записываем в колонку old предыдущее значение но и актуальные пишем уже в колонку без old на tarantul и опять же это реализуется довольно просто здесь мы видим что появилась еще одна колонка для того поля которой изменяется ну и в общем то все остальное довольно просто вот функции чтения данных становится сложнее потому что нам теперь нужно скрыть детали реализации то у нас есть какие-то дополнительные колонки и вернуть пользователю просто обычные записи которые он ожидает видеть без каких-то служебных полей функции вставки в принципе довольно простые единственное что при обновлении какой-то записи мы должны переложить старые данные соответственно в историческую колонку плюсы-минусы довольно хорошо работает третий тип когда у нас каких-то полей изменяется немного и мы хотим избыточность птиц в этом случае хорошо работает минус это то что история ограничено конечно можно добавить не одну историческую колонку во вторую третью но принципиально это ситуацию никак не изменит от себя добавлю что по моему мнению данный тип очень хорошо работает с другими типами например если у нас есть какая-то система отслеживания задач и нам критично заодно чтение видеть предыдущий статус задачи и текущий или там текущие и будущие то мы можем историю например хранить в таблице которая реализует четвертый тип а как раз и использовать таблицу встретим типов для быстрых чтений четвертый тип он смысл в том что мы добавляем таблицу в которой будут храниться исторические данные таким образом изменения версии будет означать что мы на запись перекладываем в историческую таблицу в базовой таблицы оставляем актуальное значение реализация натан здесь единственное что я хочу отметить то что да вот создается исторический историческая таблица и в этой исторической таблице у меня немного индекс отличается от базовой а именно я также вверх создал первичный ключ и из пары идентификатора и версии для того чтобы иметь возможность простым обходом получать историю функции чтения довольно простые единственное что когда мне нужно получить всю историю я дополнительно делаю проход по историческому по исторической таблицы и получаю там всю историю функции записи вставки и обновления выглядят очень просто выглядят они очень просто по той причине что вся логика у меня вынесено gear использование триггеров в этом сценарии очень удобно позволяет всю логику поместить в одно место и значительно все упростить и значительно логику упростить других местах здесь я проверяю о том что старое значение не равно нил это значит 5 что мы изменяем версию в таком случае я просто беру и эту запись перекладываем в исторический в историческую таблицу ну и в любом случае при вставке и при обновлении мы обогащаем ту запись которая будет сохраняться версией плюс и минус и плюс полная история от быстрый поиск по актуальным данным то есть у нас здесь нет никаких накладных расходов фактически здесь скорость будет такая же как в случае типа 1 где нет вообще versio нирования плюс в чем этот четвертый тип интересен тем что мы можем использовать как интересные стратегии например в исторический space складывать и не полный набор колонок а только например если у нас изменяется только часть каких-то колона кто откладывать только их или например сохранять историю на в какое-то другое место в холодное хранилище диск там что угодно на этом плюсы закончились начались минус и минусы очевидно это избыточности второй минус это то что добавлении новой версии требует записи в две таблицы подведу итог по базовым типом тип 0 оригинал не меняется тип 1 хранятся актуальные значения тип 2 добавляется новая запись и тип 3 добавляется колонка и тип 4 добавляется историческая таблица все остальные типы являются комбинацией базовых я уже упоминал что на самом деле типов описано больше что это за типы на самом деле здесь есть определенная путаница хороший и хорошо эту ситуацию показывает вот такой вот диалог нас так airflow человек пишет о том что он читал им было и stack overflow и до сих пор не понял для чего нужны эти типы 5 7 и ему отвечают что это не беда потому что есть определенная путаница там с терминологии и в общем то надо отталкиваться от своей задачи тут невозможно не согласиться полно я все-таки попробую дать описание этих типов силу своего понимания потому что на самом деле информация скудная довольно противоречиво тип 5 говорит о том что какие-то часто изменяемые данные можно вынести в отдельную таблицу как и в типе 4 и изменять только ее при этом например в книге кем было он пишет о том что возможно по соображениям производительности вас не устроит такой подход тогда вы можете взять и встроить эту таблицу в базовую таблицу в чем тогда будет отличие от типа 1 мне в общем-то не понятно тип 6 он говорит о следующем что добавляется новая запись то есть каждый каждая новая версия это новая запись как в типе 2 при этом у нас появляется дополнительная колонка которая хранит актуальное значение тип 3 и при обновлении записи мы должны обновить вот это вот актуальное поле у всех предыдущих записей то есть видно что этот тип явно заточен на то чтобы быстро получать актуальное значение вот в данном примере например здесь у нас джессика переехала из одного места в другое но при этом в исторической записи есть и запись для истории вт и в то же время есть кучей ее адрес то есть возможно в каких-то случаях этот ти будет хорош когда нам нужно делать такие запросы на чтения + и полная история получение актуального значения очень эффективно но при этом добавлении новой версии требует обновления всех предыдущих версий вот что конечно не может не огорчать тип 7 это альтернатива шестому типу то есть он позволяет достичь тех же целей но при этом другими способами а именно мы выносим актуальные значения в отдельную таблицу и можем соответственно получено когда нам нужно обновить актуальное значение мы будем обновлять это в одном месте они в н мест до соответственно что у нас тут плюсы плюсы опять же полная версия плюс при обновлении версии нам не требуется менять n значение нам потребуется только 1 экстра запись что уже лучше я закончил на этом всем спасибо за внимание и если у вас будут вопросы и я постараюсь на них ответить спасибо жался за доклад очень хороший понравился вопрос только в том где вы показывали пример и с датами там же получается но одно дело когда у тебя база смотрят за консистентной стью данных а другое дело когда ты сам начинаешь же тут может быть очень много подводных камнях особенно всяких репликаций распределенных транзакций как здесь находить баланс получается здесь можно обсудить какие-то конкретные подводные камни я на самом деле просто сейчас для себя не совсем понимаю сценарий о каких подводных камнях может идти речь и в любом случае тот код который я показывал мы берем на себя до ответственность да давайте вернемся это у нас ну например там где две даты выберите непонятно как его для чего так делала я понял один из юз кейсов этого чтобы были запросы проще когда нужно найти интервал проблема заключается в том что допустим у классическая задача там типа комнаты и стулья что у нас один стул может оказаться одновременно в двух комнатах когда есть ошибка обновления когда н.д. допустим не совпадает со стор дейт и то есть получается одна и та же запись и бывает в двух разных местах и вот здесь получается не консистентной когда тебе одно поле в базе то у тебя сама база не даст его создать хорошо в каких случаях может оказаться у нас в двух разных местах давайте пойдем с такого момента в каком случае у нас может оказаться в разных местах когда у нас используй какое-то шарди рование например часть данных у нас хранится на одном шаге я часть на другом шарди как мы можем избежать такой ситуации чтобы они оказались в разных местах мы берем и шар деру им по индексу по первичному ключу таким образом если мы откровенно там не накосячить реализацию у нас все данные таким вот индексом будут оказываться на одном шарди то есть на одной физической машине соответственно в рамках одной физической машин мы можем начать транзакцию прочитать старое значение обновить его потом записать новое значение закрыли транзакцию то есть мы защитим ся от того что у нас разъедутся данные в общем так каких-то других проблем если все реализовано правильная в общем-то не вижу надеюсь ответил на вопрос потом можем поговорить о услышал меня отлично вячеслав гнивц подскажите пожалуйста тут все кейсы были осмотрены они были рассмотрены например обновления записи также было бы интересно если вы рассказали примеры с именно с удалением записи когда происходит удаление в частности вот этот пример меньше 2 типа очень хорошо обыгрывая данную ситуацию когда у нас именно две даты и вторая дата она служит одновременно и признаком удаления когда вы спрашивали не знаете кейса в практике очень часто применяем когда запись именно закрывается то есть ул актуальные записи мы проставляем там бесконечность девятки из 1 12 99 9 999 2999 и удаленные записи мы проставляем актуальное значение тогда мы сразу видим когда запись перестала существовать и вот для меня это юзабельный кисть постоянно этим пользуемся очень полезно также встречали еще вот в этой же слове чем джим dimension использование именно флага когда просто добавляется флаг там enter the baby ride расскажите еще про удаление пожалуйста расскажу про удаление расскажу и как раз на примере тарантулы the grid как у нас реализовано там удаление с ночей мы пошли сначала следующим путём использовали отдельное поле которая говорила о том что данная запись удалена то есть там где летает равно true чем было у нас проблема при таком подходе у нас очень сильно страдали различные аналитические запросы нам нужно когда нам нужно было найти какие-то данные нам приходилось во-первых определять что это актуальное значение 1 а второе то что это не удаленное значение 2 поэтому набив тут определенные шишки мы потом перри перешли к другому способу а именно по аналогии с тем как хранятся версии в типе 4 в отдельные таблицы мы также удаленные стали перекладывать в отдельную таблицу для удаленных вот ну и соответственно вот такая вот у нас история мне кажется это довольно неплохой вариант поступать вот таким вот образом а здравствуйте и спасибо за доклад не здесь мне на самом деле два вопроса ну во первых я поддерживаю предыдущий вопрос принципе у нас тоже похоже схеме реализовано именно для в случае удаления раз добавляется дополнительная поле который говорит о том что существует ли запись или нет то есть получается что мы отмечаем не только дата существования от этой записи но и дата ее не существования то есть может быть какой то промежуток времени да да строка бывал дольно а потом и взяли восстановили но то же самое там относится к истории сафди летами и с влогами активности и так далее вот вопрос у меня во второй части был другой вопрос если пойти в сторону вообще как бы унификации данных да ну как вообще изначально делать подход битриксе чтобы упростить в работу да то есть мы обобщаем данные но в целом если мы говорим про таблицу что вот эта вся история соседи она на уровень выше чем физически таблицы на самом деле соответственно можем взять абстракцию такую что типа выделим отдельную таблицу ну если взять could do велосипедный подход то сразу идеи приходят а давайте ка сделаем отдельную таблицу в которой будет несколько полей которые говорят где находится эта запись физически одно поле текущее значение этой записи и и там одно поле боковой колонке это запись вот такой подход не рассматривали еще ну нет не рассматривали он даже звучит очень сложно сам по себе и ну допустим вот у нас там одна табличка мы хотим сделать от подход берем отдельную таблицу говорим history и в ней первое поле какая таблица название таблицы второе поле а иди в этой таблице 3 поле название колонки и четвертое поле значение этой колонке так так так так и у вас так получается при обновлении вы будете обновлять только одно всегда значение то есть добавлять 1 всегда десерт в историю да ну естественно это больше 4 типа имею ввиду то когда мы отдельно от основной таблицы уйдем историю тогда вас получается отдельно таблица вы в нее делайте вот отдельный insert один раз и у вас нет дублирование данных но херово истории в том что типа получается это вообще данные по значению по разным значениям мы закладываем в одну ячейку и сисадмины вообще в ярость придут от такого решения сейчас я немножко запутался я правильно понял что вы решили хранить все пока ло ночь на это как ну то есть вот изобрели колоночный у меня нету мы такое не используем я просто про этот метод не упоминали решил его упомянуть о я понял спасибо да он плохой получается с ваш страны но я его до конца не осознал косвенный признак того что наверно он не очень хороший если его нельзя стро понять но окей пасибо можно потом поговорим я попытаюсь вникнуть глубже здравствуйте спасибо за доклад интересует такой сценарий когда у нас вместе с данными меняется еще и тип колонки можно ли ну как-то гибридное то здесь представить потому что на практике бывает истории когда нас допустим сначала это было скалярное значение видео e-mail до затем она начинает быть красивым и клиенты очень часто хотят это прозрачный иметь на своей стороне чтобы система хранения как противник а выдалась начал там скаляр а потом массив то есть в этой методологии каким-то образом можно эту отобразить в общем и история понятно нам нужно изменить измените формат таблицы ну в общем как это обычно решается решать с миграциями то есть мы можем обычно это делается либо все останавливается накатывают скейта alter запускаются скрипты которые перекладывают из одного места в другое ну и потом все запускается можно пойти более таким путем который позволяет сократить простой делать это на лету то есть как это вот сделано например таран туда they greet когда меняется формат таблицы мы создаем новую таблицу с новым форматом после чего фоновом режиме перекладываем данные из старой таблицы в новую используйте какую-то функции функцию трансформации чтобы вот ну например таки если массив то соответственно значение это должно там лечь в первый элемент массива вот то есть нужна какая-то функция трансформацией ну и соответственно вот когда это заканчивается вот мы имеем возможность удалить старую table и все вот как бы миграция завершена вот мне вот так такой вот способ известен"
}