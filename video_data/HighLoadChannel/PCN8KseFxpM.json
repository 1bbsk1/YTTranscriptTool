{
  "video_id": "PCN8KseFxpM",
  "channel": "HighLoadChannel",
  "title": "Обобщенные табличные выражения (СTE) и оконные функции в MySQL 8.0 / Дмитрий Ленев (Oracle)",
  "views": 3315,
  "duration": 2995,
  "published": "2018-11-20T12:27:50-08:00",
  "text": "ну надо к таскать эту такое москаль 8080 это самая свежая стабильная детка моя сколь сервер она была объявлена стабильной совсем недавно в апреле этого года с выхода версии 80 11 я думаю 80 12 тоже не за горами в ветке 80 очень и вот в этой версии очень много разных изменений какие-то из них в области которые традиционны для морской например моя сколь как известно это такая база данных для лет соответственно для лучшего поддержки для приложений есть улучшение в юникоде можно что-то со звуком сделать я себя очень сильно слышу это мешает ее да и сделать дисплей улучшение винникотт улучшения в поддержке джейсон там им place обновления джейсон документов какие-то вещи связаны для гкл да то есть для высокой нагрузке такие как улучшение производительности на дыбе улучшение аппликации которого перед началом да кого тут было упомянуто есть улучшение в удобстве эксплуатации это новый словарь данных атомарный ддл работа с индексами невидимыми но есть и какие-то изменения которые скорее движутся в сторону большей поддержки сквозь стандарта более слова поддержки более сложных запросов аналитики это вот как раз поддержка табличных поражений и вообще от обычных рождений и поддержка оконных функции вот по которой мы поговорим то есть вот вот это можно сказать все с высоты птичьего полета основные изменения 80 а вот эта тема нашего сегодняшнего доклада и так что же такое вообще на это обычное выражение ну все мы знаем что такое производная таблицы то есть люди используют москаль поэтому они знают что такое призваны таблички это они задирают и босса это просто под запрос ого-го-го from клаузен вот так это выглядит и начиная с 80 у нас доступные обобщенные табличные выражения по сути дела это тот же самый под запрос который вы не вынесен перед селектором получил ими и на него можно строим клаус и ссылаться то есть такие можно сказать производные таблицы на стероидах полный синтаксис выглядит вот так у нас есть ключевое слово вив дальше идет имя табличного выражения список имен торцов то есть мы как бы объявляем виртуальную табличку под запрос который генерирует обычное выражение дальше мы можем наградить любое другое количество определений табличных выражений и наконец можем использовать selectable 3 делит который его на него будет ссылаться при этом эту конструкцию слив можно вообще использовать под запросе в чем же преимущество табличных выражений по сравнению с производными то лицами во первых они проще читаются ну давайте посмотрим пример вот у нас есть использование производной таблицы но не тривиальная какой-то то внутри join a ивлев joinha мы сначала в лет кисти видим дата пытаемся понять что уж такой dt вынуждены куда-то идти глубоко вниз внутри вложенности ну не очень удобно с обобщенными то обычно даже не это будет как-то так аналогичный запрос то есть мы сначала объявили что да вот дтп у нас табличка которая делается вот таким запросам и дальше на неё ссылаемся при этом в ложности здесь не получается ну во всяком случае не так сложностью это blade или человек который читает слева направо все выглядит проще обобщенное выражение проще выстраивайте цепочки опять же пример производный там есть друг на друга не могут ссылаться не могут ссылаться на соседи друг на друга не могут ссылаться только когда есть какая-то влажность и соответственно чтобы сделать чтобы достичь того чтобы 2 производные таблицы были связаны между собой что производная табличка нас вас на другой приходится городить какую-то такую историю со сложностью лезь под запросами все это как бы изрядно неудобно читаемые не очень хорошо с точки зрения производительности работает от обычных вложений такой проблемы нет мы можем из при объявлений то обычно выражения в табличном выражением последующем ссылаться на предыдущие таблично выражения все это прекрасно работает опять же на производные таблицы нельзя ссылаться много раз на обычно рождение можно ссылаться на много раз для производных таблица есть workaround просто мы дублируем определение производной таблицы да просто дублируем этот вопрос много раз в нашем запросе ну как бы это плохо по двум причинам во-первых дублирование кода получается да и мы один кусочек поправимо 2 забудем поправим и все у нас запрос сломался мы мучаемся ищем где у нас там что сломалась это с точки зрения поддержки кода плохо а с другой стороны вот получается что у нас этот наша производная таблицы вычисляется несколько раз что естественно плохо блок с точки зрения производительности ну и можно сказать что оптимизатор москаль такой неумный что он не может найти эти общие производные выражений таблицы ну можно сказать и так это же с обычного жизни такого не происходит можно ссылаться на одно the beach наложение несколько раз без дублирования то есть проблему с дублированием кода мы точно решаем проблемы с производительностью тоже вне трасс лучах решаем вот давайте посмотрим пример как раз с цепочкой с несколькими ссылок у нас есть табличка с продажами по дням сил здесь мы на ее основе делаем от обычное выражение с продажам по местам после этого мы объявляем следующие от обычное выражение которое на основе таблички на основе выражения по продажам по месяцам секс баймак считает самый лучший месяц при этом вы видите у нас здесь две ссылки то есть мы выбираем из тела займов и выбираем все месяцы в котором у нас под запрос и займов вернула максимальную сумму то есть лучшими мы выбираем лучше месяцев семь месяца с такой же суммы продаж ну это опять же добавляем худшие месяцы тоже аналогичным образом у определенное это обычное выражение и наконец все финальном запросит вводим в1 одну табличку результат строчка для лучшего месяца может быть несколько строчек для лучших месяцев если их несколько ту ручка для худшего месяца и строчка для и границ опять же несколько ссылок как это все делать через производные таблицы я не представляю как бы скорее всего будет выглядеть как то ужасно можно сделать то же самое через ю но не всегда хочется создавать view для какие-то временных вычислений наконец-то обычное выражение последние с производными таблицами быстрее работает сначала нужно немножко поговорить о том как же собственно говоря они вычисляются это обычное выражение вот допустим нас есть такое то обычно выражение сети такой быть запрос из таблички t 1 и он используется в запросе с в доме с табличкой 102 это же какой-то условия на табличкой на результат табличного выражения стратегии на самом деле две вычисления обычно поражений которые моя сколь поддерживать 1 от матери зация то есть мы выполняем под запрос записываем результат во времени таблички с колонками a и b и потом просто выполняя внешней select и подставляю временую табличку вместо вот как к сети при этом здесь нужно заметить что в отличие от производных таблиц морской оптимизатор умеет создавать индексы на временную таблицу если у нас условия было был бы какой-то вида вот сеть я равно t 2 see the морской оптимизатор бы сообразил бы создал бы индекс на временную таблицу и условию pq слову по этому слою бы индекс был бы хорошо это будет видно в эксплей нее там есть такое ключевое слово auto-key второй вариант вариант вычисления различных выражений это слияния но мы преобразуем исходы наш запрос подставляем вот этот наш под запрос в внешне запрос кучами какой тег валентный запрос получаем вот такое сложное условие vr clause это может хорошо работать если условия вот эта внешняя которую нас было во внешнем запросе да она более селективной чем внутренняя то есть в условий когда у нас временная табличка для обычно выражение получилась большая а так у нас мы можем сделать более селективную выборку по вот этому внешним условий у нас был бы получается лучше это 2 статьи как происходит да прежде чем поговорить в том как происходит выбор давайте покажем еще немножко право материализацию тут важно понимать что у матери зация происходит один раз но допускает на себя много сил да то есть вот откуда у нас этот выигрыш что когда мы когда мы дублировали раньше производные таблицы здесь у нас будет и каждый из них интересовалась отдельно да здесь у нас получается что у нас матери зации один раз мы делаем мотивацию для 1 год обычно выражения и дальше на него просто ссылаемся используем это время на табличку соответственно меньше получается нагрузка на диск памяти выше скорости опять же каким же было оптимизатор умеет создавать индексы для каждой ссылке потенциально для такого запроса он создаст автоматически индексы и по колонке of таблично выражение по колонке бы будет хорошо и соответственно в испании вы увидите вот такие автоматические ключи матери зация может быть лучше слияние вот мы на прошлом слайде говоря о том когда слияния хорошо по сравнению с матери зации а вот матери зации может быть лучше слияния когда внешние условия не слишком селективное или вы например по табличке выражении нет индексов и мы полагаемся на то что оптимизатор умный сладостно вот эти индексы как раз в этом случае так вот как происходит выбор между стратегия во-первых в оптимизаторе есть юри стики которые используются есть помимо эвристик есть некие технические ограничения на поддержку слиянию ты слияние не поддерживается для некоторых различных выражений например я столичного же не использует грубой или она рекурсивная то требуется матери зация при курсе мы будем чуть чуть позже наконец пользователь может явно контролировать происходит будет будете просто если я не или будет происходить металлизация за счет механизма hand of до который вот 80 опять же появился или путем управления вот таким системные переменные optimizer свечи можно выключить слияние ядер али таблиц ну и за одно это тоже повлияет на публичное выражение давайте посмотрим на пример с улучшением производительности при помощи табличных выражений вот у нас есть такой запрос из 9 3 это такая реализация теперь я же теста запрос написано через представлении у нас есть некие продаже есть поставщики мы считаем сусуму по поставщикам поправ продажа бу поставщикам да вот создали вьют который это считает для каждого поставщика общая общая выручка с поставщика вот есть такой запрос который использует этот самый умный по сути дела выбирается поставщики с максимальной выручка да то есть у нас вот здесь под за общем я использую два раза под запросы и в джонни тут есть одна такая проблема что слияние в данном случае не работает из-за того что вот есть этот грубой до приходится использовать вредную таблицу соответственно если все это написано через view там и два раза мы реализуем этот view при выполнении то есть да то есть view и диаметром по сути дела внутри москаль один механизм и соответственно у нас получается как бы две детали таблицы и две ссылки на view 2 мать и лизации хотя по сути это делаю значение это одно плохо не такой умный москорепе затар как могут быть но у нас есть решение что можно использовать обычное выражение просто заменить great view на вив убрать там точку запятую здесь мы брали точку запятую и вот этот по сути дела определение views дублировать перец селектором след остался тот же самый ебаться мы получаем выигрыш в скорости в два раза то и больше чуть-чуть вот прекрасно значит ну а вообще на это обычное выражение это не только такие дира вид таблицы на стероидах это еще новая возможность использовать рекурсию как выглядит рекурсивно это обычное выражение во первых появляется ключевое слово рик versiv вот здесь и появляется ссылка внутри определений от обычного выражения ссылка на само себя то есть мы определяем обычно же не сети у нас есть обязательно некий начальный подзапрос есть union с часть рекурсивной частью в котором есть ссылка на само себя ну и наконец есть финальный select который использует это публичное выражение так вообще это рекурсивное от обычного же не вычисляется вычисляется путем операции на шаге 0 мы выполняем начальный под запрос на каждом последующем шаге мы выполняем начальную рекурсивные части при этом в качестве значение от обычного выражения берется значение рекурсивный для выполнения курсивный части вот этой берется значение там бежит выражения от предыдущего шага то есть на 1 ты рацию у нас их будет результат наш 10 на 2 на шаге 1 и так далее так далее рано или поздно мы остановим вычисление когда результат очередного шага будет совпадать результатам прошлого шага после этого применяется внешней запрос вот так это все работает ну давайте посмотрим пример пример такое типичное использование рекурсивных табличка выражений для генерации различной послед насти мы сдаем начала шаг условие окончания пишем вот такой рекурсивный запрос с рекурсии над обычным выражением генерируем числа от 1 до 10 то есть у нас есть начальная часть есть рику сильная часть есть условие окончания как это работает значит на первой части выполняется начальник на первом шаге выполняется начальный запрос вот этой части выделено на втором шаге у нас уже выполняется и и начальная часть основная она уже возвращает результат с первого шага и плюс еще в то новую строчку да вот этот вот эта вторая строчка она появилась за от рекурсивной части на третьем шаге мы у нас добавится еще одна строчка потому что естественно все чтобы в предыдущем шаге у нас тоже там есть и добавить добавилась еще одна строчка да ну что мы к двойке добавили единичку и так далее четвертый шаг так далее на десятом на шаге 9 нас получится десятка она 11 шаги у нас не появляется новый срок потому что сработал условия останова и мы считаем что рекурсивный запрос мы выполнили тут возникает такой хороший вопрос а собственно говоря почему это все работает где гарантия что у нас вот этот рекурсивный процесс сойдется ответу чем простой разработчики скале стандарта очень хорошо подумали и наложили ограничение возможности которые можно использовать рекурсивных под запросов такие что процесс теоретических он сходится при этом слово теоретически здесь важно да то есть вот он тип тиски может сходиться а на практике у вас прежде чем он садится память кончится или там жесткий диск да потому что вы написали такой под запрос который все целые числа от одного там дома xenta тренировать и плюс еще ограничения наложено таким образом что они продают позволяют проводить вычисление эффективно в чем здесь проблема вычислять полный результат на каждой итерации это дорого мне хочется такого делать хочется ограничить вычисления только обработкой строк которые добавились прошлой итерации вот такие ограничения на ложные значит какие-то ограничения в частности рекурсивный по запрос может ссылаться на трагично и выражение только во всем части и единожды он не может ссылаться в под запросе и не может ссылаться в качестве правой таблицы в лев джо и кроме того рекурсивный под запрос не может содержать в себе грубой агрегатная или оконные функции не может содержать ордер buy limit и distinct но это скорее специфика mais quel в общем-то все эти правила можно сформулировать следующим образом представьте себе что вычисление происходит так как если бы на каждой итерации обрабатывалась по одной новой строке который добавляется с предыдущей итерации по факту приступ выселение так не происходит конечно внутри она обрабатывает все новые сроки которые давали с полной ты рации за за один под запрос и даже более того мы сейчас посмотрим как это все происходит но вот правило мнемоническое такое то что нельзя вычислить при помощи вот такого вычисления по строчного то не запрещено значит давайте посмотрим как этот наш под запрос вообще над обычно выражение гильзы от одного до десяти раб на самом деле работает на самом деле там даже не выполняется рекурсивная часть много-много раз она выполняется оно как бы один раз но мы используем такой трюк как построчное чтение выполняющиеся временно таблицы выполняя начали select записано время табличку единичку а дальше запускаем рекурсивный select которые читают по синенькой стрелочки опишет результаты пишет свои по красников девочки вот на первом шаге он читает единичку пишет двойку потом читает двойку пишет тройку и так далее пока наконец то синяя стрелочка недоволен красную стрелочку вот так мы вычислили наших рекурсивные запросы то есть в теории мы рекурсивный сериях должны вычислить 10 раз а на практике мы этот рекурсивный select выполняем единой что но как бы над постоянно расширяющимся множеством ну и вот собственно и произошло останов другой пример еще одно типичное использование рекурсивных под запросов для обхода иерархии графов еще чего-то такого в до 80 в морской ли с этим проблема потому что ли у вас ограничивается глубина обхода и приходится писать много джонов либо приходится использовать хранимые процедуры ли вам приходится использовать модель вложенных множеств где вроде бы запрос это работают и нет ограничения на глубину но там очень сложная и дорогая модификация если интересно про модель может может можно посчитать уценка известный попали затар баз данных вот у нас есть дерево сотрудников до табличка с сотрудниками у каждого сотрудника есть менеджер елена это у нас самый главный директор вот это так деле выглядит допустим мы хотим запустить на такой вот под запрос мы хотим посчитать цепочки почти подчинения то есть для каждого сотрудника мы хотим посчитать путь от него до директора мы для этого пишем вот такой рекурсивный запрос значит здесь у нас начальная часть который выбирает менеджер то есть директора и рекурсивная часть которая к результатам предыдущей части добавляют всех подчиненных как это все работает вот работает начальная часть вот это выгодная более темным выбрали елену менеджера ставили эту строчку дальше на следующем шаге у нас уже работает рекурсивная часть для елены добавляются и и подчиненные его на камиль на следующем шаге опять же подчиненные и ванны камилия повел ее зоя ну и наконец верой петр понятно как это все работает значит пара полезных советов по использованию рекурсивных под запросов и рекурсивных табличных выражений используйте union distinct потому что он позволяет избегать дубликатов дальше надо понимать что когда вот вы обходите графы в графах иногда бывает цикл в дереве циклов не бывает от графа бывает цикла и не хочется бродить по этим циклом потому что обычно вам нужен самый короткий цикл если вы его ищете до или самый короткий путь без дублирующихся без повторных заходов в одну и ту же вершину можно использовать такой трюк вот добавляется колонка пав как на предыдущих слайдах где мы записываем наш путь через на все наши вершины и потом используем функцию fontaine сет для того чтобы отлавливать цикла да то есть мы смотрим а текущий элемент в пути в текущие вершине уже встречался если встречался то это цикл и можно остановиться дальше вот мы с вами говорю о том что процент мы знаем что гарантии такие что процесс остановится теоретически но на практике запрос может убежать да то есть вы можете использовать слишком ли много жесткого диска много памяти может много процессных ресурсов хочется как-то этого избегать ну типичная причина для этого это убежавшие запросы то есть мы как-то неправильно написали запрос что ты не продумали все стало плохо что делать делать с убежавший запрос во первых первую очередь писать правильно и ограничивающее условие значит если что-то пошло не так то морской вам поможет у него есть такая переменная как сети максар коршун в которой ограничивает количество итерации она выставлена в тысячу по умолчанию поэтому рекурсивный подзапрос вас не будет выполняться больше чем 1000 раз по умолчанию они сделают больше чем тысяч операций у вас не будет безумно большой таблички плюс если у вас итерации не такие итерации мало но они очень дорогие по времени можно еще ограничивать время выполнения запроса через системную переменную макс execution так вот собственно гареев все про таблично выражении давайте передём к оконным функция значит что такое оконной функция до версии 80 для того чтобы посчитать какую-то функцию от группы строк мы использовали грига тные функции вот мы считаем среднюю зарплату по сотрудникам для каждого департамента все прекрасно есть одна проблема у нас в результате теряются данные об индивидуальных строках в исходной таблице то есть если мы хотим сравнить среднюю зарплату каждого сотрудника с зарплат средней зарплаты по отделу то нам приходится крутить либо какой-то джонни вопрос все это сложный медленно тут на помогает оконная функция которые позволяют считать функции от наборов строк при этом не теряя информацию о индивидуально строков то есть вы час не они выполняют вычисления над неким набором строк группой ограничена на группы над окном значит что у нас здесь вот это похожие запросы он тоже считает среднюю зарплату по отделам но плюс еще выводит информацию для каждого сотрудника то есть как от здесь уже удобно сравнивать информацию об зарплате каждого сотрудника и средне информацию об отделе здесь вот эта конструкция rsl против in body parts а идея это как раз указывает на использование оконной функция какие части у нас есть оконный функция два первых вагоны функции есть сама функция вот функция плюс avr это означает что мы используем оконную функцию в конце функции могут быть стандартные агрегатные функции почти все и могут быть специализированы оконные функции их тоже достаточно много во сколь поддерживает большинство стандартных насколько я знаю то есть мы задаем какую функцию мы хотим посчитать над нашей группы строками дальше мы можем задать как группировать и строки фактически мы делим наш нашу табличку на секции и обработка каждой сердце происходит независимо друг от друга то есть при обработке строке оконные функция не видит строки других секциях это задается при помощи партии шин бо я clause вот так выглядит по умолчанию секция вся таблица то есть если портишь любой clause нету то здесь будет считаться в данном случае суммарная зарплата и так называемая clock аккумулятивные зарплаты для всех сотрудников почти таблице есть вот мы портишь на борьбу берем следующая часть это задание упорядочение внутри секции ну вот когда мы считаем скажем кумулятивную зарплату в в каждом департаменте да мы хотим вот как здесь вот это считается кумулятивные зарплата в каждой департаменте напрашиваться группировка по департаментам идет мы хотим задать собственно говоря в каком порядке мы хотим обрабатывать строки до кроме того для некоторых оконных функций вообще типа ранка вообще обязательно нужно задать какое-то отношение порядка между строками в группе и вот это отношение порядка можно задать при помощи ордер buy clause ордер buy некоторые выражения и по этому ордер buy будет происходить сортировка строк внутри группы следующая часть это задание рамок окна ну по умолчанию рамке окна вся секция то есть если рама как-то не задано то наша оконная функции считается всей в секции но иногда хочется считать от какого-то подмножество строк внутри секции и вот эта конструкция роуз between an bound это приз 1 concord на u can throw говорит нам что мы хотим считать все в качестве текущего окна для каждой строки считайте все строки начинаю с начала секции до текущей строки включительно не все оконные функции пока поддерживают рамки тот же ранг не поддерживает и существует много вариантов задание рамок окна вот например тот который мы видели на предыдущем слайде я вот вот это у нас секция серенький квадратик вот эта синенькой это то что у нас попадаю текущей рамке окна да то есть все все строки сначала секции до текущего дойти до текущие до текущей строки включаю его можно задать просто текущие текущую строку можно задать текущую строку несколько последующих строк при этом вот на самом деле здесь интересно здесь range coreldraw мы про это поговорим чуть попозже отдельно это не просто текущая строка на текущая строка а также всей ковалентные к ней портер баги какие вы уже можно зайти текущую струю между текущей строкой и тремя последующими можно двумя предыдущими между двумя предыдущими и двумя последующими то есть диапазон строк можно использовать и интервал темпоральный много вариантов в общем-то к заданию рамок окна есть два подхода немножко различающихся можно задавать физически рамки то есть количество строк который мы ходим хотим чтобы ходила в окно это ключевое слово роуз просто сдается количество строк в окне равный строк вообще не рассматривается and refining aten предыдущие строкам following все более-менее просто можно говорить что мы как я уже говорил сдаем окно сначала сначала секцией долл допустимым фаланг да м последующих второй подход это логически рамке окна когда диапазон значений мы задаем диапазон значений при подходящих строк ну чтобы сдать диапазон нужно никому порядочности и поэтому для логических рама как навсегда нужен требуется от этого ордер buy клауса то есть мы видим что вот у нас строки внутри окна сортируются таким образом и мы по отношению к текущей строке издаем следующий диапазон например предыдущих значений и м последующих и вот диапазон включая гай такой диапазон включает границу у нас входит в текущее окно при этом если вот это выражение по которой происходит сортировка для нескольких строк совпадают с текущей строкой то все эти строки диапазон попадают большая разница здесь сранью с физическим заданием окна ну вот такой пример все строки с датой за последние 7 дней у нас есть логическое задание текущие к текущей строки учит вычитаем 6 предыдущих дней получаем все строки с даты за последние дней если у нас используется просто ордер buy и нету никаких храма как нам то считается что используется вот такой вот такие рамки окна помог по умолчанию то есть ордер buy a range все рамки как нас начало секции до текущего и до текущей строки и ковалентные им строкам ну давайте чтобы не быть голословным посмотрим на пример с рамкам рамками окна и как это все работает значит вот здесь мы считаем такую среднем по месяцам у нас есть табличка с продажами мы из нее через грубая получаем да ты за продажи за месяц суммируем продажи чтобы получились продажи за месяц и считаем среднее при этом хотим средний не просто читать и считать называемой скользящие средние за три дня то есть мы берем предыдущий месяц текущий месяц и следующими есть для каждого месяца здесь нету партий шайбой клаус и соответственно секции вся таблица вот как считается это самое скользящая средняя для первой строке то есть мы берём у нас предыдущей строки нет поэтому и не учитываем берем значение для текущей строки и берем значения для следующей строки она вас попадает в окно получаем средний 600 для следующей строке для строки и за апрель у нас уже есть и предыдущая строка следующая строка мы усредняем 3 значение получается значение другое 700 вот как это работает хорошая вещь это именно вне окна окна можно именовать не обязательно дублируют их определение можно ссылаться на них задать во фрунт лоузи определить окно и ссылаться на нее несколько раз это удобно то что так легче читать можно задать низкую функция которая будет ссылаться на одно и то же окно при этом вычисление будет происходить одновременно соответственно вас выше производительности когда конные функции выполняются искали запросе такой важный вопрос ну вот мы знаем что у нас есть это вполне низкое запросе логически дались join потом грубой а потом в конце есть ордер buy a distinct где место вычисления оконных функций да мы знаем что агрегатные функции выполняется при грубая окольная функции выполняется после грубая и having обработки haven клаус и но перед ордер buy i'm a distinct он соответственно надо понимать что грубой и грубое having a newly от наклонной функция ордер buy a distinct или нет соответственно на практике на вычисления кого на функции не влияет ну как не влияет он является точки зрения не влияя с точки зрения результата но может ли я с точки зрения производительности это надо учитывать в общем случае вот у нас есть join наш обработка грубая для усиления каждой оконной функции нам нужна временная таблица которую мы сортируем по содержимому партий шин бо экспресс ордер байк смешные потом просто идем по этой таблице построчно пытаюсь очистить оконную функцию очевидной оптимизация которую наша оптимизатор умеют выполнять этой переставить вычисление оконный функция так чтобы лишних сортировок не было при этом надо понимать что если у нас секции эта вся таблица а вот как здесь здесь нету park shin боитесь секция вся таблица мы просто считаем и окно вся таблица мы просто считаем сумму по всей таблице добавляемые каждой строчке то нам таки нужно прочитать всю stable су для того чтобы дать первую строку то есть оконная функция может быть достаточно дорогой если вы не думаете о том как на выполняется помимо вот этой временные таблицы которые нужно в общем случае нужно еще буфер окна для того чтобы хранить в памяти значение которое входят в текущее окно есть окно большое то они приходится использовать диск при каждом передвижение окна до при каждой при обработке каждой строке этот буфер окна как бы движется и содержимое его обновляется есть некая некий оконные функции для которую буфер окна не нужен потому что мы можем запомнить некое состояние для этой функции и просто смотреть на текущую строку и это от всего окна нам даст результат ну например номер строки или ранг не требует на самом деле не требует вот этого буфера окна вообще это так называемую потоку и функция или например вычисления суммы зарплаты на самом деле вот для растущего в верхней границы буфер окна тоже не требует ну правильно по просто берем значение зарплаты для текущей строки добавляем его к общей сумме зарплаты вот у нас этот кумулятивная сумма зарплаты получается все просто то есть потоковых это такая функция окна и типа функции есть не как некоторые функции оконные которые в принципе требует буффера вот так unten на и распределение сумма по все секции да то есть без растущей верхней границы ли нет буфер обязательно требуется как понять у вас вообще используется буфер окна или нет избавить текст explain форма джейсон в нем есть эта информация при вычислении аккорды функции вы торгуете использую вас временная таблица используйте любой фрактально используется есть некоторое количество оптимизации которые возможно но никто из них очевидно есть вас окно статическая да вот то есть сумму почти по всей таблице то значение можно вычислить единожды если окно растет как в предыдущем примере да вот эта сумма кумулятивная зарплата по всем сотрудникам то нам достаточно про править просто текущее значение не не нужно нам данные всего окна то есть вот как работает по такую функцию наконец если окно движущейся это можно применить вот такой трюк как инверсия действий у нас вот как здесь да у нас окно которое выдает все даты за месяц и мы считаем сумму от всех продаж за my sin зови за месяц нет нет извините везде считается сумма скользящая сумма за последние 22 месяца я понимаю то есть у нас опять же есть табличка продаж она группируется по датам и потом мы еще наводим группировку по месяцам и и все это делать еще и делаем на кнопку с состоящий из предыдущей строке текущей строке значит какая здесь идея дома для когда текущая строка попадает в окно мы просто добавляем это значение но когда какая-то строка выбывает из окна до предыдущей строка каждый раз выбывает из окна мы просто это значение вычитаем из нашей суммы и вроде все работает но есть некие тонкости как известно вычислений с плавающей точкой не совсем точны и нужно про них помните есть разные ручки при помощи которых это можно все покрутить какие еще можно дать практические рекомендации по поводу используя оконных функции во-первых исходит именованные окна они действительно проще читают запросы с ним новым окнами проще читаются и выполняются быстрее используйте где возможно по такую функцию потому что опять же они выполняются быстрее нужно помнить что функция максимин не поддерживает инверсию и соответственно если у вас в общем случае нет сортировки по значению который используется макс мир внутри окна то могут возникать проблемы с большими окнами ну в общем то все здесь видеть какое-то количество ссылок по которым можно почитать про обобщенно это личное выражение очень рекомендуют этот блок мы его коллега гильом абишева там 44 отдельной статьи о том как использовать рекурсивные табличные выражения что из этого может получиться опять же блог про оконной функция если какие-то вопросы задавайте спасибо спасибо за доклад открыть пожалуйста является ли когда мы объявляем partisan инструкция сортировки ордер buy после партий шинга иметь еду по пути собой ордер buy в иметь эту покойной функции да еще раз мы окна по какому-то порядку определяем правильно ну мы задаем ок значит мы сдаем квартиру мы создаем партию байда это округляет секцию и строй вас при этом есть у вас ордер buy клаус и нету вот в оконные управления койны функция то внутри этой секции строки не отсортированы да а если добавляетесь ордер buy clause то вы еще вот эти строки внутри сердца еще сортируйте получается можно секции не отсортированные делать вообще по таблице да можно делать ну как как секции они будут за счет того как это реализовано они будут отсортированы в таблице но порядка внутри секции не будет то есть в принципе можно придумать такую оконную функцию что вот она будет в каком-то случайном там порядке как у вас придется вычислять эту оконную функцию но действительно вот смотрите зачем вам нужен порядок если вы считаете суммарную за плату по отделу вот вы все равно хоть в каком порядке не складывайте эту суммарную за плату по отделу она все равно будет 1 этажа вот для кумулятивные зарплаты по отделу там порядок важен а для суммарной зарплаты по отделу у вас окно вся секция зачем там порядок например у вас кроме сервере на всех версиях ордер buy обязательная инструкция нет аура орды бани обязательно только вот если рамке окна range то есть ордер buy опционален хорошо вот а можно от вас спросить про обобщенное табличное выражение то есть отек моего референсы никто и сложный запрос и потом вам можно перес пользовать какой критерию там для планировщика например создать временную таблицу или прям использовать большой какое время жизни то есть вот как как-то можно предсказать я думаю ситуация я думаю что ответ это j это вот самый explain форма джейсон и он вам ответит подробно как как он там какие листики применяют знаешь там какие-то эвристики использоваться паду подробная не попалась то есть как бы стратегий бумаг для рекурсивных ну понятное дело всегда используйте материализации для обобщенного искажений которые не рекурсивные может быть и слияние и мать или зация и выбор происходит на основе некой эвристики лучше для каждой конкретной версии смотреть через xp джейсон как она там решает потому что там есть информация о том почему то есть понятно что для ситуации когда вот у вас 1 1 ссылка и при этом внешне условий сильный селективные то лучше использовать слияние а когда у вас много ссылок и внутренние условия сильно селективно ну понятно она будет стараться делать мать или за цию но вот граница этого это надо смотреть уже второй случай вот например вот мы сделали там первый запрос по ссылке потому что то еще посчитали и снова вернулись к старой ссылке она уже будет заново пересчитана или у меня есть какое-то время жизни я не очень понял я имею да вот если считать это почему табличных функций выражение как некую ссылку вот например это посчитали при помощи потом каких другой запрос сделали а потом снова вернулись к первому вот для более но смотрите вот это вообще на это обычное выражение это часть запроса то есть она для каждого запроса свое если у вас запрос вас продолжается то вы ссылаетесь на нем много раз это одно и то же выражение у него один тот же результат просто много ссылка вот представьте как вот если бы вы сделали прям create view перед вашим запросом на этот view много-много раз сослались а после сразу после этого этот бы view дрогнули понял спасибо дмитрий такой вопрос рассказывали циклы указывали две настройки два параметра по которым можно прервать зациклившись огров в этом случае если мы вылетаем при обработке запроса поэтом количеству итерации или по времени максимальной по времени максимальным обработки запроса мы что то на выходе получаем но по-моему ошибка выдается каких-то промежуточных рассчитанных да я думаешь потом отправлять еду и просто насколько я знаю морской проблема в том что если вы вы можете ли вы получить ошибку либо можете получить результат либо вы можете получить результаты варнинг вот я думаю что эта ошибка таня-то трешки хранятся в памяти или на диск сбрасываться как временно таблица ну там как всегда времени таблицы который начинается памяти на потом расширяется на диск то есть это как с производными таблицами которые вообще говоря на текущий момент создаются в памяти как таблица в памяти а потом она если она вырастает до больших размеров то переключается на диск и начинает работать на диске хорошо а если какие-то рекомендации или ограничения по количеству сытая подряд например есть какая-то проблема в оценке кардинально sti если у меня там больше пяти десяти цветы я хороший вопрос я думаю что там дело дефицит я просто вот те же самые проблемы что есть много табличек будете использовать запросе те же самую проблему то есть это не связано именно сети конкретно это связано просто с количеством табличек запросе то есть для вычислительной сети это просто вот такая специальная табличка ну если не считать вот эту историю с рекурсии но в случае с обычными таблицами мы получаем проблему с декартово произведение большим а если у нас это я маленькая декартова и много цветы иена мир 50 ну правильно выйти 50 сетей потом будете как-то использовать правильно если буду между ними их использовать по моей быстро не должно быть все просто то есть как бы здесь не должно быть никаких проблем я не верю что это кто-то там ты стильному что не будет ли деградация именно к оценке кардинально sti при большом количестве я почему она должна быть та я вас спрашиваю я не думал просто лажи 5 вас же есть есть цепочка ссылок да они между собой друг друга как это использует то все равно как бы последний запрос будет использовать финальный запрос будет не всей сети будут использовать немного видимо то есть либо мы приходим ситуацию когда у нас запрос который использует много много много сети и и одновременно в одном joy не там проблемы с одним джоном либо у нас и все те проблемы когда вы много много табличек в одном джонни используйте либо у нас много много много много сети но они как-то друг другу по очереди используют и там просто поставить на вычисление без крикливую такие проблемы может быть максимум что одновременно будет использоваться потребуется хранить результаты до конца запроса но тоже здесь не уверен возможно подчищает там как-то хорошо если что спрашивайте в кларк спасибо"
}