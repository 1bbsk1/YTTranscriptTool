{
  "video_id": "NHEPUzr3nBs",
  "channel": "HighLoadChannel",
  "title": "Расширяем Go: зачем и как строить свое надмножество языка / Илья Горкун",
  "views": 318,
  "duration": 2890,
  "published": "2025-01-17T02:29:30-08:00",
  "text": "Всем привет Меня зовут Ир куны Илья и сегодня я с вами попытаюсь поговорить на такую довольно странную нетривиальную тему но почему бы и нет расширяем возможность языка го Как добавить в него какой-то новый синтаксис сахар возможно вам чего-то не хватает всё-таки язык довольно такой минималистичный красивый но может быть вы не хотите от него отказываться И вам нужно что-то более-менее интересное а немножечко о себе пишу Наго Уже довольно так сказать давно Ну блин Мне 25 лет давно звучит довольно странно Ну пусть так будет и скорее всего я делаю Это какие-то бизнес-задачи гоняю на Дже сончик исполняем какие-то бизнес фичи и иногда хочется чего-то такого более-менее зубодробительный на работе чтобы о них рассказать и также такой маленький забавный факт о себе надеюсь что через 25 лет у меня будет Своя ферма с гусями курицами с репко и картошкой и скорее всего я буду выступать на другой конференции где уже можно будет рассказывать как вырастить катой кабачок и вы купите у меня курицу на рынке и также хочу Огромное спасибо сказать эдгару я его не вижу возможно он чем-то занят Но я скажу ему Огромное спасибо потому что раз это человек который уговорил меня не сливаться с конференции и допили доклад и вял часть работы и помог мне допили необходимые компоненты данного проекта в виде сила и инфраструктуры огромное ему Спасибо за это маленький дисклеймер ме наша тема сегодняшнего доклада находится в теме такого холивар то есть мы пока не имеем какого-то точного мнения того нужно ли вообще это Потому что когда я говорю своим друзьям коллегам знаете я вот рассказываю доклад про то что можно как-то расширять язык го мне говорят блин какая-то дичь или другие говорят блин прикольная штука можно поупа какую-нибудь прикольную штуку родить Поэтому если у вас есть какая-то мнение отзыв по этому поводу положительный отрицательный нейтральный то часть Я готов выслушать у нас сегодня на секции вопросы и ответы часть Welcome Давайте обсудим с вами потом уже после конференции и также я условно доступен 24.7 Поэтому если есть желание то пишите мне на почту в Telegram без проблем А сегодня мы поговорим просто про фантазию авторов то есть мою фантазию фантазию Эдгара как В целом это можно построить и как с этим можно работать а сочники вдохновения всё-таки Нужно же как-то было эту идею родить зарождаются на том что А в прошлом году л Подольский сделал довольно прикольный доклад посвящённый тому как можно расширять компилятор с помощью кода генерации на таком более высоком уровне То есть как добавлять какие-то утилиты какие-то бизнес штуки и так далее Это довольно было интересно и я подумал а почему бы подобное не сделать но только чуть-чуть больше хардвер добавить Почему бы и нет и также есть очень крутой доклад даже не доклад документальный фильм от ребята которые сняли про typescript 2 часа годного контента о том как ребята пилили свой тайпскрипт к него тенили как него в и так далее То есть кому нравится документалки про it это прямо Огонь 2 часа вечером в пятницу можно потратить и кайфануть ну и также само собой идея расширения языка она не Нова То есть существует Уже довольно такая популярная практика и кажется уже лет нано 40 или 50 когда на основе одного языка Вы можете пилить другой язык и это стало размышлять А почему в целом такое происходит понял что есть какие-то две основные причины почему это может быть первая причина Ну вам всё нравится вам нравится его инфраструктура нравится его ранта но по какой-то причине вот вам не хватает чего-то либо не нравится то есть який пример допустим является Илан Лан крутой язык у него очень крутая Лан машина выполняет довольно хорошие задачи под свои какие-то конкретные кейсы Но вот Лан выглядит довольно странно Извините те кто пишет на Ирлан возможно кого-то я обидел Но он такой немножечко диковатый язык по сравнению с языками которые существуют сейчас на рынке и в какой-то момент Понятно люди на основе этого сделали Эликсир который выглядит более-менее читабельно Понятно поэтому многие те же рубис переходят на Эликсир этого кайфуют проще набирать людей для разработки и так далее но при этом также он исполняется на Лан машине И все счастливы вполне и второй кейс - это когда вы Ender Log То есть вы уже сейчас находитесь в таком состоянии что от этого языка отказаться невозможно хороший кейс допустим JavaScript то есть в какой-то момент язык так сильно пропитал веб что взять новый язык и говорить Давайте писать Теперь будем Web на нём Ну как будто звучит уже как безумно то есть вспомним ситуации с дартом Который изначально был создан Для того чтобы фигачит на нём фронтенд и по факту у них не получилось Да и язык умер И переродился уже потом во фларе и JS остался по факту как Да понятно потом ребята придумали тайпскрипт немножечко отходя от ситуации но такая вот мотивация довольно есть и Я вот подумал куда вот допустим запихать мой кейс и подумал что скорее всего этот кейс помогает попадает во вторую секцию то есть Нам нравится го нравится его инфраструктура нравятся его планировщик нравятся горутины Ну вот не хватает какого-то допустим синтетического сахара не хватает там не знаю допустим кому-то лично нных операторов или ги намо стрелочных функций или какой-нибудь подобное ерунды и скорее всего писать собственный язык программирование Ну какое-то безумство то есть вряд ли вы сделаете Что лучше чем сделали ребята из Гугла написать свой планировщик рутины и всё остальное но попробовать его расширить с возможностью чтобы потом это исполнилось на го инфраструктуре скорее всего Можно попробовать и Давайте попробуем разрушить правила того что язык го довольно минималистичный и сделаем что-то в этом своём духе как Мы это сделаем но Конечно нужна Идея то есть сегодня я предлагаю вам добавить рный оператор то есть чтобы в языке го он был его в языке го Нет его Скорее сего не будет потому что языки документации даже на сайте сказано что ребята ный оператор мы не заведём никогда то есть и кому-то интересно то на gorg ото Expression можно будет найти причину Я лично не помню но можете почитать И поэтому это идеально сегодня такой конт на то чтобы Давайте его сделаем и перед тем как мы нанм делать нам нужна такая маленькая базовая часть таки у нас сегодня пойдёт с вами разговор про АСТ про токены про транспирацию компиляцию возможно кто-то знает что это такое там из Универа или из работы кто-то может не знает я попробую освежить знания тех кто знает Те кто не знает Дать маленький экскурс чтобы Вам не было никакой проблемы меня понимать вообще этапы работы компилятора они довольно сложные их довольно много И как ни странно говорить что всё начинается со слова то есть сначала было слово это некий файл где возможно много других слов а потенциально они должны выражать ваш синтаксис языка го а по факту они строятся на каком-то неком алфавите то есть там где есть некие символы есть некоторые буковки Циферки и они скорее всего с какой-то большой вероятностью должны выстроиться в синтаксис Go который потом может быть правильно исполниться И после этого он должен пройти в этап этой тонизация либо его ещё называют в русской литературе лексический анализ либо здесь он указан как лексер это тогда Когда вы пытаетесь ваши лексемы эту кашу которую вы сейчас написали в файле превратить во что-то более-менее адекватное уже похожее для вашего компилятора это называется кены то есть кены - это уже какие-то специальные идентификаторы позволяющие вам с ними взаимодействовать и как-то уже валидировать что действительно то что вы написали в вашем коде удовлетворяет конфигурации синтаксис языка Go и потом происходит сканер либо его ещё называют в России синтактический анализ тогда когда вы берте ваши токены токены по факту это такая Линейная структура То есть никто не мешает вам по факту написать Ваш код превратить его в токены это такое будет полотно из различных символов либо набора символов И вот так его вытянуть и потом перестроить его в древовидную структуру которая называется АСТ либо абстрактно эстетическое дерево Она более понятная во-первых для взаимодействия уже компилятора она более удобная для того чтобы разработчику самому понимать как с ними манипулировать Но кто не понимает что такое ST у нас ещё будет пару слайдов но в целом а это поставьте себе У вас есть выражение А + 3 допустим и вот вы его строите из него из линейной в древовидный То есть у вас плюсик будет на вершине и по бокам то есть листья этого дерева это будет а и три из этого уже сразу понимаем что происходит Мы Ага операция плюс и потом уже какие-то видимо должны идти У неё бинарные её элементы вот а и три и потом происходит у нас фаза тайп чекера То есть когда мы всё-таки проверяем то есть а когда построилась из токенов оно не гарантирует вам о то что то что вы написали оно валидно Да с точки зрения какого-то синтаксиса то что вы допустим правильно описали функцию либо мапу либо что-то ещё Да всё О'кей работает правильно но никто У вас не гарантирует что допустим вы написали функцию которая по сигнатуре должна принимать int а на деле в неё вкладывается string То есть у неё узел который от неё находится это стринг А на этапе сканера Никто вам не скажет то есть это уже будет происходить дальше когда у вас будет происходить проверка ваших типов что О'кей я правильно вкладываю НГ в функцию потому что реально функция по сигнатуре принимает стринг и тут уже тайп чеке Вам скажет Ага О'кей не о'кей идём дальше и не дальше И вообще у нас существует огромное количество других этапов того как у нас компилятор пытается с вашим кодом работать он его оптимизирует он его Линку ет выбирает что-то ненужное В общем огромное количество других операций которые скорее всего у вас э возможно получится сделать но очень много времени это уйдёт сделаете Вы лучше возможно возможно и нет но зачем нам запаривать Давайте всё-таки попробуем взять какую-то часть ту часть которая нам более-менее понятна так Ой почему-то у меня он зелёненький не выделяется А выделился да которая вам не понятно но при этом с ней просто работать то есть с токенами АСТ Ну и всё остальное отдадим уже на заслугу компилятор Go Пусть сам он этим занимается нас это уже не интересует Ещё раз чтобы запомнить токены - это по факту у нас набор различных идентификаторов которые у нас порождаются после лексического анализа за основе которые берут после этого то есть допустим Вот пример кенов то есть допустим у нас есть конструкция а ра 3 и мы Превращаем её вот такой вот набор идентификаторов то есть который говорит Ага То есть тут возможно будет определение переменной идентификатор название переменной А это Какая операция у нас будет происходить потому что в основном у нас операции равно больше плюс минус Они у нас не имеют своего одного такого математического названия они обычно называются Как слово и потом у нас идт потенциальное значение кото хотим присвоить в нашу переменную То есть это у нас может быть int какой-то другой тип обычно на таком этапе у нас пытается компилятор предугадать всё-таки что вы в него запихнули не там не строку не FL а допустим вот int или Number в зависимости от языка на котором вы программируется и после этого мы пытаемся эту идею лизированные в чистом виде Можно я прямо взял из Википедии чтобы посмотреть как она себя ведёт то есть да это вот ваш код который по факту щается в такое дерево Где у вас каждая операция она входит в другую операцию и мы проу понимаем что у нас а есть вершинка она зависит от своих дочерних вершинок тебя зависит от других и таким образом мы собираем нашу программу из таких вот кирпичиков и самое классное что в языке го у нас есть для этого всё необходимое то есть в языке го есть отличные библиотеки пакеты которые находятся у нас в СТД ими можно пользоваться и уже взаимодействовать с сст наверное кто-то даже этим пользовался а на этом примере у нас есть функция par File которая у нас довольно часто будет использоваться у нас в на докладе А это функция которая принимает себе файл либо строку то есть в нашем случае допустим это стринга с кодом package Main ра 3 и пытаются его превратить в АСТ дерево которое после этого выводится на экран но как вы понимаете что любая древовидная структура ссылочная она не как нормально на экран не выведется поэтому для того чтобы сделать это более-менее удобно и приятно можно использовать вот такой прикольный пакет с который мы вызываем через функцию Dump И после этого мы отображая наше а представьте себе что вот мы написали такую маленькую программку как package warr внутри А у нас во-первых это Не влезло на слайд У нас есть Многоточие Чтобы показать что у нас там ещё гого много-то генов и можно увидеть в целом как наша программа себя ведёт вообще если вы хотите понять вот я для себя так эмпирически вывел понять в целом как А в Go работает то есть со своими специальными типами нодами какие там есть поля и всё остальное То я просто вам советую написать пару програм каких-нибудь простенькие где по факту выражаются все необходимые ческие какие-то идей языка го пособирать их прос файлам вст и поводить на экран мне в целом этого хватило для того чтобы примерно понять что у нас как го живёт Какие токены за что отвечают кино за что отвечают какие у них есть поля и так далее и на основе этого уже я делал дальнейшую работу Поэтому если вам нужно то и на основе этого когда я посмотрел пару раз на шке я подумал Ага У нас есть АСТ это по факту у нас стре видная структура со своими типами А что если мы не возьмём и просто не подмени некоторые узлы некоторые ноды на свои ноды Таким образом мы возьмём их поработаем Как нам нужно опять выведем их в АСТ который понимает го и отдадим допустим нап чеке другие оптимизаторы чтобы Допустим можно уже было как-то наш код потом исполнять но при этом когда мы будем строить файл Мы построим Свои токены Свои аэш и с ними будем взаимодействовать таким образом мы уже можем расширять наш язык Go И как я говорил сегодня мы с вами попробуем сделать ный оператор но возьмём самые простые mixman in string чтобы можно было это реализовать сейчас такой Так кто не знал что такое титаны оператор Тины оператор такая вот конструкция довольно очень простая и удобная и таким образом можно выражать что вот если выполнялось одно условие то получаем А если выполнило противоположные условия решаем B довольно всё просто такая немножечко научно докладная идея такой слайд у нас Уго нет тено оператора Мы хотим сделать его легко без боли то есть мы не хотим делать свой компилятор и поэтому самый подобный вариант как это можно реализовать - это использовать транспирацию Что такое транспирация Это довольно простая идея которая можно взять за основе в typescript как он работает typescript у вас есть какой-то некий синтаксис где есть различные какие-то операции и всё остальное чего не существует в жава скрипте то есть допустим какие-то приватные поля реальные типы какие-то ещё более другие дженерики там интерфейсы всему подобное и они аккуратно выводятся языком JavaScript и уже собираются в конкретный файл JavaScript который допустим там V8 может исполнять либо в браузере либо вот на дсе где вам что-то нужно а и мы сделаем примерно то же самое то есть мы возьмём некий файл где у нас будет чуть-чуть больше синтаксиса чем в языке Go то есть допу ветеринарный оператор и попробуем его закинуть в наш транспит он из-за одного АСТ Прити другое и таким образом построит А который знает Go И отдаст его там тачер и все остальные операции первая идея которая появилась И я такой возможно она стрельнет Возможно всё так будет Просто что я прям Ох доклад прям будет наян Я просто тупо возьму зафи чу ный оператор возможно после этого примен пас файл он у меня как-то там сработает построит шное дерево потенциально Я верил что существует какой-нибудь undef либо я точ не смотрел исходники АСТ и Уля я получу ка просто его там превращу потом уже в серию наборов узлов то есть получу родной реальный АСТ отправлю его дальше но если мы так сделаем мы получим ошибку почему это так происходит довольно просто объяснить вообще когда мы делаем эп низации тонизация - это по факту набор регулярных выражений каждом та поставляется собой регулярное выражение оно у нас применяется пытается вытаскивать из ших файлов различные токены и в идеальном мире Если у вас код написан корректно в вашем как бы файле условно ничего не должно остаться всё должно покрыться токенами Но если у вас есть токен который допустим у вас регулярным окружением не покрывается то есть допустим вопросик это уже что-то странное для языка го то М кидает такую ошибку потому что ну что такое подозрительное я такое точно не могу найти см в регулярных выражениях Поэтому такая идея у нас не приходит вход мы идм дальше и появись сама такая простая идея Блин у нас же есть комментарии и теги это же такая универсальная идея как мы можем расширять свои какие-то решения то есть если мы хотим не знаю сделать моки то делаем комментарии помечает сделать тесты тоже комментарии хотим сделать маршале на маршале Бинго можно тоже тегами всё это помочь покрыть и первая идея чтобы особенно не париться не лазить никак в фиксить или править АСТ и токены которые есть в языке Go самый простой вариант давайте сделаем вот такую конструкцию то есть по факту Да у нас есть функция допустим Макс которая принимает целые числа а даёт тоже целое число и мы за фигачит наны оператор в такую вот коментар ную структуру этот код Как вы можете понять он валиден для компилятора Go но при этом мы даём понять что Ага вот то есть у нас есть переменная рез она должна быть типа in и у нас есть комментарий который по факту Элит рный оператор и таким образом возвращает всё довольно валидно попробуем с ним работать К сожалению или к счастью дефолтный пас файл у нас не умеет взаимодействовать с комментариями ему нужно это показать для этого у нас есть флаг com который говорит нашем пас файлу который будет строить а на основе нашего кода что пожалуйста комментарии Не игнорируй добавляй их в в нужные ноды нужные поля чтобы Мы их видели смогли с ними взаимодействовать Таким образом мы получаем уже где есть коментарий как реальная сущность элемента И после этого возм самый популярный кажется паттерн для такого вот кейса - это визитёр пройдёмся по нашей дро видной структуре найдём необходимые нам элементи поправим пофиксить поправим изменим на нужные нам ноды и таким образом получим валидные СТ уже с новым кодом то есть там где уже допустим ный оператор превращается вот что более-менее знакомое для го и в Go уже есть существуют необходимые нам Визитёры допустим это а inspect он работает довольно просто вы в него кидаете вершину с которой начинает стартовать и даёте функцию которая должна делать какую-то логику когда итерируемый вызывал другой коллбэк и такая была страшная структур где вообще можно было ногу сломать непонятно где Какие скобочки какие функции и так далее А примерно такое У меня возникла почему она возникла Ну потому что наша а это как я сказал это у нас дерево дерево имеет вершинки и каждая вершинка по факту это некая структура которая имплементировать интерфейс node not это такой знаете я бы сказал А вот если есть в Джаве object Да и от него все наследуется чтобы иметь какие-то базовые его методы и поля то в контексте а Note - это такая знаете базовая первоначальная сущность которая вот без неё никуда она должна быть потому что она нам позволяет понять всё-таки где размещается наш так наша нода уже в самом коде Как видите у неё есть по и end позволяющие нам как бы понять Ага где это файли у нас находится Да у нас есть вспомогательные ещё интерфейсы которые наследуют интерфейс Note то есть Expression это у нас получаются различные вызовы функций допустим логических условий есть некие стейтмент это у нас блоки вашего кода но они все у нас имеют видите по факту скудный набор каких-то параметров функций а нам нужно больше нам нужны различные метаданные которые допустим имеют некие типы имеют нам какие-то комментарии те самые которые мы будем сегодня использовать для того чтобы можно было строить нный оператор и всего этого здесь нет потому что это всё интерфейс и скорее всего вы будете заниматься Type аршином Потому что никуда без этого никуда и у вас возникает такая довольно страшная система Когда у вас возникает много иов они все вложены возможно какой-то НОД есть допустим список у неё тоже есть список НОД их тоже нужно перевести необходимому типу и возникает такая вот лабуда что которую Как с ней жить а появилось две идеи как это можно исправить первый вариант Довольно простой довольно часто стало встречать в коде где люди активно используют дженерики он такой называется канот когда мы определяем какой-то дефолтный Тип который хотим Сейчас привести если мы его приводим то всё круто мы его возвращаем с флагом True Если нет то возвращаем по факту дефолтный Тип который хотели привести и возвращать false на основе этого мы эту структуру вытягиваем из такой лестничной структуры в линейную и имеем такой Error Ne like Style и ещё можно задуматься что на самом деле вот этот инспектор который у нас ходит по всем нашим нодамэ много чего лишнего Да инспектор - это вот та сущность которая ходит по всем необходимым нодамэ мами инкремента декремента и всему остальному потому что мы решили что у нас вс-таки тельный оператор может быть только в комментарии при Варе и больше нет и поэтому мы можем просто взять написать собственный такой инспектор и уже в нём добавить свои какие-то правила того в какие мы будем посещать ноды какие мы не будем посещать то есть допустим мы понимаем что ага потенциально НКТ у нас внутри нашего функции B может быть War поэтому мы её оставим то есть всё-таки такое пропускать нельзя Но если мы допустим мы имеем какие-то унарные экспрешены бинарные экспрешены инкремент декремент но там точно у нас не будет потому что мы договорились по сигнатуре что там мы не определяем ный оператор поэтому мы просто их скипа и таким образом мы избавляемся от ненужных нам такой вот личностной структуры и также Вот оставляем только те необходимые походы в узлы которые действительно потенциально могут нам помочь реализовать нужные нам вещи и таким образом Когда мы уже будем запускать нашу программу она будет у нас бегать по нашим файли ком она будет находить необходимый наст по нему также ходить доходить до определения нашего Вара находить Наш текст там находить комментарий находить экспрешн потенциальный который у может быть этот экспрешн мы потенциально будем превращать уже в также в наш нодовый компонент предлагаю для простоты взять и превращать наш Expression в анонимную функцию которая сразу будет в себя вызываться внутри у неё будут находиться различные компоненты допустим If else и так далее и она уже будет взаимодействовать То есть она не будет иметь название только тип того что она будет возвращать и также она просто будет из замыкания сверху брать необходимые нам переменные чтобы с ними взаимодействовать таким образом она их будет узнавать и ими пользоваться внутри боди у нас будет сама логика происходить и else и таким образом мы имеем нам необходимую сущность как Expression но он довольно неудобен потому что по факту сейчас это у нас такой набор файлов с функциями которые умеют что-то делать давайте это более-менее красиво оберн силу инкапсулированные нам места и таким образом будем вызывать где-то в Едином месте в идеале картина должна быть работать так что вот система которую мы строим Да я не навал как она называется называется его его то у нас есть набор плагинов каждый плагин - это конкретный какой-то либо Макс ещё можно его назвать Это какая-то новая тическая идея которая у нас умеет превращать наш касто АСТ в нужно нам АСТ с нужным эквивалентом нашего выражения Вот и мы его вызываем то есть по с логике это работает Так мы берём наш СТ точнее мы берём наш файл мы читаем его создаём вст после этого пробегаю по нашим плагинам которые у нас сейчас есть в нашей системе каждый плагин у нас должен иметь публичную функцию деген это по факту у нас такой вот а некий интерфейс с оним по факту функцией вот и она у нас принимает АСТ который мы сейчас хотим изменить и отдаёт нам пропан ST с флагом того что был он изменён либо не был изменён и с ошибкой Ну куда же без этого всё-таки нужно понимать какие-то косяк у нас может быть скорее всего Всё может быть а вот и демо Как это работает допустим просто на примере кода А да у нас есть допустим тот же Макс вот с той самой сигнатуры которую мы определили И если мы применим наш макрос то мы его разворачиваем по факту В анонимный вызов вот функция сразу вызывается пробрасывается в рез мы отдаём выглядит конечно тот код который скорее всего вы не напишете Но если ваш коллега напишет то скорее всего вы скажете ай-ай-ай на ревью Давай по-другому Но таким образом мы можем унифицировать такие вот вызовы внутри уже нашей функции анонимной уже какие-то логические цепочки строить также можем сделать с мином можем сделать с любым типом потому что нам никак неважно что мы передаём Главное чтобы у нас по факту типы совпадали с результатом То есть как у нас рес определяется и чтобы наши функция точнее наши типы умели операцию сравнения Да больше меньше или равно и пожалуй всё остальное делает за нас сам уже плагин Вот тоже вот разворачивается он вот такую вот анонимную структур А ну какой-то момент мы осознали что Ах как-то неудобно получается выглядит довольно как-то нагромождать какие-то боковые файлы которые скорее всего очень некрасивые Скорее всего вы их не будете применять вот как-то сохранять кае конфликты могут вас создаваться в общем какой-то ужас и было бы прикольно если бы они скрывались от целевого пользователя То есть он просто бы вызывал Код Этот код бы просто исполнялся и давал необходимый нам ответ в этот момент мы подумали вообще Я даже не знал что такое есть overlay кто знал что такое overlay до этого Спасибо Данил вот Данил мне рассказал про ве Да довольно крутая штука как она работает представьте себе Вот в контексте того что у нас есть Представьте себе что у нас есть код наш код - это тот который вот имеет странный синтаксис синтаксис который довольно то не выполняет то чего мы хотим точки зрения обычного компилятора Go для этого да мы должны его превратить в код который бы исполнялся Go и он бы работал бы валидно выполнял нужную нам логику он создаёт лишние файлы overlay позволяет нам сделать очень простую вещь Он позволяет нам создать некие такую временную директорию Temp Dear в неё закинуть временные файлы эти файлики Мы в них сохраним наш код с этим странными анонимными функциями и мы сразу его вызовем вызовем получим необходимый нам результат и эти файлики удалим то есть с точки зрения пользователя он просто вызвал команду которая исполнила код странным синтаксисом этот синтаксис завёлся отработал Всё круто пользователь увидел на экране нужные намм вещи а у нас есть маленькая демка Как это работает а вот смотрите у нас есть наши функции Max Min и мы пытаемся меном вывести то что на экран у нас там пять или шесть или мин или Макс А мы запускаем с обычным допустим нашим компилятором вводим ноль Ну логично потому что у нас рес - это дефолтное значение это ноль поэтому ничего нового Мы не получаем мы пытаемся теперь это исполнить через overlay Таким образом у нас под капотом остаются необходимый нам временные директории уже с нашим развёрнутым кодом и таким образом мы исполняем его сразу получаем но как видите у нас в ничего нету в нашем проекте никаких лишних файлов Всё остаётся с точки зрения пользователя и вызова как будто ничего нет всё красивенько просто вызвали и не паримся таким образом взаимодействуем с этим уже Как Вот почти таким псевдо оператором и в какой-то момент когда я написал такие вот вещи я подумал Ну это прикольно выглядит но всё-таки это не трушно то есть трушно было бы если мы реально взяли бы с добавили необходимые токены потом ноды которые есть для того чтобы с ними взаимодействовать и потом как-то с ними всё-таки бы баловались тем более нужно понимать что комментарии - это не Самый подходящий вариант для того чтобы реализовывать всё что мы хотим да такие вот вещи как expr ну потенциально можно если мы хотим работать не знаю со структурами либо там допустим с какими-то другими ещ сущностями в языке го возможно как-то можно на компилятора комментариях что-то на кодить Но это будет выглядеть довольно страшно криво Костыль В общем всё-таки идея что нам нужно вс-таки заводить Реальные токены реальные ноды в наш код всё-таки хотелось бы и допустим дженерики хайповая тема по хайпом сегодня опять Почему бы и нет вс-таки вот хороший кейс того что у на есть допустим функци сигнатуре её да либо в в структуре У нас есть какой-то обобщённый Тип и Давайте определим его синтаксис всё-таки без этого нам никуда а синтаксис в нашем будет случае выглядеть довольно просто у нас будет самая типичная сигнатура где мы определим такой вот Type Т это вот такой самый общий Тип и будем с ним взаимодействовать Да у нас есть какая-то функция maper которая просто проходится по нашему слайс вот этого обобщённых элементов и как-то их конверти записывает и отдаёт их дальше таким образом Мы с ними взаимодействуем и в идеале Когда мы это скомпилированный Таны не вводили мы просто добавили тан туда где он всё-таки не может существовать А мы получим что-то вот вроде такого Map in string То есть у нас где-то функция вызывала с МАПО где-то внм пробрасывается int где-то ожидался рин а наш Яго это заметил а проверил построил необходимую нам вспомогательную функцию которая уже явно работает с нашими нужными типами и записал его где-то либо исполнил Оле без разницы это чем-то напоминает то что сейчас существует в языке го то есть G shap то есть мы строим только то что нам действительно необходимы то есть только те типы которые у нас реально используются в нашем проекте то есть мы не строим допустим там flout на in если нам это действительно не нужно вот тут тоже самое И работает и я думал думал думал как всё-таки это сделать как всё-таки подружить нашу функцию чтобы она принимала Type т в сигнатуре и не кидала мне ошибку и в какой-то момент осознал то что к сожалению пока без форкаст не обойтись То есть я никаких других идей не придумал и что это происходит у нас есть пакет АСТ и есть серия пакетов которые взаимодействуют с А да тоже parer там types и так далее и они у нас имеют все необходимые нам токены все необходимые сущности которые умеют токенами работать умеют их парсить строить из них ноды и всему тому подобное и вот мы берём их тоже парс с ними как-то балуемся понятно что у нас все эти пакеты они зависят друг от друга то есть они такие не самодостаточные поэтому в идеальный момент это просто было взять а и Internal которые существуют в вашем го то есть допустим на момент создания Я использовал Go 1222 поэтому пришлось прокинуть всё что у меня есть что просто поменять импорты чтобы они теперь смотрели на мои скачанные импорты моего пакетов и также уже в них поработать добавить необходимые мне токены добавить необходимые типы и так так далее и уже взаимодействовать а Единственный косяк такой ситуации в том что сейчас если допустим вы попробуете запустить не знаю по какой-то причине у вас используете старые там го версию там А там не знаю разница го пакетов в 122 и в 110 она колоссальная и с большой вероятностью у вас возникнет проблемы на исполнении тоже такие моменты нужно улавливать смотреть пока не понимаю как это можно поправить но как появится то расскажу и теперь г как бы полностью властны над пакетами мы можем без проблем взять и добавить нам необходимые новые ноды вспомогательные какие-то структуры и всему подобное и уже с ними как-то взаимодействовать Когда мы уже будем разбирать наш необходимый код вообще если посмотреть на любые вот прикольно было посмотреть как работает парсинг ваших файлов в необходимые нам токены И уже потом в ноды то это обычно всё совмещается вместе в языке го это не такие явные какие-то регулярные выражения И когда в целом Я думал что как работают такие вещи я думал что это как-то странно когда ты ходишь в форум по циклу по элемента там индексируется и пытаешься достать необходимые токены ожидая после этого токена найти другой токен Ну вот допустим Если посмотреть на этот код то я думаю что он вам окажется довольно более-менее знакомым тут есть довольно знакомые вам слова как sent receive ER CH это как бы намекает на то что по факту это определение с точки зрения синтаксиса а определения канала Да где мы говорим что это за канал какой они Тип и имеет так далее И вот в конце тут не очно удачно получилось а у нас есть такая функция как par Type То есть это функция которая у нас пытается определить всё-таки Да мы там с точки зрения токенов мы там правильно определили структуру да Что ага там скобочка стрелочка А всё это есть а ещё мы должны Определить всё-таки тип у этого канала допустим И не только может быть канал это может быть любая сущность которая должна иметь тип то есть допустим сигнатура функции либо допустим структура а неважно и самый простой вариант как это можно сделать Давайте просто да добавим в необходимые нам вещи где у нас происходит работа с типами мы добавим А логику парсинга так потому что понятно что тайп сейчас у нас работает так Ага У нас странный тайп этот тайп идёт по сигнатуре довольно выглядит это некорректно поэтому мы будем говорить Так что если мы прикидывать Flag generic и у нас потом происходит уже проход по необходимым токенам и в нашим сигнатуре мы включаем token Type и у нас genic O True то это как-то валидно теперь в нашем коде будет и таким образом мы это будем правильно интерпретировать добавлять необходимые ноды и таким образом будем это уже использовать если у нас невалидный код и у нас generic Ox True Значит мы нарушили наши правила синтаксиса и таким образом пожалуйста Давай поправим сделаем всё это валидно и также Теперь мы имеем уже кастомный свой АСТ этот АСТ также нужно теперь правильно перевести в нужный нам код для этого мы используем по факту такой кастомный конвертер который просто в глубину проходит по всем нашим нодамэ же безумно не нужны то есть да какие-то стейтмент импорты то есть там у нас точно не может быть никаких типов для дженериков мы их скипа Ну вот допустим какой-нибудь Call Expression это у нас по факту вызов функции потенциально может иметь необходимые нам какие-то сигнатуры определённо может иметь какие-то наши типы Поэтому если мы находим такую ноду где у нас есть потенциальный Call Expression то давайте мы конечно пройдёмся по нему А посмотрим всё-таки какие у него есть дженерики какие-то компоненты и попробуем на основе них построить уже новый А нам который уже будет валиден для того чтобы его исполнять на нашем коде и также как помните мы сделали с МАПО что мы мапу превратили уже по названию в Map in string Мы также будем их помечать то есть допустим на примере к если мы видим допустим да что наша структура Она имеет Женек тип то мы ещё в ней нейминг поправим чтобы она выглядела более-менее валидно и симпатично на основе этого хочу сделать пару выводов во-первых что мыли платформу которая у нас смогла брать некоторые пакеты расширить синтаксис и таким образом завести язык тоже Чего нет в языке на данный момент мы имеем пару костылей в виде форка АСТ где нужно просто всё завозить при том что возможно есть какие-то косяки обратной совместимости также overlay у нас может быть не очень Сири потому что overlay по факту у нас может Пать не только то что мы хотим Но ещё по факту всё что угодно что вы ему скажете тоже не осо безопасно и скорее всего когда эти вещи будут поправления появится в открытом доступе на гитхабе либо где-нибудь ещё на этом У меня всё спасибо за внимание Если есть какие-то вопросы то сейчас мы их услышим а также буду рад отзывам по поводу моего доклада Спасибо большое спасибо большое Илья Есть ли вопросы в зале Если у вас есть вопрос поднимите пожалуйста высо руку задавайте вопрос свой в микрофон мы к вам подойдём и вы сможете задать вопрос Давайте Спасибо за доклад было прямо интересно вот в Гош одна из важнейших фич - это то что компиляция происходит очень быстро пробовали замерять как она как время изменяется для Ну мы пробовали Только по факту напе и по факту на том что вот получалось на дженерика по факту это разворачивается в тот синтаксис который Вам нужен и скорее всего это никак Ну не сильно не будет влиять потому что потом мы пойдём на другие этапы допустим компиляции да где там допустим уже какие-то лайны будут происходить всё остальное То есть по факту это никак не должно сильно уменьшать производительность потому что мы находимся в системе сикса которая есть в языке Поэтому если вы пишете плагин то вы без проблем Можете написать плагин так чтобы он разворачивался в какую-то более-менее оптимальную систему которая Ну будет спускаться довольно валидно поэтому скорее всего это либо вообще никак не будет влиять но либо влиять там на какую-то максимальную минимальную бесконечно малую Вот поэтому я не думаю что это сильно влияет Ага понял спасибо и второй маленький момент в провали копать в сторону таго потому что кажется с lvm будет взаимодействовать прямо попроще Да я думал про lvm это немножко тогда было Другой Мне кажется доклад Если бы я улм да То есть можно было взять какой-нибудь фнн какую-нибудь слону тузу да которая бы а я в неё запихнул все необходимые сигнатуры она сама всё бы сделала После этого я не знаю какой-нибудь там кн условно бы породил бы его вместе бы с го можно было попробовать Э но основная была идея - это всё-таки мы решили совестно на трансляции сделать такой AK typescript только с элементами Go чтобы можно было работать в системе типов Иса которые есть в языке то есть если ты что-то можешь вывести на языке Go и ты можешь это запрограммировать с точки зрения плагина то это круто значит ты это можешь использовать Если ты это сделать не можешь то сожалению никак уже не получится супер спасибо Следующий вопрос из зала Привет меня зовут Эдуард Илья Я когда-то тоже сталкивался с такой Темой хотел завести в шку Ну там какой-нибудь свой там оператор скажем так вот но конечном В итоге Ты знаешь как бы поскакав по кораблям то пришёл к тому что э э ковырялся в конечном итоге в компиляторе и и в компиляторе заводил пытался завести новый этот аргумент и уже а компилировать а компилятор который этот аргумент дальше там юзал и добавлял там в код там А там по разным файлам там Ээ как бы обработку и какое-то поведение Ну получалось не очень ну потому что как говорится терпения наверное не хватило но я к тому что как бы пришлось шагнуть ещё на шаг ниже как бы вот я не знаю ты думал про это не Ну вот основная была мысль что Давайте попробуем вот базироваться вот на тех четырёх этапах которые существуют компиляторе потому Ну то есть вот этот тайчер даже не будем брать то есть только ксир сканер потому что и так сложно То есть вы видели да что допустим вы сейчас рассказываете что вам прям в кишки залазить компилятора даже на моём этапе нужно было форка а а а прямо ну тьма Там прям есть и туду ки и фик СМИ и всё остальное сиди ковыряй се Разбирайся там прямо тяжело и просто пока в текущий момент довольно страшно допустим предлагать кому-то напиши собственный там какую-нибудь янам свой кастомный потому что чтобы его сделать нужно реально форкнуть АСТ разобраться как он работает найти место где это нужно написать добавить это и потом это уже запускать А в текущий момент да порог входов Таких вот вещей он довольно высокий и хочется в будущем как-то попробовать его уменьшить чтобы допустим да вот ты вот ещё раз захотел попробовать это сделать И у тебя это получилось и ты это сделал там как-то максимально быстро без там какого-то дикого компьютера Санса поэтому и также с минимальным каким-то взаимодействием с компилятором А слушай знаешь я как выкрутился Вот в этой ситуации потому что Ну действительно оче Я предлагаю это обсудить В дискуссионной зоне не не я просто скажу Может быть скажет что-то для всех остальных Я в библиотеке ранта а делал то что делает не оператор а именно уже обыкновенным там методами и прочим и как бы ээ Ну было похоже только не так красиво да там Спасибо большое Я думаю вам стоит встретиться в дискуссионной зоне и поболтать об этом тема интересная тему можно развернуть Там есть разные способы но очевидно Это должен быть диалог а не вопрос-ответ есть ли ещё вопросы в зале Давайте дадим возможность задать вопрос вспомнил а вот вспомнил студенчество Когда мы писали компилятор подмножество замечательное время было единственно кото генерации не освоил вопрос Следующий Вот внедрили вы какую-то новую языковую конструкцию через эту через ваш через ваш па Вы получили готовый бинарник и Вы захотели пот его вы там запускаете какую включаете ОТК скажем через и пройтись там по рейсу по шагам попои смот Какие переменные вот как справляется средство отладки с вашим новым кодом как он отображает трейс как он отображает переменные ничто там не ломается и так далее Потому что насколько я понял из примера с те оператором ты подменяет в таком случае отображаться в отладчике в конечном результате нула то есть анонимной функции то есть потому что ты сначала собираешь новый файл а потом уже его запускаешь Вот именно уже компилируется там Горан без разницы ты закладчиком ты уже взаимодействует именно с ним то есть уже с тем что породил сам его То есть ты не работаешь с тем фактом что ты там запускаешь и ты видишь как он там разворачивается либо не разворачивается То есть ты по факту получаешь просто уже продукт который ты уже исполняешь вот и всё супер спасибо Есть ли ещё вопросы в зале поднимите пожалуйста руки мы к вам подойдём с микрофоном вот в первом ряду есть вопросы да спасибо за доклад Вопрос такой А ты видишь какое-то практическое применение в этом Или это так поиграть Ну да это родилось потому что блин можно по фану что-то такое сделать но я пытался придумать какое-то тическое применение и пока у меня родилась только одна идея где-то можно применять у нас довольно много сейчас то есть у нас нетлан о на части опенсорс най Ты можешь зайти на github посмотреть само репозиторий там есть ию про полы всё ему подобное и часто человеки пишут такие Блин давайте добавим вот эку новую штуку Я вот тут тут уже почти эту штуку сделал вот завёл Давайте её езать и для того чтобы не знаю там нужен роду пайку посмотреть того как это заводится он должен взять репозитории взять себе ло кало попробовать запустить побаловаться поэкспериментировать и потом уже сделать вывод типа Оли Не ОК ещё реализацию посмотреть понятно как это происходит у него в кишках а одна из верей как это можно сделать допустим через его - это просто написать некий плагин его скачать и его запустить Да также побаловаться в коде то есть идеальный такой мир - это допустим упростить работу с прфн концептом различных новых фичей и типов которые будут появляться в языке Ну это понятно что при условии что тот чувак что делает он делает на этапе именно выводимой с точки зрения синтаксиса языка го Вот спасибо Следующий вопрос из зала а Привет вопрос Мора слышал про проект борго это проект по трансляции раз подобного синтаксиса вче вдохновении из этого так я не до конца Понял Вопрос Можете повторить пожалуйста может быть слышал про проект синтаксиса в го подобный в го а ну таких на самом деле много там которые в JS превращают JS всё остальное довольно популярное тема вот А може быть черпал Вдохновение из из каких-либо подобных Я некоторые подходы брал оттуда некоторые подходы в решении задач именно превращения одного из АСТ в другой АСТ Да были взяты оттуда потому что Ида просто был такой Инженерный тупик когда ты думаешь как это сделать ты начинаешь родить понятно по различным библиотекам в репозитория хабу и такой А ну тут можно вот взять допустим вот ну идею допустим сст что можно допустим по нему полностью не ходить а брать только то что нужно и Ну это не моя идея я её взял потому что это такой общий стандарт того как люди ходят и патча СТ это ну стандарт уже такой В разработке Таких вот вещей супер спасибо большое это был последний вопрос в сессии вопросы-ответы всё что не удалось обсудить здесь Давайте вынесем в дискуссионную зону дискуссионная зона находится сразу же слева входа докладчик туда отправится буквально сразу же после доклада Ну а теперь давай Илья выберем вопросы которые тебе понравились больше всего Давай для начала выберем вопрос и человека который получит матрёшку от онтика А да да давайте как всегда сложно когда у тебя оперативная память забита вопросами и ты не можешь вспомнить что те задавали первым Поэтому приходится как-то думать мне нравится вопрос про на самом деле про Давайте средство откладки довольно просто интересно Я даже об этом не задумывался То есть просто я сразу почему-то У меня флешбек был с йп скриптом что чуваки же это как-то умеют делать возможно имеет смысл попробовать сделать то же самое как-то разобраться можно ещё как-то ид ешку подружить с этим Поэтому да наверное матрёшку я дам средство откладки Спасибо большое подними пожалуйста руку не теряйся мы подарим тебе подарок не уходи пожалуйста Из зала А теперь давай выберем второй во человек получит подарок Лично от тебя Да у меня есть свой подарок вс-таки я Независимый Эксперт у меня компания жадная ничего не даёт но я лично не жадный поэтому я всем даю И как я упоминал что я хочу быть фермером у меня есть отличный товар То есть пока он не мой но я вот его взял поэтому за вопрос зачем вообще это всё нужно Я предлагаю отдать арбуз поэтому вс-таки хотелось бы обяснить пому для чего его можно применять я забыл сказать презентации Спасибо что это посвети И вот поэтому вам арбуз Александр Не ну ты будешь Катить его конечно до первого ряда докатиться но я не рекомендую А хочешь выйти к нам получить свой арбуз пожалуйста ваш арбуз Спасибо за вопрос Отлично Спасибо большое вас Мы тоже Хотим поблагодарить очень крутый доклад прикольно Тема мы хотим Подарить вам подарок от конференции Приходите рассказывать нам доклады ещё спасибо спасибо большое"
}