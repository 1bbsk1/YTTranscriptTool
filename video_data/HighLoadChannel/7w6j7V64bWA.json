{
  "video_id": "7w6j7V64bWA",
  "channel": "HighLoadChannel",
  "title": "How to choose the right index / Gerardo Narvaja (SkySQL)",
  "views": 73,
  "duration": 2978,
  "published": "2017-04-25T08:02:58-07:00",
  "text": "же рада нарва я настоящий ветеран индустрии со стажем работы в четверть века большой специалист по май скривил гуру тонкой настройки и волшебной оптимизации не знаю что сказали поэтому может быть я буду повторяться меня зовут по простому в топ-1 присоединился к бальские 2001 году давно работаю с ларсом с колином которые выступали передо мной вы видите ссылку считал гаучо я из южной америки нажиму все работали view все для я уже 2 представитель латинской америки который сегодня выступает первым был последним и так я работаю мыски когда я начал работать я понял что если вы хотите повысить производительность значительно если вы видите что приложение работает медленно тогда вам нужно посмотреть на схему прежде всего особенно в майские люди говорят но если я конечно увеличу если память увеличу если буфер увеличу тогда будет производительность лучше не всегда а иногда бывает ну лучше всего посмотреть знать для начала схему посмотреть запрос и посмотреть как они исполняются а уж потом можно делать и все остальное вот поэтому в первую очередь надо смотреть индексацию индексы могут дать на и большую прибавку производительность если вы там все поправить и поэтому мы сегодня будем говорить как мы будем говорить о том как правильно выбирать индексы я буду объяснять некоторые функции которые мы реализовали в только тебе а это движок хранение для моей скейл начнем с базовых определений что такое таблица можно рассмотреть таблицу как со сла своеобразный словарь куда мы смотрим чтобы найти слова и определение этого слова это то что мы называем в таблице ключом и величиной числом которые там записано и так beatriz фрактал приз это примеры словарей по нашему пониманию что такое таблица таблица это набор словарей это такое базовое определение вот простой пример которого будущий сегодня обращаться от колонки а это основной ключ эти данные отсортированы по колонке а есть еще другие к руки bc и так далее вот так можем на это смотреть как мы говорили уже эту таблицу это словарь это в словаре слова расположены в алфавитном порядке здесь данные тоже должны в таблице быть отсортированы по ключу и в результате мы можем очень быстро провести поиск находим ключ и быстро получаем все данные это самый быстрый подход однако если вам нужно посмотреть не отсортированные колонки тогда в общем то надо смотреть всю таблицу и в этом случае работа будет проходить очень медленно потому что вам нужно считать все прежде чем вы найдете результат особенно когда объемы данных увеличивается производительность мы хотим увеличить по максимуму совершенно очевидно становится очень трудно поддерживать быстрый поиск такого типа с помощью старых технология и об этом мы еще поговорим точечные запросы это запрос к таблице по первичному ключу когда мы ищем что-то одно одну какую-то запись тогда все работа очень быстро индекс есть яндекс дает вам ключи вы смотрите что там записано однако если вам нужно получить несколько результатов из таблицы вот так вы получаете несколько ключей и производительность быстро снижается таких запросов что такое яндекс яндекс как я уже говорил это тоже сам по себе словарь это та же таблица которая позволяет делать ссылки на основную таблицу это под массив основного словаря или таблицы если хотите вот основная таблица главная таблица которая сортируется по первичному ключу показано слева а справа показанные дополнительные индексы как видите разницы концептуальной пожалуй особой нету но в правой колонке справа все сортируется уже не по колонке а по колонке б вот это уже новый индекс вот и иногда это бывает выгодно поскольку позволяет избежать полного сканирования вот таким образом простой запрос посчитать все где значение колонка более 120 достаточно просто все вернее меньше 120 вот и все вот система по ключам смотрит по основным ключам вот который и меньше 120 получается две строки все вот вам результат если мы делаем то же самое по колонке б тогда мы находим справа 4 значения но нам нужно в этом случае осуществлять точечный поиск и давайте еще раз сюда вернемся мы считаем количество строк по основному ключу и проблема решается и в том и в другом случае но данные считываются из основной таблицы в конце концов вот так по индексу то есть вроде бы все находится но потом мы переходим в основную таблицу и все оттуда выбираем и возникают дополнительные операции ввода-вывода а если у вас миллионы строк то соответственно вы можете встретить большое падение производительности но имя так и происходит работа очень многих баз данных до чего старая использовать индексы каждый индекс в таблице ускоряет некоторые запросы ускоряет поиск ответов на некоторые запросы в зависимости от того что вы делаете в зависимости от того какие запросы поступают базы данных вы должны выбрать правильный индекс первое что вам нужно стирать выбрать самые важные запросы те которые имеют самое большое значение для вашей системы и все базы данных имеет это такие функции как explain которые говорят о том как работает оптимизатор вот пожалуй и все что вам нужно сделать иски и другие средства и другие базы данных поддерживает журналы запросов историю запросов исполненных запросов а иногда даже и время которое ушло на и поиск ответа и многие разработчики смотрят на эти результаты чтобы избежать каких-то ужасных ответов задержек вернее но если запрос один раз в день исполняется тут даже если вы его оптимизируете это это вам прибавка производительности практически не даст а если вы хотя бы чуть-чуть оптимизируете запрос который берёт 1 день исполняется тогда система будет работать гораздо более производительна и высвободить время для выполнения других операций поэтому может быть иногда если что-то долго исполняется но редко то пусть она и есть как есть надо в первую очередь оптимизирует наиболее частотные операции вот некоторые люди говорят хорошо мне нужен индекс тесьмы нужен индекс тут машины индекс там и все заполняется индексами как видите индексы в общем то они вам дается не бесплатно а не требует дополнительных операций ввода-вывода они так сказать стоят требует дополнительных усилий и поэтому индексировать надо только то что действительно для вас наиболее важно лишние индексы это нехорошо еще раз скажу возьмите самые важные запросы определите что для вас является наиболее важным запросам и их только индексируется итак у меня есть три правила простых правила выбора хороших индексов в целом нужно избегать излишних подробностей в структуре данных beatriz фрактал 3 из можно отдельно презентацией сделать по каждой из этих технологий но и в россии москве в теорию знаете хорошо фрактал 3 из этой структуры которые были созданы основателям нашей компании и эта информация есть можно и почитать на нашем веб-сайте в конце я вам покажу ссылки а пока мы будем рассматривать следующие запросы к определенному массиву о нем работает быстрее чем точечные запросы в общем-то нахождение наиболее важных запросов это не тривиальная задача это не дважды два четыре это все равно что решение сложной математической задачи вот если вы какие-то правила разработки для одной системы не обязательно не будут также хорошо работать другой системе иногда у вас бывают опции можно выбрать так можно выбрать другое можем выбрать то можно выбрать другое что-то лучше работает в одном варианте что-то работает другом варианте вам нужно очень хорошо знать свои данные чтобы принять правильное решение однако если вы начинаете с нуля если вы никогда этого не делали то хорошо иметь в голове некоторые правила для начала и это даст вам возможность сразу получить более качественные результаты три базовых правило выбирайте меньшие объемы данных почему все очевидно меньше операции ввода-вывода меньше полоса пропускания меньше задач для обработки данных меньше логике всего меньше все работает быстрее вот если у вас используется ширин sharding то вы можете то есть тем меньше данных вы выдаете тем она собственно и работает быстрее избегайте точечных запросов point qrs последовательный доступ гораздо быстрее чем доступ по случайным признаком эти запросы работают по-другому по разному но в целом это правило выдерживается почему потому что она вращающихся механических дисках головка должна постоянно просматривать всю поверхность диска вот если она все время прыгает и с одной точки на другую это требует много времени много энергии если вы говорите а кончай кончайте читать здесь читайте тут читайте там то диск вращается головка ходит на это уходит время и энергия избегайте сортировки группой удар по эти запросы после получения базовых данных выполняют дополнительную работу они получают данные все которые нужно выбрать для функции агрегации потом они выполняют дополнительную работу поэтому индексация поможет вам минимизировать объем работы в соответствии с этими правилами и так правило первое начнем с него получайте меньше данных то есть ограничиваете объемы данных у нас есть таблица 3 колонки как у нас было и возьмем пример без ключей у нас имеется агрегация колонки c в зависимости от величин которые приводятся в колонке а и b значит выбрать суммы везде где b равно 10 х меньше 150 и идет сканирование если у вас миллиард структур в общем это займёт какое-то время независимость от того какая у вас там база данных и особенно в этом случае как с на слои говорится мы сканируем миллиард строк для того чтобы получить тысячу значений это очень неэффективно потому что же нам делать как нам ограничить объем работы давайте попытаемся сделать так чтобы нам не пришлось сканировать миллиард строк правило первое сконцентрируемся только на том что происходит сколько строк нужно просматривать у нас какое правило b равно 10 х меньше 150 так ставить у нас три варианта а третий вариант это о проведении слияние я это объясню в конце презентации давайте сейчас сосредоточимся на ключе а и клещи б к примеру если будет меньше рядов где а меньше 150 то а первый ключ лучше в противном случае 10 то есть второй вариант мы может быть не знаете ответы заранее в май сиквелом есть одна команда которая называется шо корзины ведь и она показывает какая лучшая из двух оценок и эта функция по сути дела используется optimizer ом для принятия решения когда вы знаете какой ключ используется вы можете определить оба и можно принять решение в этот момент нужно чтобы у вас были свои критерии а если мы исходим из того что 200 тысяч строк имеют а меньше 150 что вполне разумно обычно поскольку здесь имеется неравенство в большинстве случаев это будет перед нищим равенство что в этом примере оба индекса извлекают много данных и какой из них мы будем использовать какое лучшее решение будет следующее нужно использовать композитный индекс составной потому что составной индекс позволит мне выбрать по крайней мере 100 тысяч значений потому что это самые ограничивающие варианты после этого мы сканируем по индексу не нужно будет извлекать все для того чтобы определить какие значения лучше соответствует ключу тогда мне нужно сделать только 1000 просмотров позже вот так два варианта в случае составных значений 1 просмотр по б после этого а поскольку мы решили что у нас 100 тысяч значение который соответствует b и 200000 значений которые меньше чем то значение которое назад на для а и в этом случае лучше использовать б то есть эту колонку где бы впервые колки а во второй колонке но и имеется общие правила в этой части нужно попытаться равенство для того чтобы они шли сначала в а ключ обычно они имеют больше ограничений тем там где есть неравенство теперь-то я анимация демонстрации этого запроса здесь вы видите три значения решения в данном случае принимается по b , а и по сути здесь расчитываются три значения я просто считаю а здесь все решается просто за счет считывание ключа что если мы имеем более сложную картину а больше ста и а меньше чем 200 и а b больше чем 100 что в данном случае будет лучше один ключ в колке один ок лишь колки b или составной ключ то есть ли одно из значений в рабочем условий это неравенство тогда второе значение верни вообще наличие вторичного значения и а составного ключа на уже никак не помогает тогда тех примерах которые мы видим б это 100000 значение а а это 200 тысяч что она больше поможет то что мы можем использовать ключ колонки б поскольку в этом случае нужно будет сканировать весь ключ для поиска решения аа был первичным ключом так что придется сканировать все и это не означает что есть случаев простые примеры где можно использовать составные ключа а придется проводить свои собственные исследования данные для того чтобы понять что правильно что я делал когда не работал с дверь я экспериментировал я начинался о простых условий и смотрел что получится если мы пытаемся понять с какими результатами возвращается запросто тогда в командах select вы можете ввести ограничение если у вас не миллиард строк то тогда не нужно ждать пока вам дадут ответ по сто тысяч и вот рядов вы можете задать ограничение начать экспериментировать чтобы понять все ли правильно работает потом вы можете дополнять новыми условиями скажем а больше чем 100 вы можете посмотреть что из этого получится после этого второе третье условие можно добавить и а план выполнения мне будет сообщать о какие ключи будут работать лучше чем прочие вот тут у нас еще один пример здесь b больше или равно писи а а говорить больше 150 мы видим что составлю ключ не работает поскольку есть значение в середине и этом есть разрыв а больше чем 5 или больше и равно пить ее значение или те которые соответствуют b для того чтобы определить подходит ли нам или не подходит однако если мы поменяем порядок колодок здесь и отце сделаю вторым и если мы помним о том что мы говорим про равенство если мы будем вести сканирование побои поцци в это нам уже будет полезно вот здесь мы видим вопросы с форматированием так или иначе только верхние четыре значения верхнее значение в ключе попадают сюда и приходится пропустить два в середине и поэтому тут со стороной ключ на мне помогает в этом именно случае а первое правило резюмирует то что мы пытаемся сделать мы пытаемся сократить количество воды выводов количество времени обращение базы данных диск во второе правило создаем составные индексы основываясь на условие где мы сначала используем равенство составных индексах и пусть первая колонка будет максимально селективной использовать инструменты для анализа результатов мы начинаем анализировать какие запросы являются наиболее представить ну и после этого можно использовать те же инструменты для подтверждения правильных результатов а иначе вы будете двигаться вслепую теперь давайте перейдём ко второму правил вам а именно избежание точечных запросов что это означает тут у нас есть определение мы пытаемся понять получить агрегацию где б больше 50-ти в этом случае для каждого значит не если мы будем придерживаться о первоначальной таблицы где бы это единственный ключ то тогда нужно последовательно сканировать все значения в б потому что так проще быть большим 50 и потом для каждого из индексов и записи нужно извлекать значение по строчкам для того чтобы попасть в отце все эти четыре значения после этого нужно делать точечные запросы это произвольный доступ и эта непростая штука мы при работе с диском извлечение из каждого и строки это не дорого но строк слишком много если сканировать первичная таблицу можно пропустить индексы переходить сразу к первичной таблицы весе всего 4 но нужно сканировать все таблицы для того чтобы найти пропуске вот что если мы создадим redex который будет включать колонка ция в яндекс и мы называем это ковер куэрри камирен эдепсиз мысль состоит в том чтобы по мере чтение значение из индексов для уже было значение c чтобы можно было вести расчет агрегации без возвращения к основной таблицы и извлечения данного данных c тогда мы сохраняем экономим в и воды в таком варианте мы по сути дела каждый раз когда у яндекса есть достаточная информация для решения задачей для решения задачи по выборке мы здесь выбираем значение тех колонок которые должны быть извлечены они добавляются к индексу за счет 1 правило когда мы смотрим только на рабочие условия можно использовать такие индексы но надо помнить о том что если вы будете использовать их слишком много то в этом случае вы можете прийти к созданию единого индекса с большим количеством колонок в нем вместо использовать 2 индексов использование единого индексы гораздо дешевле всмысле использование ввода выводов по стране с двумя индексами если у вас 2 select a 1 добавляет все что в колонке c другую то что в колке д так дешевле в плане устройств ввода-вывода а и тут у меня есть третий пример на этом слайде тут мы решаем проблему по обоим запросам и я видел следующие многие разработчики используют эти правила вслепую даже не заглядывая в схему они узнают что есть еще специальный индекс covering который мог решить их проблему как я говорил недостаточно использовать исключительно рабочую формулу нужно а также разобраться что происходит в колонках из которых вам нужно извлекать данные для того чтобы дать ответ на запрос другая альтернатива первичный ключ может соответствовать записи где в этом случае первичный ключ может включать колонку b и добавление к ней я начну а двигаться быстрее иначе мы никак не успеем вот здесь функция по класса лизации индексов который возможно попадет и в марию db такого будет вклад эти индексы охватывает все запросы как и первичный ключ и что мы тут получаем вместе со значениями индекса здесь сохраняется остальная информация по строке и вести будет это себя как яндекс категории covering в этом случае приходится проводить широкий анализ и возможно это не решит вопрос и всех запросов поскольку вы будете извлекать очень много информации но стоит забыть о том что было до условия где и пастеризация вагонки берешит часть проблем поскольку тут уже включены все колонки которые есть в этой строке значение b которая вам нужно теперь к и извлекаются той из удаляются точечные запросы и вы сосредоточить внимание только на этой стороне но все это пока что есть только в только д.б. вот здесь вы видите слияние о котором мы говорили здесь мы по сути видим что бы произошло если бы систем базы данных поддерживала эту функцию и если в а значение 200 sx 200 тысячах строк а blu меньше 150 и 100 тысяч строк b равнялась бы 10 тот требуется дополнительная информация и вот что мы получаем и так в общем лучше чем отсутствие индексов но если у вас имеется индекс кластеризации то все работы газы лучше вот тут в этом случае что мы делаем на определяю составной ключ для кластерных индексов которые позволяют лучше получить результаты без осложнений итак резюмируем нужно избегать о точных запросов когда вы определяете индекс покрывающие то вам не нужно возвращаться в строку для получения значение вне зависимости от того имеется ли там агрегация или нет тогда вы все можете решить с теми значениями которые вы получили из ключа теперь я перейду к следующему пункту а именно к избежанию сортировки вы имеете все значения из но если просматривать обычные условия то вы работаете с определенными ограничениями если если взять select каунт отце и группу формируете а пол б вы а просто все сканируете и сохраните группирование во втором случае высох встаете временный файл где производится сортировка данных после этого произвести группировка добавляя составные ключи вы делаете покрытие значительно более простым и тут вы используете сначала сортировку по б при этом мы избегаем сортировки в избыточном объеме вот это простая часть использование индексов для предварительной сортировки теперь мы хотели бы показать вам несколько примеров для того чтобы у нас создалась время задать вопросы в данном случае мы используем от цен в первом случае и это очень похоже на то что мы уже с вами рассмотрели отце это то где больше ограничений поскольку мы изменим групповую версию то мы здесь рассмотрим несколько колонок пример еще один что можно считать правильным со страным ключом для того чтобы разобраться нужно понять что здесь есть несколько индексов и о составных ключей несколько правил одно правило какую колодку выбирать так для обстановки на первое место включи третье правило избегать сортировки который определяется грубой и избегать о точечных запросов потому что в этом случае нужно агрегация через колючки нет необходимости приносить непосредственно строку для получения значения в этом случае не ясно что будет лучшим индексом и опять же проведение анализа нам поможет начинаем мыса простого запроса и мы пытаемся понять какой план является планом выполнение и это поможет вам решить какой использовать вариант ключа здесь вы видите один случай который несколько более сложен по своей сути я его пропущу вот этот вариант цена индексов я говорил о добавлении индексов но добавление индексов чего стоит и проблема состоит в том что действительно у вас получается выбор более быстрым но ставка будет двигаться медленнее в случае больших данных дерево 3 самый простой метод индексации в лекционных системах каждое дерево имеет определенное количество от пиратов и узлов на странице если данные не помещаются то производится расширен на следующем уровне и это движение продолжается получение пиратов дает вам группу значение и устанавливает количество воды выводов таким образом реализовано однако в большинстве случаев когда вы переходите к большому объёму данных там уже не используется оперативная память в этом случае вы должны извлекать все с диска допустим в внедрение майский л.а. там 16 тысяч страниц и если вам нужны какие то данные то вам нужно будет взорваться до самого низа и это означает использование устройства ввода-вывода это вот как раз то что написано в последнем блоке здесь а я хотел бы кратко объяснить оставшийся материал то что называется фрактал 3 кроме а пиво тов здесь есть еще буферы сообщений и данные перемещаются таким образом эти страницы по 4 мегабайта иметь размер и здесь вы видите что если нужно спускаться по дереву то много аккумулируется в буфере и буфер долинина полагается и до того как мы все заполнили данные не вытекают то есть здесь речь идет не о давлении давние добавление строки какой-то странице тут до складываются все операции которые производятся одновременно да действительно делается определенные действия поводу вывода но в данном случае система работает значительно более эффективно и производитель начать случае с обычным деревом by three когда мы говорим о больших объемах данных это преобразует фактически ситуацию в последовательную систему ввода выводов о которой работает быстрее больше изменений по нагрузкам все это является транзакционных и мы не будем ничем жертвовать тут вы видите слайд по системе хранения вы должны помнить сколько вам стоит а система хранения показывается то каким образом осуществляется хранение место занимаемая компрессия всегда включено вы получаете высокий коэффициент компрессе деревья обе 3 имеет свои собственные ограничения в любых системах яндекс и работают весьма быстро во всех случаях хотя у нас есть решение для майские у нас есть решение для мол gdb есть также обработчик который похож на energy b что-то мы наблюдаем мы наблюдаем фрагментацию обе 3 общая производительность может быть хорошей но если фрагментацией слишком высоко то это может вызвать дефолтная проблема что касается деревьев который относится к категории фрактальных то таких осложнений не возникает поскольку осуществляется повторная балансировка и здесь передается только то что должно передаваться но собственно вот на этом у меня все спасибо за внимание а все это превратилось проблему потому что я застрял очень надолго добавил я индексы и запрос блоки широким а то боюсь большое количество строк из таблицы я тогда поменял структуру gent of и я тогда применил индексы и это в общем то решила проблему согласно объяснению сканировать пришлось только 100 строк со правда что это за действо очень медленно от свечи раз я снова профиль на единицу показал профиль моему запросы все прошло хорошо но отправка данных двигалась очень медленно может и внешность посоветовать как решить такую проблему я потому что не знаю что делать следующий раз когда возникнет такая проблема если вы видите значные индексирование то все замедляется вы какую базу данных используя эти проблемы не во вставке проблемы в селекции выбери я не могу здесь добиться высокой производительности высокой скорости работы мне надо более внимательно изучить ваш случай потому что может возникнуть проблемы с оптимизатором в 56 например для россии в optimizer есть еще проблемы марии dubbed на были улучшения внесены но реальные улучшения имеются только версиях 5556 надо смотреть запрос на смотреть на схему для того чтобы вот разобраться с тем что происходит в ряде случаев optimizer помогает оба были ли вы использовать heating индексы я пробовал объяснение было хорошей назад ну чтож все затыкалась когда я показывал профиль этого запроса надо посмотреть конечно конкретно уже у меня к сожалению сейчас нет это проблема и второе у меня есть еще вопрос оказывается вот насчет поддержки обычной поддержки запросов таких акселя бла бла виля идеи in sap query которые moi ce qu'il 55 не поддерживает того что мария тебе вот mysql 5 6 только будет поддерживать там будут в новой версии посмотрите новую версию здравствуйте можете рассказать более подробно про индексацию и тоже не эксперимент это уже вы говорите что решение это в бета-версии пока есть бета если вы выйдете на наш веб-сайт или пошлете мне email я вот адреса здесь есть я тогда вам расскажу как получить эту бету индексация та же самая проблема все зависит от того какая у вас за база данных мы можем распространять свои решения только на open source майские л это самый популярный плагины есть интерфейсы для новых плагинов поэтому многие люди пользуются и это самая популярная база данных новый скилл поэтому мы поддерживаем arocs планы распространение более подробной информации вся информация у нас на веб-сайте вот вы ходите туда смотрите все что там мы можем опубликовать библиотека indeed индексации все что там есть open source все там есть но по условиям лицензирования то что не спонсорством отсутствует ну и еще вопрос а там там джин с вами связывается да да да есть такие спасибо не могли бы вы рассказать еще об алгоритме который вы используете для фрактал тряс буфер используйте не понял я вашего вопроса когда буфер полностью заполняется переходите вы на более низкие уровни дерево что вы делаете с буфером с данными которые в буфере но буферные данные они идут на более низкий уровень и буфер распределяется на разные части дерева и данные могут принадлежать следующему узлу и тогда они находятся там или дальше еще распространяется по этому могут еще дальше вниз распространяться одной из преимущество этого буфера я не хотел здесь в общем то распространяться особенно в презентации например если есть таблица которая выходит на страницу она распространяется на весь буфер но в общем то не исполняется пока буфер не будет опустошена следующем этапе и это не требует дополнительных операций ввода-вывода и маркировки ну вот как это все работает система знает как получать все данные из буфера но буфер не очищается пока это не нужно системе омс ибо все мы закончили спасибо что пришли"
}