{
  "video_id": "SN2XpgwrKY4",
  "channel": "HighLoadChannel",
  "title": "Effil: иной подход к многопоточности в Lua / Михаил Куприянов (Kaspersky Lab), Илья Удалов (Яндекс)",
  "views": 538,
  "duration": 2279,
  "published": "2019-05-14T14:40:41-07:00",
  "text": "всем привет из меня зовут михаил куприянов сегодня мы хотим пока точности в ла и рассказать вам и нам подходит многопоточности которые мы реализовали в нашей библиотеке и фил потягаться в скорости с многими компилируем языками за счет своего легковесного интерпретатора второе ло можно быстро изучить если вы уже умеете программировать на каком-то языке два часа и вы эксперт флот для вас почти не остается темных углов вы спокойно жонглируете всеми языковыми конструкциями и можете писать lua код и третья ночь просто встраивать интерпретатор лу это несколько си файлов их очень легко скомпилировать и встроить в свой проект неудивительно что а можно найти везде его используют как разработчики баз данных для какого-то слой кастомизация также можно найти в самых неожиданных местах например его можно найти в утилитах для анализа сетевого трафика также ло очень любит разработчики игр за его скорости быстродействия почему мы начали говорить про многопоточность лу работая слой у нас сейчас возникла задача запустить параллельно скрипт функцией даже отдельную команду одна из таких задач после которые мы решили заняться этим вопросом более плотно во необходимость создания вто мотивированных тестов для определенной системы где большая часть времени исполнения тесто занимали не посредством удаленные вызовы системных команд копируем файлы между хостами и так далее очевидным решением для того чтобы повысить эффективность просто снизив время исполнения данных тестов это 1 параллелей расправе объявить данные операции тогда мы решили приступить к исследованию данной задачи и выдали формировали определенные требования к многопоточности влово чего же мы хотим от потока flow самое главное мы хотим чтобы решение которые предоставляет реализует многопоточность было универсальным мы не хотим завязываться круто отдельную версию интерпретатор а соответственно и наши решения какая-то wheels интерпретатор а соответственно и библиотека должна должна работать со всеми современными о сами татары опять 1525 ridgid мы также хотим как раз платформинга и соответственно библиотека должна поддерживать уметь работать на всех современных как мим дисконтных системах и по функциональным требованиям они принципе достаточно очевидные пасты нам необходимо механизм синхронизации для обеспечения синхронного доступа к данным для вас течение порядка доступа к данным а также нужны разделяемые данные для того чтобы могли использовать одни и те же участки памяти одни и те же данные из разных потоков параллельно и непосредственно сами потоки и тоже не простыми понятными и специфика многопоточного программирования не должна сильно выделяться из обычного лова кода а чтобы посмотреть как слова будут работать потоки сначала нам стареть как работают другие скриптовые языки обычно скриптовых языках таких как питон и рабби есть джилл global and are pretty лог что это значит это значит что в один момент времени может выполняться лишь одна инструкция интерпретировал интерпретируем авокода да можно составить на создать поток но копать реально многопоточности это не даст единственный где можно выиграть от на тяжелых и о операциях ложе имеет интерпретатор очень изолированный и в одном процессе можно считать несколько копий интерпретаторов этикой пинтер predator могут работать и никак не повредят себя единственный вопрос как же обмениваться данными наверняка а росло иметь такую особенность уже есть много библиотек на рынке который реализует многопоточность в том или ином виде давайте посмотрим с какими решениями мы столкнулись и какие преимущества и недостатки у них есть первый самый простой подход это all white red все что можно это породить поток передать него какие-то аргументы и получить возвращаемое значение собственно очевидно недостаток данного решения это отсутствие какого-либо обмена данных как написано на слайде электрического у него бьет канат под рядом и windows стресс может быть довольно хорошим решением но не отвечает нашим требованием ok интерпретатор но на самом деле очень простой это все лишь несколько си файлов можно попробовать разобраться как они работают поставить правильные места view my tags и сделать так что было работал многопоточной среде и не сломался самое известное имплементации такого подхода это love red очевидный недостаток это универсальность мы не можем работать не с одним из стандартных интерпретаторов и кроме того должны поддерживать еще и свою версию такую интерпретатора что дает сложность при переходе на более новой версии как например на ted поддерживает лишь в версии 5 1 нам это не подходит хорошо еще один возможный подход это сделать так чтобы между lua стоит мы были какие-то каналы один поток пишет сообщение в канал а другой читает до тех пор пока сообщение другой потока с канала не забрал мы блокируем ся самый известный библиотек которых живет только подход это лаб рок здесь помимо сложности написание эффективных программ с синхронным обмена сообщений у нас отсутствует возможность использовать общие данные мере использовать разделяемой данные между потоками что также не удовлетворяет всем нашим требованиям по kei если вы возьмете какой поисковые системы из объятий там запрос ло многопоточность то первый результат который вы получите это лоуренс его использует большинство программистов он работает следующим образом он делает между потоками асинхронные канала куда один поток может писать другой из них например читать и пока в канале будут сообщение мы сможем их сразу прочитайте если там не будет сообщение мы заблокируем ся до тех пор пока сообщение не будет прочитано это решение одно из самых популярных в то же время одно из самых эффективных довольно удобна в использовании но проблема мы все еще не мимо выделяемые данных у нас единственным возможность общения между каналами это пересылать наши данные через непосредственно канал и тем самым осуществлять двойной копирование данных на каждой операции обмена сообщениями разобравшись рассмотрев все существующие решения мы решили приняли решение что лучше сделаем подобным библиотеку сами и таким образом приступили к созданию библиотеки для лова под названием i feel и начали мы очевидно из потоков представим что у нас есть функция которой конкатенировать две строки мы хотим запустить ее в отдельном потоке тут стоит сразу вспомнить о том что наши потоки мест это не только потока person система но также это отдельные спеть интерпретатора что позволяет нам или нам бы хотелось иметь также дополнительно сконфигурировать поэтому процесс создания нового потока мы решили разбить на два шага и первым вызовом библиотечной функции field red мы передаем функцию которые хотим исполнить другом потоке получаем некий объект генератор который мы можем сконфигурировать и например указав необходимые для подгрузки модули или прописав пути до модулей которые необходимо будет использовать интерпретаторе такие как посадить пас после этого мы делаем еще один вызов на данном генераторе передавая уже необходимые аргументы нашей функции и тем самым запускаем поток параллели исполнения нашей функции получив объект потока мы можем например дождаться его завершении и получить результат исполнение данной функции все довольно толсто пойдет дальше мы поняли что используя дебаг интерфейс solo а именно используя возможности установить хуки на исполнение lua кода мы можем реализовать прерывание данных потоков как показано на примере мы можем использовать функцию и степи лука там за цирк указав необходимое количество инструкция принтера через которое даже должен быть вызван call back который будет выполнять проверку на необходимость прерывания потока и если ты необходимо поток могут перелом в общем то в любой точке исполнения локодо как показано на примере можно плеваться любой точке но очевидно что использование дебаг интерфейсов и постоянное прерывание исполнения ло скриптов на вызов наших call back of может очень сильно повлиять на производительность таким образом через наш костаки генератор мы можем сконфигурировать данный данная функциональность и либо указать явно размер шага через которые ты должен вызываться наши call back либо указать данный шаг равный нулю тем самым полностью отключив использование хуков в лова для прерывания но для того чтобы сохранить возможность кривошипа только чтобы поведение потоков в общем был идентичным независимо от включена стиле выключи настей использование хуков мы добавили явную точку прерывания и фил хилл которая собственно выполняет задачу поверки на необходимость прерваться если прерываться необходимо поток быть прерван именно в этой точке помимо этого можно реализовать прерывание потоков в общем-то во всех библиотечных функциях в богаче какой-либо ожидания показано на примере если наш поток как например ждет завершение какого-то другого потока будь то с тайм-аутом или бесконечно мы можем реализовать прерывание этого ожидания и тем самым функции ожидания в филе будут являться также точками прерывания потоков с прерыванием мы можем добиться следующих мы можем реализовать описанные здесь методы потока есть статус мы всегда можем вы поверить мы можем приостановить исполнение потока возобновить его исполнении либо же полностью отменив вызов console для этого потока ух потоки у нас есть что с обменом данных да действительно что же сомненно нам данных прежде всего лучше не придумывать что-то новое об кода посмотреть и украсть есть такой удобный примитив в go как каналы мы подсмотрели украли его это fest in first out очередь с одной стороны в нем можно писать сообщения с другой стороны из него можно читать если очередь пустая мы заблокируем что до тех пор пока нас не отменят ли кто-нибудь не прочитает очередь наш имплементация можно писать даже кортежа в памяти это выглядит вот так да пусть у нас есть поток при пишет сообщение поток которые их читает где-то за пределами lua state of мы ассоциируем структура данных которым можем осуществить синхронизацию и сохранять там наши сообщения я довольно удобно и позволяет легко передавать потоки данных между стойками немного похоже на лоуренс но мы же здесь все la программисты и хотелось бы использовать разделяемые между потоками структуры данных и круто было бы если между потоками можно было бы разделять таблицы например так у нас есть таблицы которая тоже существует за пределами пласта это один поток может не и писать о другой может одновременно из нее читать ведь будет абсолютно потока безопасно да такое тоже можно реализовать с помощью визир дата более того такую таблицу можно заставить вести себя почти также как обычную lua таблицу в нее можно записывать ключ и значение из нее можно удалять значение она будет максимально мимикрировать под обычной таблицу если что будет отличаться она будет создаваться библиотечными функцией также к ней вот можно будет использовать почти всегда с такими таблицами можно будет использовать библиотечные функции более того такие таблицы можно будет передавать через каналы и в таком случае эта передача будет очень быстрой мы просто скопируем ссылку в канал и достанем ее с другой стороны такая таблица будет существовать сразу нескольких потоках можно больше и можно делать для таки задавать для таких таблиц мета таблица таким образом конфигурировал метод таблицу в одном потоке мы получим такое поведение сразу в нескольких потоках и мы можем строить более сложные объектной абстракция в многопоточной среде нала единственное что нам нужно в мета таблица нам нужно уметь сохранять функция как же это сделать говоря о примитивных типах вопрос передачи к между потоками довольно прост мы их копируем с функциями дела обстоят несколько сложнее для того чтобы перенести одну функцию функцию из за того что это в другой нам необходимо выполнить ее цивилизацию 10 реализацию в байт-код а как показано на слайде мы создаем пример государь таблицу и фил таблицу с даем обычное ло функцию и кладем эту функцию в таблицу в данном случае нам необходимо выполнить вызов функции эквивалентны string дампу и создать некий внутренний тип который будет хранить цивилизованный байт-код этой функции после этого когда мы захотим эту функцию вызвать прямо из таблицы или явно загрузить ее в lua state нам необходимо будет выполнить обратно операцию и превратить наш внутренний i feel фанкшн объект в обычную ло функцию тем самым здесь реализовав ее и вызовов load string ну как мы знаем функции в имеют состоянии могут захватывать внешние перемены своих об элис и как показано на примере зак здесь захвачен 2 локальных переменных тем самым получается что наш внутренний объект должен помимо сохранения байт-кода функции сохранить также и значение переменных если ты луны о переменные либо захватить ссылки на наши внутренние объекты если это фил объект например как таблица тем самым когда мы будем продолжать эту функций обратно blew a state мы выполним здесь реализации функции и восстановим себя полюс этой функции которые мы сохранили они очевидным очевидной проблемой такого подхода является время которое мы будем тратить на цивилизацию здесь реализация функций с учетом того что он появляется разделяемой таблице мы можем перес пользовать одну и ту же функцию делать ее вызов сколько угодно раз и очевидным решением оптимизации данной точке было бы запиши ровать заказа кешировать этой функции когда сказано о необходимости реализовать функцию мы заглянем в кэш и посмотрим нет этом ужас реализованный и сохраненный внутренней внутреннего объекта функция фил фанкшн и если есть когда нечего нам делать больше не нужно и когда мы будем выгружать обратно мы также заглянем в кэше посмотрим а может быть вас уже есть диси реализована функция для нашего внутреннего объекта и сам нас появляется кэш который позволяет очень сильно повысит производительность работы с функциями собственно посмотрим что у нас есть у нас есть потоки контекст исполнении lose sight нас есть каналы есть таблицы и есть функцию через каналы можно передавать таблицы через каналы можно передавать каналы таблице можно вкладывать в таблице а еще это все может быть захвачена функции быть вложены друг в друга в произвольном порядке и кажется в какой то момент мы можем получить циклическую ссылку в разделяемой памяти между lost это мир кажется здесь не обойтись без коробочкой лекторов чтобы он собирал такие объекты синхронизации обычно garbage collector работает следующим образом у нас есть какое-то корневое множество объектов которые точно присутствует в программе а потом мы рекурсивно обходим за дерево зависимости объектов и те ты которых мы не дошли мы их удаляем обычно скриптовых языках таких как лова корневое множество объектов это те объекты ссылки на которые присутствуют в стеке или в глобальной области видимости в нашем случае это те объекты на которые существуют ссылки и зло a state of в данной реализации мы рисовали простой алгоритм арканс и однопоточный не очень страшно потому что на самом деле garbage collector сделает стоп зе ворлд только в том случае когда поток начинает работать с разделяемыми данным местом не работает с разделяемыми данными он может исполняться стоит и могут исполняться параллельно давайте посмотрим на простом примере как будет работать garbage collector и какие объекты у нас будут созданы и когда они удалятся в данном примере мы создаем канал создаем поток в который передаем функцию все что сделает функция она создаст таблицу возможен заполнит ее какими-то данными возможных будь тяжелая операция который имеет смысл грузить в отдельный поток например здесь реализация джейсон из диска и потом передаст эту таблицу обратно сначала молодцы ruim канал и на которой у нас есть ссылка из главного потока также у нас появляется функция который мы на самом деле создали главном потоке си реализовали передали в поток номер два идеале завали уже там она тоже будет ссылаться на канал под именем ч ну после того как мы заполним таблицу у нас будет на нее ссылаться функция под им на по имени тебе и так же мы положим эту таблицу в канал и канал тоже будет на нее ссылаться после этого поток может закончить свою работу если поток закончил свою работу то мы можем его дела тировать после того как мы водила сырова ли мы видим что функции недостижимо и удаляем ее тоже все остальное нам пока нужно главный поток держит канал канал ссылается на таблицу их нельзя удалить идём работать дальше и достаем таблицу из канала канал теряет ссылку но теперь появляется ссылка из главного потока если наша программа продолжит исполнении дальше то рано или поздно ссылки пропадут и тогда мы сможем дела целовать два остальных объектов посмотрим что у нас получилось мы можем передавать между потоками все примитивные типы строки и числа логические переменные можем передавать функция можем передавать таблицы и like userdata то с чем мы сейчас не умеем работать это мы совсем никак не умеем передавать к рутины если вдруг у вас есть идея как сделать это обязательно поймайте нас после доклада и расскажите второе сложно передавать userdata в общем случае это трудно реализуемо можно пропатчить код и научиться передавать easier дату а я сейчас спрашивает почему нет мьютекс of есть всего два примитива для синхронизации таблицей канала первое потоки умеет отменяться их можно ставить на паузу и нет такого понятия как области видимости очень тяжело автоматически отпустить мьютекс и очень-очень легко сделать до блок мьютекс и в данном случае опасно второе поскольку есть каналы то как мы знаем по примеру других языков программирования канал и побуждают разработчиков писать код который не в терминах взаимных блокировок в терминах передачи данных это более простой для понимания подход и более надежный и вот если очень-очень нужна и хочется то можно сделать мьютекс из канал это буквально десять строчек кода но мы не стали включать такой примитив по умолчанию потому что кажется что он опасный давай посмотрим что получилось есть реализация только ncap цивилизация доступным гид хоп она поддерживает до 51 52 53 и logic и собирается под три основных дух темных операционных систем и теоретически должна собираться и работать под любой мобильный девайс но мы инвестировали хотя там не должно быть никаких проблем что нет никаких зависимостей кроме хадрон ли библиотеки популярные sl2 или бти + + давайте теперь взглянем быструю все это работает и для того чтобы понять насколько эффективно у нас получил совершения мы решили сравниться с кем-то из кино сравниваться как несло лэйнс очевидно что мы реализуем совершенно разные подходы и часть функционала доступную доступно у нас не реализовано недоступна blades поэтому сравнить сравнить завершения полностью но пока доступны функционально функционал мы не можем но мы можем сравнить позади телес каналов поскольку они есть и у нас и у ло лэй нс собственно провели достаточно большое количество тестов здесь мы решили показать один из сценариев поскольку а во всех остальных результаты были примерно такими же сравниваем скорость передачи различных типов данных с канала в конфигурации с двумя потоками и двумя каналами между ними работаем на ла-5 один первый тест это передачи примитивов как мы видим здесь его показывать значительно лучше лучший результат и быстрее рейнса данная конфигурация примерно три раза здесь стоит упомянуть особенностях реализации каналов и вообще механизм передачи данных в наших библиотеках и фил реализуют каналы очень просто это очень легкий и последствия реализации примитив использующий один из цельных контейнеры 20 примитивы синхронизации во многом собственно непростые как мы видим достаточно эффективно aliens использует для обмена данными промежуточный lua state тем самым когда необходимо скопировать какие-либо данные из 1 голос стоит в другой мы берем 3 a state копил сначала в него которое поставляется каналы и потом делаем еще одну копию в другой стоит собственно в этом основная разница передачи данных между нашей библиотеками давайте взглянем на другой тип эта функция здесь дела обстоят уже не столь разница между и филом элейн сам не столь существенно но и фил все равно немного обгоняет liens здесь мы видим тест на передачу небольшой функций состоящий всего взять их инструкций и на большие функци состоящий из нескольких сотен строк кода что существенно влияет на время стерилизации здесь или зал с этих функций и также мы добавили еще один не совсем честный тест но он показывает эффективность использования кашей который мы можем реализовать выпили и данный тест выполнять передачу да и ту же функции и сразу вас через канал и отличие от лэнсом в фильмe мы можем реализовать кэш и выполните сигнализацию 10 мутацию лишь один раз и все остальные разы передавать только ссылку на наш внутренний объект остается 3 test и эта передача таблиц для начала решили дать определение двум способам использования таблиц а именно создания таблиц в и филин сразу скажу что method in place создание таблицы в нашей документации описан как наиболее приоритетной в чем разница в говоря вылет они практически идентична разница в том что когда мы используем in place меток на создаем эту таблицу и кладем наши данные непосредственно в эту таблицу после чего когда мы сделаем push в канал мы передадим уже лишь ссылку на эту таблицу и больше никаких срезаться и копирование данных и почвах операции выполняться не будет тогда как при обычном или не inplace методе создания таблицы мыслям обычного таблицу кладем нее данные и после этого передаем ее в канал и вот на этом этапе нам на выходе месси раздавать вы таблицу то есть мы пойдем по всем элементам еще раз очевидно что такой метод не не очень эффективным в терминах и fila и давайте посмотрим на результаты тестов с передачей таблицы на небольших table saw стоящих всего из нескольких элементов результаты принципе неплохие как мы видим при обычном способе способе создания таблиц на небольших таблицах мы все еще побыстрее лэнс не стоящих они никогда не столь разница не столь существенно при in place результат разнится уже побольше мы работаем по быстрее но когда речь заходит про большие таблицы состоящий из 1000 элементов ситуация становится хуже при обычном методистом создания таблиц мы выполняем все реализацию то есть походе через эти элементы еще раз и как мы видим эффективность такого подхода не столь велика зубы страны если мы вспомним про так как работа с таблицами в филе более эффективно и за используем in place метод создания то результат будет уже не столь шокирующий хотя и фил все равно немного уступает лэнсу и здесь важно помнить что в данном случае мы получаем результат говорит нам о чем что создание сериализация i felt таблиц уступает в производительности стек тустеп копи реализованный блейн важным важный момент что мы говорим о разнице производительности именно создание i feel the blitz поскольку если мы захотим передачи таблицу еще раз куда бы то ни было повторно копирование данных или сериализации выполнено не будет мы будем придавать лишь уже ссылку на этот объект тогда как flames нам придется выполнять копию при любой передаче данных еще раз что мы получили в результате up in sales библиотеке доступны они накидка поддерживает основные современные интерпретаторы ла-5 1525 3g версии 2 0 имеет на данный момент один релиз версии 10 и доступный налога рокс страница по лицензии mighty и работает на трех основных доступных системах это linux макса windows собственно спасибо за внимание сканируете qr-код заходите накидка пробуйте я буду рад если у вас будут новые идеи и попробуйте и в своем проекте или поставите нам звездочку спасибо вопросы вы ребята запоминайте за лучший вопрос приз до первый вопрос правильно ли я понял что у вас передается ссылки аннеси реализуются таблицы например как передаются более сложные элементы через каналы по ссылке или через реализацию если нужно передать а таблицу обычную но мы не сможем передать мне зассе реализуем в юзер дату который быть и field эйбл и передадим ссылку лишь на неве если мы сразу создадим i feel they болта мы будем передавать лишь ссылку второй вопрос микрофон пожалуйста второй вопрос не пробовали ли вы запускать это в таранто ли там раздавали данный вопрос окружении пока нет у нас нет достаточно опыт работ с тарантулом чтобы сделать это быстро и эффективно тарантул просто работает как интерпретатор вместо лот пишите тарантул и она работает о таком нет мы не по были хорошо хороший возможность еще еще вопросы добрый день вы сказали что при передаче функций вы реализуете в том числе и стоит этих функций имеется в виду все внутренние перемены которые доступны на сколько я понимаю им доступно не только внутренние переменные которые были объявлены как local но и глобальные переменные то есть по факту получается что вам нужно тащить полностью весло стоит спасибо за вопрос о снижении так и не добавили слайд об этом на нашу презентацию принцип работы с число стоит вообще без перемен и окружение для функции нижней подсчете не н.ф. весы и больше 51 организован следующим образом если функция иметь в качестве свои переменные окружения глобальная таблица универ не подчеркни жить там и несерьезен данным данную таблицу мы ее прогнозируем когда мы загрузим эту функцию каком-то другом потоке мы установим тот текущей ниже по чайка неджи в качестве текущего in varmint а если функций установлен кастомный бармен какая-то кассано таблица отличного глобальный джек то мы используем мысе реализуемые в новом свете гивы где мы погрузим мы ее установим в качестве текущего не на мента хотя и исключением заново правило является лова 51 где мы не можем использовать easier дату в качестве окружения для функции и тем самым мы не можем посетить эту операцию собственно так это еще вопрос вот нам а как быть с от вылью у функции есть apple илью то бишь замыкание вы можете как-то то есть ну вот предположим я создал функцию она замыкает какие-то вещи вообще то есть вы исследуете содержимое от в льюисе реализуете как-то передаете мы вот как было описано правовых работа с типами в нашей библиотеке нас правил работы с типами единой везде то бишь это поле us передача какого-то типа через канал попытка положить этот тип в таблицу везде будет отдает уже появился аббат все примитивы копируются как его все таблицы превращаются в фил таблицы на их серьезным превращаются во внутренней типа и уже работаем со ссылкой на этот объект все функции превращаясь во внутренней типа фил фанкшн и как только мы пытаемся их достать обратно в лу каким-либо способом она обратно превратиться в функцию и собственно все вы не так много типов ну и про каналы я честно говоря может быть невнимательно смотрел лимитируется или размеры есть и рокировка на канале дам у нас все операции ожидания тоже имеет универсальный api они могут работать синхронно без ожидания ожидать какой-то зафиксируй тайм-аут или ожидать бесконечное время канал имеет может опционально иметь ограничена вместимость и как раз таки с вместимостью в единицу в две строчки реализуются мьюту ксу к сожалению сейчас нельзя запечатывать канал и сделать канал только на чтение только на запись но мы думаем чтобы так сделать еще вопрос а вот у меня вопрос есть глупый в каком потоки у вас выполняется garbage collector в том потоке который которому не повезет тот поток это попытается создать очередной наш разделяемый объект и и количество созданных объектов превысит определённый порог в этом потоке начнет выполняться сборка мусора а это как-то можно настраивать нет на данный момент нет но у нас есть api для коллекторов сюда можно приостановить сбоку и явно сделать вызов сборки если нужно контролировать и то тогда конечно как в казалось интерфейс максимально скопировать важные для фейсы и даже как бы сколько выглядит примерно так же собственно и работы так же как в 50 примеру а я могу узнать из одного patek потока что в другом потоке работает горбач коллекторы не трогать разделенные до данные сейчас интересный вопрос да у нас часто не реализовано возможными смысл это сделать хорошо еще вопросы коллеги привет спасибо за доклад у меня такой простой совсем вопрос по поводу тестов перформанса не проводились на синтетических данных или у вас была возможность обкатать и welcome to боевом проекте и посмотреть на большом числе статистической выборки какой-то нет по фону сопроводи исключительно на синтетических тестах статический тестах на реальных проектах откатывался исключительно с точки зрения удобности использования но не производительности то есть такого пока у нас еще нет опыта интеграция это спасибо еще вопросы а вот у меня тогда есть еще один вопрос тоже глупы какую цену должен заплатить программист за то что использует вашу реализацию многопоточности программист платят самым ценным своим временем несли что ему надо это зайти на git хоп и вот по лицензии mighty вот так вот порно но я ведь не про деньги я про память и процессор а память кстати говоря какие вы меркантильные ребят именно после обсуждения с вами этого вопроса мы знаем сделали замеры она не потребление памяти непосредственно в процессе этому еще не успели сделать библиотека весит около 600 килобайт и 600 как это правильно что несколько больше чем лу но это цена за си плюс плюс стоит как ни странно из 22 с половиной тысяч источник всего что значительно меньше чем в целом работа довольно быстро потреблять немного на какая-то цифра пока нет хорошо пишете ци измерьте пожалуйста пишите цифры в нашей телеграм-канал хорошо еще вопросы по лесу и тимчук порекомендую sl2 если вам нужно писать lavabending писал 2 ваш единственный выбор не пишите было бен денги на си плюс плюс не надо еще вопросы нет вопросов хорошо спасибо я сам нет вопросов тогда да уважаемые спикер и выберите лучшие ответы из аудитории мы лучшие вопросы выбрала лучший ответ аудитория пусть говорит между давай выберем вот так который задал два вопроса и в том числе про каналы он задал три вопроса как минимум я считал 12 много заду много вопросов вопросов и вопрос про канал был очень хороший аплодисменты пожалуйста спасибо"
}