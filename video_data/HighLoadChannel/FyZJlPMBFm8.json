{
  "video_id": "FyZJlPMBFm8",
  "channel": "HighLoadChannel",
  "title": "Как ускорить программу, не переписав ни строчки: PGO для Go-разработчиков / Кирилл Кузин (Vi Tech)",
  "views": 1682,
  "duration": 2952,
  "published": "2024-09-17T09:05:48-07:00",
  "text": "Итак познакомимся Я Кузин Кирилл старший разработчик в компании тех распиливают и помогаю создавать пас платформу Почему писатель потому что в свободное время я пишу научную фантастику Ну или по крайней мере пытаюсь писать научную фантастику тех - Это дочка всех инструментов маркетплейс по продаже товаров для ремонта дома дачи здесь я и мои коллеги создаём высоконагруженные для развития бизнеса маркетплейса наш основной язык - это гон и помимо всех наших прочих задач мы решаем задачу ускорения наших микросервисов их работу и об одном таком инструменте который нам помогает это делать я сегодня расскажу название этого инструмента Давайте сразу я наверно те бы спросить кто-нибудь о нём слышал знает Вот можно руки поднять Ну кстати нормально так А вот в продакшене У себя на работе кто-нибудь его использует вот прямо плотненько вижу одна рука это уже отлично А сегодня я расскажу о том что происходит внутри компилятора Что происходит с нашим кодом когда мы используем pgo Итак как говорил Юрий Гагарин поехали про guid - это расшифровка аббревиатуры P что мы делаем В общем случае чтобы использовать данный инструмент во-первых Мы запускаем серс в прок во-вторых снимаем профиль нагрузки при каждом новом пло соответственно про GU это оптимизация на основе тех данных которые мы получаем После профилирование наших с вами микросервисов смотрим Это довольно простые шаги и на самом деле от языка к языку они не меняются Как пример кусочек текста из Робу кусок текста с поста из блога мы видим шаги применения одинаковые но отличаются реализация конечно и работа компилятора Почему ВН компилятор довольно консервативный если он использует какие-то инструменты которые существуют более старых языках он может их использовать не на полную катушку А так сказать в вырезанной формате на чём же основывается работа н как мы поняли это профилирование обязательная часть и второе это оптимизация компилятора это тот те процессы которые позволяют изначальный фрагмент кода преобразовать в новый фрагмент функционально будут совершенно идентичны Но будут отличаться по скорости работы и количеству машинного кода Сегодня я буду говорить как раз про оптимизацию компилятора про профилирование не буду но стоит отметить что Напомнить нам всем что в моменте профилирования может уменьшить работу скорость работы нашего сервиса на 5-10 про когда же оптимизация компилятора применяются в общем виде выделяют два этапа компиляции на первом этапе называемый frontend мы парсим код тонизирует но в документации гунга у нас присутствует ещё и третий этап midle именно на нём мы преобразуем наш код с помощью оптимизации в Гош мы используем четыре оптимизации поиск устранения мёртвого кода который позволяет убрать код который не участвует в логике нашей программы тем самым худеет бинарный файл худеет синтетическое дерево соответственно Чем меньше синтетическое дерево тем быстрее применяются следу оптимизации области памяти мы будем хранить переменную в куче или в стейке что соответственно влияет на давление на Garbage колектор inlining позволяет встроить тело функции э вместо её вызова мы экономим на вот этом самом переходе от место вызова к телу и обратно и де виртуализация преобразование м косвенного вызова метода то есть от типа переменной интерфейсный к прямому вызову то есть от конкретного типа и вот в гунг использует две из этих оптимизаций На данном этапе своего развития это Илан и виртуализация и перед тем как на самом деле рассказать как влияет на всё это дело Я бы хотел бы погрузить вас в то как эти оптимизации работают по дефолту И начнём пожалуй с иланга на слайде представлен блок констан который по факту определяет всю работу и первый же из этих констант ма Рав единим рассказывает нам о том как это всё работает оптимизация на вход получает функцию и сразу же присваивает ей вот этот бюджет на встраивание 80 единиц далее мы рекурсивно обходим тело функции проверяя каждый её элемент который вфа зачат уго стоимость то есть вес каждого элемента мы уменьшаем бюджет на встраивание соответственно со стоимостью этого элемента в конце прохода мы проверяем значение нашего бюджета по итогу если он равен нулю либо больше нуля мы встраиваем если нет помечает и весь ла на словах сду констанс стоимость их которые вынесены вот как раз-таки для отдельных случаев первая Константа у нас описывает стоимость встраивая стоимость нахождения метода ещё одна Константа Extra Call cost равно 57 определяет стоимость встраивания невстраиваемый вызовов это те вызовы которые оптимизация посчитала уже не встраиваемы на по критерию бюджетирования паника с минус единий А те методы которые внутри себя используют вызов Run раскручиваю стек приравниваются к значению бюджета и такие функции в принципе не строятся но тут есть один интересный момент с Inline Extra Call cost равный 57 вот не знаю как вы лично я привык к более круглым числам 50 60 55 Есть ли какие-то идеи Вот вот почему 57 И на самом деле это быть несерьёзный ответ Давайте подумаем Есть ли какие-нибудь идеи насчёт этого так коллеги Сейчас микрофон дадим Для различных догадок видимо рабочих компилятора была какая-то большая база тестовых программ и они таким образом нашли какой-то минимально Ну какой-то оптимальное значение из этого серии там от оного до 8 как раз Хороший ответ Возможно это просто ближайшее там к шестидесяти простое число которое просто чтобы не делилось и не вызвало никаких проблем при подсчётах дальнейших это было бы круто но вот это вот не так Окей на самом деле это ответ вот ближе к этому на вопрос жизни вселенной всём прочем раньше Константа была значением 6 но один из Энтузиастов подумал и А давайте на своих кейсах прогоню Вот это ВС дело от 50 до 65 каким-то непостижимым образом 57 дало наибольшую среднюю скорость применения оптимизации поделился в блоге к нему пришли проверили реально так Константа теперь 57 к чему я это веду весь Да и в принципе как мы увидим вэтом основании прочном это просто какие-то критерии которые разработчики взяли себе для разработки данного инструмента Ну окей Давайте быстренько са аккумулируемых Илан имеет бюджет то есть критерий на встраивание А во-вторых все элементы тела функции тратят бюджет но я даю небольшой спойлер и иногда некоторые элементы позволяют увеличить бюджет на встраивание и Об этом я обязательно скажу далее скажете Кирил Ой у тебя вообще-то было написано о том что ты покажешь исходники покажешь как это всё работает изнутри прошу функция Pack Извините меня за мой английский это функция точка входа для работы с оптимизация а она работает с пакетами получаю её их пакетные верхнеуровневый функции и применяя к ним оптимизации если говорить прон он делится на два этапа на Первом эта мы во-первых проходим по всему синтаксическому дереву проверяя функции на встраиваемой и расставляя соответствующие флаги а на втором этапе мы Валиди эти расчёты и производим непосредственно перестраиваем синтаксического дерева таким образом чтобы получить по факту новый код функция второго этапа DIR and Inline намекает на то что лизация ining будут как-то связаны но Давайте проливаем в первый этап иланга здесь сразу вид флажок имеется L Это флаг который Включает выключает то есть по факту Мы можем с вами влиять на то будет ли применяться оптимизация или нет функция считает количество функций которые не являются замыкания ажк курсив говорит нам о том Есть ли функции которые Взаимно рекурсивные внутри пакета если у нас соблюдается условие что не существует рекурсии либо она охватывает больше чем од функцию и и проверять функции на встраивание и здесь функции Canon мы можем встретиться с двумя причинами двумя группами причин не встраиваемое первая группа причин зависит от праг праг - это текстовый директивы которые позволяет компилятора понять что делать с кодом в зависимости от определённых условий он не является частью языка его нет спецификации он используется только для компиляции в нашей с вами работе это очень плохой тон использовать Однако Я бы хотел заострить внимание на двух прама которые вс-таки разработчик Может в своей жизни использовать при разработке это on и R как и как и их присутствие присутствие всех остальных гм запрещает встраивание функций к которым они относятся даже без проверки тела этих функций также производится проверка на пустоту тела что Логично функции пустой Зачем нам её рассматривать мы помечается и живём счастливо вторая группа причин зависит от содержания тела функции мы не строим функцию если внутр неё определена рутина если там есть вызов recover если мы мы там определили фр либо у нас имеется хвостовой вызов или флаг incl равен нулю флажок этот - Это флаг дебага соответственно если он равен нулю то любая функция которая в себе содержит замыкание не встроить и таким образом с помощью этого флага мы можем влиять опять-таки на эту самую оптимизацию остальные случаи пока что слишком сложны для нашего с вами иланга в Гонг Но развиваемся дальше и чуть ранее Я сказал о том что некоторые элементы функции всё-таки помогают увеличить бюджет на встраивание какие же это кейсы паника на первом же пункте и вы меня спросите Кирилл ты только что показывал что паника встраивается у неё есть отдельная Константа она была минус о в чём прикол а как обычно велосипеды и всё такое прочее по факту это Хак внутри компилятора сидит один из тестов который которому необходимо при наличии паники увеличивать бюджет иначе он не пройдёт если мы говорим про выражение метода то в этом случае он будет этот кейс работать только в случае когда мы используем механизм ш преобразование типов указателей разыменования блок скоупа не генерируют кода Согласно документации соответственно и ничего не тратят А вот интересно с со множественным присваивания за кулисами компилятора мы имеем преобразование кода которое происходит при в том моменте когда мы встречаем множественное присваивание чтобы компенсировать это время преобразования мы накидывай по определённой формуле определённое Значение бюджета все остальные кейсы тратят этот бюджет это паника вызовы которые могут быть встроены что логично это вызов Анда равный нулю замыкание при флажок и Fun closers больше чем нолик вызов функции который не встраивается это T57 Ну и всё остальное на самом деле по дефолту любой не описанный элемент в коде тратит минус единичку от общего бюджета и это первый этап на втором этапе функции в методе TR мы непосредственно уже проверяем расчёты первого этапа и преобразуем код Почему мы проверяем оптимизация используют структуру синтаксическое дерево которой передаётся по указателю Что это значит дерево может быть изменено в какой-то момент времени чтобы проверить наши рас мы обяза чтобы перестроить код Мы обязаны проверить расчёты вот и всё Илан реализуется таким образом но Обратите внимание Мы перед вторым этапом вызываем метод из пакета viral под названием Static Call и это та самая де виртуализация вызова почему она находится именно здесь давайте выясним как я уже сказал виртуализация - это преобразование косвенного вызова прямому на слайде представлен пример косвенного вызова от переменной типа интерфейса Когда нам необходимо использовать таблицу интерфейсов для того чтобы понять от какого метода вызывать данный метод виртуализация позволяет вытащить конкретный тип в моём случае Example и перестроить код вот таким вот образом мы не используем таблицу интерфейсов экономя на том что к ней не Обращаемся и не ищем у конкретного типа конкретный метод в общем случае Такой тип называется Мы помним интерфейсу может соответствовать любой Тип который реализует этот интерфейс Но что происходит непосредственно в логике работы де виртуализации во-первых оптимизация проверяет что вызов - это вызов метода от переменной типа интерфейса что логично другие вызовы в принципе ну не подлежат виртуализации далее от места вызова рассматриваемого мы идм вверх по телу функции место преобразования конкретного типа к нашему интерфейсу тут есть особенность компилятор может не найти такое место либо найти и понять что в этом случае внутрь функции может передаваться больше чем один статический тип в этом случае виртуализации не хватает данных на то чтобы понять какой тип подставлять и она заканчивает свою работу но если мы нашли такой тип мы радуемся и производим обратное преобразование типа метод у конкретного нашего с вами найденного типа и опять-таки виртуализации может быть отказано отказано по двум определённым случаям во-первых если вызов метода находится в блоке в блоке гофр то в этом случае виртуализация не произведёт Почему Потому что мы уже второй раз видим что при го оптимизация реализуется ВС на самом просто при возни паника переходит из вызова нашего метода в блок Go компилятор не может это обработать и например при в том моменте когда мы в recover панику пытаемся обработать у нас могут получиться невалидные расчёты по тем данным которые мы хотели бы получить разработчики такой кейс сразу зарубили на корню и во-вторых вот если мы находим это место преобразования интерфейса к конкретному типу и если это тип тоже интерфейс в этом случае компилятор Что делает он отказывается от своей дальнейшей работы по одной причине он консервативный ему не хочется тратить время на то чтобы искать дальше по дереву что-то искать переходы очередные Нет ему это не надо компилятор ленга позиционируется как быстрый он он встречает место преобразования понимая что интерфейс интерфейс с интерфейсами у него не хватает данных в синтетическом дереве он заканчивает свою работу Как пример на самом деле простой более упрощен потому что на самом деле то что я сейчас сказал сразу сам не особо понял есть у нас с вами буфер типа bufio преобразуем в интерфейс read Writer его в интерфейс rter вот с места вызова райте мы идём вот в первое преобразование двух интерфейсов и вот в этом месте мы отваливаться здесь ленивая Но это было бы лишь пустой трёп если бы не тестовая Задачка Я люблю животных И в особенности кошек и собачек вот даже тех животных которые в Австралии живут хотя именно из-за них Я скорее всего туда и Боюсь ездить но Давайте представим что мы работаем в международной компание которые содержит приюты с кошечками собачками нам что необходимо мы отслеживаем кому и куда и сколько отдали наших подопечных в лучшую жизнь а во-вторых мы хотим стимулировать людей на то чтобы они забирали наших животных себе И заботились о них мы делаем проводим конкурс награждаем те дома где больше всего кошечек и больше всего животных в целом на выходе е и сортируем полученные данные если честно код получился довольно Громо и поэтому вот структура вызовов что из неё Понятно есть сервис с одним хендлеров это функция все вызовы последовательные я не делал никакого параллелизма мсте дома структур у нас приходит на вход из сервиса который генерирует нагрузочную из сказок утка яйцо игла и так далее но Обратите внимание на этот код это как раз-таки точка входа во всю логику do Work и она принимает в себя переменную типа интерфейса А этот пример пока будет показывать Как происходит виртуализация и вот если бы я перед вызовом этого этого метода поставил бы какой-нибудь swich который бы рандомно закидывал туда различные типы тут бы виртуализация как раз-таки не сработала но в моём примере я закидываю один конкретный тип виртуализация будет произведена тоже небольшой спойлер структура вызовов с с учётом сигнатуры я использую только входные данные это видно ком код получаем логи и это логи и встраивания и де виртуализации у меня встроили все методы которые оказались небольшими по своему объёму их стоимость меньше чем 80 единиц все остальные не встроили потому что у них стоимость выше Обратите внимание на третий на третью строчку там виртуалити вызов метода D к конкретному типу Country мы не используем интерфейс таблицу вот так выглядит структура вызовов уже встроенная встроили листовые вызовы они небольшие и строилась функция собственно говоря вот так вот я продемонстрировал работу оптимизации по дефолту Но сегодня мы говорим про И как же она реализуется в Гонг в Гонг описывается четырьмя переменными две из этих переменных - это мапы мапы принимают себя наиболее горячие вызовы что это за вызовы наиболее часто вызываемые мы их берм из файла профилирования как раз таки вот этот вот этап профилирования нам необходим мы получаем по факту Взвешенный Граф вызовов и работаем с ним чем больше стоимость у вызова тем он горячее А если он горячий мы его определяем в мапу переменная под номером три по факту используется только в де баге а переменная под номером Она позволяет отсе обм обму от всего от всей стоимости графа те вызовы методов которые нам необходимы Окей начнём с того как работает с виртуализацией мы уже видели этот метод Pack это точка входа с оптимизация во-первых можно уже сказать о том что существует переменная проа именно она в себе содержит этот взвешен Граф вызовов А во-вторых у нас существует и флаг дебага на данный момент потому что скорее всего его потом когда-нибудь уберут это P включение выключение виртуализации Обратите внимание Вот на что во-первых эта виртуализация вызывается отдельным методом а во-вторых она вызывается вообще перед всеми остальными оптимизация Ну почему отдельным методом я сейчас расскажу А почему она здесь ну Откровенно говоря там сейчас есть комментарий который намекает на то что ребята Здорово Что вы сюда его поместили но Давайте его переместимся так что не факт что в два Трей двадцать четвёртой версии языка этот метод останется на своём месте Но почему он отдельный мы уже рассмотрели что есть виртуализация стандартная Что она делает она проверяет что у нас есть метод вызываемый от интерфейса и у неё есть ограничение если больше чем один тип передаётся в этот в эту переменную которую мы расма оптимизация не используется оптимизация работает несколько иначе она мало того что работает вот с методами типа интерфейса Она позволяет работать с замыкания переданы в качестве параметра внутрь функции это очень интересно потому что На данном этапе по факту про производится иланг Но какой именно механизм реализует это образом и этот пример Я честно взял из документации по факту мы проверяем что метод находится в наиболее горячей мапе а далее вытаскиваем информацию о том какой тип наиболее часто в данном конкретном месте вызывается и преобразуем вызов метода в If else соответственно приводя переменную типа интерфейса конкретной переменной мы не используем таблицу интерфейсов profit иначе ну Работаем как обычно вот так вот преобразуется де виртуализация как мы работаем снм И здесь я немного слука потому что описывается пятью переменными и пятая переменная - это in H Мад она равна 2 единиц и вс Что она делает она заменяет изначальный бюджет 80 единиц вот и всё Вот и вся работа с инго она производится здесь в про нас есть в горячей мапе и если все условия соблюдены мы увеличиваем бюджет Илан становится более агрессивным именно из-за того что мы увеличиваем бюджет на встраивание ну интересно но довольно просто заметьте что вот иланг в гонги Довольно простой в своей реализации А я напомню что структура вызовов в моём примере выглядит следующим образом Но что будет если я вдруг возьму и сделаю следующее я я соберу профиль засуну его При следующей компиляции у меня строится пять новых методов и стоимость их встраивания будет больше чем 80 единиц как мы видим есть пример с со встраивания 197 единиц в 91 единицу Это здорово оно у нас всё работает получается вот так вот выглядит структура вызовов уже с новыми методами то есть не только листовые но е методы родителе встроили и отдельно вся сортировка нуже Здорово оно работает получается ну оно как-то влияет получается на оптимизацию Но что она может дать нам по-настоящему даже в моём таком довольно простом примере на арми где количество инструкций меньше Я получил прирост производительности в 45% этот процент как раз таки попадает в тот процент который обещают разработчики 2 тире 14% прироста производительности для того же скажем Ну амазона это Деги сэкономленные и также ресурсы процессоров то есть по факту время работы одной операции у меня уменьшилось на эти 4 С5 секунды процента и вот в этом Профит P помогает нам именно за счёт работы с оптимизация которые есть в Гонг увеличивать скорость работы наших сервисов и Это ли не здорово давайте рассмотрим Какие положительные стороны вот при работе с Peugeot мы можем для себя раскрыть во-первых P помогает оптимизировать код конкретного сервиса под конкретную нагрузку что это означает неважно какой код вы написали Неважно как вы нагрузили нагрузка может меняться и соответственно собирая профиль мы под конкретную нагрузку оптимизируем наше приложение Это здорово во-вторых Мы расширяем стандартные возможности наших оптимизаций компилятор гон оптимизируйте оптимизации и без всяких там дополнительных возможностей реализует но с помощью и с помощью предсказаний через профайлинг мы разрешаем нашему компиляторы действовать наиболее агрессивно а также вот на самом деле всё что я сейчас рассказал не обязательно знать разработчику всё что нам необходимо - это собрать профиль засунуть его в компилятор и мы получаем прирост производительности но как том самом анекдоте У нас есть н и во-первых это конечно же дополнительная нагрузка на компилятор чем больше встраиваемых э элементов тем дольше он работает как итог на самом деле чем больше элементов Мы устраиваем тем больше размер бинарник в процентном соотношении Да которые бы мы могли бы получить но как мы видели и в Расте и в ленг и в остальных языках э механизм имеет примерно да одну и ту же применимость поэтому нагрузка на компилятор Ну от этого не уйти а От чего бы можно было бы уйти так это от простых моделей оптимизации что иланг что виртуализация могли бы быть намного сложнее В своей реализации А на данный момент Они не позволяют покрыть определённое количество кода в том числе из-за того что мы любим и умеем работать с го рутина Мы обязаны и я хочу подчеркнуть обязаны собирать профиль с рабочего окружения если мы получим невалидный Граф вызовов Взвешенный мы во-первых вообще ничего не достичь А во-вторых даже и уменьшить перформанс наших с вами сервисов читал статью когда двадцать первая версия вышла там ребята смогли получить мину 7% уменьшение скорости действия своих сервисов просто потому что они сгенерирована получили профиль сгенерировано нагрузки А на Настоящее они получили просадку Ну и конечно это увеличение дест выкатываем сервис собираем профиль пересом выкатываем снова и смотрим чтобы ничего не сломалось Окей Какие же выводы мы можем сделать с вами прослушать прослушав всё это ну во-первых это то что P он существует и в других языках это далеко не новый инструмент но в Гонг он появился полтора года назад Окей с этим можно работать но даже и без всяких стероидов наш компилятор - это оптимизируют код который на он заведомо оптимизирован и Это ли не прекрасно только вот заставляет компилятор быть более агрессивным за счёт полученных данных с профилирования мы позволяем компиляторы захватить большую часть кода мы позволяем ему пофантазировать о том какой тип реализовать здесь что мы можем строить сюда Однако есть особенности рабо с этим инструментом нет соответственно нам просто необходимо эти особенности учитывать и с удовольствием использовать в своей непосредственной работе получая Профит просто из файлика профилирования на этом У меня всё на самом деле благодарю голосуйте за доклад готов ответить на вопросы Спасибо большое за доклад Есть ли вопросы в залес у ва во пожалуста высоко Вашу руку к вам подойдут молодые люди в красных футболках выдадут микрофон произносите свой вопрос пожалуйста Чётко и ясно в микрофон держите микрофон урта это очень важно Здравствуйте А у меня вопрос возник получается вы показывали то что Константа про стоимость бюджета становится 2.000 мне встать наверно что Спасибо большое Ну вот а потом Когда вы показывали Граф стоимости там получается Ну у всех вызовов стоимость была меньше чем 2000 но при этом заин только часть вызовов которые там были около 100-200 Вот почему так это у нас определяется непосредственно той МАПО которую мы собираем с профайлинга если функция не попала в пул наиболее часто вызываемых Она её работа с оптимизацией останется такой же как и была А вот если она будет присутствовать в мапе тогда ей позволено иметь бюджет больше чем 80 Вот только вот в этом случае она будет встраиваться с бюджетом больше чем 80 если она вызывается не очень часто в нашем рабочем окружении то и как бы она не попадёт в профайлы с P Спасибо я Напоминаю что вопросы Также можно задавать в чат зала особенно если вы смотрите нас онлайн Я зачитаю ваш вопрос Вы получите ответ Следующий вопрос из зала Давайте дадим слово свинке Мне кажется Ну это достойно я её сегодня не выиграл К сожалению я сомневаюсь что у меня вообще будет шанс раз раз здравствуйте Да спасибо за доклад У меня два вопроса Первый - это вот мне как разработчику нам Мне вот очень интересно Если я использую Ну я достаточно умный разработчик я могу е подсказать есть ли возможность каких-нибудь ключевых слов типа in как код это делается то есть чтобы я на функции написал inine и такой о разработчик написал in скорее всего эту функцию надо зайни есть ли такое что-нибудь У нас есть возможность запретить иланг как раз таки через директиву Но именно с со встраивания компилятор работает без указателя от разработчика без указания он встраивания уза разработчики Гош именно и второе там по-моему было на слайде что нельзя встраивать функции с рутина если я не ошибаюсь не встраиваются Дани не встраиваются А почему Скорее всего я на самом деле не особо подготовил ответ на этот вопрос я знал что он будет но мне кажется это всё из-за того как происходит работа со стеком внутри ран тайма скорее всего там что-то с со счётчиком с указателем происходит Гошка не успевает или не может что-то выполнить какие-то расчёты из-за этого просто такие кейсы рубятся Спасибо пожалуйста Спасибо ещё вопросы в зале Давайте дадим слово молодому человеку тут раз добрый день Кирилла Меня зовут Эдуард такой вопросик вот если применять вот эту агрессивную более агрессивный подход А вот Как это влияет оценивали на то как попадает в кэш процессора на Сам на архитектура Как влияет на это процессор Потому что есть разные процессоры многоядерность процессора и система когда многопроцессорные к примеру компьютер Вот есть какая-то статистика и есть какой-то взгляд на это к сожалению не у меня такой статистики Нет я её не нашёл пока нигде тоже это очень хороший вопрос а Могу лишь сказать М что вот на архитектуре армы а будет ну по моим личным ощущениям скорость возможная прироста будет меньше чем на восемьдесят шестой например Вот потому что на том на той же Лину Я получал с тем же кодом э ну X2 точно то есть Ну всё зависит от архитектуры точно зависит вот процентов не могу сказать и из процесса Вот вот вот именно с Шом тоже не могу к сожалению Спасибо ещё вопрос из зала из левой половины зала дадада Спасибо за доклад очень интересно у меня на самом деле вопрос Вот про теорию всё супер Понятно А вот про прикладное использование Мы конечно же можем зайти на продакшн снять профиль в какой-то энный промежуток времени вот во-первых Имеет ли Большую разницу что условно мы снимаем в пиковую нагрузку или там при средней нагрузке может были такие замеры и второе Интересно а вы уже автоматизировали это решение Ну то есть как у вас Может автоматом профили снимаются в нужный момент времени чтобы потом автоматом подложить под следующую сборку это Бинго на самом деле я отвечу сразу на вторую часть никакой автоматизации Пока нет единственно есть инструмент графана недавно выпустила перископ по-моему Cloud Fair уже с этим работает Это позволяет наиболее Ну удобно там подменять профили вот так а первую часть вопроса можно пожалуйста ещё раз повторить Передайте ему ещё раз микрофончик пожалуйста Имеет ли разница снимать профиль в пик нагрузки илич нагрузку Всё верно тут на самом деле такой подход в зависимости от того что требуется есть ещё такой кейс Когда наши сервисы ну е нельзя предсказать в течение дня то есть у нас какие-то Рандомные всплески могут бот приходить или ещ что-то Да в этом случае вообще рекомендация от разработчиков снимать профиль частично То есть можно там в одно время в другое время в третье время есть механизм жа профиле общий профиль используется но увеличивает время деплоя опять-таки и инструмент ска сужа окно выд Спасибо ещ вопросы Из зала Давайте дадим слово центру зала мы бежим бежим бежим Да привет Спасибо за доклад у меня вот вопрос по константам которые были в начале там у одной константы был коэффициент ноль ков в ЧМ смысл Суть в том что как я сказал весь инструмент инструмент эмпирический разработчики создали какой-то свой инструмент Ну в плане Вот именно ограничили его работу именно теми значениями которые они прогоняли на каких-то своих тест-кейса он вынесен в отдельную константу соответственно это нам намекает на то что в дальнейшем просто с изменением Циферки Да вот в этой строчке кода этот будет ну изн будет по всему коду соответственно на данный момент разработчики считают что стоимость вызова таких стоимость нахождения таких вызовов Ну ничего не стоит Но может быть в дальнейшем они оставили себе такой так скажем окошко на то чтобы варьировать этот параметр то есть объяснение Почему ноль Как такового нет можно исходить только из того что ребята по каким-то своим критериям во-первых всё отобрали потом возможно прогнали там с пятью с единичка и поняли что он может очень сильно особенно в циклах for влиять на встраиваемой и посчитали что А может и не надо но пока Спасибо ещё вопросы Из зала дните руку Давайте подойдём в левой половине зала там много рук Подойдите Добрый день вопрос тоже по константам бюджетирования вот этим я правильно понял что они используются одни и те же в Независимости от целевой платформы на которую собирается Да Независимо всегда всегда 2000 то есть то есть дефолтный гон по-разному оптимизирует не одинаково хорошо оптимизирует Под разными платформы ну по факту Да не одинаково хорошо Прикольно спасибо спасибо ещё вопросы да спасибо за доклад А скажите а вот вы рассказали так много про этот инструмент А у себя в компании вы его внедрили или проходит сейчас процесс этого внедрения насколько болезненно с сопротивлением это происходит А на данном этапе мы пока кустарно пытаемся этот инструмент затащить к себе на определённом сервисе э но в дальнейшем Да мы мы планируем это просто всё как-то автоматизировать и строить в пайплайн Но вот как раз-таки вопрос был про вообще автоматизацию пока даже коммьюнити особо не подготовило каких-то инструментов для того чтобы работать с этим Ну в автоматическом режиме Поэтому вот в этом случае есть сложность Спасибо ещё вопросы в зале Давайте дадим слово левой половине там всё ещё остаются руки лес рук как говорила моя учительница по русскому языку Блин ну тут-то правда А моя преподавательница обычно врала на этом месте Да тут правда лес рук Спасибо за доклад У меня есть пара вопросов про де виртуализацию вот классическая с обычным компилятором если у нас есть интерфейсного метода и в функцию в качестве этого интерфейсного параметра всегда подставляется одно и один и тот же реальный тип то он может заини в общем как я понял да А что если у нас там 20 вызовов функций они все передают интерфейсный тип Но вот самая первая она вызывается с реальным типом и только единственным такое будет Илай или только один вызов так А можно ещё раз если у нас допустим 20 методов друг друга вызывают все Все передают интерфейс Reader Да но самый первый в него всегда передаётся единственный динамический тип виртуализация работает с конкретным вызовом если в конкретном вызове Она видит что там всегда только один тип она его виртуалити короче да независимо от того что такое у нас интерфейс 3Д 5 методов 20 методов мы в любом случае работаем по месту хорошо и второй небольшой Вопрос вот с пго мы уже можем в случае если какой-то тип часто является интерфейсный реализацией за Ифа его если у нас такой-то тип то вызвать его реальный метод не будет ли Вот эта проверка виртуального типа тоже дорого стоить так же как и виртуальный метод Вот это вопрос который я ждал это классный вопрос Если честно я свои замеры не делал вот Откровенно говоря но в целом у нас виртуализация по дефолту она тоже по факту приведением типа занимается обратным да то есть Ну видимо и там и там эта проверка она по стоимости ниже чем проверка наших таблиц интерфейса могу ответить так спасибо А помните что в дальнейшем докладчик уйдёт в дискуссионную зону и с ним можно будет там пообщаться не просто задать вопрос а развить какую-то дискуссию поспорить не знаю похавать если хочется потравить анекдоты тоже если хочется есть ли ещё вопросы в зале поднимите пожалуйста руку и мы к вам подойдём Спасибо за доклад Меня зовут Максим а скажите Кирилл А ну вот вы сказали что через P можно расширять иланг а сужать его можно Ну то есть условно Ну Илай бы проста у какой-то функции А после прогона профиля ну после получения профиля прогона P вот мы получили что туда Илай не нужен и компилятор его там не поставил в обратную сторону с pug это не работает Peugeot именно работает на расширение Но есть один лайфхак я не помню как называется флажок его можно выставить таким образом чтобы стоимость встраивания была больше или меньше 0 поэтому На данном этапе его он по-моему в дебаг лежит им можно манипулировать сейчас то есть ставить вместо 8050 изначально или увеличивать значение Но опять-таки это влияет и на скорость компиляции да и на то количество кода с которым будет работать поэтому нет сужать мы не можем никоим образом компилятор сам принимает решение Спасибо ещё вопросы в зале Давайте подойдём опять же к левой половине зала там остались руки Привет Кирилл Меня зовут Лёша Спасибо за доклад меня зацепил слайд где приводится к Ну де виртуалити El Да конструкция конкрет Да тип Ну я же умный разработчик Я же могу сам это всё написать но для чего я подаю выдумываю интерфейс я пытаюсь развязать от циклических зависимостей и как справляется получается компилятор когда подставляет зависимость которая может циклически мешать её использовать То есть когда я напишу вот такой и и возникнет циклическая зависимость Ну это всё это значит я у меня код не скомпилировать эту циклическую зависимость поставить конкрет который же зависит от реализации этой функции а функции которые являются точкой входа с работы в оптимизации есть флажок рекурсия и вот этот флажок Мы же Идём рекурсивно по телу вызовов по телу метода или функции и попадая в вызов мы проверяем есть ли там внутри рекурсия дополнительно с рекурсией ни одна оптимизация не работает компилятор старается рекурсивные какие-то вещи если мы вдруг это делаем да обходить стороной для него эти вещи сложны он Ну ничего не научился перестраивать код таким образом чтобы устанавливать себе какие-то границы Спасибо у нас есть время на один последний вопрос поднимите пожалуйста руку Давайте подойдём в левую половину зала А я Напоминаю что у нас на экране есть QR коды пожалуйста сканируйте нам очень важен ваш фидбек ваши оценки Да спасибо за доклад вообще я на голос плюсов переходил и не умел Почему нет лайно вот они появились Вот Но вопрос я задам скучный вот го Ну я в основном использую для веб-разработки а веб-разработка она а Bound Вот и в основном я жду Там данные от других сервисов от баз данных Неужели вот в реальном продакшене Ну вот эта де виртуализация как-то влияет стат значимо на на скорость работы сервиса именно виртуализация Ну нет Я имею в виду встраивание нула на самом деле у нас есть такой кейс что один из сервисов непосредственно у нас в компания имеет определённую сложную логику с вызовом различных методов в разных местах у него большая кодовая база на примере очень удобно как раз таки и смотреть что даже в этом случае веб-разработке да мы можем получить у некоторых сервисов да то есть ну какой-нибудь bff вряд ли в него лайнинг как-то Здорово заедет Да но вот те сервисы которые непосредственно производит определённую работу внутри себя вот тут вот мы можем выиграть достаточно большое количество по скорости Спасибо большой это был последний вопрос У нас закончилось К сожалению время Но помните что нной зоне можно до задать вопросов и ещё поговорить Спасибо большое за доклад Кирилл давай выберем вопрос который тебе больше всего понравился для того чтобы вручить подарок от онтика мне вот понравился вопрос молодого человека в футболки кирпичного цвета отлично молодой человек футболке кирпичного цвета Пожалуйста поднимите высоко руку чтобы мы вас увидели и подарили вам подарок вас Мы тоже Хотим поблагодарить большое спасибо что пришёл было класс Я надеюсь ты придёшь ещё раз вот Держи подарок так сейчас Спасибо вам что пришли сейчас мы уходим на небольшой перерыв"
}