{
  "video_id": "l29_pFa2QLQ",
  "channel": "HighLoadChannel",
  "title": "Статический анализ как ответ на вопрос о повышении качества кода / Сергей Васильев (PVS-Studio)",
  "views": 1330,
  "duration": 2507,
  "published": "2019-06-03T08:55:37-07:00",
  "text": "ну всем привет меня зовут сергей и сегодня я немного по рассказываю про статический анализ посмотрим на ошибок рассмотрим сценарий внедрения правильного неправильного использования и и поговорим о том какие проблемы могут возникать при внедрении статического анализа вот кроме того у меня есть несколько подарков такая вот например крутая шапка и тульские пряники они даются за лучшие вопросы вопросы прошу задавать в конце доклад по да я расскажу доклад и и потом отвечу на ваши вопросы обозначим сначала а нет кто-нибудь не в курсе что такое статический анализ ну то есть стоит ли мне про это пару слов сказать ok статический анализ этот такой анализ программного обеспечения который выполняется без его реального исполнения в контексте данного доклада мы будем говорить о статическом анализе как а средстве поиска ошибок и соответственно повышение качества кода сначала я хотела немного остановиться о проблематике и обличить это все в какие-то цифры и графики например здесь изображены графики возрастания плотности ошибок в соответствии с увеличением размеров проекта соответственно горизонтальная ось это размер проектов тысячи строк кода а вертикальную ось количества ошибок на тысячу строк кода соответственно зеленая линия это минимальное количество ошибок оранжевое максимальное осени и что-то усредненное из этого графика следует простой вывод что чем больше размер вашего проекта тем большее количество ошибок приходится на один и тот же объем кода следовательно нам необходимо заботиться о том чтобы использовать как можно больше автоматизированных и не только методик обеспечение качества кода и статический анализ является одной из них немного затронем тему узи масти смотрите уязвимости это баги иногда то есть по данным национального института стандартов и технологий сша больше половины узи масти это происходит от простых ошибок программирование а не каких-то специфичных security функций то есть банально ошиблись на единицу что-нибудь нулевой указатель раза миновали и получили уязвимость не всегда но это часто бывает и потом мы немного на это посмотрим таким образом повышая качество кода вы также неявное заботьтесь о повышении безопасности смотрите здесь приведено количество уязвимостей зарегистрированных по годам за последние 10 лет например до 2014 года каждый год регистрировалось несколько тысяч use масти но при этом общее количество не превышала 6000 а после 2014 года количество узи вместе уже не опускалась ниже этого уровня а что же с 2017 2017 самое интересное там произошел резкий скачок то есть количество зарегистрированных уязвимостей приблизилась к 15 тысячам это с одной стороны хорошо с другой стороны плохо почему это плохо потому что проблема есть и это наглядное тому демонстрация почему это хорошо хорошо потому что разработчики все таки заботятся о качестве своего кода и о его безопасности различных barbati пан программы назначают и так далее то есть динамика исправления уязвимости есть и она видна также важно отметить что стоимость исправления как простой ошибки такое дефекта безопасности возрастает со временем причем очень значительно следовательно нашей целью является как можно более раннее обнаружение и исправление проблемы в то время когда стоимость исправления еще минимально равно как и сложность отсюда следует несколько ключевых моментов количество уязвимостей обнаруженных последнее время сильно возросло и наша задача искать и исправлять как уязвимости так и проблемы как можно раньше и здесь самое время вспомнить про статический анализ потому что одно из его основных прямую есть это как раз раннее обнаружение ошибок вплоть до момента написания кода к тому же ему не нужно исполнять программу он покрывает всю кодовую базу более того он хорош в поиске различных паттернов ошибок но не всего понятное дело с обнаружением некоторых дефектов лучше справляется динамический анализ ну равно как-то не наоборот у статического анализа есть несколько недостатков в том числе и то воспользуйтесь ложные срабатывания то есть срабатывания анализатора на тот код который является корректным но анализатор счел его подозрительном следовательно такие зарабатывания засоряют шум это не так страшно как кажется и почему мы поговорим позже есть еще один момент предупреждение выданные статическим инициатором мы точно не не знаем их критичность то есть если ошибка обнаруживается динамическим анализом мы точно знаем что в ходе исполнения программы это ошибка может быть повторено со статическим анализом такого нет то есть может быть ситуация когда анализатор нашел проблему но оно где-нибудь закопано под большим слоем костылей и не проявляет себя еще немного скучные терминологии потому что на некоторых дальнейших слайдах и те сокращения будут встречаться есть такие термины для обозначения узи масти и вести домой и семьи sie w это потенциальные уязвимости то есть такие конструкции которые при определённом стечении обстоятельств могут дальнейшем стать реальными узи мастями севильи это уже реально из документированные узи масти дальше будет несколько фрагментов кода с ошибками и я предлагаю вам их попробовать поискать только просьба не выкрикивать в чем здесь именно проблема а просто поднимать руку тем кто нашёл ошибку хорошо давайте первый фрагмент кода кто видит здесь проблему кто-нибудь еще здорово тут достаточно тривиальна и все анализатор выдает предупреждение то что левые и правые операнды логического и одинаковые скорее всего в первом или втором случае у аргумент файл экзист должен быть другой еще обращаю внимание то что эти проблемы обнаружится разными анализаторами их предупреждения тоже приведены на слайде следующий фрагмент кода кто видит проблему здесь до 2 раза написали got the file причем это не просто какая то ошибка дефекты это реальная серьезная уязвимость и завез какое и обнаруживает анализатор например во первых видно что есть безусловный гоу ту а во-вторых форматирование кода не соответствует логике исполнения соответственно 2 голод у должен был быть сдвинут влево идем дальше кто видит проблему здесь кто-нибудь да все верно перепутали аргументы функции умеем сет заставляет значениями и некоторые блок памяти во втором аргументе принимает значение которое надо выставлять а автор этим и размере блок памяти здесь перепутали аргументы местами и из-за этого ничего не заполняется кто видит проблему здесь один человек побольше хорошо здесь проблема заключается в том что части условия бессмысленно так как выражение всегда будет истинным смотрите переменные у нас локально при этом ее значение не изменяется и выполняется проверка в условие цикла так как он не изменяется то и отвечаешь выражение сюда будет истинным идем дальше фрагмент кода и за андре-луи джона кто видит проблему здесь с этим тоже справляется анализаторы получаем указатель фрейм дальше создаем через него какое-то значение а потом что-то возвращаем но проблема в том что в последнем выражение указать проверяется на то что он не 0 но перед этим его уже разумного ли соответственно следуя из этого кода указатель может быть нулевым и если он действительно 0 то у нас произойдет разыменование перед его использованием и еще один фрагмент кода найдите ошибку на прошлой конференции я такой показал может смотрите давайте объясню тут в общем на самом деле две проблемы что мы хотели ну что разработчики скорее всего хотели сделать они считывают какую-то строку из входного потока данных если считывание прошло неуспешно то есть функция f get свернул то записывают нулевой символ по первому индексу то есть чтобы строка была 0 а дальше вычисляет вычитает длину строки добавляет не цу и записывают опять и терминальный 0 причем вне зависимости от того был успешно была успешно считывание или неуспешно проблема в чем если например считывание прошло неуспешно или мы построили данные таким вот образом чтобы входная строка была нулевой с точки зрения языка си то есть чтобы первый символ был терминального нулем у нас получится обращение по минус первому индексу стр или он возвращает ноль ноль соответственно так как строка 0 с точки зрения сие -1 получаем -1 и работу по минус первому индексу это интересная ошибка стоит точки зрения что она воспроизводится то есть немного покопавшись в ходе мне удалось вы здесь вас провести и эту проблему шаги следующие надо подключиться к серверу загрузить файл причем такой же файл уже должен существовать но иметь другие свойства далее приложение предлагает нам выбор действий соответственно необходимо ввести действия с заглавные чтобы задать файлу новое имя подстроим входные данные и в зависимости от условий приложения например может упасть здесь список конкретных команд вот например видео воспроизведение проблема то есть начала запускаем приложение сразу подключаемся к серверу после этого запрашиваем какой-то файл такой же файл но с другими свойствами уже есть локально ну и поставим со следующим образом входные данные в результате чего приложение падает такие вот фрагменты кода и их на самом деле намного больше при желании можно спокойно найти тем не менее некоторые аргументы поттера аргументируют необходимость использования статического анализа тем что например давайте обучаем новичков давайте обучим всех правильно писать код и тогда никакие анализаторы не будут нужны я не придумал это реально я слышал пару недель назад такое мнению естественно это невозможно во-первых потому что люди постоянно меняются во вторых потому что все мы люди мы можем отвлечься и допустить какую-нибудь банальную опечатку которая может стать например даже уязвимостью здесь приведены логотипы некоторых проектов небольшого числа в которых например успешно обнаруживаются статическими анализаторами проблемы в коде допустим выйдешь или проверить проект статическим анализом посмотрели ошибки порты находит ok давайте проверим разовые проверки это конечно хорошо стоит точки зрения что вы все-таки можете что-то найти и поправить какие-то критичные проблемы но все таки это не оптимальный сценарий использования проведем аналогию допустим вы начали разрабатывать какой-то проект и выключили все предупреждения компилятора разрабатывали разрабатывали и под конец перед релизом грубо говоря через несколько месяцев решили все их включить вполне возможно что вас завалят и вы не будете их исправлять вот со статическим анализом возможна такая же проблема которая на самом деле не проблема о чем я скажу чуть чуть позже к тому же как мы помним наша задача как можно раньше исправлять ошибки и при разум и использование вы можете уже обнаружить тех ошибок которые были исправлены раньше например да если раме или или разработчиками в результате длительной отладки в то время как если бы они использовали статический анализ они бы могли их исправить сразу после возникновения на конкретном примере посмотрим это фрагмент кода и из липой т.н. реальная уязвимость связана в общем с тем же что мы рассматривали чуть чуть раньше в случае с инсеев теперь если построить входные данные специальным образом чтобы считывание прошел успешно но при этом строка была нулевой длины у нас будет работа за пределами массива по минус первому индексу но разработчики посмотрели кода а киеву видимость надо исправить исправили на следующий код code поменяли буфер переименовали но тем не менее ошибка никуда не делась опять и если мы передаем специально построенную строку опять работа с по минус 1 дык су индексу и опять проблема повторяется опять отписали у вас здесь проблемы ребят поправьте окей с очередной попытки они поправили и добавили проверку на то что полученная строка имеют ненулевую длину самое интересное здесь том что между вот этим обнаружение вот это use масти и исправлением якобы прошло ой прошло пять месяцев то есть якобы исправили уязвимость и она еще полгода успешность существовала в то соответственно если бы использовался анализатор который смог бы обнаружить такую проблему в идеале это ошибка была бы избавлена прямо в момент написания кода ну или например после сборки отсюда следует первый ключевой момент то что использовать статические анализ необходимо регулярно именно тогда достигается максимальная польза от его использования малая регулярного использования дополнительно надо использовать анализ как локально на машинах разработчиков так и на сборочном сервере соответственно своевременно исправлять ошибки которые который обнаруживается и там и там в чем плюс локального использования при локальном использовании в момент написания кода стоимость ошибки минимально соответственно разработчик писал код ошибся анализатор сразу ему эту ошибку нашел разработчик исправил все окей кроме разработчики никто о проблеме не узнал ни в какую в репозитории она не попала все хорошо то есть при локальном использовании вы как бы выстраивайте первый рубеж обороны от ошибок для этого хорошо подходит такая методика как и инкрементальный анализ то есть анализ только того кода которые модифицируют или пишется разработчикам это позволяет сокращать время анализа и не анализировать тот кот с которым в данный момент разработчик не работает пример того как это у нас реализовано на практике мы разрабатываем статически анализатор если кто не знает вот у всех разработчиков которые используют visual studio установлен соответственно плагин pvs-studio и запущенные капитальные анализ соответственно интеллектуальный анализ запускается после сборки разработчик если допускает ошибку запускает сборку проекта запускается инструментальная сборка и если какие-то проблемы есть анализатор репортят об этом и ошибки исправляются еще до того момента как впадают в репозиторий тем не менее иногда бывает что ошибки все-таки просачиваются в репозитории ну мало ли не заметили не поправили или бывают такие ошибки которые возникают на стыке то есть при анализе измененного фрагмента кода только нельзя сделать вывод о том что была допущена ошибка поэтому статический анализ также должен быть развернут на сборочном сервере есть различные способы использования результатов анализа как правило анализаторы предлагают различные утилиты и фишки для работы с его результатами например конвертация в различные html отчёты рассылка писем автоматические заведения и шью и так далее соответственно все эти штуки тоже необходимо использовать для того чтобы получить максимум пользы еще пример того как это реализовано например у нас каждую ночь на нашем сервере запускается полный анализ тех проектов которые нам интересен соответственно во время этого анализа мы мониторим все ошибки которые были заложены в репозитории в течение дня мы мониторим несколько проектов которые потом при помощи специальные утилиты мертвого один большой отчет и при помощи и еще один уйти от одной утилиты которая по цепляется к системе контроля версий и берёт от анализатора выполняется рассылка писем разработчиков разработчикам которые эти ошибки в систем контроля версий заложили а также всем заинтересованным лицам соответственно второй ключевой момент то что статический анализ должен проводиться как локально на машинах разработчиков так и на сборочном сервере хорошо допустим вы решили внедрить анализатор в свой проект запустили проверили и на выходе получили 80000 предупреждений естественно не понятно что с этим делать ситуация может быть более плачевная если у вас тонны legacy кода возникают вопросы как все это править как это работало и что с этим вообще теперь делать как нам исправлять новые предупреждения как отличать их от старых начинаете разбирать отчет вылазит ложные срабатывания соответственно тоже непонятно почему анализатор ругается например на корректный код тому же анализируется какие-нибудь сторонние библиотеки и файл этот код который нам не интересен срабатывают диагностики которые не актуальны для нашего проекта и лет вполне ожидаемой реакции может быть что-то вроде вот этого тем не менее не стоит опрокидывать стал и так как все решаемо главное успокоиться вкратце обсудим проблему обозначенные ранее и их решение смотрите ложные срабатывания как правило это не проблема по нескольким причинам ложное срабатывание надо понимать они тоже бывают разные если это ложное срабатывание специфичные для вашего проекта то есть анализатор вроде бы ругается корректно но специфика вашего проекта такая что например функция какой-нибудь не никогда не может вернуть нам но анализаторы заподозрили в том что она может вернуть нам но специфика вас такая вы можете это срабатывание одно или несколько разными способами задавить по паттерну например или единичный если же это явный косяк анализатора то есть конструкция сто процентов корректная анализатор ругается выдает предупреждение то следует отписать разработчикам анализатора так как правило обе стороны заинтересованы в исправлении таких проблем разработчики улучшают качество своего продукта а на вашем коде вылезает меньшее количество предупреждений взрыв при первом анализе чем больше в вашем проекте и legacy кода тем соответственно может большее количество предупреждений быть выдана когда вы проверите все в первый раз это тоже не страшно задача здесь ключевая в том чтобы отделить старые предупреждения от новых и за ним не допускать появления новых ошибок в вашем коде со старыми предупреждениями приложение как-то работала ok пуская работает дальше мы отметим их всех как не интересны и оставим на потом разработчики тоже анализаторов предоставляют для этого средства таким образом после того как вы отметьте все предупреждения как не интересны на вашем ходе будет выдаваться ноль предупреждений соответственно каждое новое предупреждение это новая ошибка в вашем коде и наша задача не допускать роста этих ошибок а держать их количество на нуле а уже потом при необходимости мы можем вернуться обратно и посмотреть те предупреждения которые мы раньше подавили то есть отметили как неинтересные долгое время анализа решается упоминавшемся ранее in crime тальном анализом который может выполняться как например и локально так и на сборочном сервере случае локального использования анализатора это вообще оптимальная вещь если вы работаете с сырыми лагами в текстовом представлений или какой-нибудь там xml а у вас то скорее всего вы что-то делаете неправильно разработчики анализаторов предоставляют не только ядро то есть ту функциональность которая именно сосредоточено на поиске ошибок но и различные утилиты которые решают вспомогательные задачи и помогает интегрировать анализатором в ваши процессы разработки соответственно для работы с выхлопом анализатора тоже есть различные утилиты например конвертации в html отчеты с которыми потом удобно работать есть навигация грубо говоря к конкретному фрагменту кода где была допущена ошибка либо есть различные плагины в какой-нибудь sonear куб можно подцепить результат работы анализатора и отслеживает динамику и изменения количества ошибок в вашем ходим с предупреждениями на стороннем коде и неактуальными диагностика my в принципе та же самая ситуация нужных просто отключить то есть вам необходимо просмотреть посмотреть ага файлы например из этой директории нам совсем не интересно соответственно вы их просто исключаете из анализа и они больше не анализируются с диагностика my похожая ситуация бывает диагностики срабатывания которых не актуальны для вашего проекта например вам неинтересно срабатывание анализатора на сравнение чисел с плавающей точкой ну вы точно знаете что с этим у вас нет проблем в итоге вы просто отключаете ненужную диагностику и спокойно работайте дальше это на самом деле очень важный момент изучение предлагаемых разработчиками анализаторов утилит потому что некоторые сразу кидаются писать какие-то свои решения в то время как уже есть готовые и хорошо обкатанные соответственно при внедрении в проект общая методика внедрения складывается из нескольких шагов вы выполняете проверку своего кода и все обнаруженные предупреждения отмечайте как неинтересно и все с ними как-то жили до этого будем жить дальше наша задача теперь не допускать появления новых проблем в коде дальше вы настраиваете анализатор просматривайте блоги отключаете неактуальные диагностики исключаете те примеры срабатывать и примера диагностик которые не актуальны для вашего проекта и со старым предупреждениями работайте уже после настройки процесса в случае необходимости рекомендую пару статьи по этой теме в них описано наш опыт работы нашей команды по в студию с командой epic games где мы занимались как раз внедрением анализатора и исправлением ошибок обнаруженных в коде unreal engine может быть полезно там так как там описаны также подобные вопросы тем которые мы обсуждаем сейчас в итоге немного изменив график стоимости уязвимости и сначала и сначала презентация он будет выглядеть немного примерно так как я говорил стать при использовании статического анализа мы можем обнаруживать и править проблемы на этапе разработки и на этапе сборки ну где-то после сборки и в итоге мы можем при использовании статического анализа значительным способом значительно сократить затраты на их исправление дальнейшее проблем так как будем править их тогда когда стоимость минимально тем не менее не стоит забывать о том что статический анализ это все таки не панацея и от всех проблем вас он не спасет но это эффективная методика которая отлично сочетается с другими и позволит повысить качество вашего программного кода спасибо вопрос спасибо за доклад вопрос такой а известно ли вам случаи использования вашего продукта в плохих целях для поиска уязвимостей чтобы потом что-то нехорошее сделать нет конкретного случая не известно мне известно использование в хорошем смысле когда мы выполняли сопоставление наших диагностик с sie w и с потенциальными узи мастями то есть смотрели как сочетаю как наш анализатор справляется с обнаружением потенциальных проблем я брал отчет базу сивэй то есть реальных уязвимостей выбирал из них некоторые фрагменты коды которые были доступной и натравливал analyzer и в итоге обнаружилось что достаточно большое количество ну не то что но большое количество проблем удивим as they реальных связано с простыми и ошибками программирования например двойной год у взаимного нее нулевого указателя неявный каст и так далее то есть про плохие мне неизвестно а про хорошие я могу порекомендовать статью если вам интересно как пояс studio может помочь в поиске уязвимости где я рассматриваю такие моменты спасибо за доклад я здесь очень интересно было послушать и возникает вот такой вопрос а если у вас какие-то рекомендации скажем так как правильнее писать код для того чтобы статистическому анализатору было проще найти какие-то недочеты то есть точки зрения программиста один и тот же код можно написать и так и так и работать в приск вы будете одинаково но в одном случае там какие-то вычисляемые значения буду в другом случае не вычисляем еду то есть и для каждого из к программирования соответственно такие рекомендации было бы мне кажется интересно и полезно почитать и учитывать при написании кода а смотрите какой делом вообще например люди при когда пытаются оценить эффективность статического анализатора они составляют какие-то мудреные тесты то есть пытаются его обмануть вот но ошибки обнаруживаются в даже в достаточно простых конструкциях например часто ошибки обнаруживаются в функции сравнения когда хотя казалось бы этом сравнивается несколько полей друг с другом как там можно ошибиться какой-нибудь объект перепутали или поле перепутали и все вот она реальная ошибка то есть есть такое заблуждение о том что ошибки они обязательно сложные синтаксические ну сложных конструкциях хотя на самом деле многие ошибки существуют в простых конструкций до чем более мудреный код написан тем сложнее анализатору его проанализировать и тем больше времени ему может понадобиться ну какой то совет не стоит перу сложнить пишете код и понятной и людям и инструменту к тому же в анализаторах иногда есть различные подсказки которые помогают получают дополнительную информацию от кода то есть вы можете как-то сообщить ему например о том что ну дать какую-то подсказку для гонок для диагностических провел немного под настроив их тем самым ну в общем совет не надо переслать пишите простой читаемый код и для людей и для инструмента извите и можно еще небольшое дополнение то есть везде затронули тему еще скорости работы анализатора случается ли так что в коде очень большие ветвления происходит что анализатор очень очень долго работает то есть если такая проблема или нет если есть то как она решается спасибо а хороший вопрос кстати да такая проблема есть разные способы решения есть когда мы например вычисляем возможные значения для переменных есть большое количество ветвление у нас есть несколько подходов например мы можем либо обрубить все значения например сказать все мы ничего не знаем об этом коде он слишком сложной либо мы можем вычислить и сохранить какую-то информацию но при этом сказать то что мы вычислили не все значения то есть мы будем работать с каким-то диапазоном значений и те про диагностические правило которым достаточно будет этой информацией они будут срабатывать тем же диагностическим правилам которое необходимая информация полностью вычисляя она не например срабатывать не будут и чтобы не давать ложных срабатываний и еще такая вот мы как раз столкнулись с подобной ситуации несколько лет назад когда делались sharp анализатор есть проект я правда не сейчас не вспомню его названию в общем там даже падает студийные расширения syntax виза лазер там очень большое ветвление в коде была он его не осилила если пытаться посмотреть дерево дакота the studio подол а можно еще вопрос спасибо за доклад сергей такой вопрос насчет границ инкрементальные анализа то есть в говорили о том то что для если вы очень много времени занимает то используйте нко ментальный анализ но понятное дело до то что если брать в расчет только изменения самого программиста то можно взять дата пример обычный метод который всегда выращивал какой-то объект ну программе сделал одно изменение начал замечать ну вот и здесь ко дну их примеру данный метод который делает используется в 200 места по проекту и вот такой вопрос winter ментального анализа то есть какие-то границы ли какие-то градации какие там произведу . детальный анализ дату который еще зависимости для этого то есть какие есть виды рынка ментального анализа и есть ли они вообще ну вообще есть если я и говорил фрэнком детальный анализ смотрите здесь два момента первой все-таки границы определяются тем от чего инкрементальный анализ отталкивается грубо говоря если мы отслеживаем например запуске компиляторов там ему полагаемся например на миг систему да мы смотрим ну мы просто запускаем запускается майк мы отслеживаем компилятор который запустились ловим их и анализируем файлы с которыми они работали то же самое может быть и с другими и в сборке системы например мы можем полагаться на артефакты им из билда то есть и mosbuild отработал сообщил информацию о том какие файлы были затронуты мы эту информацию подцепили и соответственно проанализировали эти файлы и дополнительно я про это говорил и рекомендуется использовать полный прогон регулярно то есть если инкрементальный анализ все-таки что-то не подцепил чтобы на сборочном сервере это проблема была обнаружена и мы пофиксили спасибо здравствуйте спасибо за доклад хотелось бы узнать применительно к языкам какие больше все-таки языки подвержены статическому анализа такие менее подвержены смотрите я думаю статический анализ больше но лучше подходит для языков со строгой типизации со статическим потому что ну чем больше у нас и чем очень информации мы можем извлечь непосредственно из исходного кода или из какой-то его формы например при процитированного кода тем более эффективно пройдет статический анализ то есть без выполнения до каких-то дополнительных вычислений эволюции и там под 2 подобного к тому же касаемо языков статический анализ может быть популярен например для проектов которые написаны на старых или на старых языках или на тех языках которые более подвержены ошибкам например в тех же проектах на си плюс плюс находится больше проблем чем в проектах на шарпе потому что в open source ну например я листал список лит хаба там больше самих проектов больше объема этих проектов и в сейфе плюс плюс больше способов выстрелить себе в ногу соответственно статический анализ для них более актуален и приходилось сталкиваться например с тем что при портировании диагностика который актуальной для си плюс плюс касаемо сишарп вода они просто оказывались нерабочими потому что компилятор уже это отсека а вот спасибо и небольшой еще вопрос в боготе участвовали с инструментом нет пока не провал здравствуйте спасибо за доклад достиг то еще интересно у меня вот такое просто опыт разработки на си плюс плюс часто программа многопоточной у них типовой класс проблем рейс candychan ну типа там и снова потока обращаясь к ременные без мёдика вот если у статического анализа инструмент для поиска таких вот проблем с конечными статический анализ не очень хорошо подходит для поиска именно таких проблем но параллельных вычислений да то есть он может что-то пытаться какие-то диагностики могут быть реализованы но все-таки эта область применения динамического анализа у вас нету планов эту область осаке расширять в статическом анализе ли вы говорите 2 динамика тяжело-тяжело это анализировать в статике где спасибо за ответ еще вопросы если вопросов нет у меня небольшое дополнение можно пообщаться я тут еще буду также у нас есть стенд то можно пообщаться и у нас me to будет в a13 по-моему там тоже может задать вопросы теперь время награждение пряников да еще спасибо большое сергей за доклад можете ли вы выделить самый интересный вопрос по вашему мнению да я сейчас этим буду заниматься ну еще и длина а поднимите руки пожалуйста те кто задавал вопросы о у нас на всех получается подарков нет кому-то не хватит у вас один подарок наклейки давайте мне про инкрементальный анализ больше всего понравился вопрос вам достается супер шапка еще раз пожалуйста руки поднимите держите пряник прямиком из тулы и вам спасибо остальные вопросы тоже были классные но извините у меня пряников больше нет но у нас на стенде есть классные статусы на рабочий стол подойдите скажите я задавал вопросы вам дадут сразу без проблем а так еще для вас пользуемся красиво"
}