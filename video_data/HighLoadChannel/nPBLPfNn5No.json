{
  "video_id": "nPBLPfNn5No",
  "channel": "HighLoadChannel",
  "title": "PHP в асинхронном мире / Дмитрий Мамонтов (МАГНИТ)",
  "views": 216,
  "duration": 2152,
  "published": "2023-10-06T07:23:55-07:00",
  "text": "Всем привет Меня зовут мамка Дмитрий я занимаю должность руководитель команд Магните и сегодня вместе с вами и PHP Мы погрузимся в асинхронный мир Почему сказал лучший способ объяснить это сделать это если вы захотите попробовать это сами в один из зимних дней я расскажу вам как это удалось Алиса в стране чудес наш доклад будет разбит на два блока основы и файберы а что же будем говорить блоки основы это асинхронность реальном мире Как устроен PHP Ну и куда же без реальных примеров блоки файберы я вам расскажу что же это вообще такое принесли ли они асинхронность нужны ли они нам и какую проблему они решают Ну и конечно же сравним реализации и попробуем сделать выводы подготавливая доклад на реальных примерах объясняющих асинхронную обработку с нуля Я понял что примеров слишком много И выделить самые актуальный затруднительно серьезно Вы можете себе представить процесс природе который следует определенной последовательности или организованной очереди И асинхронно это не значит хаотичный например улей это единое целое живущее Как хорошо управляемая система Несмотря на то что каждая пчела действует самостоятельно занятая своей задачей Еще одним примером является человеческое тело где каждый орган действует со своей целью и процессом однако все прекрасно скоординировано с повторяющимся ударами сердца постоянным тиканьем и проталкиванием крови по всем частям системы на самом деле гораздо труднее представить что-то действительно синхронное природе Вы можете себе представить пчел к примеру ожидающих своей очереди чтобы войти в улей и чтобы положить в него немного меда Я думаю это невозможно а это чудеса равнодушно пояснил Чеширский кот вниз по кроличье нарен если углубиться в тему PHP это язык сценариев общего назначения особенно подходящий для веб-разработки в отличие например от Java PHP не имеет встроенного сервера Но на самом деле он есть но это Экспериментальная функция не предназначена для использования в продакшене Если вы хотите запустить приложение PHP вы Либо выполняете его как отдельный скрипт запускаем через интерфейс командной строки либо запускаете его как текущий серверный процесс например с помощью fpm который может управлять вечерними процессы в случае скрини Все очень просто для обработки одного запроса выполняется один процесс PHP компилирует код динамический по запросу Что означает что PHP запускается инициирует движок и подключит модули после того как это будет сделано PHP скомпилирует и выполнит ваш код по окончанию обработки Он отключится с fpm все будет также но система постарается подготовиться к запросу приходящим сервера FM позаботится о том чтобы запущенный процесс PHP уже существовал и был готов принимать запрос в зависимости от типа управления процессом статического динамического или по запросу он определяет сколько дочерних процессов необходимо выполнить для обработки входящего запроса ответ сервера Однако каждый из этих процессов выполнится для обработки одного запроса одновременно таким образом каждый второй запрос попадает в очередь и ждет своей очереди на этом безумном чаепитии и это не означает что рабочий процесс используется каким-либо процессором в каждый момент времени ожидания возможно был отправлен какой-то внешний запрос и процесс просто ждет ответ Чтобы продолжить выполнение текущего запроса было бы здорово если бы мы могли разумнее использовать ресурсы и выполнять другую задачу по времени ожидания а текущую по истечении времени ожидания мы уже отгадали загадку Некоторые из вас уже сталкивались с подобными ситуациями работая с импортом экспортом данных по внешней системе и мы думаем о том как запустить новый процесс или поток PHP непосредственно из вашего текущего процесса есть несколько у нас существующих расширений доступных для phps и параллель Оба на самом деле требуют сборки PHP заключенным зтс возможно позже я подготовлю еще один доклад именно углубляясь многопоточность Однако Теперь мы ищем понятный простой и контролируем способ запуска не блокирующим образом без фактически необходимости использовать многопоточность или думать иметь в виду что здесь основными целями являются повышение производительности и повышение удовлетворенности конечным пользователей поскольку мы хотим эффективно использовать наши ресурсы иногда Нам нужно запускать асинхронно даже если изначально он должен не должен был запускаться таким образом прежде всего нам нужно понять что именно означает асинхронная обработка это своего рода конструкция для вычислительных задач выполняющая их без каких-либо зависимости друг от друга каждая задача уникальная и последовательность выполнения не гарантирует одинаковый порядок доставки результат когда мы примеру запускаем сервер у нас такое же поведение при обслуживании веб-страниц для пользователя браузера чтобы это произошло как на текущем изображении нам нужно чтобы fpm выполнял как минимум 4 процесса если мы посмотрим в рамках одного процесса то Увидим что каждая задача ставится в очередь выполняется одна за другой но возможно ли чтобы один процесс выполнял несколько задач параллельно как на данном изображении если задача делать какой-нибудь внешне запрос например хранилище данных и какое-то время ждет результата мы можем оставить ссылку открытой и выполнить задачу В течение времени ожидания когда задача B имеет такой же внешний запрос программа может проверить готов ли уже результат для запросов задачи А и вернуть его пользователю а затем продолжить выполнение задачи Наверное я вас запутал лучший способ объяснить Это запрограммировать реализация на PHP может быть сложной но возможно например запрос хранилища данных может быть реализовано не как запрос базе данных а как постановка задачи в очередь с последующей проверкой по заданной ссылке Если же есть результат реальные запросы данных могут выполняться каким-либо фоном рабочим процессом или заданием Chrome на может понадобиться обновить пользователь ожидающего результата с некоторыми абстрактными значениями о том Чего ожидать когда результат будет доставлен это можно сделать через невыполнимая обработчик объекта который пользователь получит до того это может помочь начать рендеринг уже на интерфейсе это очень распространенное решение используемое на фронтенте и здесь нам поможет концепция популярный пример промесов в реальной жизни это заказ в известном ресторане быстрого питания часть терминал самообслуживания вы выбираете свой любимый гамбургер а затем система выдает вам билет с номером который точно описывает что получите после кита будет Если вы разработчик транскрипт Вы должны быть знаком с этой концепцией и достаточно хорошо по сути промисы это прокси для результата который может быть еще неизвестен на момент создания промеса Обычно он может иметь одну из следующих состояний ожидания которое является начальным состоянием выполнена когда операция завершилась успешно или отклонено когда операции не удалась Если вы используете примеру тайпскрипт Вы даже можете предоставить интерфейс и летим значение функции когда она будет выполнена Но если вы используете PHP настоящее время это не доступно из коробки в данном листинге Я очень просто описал концепцию промеса он реализует интерфейс с тремя методами разрешить Отклонить или получить значение результата После выполнения к счастью это реально реализация у нас она может остаться прототипом всегда потому что среда ряд PHP уже предоставляет отличную библиотеку реализующую опцию концепцию Я рекомендую вам с ней ознакомиться более подробно любопытнее и любопытнее сосредоточимся на недостающих элементах необходимы для реализации решения описанного на данном изображении учитывая что на этом изображении запущен только 1000 процесс следующая задача выполнить вторую задачу В течение времени ожидания ответа от хранилища данных здесь мы и готовы следовать следующий концепция хорошо известна в мире но Джес цикл обработки событий один из самых важных аспектов которые нужно понимать цикл событий Постоянно работает проверяя есть а на данном изображении изображена изображен цикл событий и он применяется упомянутым ранее решение существующий пол задач который может обрабатывать функции Apple promisso обрабатывая ссылки и соответствующие промисы которые должны быть разрешены искренне счета событий работает постоянно беря задачи из пола задач и сохраняет созданный тоже цикле он проверяет результаты для разрешения сохраненных обещаний если бы мне нужно было реализации чего-то простого как примеру описано на данном истине а но Давайте скажем наверное еще раз спасибо такая базовая реализация не нужна нам и не нужно изобретать еще один велосипед вряд ли есть библиотека для цикла событий как и в предыдущем примере цикл обработки событий выполняется в одном потоке но с использованием такта таймера для синхронного программирования и выполнение всех задач и событий как и в javascrip 5 реализует модель параллелизма полностью основана на цикле событий чтобы использовать цикл обработки событий в приложении необходимо создать один экземпляр использовать его для добавления таймеров и в конце года приложения цикла обработки событий должен быть запущен поддерживает несколько реализаций циклов Некоторые из них требуют установки дополнительных расширения PHP о которых я говорил ранее но тем не менее есть Стрим сели и он используется как запасной вариант если Нет доступных конкурентов решений Скажите пожалуйста куда мне отсюда идти и наконец мы приступаем к самому интересному Это новая возможность для синхронного PHP что же такое файберы Я думаю что документация Ruby хорошо описывает что такой файберы файберы Это примитивная для реализации облегченного кооперативного параллелизма по сути они являются средством создания блоков кода которые можно приостанавливать или возобновлять подобно потоком основное отличие состоит в том что они никогда не вытесняются и планирование должно выполняться программистом а не виртуальной машины принесли ли в действительности файберы асинхронность нет а может быть это пожалуй Одно из самых распространенных заблуждений о файберах а также то где все становится сложнее Так что выслушать у меня слайдеры предоставляют собой низкоуровневую конструкцию они позволяют создавать синхронные функции таким образом чтобы их можно было приостанавливать и возобновлять человек разрабатывающий эту функцию должен определить где эта функция может быть приостановлена и Какое событие она ожидает чтобы возобновить волнение сами не планируют эти выполнения но они позволяют дополнительного планировщику возобновить любой реалистичность идея это будет обрабатываться с помощью реализующего шаблон сам файбер не предоставляет такой цикл обработки событий и я это считаю очень хорошая вещь Это означает что вам все равно придется использовать ряд PHP sull или MP для предоставления модели асинхронного выполнения или для создания чего-либо что может выполнить одновременно Это означает что с вайберами или без них асинхронной PHP будет представляться внешним библиотеками Однако в то же время вайберы могут использовать асинхронные PHP в большом количестве проектов с точки зрения среднего разработчика Они вообще никогда не будут взаимодействовать с вайберами файберы можно использовать как реализации библиотека чтобы асинхронные функции выглядели точно также как синхронно но с помощью могли выполнять что-то асинхронное внутри Это означает что есть шанс что в будущем Мы увидим больше асинхронных реализации потому что они более легко интегрируются в синхронной среды Нужны ли нам файберы нет как и говорил я в предыдущем разделе Нам нужен планировщик или Эван клуб чтобы запускать вещи асинхронно или параллельно это также означает что вам все равно придется использовать что-то Вроде предоставляться файберы это один из возможных строительных блоков для синхронного приложения Как конструктор еще не выдержали испытание временем тем не менее Мы видим что файберы могут навсегда изменить ландшафты и возможно лучше какой же проблему решают файберы файберы отвечают на вопрос Какого цвета ваша функция если коротко это если ваша каждая функциях или обычная функция с именем является или красной это асинхронной или синий Это синхронный Короче говоря это означает что во многих языках есть различия между синхронными и асинхронными функциями что еще хуже при использовании любой асинхронной функции весь стек вызовов также становится асинхронно синхронные функции возвращают результат а синхронный нет замена не вызывает колбе синхронные функции выдают результат как возвращаемое значение асинхронные выдают его вызывая колбэк который вы им передали вы не можете вызывать асинхронную функцию и синхронной потому что вы не сможете узнать результат пока синхронная функция позже здесь указано достаточно длинный пост но вы можете прочитать его чтобы полностью понять проблему Ну и далее чтобы увидеть это на практике Давайте взглянем на некоторые код для отправки http запроса в синхронном коде отправка запроса могут выглядеть примерно так но чтобы предоставить возможность возвращаемое значение вызова синхронной функции многие языковые следы используют некоторые языки предоставляют встроенную реализацию кроме других языках Это обычно реализуется пространстве пользователя PHP обеспечивается при помощи вот тот же пример с использованием для отправки проекты на основе промисов обеспечивают мощный и разумный интерфейс для работы с асинхронными ответами в то же время мы понимаем что этот пример может выглядеть сложнее чем вот традиционная синхронный аналог в частности при использовании асинхронной пэч весь наш чек User метод также стал асинхронным и должен возвращать именно промисс это в свою очередь напрямую влияет на то как основное приложение использует этот метод но здесь в игру у нас вступают корутины это блоки квода который работает асинхронно то есть по очереди в нужный момент исполнения такого блока приостанавливается сохранение всех его свойств чтобы запустить другой код когда управление возвращается к первому блоку он продолжает работу Некоторые предпочитают реализовывать картины с помощью генератора чтобы тот же поток управления больше походил на синхронных код среди прочего Вы можете найти это при комбинировании реакции или при использовании текущей версии здесь доступ к асинхронному возвращаемому значению теперь безусловно выглядит намного проще Однако мы видим что теперь для этого требуется обернуть это функцию генератор Кроме того теперь нам нужно реализация корутины на основе генератора предоставляющая оси которая подключается оператору и управляет потоком управления для наших промесов Это означает что это может быть более удобным для некоторых вариантов в конце концов к счастью Здесь нам могут прийти на помощь вайберы это выглядит красиво правда на самом деле с вайберами вы больше не увидите что вы за функции вообще асинхронно файберы позволяют вам выразить синхронный поток программы поэтому вам вообще не нужно иметь дело с каким-либо асинхронным выполнении интересно что это также означает что средний разработчик приложения Вообще никогда не будет взаимодействия с реализацией это огромным плюсом файберы представляют собой строительный блок для создания функций которые можно использовать в синхронной или асинхронной среде без изменений их внутренняя работа скрывает тот факт что другие функции могут выполняться асинхронно с помощью файберы можно использовать как синхронное так и в асинхронных средах без использования промежуточных адаптеров Это означает что у нас будет шанс увидеть асинхронной реализации потому что они более легко интегрируются именно синхронные среды Однако это немножко некорректно стране спросами приведем приведенный пример выглядит полностью синхронным но на самом деле потому что действительно синхронние чтобы провести справедливое сравнение с файберами и комиссами нам действительно нужно взглянуть например который отправляет параллельный запрос также выглядит параллелизм в реальных приложениях опять же Давайте возьмем наш предыдущий пример и проверки одного и мы проверяем 2 Извините это в нашем электронном примере не так уж сложно теперь предположим что первая служба всегда занимает одну секунду а вторая всегда занимает 2 секунды выполнение этого занимает в общей сложности 3 секунды легко понять почему каждый вызов происходит один за другим Так что время суммируется точно так же мы можем изменить наш предыдущий пример промеса чтобы получить данные из двух запросов Мы видим что добавление это второго вызова не сильно изменилась структуру кроме со будут выполняться фоновом режиме по умолчанию и мы можем просто дождаться обеих результатов используя Теперь снова предполагаю что первая служба занимает одну секунду а вторая всегда занимает 2 секунды выполнение этого займет всего две секунды внутри промеса все разрешается с помощью асинхронного это происходит одновременно Поэтому нам нужно дождаться завершения самого медленного из них Ну и Точно также мы можем посмотреть на переделанный код короче Мы видим что добавление это второго вызова снова не сильно изменилась структуру но также это что он начинает очень походить на предыдущий пример с использованием на самом деле это не так уж удивительно учитывая что это реализация корутины будет построена поверхность Именно поэтому и по моему опыту реализации карантина обычно не приносит большой пользы многим приложения и теперь получается снова предполагаю что первая служба занимает одну секунду вторая занимает 2 секунды и выполнение этого снова займет 2 секунды а давайте посмотрим как выглядит наш предыдущий пример с вайберами Если изменить его на выборку из двух запросов Подождите минутку разве фаберли не должны упрощать асинхронность что-то вроде но на самом деле это не то что касается особенно помогают избежать вопросы Какого цвета ваша функция это не волшебство сами файберы не решают проблему одновременно выполнения файберы позволяют выразить синхронный поток правления в тот момент когда мы хотим выразить асинхронный поток управления нам все равно придется прибегать в этом примере нам нужно использовать две функции предоставляемые нашей асинхронной библиотекой функция Осин превращает функцию на основе файберов кроме будет выполняться в фоновом режиме и функция которая указывает Event loop выполняться до тех пор пока он не сможет вернуться к вашему синхронному потоку это assing функция выглядит как волшебство Похоже она может превратить Любую синхронную функцию синхронную Однако К сожалению это работает только с функциями которые используют файбер который внутри инспектирует проблема Проблема в том что вы больше не можете сказать можно ли вообще использовать эту функцию в асинхронном контексте с тем же успехом он может Заблокировать все ваше неблокирующее приложение и вы не сможете узнать об этом заранее файберы устранили различия между синхронными асинхронными функциями и то что начиналось Хорошая идея означает что теперь выпускаете важную информацию и ваш Единственный шанс проверить документацию для каждой функции которую вы хотите использовать асинхронно как предыдущих примерах в примере с файберами оба наших запроса будут занимать всего две секунды так как нужно будет дождаться самого медленно больше вопросов чем ответов Что же это означает для будущего промеса помните Никуда не денутся но возможно мы будем видеть их намного реже с вайберами мы можем видеть как потребителям не нужно использовать промисы для многих распространенных случаев использования Я считаю что это хорошо потому что это может сделать многие из более простых вариантов использования намного менее сложные всякий раз когда вы хотите одновременно выполнять несколько функций но все равно придется использовать асинхронный примитивы Это означает что кроме останутся жизнеспособным вариантом для асинхронных программных потоков как и сегодня это не то что файберы сделают устаревшее Что же это означает для карутин корутины на основе генератора иногда могут быть полезны хотите Взглянуть на мой хрустальный шар как только файберы станут использования скорее всего сойдет на нет и картины больше не потребуется как же насчет Осинка воид на самом деле способ которым многие языки решили предоставить найти привели бы к основному вопросу Какого цвета ваша функция решение которого нацелены файберы Это означает что вероятность того что мы увидим эти ключевые слова таким образом PHP снижается в приведенных примерах используются которые могут предоставляться выбранными вашими библиотекой Лично я по-прежнему вижу большую ценность в том что эти базовые строительные блоки были частью самого языка Таким образом мы потенциально могли бы обеспечить широкое взаимодействие между различными асинхронными платформами но в то же время эти реализации имеют гораздо больше размах хорошей новостью является то что мы начинаем видеть больше взаимодействия между этими реализациями да и вообще эта тема наверное для отдельного разговора Должен ли пить вайперы Я думаю что файберы это достаточно интересные концепции но фаберли не делают того что кажется большинству людей я первый признаю что фаберли звучит великолепно и очень сложно описать нюанс файберы кажется обещают что мы увидим нативный асинхронный PHP а на самом деле они для этого отлично справляются с решением вопроса Какого цвета ваша функция Это означает что есть шанс что будущее мы увидим больше синхронных реализации потому что они более легко интегрируются синхронные средства тем не менее это первая реализация параллельно совместимости совместной многозадачности PHP и я думаю что это отличное начало совершенно нового пути для PHP в мире асинхронность Если бы это было так это бы еще ничего если бы конечно оно так и было но так как это не так так оно не это Такова логика вещей Всем спасибо да это мои контакты пишите Подписывайтесь ставьте лайки Спасибо теперь можно задать вопросы Итак Спасибо большое за доклад тема асинхронного PHP всегда будет подниматься и чем дальше тем больше тем более у нас 5 есть некоторые подвижки в эту сторону Дмитрий А вы меня слышите сейчас да отлично Я сейчас озвучу вопрос Давайте тогда так поступим Дайте микрофон тогда зрителю а я еще повторю если не будет слышно Ну я могу спросить Дмитрий как меня слышно потребуется не потребуется Дмитрий на самом деле я жутко недоволен вашим докладом Я говорю об этом вам честно прямо глядя в глаза поскольку этика требует задать вопрос я его задам в конце но я чудовищно недоволен вашим докладом Он наверное худшее что я сегодня слышал вчера было хуже Не волнуйтесь вы умудряетесь путать параллельности синхронность многопроцессность и многопоточность собрать вообще всё в одну кучу и у меня есть вопрос Как вы умудрились сделать доклад профайбер ни разу не показал В класса Fiber и его методы Спасибо на самом деле все немного просто как я говорил ранее среднестатистическом разработчику не надо видеть пойду также закроется внутри библиотек которые уже везде доступны то есть в том что тот же самый реакции уже давно начали работу на то чтобы переделывать под них Я не вижу смысла в принципе разработчикам всеми взаимодействовать если Естественно они не реализуют я Ну тоже присоединюсь к Дмитрию согласен что Ну мне кажется не обязательно показывать какой-то контракт если в докладе важна сама идея Ну то есть что Ну а почему и такая идея доклада имеет право на жизнь еще кого-то есть вопросы Сейчас я посмотрю если у нас от наших онлайн-участников Вопросы вроде бы пока нет Ну тогда от меня вопрос такой наверное общий Очень популярный Дмитрий Как вы вообще видите но вы отчасти ответили Но мне хотелось бы прям совсем такую большую картину Как вы видите будущее асинхронного PHP вообще что нам нужно сделать для того чтобы ну вот у нас сейчас есть Open collective Да точнее через Open collective вот эта инициатива PHP Foundation через которую мы теоретически можем дальше развивать язык и подавать им идеи вот какой следующий шаг вы бы предложили сделать э-э И каким вы видите ближайшее будущее асинхронную PHP его популяризацию там Ближайший год два это на самом деле достаточно сложный вопрос как это будет PHP но для начала все-таки нужно вывести PHP на тот проект те же самые файберы используются сейчас достаточно много Где используется еще другие решения которые были ранее исполнены есть примеру очень плохая статья когда она выходила насчет того что пока все что есть печки это не асинхронность и действительно полноценного можно добиться только к основной библиотеками Вот Но путь очень хороший и я очень жду что дальше у нас появится как минимум Какие примитивы наподобие планировщика событий я правильно понимаю что нам как минимум хотелось бы чтобы в ядре появились какие-нибудь уже асинхронные варианты драйверов для взаимодействия с файлами еще чтобы это были не сторонние какие-то расширения а прямо изнутри росли да Да сейчас большая часть просто блокирует все и приходится искать сегодня блокирующие вы упоминали amphp и я там вот так по следу подписано их релизы вроде бы должно скоро выйти новая версия которая уже будет использовать файберы Вы как-то тоже за этим следите контрибуте нет в проекте соответствующие поэтому я даю еще наверное Минимум год а то и два чтобы Все успели на это переехать хорошо спасибо большое так в зале больше нет до вопросов Спасибо за то что подняли в очередной раз эту тему Мне кажется такие доклады как раз для того и нужны чтобы Мы приближались к синхронному будущему готовили и аудиторию под это и сам язык Вот спасибо что вышли на связь с нами чтобы ответить на вопросы и спасибо вам большое До встречи на следующей конференции спасибо спасибо пока Ну что ж мы с вами Подходим к финальному нашему докладу через несколько минут после тех тока от сбермаркета у нас будет доклад от PHP боярина и санитара философии Ивана про фичу как объект после которого мы плавно с вами выйдем в анконференс на котором возможно его идеи философские и еще дополнительно обсудим вот так что я вас жду в 15:40 на тиктоке и в 15:50 на докладе До встречи"
}