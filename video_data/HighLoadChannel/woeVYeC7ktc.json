{
  "video_id": "woeVYeC7ktc",
  "channel": "HighLoadChannel",
  "title": "Что могут C и C++, и когда нужен ассемблер / Александр Крижановский (Tempesta Technologies)",
  "views": 763,
  "duration": 2443,
  "published": "2023-01-19T05:55:17-08:00",
  "text": "начнем с того что вообще откуда взялся за год мы работаем в двух областях это разработка заказного софта специализируемся в области сетевых приложений как поет система безопасности и системы хранения также мы разрабатываем свой по 2 tempesta vw это гибрид аж теперь все готово и и заказную работка на зака встречается задача когда нужно либо для нашего заказчика построить что-то быстрее чем у его конкурентов либо после оптимизируй текущие решения тим песню нас есть ряд технологий которым мы гордимся по производительности это самый быстрый или просто очень быстро штабе полосы и также сеанс хан шейками в большинстве случаев высоко производитель достигается алгоритмами математика и почем но частицы просто нужно аккуратно запрограммировать оптимизировать код и так далее ну и в основном мы работаем си си плюс плюс eos m берем давайте посмотрим на пример мы делаем code review видим функцию из digit и знаем что есть книжка hackers деляет и в ней предложен трюк для данного подхода всем чтобы вместо двух операций у нас было вместо трех окрасы было две операции вот давайте посмотрим вообще имеет ли смысл на вход дополнена сложностью носить на самом деле нет compile на достаточных высоких уровнях оптимизации уже обычно этому трюку и такой такой оптимизации имеет смысл можно писать по простому другой пример есть функция лака встроенная она по сути выделяет байта на стейки пойти выделить 16 байт на стыке должно быть то же самое что и позвать ооо к давайте посмотрим так ли это на самом деле для того чтобы смотреть я буду использовать код болт и вообще ха ха хороший ресурс для того чтобы исследовать что дает compile вот собственно два вот этих примерах которыми я на слайдах и первое что сделал это скомпилировал флангам 2 я скопили в цехе для кванга видим что обе функции они вообще идентичны это действительно ока она вам тоже самое что выделить на стейки но для джесси это не так вариант с выделением байт на стыке такой же как у кванга а вот вариант ставок они такой же он уже в используйте bp и немножко больше кода генерируют давайте теперь посмотрим на x 864 вообще что это такое ну чем то эта архитектура на примечательная но общих словах она супер скалярная то есть мы можем выполнять несколько инструкций параллельно она аута фонда высоки уж он то есть позволяют вам инструкции перед порядок чуть она переупорядочить их но при перепаду чине инструкций рита ринг завершение инструкций ну-ка мид результатов инструкции в регистры в памяти происходит всегда в порядке самих инструкций далее у нас есть при fetching и каждый инструкцию нас состоит из миг операций у инструкции есть патент нас несколько тактов процесс ли она занимает и есть выпускная способность обычно она мериться как обратно пропускная способность то есть чем больше инструкции такого типа может быть исполнено параллельно на процессоре чем меньше областная пропускная способность для того чтобы посмотреть на это все в действие я буду использовать утилиту или 2 м м всей вообще очень себе полезная утилита для исследования кода нам о производительности ну как полосам lenovo кода терминал хорошо видно с задних рядов окей что что здесь буду сейчас так что здесь происходит во первых я компилирую некоторую пока мку и отдаю выход соленого кода на вход и в massey и так у ангарского террито но она съедает как и джйотиш на выход так и в дальше я говорю о том бы на какой виктория работу у меня ноутбук это skylake и пошло и сделать еще дополнительно анализ давайте посмотрим что она нам показывает в окопах посмотрим в топ давайте так начнем что у нас здесь никто число итераций м все это вообще виртуальная машина то есть она пытается исполнить наших программ он много газ и потом собирать статистику первое что мы видим это максимальную ширину нашего папой насколько вообще в параллельном мы можем исполнять из функций далее у нас количество armik операций в средние которое исполнено в наших богами это 563 это очень близко к шасси очень хороший показатель то есть у нас программа прольются хорошо инструкции тоже достаточно много параллельно работает и обратно подписано способность вообще всего блока кода в принципе здесь достаточно хорош и далее мы видим особенный код и слева мы видим количество микроопераций дальше этого ценность во втором и скобы во втором столбике и в третьем столбике то сколько у нас обратно папус она способна для каждый инструкций прицел это можно все найти а в справочниках либо вогнав ока либо 1 из 12 хочу обратить внимание что вот если мы полистаем этот листинг вниз мы видим что микроопераций в основном все инструкции они по даме кооперации мне сначала в это как-то не очень по верилось потому что есть достаточно сроки сложной операции вот этот типичная операция когда мы что-то читаем потом мы складываем и потом пишем обратно но тем не менее я проверял по с плач ником действительно здесь в основном все инструкции они у одной микрооперации только в конце видно что более тяжелые инструкции работают далее давайте посмотрим на собственно сам их закину шин на этом графике у нас время идет слева направо а инструкции в порядке их исполнения сверху вниз то есть мы сейчас видим что вот в 0 до во времени у нас 6 инструкция начинают выполняться параллельно и это дико thing инструкция то есть они декодировали дальше пошли исполнять вот это знак равно это что если кстати к дивное ждет исполнения и маленькое то само исполнение язык вершину большой это конец и вот здесь reed army давайте посмотрим на вот эти две инструкции здесь видно что первые начинают исполняться чуть позже чем 2 2 она заканчивает исполняется раньше чем пела и нори the ring происходит этот момент на то есть мы исполняем и стук south of a dove но коми чему их результаты строго последовательно обратите внимание еще на общую картинку сколько мы проводим ожидания да это да и спал по началась языку шона и после на этом графике сам это и большие ты во времени у нас достаточно быстро отрабатывают функции и сам пог'ом хорошие теперь давайте посмотрим еще на один пример все тоже самое но богам немножко другая вообще другая программа здесь мы видим что при том что у нас максимально показано с пазом та же самая программа уже менее параллельно чем предыдущие уже должна работать хуже соответственно и обратно на способность всего блока она сильно выше то плохо ну потому что она обратно обратная величина поскольку программа не очень здоровская то м всей нам предлагает анализ и стоит нам критическую последовательность инструкций вот вот этот график показывает какие инструкции от каких зависит и по вот этой зависимости мы можем оптимизировать ассемблерный код переупорядочить через функции переписывайте в гарет для того чтобы у нас зависимость по инструкциям было меньше давайте теперь посмотрим на график казаки уши на как он выглядит вначале он принципе выглядит похоже на предыдущий поголодать если мы видим что уже самого начала если мы в самом начале в той по гамме 6 ресурс иначе дико делать параллельно то есть здесь начинают только две инструкции доработать в принципе график очень быстро движется вправо вот здесь уже ближе к концу программа видно что нас прям все плохо становится то есть вот долгие ожидания на началах языке уши нам после декодирования это как раз отрабатывает зависимости по данным то есть еще не доступны данные которые мы начинаем которые нужно это исполнение инструкций так давайте дальше посмотрим собственно то что архитектуру нас позволяет out of all i do execution это привело к ряду уязвимости завидная самых известных это спектр и вызвано а на следующем следующей проблемы давайте посмотрим по гамму хорошо видно код на в браузере смотрите у нас есть условия там как бы это валидный код программы у нас есть некоторый объект есть абсент вам проверяем asset для доступа в массив он укладывается в eins или нет и если укладывается значит мы идем какие-то вычисления лишь только в том что значение объект может быть нам сейчас недоступна она может лежать где-то в памяти и пока мы идем в канал памяти ожидая мы начинаем отрабатывать код который предсказал нам предиктор насилию и допустим он предсказал что наиболее вероятно у нас будет вот эта ветка кода и мы начинаем исполнение этой ветке кода результатом исполняет и ветки кодов может быть что у нас обновятся каши данных процессоров ну функция допустим дустом финквист она пишет что-то в память будет записано в кэш процессора и когда мы у нас придет все-таки значение links то мы поймем что этот бланк и валидный и все результаты не валидного blanche мы должны дропнуть но проблема в том что данные которые сейчас у нас записались в каждого уровня процессора они могут там еще остаться и другой параллельно обзор может с помощью приметами к атаке вычислить значение этих к жене и к то есть другой параллельный поток может используя предсказывая значения в кэше которые были по невалидным bunchy может предсказывать значения данных если мы скомпилируем конгом с обычному 3 вот это то что мы видим для данные функции собственно вот условия перехода в конец если не выполняется то мы выходим из функции теперь давайте добавим опцию м ред pavlin которая собственно добавляю говорит компилятор о том что мы должны добавить генерацию защиты от атак типа спектр и сути это защиты в том что мы добавляем эпилог который вообще говоря недостижимый кода потому что у нас оба бланше отрабатывают до этого кода здесь тоже редкий отрабатывает как и ожидалось но если мы идем в этот бланк то есть если мы понимаем что away links у нас не идут варить мы должны выйти из функции у нас снова пришли работает при fetching и вот этот код отрабатывает так что мы переходим в результате до барьера памяти offence и sense выбрасывает данные из кошачья в уровне то есть с одной стороны у нас вызвано атака пресечь янгом и out for execution другой стороны мы защищаемся чили тем же самым путем кроме спектр еще было интересно атака meltdown которая позволяет из use space за получаете доступ к памяти в кино спейси большинство одинаковых современных скомпилирована из опций изоляции то таблице они сыном системах у к в которых использую много системных вызовов декорации производительность может быть до 30 процентов соответственно если вы работаете в одном адресном пространстве то проблему это становится более девочек давайте вернемся к нашей практической работе о том что мы делаем кадре view и нам нужно понимать как работает данный кода насколько он быстрый насколько хорошо компилятор делать свою работу и проч и в принципе мы можем весь код который нас есть отправлять на год болт исследовать оставленный код это все очень муторно и долго компиляторов есть опция opt-in for up to all которое собственно говорит о всех оптимизациях которые были приняты компилятор можно посмотреть в документации компилятор фома очень хорошая документация можно почитать там о том что в принципе compile умеет делать но лучше запустить компилятор с погас дополнительные опции который скажет какие непосредственно вместо были оптимизированы дальше мы немножко посмотрим на пример такого ввода-вывода ну и последнее это если уже действительно нужно по биться за пивком ас можно тогда почитать особенный код и по компилировать давайте посмотрим несколько плохих примеров первое это большая стоит машина который использовав его этим песню нас стоит машина здесь например стоит машины показан на картинке как правило это цикл который идет о байту читают входные данные внутри у него два вложенных свеча 1 switch этапа текущем состоянии 2 switch по входным данным закодированная таблица конечных автоматов и сочи года в том что мы наворачиваем внутри файла мы делаем много jump off сначала мы исследуем текущее состояние поедим на какую точку кода потом мы следуем текущую входной данные об и двигаем еще дальше потом мы уйдем какие-то действия прыгаем в конец цикла потом снова начинаем с конца цикла то есть характерность этого кода в том что у нас очень большой кот и мы идем на каждой итерации цикла очень много jump off внутри кода если посмотреть на то как устроен стоит машина в жены xi то мы увидим что объем кода это примерно 9 килобайт но помним что кэш павловне инструкция это 32 килобайта нам пока бери на моей машинке всего в яндексе о довольно мало состоянии там порядка 80 там панси достаточно простой в темпи есть используется более сложные паузы мы идем очень много security чеков по полезно с посевом htp и у нас на порядок больше состоянии то есть нам вот эта история с хамасом стоит машина очень критично становится допустим у нас есть switch statement и в нашем свечи у нас все метки они последовательно то есть это случае для state of настей то это томатная int и да там скажем 100 или 80 в таком случае компилятор генерирует таблица переходов вот пометки 2311 у нас есть таблица скомпилированные дальше мы берем в регистре ax что у нас текущее значение значения сайта и че за эту таблицу прыгаем на нужное место здесь мы видим что она снова есть от входных данных некоторый прыжок прыжок то есть мы прыгаем на чьи кусок кода в зависимости от входных данных это еще один пример для спектра таки второй вариант для оптимизации свеча если уже метки у нас непоследовательно вот как в этом примере сильно разряжен это компиляторы генерит бинарный поиск по коду и если у нас в предыдущем случае метки это последовательное чистого но мы кабели вам программу собственные предполает то есть защищаемся спектр the compiler и снова нам генерит бинарное дерево и дерево альбина до поиск новые компиляторы достаточно умны для того чтобы if-else цепочку тоже сворачивать той же оптимизации как и switch statement в целом мы генерируем код у нас на стадии компиляции все данные известны которые у нас есть с вич statement и вообще говоря использовать угорь ритмический алгоритм это не очень здорово да можно было бы за константное время это делать и есть статья аж 8 года конференции по джесси где предлагается использовать например пофиг fishing для того чтобы активизировать switch statement даже для на случай когда метки непоследовательные там используется к оптимизация то есть compile выбегают несколько подходов к построению структуры данных для свеча и выбирать наиболее выгодную но к сожалению так это опции и гекко за комбинированная то есть не вошла в состав compile то есть и ук one guy и у джесси в целом государства как я показал на слайде к сожалению мы не можем заказ от на время искать непоследовательные метки следующее что мы сделали с этим поскольку в общем диване с донорскими заменили switch степин на прямой переходы то есть каждой метки ps вы добавляем еще прямой метку и вопросы добавляем оператор gold и получается что мы если можем сказать на какой следующей свечи нам нужно кейс играть мы можем сказать сделать голод и нам не нужно проходить через весь switch и запускать бинарный поиск принципе такое же стоит машина генерируется для гегеля далее что джесси предоставляют расширения когда мы можем сохранить указатели памяти на метку и как вас м лили прыгнуть на данную метку джесси а мы используем это расширение и получается у нас достаточно огромная такая стоит машина который делает прямые переходы джесси в дизайне мув у нас есть код который отслеживает объем данных которых сейчас еще есть для чтения и вот это кот он дублируется кусками в джесси работает это необычно свеча и в нашем случае если посмотрим на результаты таких оптимизации то получается что прямые переходы выгодны для больших стоит машин а для стоит машины там в несколько состояний она может быть не очень выгодно и связано это с тем что у нас в ходе очень много bunch без prediction of то есть кэш и страшен кэш процесс работает и очень здорово интересно здесь то что при том что машина состояние на прямых переходах 1 весит почти 50 килобайт что сильно превышает кэш певунья но тем не менее у нас объем помахав кашпо махов куда каша из функций в два раза меньше связано это с тем что хотя бы не пума не помещаемся в кэш у нас сам кэш заполняется в более оптимальным следующее что мы нашли что джесси ваших стоит машинах может перри порядок чего код ну то есть у нас мы помажьте пиза запрос у нас есть метод get или post и дальше какой-то заголовок аналог и мы нашли что get может в ходе стоит машина оказаться где-то в середине пост в конце а наверх кабеля то может поднять хедер это не очень здорово допустим мы будем использовать барьер к период то есть мы скажем что генерация парсинга методов должна быть до генерации паркингом хотя в принципе это то что делает баре компиляторов но здесь есть подвох что барьер как педиатр говорит о том что код избит будь всегда до кода парсинга htp заголовка кот пост оба всегда до кода посягаешь теперь заголовка но если compile увидит что когда мы получим get мы сразу переходим на опасен каш типе запроса и под до пола singapore post а вообще не достижим для данной ветке он все равно может через барьер поднять этот код то есть он здесь соблюдают только относительно сносить зависимость кодов и для того чтобы компилятор не переносил через барьер код мы использовали lightly on like ли это тоже расширение сейчас уже в новых местах появились и расширение компилятором и еще атрибуты этой but i меток для условных переходов метки мы можем сказать как указать как ход то есть эта метка она очень горячая мы все время будем на ней и компилятор поднимет эту метку код под этой меткой вышивки всей функции холодной метки опуститься вниз смысл океан лагеря в том что код под likely будет сначала перед поверкой условия и ход за в бой джеймс будет принесен вниз функции давайте посмотрим теперь что компиляторы делают по оптимизации попробовали скомпилировать 102 и дальше мы берем о 3 пробуем каждую из оптимизация входящих внутри оказалось что если мы попробуем каждой из оптимизацией далеко не каждый из них действительно генерирует более быстрый к то есть иногда можно увидеть что код 103 будет медленнее работать чем 102 можно найти можно найти оптимальные для данного кода на набор оптимизации давайте посмотрим теперь на этом сайте в зеленом выделенные методы по авто векторизации и получается два из них нехорошие они и красным цветом выделены давайте на них посмотрим более детально ну во-первых авто векторизация это использовать висках шума у типу дейта то есть мы можем за газ есть по исполнить на 32 байта х даже x 512 можем 64 байта есть и одну и ту же функцию на большом количестве данных но с этим расширением связано несколько тоже скольких моментов первое то что нам нужно выравнивание на 32 байта 64 так далее не весь код далеко не весь он вообще авто факторизуем и компиляторы принимают нам при авторизации принимают очень много эвристик для того чтобы какой код сгенерировать вот если кому интересно только к кабинету стоит внутри по авто векторизация очень советую так was sorry we can в 12-го года который рассказывает что-то что компилятор делать при авто векторизации давайте посмотрим теперь что такое автовек стерилизация как оно работает я скомпилировать сейчас программку для базового блока и компилятор мне скажи сколько еще yes не лимитированным cost моду это значит что как раз cost моду говорит компилятору какую модель мы выбегаем на насколько долго нам используется как высохшим молча плоды это аниме ты говоришь что очень дешевы и компилятор будет пробовать of the weak to rise ровать все что только можно сейчас мы видим результат опции информации о в оптимизации видим что во второй глаз компилятор программа была уже of the weak to rise она в первый раз она не of the victory zeus давайте посмотрим на эту программу акты векторизация сказала что это 54 строка и давайте посмотрим на то 54 эту строку смотрите здесь у нас это бы basic books of optimization по сапогам называться как биби и здесь видим что хорошая параллелизм по инструкциям то есть фактически каждая строка нее зависит от другой выше мы видим много других блоков но у них есть зависимость поданы они не могут быть of two x из зова на вообще говоря вот эта функция из криптографии взял это при том что у нас есть большое количество однообразных действий в принципе это паттерн для базик бокс оптимизации но тем ни менее всей функции у нас оптимизировать только вот этот маленький кусочек давайте еще посмотрим на выравнивание и на работу restrict а это та же самая функция но у нас все указатели они помечены как рис track и дополнительно у нас еще есть есть опции того чтобы на стыке наши данные вы выровнены вообще имеет ли смысл вообще вот эта штука снова и и компилируем снова получили в твери кассацию и давайте посмотрим две версии программы restrict без рецептов из выравнивание без выравниваем слева без бога у него я сплава с выравниваем видим что используются одни и те же инструкции суффиксом юрий она липнет и али гнет давайте посмотрим вообще что это значит на сайте этого есть хорошая дока по новым инструкциям можно найти ту же самую информацию у окна я фока у меня архитектура skylake а ум она легла версию нас в этой оси 5 попутно способность единица у вы в иные вещи тоже 5 и 1 то есть как бы инструкция 1 работает с одним и тем же тоже сам производитель на более поздних моделях это не так далее посмотрим в целом в этом месте у нас код примерно один тоже то есть от restrict а у нас никакого толка здесь нету давайте посмотрим еще на одном программу это уже второй тип авто векторизации для циклов собственно нас есть цикл который работает он вам большому количеству данных и делать тоже однообразные действия как и в предыдущем примере тоже хороший поттер для авторизации но и здесь у нас еще ограниченное количество итераций тоже можно с этим циклом хорошо работать можно его разворачивать поперек созывать и так далее снова его скомпилируем видно что у нас здесь есть de son of the векторизация отработала и давайте сделаем то же самое для кванга первый раз мы с оптимизировали джесси второй раз флангов куанг нам сейчас ничего не написал ни как их оптимизация но он здесь не смог сделать давайте посмотрим на 2 вещи программу в принципе это та же самая программа но я добавляю крахмал для того чтобы сказать а куанг о том что он должен авторизовать этот цикл и давайте вы снова попробуем вот теперь нам clang уже что-то выдал когда мы его попытались заставить это реализовать он сказал что он не может авторизовать сейчас посмотрим дальше что он моя собственность чем это связано а пока давайте сравним версия с конкретного кода вот это разница между jitsi версий и конгом ну плюс-минус цикл ой одинаковый ног укладка мы видим что появляются еще дополнительные данные это разве выворачивание от цикл в этом месте у нас два по моему здесь в общем в этом цикле мы оперируем вот в это вот это место мы оперируем к аккаунту по двойке и мы два раза к каждый каждый каждой итерации цикла мы двойной к делаем но авторизация не получилось и у нас вынесен эпилог собственно запись результатов в основную память собственном связано это с тем что был багрепорт в лонге и человек собственно жаловался на то что такие циклы не авто факторизуется на это было сказано что ливи мне может авто факторизовать когда вы читаете из памяти и сразу же в цикле пишите в память но уже все это получилось сделать у кванга нет привет пола уже 2 я часто говорю о вопрос тогда уже вам давай мыла ваню что не хотя бы есть вопрос поднимите руки кого есть вопрос 1 рука вторая рука не переживайте если вы стесняетесь той задать вопросы всегда будет зона где можно еще будет поговорить про доклад саша так я вот видел вот male ну давайте с этого начнем здравствуйте спасибо за доклад я хотел что уточните вот вы видели такую таблицу с разными флагами оптимизация my и с разным перформанса вам соответственно программы и сделали вывод что соответственно какие-то флаги более применимы там лучше работать других уже но когда на практике мы проводим такие проверки там всегда возникают какие-то флюктуации соответственно там я не знаю очень там антивирус там в это время параллельно делают вот и соответственно там можно ли там когда можно на эти данные полагаться и говорит что да действительно там вот эти флаги для нашей программы работают лучше что можете сказать по этому поводу в данном случае оптимизация кода она не зависит от факту ации которая будет параллельно с программой если вы работаете с каким-то урок free алгоритмом то для вас очень болезненно прям шин да то есть когда у вас работает ваш пог'ом потом между какими-то инструкциями у вас вытесняется другой поганые случилось вытеснение да и вам нужно данный поддержек консистентными это немножко другие вещи то есть сейчас мы говорим о том как наполняется pipeline процессу а то есть все но у процесс то есть там писалось когда он работает если у вас нагружена систему вас там свои сокращаются но в пределах вот этот твой со собственно тот код который вы сгорели он работает таким образом как вы ожидали то есть 500 я я бы сказала того что если у вас происходит флуктуации вы видите что вы оптимизировали оптимизировали а у вас как бы там а привезенный код работает хуже чем оптимизированного продакшене на тогда вас на что происходит системе делать профилирования сэмплирования профилировщика собираюсь что sasuke сами что с каша происходит и так далее то есть это скорее да какие то проверки какой то не знаю конкретные функции кого-то куска кода дает не говорит мы всю программу так не не стоит прогонять с такими флагами нет бы почему все программы стоит погонять но связанными с разными вариантами оптимизации то есть в программе у вас вы начинаете с того что вы собираете к перевозчикам кафель программы находите наиболее горячие вместо это место оптимизируйте да там копаетесь в землю и так далее работает она быстро все хорошо как бы потом когда вы выкладываете на плод но ваша гордость вы увидите что у вас все стало лучше если стало хуже значит надо сдаваться что в чем дело но в цену я не помню такого кейса чтобы действительно нельзя было забацать почему оптимизации не приносит пользу спасибо тут еще был один вопрос добрый день и спасибо за доклад очень классно все я хотел спросить и вы там используете статические предсказания ветвления то есть я правильно понимаю что в вашей машине и каждая ветка она в общем то один раз практически выполняется по большей части больше чем свет не там не в этом дело ветки могут исполняться по несколько газ но дело в том что когда вы это историй вообще поставить машину когда вы стоит машину пример попробуйте оптимизируйте тяжело с по полевым то тяжело выносит наверх наиболее горячую точку до который много раз исполняется нас есть семантика входных данных то есть мы знаем что навсегда метод идет за ее гелем за потом еду еду и так далее и нам для того чтобы максимально эффективно было стать машина мы должны сначала спросить метод потом йогой независимо от того что метод там могут быть вообще копейки но он должен работать до того как у нас отработал gianelle вот мы пришли куда-то там середины функцию там накрутили свои интеграции пошли дальше просто при повторных проходов же предсказания ветви цикл включится и он уже будет на него ориентироваться да но обувь его предсказание ветвей а конечная органично размер если посмотреть на ход который там весит 9 килобайты в нашем случае там 50 килобайт там очень много ветвлений и это все не помещаются буфер"
}