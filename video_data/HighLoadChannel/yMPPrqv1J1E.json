{
  "video_id": "yMPPrqv1J1E",
  "channel": "HighLoadChannel",
  "title": "Долгожданный релиз pg_pathman 1.0 / Александр Коротков,  Дмитрий Иванов (Postgres Professional)",
  "views": 2362,
  "duration": 3296,
  "published": "2017-04-22T14:48:17-07:00",
  "text": "тяжёлая артиллерия в лице Александра и Дмитрия, которая будет рассказывать про не менее важную фичу постгреса и не менее важную даже не то, что фичу, а проблему, которой сталкиваются люди, работающие с Позгрисом, и не только. Это то, как правильно секционировать или партеционировать, как вам более удобно произносить эти таблицы. И Александр с Дмитрием уже довольно длительное время трудится над расширением, который позволяет делать гибко, хорошо и удобно и быстро. И быстро, да, и не только мы, на самом деле. Ну, на самом деле, я что-то немножко сбился с ритма. Да ничего, ничего, ничего страшного. Ну, коллеги, давайте поприветствуем наших коллег и передадим им слово. Угу. Спасибо. Значит, как правильно уже сказали, наш доклад будет посмещён расширению ПГпасн, которое реализует продвинутое секционирование в Постгросе. А в основную часть доклада будет рассказывать мой коллега Дмитрий Иванов, который сейчас как раз очень активно включился в работу над расширением ПГ Passman. А я буду так время от времени что-то добавлять. Так, ну хорошо, давайте сначала рассмотрим, зачем всё-таки нужно секционировать таблицы. Вот так случилось, что на самом деле до того, как появился ПЖ Passman, уже существовал экстнен, который нужен для секционирования PG Partman. Но лично у меня сложилось впечатление, что, э, судя по тому, какую он производительность выдаёт, ну, и не только по Бартману, а потому, что говорят в Хакеersс, что говорит Том Лейн, а что у протецирования, в принципе, достаточно ограниченное применение. Вот. А в принципе зачем нужно протеционировать? Ну, во-первых, эмо, что приходит на ум и о чём люди постоянно говорят, так это управление большими объёмами данных. То есть у вас может быть какой-то невероятно большой объём данных, который нужно как-то обслуживать, нужно периодически подчищать этим всем заниматься. Э у вас есть возможность м сложить всё в одну таблицу, начиная с какого-то момента у вас будет индекс блоутиться, у вас будут ну таблица получается реально очень большая, в неё будет дорого вставлять, дорого апдейтить, дорого её обходить много вакуумом. Поэтому, начиная с какого-то момента, можно использовать механизм наследования в постгресе, который мы чуть позже через несколько слайдов подробно рассмотрим. Но базовая идея заключается в том, что когда мы добавляем партицирование, мы можем менеджить каждую партицию отдельно. То есть мы можем по ней отдельно делать вакуум, отдельно зная, что мы в ней ничего больше не будем инсертить, мы можем вообще отключить вакуум, отключить ну всякое такие вещи. Мы можем вынести её на отдельный физический сервер. Сейчас вдв это позволяет, да? То есть мы можем использовать более гибкий подход, когда для каждой партиции, в зависимости от количества инсертов, от вообще от разной нагрузки, мы можем как-то совершенно по-разному с ними работать, что одна единая таблица нам не позволяет делать в общем случае. Ну, в общем, самый простой пример. Вот есть у вас, например, таблица большая, куда вы пишете логи, да? Вот, и вы решили там, что логи там за январь прошлого года вам стали уже не нужны. Если у вас это всё лежит в одной таблице и записи уже за это время там как-то случайным образом перемешались, то у вас пойдёт там какой-нибудь индексн, он начнёт перемалывать весь хип, вы вот этот лит у вас зависит надолго, вам надоест его ждать, вы его консельнёте и будете не знать, что делать. А если у вас всё распротицировано по его месяцам, то вы просто дропните одну таблицу, и всё произойдёт очень быстро. То есть локальность данных есть по тому атрибуту, который вам нужен. Ну, собственно, да, это, в принципе, закономерный итог того, что наши коллеги рассказывали и про автовакуум, ну, и про остальные другие вещи. То есть эти все эффекты можно в какой-то степени нивелировать по кусочкам. Вот. Далее, мм, можно придумать такие случаи, когда возможны быстрые запросы к наиболее часто используемым секциям. То есть, скажем, если у нас есть какая-то, ну, какой-то закон, который, которому подчиняются данные, например, мы постоянно добавляем что-то за каждый следующий день. То есть у нас есть блоги, у нас есть новостная лента там ВК, ну, всё, что касается соцсетей, когда появляются данные с каждым новым днём. И понятное дело, что, э, они только раз задним числом могут попасть за предыдущее время. То есть у нас есть возможность создавать секции во временном диапазоне и туда добавлять данные. И тогда получится, что для самых последних актуальных данных мы можем сделать партиции с индекссканом. И вообще, забегая вперёд, скажу, что было бы очень неплохо, если была возможность как-то обмануть позгриз и заставить его по нашим условиям не смотреть те портицы, которые уже не актуальны. Вот. И смотреть только из тех, которые последние, которые актуальны на сегодняшний момент, чтобы запросы наши, конечно, обрабатывались быстрее. Это очень сильно перекликается с тем, что говорил Иван Фалков, когда мы, ну, имеем проблемы с офсетом и вообще чаще всего пользователю нужно несколько последних, ну, не строчек, ну, какой-то небольшой объём данных реально за последнее время. Так, мы, а, вот мы сейчас этот вопрос рассмотрим тоже. Ну, вы Давайте. Ну, ладно, я думаю, нужно двигаться дальше, а то мы так на первом слайде всё время и потратим. Да, да. Отлично. Ну, в общем, подведя итоги, когда нужно секционировать, если таблица содержит архивные данные и в последнюю секцию добавляются новые данные, да, это да, это раз. Вот два. Содержимое таблицы должно быть распределено между дисками или серверами. Это шардинг. Ну, я думаю, тут не трудно догадаться, что производительность при этом упадёт, но зато мы будем иметь возможность разбивать всё по разным серверам. И Passman в какой-то мере позволяет это сделать. Так, ну и ещё, как я уже сказал, хочется ускорить запросы к определённым срезам данных. Ну то есть, например, вы можете взять и по последней партиции только построить индекс, а по остальным не строить, да? Потому что реально зачем? А так вот старый добрый метод, который используется ипокон веков в постгресе, это то, что мы создаём таблицу, ну, скажем, она будет называться Partiition, после чего мы добавляем partition о, который будет играть роль партиции. Для тех, кто не знает, like Includin All позволяет нам создать партицию почти полностью, ну, фактически с таким же лейаутом, как у нашего родителя. Причём отнаследуются индексы, отнаследуются чекконстрейнты, отнаследуются, ну, некоторые другие свойства. В принципе, это вы можете посмотреть по документации, да, потому что если просто inхit сказать, то оно, по-моему, только колонки, да, оно возьмёт возьмёт только колонки. Причём оно даже нл не будет, естественно, учитывать. А это, ну, в общем-то, не то, что нам нужно, если мы хотим создать прозрачное партицирование, где каждая партия, ну, фактически полностью соответствует нашему родителю. И под конец мы добавляем чек констринт, который для данной партицы описывает, э, с какого по какое там, ну, диапазон, в котором лежат данные. Но, к сожалению, у этого подхода есть определённые минусы. Ну, во-первых, а, очень много ручной работы для управления партицами. Ну вы сами вдумайтесь, если вы не напишете каких-то скриптов на PLPGSQL или даже PL Python, ну по вкусу. Если вы всего этого не сделаете, то просто представьте, с какой болью столкнётся ваш администратор, который будет постоянно вынужден там под каждый временной сегмент не забыть добавить новую секцию, которая будет содержать эти данные. Вот. Во-вторых, то, что вы упомянули, такой момент действительно есть. То есть партиции из итогового плана действительно выкинутся, которые поч констринтам не проходят для данного. Но не стоит забывать о том, что будет использован exosive sech, то есть будет полностью перебираться для каждой партиции. А теперь представьте, что у нас их 10.000, 20.000, ну и ещё больше. Ну и понятное дело, что это будет довольно грустно. И у нас вполне возможные ситуации, не нужно далеко ходить, чтобы найти ситуации, когда в таком случае у нас перебор и, соответственно, планирование будет занимать больше времени, чем достать какую-то несчастную строчку 1 байт. Э, как ты говорил, Вань. И ясное дело, что нас это не устроило. А, кроме того, отсутствует оптимизация во время исполнения. То есть, скажем, ясное дело, что если вы используете какой-нибудь nested loop и слева у вас, ну, поте не не loop, а join. Если вы используете join, у вас слева не прортецированная таблица, справа прортицированная таблица, вы хотите их заджойнить. И вполне как бы логично, если не вдаваться в тематику баз данных, что когда вы берёте строку из таблицы, которая не протицирована, то вполне логично и понятно, что можно не перебирать вообще все секции. Можно выбрать только ту секцию, в которой которая приходится на то число, которое мы выхватили. Очень сложно говоришь. Короче говоря, суть в том, что вот механизм constraint exclusion, он позволяет, а, выбрать нужные секции, когда у нас, а, константа прямо в запросе зашита. Но она может, например, у вас быть не зашита в запросе, а приходить из условияна там или приходить там из препарайтмента. Вот. И в этом случае нам нужно секцию, которая нам нужна, выбирать уже на этапе выполнения. Constraint Exclusion такого не умеет, а в то же время это очень нужно. Да, construsion это не умеет по той простой причине, что во время планирования эти данные просто недоступны. У нас их нет, этот запрос ещё не начал выполняться. А дальше нет стройной поддержки хэш партицирования. То, что говорит сам Томлейн по этому поводу, то, что оно, в общем-то, не нужно, потому что мы лишаемся всех тех замечательных свойств, которые стоят на первом месте. Неудобно работать с такими партициями совсем. Вот. Но тем не менее все просят хом постоянно просят, поэтому у нас оно есть. Не копируется кейс родители. Это, ну, не самая очевидная вещь, но довольно неприятная, потому что если у вас родитель как-то, ну, присутствует для него referренal integrity с другими таблицами, то оно внезапно возьмёт и для партицы исчезнет. То есть не забудьте к вашей реализации на коленке добавить ещё и эту вещь. Дальше ещё более неочевидное - это то, что возможна проблема с привилегиями. То есть когда вы сами создаёте партицы, точнее таблицы, то вы же и создатель парти, ну этих таблиц, вы же и создаёте им привилегии на инсрты, delete, апдейты и вообще всё, что только можно. А для партиции это, в общем-то, не очевидно для людей. Быть мы же хотим прозрачное партицирование, где абсолютно понятно, что партицы они обладают, ну, такими же прилетими. Короче говоря, если простым языком сказать, то у вас есть, а, таблица, да, вы на неё повесили триггер, чтобы на неё партиции добавлялись. Вот. И значит, если вы не скажете, что оно Security Definer, то но то новые та секции будут создаваться уже от имени того, кто данные туда вставляет. А это совершенно не обязательно тот же самый пользователь. Ну, в общем, это достаточно большая проблема. А ещё учитывая тот факт, что тот, кто не владелец, через родители всё равно сможет их читать. Это немного нелогично, но тем не менее. Ну, в общем-то, возможное решение хотя бы для части этих проблем первый вариант - это то, что мы можем выбрать какое-нибудь расширение для автоматизации рутины. Как минимум пжман партман в принципе подходит для этого дела, но, как уже сказано, планы он не особо оптимизирует. Ну, то есть пжman - это расширение, написано на пльгскуэле, насколько я помню, на 80% как минимум. Вот на 80%. И оно, в принципе, ну, работает в рамках тех вещей, которые там доступны. То есть на процесс планирования он никак не может повлиять. Ну, в положительную сторону. И на самом деле он просто был разработан ещё тогда, когда этих механизмов в постгресе расширяемости такой не существовало. Хуков планировщика определённых плюс костомных нот. И, в принципе, поэтому он и не поддерживает. А мы уже используем вот эти все новые механизмы, которые появились, начиная с постгреса 95, и поэтому у нас уже возможностей гораздо больше. Да, именно поэтому мы пришли ко второму варианту. Мы решили создать протецирование таким, каким мы его видим, хотя бы на основе тех механизмов, которые появились в 9 и, соответственно, в 96. Так вот, пжман, что он предлагает? Ну, во-первых, поддержка хэш и range протицирования, а, во-вторых, автоматическое управление секциями. Что это значит? Это значит, что, во-первых, если вы вставляете данные, для которых нет всё ещё секции, то вы можете включить фичу такую, чтобы автоматически создавались секции. Ну, то есть вставляйте и задумывайтесь. У вас запрос, конечно, работает медленнее, потому что под капотом он вынужден эти таблицы создать, но зато Иссёрт отлично отрабатывает и ваши данные на новом месте. А вот дальше улучшенно планирование запросов. Вот как раз то, о чём мы сейчас говорили, поэтому потом. А дальше теперь фишечки наши. Мы создали несколько э специализированных узлов планировщика. То есть понятное дело, что те, кто те из вас, кто смотрели Xin налай, они видели там Nestet Loop, Secan всё такое. Ну вот Rime Appent и Partition Filter - это специальные узлы на основе функциональности, добавленной в 95, которые позволяют нам как-то вклиниваться в этот процесс и менять стандартное поведение к лучшему. Так вот, runтай appent - это выбор секции во время исполнения. как раз переменим в нетлупе, когда вы должны из партицированной таблицы на основе параметра отсечь все ненужные партицы, которые заведомо не могут содержать вот это вот значение. То есть понятное дело, что если у вас параметр вычислился в пять, то в секции от миллиона до 2 млн искать его бесполезно. Вот дальше partition filter - это insert без тригдеров. Вот, ээ, это довольно интересный момент, потому что, как мы видим из бенчмарков, это одна из самых чуть ли не крутых фич. Это и ещё одна проблема, собственно, ирта, то, что иртреторнинг ничего не возвращает. Да, да. Вот. То есть это инсрт без триггеров, а триггеры, то есть, ну, вот с с нодой возвращает без триггеров. Да, сейчас, сейчас мы всё это расскажем. Так вот, неприятное свойство триггеров заключается в том, что когда вы делаете инсерты, ну, мало того, что вы не можете сделать ретёрнинг звёздочка, потому что тригер он подменяет, вы возвращаете наверх, ну, этого кортежа нет, я его туда куда-то там ставил. То есть у вас инсртвить в родителя, вы из триггера вынуждены эту вставку отменить и сделать отдельно вставку в э в секцию. Вот. Но из-за этого получается, собственно, то, что ничего не возвращается, потому что у родителей ничего не вставилось. Да, абсолютно верно. И, соответственно, как результат, вы не можете увидеть, какое количество строков вставили. У вас просто будет insert 00. Это определённо не то, чего люди ждут, когда ожидают прозрачного протецирования. Вот. Ну и дальше также у нас был фикст сделать copy from to, который, в принципе, использует ту же самую функциональность, что partition filter. То есть он точно так же берёт и для всех данных, которые вы подаёте там из stна, из файла, он распасовывает это по партисациям. Причём он точно также может создавать их вот секции. А неблокирующая конкурентность секционирования. Что это такое? Что за зверь? А, ну понятное дело, что если вы практицируете, у вас есть две стратегии. Первая - это разрешить и разрешить модификации, но тогда нужно как-то перемещать по кускам. И второй вариант гораздо более простой. Давайте заблокируем всю таблицу. Пусть никто в неё не сможет инсертить. Ну то есть это соответствует exclusive log. возможно только селекты, потому что они ничего не меняют. И далеко не всех это устраивает, потому что если у вас там в продакшене какая-то база на большая, то есть если вы возьмёте и просто заблокируете, то никто неё не сможет исёртить, никто не сможет апдейтить, делитить, и это довольно плохо. Поэтому, когда мы создавали неблокирующее прортицирование, мы блокировали кусок строк, ну, какой-то небольшой бач с помощью for share, for update, точнее. После этого мы его перемещаем и, наконец, мы его удаляем. То есть вот так вот по кускам Background Worker э берёт и перемещает стройки по партиям. Ну, то есть это позволяет нам сохранять доступ нарта, делиты и апдейты, да. Ну и ещё, ээ, хотел сказать про создание секций конкурентное. То, что вот, например, а если у вас есть автосоздание секции, то вы вставили строчку, при этом автоматически создалась секция. Но фишка в том, что если это происходит в той же транзакции, то эта секция пока никаким другим транзакциям ещё не видна. То есть, если кто-то ещё параллельно захочет что заинсёрть, то он будет ждать, пока ваша транзакция не завершится. Это не очень хорошо. Поэтому у нас есть специальный механизм, что когда вам нужно создать секцию, порождается бэкграунд workкеer, который её создаёт, комитит эту свою транзакцию, она сразу видима всем. И все могут в эту секцию инсортить, не блокируя друг друга. Да. Что самые замечательные, они, собственно, транзакция попадёт? А что просида попадёт? Транзакция. Нет, в этом вся фишка как раз. Это это ясное дело, что это, ну, по крайней мере, пока, ну, в будущем это будет отключаемое поведение. Мы ещё просто не успели это сделать. Аэ. А, то есть фишка заключается в том, что если вы насоздавали секции, а потом, ну, делаете ролбек, то неногда бывает закономерно, что вы хотите эти секции сохранить. Кроме всего прочего, э, ну, это может быть не совсем то, что вы хотели, но хотя бы это позволяет, как только транзакция закомитится, отпустить все блокировки. То есть то, что было создано бэкграундворкером, мгновенно может быть увидено теми другими конкурентными инсертами, которые тут же его увидят. Они будут вынуждены ждать часами, пока вы там свой, ну, инсрт гигантский закончите в одной транзакции. Вот. Ну и вишенка на торте - это поддержка ФДВ. Ну, в какой-то мере можно сказать, что она экспериментальная, но мы имели возможность потестить её на постгрев. Ну, собственно, это целевая аудитория, потому что если мы хотим сделать шартинг, то не имеет смысла на чём-то другом пока что тестить. А фишка работает, но опять же на insert, э, то есть апдейт будет не будет нормально обработан, но зато Insort точно так же будет выбирать нужную партию и в неё вставлять. А сделано это тем, что он там все функции, которые под ковриком лежат, будет подменять таблицу и будет использовать для неё. Ну, об этом, если хотите, потом обсудим в клорах. А так вот основные элементы IP, что мы умеем? Ну, во-первых, мы можем создавать секции, татача, appent, prep. Что это значит? Ну, end - это добавить новую партицию с заданным диапазоном. То есть вы можете задать его вручную. Кстати, по поводу этого вот чем мне слёту не понравился Партман, это то, что если ты берёшь диапазон не для чисел, а для дат, то он почему-то, ну, автор посчитал, что самое удобное - это взять и создать от какой-то даты, там когда-то там давно до сегодняшнего дня. Ну и плюс ещё приплюсовать, сколько вы хотите. В общем-то, это далеко не всегда то, чего вы ждёте, особенно когда пишите ваши тесты. Поэтому у нас такого нет. У нас можно создавать любые партиции с любыми диапазонами, но при условии, что они не должны пересекаться, потому что это усложнило бы планирование, а ещё это, ну, не очень логично. Вот. А тач - это взять и готовую таблицу, в которой у вас уже есть данные, модифицировать её слегка, чтобы она стала партицей, то есть накинуть на неё констринтов, э, прописать её куда надо, ну, и закашировать. То есть у нас есть кэш для того, чтобы всё это дело быстро работало. Апент и препент - это к существующему диапазону слева, справа накинуть партицию стандартного размера. Потому что, когда вы практицируете, вы можете сказать, что, ну, я хочу, чтобы все новые партицы создавались шириной 1.000. Вот 1.000 там, ну, в интах. А дальше управление созданными партицами. Ну, вы можете мёржить их, сплитить, э, разделять, то есть склеивать диапазоны и дропать, конечно же. Куда же без этого? Причём дроп мы сделали такой удобный, что теоретически вы по вьюхе, которая, ну, имеет перечень партий, вы можете задать условно: \"Я хочу там, например, дропнуть все партиции там с такого-то числа по такой-то\". Всё, что вам нужно будет сделать, это просто select там drop partitions, where нижняя граница такая-то, верхняя граница такая-то. Он возьмёт и по этой вьюхе пройдётся и дропнет все партицы. То есть это намного удобнее, чем когда вы будете писать свой скрипт, я уж не знаю на чём. И, э, ну, на Питоне там, например. А дальше э генерация чек констренции и триггеров для апдейта. Ну, на самом деле, совсем от триггеров нам пока не удалось избавиться, потому что это более сложные задачи сделать их для апдейт, то есть с учётом всяких ход и прочего. И, ээ, ну, во-первых, по поводу триггеров. У нас есть функция для того, чтобы сгенерировать автоматические триггеры, которые позволит перемещать данные между партиями. То есть, если вы не просто обновляете какой-то ключ, который, ну, вообще не является ключем протицирования какую-то часть строки, то есть понятное дело, что она останется в той же самой партиции, ну, значение у неё какое-то изменится, но возможно, что вы хотите взять, если вы протеровали по ID, запдейтить, чтобы ID изменился. Ну, так это позволит перенести кортеж в другую партицию. А дальше, а-э, установка обработчиков в создании секции. Нам поступил fчре Request, который заключался примерно в следующем. Давайте мы предоставим возможность на каждое создание секции вызывать некий пользовательский колбэк, который внутри сможет выполнять любую логику. Ну, простейший пример, зачем это может быть нужно. Допустим, вы хотите, чтобы все партии, созданные там пятницу тринадцатого, перемещались в особый table space. Ну, у вас партия создастся. После этого всё, что вам нужно будет сделать в этой функции, вы берёте, делаете alter table, там, изменить table space. Ну, и поскольку она всё ещё пустая, она сразу же переедет куда надо. без особых проблем. Дальше, ну, несколько вьюшек, то есть информация о секциях, которые я уже упомянул. И, собственно, вьюха, которая содержит перечень бэкграундворкеров, которые трудятся над вашим конкурентным протецированием. Естественно, узнав информацию об этом вокере, вы тут же можете его хлопнуть. То есть вы скажете, что для данной таблицы, пожалуйста, остановите эту задачу, потому что мне сейчас это не нужно. Э, ну, это уже ваше решение будет. Ну и, наконец, для отключения всяких вещей, типа там, давайте мы возьмём и запретим создание партии на Insert. У нас есть отдельная таблица, в которой мы храним эти флажки, которые позволяют некоторые фичить. И дополнительно хочу отметить, что мы добавили возможность отключать определённые подсистемы пасмана, аналогично тому, как это сделано в позгрессе. То есть вы можете сделать там в подкрепи set enable index scan enable там nested loop и точно также для пасмана вы можете основные подсистемы включать отключать как вам нужно для бенчмарков для тестов если что-то там сломалось но вы не хотите например полностью от него отказываться дальше а начнём всё-таки с того что для чего создался пасман дело в том, что пасманом он называется не просто так то есть пас - это путь и смысл заключается в оптимизации пути исполнения а м Ну, то есть не просто партицы, а партиции на стероидах. Так вот, для того, чтобы проделывать такие операции, э нам нужно вклиниться на двух стадиях: на стадии планирования и на стадии исполнения. Ну, то есть после того, как запрос обработался, распарсился, рейтнулся, мы включаемся в дело, срабатывают наши хуки, и они вносят некоторые конструктивные изменения в пути исполнения. Вот. Ну, тут я нарисовал картинку, которая, собственно, обозначивает ключевые фичисмана. Ключевые фичи следующие. На чём держимся? На трёх слонах. Runime append специальная нода для того, чтобы оптимизировать, ну, по сути, настатлупы или что-нибудь на это хотя бы как-то похожее с параметрами, чтобы отсеивать ненужные секции. Partition filter для того, чтобы можно было делать быстрые инсерты. И, наконец, обработка условий, которая лежит, собственно, в основании всего, потому что именно с помощью мы создаём срез, отсеваем те партии, которые нам не нужны. Давайте рассмотрим, как Passman обрабатывает условия. Ну, во-первых, опять же, небольшой ревандинг, что механизм чекконстринтов в постгресе, он не может упрощать. Ну, то есть он просто вот условие в, какое у вас было в запросе, он просто во все партиции спускает, как есть, даже если там какие-то проверки, они, например, тождественную истину возвращают или тождественную ложь. Вот. А в ппасмоне мы, соответственно, сделали механизм, который вот это условие в может упрощать. И те проверки, которые тождественно истинны и тождественно ложны для этой партицы, они просто не будут выполняться. Вот. И, да, он достаточно механизм такой, может, не очень очевидный для понимания. Вот поэтому на простом примере его рассмотрим. Пусть у нас есть там шесть секций, да, с там с января по июнь 2016 года, да. И давайте попробуем выполнить по ним примерно такой запрос. Ну, правда так немножко мелкий, вот, но, ну, я думаю, вам должно быть, в общем, там четыре условия там, а, по сути, два ренджа, склеенные через ор. Вот. Да. И давайте посмотрим. Ну, собственно, фишенко, что мы здесь выделяем? Мы выделяем дерево наших условий. То есть представляем все вот эти условия с орами, эндами, меньше либо равно, больше либо равно в виде дерева. А во главе у нас ор, дальше от него тлятся два энды. Ну, я думаю, тут всё в принципе понятно. неравенство, которые нужны для ренджей. Да. Вот. Теперь давайте посмотрим. Вот у нас первое, э, что появляется на слайде- это по каждому из условий самых нижних мы выделяем вот эти шесть партиций, которые у нас есть, и для каждого условия смотрим, какие партиции подходят, какие партицы не подходят. Если в ранних версиях Пасмана использовались, использовалась двоичная логика обычно, ну, true - это подходит, флс- это не подходит, и условия применялись все, то после того, как Саша внёс некоторые изменения, у нас появилась троичная логика, когда становится понятно, что, ну, если ну то есть для каждого условия есть три варианта. Оно тождественно истинно для данной партиции, тождественно ложно или его нужно проверять. То есть здесь, собственно, вот на картинке показано ТF, там тождественная истина, тождественная ложь, а MB - это значит, надо проверять. И по партия, дада, да, да. Это вот по по партиям вот. А мы вот здесь на графике, на картинке показали это в виде массива. На самом деле, учитывая, что секций может быть много, у нас там лист Range хранится. То есть это просто удобное представление, чтобы объяснять было, потому что, ну, фолс мы не храним, да? То есть вот мы сделали вот для левой части выражения, потом следующий слайд. Вот то же самое для правой части сделал. И нам остаётся агредировать все значения вверх до тех пор, пока для ор не посчитаю. То есть через просто через трёхзначную логику. И за счёт трёхзначной логики решение может быть в некоторых случаях не совсем точное, но зато мы его получаем очень быстро, потому что в целом это как бы НП полная задача, а тут вот такой а такой алгоритм, который работает быстро и позволяет там 99 реальных случаев обработать. Итак, ну, собственно, вы видите XLIN налай, который получился. А давайте вернёмся на секундочку назад и увидим, что в итоге здесь были выбраны четыре партиции сверху, да? То есть вот те для две, для которых F красненькая, это значит, мы их вообще не проверяем, потому что для них условие в целом всегда ложное. Соответственно, Т - это значит, что мы значит полностью партицию просто сексканом. Вот. А, соответственно, мы там проверяем часть условия. И ту, какую часть условия нам надо же проверять, мы просто вниз спускаемся и смотрим, что там, да. Итого у нас выбрались вторая, третья, пятая и шестая. Угу. Вот. Ну, собственно, мы здесь их и видим. Угу. Причём, заметьте, что далеко не у всех таблиц одинаковый тип скана используется. То есть, если для некоторых был выбран сексн, потому что они заведомо для заведомо истиной, они для них целиком нужны все данные из таблицы, то очевидно, что самая быстрое. А вот этот вот Mayби, он как раз создаёт идекс only scan в данном случае, который выбирает те самые стройки, что нужны. Да. Ну проверяли? Да, конечно. Ну, это просто пример такой. Откуда откуда-то скопировали? Не, просто скопировано. Откуда-то это просто, чтобы объяснить слайд для объяснения того, что там показано дерево. Реальные данные потом будут, конечно. Теперь давайте рассмотрим второй механизм. Вот обратимся к обычному апенду, который существует в постгресе. Допустим, нам нужно поджойнить две таблицы. Ваня Фроков об этом уже рассказывал. А что у нас есть три вида джойна. Ну, давайте рассмотрим на примере этот loop, когда мы должны для каждой строки левой таблицы попробовать каждую строку правой таблицы. Вот, соответственно, ну не не трудно заметить, что вот действительно для каждой левой проверяется каждая правая. Теперь представьте, что у вас там 10.000 партиций. В каждой партии ещё очень много много-много данных. И выясняется, собственно, что для левой нужно перепробовывать все правой. И так для каждой строки. Но, соответственно, это неудобоваримо совсем. Поэтому мы придумали своё решение и назвали его Runтай Open с намёком на то, что все вот эти волшебные проверки, они в рантайме происходят. То есть, когда у нас появилась такая ситуация, что Constraint Exclusion не смог отсечь те партиции, которые нам не нужны, потому что, ну, параметр, а что мы сделаем? Мы не знаем, чему это значение равно. Run append может взять из состояния экзекютора и эти переменные выдрать. А затем использоно, используя спрятанное выражение, которое мы взяли из запроса, при примерить и, наконец, выделить те партиции, которые на данной итерации нам нужны. Ну, собственно, если вы знаете наверняка, то, ну, наверняка вы знаете, что когда у нас план выбран, вы можете снова, ну, собственно, ладно, сейчас, если у вас есть Nestat loop, если у вас текст скаan, а справа у вас индекс скан, то индекс скан параметризуется и каждый раз для каждой итерации принимает на вход строку из левой таблицы. То есть экзектор постоянно этот скан, когда выполнит, на следующую строчку из левой таблицы, он возьмёт и обновит индексскан и заменит в нём параметр. Ну вот, в принципе, можно провести прямую параллель между индекссканом и рантаймом апендом, потому что в какой-то мере он на основании этой переменной может отсекать те партицы, которые не нужны. Вот так. Ну, в общем, если простым языком сказать, что в чём проблема с аппендом? в том, что, а, если у вас значение параметра протицирования неизвестно заранее, то у вас он сгенерирует такой опент, и там будут все партицы, и в нём индексскан. Вот. И как бы довольно глупо, потому что большая часть этих индекссканов вам вернёт ноль, и только та, которая нужна, вернёт вам единичку. А что делает runтай append? Он тоже спланирует сделает планы для всех партиций, но экзексить он будет только ту, которая реально нужна, и он это в рантайме проверяет. Вот. Ну, естественно, это не обходится нам совсем бесплатно. И побочный эффект заключается в том, что когда запрос выполняется, мы ничего не планируем. А значит, запланировать все акцессы ко всем партицам мы должны были заранее. Таким образом, мы действительно на этапе планирования сочиняем сканы ко всем партиям, а затем имеем возможность на основе вот этих сохранённых данных отсекать. Поэтому, если вы сделаете без аналай, он вам покажет перечень всех партий. Но если вы делаете с аналайом, то пропадут те, которые из которых ни одного скана действительности не будет. Ну, в общем, короче говоря, тут мы уже, то есть, Дима правильно сказал, мы вынуждены всё равно все партицы спланировать. И как бы, если вам нужно выбрать там всего одну строчку, вы на ту же самую проблему натыкаетесь. Вот. Э, здесь суть в том, что мы уже выходим за рамки того, что мы можем сделать просто в экстеншене. И нам это нужно будет делать в виде патча. И этот патч будет уже, соответственно, в нашем форке. Вот. Ну и, соответственно, давайте посмотрим, что в таком случае меняется, чтобы подкрепить слова. То есть вот мы видим, что для первой строчки выбрана только та партия, которая для неё подходит. Мы видим также напротив этой партиции диапазон. Ну, чтобы удобнее было. Для следующей строчки выберется новая партия. Ну, и таким образом мы постоянно будем сужать тот список партиц, который нам нужен, до действительно необходимого. Вот. Соответственно, в каких случаях это применимо? Ну, я решил выписать те запросы, для которых это действительно актуально. То есть мы видим, что у нас колонка протецирования приравнивается чему-то, что мы не в состоянии на этапе планирования узнать. Это какой-то сабселект. Причём мы видим, что здесь равно сабселекту с лимитом один. Ну, потому что для равенства нужно вернуть обязательно одну строку. Мы видим, что также можно делать равно. В данном случае погресть это трансформирует как раз в Nested loop. в котором и будет использоваться runтай appent, который будет на основе текущего значения, полученного из этого сабселекта, отсеивать вартицы. И, собственно, мы видим, э, ещё один запрос. Это напрямую joint, который мы явно написали. Тут то же самое будет, в принципе, происходить, потому что это оно и есть. Ну, то есть последние два случая, они, в принципе, написаны по-разному, но на деле это практически одно и то же. Дальше следующая наша фича. Вот теперь давайте подробнее посмотрим, как же мы сделали так, что у нас не нужны триггеры. Назвали мы эту ноду Partition filт и как совету из название она фильтрует те партиции, которые нам не нужны. А давайте посмотрим. Вот слева показан XPlain с выключенными костами, потому что они в данном случае неинтересные. Explain в случае обычного инсерта. Мы видим, что у нас есть insert нода, у которой дочерний result, то есть какой-то набор данных. Ну, фактически мы видим, что здесь я примерил это на Generate Series. Ну, он создаёт ноду result, который тупо вычисляет эти значения. А справа мы видим, что в план добавилась наша нода кастомная, которая появилась. Вот как раз кастомноды в 95 появились. А, то есть мы берём и на этапе планирования модифицируем план так, что между инсертом и источником данных, которые он будет, собственно, вставлять, мы вставляем наш прокси, которого которому отведена специальная роль. А давайте посмотрим. Вот так, я думаю, удобнее на это всё смотреть непривычным взглядом. Итак, сверху, снизу проксинода, а ещё ниже субплан, из которого будут браться данные. Я сейчас покажу, как это работает. Ну, поэтапу поэтапно. Предположим, что инсрт у нас уже начался. Дело перешло к партишнфильтру. Да. Напомню, что экзектор в постгресеке style, то есть у вас каждая нота, когда каждый узел, когда выполняется, он на каком-то в какой-то момент передаёт управление дочернему узлу. Тот своему дочернему, до тех пор, пока самый нижний не сгенерировал кортеж, который он потом будет возвращать снова родителям. То есть у нас фактически кортеж из недр поднимается наверх, и процесс повторяется до тех пор, пока, ну, мы не скажем, что кортежей больше нет. Так вот, представим, что мы уже находимся в Partition Filль. Э, что мы здесь делаем вообще? Что что нужно учесть? А вот мы фактически взяли из Partition filter запустил дочерний план, чтобы взять новый кортеж. А потом после того, как кортеж взят, мы снова управление возвращается снова в парition filter. И тут мы видим, что partition filter, он имеет доступ к эшированной информации о партицировании. То есть он про все наши секции прортицированный таблицы имеет вполне конкретное представление. Он видит, какие у них диапазоны. Я схематично это изобразил в виде перечня. А что мы можем с этим сделать? Вот. Ну, на самом деле, в постгресе есть ещё один элемент, который вот мы сейчас добавили на слайд. Дело в том, что ирт он не просто с бухты баракта определяет, откуда и точнее куда вставлять. Есть определённая структура во время исполнения, которая заполняется неким дескриптором таблицы. Дескриптор он что содержит? Он содержит в себе, грубо говоря, путь к таблиц, какие по ней есть индексы, ну и другую дополнительную информацию. Например, для ФДВ он будет содержать список методов, которые нужны для того, чтобы с ФДВ что-то делать, инссёртить там. А именно поэтому, кстати, Partition Filль и работает с ФДВ, что фактически мы там ещё небольшую обвязку наколдовали. Ну, методика остаётся та же самая. И фактически, что partition filter нужно сделать на основе вот этих вот перечных секций и данных и запроса, точнее условия, ну не условия, а мы фактически используем ту же самую механику для вычисления условий, только дерево у нас тривиальное, у нас просто константа, которую мы примеряем. Так вот, фактически всё, что ему нужно сделать - это в этом, в этой структуре заменить таблицу, которую подставил Постгрис в процессе планирования, на ту, которая нам нужна, а именно партиция. После того, как мы её заменили, управление возвращается в insert, и он уже видит другую таблицу. То есть для него, на самом деле, как произошло, он впал в кома, он дождался, когда вернулись данные, после чего, ну, я вижу таблицу, я в неё ичу, и это получается наша партия. Так вот, какие плюсы у нас получаются, ещё раз повторим. Во-первых, действительно быстрая вставка данных без трийдеров, без PLPGSQL или даже написанных на C. Ну, потому что действительно, если мы пишем какую-то функцию на C в постгресе, то там добавляются накладные расходы на особую конвенцию вызовов. То есть, в принципе, даже если мы напишем на C, ну, так быстро не получится, как с помощью ноды. Ну, и помимо всего прочего, как я уже сказал, э работает ретрнинг, и мы видим, сколько строк мы реально вставили. Ну, собственно, триггеры многим людям всё равно нужны, поэтому эта нода, она ничего не ломает в этом плане. Три вы по-прежнему можете использовать, и с ними всё хорошо. То есть можно сделать триггеры на родителя, да, и он будет вызываться при вставки в любую секцию. Дада. То есть это всё по-прежнему работает, но вот видите, с такой прекрасной примочкой. Ну, а теперь давайте посмотрим на это дело. То есть вот мы вставляем таблицу Journal значение, потом делаем return и воаля у нас возвращается то, что мы сейчас вставили, да, ещё и пишется, сколько строк. Вот. Ну, далее, как я уже сказал, в принципе, тот же самый механизм используется для копии, только вся разница в том, что у нас недочерний плана, а мы этот кортеж получили из файлы, ну, изdin или или из файла, который лежит, да, или из файла, который лежит на диске. Ну, имейте в виду, это только суперюзер можно делать. А, собственно, я здесь это и показал, что у нас работает вывод в SD out, у нас работает вставка в таблицу из файла. Причём, э, чтобы никого не смущать и чтобы всем было предельно понятно, мы изменяем стандартное название оператора, которое возвращается. Мы пишем Passman копию. А таким образом, если вам, допустим, это поведение не нравится, вы можете его отключить, у вас всё будет по-прежнему, он будет писать копию, копируют в родителя. Ну да. То есть это просто convenнс. Вот. Угу. А, ну и, наконец, мы видим вот в качестве доказательства, что когда мы делаем select from only, а only - это означает, что мы берём только из родителя. Ну, действительно, у нас ноль строк, ничего там нет. Теперь давайте перейдём к бенчмаркам. Ну что мы здесь сделали? Мы создали как раз эту таблицу journal. А заполнили её какими-то данными. Так, какими же батчмарки мы будем проводить? Что будем сравнивать? Ну, раз уж речь зашла о партне, то мы сравним partman, па и обычную непратицированную таблицу, чтобы знать, а что мы всё-таки потеряли после вот этих вот изменений. Ну вот, давайте посмотрим. Здесь показан селект, который возвращает нам одну строку. Сколько мы создали партий? Мы создали 366 партиц, как дней в високостном году. А запомнисоном, да? Да, високостном. Я сказал високостм. А и в чём дизайн этого бенчмарка? В чём идея? Э мы не используем здесь prepared statement. Нам интересно знать накладные расходы, которые вот произошли, когда мы планировали планы. То есть понятное дело, что учитывая тот факт, что мы создали там индексы, обложились ими по всем партиям, то, чтобы вернуть одну строку, на это реально уйдёт очень мало времени. Это пшик по сравнению с тем, сколько реально будет длиться планирование. И вот обратите внимание, что на графике показана логарифмическая шкала, то есть то есть Партман отстаёт на два порядка с лишним, да? То есть реально Партман находится где-то на дне, но понятное дело, что ну тут по по вертикали это QPS число запросов, которые в секунду обрабатываются. А, ну тут ещё нужно обратить внимание, что мы на самом деле здесь тестируем худший случай для порционирования. То есть это случай, когда мы равномерно выбираем случайную партицию. Ну да. А потому что на самом деле, если результаты будут, если мы будет, ну, локализовано, то есть как какая-то будет чаще, как какая-то реже, то на самом деле результаты будут лучше, и, может быть, партицированный вариант даже начнёт выигрывать по сравнению с одной таблицей. Ну да, конечно. В общем, э, как раз, в общем, не испытывайте ложных каких-то иллюзий. Это действительно показан терминальный случай, когда съедается именно планированием, а не исполнением за счёт вот этой одной строки. Угу. Ну и, собственно, давайте вот покажем другой график. Это уже когда мы возвращаем данные из одного дня. То есть вот мы берём одну партицу целиком один день и видим, что здесь действительно ТПС очень хорошо так просел. Но тем не менее, что называется, Наздр, в наздрю идут обычная таблица непротицированный и пасман. Но Партман по-прежнему отстаёт. Причём, как вы можете заметить, они все упираются в особенности нашего сервера. То есть на пике они находятся там, где у нас 72 ядра где-то. А, ну Партман он точно так же как бы себя ведёт. Ну, конечно же, хуже за счёт вот особенностей его. А теперь давайте за бенчмарками инсёрты. И вот это та самая интересная часть, о которой я говорю, потому что тут мы видим, что за счёт особенности прортицирования и той магии, которую мы применили в парition фильтре, мы видим, что инсерты в партицированную таблицу становятся быстрее, чем в непрартицированную, потому что, ну, этому можно придумать достаточно много объяснений на часть того, хотя бы, что у нас есть здоровый индекс по родителю, а на протицах, естественно, он будет на порядке меньше, да? здоровый индекс, и при этом в нём есть такая достаточно неплохая конкуренция за его ротовую, особенно за рутовую страницу, которую все постоянно пинят, лочат, разлочивают и так далее. Ну и, конечно, это не единственное, то есть если бы на самом деле мы рассматривали не инсёрты в вакууме, где мы только их инсертим, а точно также использовали бы frepace map, то тут ещё хуже было бы, на самом деле. Вот. И Visibility Map тоже не забывайте. Короче, видим, что Пасман лидирует явно в этом тесте. А, да, кстати, заметьте, я я совсем забыл добавить, что этот тест был выполнен с помощью пожбенча с опцией минут, то есть это именно prepared statement, то есть не нужно думать, что время здесь съедается планированием. То есть планирование вообще не играет никакой роли, потому что ирт очень просто планируется, там двух вариантов быть не может. он очень быстро создаёт generic план, который действительно должен иртить. Э временно на планирование на каждом запросе не тратится вообще. И этот бенчмарк позволяет оценить именно накладные расходы при выборе партиции. Ну и плюс ко всему вот эти вот особенности с индексами, потому что, ну, реальный случай, когда мы реально используем много индексов и вообще используем индексы, поэтому стоит иметь это в виду. И, наконец, апдейт. Ну, точно так же мы видим вполне закономерно, что апартмен находится внизу. А, и в то же самое время Passman и обычная несекционированная таблица тоже идут на здр наздрю. Что мы здесь делаем? Пояснение небольшое к бенчмарку. Здесь мы не используем prepared statement, потому что, ну, update он уже не работает как insert. Update он действительно планирует всё для дочерних партий. То есть, если подразумевается, что он вообще в природе, в погресе может только в одну таблицу вставлять за один раз, то с апдейтом всё не так. Он для каждой таблицы заedт update. То есть фактически вы увидите, что у вас апдейт такой волшебный, что у него очень много таблиц, которые он одновременно апдейтит. Э так вот мы не используем prй statйтменты, потому что тогда не получится показать преимущество ПТМА. В этом случае у нас добавлено Ну, короче говоря, апдейт у нас пока с препостайтментом не оптимизируется, но мы это в дальнейшем поправим, да. А, а сейчас он как бы, если видит, что реально пересечение по по условию перешло в одну партицию, то он автоматически её заменяет родители ею и, соответственно, вставляет в неё. Угу. Ну вот мы видим, что они действительно лидируют. Э секционированная таблица и обычная. Ну, апартмен. Нет. Вот. Ну, в принципе, если бы вы заходили в session блок, вы бы могли увидеть какой-то, ну, примерно такие же бенчмарки. Ну, тут как бы был более серьёзный только уже, да, бенчмарки на более мощном сервере с более новым пасманом, где результаты улучшились. Условия ближе намного к боевым. Вот. Ну, естественно, бенчмарки были бы неполными, если бы мы не попробовали Runтай апенend в деле. Соответственно, здесь уже использована примерно, ну, не примерно, а другая таблица. А пробовали, на самом деле, мы в двух случаях. Я вот не случайно выделил две переменных всего. Мы в таблицу вставляли 100 млн строк. Они были не шибко сложные. Там всего лишь текстовые поле MD5 от А, ну да, да, там вставлялось МД, а случайное число и, собственно, просто intно тем не менее вот мы создавали так секции, чтобы всего в таблице получалось 100 млн строк, а, собственной секций было 500 и 1.000. Ну, в принципе, я думаю, этого достаточно для того, чтобы примерно прикинуть, что получится. А, то есть, соответственно, вы можете судить, что в одном случае будет чуть больше кар кортжей в секциях, в другом случае чуть меньше. А, собственно, тут точно также созданы индекс индексы по колонкам, чтобы когда мы делаем запрос, у нас опять же использовался индексны, и мы могли посмотреть э не на то, как у нас эффективно или неэффективно берутся кортежи, а действительно на то, как там выбор идёт. То есть опять же мы получаем, что строки здесь не играют большой роли. Именно всё дело в том, чтобы выбрать партиции правильные. Вот. Ну, тут, конечно, уже не всё так радужно, во-первых, потому что, ну, в тот раз, как вы помните, 366 секций было здесь уже 500 и 1.000. Вот. Да ещё и prepar statement мы использовали. То есть я вот напрямую демонстрирую то, что мы на предыдущих слайдах показали. У нас используется select с prared statйтментом, то есть на этапе планирования ещё неизвестно, да? какую секцию мы выберем. Вот мы не можем знать. И, соответственно, TPS у нас не очень большой, но всё равно видно, что, ну, всё равно почти, ну, ну, в несколько раз быстрее, чем обычная пента, оказывается. Таймпен, собственно, как бы вот вы можете видеть, у нас для Нтайма получилось где-то 8900, а для этого для обычного апенда получилось 2.700 около того. Ну, это на самом деле вот такие результаты на prepare stнк. Вот у меня в блоге как раз был тест, где Nestlop join. На nestop джойне там получше получается выигрыш за счёт того, что мы для нету джойна спланировали runтайм app только один раз. Вот. А дальше его мы очень много раз выполнили. И тут как раз выигрыш за счёт того, что мы сразу выбрали нужную партицию, только только для неё исполнили запрос, он гораздо больше, оказывается, да. Ну, в принципе, это неплохая отправная точка, чтобы дальше смотреть, да. Тут ещё особенность связанная с тем, что даже несмотря на то, что мы один раз как бы спланировали prep statтменement, нам всё равно нужно каждый раз, когда мы его начинаем экзекть, всё равно, по-моему, все партиции залочить, правильно? И вот за счёт этого как бы не на 100% удаётся это преимущество использовать. Опять же, вот мы упёрлись в те механизмы расширяемости, которые мы используем, но уже с помощью поча ядру это можно будет зарешать, да, собственно, мы хотим в нашем дистрибутиве решить эту проблему. Ну, это также будет там, ну, на два порядка будет выигрыш по сравнению с аппенда, с апендом, как должно быть. Ещё раз, вот как раз в стандартном планировании мы не можем использовать таблицы, если мы не знаем, что они существуют. Ну, как раз за счёт конкурентности. Поэтому вынужденная меры, что при начале выполнения мы должны проверить, что план валиден, всё заблокировать. Вот когда мы действительно решим эту проблему, так что лока будет браться только, когда дело дойдёт до этой партиции, вот тогда можно будет с уверенностью сказать, что бенчмарки станут ещё лучше. Вот. Ну, соответственно, второй бенчмарк. Тут уже мы используем 1.000 партиций. И, ну, видно, что ТПС просел, но кардинально ситуация не изменилась. То есть просел, что Run, что обычная пент, но преимущество по-прежнему сохраняется и даже в том же порядке. Вот. Ну и какие мы можем сделать из этого выводы? Ну вот, ну то, что пасман, он у нас даёт достаточно богатую функциональность, а, и высокую производительность по сравнению с теми решениями на базе наследования, которые до него существовали. И, в общем-то, его уже можно брать и просто им пользоваться, да. Вот мы, соответственно, сейчас уже был у нас релиз 1.0. Сейчас, ну, баги потихонечку исправляем. Сейчас уже 1:2 релиз. Вот, собственно, мы поддерживаем его. Ну, на гитхабе всешью, которые нам кидают, мы очень оперативно исправляем. Отдельно хочется сказать про декларативное партицирование патч, который есть на комитфесте. Мы за этим следим. Вот. Но так в хакерсах всё продвигается достаточно медленно. Вот поэтому мы сейчас сосредоточились на Пасманее. Вот когда уже декларативный партишнинг базовый фильтр, ну, базовая версия будет уже закомичена, мы туда потихоньку начнём свои наработки портировать. Вот. Потому что, ну, наработка у нас, как вы видели, уже достаточно много. Вот. И как бы когда декларативное партицирование, оно уже достигнет наши, ну, вот функциональность текущего даже пасмана, это будет, ну, там год 2018 где-нибудь, потому что в десятку уже в лучшем случае войдёт только базовый декларативный синтаксис. Да, не стоит забывать, что к тому моменту мы ещё наверняка что-нибудь придумаем. Ещё, да, ещё что-нибудь придумаем, но мы как за за декларативным синтаксисом следим и думаем даже перенести его к себе в свой форк. Вот, чтобы внутри всё это исполнялось, а, уже пасманом, теми механизмами, про которые мы вам рассказали. Да, и у меня есть время ещё немножечко добавить. Дело в том, что так как мы занимаемся вообще разработками Постгреса, это не единственная фича, которую можно в синергию с Пасманом ввести. Например, Настя Лубенникова создаёт редонли таблицы. И представьте, как можно их соединить вместе с пасманом, что, ну, если у вас реально большой сегментли данных, скажем, процентов 8090, вы берёте и просто помечаете эти таблицы как донли, по ним отключается вакуум, по ним отключается всё, что не нужно, то есть производительность реально становится ещё выше, и дополнительно вы защищаетесь от ненужных, ну, потенциально инсертов. То есть, используя вот эти все сопряжения фич, мы можем получить ещё более мощные. Да, у нас ещё есть бинарная миграция таблиц между серверами. То есть можно взять, ну, как таблицу, можно дампомрестором перезагрузить, но это сравнительно долго, потому что там копия вначале сделается, потом индексы все будут строиться, а то, что Настя сделала, это можно просто вот бинарные файлы перенести на другой сервер, там их подцепить. Вот. И таблица будет работать намного быстрее. И таким образом, например, можно взять какую-нибудь архивную таблицу, очень быстро вынести на другой сервер и подключить через FDВ. Да. И ещё одна фича, которую я забыл упомянуть, это то, что всё это дело транзакционное. У нас изначально первая такая топорная модель, чтобы proof of concept была, что использовал Sharped Memory. Но теперь у нас во-первых кэш по образу и подобию того, который используется в подкресе, то есть там первый бэкэнд идёт кэшированию. А во-вторых, чтобы реализовать всё это дело правильно, Саша предположил, что логичнее всего подключаться напрямую к тому кэшу, которое есть в подгресе. То есть там есть хуки, мы берём, создаём свой собственный хук, который когда у нас инвалидируется. Ну, в общем, если не вдаваться в детали, то просто всё транзакционно. Вы можете взять, начать транзакцию, распроцировать таблицу, откатиться, у вас снова будет всё как будет, да, и всё, всё должно работать вообще. Байдизайн, ну, не работает. Ну, давайте теперь вопросы, если они есть. Надеюсь, что они есть. Да, пожалуйста, давайте в микрофон, чтобы раз-два. А вы говорили про то, что у вас секции не должны пересекаться по условию. А вот как вынос тогда в архив будет логов, например,ходить? А, ну просто отцепляете одну секцию, подцепляете другую. Ну, то есть надо будет обязательно отключать. Ну да, нужно отключить её на этом сервере, а на другом подключить. А, а и ещё вопрос. Вот, например, если индексы создавать будем, они будут автоматически применяться на партиции? Да. Ну, вы в самом начале создаёте индексы на родителей после того, как вы если новые, если новые Нет, вот это мы пока не реализовали, но в принципе нет никакой технической невозможности это сделать. То есть новые нужно по всем партиям создать. У нас, в принципе, втодулист это есть, да. Но зато как бы фича в том, что вы можете сделать индексы только на некоторых партиях, которые вам нужны. У меня на самом деле был почти тот же вопрос. Foreign K. Их можно делать на родитель, ну, то есть ссылающиеся на распротицированные таблицы. Ну, на самом деле, наоборот, идея была сделать на главную таблицу, чтобы проверялся для всех. Возможно, что не совсем понял. То есть нет, то есть вы делаете for делать fork на, грубо говоря, на все партицы. Ну то есть вы ссылаетесь именно на партицированную таблицу. Нет, пока что это невозможно. И причина на самом деле здесь одна, она фундаментальная - это отсутствие глобальных индексов, которые покрывали бы таблицы. Не, ну то есть на самом деле есть это как бы немного разные вещи. То есть есть 4NK, насколько я помню, 4NK в Посгресе может даже без индексов. А нет, не, он требует уникального индекса. Да, не я я е не с чем соврал. Ну, в общем, короче говоря, тут мы на самом деле упёрлись в то, что мы опять же из экстеншена это вряд ли сможем сделать, да? А, во-вторых, глобальные индексы. Ну, над глобальными индексами - это отдельная тема, мы над ними думаем. Вот. Но глобальные индексы, они всё-таки должны, наверное, сильно отличаться от тех индексов, которые в Постгресе есть. В частности, мне кажется, они должны версионироваться отдельно, а не вместе с хипом, потому что хипов получается много. Коллеги, у нас, к сожалению, время подошло к концу, но неумолимо идёт вперёд, поэтому давайте поблагодарим ребят за то, что выступили, поделились знаниями. Спасибо. Спасибо."
}