{
  "video_id": "w4dLPxa_nK4",
  "channel": "HighLoadChannel",
  "title": "Эволюция Go: как (не) изменилась наша реальность / Дмитрий Матреничев (Siderolabs)",
  "views": 754,
  "duration": 1862,
  "published": "2024-10-29T03:08:44-07:00",
  "text": "сейчас Я на сцену приглашу главу программного комитета конференции гон конв Даниила Подольского Здравствуйте коллеги я не могу упустить возможность сказать пару слов Простите меня Я приветствую вас на четвёртой Go и второй в рамках Хада объединился с м в пост тяжелые постковидные времена мы выживали как могли И это не случайно Что именно с халом Я лично глубоко убеждён что Современный передний край современного Хайда проходится там где применяется го Ну конечно выжать из приложения на го топовую производительность может быть довольно трудно может бытье бизнесе приложение всё-таки язык у нас ориентирован на решение технологических задач но язык развивается появляются новые инструменты адаптируются старые подходы А мы растём растёт наш язык растёт гон сообщество В том числе в России а и Ну что я могу сказать вперёд к звёздам я приглашаю на сцену Дмитрия маничева с докладом о путя развития Всем привет коллеги я очень рад вас сегодня здесь всех видеть особенно в такой ране Я знаю что большинство из нас не любит так рано просыпаться поэтому я постараюсь не сильно вас бодрить но одновременно не дать вам заснуть в далёком 2018 году БФ Патрик приезжал на первый гон ша и открывал он доклад с такой фразой недавно У меня родился сын Я помню что такое сон Сон это было хорошо Ирония жизни состоит в том что полгода назад У меня тоже родился сын но я не буду рассказывать вам о том что сон это было хорошо но я точно скажу Вам одну вещь жизнь была как-то раньше попроще возможно в этом и состоит главная эволюционная часть нашей жизни эволюция остановимся на этом термине чуть поподробнее биологи Или те кто связаны с биологией в зале пожалуйста Не судите строго а отсутствие развития ведёт к стагнации и к смерти вида хаотичное развитие ведёт к вымиранию конкретного индивида Ну простейший пример хаотичного развития это мутации клеток превращения в раковые клетки отсюда получаем что задача эволюционных изменений - это Улучшение качества жизни вида решение конкретных проблем далеко не всегда это получается но природа в отличие от нас может себе позволить такие вещи за счёт очень большой дистанции в несколько миллионов сотен и миллиардов лет неудачи будут отфильтровать при этом идеальны приме это когда изменения открывает дорогу новым изменениям в противном случае мы получаем Тупиковый вид эволюции стагнацию смерть эволюция языков программирования подчиняется ровно тем же правилам изменения должны решать вполне конкретную боль с которой сталкиваются разработчики которые пишут на этом языке программирования при этом изменения должны работать в сумме с прошлыми и будущими изменениями минимально изменений позволяет эволюционировать поэтапно собирая фидбек от каждой конкретно внедренной фичи ни раз ини два к нам приходит на ум что можно внедрить большое изменение которое решит сразу ряд больших проблем и кажется что именно это и стоит сделать Ну как же мы сейчас возьмём всё решим зараз но такие изменения масу повод которые далеко не очевидны с первого взгляда И самое главное не пытайтесь делать из языка химеру не стоит внедрять в язык фичи которые там не работают которые не будут работать в сумме с другими вещами которые уже внедрены в язык как бы крутые эти фичи которые вы пытаетесь внедрить не были в теории или на практике в других языках не выглядели Что приводит нас к го одному из самых консервативных языков Новой волны в основу языка легли конструкции и принципы которые опробованы в сином семействе те из вас Кто изучал го немного поподробнее знают что он спл влияние Арона и лимба А вот те из вас Кто пришли из семейства будут скорее разочарованы но нет в мире совершенства основа языка его инноваций высту сочетание каналов и рутин каждой из этих вещей в том или ином виде уже встречалось в других языках но вот комбинация и о качестве основы оно в го встретилось пермы а начнём мы с дженериков главное событие 2022 года сами дженерики начали планироваться задолго до Лиза в 2012 году прик реализации смогли лишь в 2021 так как прошли несколько итераций всё время предлагались различные варианты Но каждый из них не подходил сохран привычный синтаксис языка с некоторыми допущения поэтому они не выглядит как синтаксическая настройка соответствует духу языка простой ход для пользователей языка и много интересных вещей и много специфичной скажем так внутрянки под капотом компилятора ран тайма Ну и главное мы можем наконец писать наши собственные контейнеры шли ш Map э вектора списки и любимая тема многопоточные версии каждой из этих коллекций приведу простой пример вот как мы раньше писали поиск строки в слайс строк Ну ничего сложного буквально там 5-10 секунд там посмотреть а вот так мы пишем их теперь при этом эта функция подходит для любого сравниваемое типа вся магия ну скажем так условная скрыта в квадратных скобочках и небольшое количество синтаксического мусора в итоге среди новых вещей У нас два идентификатора небольшое расширение интерфейсов и собственно эти квадратные скобки при этом у нас полное отсутствия магии те из вас кто работали с двой знают как дженерики реализованы там и особенности скажем так внутрянки этих дженериков при работе с Java приложениями в Go любой дженерик в конечном счёте - это обычный тип самый традиционный или функция со всеми оптимизация которые предоставляет шный компилятор для пользователя generic функции и коллекции для них вообще минимальный порог для входа в большинстве случаев это работа не отличается от работы с обычными функциями и это позволяет новичкам сравнительно с очень ранних этапов начать использовать дженерики при этом даже не разбираясь в том как это должно или устроено внутри простой пример опять же берём функцию с инстан её со слайм и прис вполне обычной функци и Даше вызываем сонно на последних строчках видно ищем двойку нашли двойку ищем пятёрку не нашли ибо там её нет Обратите внимание что мы никакие дополнительные вещи здесь кроме собственно говоря квадратных скобок с инстанция не используем все остальные сигнатуры привычные опытному и даже не очень опытному разработчику И теперь у нас есть такие крутые вещи как высокопроизводительные коллекции рекомендую на ги посмотреть то раньше мы все бы слышали Том сво вам это не нужно Пользуйтесь тем что вам предоставили ребята из стандартной библиотеки в виде слайсов и Map больше такой аргумент не работает различные функции и хелперы о которых я расскажу чуть позже а ещё нас ждут итераторы и скорее всего мы скоро достигнем уровня Java 1.8 поговорим про лёгкое вот есть такая замечательная функциям вобще нуж функция нужна ну как бы организует встроенную очистку памяти слайса и мапы логика подсказывает что мы всё это сами можем реализовать но в крайнем случае написать пер на тех же самых дженерика обратимся к примеру вот я дам немножко времени но здесь ничего сложного концептуально нету создали мапу присвоили not Number в качестве ключа дальше пробежались по всем значениям и вывели итоговую длину мапы беглый взгляд подсказывает что вывод длины мапы должен быть равен нулю Однако интуиция нас здесь подводит вывод будет равен единице и тут последует большая терада научная о том как это должно работать но я попробую сохранить её в одну фразу а именно not Number не равен not Number почему это так работает в коллекциях и в вообще в любых практических языках программирования есть отличная статья у раса Кокса а короткая версия в противном случае если мы так делать не будем мы получаем увеличение времени поиска по мапе в том числе до квадратичного и увеличение объёмов в итоге мы имеем маленькую функцию которая умеет обрабатывать любые варианты данных помещённых в мап а для пущего универсальности унификации она умеет е и очищать слайсы примм простой вызов ранта функции которая уже была в компиляторе и которая была просто скрыта от внешних взглядов используем новую логику и получаем ожидаемый результат в виде длиный мапы которая будет равны нулю наша любимая за 10 лет Я практически уверен Каждый из нас написал в том или ином виде эту функцию как минимум один раз те из вас Кто этого не сделали ни разу я прям Завидую вам что вы ни разу мин Макса в го не написали Почему не дженерики спросят погрузившись в эти же самые дженерики А смысл в том что наша функция мин и наша функция Макс принимает статически известное число аргументов от единицы до бесконечности это важно потому что компилятор может создать максимально оптимизированную версию кода в большинстве случаев произойдёт ещё и встраивание то есть ваша функция она прямо окажется в теле вызываемого и это ещё более ускорит приложение бонусом служит корректная обработка Нан в любой ситуации аналогичный код зависел бы от порядка условий простой пример различных вариантах Обратите внимание То есть если мы как бы используем обычные цифры у нас Нан если он чувствует в списке аргументов бесконечность Ну понятно В общем максимум всегда будет бесконечность А вот если у нас сравнение по Бене по максимуму между бесконечностью то мы всё равно получим Нан это для мин и Макс абсолютно одинаковое поведение вы всегда получите NAN поговорим про различные утилиты Вот пример копирования слайсов в его различных вариантах обращаю внимание что в качестве основы мы берём слайс нулевой длины и слайс New напомню что слайс нулевой длины не равен New Ну собственно говоря три различных варианта для каждого вариантов слайсов получаем вот такой вот вывод который далеко не не так интуитив как хотелось бы для тех кто не так часто работает со слайсами большинство разработчиков Скорее всего в этот момент полезут в Google разбираться почему это работает так а вот так мы копируем сй начиная с go12 вывод вполне соответствует нашим ожиданиям ставка вальс Это пример и с Гош навики Скажу честно я этот код с ходу вспомнить не смогу он обладает при этом рядом минусов по производительности ибо только для вставки одного элементов он использует две локации А вот это код примера производительной Ставки Не надо его читать пожалуйста тут его много и он далеко не весь приведено просто для понимания уровня проблемы а вот так выглядит наша вставка начиная с go12 оно по сути говоря реализует всё Полотно с прошлого слайда но под капотом и работает для любых типов А теперь поговорим про необычное Вот пример функции поиска пустого значения в слайс на первый взгляд Выглядит вполне рабочий Ну что В общем пробега ищем конкретный элемент сравниваем сним пробуем скомпилировать и компилятор выдаёт нам ошибку и оказывается дальше с нами работать а всё просто ни нельзя сравнивать вообще ни с чем хорошо Давайте попробуем использовать comp в конечном итоге он и был предназначен для того чтобы сравнивать с пустыми значениями для того чтобы эмулировать пустое значение Мы в самом начале создаём instance нашего типа переданного и с красноречивым названием Zero и пытаемся сравнить его со всеми элементами и такой код даже будет работать но к сожалению далеко не для всех типов попробуем взять относительно простую структуру с двумя полями и провести эксперимент на ней Ну то есть у нас здесь ничего сложного нет один ИТ один другой слай интов и компилятор опять нам говорит что мы не понимаем основу языка и прекращает компилирование отсюда и проблематика нужен идентификатор который позволяет сравнивать любой тип с пустым его вариантом тот факт что это не ключевое слово помогает нам поддерживать обратную совместимость Наш новый Zero работает как внутри genic функций так и внутри обычных отсюда следует маленькая необходимость наложить некоторые ограничения чтобы люди не задавались вопросом сравнивать например тот же ин с нум или с вроде Вполне себе Неплохая идея ничего концептуально сложного достаточно минимальные изменение звучит как идеальное изменение и мы приходим к лучшей части Open сообщества бесконечные дебаты и по итогу предложивший его раскос отказывается и закрывает предложение а что же пошло не так ведь выглядело же всё хорошо предложение даже успели принять а потом как всегда начались проблемы как субъективные так и вполне объективные вообще славится своей конечностью и простотой А это изменение вносит некоторую сумятицу более того разработчики языка три ключевых разработчика Роберт меер и ра Кокс предложили три различных варианта реализации такого функционала и договориться между собой они не смогли но а раз изменение не подходит его отклоняют и на этом обсуждение заканчивается поговорим про то что делает нашу жизнь лучше Вот простой пример кода который в том или ином виде писали или видели практически все Как вы думаете что он выведет я дам 15-20 секунд на подумать можно не отвечать просто в уме сделать Но те кто из вас много проходили со бесов скорее всего ожидали вот такой вывод те кто из вас кто работает с го недавно скорее спрашивает что за фигня происходит захват переменной посылки и те кто работают языком давно уже привыкли к такому мы уже как бы человек вообще существо адаптивное мы к чему угодно привыкаем но вот новичков это каждый раз вызывает ступор при этом не только среди новичков сам рас Кокс признаёт что допускал эту ошибку много раз хотя и говорил при внедрении в самом начале цикло фор что это будет ловиться линтер это будут ловиться программистами и такую ошибку вообще допускать По большей части не будет как показала практика даже он много раз эту ошибку за годы работы над компилятором го умудрился допустить при этом эта проблема приводит к очень неприятным вещам в критическом по на слайде баг внутри сервиса LP который затрагивал выпуск тлс сертификатов А значит время меняться начиная с го 1222 жизнь переменной будет привязана к каждой конкретной итерации меньше волнений больше строк кода которые не вызывают нужный стресс в процессе написания Особенно это критично Когда вы мутирует однопоточный код в многопоточный вот тогда это прямо становится очень-очень важно и это почти бесплатно по производительности в 99% случаев тот же код который э у вас был в самом начале произведёт тот же код на бинарном виде при этом Мы помним про код который был написан до го 1222 поэтому старые проекты продолжат работать со старым поведением если для них это критично и вот начиная с го1 22 мы уже получаем вполне ожидаемый вывод поговорим о фундаменте в прошлом примере мы фактически ломаем обратную совместимость Да Однажды Но где Однажды там и дважды И вообще хорошее Повтори поэтому что если придётся снова Как поддерживать старый код но не становиться пленником ошибок прошлого для этого у нас теперь есть две вещи Первое - это запрос обратной совместимости как на уровне файла так и с помощью переменных окружений во время запуска нашего приложения например на слайде приведён изменённый изменённое поведение Pic New начиная с Go 1221 которое будет выкидывать ошибку за дефайн Но если вы попросите то он продолжит вам возвращать в recover с помощью кружение и восходящая совместимость которая даёт возможность внедрения изменений а для пользователя выбор семантики компилятора и уровня языка остаётся на файле или на проекте бонусом теперь шный компилятор за вас скачает to Chain начиная с версии Go 1221 если у вас гомо например го2 или го 23 он сам скачает и ском с нужной версией выбор идт при этом стабильно Только вверх поэтому шный компилятор двадцать первой версии увидев Go Mode 120 не скачает двадцатую версию вот такой гот файл даст старое поведение для циклов А вот такой гот файл даст новое поведение для циклов Ну и напоследок поговорим про светлое завтра Вот так мы пишем обычные циклы сейчас ничего сложного а вот так их можно будет писать начиная с го 1222 и опять же возникает тот же самый вопрос зачем вы усложняет язык ненужными конструкциями ответ на него очень простой унификация Вот пример предыдущего цикла во всех его многочисленных вариантах те из вас Кто из увидели небольшие отличие большие Молодцы но в целом когда ты вечером сидишь уставший ревью ешь последний пир всё это выглядит абсолютно одинаково с итератора ситуация чуть лучше их хотят буквально все дженериками их хотеть начали их все в два раза больше Потому что если раньше было отмаз нет у вас кастомных коллекций поэтому вам итераторы не нужны то больше такой отмаз Нет при этом существующие языковые конструкции не позволяют решить эту проблему а какие варианты но можно попробовать свай Но вот для однократных коллекций это будет достаточно неприятно по производительности и точно неприятно по памяти Можно попробовать использовать Это для бесконечных итераторов но у нас память не бесконечная поэтому тут слайсы тоже не подходят Хорошо давайте возьмём каналы и вроде бы всё работает и даже логику Можем написать но внезапно оказывается что мы внедряем этот код на продакшн и всё становится резко медленно каналы не предназначены для однопоточный способ реорганизации работы данных внутри грудины и эти затраты по производительности на больших объёмах данных становятся резко критичны просадка по производительности в среднем от пти до 15 раз нуно у нас есть ещё паттерн с методом Next который так или иначе видели все кто работали с библиотекой SQL как пользователи так и внедрен те кто адаптеры для них писали но вот плохо он компо неко друг на друга повесить и самое противное что без рефлексии мы не можем использовать как итератор для мапа потому что мапа итерируемый и чёрной магии приме вот функция кото и возвращает значение для каждого элемента если у вас сейчас вот такое лицо не пугайтесь это нормально мы попробуем пройти каждый шаг отдельно Первое - это собственно сигнатуру нашей функции которая принимает слайс и возвращает функцию которая в свою очередь принимает другую функцию и возвращает булевое значение сбитом тут как нельзя кстати внутри мы просто возвращаем функцию которая будет дёргать Range который мы вызываем снаружи сама функция вызывает функцию е переданную и уже пробрасывается значение наверх в тело рейджа наше использование обратной трасс выглядит вот так фактически го за нас трансформирует всю эту конструкцию скобками в Вполне себе в выпрямленный код всё очень просто каждый раз когда ну в самом начале выполняется возвращает функцию и Range начинает эту функцию дёргать внутри функции вызывается Y который уже передаёт управление нам в цикл Ну и собственно говоря внутри цикла мы вызываем Print для каждого элемента получаем ожидаемый вывод Однако есть ряд открытых вопросов в которых Вы можете поучаствовать прямо сейчас некоторые из них синтаксически другие вполне практически реальные из практических это то как быть с тем что цикл что код внутри итератора может не проверять таким образом может получиться бесконечно исполнение бесконечный цикл и всё это зависнет ну как бы ваш код просто будет без конца в одном месте крутиться другой вариант Что делать с внутри дефра Что делать с паника как внутри итератора так и внутри тело цикла использовать ли чение для всех указание всех этих значений или можно как в традиционных наших коллекциях типа свайпов использовать только то что нам нужно и это далеко не все вопросы которые в текущий момент сталкиваются разработчики при внедрении этого функционала в заключении я бы сказал следующее правильная эволюция языка в нашем случае это хорошо несмотря на некое усложнение нам жизнь наши дженерики наши утилиты нашими Макс и клир функции она избегает спорных вещей Z Несмотря на все его преимущества вызвал конфликт в среди разработчиков как самого компилятора так и просто Гош разработчиков она также избегает противоречия прошлому языка Но при этом старается исправлять ошибки поведения циклов и эта эволюция продолжается и сейчас Спасибо вам большое за внимание Большое спасибо за доклад Есть ли вопросы для того чтобы задать вопрос Пожалуйста поднимите руку к вам подойдут с микрофоном и вы сможете задать в микрофон ваш вопрос для того чтобы для него ответили также для тех кто смотрит нашу трансляцию онлайн есть чат доклада чат зала в него можно зайти по QR коду вот он на экране и задать вопрос в чат а я его зачитаю соответственно Есть ли вопросы а можно вернуться на слайд Где в первые показан новый Range Range 100 Да момент вот если сравнить то что здесь и и те множество вариантов которые ты показывал посыл был такой что там много разных но они все понятны Глядя на текущий вариант Откуда ренж будет от нуля до 99 от нуля до 100 от одного до открытая закрыта То есть до 99 это переносится на вот так вот эквивалентная запись читайте документацию запоминайте как оно будет и так далее понял спасибо У меня просто новость я удивился очень на самом деле это одна из самых не конфликтных вещей которая была в предложено практически всё голосование было Вот пальцами вверх проставлено и все говорили что Да больше вопросов про литератора у людей возникало про их дизайн про их функциональность А про Рен все сказали да хотим уже сейчас можно ли хорошо Есть ли ещё вопросы у меня есть вопрос изначально го это был достаточно простой для входа язык не кажется ли тебе что данные изменения говорят нам о том что язык и движется в сло в сложном направлении в увеличении сложности входа в язык и не превратится ли он во что-то совершенно другое Да не будет ли у нас питона 3 А Это хороший вопрос э я здесь конен мыслить что усложнение языка оно всё равно неизбежно это просто вопрос контролируемое этого процесса То есть это можно бесконтрольно запустить А когда у вас язык просто обрастает вещами каждый год просто потому что хочется или вы пытаетесь это сделать чтобы оно ну как-то умеренно росло в свои сложности Но вот совсем избежать этой сложности не получится другой вопрос что облегчить уровень входа для новичков можно и вот собственно говоря такой Темп изменений и такие изменения для этого предназначены что у вас не вертикальная горка для новичков которые приходят смотрят на язык и говорят так Я пожалуй пойду пощу другую работу а всё-таки более-менее потихоньку поднимаются имне обязательно знать про дженерики в самом начале они уже могут их использовать Но вот детали реализации или как оно должно компоновать как вообще писать код на дженерика знать обычного пользователю далеко не обязательно супер спасибо Есть ли ещё вопросы в за нет Хорошо спасибо тебе большое за доклад Это было очень круто Давай я пож тебе руку давай выберем с тобой вопрос который тебе понравился У нас есть подарки за этот вопрос да да Для того чтобы получить подарок можно задавать вопрос Не зря я задаю вопросы а и не уходи пожалуйста со сцены После этого мы также хотим подарить подарок и тебе какой вопрос тебе понравился Ну тут очень сложный выбор Поэтому вот человек в зелёным Ну прям лучше всех отлично Спасибо большое человек в зелёным Не уходите пожалуйста Мы хотим Подарить вам подарок от наших спонсоров от Газпрома а тебя мы тоже Хотим поблагодарить за доклад И тебе тоже Мы хотим подарить подарок от онти Приходи к нам ещё пожалуйста рассказывай было очень интересно спасибо вам большое дополнительные вопросы можно задать в дискуссионной зоне N"
}