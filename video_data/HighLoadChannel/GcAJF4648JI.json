{
  "video_id": "GcAJF4648JI",
  "channel": "HighLoadChannel",
  "title": "Алгоритмы быстрой обработки HTTP-строк / Александр Крижановский (Tempesta Technologies)",
  "views": 2643,
  "duration": 2966,
  "published": "2020-02-26T12:00:42-08:00",
  "text": "всем доброе утро уважаемые си хакера спасибо что пришли спасибо за пиццу представление давайте представлюсь кто я что мы делаем вообще мы занимаемся разработкой софта на заказ специализируемся в сложных областях те которые связаны с высокой производительностью по которым мы очень гордимся это вов пассив текнолоджис мы сделали первые два собственно наша команда написал первые два этого проекта который было моментов гад мере финансовом году мы они из главных контрибьютором мария тебе здесь можно посмотреть вот это сайт сайт и мария тебе fondation мы здесь рядом с другим уважаемым компаниями и кроме нашего consult га мы разрабатываем tempesta fw а при конечно delivery контроль о котором сегодня пойдет речь собственно когда мы говорим об application delivery контроль яхта это по сути hd poxy которые делают еще дополнительный раза функционал ну в нашем случае который нас будет сегодня совать это безопасность это ситуаций adidas так и вы оба так tempesta vw в side of the peace так linux поэтому сегодняшний код который бы рассматривать он работает в ядре linux в конце я скажу что об ограничении которые здесь возникают ну и благодаря тому что у нас есть ряд оптимизации того что мы в игре нету копирование почти нету соответственно мы очень быстро это 18 миллионов запросов в секунду на самом дешевом железе если сравнить с другими проектами то в 3 раза быстрее engine.exe на топовые нагрузки и в принципе так же быстро как если сравнивать с киану байпаса патч это foxy as the который использовали db проект написан 15 и кей и на небольшом количестве я не мы показываем схожую производительность собственно мы начали работать над этим проектом как с когда мы начали работать над проектом пассив техно уже с которым я вначале говорил и собственного of the web application firewall это тоже htp прокси которые занимаются очень глубоким анализом аж типе трафика на предмет уязвимы си а так неуязвимости а так интересует тоже в патоке de dos атаки и когда мы начали работу над проектом собственно как и большинство таких проектов он базис на каком-то уже популярном опасаться тебе фокси и мы тогда поняли что аж тебе фокси вообще говоря это могут быть очень хорошие продукты которые отлично доставляют контент каши тут делать много разных всяких штуковин с этим контентом модифицируют его но почти никто из них не предназначался для массивной ситуации трафика именно перемолоть очень много трафика и отфильтровать большую часть этого трафика из предположений что будет много за намеренного трафиком соответственно мы начали проект мы подумали о том что вот есть файл всего уровней почему бы не положить эту идею и продолжить стек протоколов аппетит и дальше https и встроиться в качестве файлового вот переписок но собственно и получился гибрид наш тебя oxidative его то что мы и есть индекс будет очень много используется в слайдах но хочу хочу сказать что это в основном потому что индекс это очень простое софт который в общем то не понятен и много его знают и собственно моего используем как референс давайте посмотрим наш типе запрос во первых у нас может быть очень большой йогой здесь я на сайте выделил жирным мясом это наши разделители которые нам важны в момент разбора htp например вот здесь у нас есть еще дополнительные разделители это , . запятой тоже вообще говоря нам нужно их носить и здесь по его что бросается в глаза в тех что здесь бывают большие сроки по несколько килобайт 2 то что у нас разные за делителем наш теперь два тоже нужно сказать собственно я не сделал аж теперь сайт по htp 2 продаж до сочи тяжело там микс строк и бинарных данных тяжело его показать и аж теперь два вообще говоря это не хотя он папе famas вообще в общем того чтобы запросам работой быстро но не по то чтобы вас на сервере все было быстро то есть он не по экономию сепию во-первых он используют динамическую российскую таблицу они динамика таблица заполняется то есть первый запрос когда к вам приходят клиенты он не не оптимизирующие его не туфта в таблице ответственного вы вы должны раз повысить ну соответственно это сочи видоса следующее что у нас есть хоффман кодировка и хоффмана чудовищно чудовищно тяжело за погоняют почти как бы сама по себе штука просто но сделать его быстро очень тяжелое дело в том что а хоффман кодировка пересекает границу байт и соответственно мы не можем пользоваться векторами нарушениями и соответствие мы должны идти по бать мы не можем прям выжигать данные по 32 и по 16 байт далее все коды они опциональную тоже степи 2 как бы в нормальном случае это бен анапа такого но вообще говоря вы все она должны посетить ex там такие же текстовые имена заголовков данные и так далее то есть вы все она должны работать с текстом следующее что cookies and рефери gio goi могут быть по-прежнему очень большие это большой текст выдал сначала снимаете хоффман потом отдаете в обычно htp попасться такой же как в ваш т1 и последнее что cookies не рекомендуется сжимать потому что секрет соседей то ее нельзя нельзя давать информацию о такой чему он размере их соответственно большинство вообще говоря все по степи север они сначала все декодирует htp два и потом отдают эти строки of passage тебя 1к том же пользоваться и но и обычно htp один в чем проблема с постинга масштабе 1 это первое что мы будем сегодня смотреть это вообще говоря доклад из двух частей состоит первого этапа то как программировать быстрый совет машины второй поток как быстро обрабатывать непосредственно последовательные последовательный строки ну и о том что я если у нас мы хотим делать фильтр то мы должны затачиваются на клевые случае чтобы наш кривой сути тоже работаем быстро не только те случаи которые большинство с большинстве встречаются соответствие давайте посмотрим на дженкс профиль отключаем access wog чтобы у нас это mozilla файла система и получаем кофе что даже на простом худи когда у нас запрашиваются обычное индекса страничка нас подниматься порцию в топе интересно посмотреть что это так называемый flat a file что наиболее горячая . она не намного более тяжелая чем следующие ну и дальше то есть и очень очень говна спускается профиль это значит что если мы например оптимизируем первую свою первую функцию в два раза мы не получим драматического эффекта соответственно то почему мы не стали оптимизировать текущий проект и мы стали делать новый новый pencott уберет вообще полностью все все весь в этот хвост профилем давайте посмотрим все как кодируются обычные htp сроки обычно это мы у нас есть цикл который бежит по строке это цикл вау у нас есть и никто перемен состояния есть переменная текущих данных вот мы входим в цикл смотрим текущее состояние и дальше мы прыгаем нам пришедший данным на в dance чином символ by здесь мы где у меня как-то логику дальше мы должны перейти на второе состояние здесь мы переходим в конец свеча то есть мы делаем уже второй jump относительно начала нашего кода переходим на начало вас с сидом следующий символ и снова идем ищем какое состояние вот при том что мы могли вот уже когда мы присвоили переменной state 2 мы вот могли просто перейти на следующую функцию вместо этого мы сделали еще jump наверх еще спустились получать вот мы нарезаем так такие круги по нашему коду вместо того чтобы просто взять и спуститься вниз соответственно нормальный пальцы вы так не делают еще нужно сказать несколько слов о посажен x и вообще как бы о том окружении в котором он живет во первых индекс работать обычным соки на мои пиарит и значит что данный которых выступают вам надо то они копируются в use space у вас есть большой чанг данных потом вы уже ищите то что вам нужно соответственно же никс поступать следующим образом первое что он делает это сканирует строку он на на токены ищет-ищет первый победный токен вот у нас мы такие земли сходили на конец запрос в данном случае get и теперь мы по размеру токи на котором мы имеем мы уже запускаем switch то есть получается 2 походной алгоритм сначала ищем длину потом уже проверяем что на собственно пришло второе то что дед у нас в данном случае он всегда будет у нас в одном очанки данных мы работаем с сего копия это значит что нам даны могут приходить совершенно произвольным возьмем по одному байту по 1000 байт как угодно соответственно мы должны немного по-другому жить давайте посмотрим что как вообще происходит как работает switch все слева у нас типичный пример enum-а начинаем с нуля потом последовательные метки вот здесь 26 constant потом у нас есть некоторый код который обрабатывает удается все и собственно наш код который сворачивает компилятор первое что мы делаем это сравниваем со сравнимым риге регистром на наш переменный state и дальше самое интересное собственно это мы представляем все наши метки виде не последовал последовательно ван массива указателей по восемь байт и на этой инструкции мы прыгаем по смещению в этом в этом массиве то есть это двойное разыменования указателя и здесь уже у нас в самом конце непосредственное кот у котов на которую мы прыгнули из этой таблицы здесь мы обратим внимание что получается двойное возьми нового не и памяти у нас пришли некоторые данные если наши данные секретное там и по нашим данным который происходит пришли по байтам берем адрес в массиве и прыгаем по этому указателю это ничто иное как кейс для спектра таки который был а вот начать 1 прошлого года в конце я немного расскажу под эту атаку и по ее эффект но сейчас нам важно знать что что при том что здесь двойной возьмем не указатель на самом деле в жизни она здесь еще несколько хуже устроена чем вот сейчас на сайте показано следующий кейс это switch уже с непоследовательными константами а с какими-то ну вот позвал произвольными случайными а тот же самый код но теперь же сцене можно скомпилировать такой большой массив и использовать эти константы в качестве индекса массива и он переходит на бинарный поиск вот мы видим последовательное сравнение прыжок на адрес и продолжение сравнения здесь у нас бинарный поиск по нашему коду идет следующее давайте посмотрим вообще что из себя представляет стоит машина дженкса во-первых в ней 9 килобайт кода это меньше чем кошка в уровня на машине в три в три раза а следующее что посажены ксо по сути это некоторые таки не затар то есть он ничего не делает с непосредственно со значениями заголовков и их именами он просто складывает токены htp заголовков хэшей потом там упал кому нужен какой заголовок он сам кого ковыряться в этом хэши мы же должны и соображений security делать любую верификацию входя и входящих данных я на боль позевайте покажу кейс когда это действительно нужно соответственно у нас намного более мощная state machine у нас уже учатся на порядок из там было 86 нет у нас 520 их все время становится больше то есть уже бог еще одна если мы по гомер на switch эту свечку бы в 10 раз больше следующее что у нас 1 копию вот вывод и у нас соответственно могут разные чанки пример приходить реже резать наши данные и собственно мы увидим что у нас становится еще по совсем все пох при том что мы фактически убегаем затраты на ввод-вывод мы видим что паз у нас вообще взлетают вверх и это становится одной из самых критичных место в проекте соответственно что можно делать для того чтобы эту ситуацию улучшить первое что мы делаем это то как поступают нормальный генератор и парсов вот один из примеров это ригель мы не используем цикл мы используем прямые переходы по меткам чтобы мы кай codiaeum вот таким образом каждое наше состояние то есть это метка в свече плюс еще это метка языка си с таким же именем и каждый раз когда мы хотим прийти мы либо в свече прыгаем на данную метку либо можем чип напрямую к этому же состояние позиции skoda то есть первый раз мы идем через свич а потом мы уже внутри этого свеча прыгаем сразу на нужную нам метку какой недостаток хочется сразу выделить что здесь у нас в переходе от а когда мы должны прыгнуть нас еще состояния мы сразу должны оценить есть у нас еще доступные данные опять же это изи окопе соответственно вот это тело условия for она у нас дублируется на каждое состояние вместо того чтобы иметь одно условие в коде у нас их ну по часу состояния соответственно 500 500 условий это нездорово совершенно и так получается что ну как бы вот на каждое состояние генерим код это нездорово другой стороны условия нам нужно достаточно близко иметь его кода и поэтому dc тону на другие компиляторы тут же делать оптимизацию его случае больших сайт машин если у вас есть фон с большим свечой внутри то джесси тоже сгенерирует условия фола несколько раз внутри кода то есть но у нас где-то 45 вас видели что в коде повторяется условия следующее что мы делаем мы не хотим вообще делать бинарный поиск либо прыжок по двойному разыменовать указателя и сразу прыгать в ходе как только мы зашли функцию х запрыгнуть на нужную точку джи си это позволяет делать и стандартное расширении у джесси и собственно мы можем вот если у нас есть некоторое метка мы можем просто взять и и имя 10 форм и вот через два написан присвоить адрес этой метки в некоторую переменную session и и потом сделать вот по такому синтаксису прыжок на данный адрес в с точки зрения сэм ли это просто обычный jump все тоже самое но вот как получается побыстрее следующее давайте посмотрим вообще что из этого получается во первых можно на гитхабе посмотреть все which make о которых я рассказываю там есть мика бенчмарки в котором можно посмотреть как это устроено потому что код синтез он намного более большой сложный первое что нам бросается в глаза если мы сравним пасты давайте сравним вообще от объемом данных когда это имеет смысл делать когда не имеет здесь switch стоит машины и прямые переходы по голоду для семьи 27 и и 400 состоянии получается что он для маленького количества состояний кода генератор который делает прямые переходы он может быть даже немного медленнее чем обычный свич больше кода мы сгенерировали но для больших машин мы получаем 2 от ную привез производительность поэтому вот такой подход он лучше работает для большинства машин если эта машина маленькая лучше пользоваться обычным свечам давайте по исследуем как бы что у нас здесь происходит первое что о чем какая происходит это то что у нас большими с prediction да то есть когда мы прыгаем по ходу нами наверно больше всего нас беспокоят это большое количество матчей должно быть больше плащами сидишь на в первом на первом пункте мы видим как а сделан по файлик по branch мисс predictions видим что действительно нам свече на большом на большой вашем состоянии в четыре состояния 400 состоянии мы тратим почти 40 процентов на обработку от этого свеча на прямых переходах у нас основные гай горячей точке в обоих случаях это passing непосредственно строки ногу понимают что пазик строки туда происходит и обработка каждого условия который нас на каждом символе получается следующее что мы посмотрим и вообще как бы удивительные результаты это если мы посмотрим на два вот 2 2 версии для большой стоит машины версия со switch-ем явился по прямым переходом мы увидим что вот в первый ставил в первых строках этого змея стоит машины получается почти 30 килобайт для свеча и почти 50 килобайт для прямых переходов это вообще говоря больше чем кашкая в уровне из акций и казалось бы при таком большом при то что у нас абсолютно мы не помещаемся в конечно нас должно быть очень много кэш промахов для инструкции но нет на самом деле у нас 2 раза меньше кэш промахов и все это потому что кэш работает более оптимально что мы более последовательно работаем с кодом и соответственно мы успеваем из более старших кашель подтянуть данным следующее что мы нашли если мы погорим с вами код на борту мы делаем на разумно предположить с вот мы пишем стать машину мы пишем сначала вот мы повысим метод потом мы по осям йогой потом мы просим степи заголовки но данные по мере их поступления да то есть мы ожидаем что вот как мы идем по данным мы также спускаемся по коды у нас код будет загружаться в кэш процессора последовательно вот сверху сверху вниз на самом деле это совершенно не так и если мы заглянем в землю то увидим удивительные вещи вот слева это то что мои сапогами ли это некоторый наш язык стоит машина которую мы определили мы сначала по оси методы get и post потом мы пасть некоторый вероятный метод а ног и мы бы ожидали что увидеть в начале как раз парсинг get и post а потом уже unlock но на самом деле мы видим все совершенно наоборот get у нас где-то оказывается в середине пост в конце сверху нас наша блоку оказывается ну и соответственно работать не не здорово собственно что здесь происходит ну происходит то что компилятор не понимают о том как нам приходит данные у него есть некое представление фриков прекрасном коде и он рио гаджет код так как он у кунг-фу хочет и соответственно для того чтобы он все-таки код располагал так как мы его написали ровно в том порядке мы должны использовать компиляторами барьер это вот же все это вот такой intrinsic 8 пустышка сэндвич из готового компилятор не будет ничего реален жить поставил оставить такие барьеры по очередь 4 процента улучшения следующее что что приходит в голову данный газ мы компилятор нам как-то не так из полагает данные как нам хотелось бы а давайте мы тогда сделан по файл горит оптимизацию мы заплыву сделаем код запустим на нем which make и потом скормим результат результат профайлинга в компиляции компилятор нам сгенерирует оптимальный код для наших на нагрузке но проблема в том что по falling он не отслеживает он по simpler у юноши наиболее горячие участки кода и он не отслеживать зависимость по времени то есть если у нас йогой наши нагрузка самое большое это будет наше самое горячее место его у нас поднимется в топ функции а то что у нас всегда передвигай находится метод имя метода как бы по фаре упав organized темизация не покажет соответственно не работает такая штука что работает это во-первых гайка найтли макросы которые нам говорят о том что вот вот это кот он более вероятно и вот надо его расположить су дон расположить ближе что здесь происходит когда мы говорим likely мы говорим что вот тело тело под ифом оно должно находиться сразу заботой и тогда у нас при при fetching процессов выберет вот этот код и у нас будет все вроде бы быстро здесь у нас начало нашего парсинга метода есть конец есть мы расположили некоторые барьер и мы не ожидали совершенно вот в этом месте увидеть код за барьером кажется это не но не должно быть такого да мы спасали барьер но что происходит в реальности компилятор видит что здесь у нас кондишен и мы сразу прыгаем на код за барьером и поучаствуй а что код который у нас находится после нашего обманчиво он вообще не достижим для нашего хотпот и соответственно двигает код под вот этой меткой сюда подрыв несмотря на то что мы расположили барьер потому что соблюдать условия горячего кодом соответственно чтобы такого не было джесси предлагает следующие шире не это атрибуты hot & cold для меток и он говорит о том что вот эта метка на горячие следующие холодная и здесь мы действительно соглашаемся с тем что у нас дед наиболее вероятным и оставляем likely для одета сюда у нас под условия понимается обработка йогой а после хочет немножко ниже но весь другой код который нам не важен вот самый низ для наименее вероятных пять машин он остается внизу потому что это метка холодная следующий пункт посмотрим на оптимизации компилятор его что приходит в голову давайте мы их если хотим спасти мы будем использовать не о 2 o 3 должно быть быстрее но на самом деле это не так и мы видим что три иногда меряют хуже код давайте возьмем сейчас давайте мы возьмем мы поймем что очэс училась что происходит что состоит в a3 a3 это нам было некоторых оптимизации если мы их попробуем по отдельности добавить co2 мы получим разные варианты и некоторые нам оптимизации действенно помогают относительно 2 не которые мешают соответственно для нашего конкретного кода мы выбиваем те только оптимизации которые gerade лучший кот оставляем их получаем лучший результат это 820 относительно 838 и в 150 8 что здесь сейчас будет интересовать это как раз зеленым выделенные некоторые опции из огня все оно черное но на вас надеюсь зеленая это так называем of these векторизация насколько понимаю аксёнов чего рассказывать плавта векторизации у нас есть примеры цикла вот самом низу слайда из гайда джесси о том что если у нас есть некоторые переменные массив которым матерью мы можем как бы в данную данный цикл оптимизировать на виктора возложить и вот эти то есть по умолчанию на третьем уровне у нас включается в ты векторизация джесси генерирует векторный код но не всегда он викторе суэца мы можем включить опцию для который показывает вообще что было векторизованное что нет и вот получаем что для нашего биг мак у нас в результате ничего не электризуется но хотсе она генерируется хуже поэтому векторизации работает не всегда иногда она замедляет ход но мы можем всегда посмотреть что свято резеро вася что нет следующее что мы также как делом ними небольшой хак мы не получим ни по всем строки побайтно мы берем вычищаем and in the мы сравниваем сроки мы знаем что если and не выровнен на то он становится более медленный вот мы написали маленький бишма который покажет что не выровнен учатся три раза в два раза медленнее чем выровненный давайте попробуем тогда выравнивать in смотреть о том что выровнены адресанта или нет если выровненный то сравниваем поинту если нет то сравниваем по байтам к сожалению оказывается что такой подход работает хуже более подробное обсуждение почему так происходит может в нашей задаче почитать на в 695 но если коротко мы генерируем больше кода компиляторы работает хуже соответственно но больше кода в работает медленнее хотя никаких там пенальти ничего такого фольги не видно просто код становится хуже почему нам важны сроки вообще зачем мы говорим вот слева это нормальный который если вот вы достаточно привередлива к отелю вот если мы на booking зайдем выбрать отель зададим какие-то виды вот мы получим там больше килобайта йогой engine.exe сплава достаточно массивная мосин массивная стоит машина папа синга по вы его увидели что она сейчас работает не очень быстро и если нам вот кроме того что после распахивай нам нужно еще сделать какую-то аналитику относительно того что есть какая-то инъекция то есть вот вот при том что в воде и вот этот йогой в игре так так же как вот и второй йогой во втором есть инъекция и нам нужно достаточно много поковыряться поиграть даже по понять если там что-то или нет давайте проведем тест возьмем этот йогой скамьям в к натравим на яндекс увидим что posing индекс вообще очень горячий становится есть мы видим на первом слайде на обычном индексом запасе как бакс уже в топе здесь у нас еще горячей становится что специального есть о строках ешьте ты во первых они имеют ваза разделите о чем я говорю в начале во вторых у нас мы мы хотим для всех безопасности более аккуратно проверяешь только что нам приходит нас есть две стандартные функции которые нам помогают посред стс pn который проверяет алфавит доступные символов строки и есть из xmp они работают медленно и вещь как сейчас посмотрим что в них не так что делается в мире джин x это наиболее простой пауз и но он очень он проверяет снова проверяет соответствие все паруса и что и кафе они быстрее едят данные но они более большими джами допускают символы соответственно они могут попустить вам символ который недопустимо по аверсе первый подход так писем из твой инструкция который используется в пика панцире мы сдаем ганджи в в инструкции и к сожалению мы можем либо загрузить 16 сигов либо 8j и если у нас раньше ты всего лишь из одного символа стоит там и вопроса повторяем и как раз из-за вот этого ограничения прикопался не может полностью проверить соответствие все потому что в данном месте vfc бой большее количество данжей загружаем загружаем алфавит в регистр загружаем всякую в регистром исполняемые с акцию на выход папа получая есть matching или нет очень быстро клауд в api 7 мест по 16 байт входных данных а вы x турист по 32 байта соответственно вклад в лучше этот паз и тем что перевели его на в x2 соответственно у нас есть мы проверяем все символы до пробега по таблице аске и все символы больше ста двадцати восьми и берем а раньше между ними простой код работает быстро здесь сравнения двух парсеров не имеет в 1500 это актуально лимит до нас потому что это максимальный размер пакет который нам приходит видим что а вы x2 работает сильно быстрее чем ты копался но на мальте данных медленней потому что вы x более тяжелые инструкции если мы подумал то что взять и использовать стс п но как бы все становится сильно хуже и особенно больших данных то есть липси вообще плохо использовать впал панцире у нас пальцев по тоскующим примерно как эти два но он на майке данных такой же быстро как и попался на больших такой же быстрый как у атф и но при этом он намного более аккуратно в том что он попускает как устроен полоса мы как engine x берем определяем массив байт проверяем входные данные на поэтому массивы это плавок функции здесь мы здесь мы работаем только с короткими сроками используем likely потому что плач беспределен для коротких срок более более болезненны чем di1 их всего соответственно носим этот код наверх и ограничение в 4 из за последние строчки которые нам мы должны достаточно мощные условия написать и если мы будем больше байт обрабатывайте свои будет тяжелее вот будет медленнее в основном цикле обработки мы делим данные если они достаточно длинные едим по 128 байт по 64 по 32 по 16 поможет 128 имеет смысл есть потому что мы параллельно используем несколько каналов процесса несколько планов и используем супер соленость процессу конец функций похож также на начало если у нас меньше 16 white там и по четыре байта съедаем по четыре байта с съедаем так софт это основной алгоритм основной основного тела функции собственно мы представляем таблицу аске вот по данной картинке это 16 строк 8 столбцов и первое что мы делаем это кодируем наш наши сроки в первом регистре и обеим давайте посмотрим что здесь мы кодируем нашу первую строку и второй в то есть вакуум соответственно актуальность его у нас который мы допускаем это так вот здесь это 0 собака п п маленькая здесь мы допускаем два бмп вот это то кто как они как одевается ходил в обратном порядке то есть начинаем с нуля ppv сюжетный сегодня пусть недоступна недопустимой и потом язычки то что допустимо первая строка третья строка следующее что делаем у нас на вход приходит строка пион первый символ из первой строки и адские 2 из 2 строки соответствие мы запускаем если уксусов у которой перемешивает наши на наши строки таблицы закодированные в соответствии с порядком как они встретились в наших входных данных следующее что мы делаем мы хотим также расположить другом регистре наши колонки по аске потом мы пересечём мы получим собственно есть у нас наше досье воли не наш девам то же самое но сейчас поскольку нам колонки это старший четыре бита от байта мы должны сместить первое что сделать это сместится влево сожалению у а вы их съесть смещения только по два байта поэтому мы кроме того что мы делаем смещение байт мы еще должны сделать мы сначала делаем смещение байт потом мы должны выполнить and с нашим маска чтобы очень получить только значимые битым дальше запускаем второй shuffle перемещаем нашу колонку по нужным позициям в данном случае у нас в обоих случаях байт байт входных данных из последней колонке поэтому мы на 1 2 позиция получаем одну и ту же колонку и делаем and и получаем что у нас входные данные допустим потому что у нас результат and a отречение колонки строк не 0 подсчитываем в конце количество нулей собираем это все из вектора в int и возвращаем на выход достаточно просто здесь мы работаем stable царские у нас получаем дешевые следующий следующий фичи что сейчас мы использовать очистки таблицы но на самом деле нам ничто не мешает спрашивайте пользуйся какого фа вид у тебя доступные для отдельных полей в йогой ваш типе запасе юга и ваш тебе заголовки там порядка восьми алфавитов используется для парсинга 1h типе запроса им эти таблицы можем загружать в и тот же код и по глазам алфавитом и сравнивать собственно допустим я прибежал или нет допустимой юзай джен прибежал и нет первый кейс это серов атака с black это мало маловероятные simple его artisan да нет и приложения использовав некоторых не использовать но если у вас не используя за соответствием можете выключить из гянджа сие атака на удивление use widget казалось бы статических и да но вот есть и кейс все атаки в джинсе в easyjet вам приходит некоторый шоу который имеет принципе ненормальные символы для ю завершит соответственно скучаем знак доллара совещаемся атаки последние то чтобы у 16 году на google в йога приехали фигурные скобки : тоже маловероятные все вы готовы мы можем исключить из нашего алфавита последние tsm очень тривиальный код по сути единственное что здесь есть интересного тоже по 32 байта сравниваем строки два массива канве приводим к приводим кейс только одной строки потому что второе это то что мы константы за программе в нашем по озере и соответстви поскольку у нас сравнение знаковым и вычитаем пасу 28 из каждого байта трюк из hackers дизайн и второй трюк мы используем что от перехода когда мы сравниваем меньше допустимого сего можем ли мы приводи кейс для этой строки или нет то есть является ли эта буква или нет момент при виде проверки этого винджа мы можем вместо двух сравнение вот от a до z использовать только одно сравнение переместиться в константу сравнить с и липси с имперской намного более быстрые причем липси мы использовали новый по моему с 18-19 алексею код церкви семьи тоже используется в x-none вторую версию но когда вы их 2 поучать быстрее соответствующим пресса быстрее код мы используем векторы на расширение процессора они не да ну как бы они доступны в ядре но здесь нам интересно сказать следующее вещи что векторное инструкции они обрабатываются в пью модулям процесс это не основной модуль процесс его не основные регис и соответственно регистра достаточно большие до объемные соответственно съесть оптимизации если мы идём и зуд 2 use space и обратно мы не сохраняем контекст наших викторов мы меняем контекст только регистров основного модуля процессора и предполагается что ядро операционной системы не работает с объектом расширением процесса но если нужно работать с эффектами расширением процесса в ядре например и криптограф вы можете это делать вы должны использовать и в пинге генов пью and it's собственном akkas и который сохраняет восстанавливает состоянии моды процесс отвечающего за ари регистры векторные эти ресурсы за сочи медленные сейчас посмотрим на which make но перед этим хочу сказать еще по верх данное расширение есть почему как иногда имеет смысл работы с имбирем они с intrinsic ами джесси это то что джесси генерирует иногда не оптимальный код можно вообще говоря уже все есть ключ но возила по чтобы он нигерии в эту инструкцию но вообще по умолчанию на ее генерируют и проблем если в том что носовых моделях процессорах достаточно значительной пенальти вот перехода кода который использует сена в x а мы должны очищать риге слова состояния на новых процессорах под skyway к это более дешевые пенальти соответственно skylake если мы не используем apple то у нас код становится быстрее нужно это использовать функцию сок если вы работе со своим кодом но как в нашем случае это не интересным следующее что мы должны сохранять понять что у нас есть авто векторизация в процессоре соответственно знать что любой ваш use space код если вы его посмотрите вашем счете у вас там будет векторные операции соответственно у вас вы два потока любые два процесса системе они используют вектор расширения процессором это значит что когда ваш процесс идет в едва я обратно вы не тратите время на сохранение восстановления данного модуля процессора но если вы переключаетесь из use space of другой use space кончать свечу и за спейси то кроме того что мы знаем что там не хочу работают кошельке в уровня январе делается у нас еще эпох работает моды контекст свеча на в пищу бегин энд операция достаточно да лагает и мика биг мак напиваться и дело что в мика бич могу всегда все систематизировано но операцию получается действительно сильно дорогая поэтому новые за спейси переключать контекст долго в ядре у нас нет переключения контекст поэтому нас быстрым и девам сохраняя восстановления верх над процесса только один глаз на достаточно большой патч пакетов следующее что наверно последнее что хочется сказать это в начале я когда мы говорили по switch я упоминал аспектах атаку соответственно если помните мы делали первый вариант свечи таблиц когда у нас последовательно ягинумы есть мы компилируем свечи таблицу массив и идем 2 на 8 новыми указателя прыгающего поэтому массивом это спектр атака есть хорошая статья от гугла как устроен сейчас в нынешней компиляций ахнул компилятор вот уже по сначала 17-го года как собственно двойного изменений указатель работает работает она не очень здорово то есть если у нас раньше был вот такой jump то есть это вот в регистре у нас есть некоторые адрес хранится и мы прыгаем по этому адресу то теперь у нас вместо такого кода у нас вот такой код мы делаем вызов по вызов функции как будто на н1 здесь процесс прыгать на эту метку и здесь мы делаем хак мы как будто возвращаемся из функции которые у нас на самом деле нет но мы переписываем адрес возврата то есть когда мы делаем из аксаков мы на стыке располагаем адрес возврата текущий адрес здесь мы его переписываем нужным содержимым регистра и мы бегом туда куда нам нужно на или один дальше продолжаю но процесса когда работает его префетчер он видит что здесь у нас функция дальше у нас будет пауз будет барьер соответствие все будет медленно он бросает наш при федченко и соответственно у нас мы избавляемся от уязвимости спектр код получаются очень медленные есть еще у нас обсуждения на в паре квесте 15 процентов performance деградации следующая атака которая относить недавно это мель down тоже она специфично вообще говоря только для use space процессов очень болезненно до 30 40 процентов performs деградации связана она с тем что вы вас больше нет оптимизации ленивого тебе вы полностью теряете адресное пространство процесса и и 2 соответственно у вас если для usa space а полезен для okinawa не болезненно несколько ссылок полезных на этом все будем рады вас видеть на нашем герхард вашим задачам звездочкам все всем спасибо александр спасибо огромное я думаю мне надо еще раза три посмотреть доклад чтобы что-то понять то есть спасибо спасибо тебе большое держи пожалуйста нашу благодарность и и маленький подарок ребят и мы успеем до вопросы быстро если вы уже подняли челюсть ура говори просто я как вижу вы используете хардкорная суммарной оптимизация в вашем коде и у меня такой вопрос насколько и знаем да и intel архитектуры совместимы ну то есть там есть какие-то совместимы или похоже инструкции хотя бы у меня собственно первый вопрос это работает ли ваш код на м да и на intel и если да я понимаю что да скорее всего если какие-то сравнения насколько хорошо он работает там или там она и на интере нет у нас даже есть ограничения в вики требования ментовского процессора внутри нет ну как блонди другой векторное расширение у нас были какие-то еще пока в этот от того что здесь нас были еще какие-то требованиям на поинтов с компасом расширением планируете ли вы поддерживаете но если надо будет поддерживать спасибо если у нас еще люди которые успели и приз вопрос раз выкрикивать если у вас не вижу вопрос 2 ура где вопрос не по своему рождению а вот я посмотрел ваш гид хоп и и и что у вас полностью открытый исходный код и мне вот интересно как вы собираетесь монетизировать решение то есть дальнейшем месяц кто-то его будет внедрять насколько вы планируете его поддерживать и как бы если у вас поддержка платная такая поддержка будет потом капитана медалью модель внизу спейси на здесь че такая история что мы используем код ядра linux то есть у нас внутри есть своя свой уровень абстракции которой использовать linux переписывает и линуксовые ставьте себе знать мы не можем его закрепить нашу используем код ядра linux поэтому от платформа она всегда будет открыт на мой взгляд при за достойную украшавших просто потому что они успели понять что-то в докладе и сформулировать свой запрос может быть в тот который тебе в первый выходи к нам пожалуйста выходи сюда на сцену до вспоминая как тебя звать где ты работаешь и расскажу микрофон и зовут иван я работал тиньков меня доклад через два часа если что приходите в главный зал спасибо"
}