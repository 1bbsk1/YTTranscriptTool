{
  "video_id": "PQkW3cvGLkY",
  "channel": "HighLoadChannel",
  "title": "HTML5 Web Components: следующий шаг к модульности вашего проекта / Андрей Рахманов",
  "views": 481,
  "duration": 2597,
  "published": "2017-07-20T11:45:24-07:00",
  "text": "мы с коллегами занимаемся разработкой проекта андер печь совсем недавно мы прикрутили web components сейчас уведу web components к нашему проекту я бы хотела с вами поделиться тем зачем мы это сделали какие ошибки мы допустили какие у нас проблемы случились в процессе интеграции и к чему мы в итоге пришли для начала давайте поговорим о том чем мы вообще занимаемся наш проект андер пейдж это проект по созданию интерактивных книг это онлайн редактор который позволяет пользователю создавать интерактивные издания интерактивные издания это такая книга для смартфонов или планшетов которую пользователь может добавить различные медиа элементы аудио-видео а также анимацию разной степени сложности давайте посмотрим на интерфейс опыт таких редакторов как adobe photoshop например показывает что оптимальная организация интерфейса для подобных продуктов она представляет собой такое большое окно в котором есть множество панелей который пользователь может уже настраивать по своему вкусу в результате он получает удобную среду разработки как мы докатились до такой жизни как мы решили попробовать и зачем пересеклись пути нашего проекта и web components давайте представим себе сферическая сингл пейдж приложение в вакууме из чего она скорее всего состоит это скорее всего роутер это ряд вьюв верхнем уровне которые обязательно были бы страницами не будет a single бейдж архитектура чаще всего связанность между этими view хами она достаточно низкая то есть загружается 1 вьеха выгружается в юха происходит процесс взаимодействия в рамках скажем каких-то общих модулей таких как доступ к данным например давайте представим ситуацию с модульностью проблему с модульностью более остро допустим у нас есть такой сингл пэйдж приложение которое физически в себе содержит реально одну страницу что в этом случае получается обычно набор модулей и количество модулей в этом случае достаточно сильно возрастает связность между модулями также возрастает каждая инициализация view подключение плагина требует хотя бы долю нашего внимания хотя бы небольшую кодовая база растет количество в их количество модулей увеличивается и внимание которое требуется для поддержки подобного проекта требуется все больше и больше кодовая база увеличилась ваши ресурсы остались такими же внимание требуется все больше и больше и рано или поздно ваш проект рискует испортить тебе архитектуру и рискует прийти к такому состоянию когда разработка превращается в некоторую войну между программистом и проектом и чаще всего результат такой войны при недостаточно хорошим проектирование следующий год побеждают и программисты остаются весьма плачевном состоянии мы не хотели такой судьбы для своего проекта мы хотели снизить то внимание ту долю наших затрат которое требуется при поддержке отдельных модулей для нашего a single ps приложения с действительно одной странице и начали думать как это делать и в этот момент мы вспомнили отличный доклад выставки губбио где инженеры google показывали данный код это то как инициализируется google map в этом коде они подключают нужны и пиаре они инициализируют карту они делают маркер подключают этот маркер прицепляют карту к странице вроде бы все для того чтобы получить достаточно простой функционал для того чтобы получить просто карту с просто маркером нам не хотелось писать такой код и обращает внимание на каждую деталь каждый раз когда нам это требуется нам хотелось писать что-то вроде того действительно берем элемент инкапсулируя в него нужный и pr инкапсулируем у него нужные стиле и все за что этот компонент действительно ответственен пишем 1 тик и используемого как стандартные элементы управления это было бы здорово это было бы удобно и хотелось бы делать это уже сейчас так вот каким образом мы можем этого достичь в рамках нашего проекта мы используем bangers вы вероятно используйте какой-то свой фреймворк или свою систему и для интеграции естественно придется приложить определенные усилия так вот быть том же с не предполагает изначально возможности реализации таких кастомных элементов значит требуется искать какое-то решение еще какие решения еще могут быть есть ряд фреймворков таких как angular например которые позволяют определять свои кастомные элементы но в нашем случае смешивать два разных подходов angular и бэкгон это было бы неумна потому что каждый фреймворк все равно диктует свою структуру проекта то каким образом какие паттерны будут использоваться вашем проекте как будет построена кодовая база а это вам не подходит остается два варианта либо реализации с помощью библиотек таких как нокаут например если вы когда-то с ним сталкивались вы знаете что там есть кастомные билдинги которые позволяют реализовать что-то типа кастомных элементов но всегда когда вы используете библиотеку следует обратить внимание на то что по сути вы получаете java скрипта бёрку war обертку над элементом то есть вы получаете ник просто отлично продолжим созерцать закончили у нас есть библиотеки которые позволяют вам сгенерировать определенный набор к основных элементов но это будут определенные обертки который отправится в браузер которые будут там от рендеринг которые пройдут какие-то преобразования через шаблон и таким образом это не будет сам по себе кастомный элемент это все равно требует некоторые некоторую долю накладных расходов при работе в браузере есть третий вариант есть набор спецификаций современных набор спецификаций web components который и предполагает использование непосредственно того что нам надо напомню составные части спецификации web components это набор спецификаций которая состоит из темплейт of которые решают проблему шаблонизация в данный момент шаблоны чаще всего загружаются строкой скажем в теге скрипт после этого парсится подставляются нужное значение и так далее это html imports которые позволяют загружать куски html-кода такие как шаблоны также как вы это делаете с с и java-script это кастомный элемент элемент за которыми мы собственно и охотимся и это shadow дом который на данный момент достаточно эффективно позволяет решить проблему инкапсуляции стилей давайте посмотрим как в данный момент это все реализовано в браузерах и как с этим можно работать на текущий момент поддержка спецификации web components она уже лучше чем скажем год или полтора назад но тем не менее полностью поддерживаются только браузеры chrome и опера частично поддерживается firefox поэтому нативная реализация без каких-то поли филов она на самом деле достаточно печально однако pagefile из за последнее время за те же самые полгода-год очень хорошо шагнули вперед и последние версии наиболее распространенных браузеров они поддерживаются поэтому для того чтобы интегрироваться в наш проект мы приняли решение использовать все таки полифилы для того чтобы максимально покрыть все браузеры которые нам необходимы какие решения в виде поли филов предлагаются на данный момент во первых вы можете просто подключить полифилы и писать веб-компоненты в таком иди в котором это определено спецификации в этом случае вы действительно получаете максимально совпадающие со стандартной реализации максимально совместимый код но данного кода становится достаточно много и есть варианты которые по моему мнению в чем-то интереснее чем нативной реализация это проект бозоне проект позорник достаточно молодой проект который информации по нему практически нет в рунете они также предлагают свои полифилы но активность на гитхабе например в последние несколько месяцев она показывает что за этот проект действительно для использования реальном проекте браться не стоит потому что уж очень медленно как ты его поддерживают очень медленно он обрастает функционалом и медленно правится баги следующий вариант это xt как мазилы это вариант уже интереснее но он предлагает только кастомные элементы то есть использовать преимущества html imports темплейт вы не сможете и четвертый вариант это полимер от google на нем я становлюсь более подробно по одной простой причине мы его выбрали почему мы это сделали во первых он предлагает удобное декларативное описание элементов в основном стандарте web components вы должны императивно описать необходимые web component и после этого подключить их декларативное описание она действительно лучше читается и позволяют лучше понимать ваш код и он предоставляет определенный набор синтаксического сахара на 1 тивной реализации который позволит определенные вещи реализовать просто быстрее отлично инструмент мы выбрали каким образом можно его интегрировать существующий проект для начала определимся что собой представляют сам существующий проект серверная часть реализовано но джесс клиентские библиотеки мы собираем с помощью браузере whey gold и собственно саму клиентскую часть мы разрабатываем с использование bombones стилус и джейд как это происходит сейчас джеймс при компилируется в html стилус обрабатывается и становится csm и java script с помощью команды с и браузере fi преобразуется в те сборки которые в результате и уходят пользователю чего ждет от нас полимер он ждет такой декларативный те кто модуль в стилях он ожидает стиле на css template на html и скрипт который будет инициализировать ваш веб компонент подобных веб-компонентов сейчас на самом деле в сети есть уже достаточно много вы можете зайти на определенные сайты которые содержат эти компоненты ссылки я дам чуть позже и попробовать подключить что-нибудь из них давайте возьмем и попробуем стандартным путем подключить один из веб-компонентов допустим у нас есть веб-компоненты который мы подцепляем и предположим что он несколько сложнее чем обычный hello world и используют хотя бы одну стороннюю зависимость он свою очередь подключают полимер html библиотеку который используется для работы с компонентами и скажем какой-то web component первого уровня web component первого уровня как компонент который сделан сторонним разработчикам он свою очередь подтягивают компоненты второго уровня таким образом мы пишем 1 hdmi импорт один для того чтобы подключить web component а за ним идут еще пять других импорт of которые были вызваны собственно этим импортом таким образом подключая один web component вы получаете шесть лишних сетевых запросов естественно это очень неудобно и никуда не годится счастью есть решение непосредственно от команды полимер это полимер вулкана из он позволяет передать набор файлов которые вам необходимо вулканизированная борках компонента в которой вы планируете подключить он обрабатывается и записывает весь результат в файл all-in-one html нашем случае вы делаете импорт данного файла и можете его спокойно использовать как обстоит ситуация в проекте со сборками как обстоит ситуация со сборками у нас проекте и возможно у кого то из вас у нас есть два файла венджи заключают себе набор библиотек которые используются на клиентской стороне и apps он представляет собой файл собственно с кодом приложения можно ли уменьшить число сетевых запросов таким образом чтобы ограничиться имеющимися сборками давайте посмотрим как это можно сделать вендор джесс отправляется web components light это полифилы дальше прочие библиотеки которые у нас стандартно там находятся и мы хотим подключить полимер html напомню делаем это с помощью браузере fi и вот здесь на самом деле начинается проблема первая связана с тем что библиотеку в виде html который поставляется полимер подключить напрямую в джесс мы не можем потому что это неджес какое стандартное решение используется обычно в таких случаях используются браузере тот форм это такое преобразование которое позволяет из файлов любого расширения любого формата сделать так называемый модуль cam anges который потом уже окажутся в вашей сборки которые экспортируют необходимые зависимости эта идея пришла не нам первым в голову мы погуглили и нашли интересное решение по lime райс который как раз производит подобную трансформацию чем он хорош до батарейки да но отлично сейчас произойдет замена батареек вот я надеюсь вы можете пока поизучать это крайне содержательный слайд да представьте как подключается этот компонент одной строкой все работает пайпер bottom давайте о а я чувствую связь отлично пайпер battle мы его подключили и использование действительно очень удобно но реализация в этом случае подкачала почему потому что для реализации этого трансформа необходимо во-первых фикс для полимер автор использует ряд техник таких как в окружении переменных в глобальной область видимости для того чтобы все это успешно работала это естественно не очень хорошо потому что любое изменение библиотеки даже изменения минорной версии она может привести к тому что все у вас просто отвалится и не будет работать и так же каким способом реализуется этот transform ваши веб-компоненты формате html они изначально поступают клиенту после этого не парсится и вставляются непосредственно в ваш индекс html в тот файл в ту web-страницу которая пришла к пользователю таким образом сначала вы загружаете индекс html потом вы подтягиваете сами компоненты они портятся инвестируется в страницу естественно все это работает медленнее чем хотелось бы какой есть ещё вариант на сайте библиотеки есть вариант который позволяет нам подключать веб-компоненты и скрипта подобным образом он на самом деле немного похож на предыдущий вариант но разница в том что в этом случае вам приходится хранить сам web component вот в таком вот скриптом видео а это html естественно это не очень хорошо какой мы получаем результат такой код не удобно удерживать потому что вам придется писать данный код либо в виде строки и потом с этим работать либо вам придётся делать дополнительные трансформации чтобы это успешно работала и остается нерешенный вопрос подключением самой библиотеки полимер html потому что в случае с подключением компонентов они определенным образом и имитирую страницу и ok но сам полимер html содержит ряд тегов достаточно большой набор подключаемых html файлов скриптов которые также должны будут преобразованы также должны быть преобразованы при каждой загрузке страницы естественно это неудобно и это займет достаточно много времени итак вернемся к тому варианты которые предлагается по умолчанию вулкана из что он делает он берет все ваши веб-компоненты берет стиле которые они используют берет файлы со скриптами заворачивает их в один файл html и этот файл может быть поставлен пользователю каким образом это может происходить у нас есть наш индекс html то условные странице которая дается пользователю и есть компонент html который мы собрали из наших веб-компонентов как мы его можем подключить вариант 1 при рендеринге мы можем скотт из данного компонента html вставить в яндекс html и отдать все это пользователю в этом случае мы получаем меньше световых запросов то есть html импорт здесь не играет своей плохой роли но сборка не кэшируется то есть каждый раз когда пользователь перезагружает наш редактор перезагружает свое большой a single пейдж апликэйшен он получает каждый раз эту сборку с компонентами естественно это не очень удобно и второй вариант мы можем сделать один html imports все компоненты html с тем файлом которые мы собрали в этом случае мы получаем действительно один лишние сетевые запросы но это не так уж страшно и сборка хэшируется таким образом пользователь получит новую версию только в том случае если вы обновили версию библиотеки если вы добавили новые компоненты но собственно в тех случаях которые происходят от релиза к релизу так вот что мы получим если мы попытаемся интегрировать веб-компоненты в частности реализацию например в имеющиеся сборки java script файлов на самом деле мы создадим себе больше проблем чем мы их решим потому что получится достаточно нестабильное решение с тем кодом который описывал ранее вулканы сжечь снижает число сетевых запросов и позволяет их использовать достаточно позволяет достаточно эффективно подключить необходимую сборку отлично возьмем наш тег разработки с которым мы привыкли работать и посмотрим как мы можем интегрироваться в наш так разработки таким образом что разрабатывать веб-компоненты которые от нас ожидает платформа в том виде в котором мы привыкли это делать на помню как это происходит сейчас у нас он с джейд стилус и java script и напомню то что у нас ожидается в результате работы с компонентами мы хотим использовать тот же самый стык разработки в вашем случае это может быть ваш темплейт engine либо вы можете писать чистый html вы можете использовать любой препроцессор в любом случае вы хотите получить web component и собрать их в один файл и поставить пользователю в виде html сборки каким образом мы можем это сделать поможет нам этом сборщик проектов gold который на самом деле решает достаточно много задач связанных с интеграцией каким образом мы это делаем мы пишем простой call танк который преобразовывает джейд разметку в html получаем первый кусок веб-компоненты делаем следующий cold as который преобразует стилус css получаем стиле склеиваем три файла в один получаем после некоторых преобразований тот самый web component на изначальном наборе технологии который от нас ждет полимер который может дальше использоваться таким образом из набора тимплей тов стилей и java script файлов мы получаем набор веб-компонентов динамические при сборке после этого данный набор web компонентом в следующем то скам записывается в специальный файл реестр на него проставляются ссылки виде html импорта и вот данный файл реестр уже скармливается вулкана или таким образом мы пишем 3 изначальных файлов для каждого компонента и после сборки мы получаем единый файл который уже будет поставляться пользователю как выглядит сам резистор компонент он представляет собой подключение библиотеки polymer и динамический формируется реестр ссылками с использованием gulp а после этого он уже отправляется на вулкана в этом случае все работает но следует отметить следующую деталь для управления зависимостями веб-компоненты по умолчанию использует тег скрипт какой здесь минус минус 10 на самом деле такой же как и при использовании тега script в управлении зависимости в обычном приложения связан он с тем что когда вы управляете зависимостями через тег скрипт вам как минимум необходимо управлять порядком того в каком виде у вас подключаются ваши компоненты в правильном порядке в неправильном гораздо удобнее использовать для этого подход более модульный сделать рекламу определенного модуля и все будет работать зачастую 1 jalas тип файла в компоненте не хватает потому что если вы разработаете разрабатывайте какую-то определенную логику вам хочется либо разнести ее на разные файлы для того чтобы сделать скажем определенные модули определенные классы и скорее всего вы захотите подключить скажем например джек вере плагины которые вы будете оборачивать данные веб-компоненты любом случае вам потребуется управлять зависимостями команды с действительно удобнее это проверено ну конечно не поколениями разработчиков но тем ни менее последние несколько лет он себя очень эффективно показывает полимер по умолчанию команды с не поддерживает каким образом мы можем собрать сами ту сборку которая нам нужна сделаем это следующим образом у нас есть vendor джесс из которого мы экспортируем те библиотеки которые мы планируем использовать как в клиентском коде так и файле компонент html таким образом из клиентского кода и зпп джесс мы обращаемся к библиотекам там джек very big bon лодок и они второй раз не дублируются в клиентский код то же самое происходит и с файлом компонент html мы не заворачиваем одни и те же библиотеки в наши три разные сборки и сами компоненты и apps знают о том что эти библиотеки являются внешними таким образом если у нас определенный web component используя три разных модулях например manages модуль 1 и джек мере в этом случае джек вере не будет дублирован и мы получим сборку того размера который мы ожидаем отлично в этот момент мы для разработки в компонента должны написать три файла чтобы это соответствовало той модели разработки которая у нас принято как это можно еще более автоматизировать мы сделали генератор для и имам таким образом для того чтобы создать новый веб-компоненты мы пишем одну строку и достаточно просто получаем 3 нужных файлы которые представляют собой джейд шаблон с заготовкой под данный дом модуль java script который инициализирует данный web component и стилус которые имеют заготовку под определенный набор стиле таким образом какой бы стойка разработки вы не использовали под большинство решений которые вы используете для упрощения именно написания кода возможна такая интеграция своем компонентами которая действительно позволит вам в одну строку кода для генератора создать такое решение которое позволит вам интегрировать эффективно веб-компоненты в ваш проект таким образом создания нового компонента в при должном уровне автоматизации получается буквально таким же простым как добавление нового тегов разметку вы пишете одну строку у вас появляется веб-компоненты вы можете и вот тут же использовать и тут же добавлять ему необходимую логику как создавать веб-компоненты мы поняли таким образом нам надо понять где же нам их применить какая от них будет практическая польза в проекте возможности применения в реальном проекте можно разделить на две категории это низкоуровневая применение и применение на высоком уровне чем не отличаются скорее всего вы часто сталкивались ситуации ну или хотя бы иногда когда у вас есть стандартный элемент управления стандартны например input допустим это будет color picker так вот рассмотрим такую ситуацию пользователь выбирают определенный цвет для текстов использует стандартный color picker нажимает кнопку выбора цвета выбирают нужный цвет нажимает клавишу ok смотрит текст покрасился новым образом nophone немного не подходит думает ладно давайте изменим что-нибудь называет саму кнопку выбора цвета снова возит по панели выбора цвета нажимая ok подбирают новый цвет естественно неудобно и в этом случае чтобы хотелось делать хочется чтобы стандартный компонент обладал возможностями того чтобы нам можно было взять и каким-то образом транслировать тот цвет который пользователь выбирает сейчас данный момент не посредством в наш текст то есть не хочется подключить какое-то сложное решение и потом следить за тем чтобы она инициализировал ась правильно удалялась хочет чтобы стандартный компонент позволял сделать это на простом уровне добавить скажем какой-то атрибут и чтобы все заработало рассмотрим подробно расширение стандартных элементов управления на примере тех элементов которые решили ли мы и как нам это помогло это input с автоподстройка длины это данный color picker который также был реализован этот тег старый аккаунт который показывает пользователю число оставшихся символов это все расширение стандартных элементов управления и классический пример с об selecta это такой select который позволяет в зависимости от того какие данные мы в него передали отстроить себя либо иерархические либо показать определенные запрещенные значение в списке и для этого всего использовать собственно 1thek настроив его определенным образом какой вид в этом случае у нас принимает web component и какая логика в нем заключена мы подключаем необходимые зависимости через браузере fi наследуем ся от обычного им пута подключаем и откручиваем плагин в attach a и d . бег чем прекрасен такой подход тем что для того чтобы работать в каким-то плагином с определенной логикой которая теоретически может себя заключать возможности утечек памяти при правильном проектировании архитектуры подобного решения это возможность утечек памяти она в принципе невозможно потому что в тот момент когда у вас появляется ваш кастомный так скажем это input of the ресайза был без разницы каким образом он появился ваши разметки или вы его отрисовали из шаблона или вы его добавили императивно прямо из вашего кода вы получаете автоматическую отработку а то чаткал бека который прицепляем данную логику к вашему input а также в том случае когда у вас удаляется view в том случае когда вы вручную скажем через джек вере сделали джек верили мув и грохнули этот элемент вы получаете вызов detached call back а в результате вы можете использовать определенный тег вы совершенно может не беспокоиться о том какую логику он себе несет один раз вы ее разработали и в дальнейшем используйте также как стандартное html элементы управления подобный подход используют angular скажем для своих директив и нокаут для своих кастом инга но в этом случае от отсидит отсекал бекки проецируется непосредственно в те калмыки которые предоставляются стандартам веб-компонентов то есть они исполняются именно нативно на уровне браузера в тот момент когда том дерево говорит надо сделать то-то и то-то и это замечательно следующий пример это color picker мы его так же наследуем от им пута и вот как раз только основные события о котором я говорил пользователь возит по элементу выбора цвета и в тот момент когда он передвигает мышку мы хотим знать что у нас произошло не только события ченчик которая происходит тот момент когда пользователь нажал на клавишу ok и отправил определенный цвет но мы хотим его видеть скажем в режиме реального времени в тот момент когда пользователь его именно выбирает нам хотелось бы иметь не только события cinch но и скажем событий превью которое будет исполняться в тот момент когда мы занимаемся выбором цвета непосредственно так вот мы можем легко это сделать про бросив определенный триггер прямо на данном элементе таким образом из внешнего кода вы также подписывайтесь от к привью событию превью и также как наши быть очень швы скажем изменяете определенные настройки вашей модели также по событию превью вы просто изменяете вашу в юху и изменяете сам цвета текста и работайте с этим совершенно также как вы работаете с обычными событиями обычный дом элементов использование в этом случае сводится к следующему вы пишете обычный input указывайте что он является необычным им потом а определенным наследником этого input а нашим color picker am в этом случае об это префикс нашего проекта пантер пейдж обязательно в компоненты должны иметь в себе черточку которая разграничивает namespace и собственно имя самого компонента и с помощью атрибутов вы стандартно настраиваете данный компонент текст или аккаунт зачастую когда вы работаете с input он например или select нам со стандартными элементами управления вы ожидаете что они будут использовать стандартный определенный и пиарь то есть вы обратитесь к свойству вылью или присвоить и его или получите его скажем из данного элемента и вы ожидаете что она действительно будет получаться из элемента или наоборот при поэтому определенные значения а это можно сделать с помощью git и raw и сеттеров следующим образом вы определяете методы get и set и к этому элементу обращайтесь совершенно также как вы это делаете с обычными элементами управления использование в этом случае такой же как использование обычного элементы текста ри но вы указываете стандартные атрибуты но расширять их одним атрибутом которые как раз и дает то самое необходимое расширение стандартного элемента которая нам требовалось и элемент об select с помощью объекта properties вы можете легко пробросить те необходимые свойства для биллинга которые вам необходимо интегрировать в логику данного компонента такие как например возможность множественного выбора вы может легко указать placeholder который будет отображаться пользователю и коллекцию ой там с на основании которой сам элемент будет определять каким образом мы это все будет отрисована в себя использование будет выглядеть следующим образом в этом сказываете передаете скажем переменную из вашего шаблонизатора или из какого-то другого клиентского кода и комбик уже сам решает каким образом он тебя от рисует как мы можем использовать на более высоком уровне как перри используемая логические блоки можем использовать следующим образом представим следующую схему у нас есть набор логических блоков которые могут заключать себе не только разбиение на определенные блоки под системы но и определенную логику то есть внешний блок мы настраиваем с одними атрибутами внутренний блок с другими атрибутами каждый из них заключает внутреннюю логику таким образом саму разметку мы сильно упрощаем убрав из нее лишние элементы и строим действительно тематически понятную тематический понятный код давайте посмотрим на наш полигон для испытаний в нашем случае это инспектор выбранного элемента которые отображают изменяющиеся свойства и панель действий в которой пользователь настраивает разные анимации в этом случае с инспектором разбиение будет следующим образом будет внешний объект об инспектор в него вложен следующий логический уровень оба этих компонента мы настраиваем через атрибуты то есть мы можем легко их поменять местами мы можем настроить через атрибуты другое поведение но тем не менее мы делаем достаточно простую и понятную разметку из которой сразу понятно что она делает она также представляет собой тематический понятный и логический код следующий вариант это панель действий данные элементы мы на самом деле сначала думали как называть изначально в первоначальном фрагменте дизайн они были розового цвета вроде бы и не тайминг и нечто основное в общем объект сосен объект suicide вы настраиваете следующим образом указывайте через атрибуты необходимые значения длину внутреннюю длину анимации внешнюю с помощью этих параметров вы управляете тем что происходит внутри этого объекта и размещаете обстоит маркер таким образом что увидите в интерфейсе вы видите элемент контейнер и вы видите скажем так маленькую пипку которая находится внутри него с которым мы взаимодействием и в разметке мы видим то же самое то есть в разметке мы видим совершенно такую же картину которая представлена в интерфейсе внешний контейнер и внутри содержится тот маркер который собой представляет нужный функционал и нужную стилизацию таким образом веб-компоненты вы можете применить везде это не значит что надо переписать всю разметку с использованием веб-компонентов просто их сильные стороны вы можете использовать в зависимости от того что вам требуется ли вы можете завернуть часть и пиарь необходимого либо вы можете инкапсулировать нужные стиле и разбить вашу систему на набор логических блоков которые при правильном проектировании будет действительно удобно поддерживать и расширять дальнейшем после проведенной интеграции после того как мы на веб компонентах реализовали ряд решений и сделали определенный комплекс работ которые были с ними связаны возникает вопрос здорова ли нам был работать с веб-компонентами и стоит ли этим вообще заниматься ответ определенно да потому что есть ряд минусов есть ряд проблем которые возникают в процессе интеграции но тем не менее уже сегодня они позволяют предоставить очень большой объем полезной функциональности наиболее частые проблемы которые возникают это не полная документация потому что спецификация находится в разработке сами библиотеки которые используются для разработки веб-компонентов также находятся в разработке возможны некоторые изменения выпей хотя в данный момент есть уже версия 09 которые максимально приближены к стабильной и разработчики обещают минимальные изменения и пиррой до стабильной версии и также есть достаточно мало нет достаточно много информации на stackoverflow и на подобных сайтах которые связаны со свежими версиями библиотек поэтому отчасти приходится смотреть спецификацию исходный код в некоторых непонятных местах но на самом деле это следует делать даже в том случае когда информации избыток какие есть перспективы развития у web component а в целом и о полимера в частности если вы используете версию 09 как это мы делаем ее вы можете использовать базовый и 5 который будет заложен для версии 10 которую обещают уже летом большинство веб-компонентов написаны на версии 05 которая была выпущена еще в конце прошлого года поэтому для того чтобы посмотреть примеры как реализованы сами веб-компоненты скорее всего придется копаться в той версии которые есть на данный момент на рынке то есть версия 05 но мы выбрали следующую версию почему потому что производительность поли филов которые предоставлено авторами библиотеки вот синий столбик это производительность новой версии красный столбик производительность новой версии меньше это лучше действительно производительность увеличилась несколько порядков и это конечно не может не радовать какую информацию еще можно почерпнуть касательно веб-компонентов и где это можно сделать во первых это web components точка орг сайт на котором консолидированной информация по библиотекам по поддержке браузеров по различным статьям с которыми используется в компоненты это кастом элемент и о и компонент kitchen это как раз те ресурсы на которых есть уже определенной веб-компоненты с которыми вы можете взаимодействовать который вы можете посмотреть и понять как им пользоваться есть мнение что скажем для использования джек вере необходимо иметь хорошее знание java скриптов для того чтобы понимать как то все работает под капотом своем компонентами все тоже самое для того чтобы использовать библиотеки такие как полимер вам необходимо знать основы и есть замечательный курс на прервал сайт к вы можете посмотреть там очень подробно и обстоятельно объяснены основы именно той версии стандарта которые есть данный момент и естественно это сам сайт polymer-project.org на котором вы можете проникнуться духом полимера посмотреть какой функционал представляют он в данный момент и попробовать что не сделать какой главный вопрос возникает при работе с веб-компонентами сегодня возможно ли интеграция в реальный проект сейчас на самом деле это зависит от того какие браузеры вам необходимо поддерживать и как как необходимо с ними работать вашей целевой аудитории набор modify love которые предоставлены в данный момент библиотеками позволяет покрыть разные необходимости разные ограничения то есть вы для себя можете выбрать какую именно версию функционала вы можете для себя выбрать тот баланс между функциональностью и между ограничениями которые есть у вашего проекта и подключить либо нужную библиотеку либо просто использовать полифилы и писать веб-компоненты нативно библиотеки сегодня имеет гораздо более широкие возможности чем например полгода или год назад таким образом риск который связан с использованием такой достаточно свежий технологии он уже оправдан потому что тем самым используя веб-компоненты вы можете привнести в ваш проект тот функционал который в будущем действительно будет хорошей основой для действительно подлинного интересного понятного и читаемого и расширяем авокода попробуйте веб-компоненты это действительно очень вкусно хотя бы на не большом проекте хотя бы на чем-то маленьком но попробуйте это завтрашний день и я уверен что вам обязательно понравится спасибо 1 привет у себя на проекте мы тоже бород пробовали внедрить веб-компоненты но столкнулись с такой проблемой что ее 9 он в принципе не поддерживает shadow дом вы вот какие поддерживайте браузера задумывались о каком-то порка раунде школе 2 и 9 а на самом деле есть проекты о которых я говорил то есть это проект по зоне и xpeke есть не ошибаюсь они заявляют себе поддержан но они не ну как это все то же самое что встроить просто какой-то деф на страницу который будет подвержены всем влиянием тех же скриптов и таблиц стилей которые уже на нее есть они грубо говоря что делают они оборачивают какой-то элемент и вставляет его на страницу там вместе со своими захваченными стилями и джесс а вот все-таки shadow думает немножко другой он инкапсулирует все это до поэтому проблем с тем чтобы его использовать где угодно нет а пройдя 9 вы не задумывались вообще на самом деле конкретно про и 9 мы не задумывались потому что у нас проект не поддерживает этот браузер но скажем пример библиотека которая решает проблемы shadow домом shadow дом как я уже сказал он поддерживается сейчас напрямую только в браузерах которая сделана блинки то есть это chrome и опера для остальных решений по умолчанию полимер какой подход использует он используя так называемый shady дом сталкивались таким понятием да и так ли мы рассматривали тоже вставал эту проблему вот везде решаем мы все кроме и е9 к сожалению да но с ее 9 действительно проблема есть то есть скажем те же самые другие проекты не полимер позорники xpeke они заявляют свою какую-то поддержку но мы такой такой конкретно вопросы и 9 мы более детально не рассматривали поэтому я думаю здесь конкретно что-то посоветовать кроме как изучать существующее решение я не смогу спасибо 1 спасибо вот какой вопрос хотел задать я обратил внимание что вы весь java script склеивайте ну вот этих 2 файла и нет разбиения там ну по страницам грубо говоря вот хотел узнать сколько у вас весят файлы vendor ds и apps сжатая где полная версия если я не ошибаюсь весит около сейчас помню по моему около 300 килобайт avengers zippo ванный имени цитированный тот который мы объемный клиента момент то есть не встречались такой проблемой что весит это очень много и пользователю слишком накладно все сразу весь это действительно на самом деле много но наш редактор собой представляют ту страницу собственно на которую нам действительно необходимо загрузить все эти библиотеки разум потому что мы один раз действительно сначала происходит в рамках веб-стандартов за станцию долго инициализация но после этого пользователь достаточно долго работает непосредственно самим редакторам то есть он один раз загрузил все приложения и потом с ним спокойно работает естественно в in jest кешируется поэтому проблемы с только при первой загрузке чтобы могли посоветовать для тех у кого приложение побольше помассивнее страниц много и так далее но приложение на самом деле достаточно массивное просто я думаю на с вами разная архитектура в этом случае какое может быть решение может быть у вас несколько венгерских библиотек то есть вы я так понимаю используете несколько разных разделов в каждом разделе у вас есть свой vendor джесс вы можете также из него делать экс пауз о котором я говорил то есть помечать нужные библиотеки таким образом что они являются внешними по отношению клиентскому коду и components html то есть вы используете определенные компоненты на вашей странице вы используйте определенных клиентский код и определенный вендор джесс и то к чему вы обращаетесь из компонентов и из-за ппс вы помечайте как внешние ссылки то есть по сути вы получаете набор меньших скажем файлов вы получаете тот же самый vendor джесс просто для вашей конкретной страницы для вашего скажем но для вашей определенной страницы до с которой вы можете работать хорошо спасибо на этом все если хотите еще задать какие-то вопросы андрею выловить в кулуарах спасибо спасибо"
}