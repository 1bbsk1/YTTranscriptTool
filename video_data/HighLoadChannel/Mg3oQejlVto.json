{
  "video_id": "Mg3oQejlVto",
  "channel": "HighLoadChannel",
  "title": "Возможности виртуальной памяти для улучшения масштабируемости систем/Тимур Давыдов(Московская Биржа)",
  "views": 447,
  "duration": 2082,
  "published": "2023-01-19T06:56:46-08:00",
  "text": "добрый день я тимур давыдов программист c + + работаю в роли главного программиста на московской бирже и последние шесть лет в общем московская биржа занимается разработкой период маток московской бирже занимается разработкой многофункциональной биржевой площадке по торговле акциями и облигациями производными инструментами валютными инструментами денежным на денежном рынке и плюс товарами значит о чем собственно будет этот доклад в настоящее время помимо производительность системах очень важен факт лет инси то есть низкие задержки они очень важны при обработке информации соответственно сейчас одну секунду извиняюсь значит где это важно где нужен где нужна обработка массива информации последовательно расположенного например это могут быть in memories базы данных это могут быть каширу ющие системы это могут быть брокеры сообщений и так далее в чем может возникнуть проблема мы заранее можем не знать всего объема информации которые нам нужно зарезервировать но при этом если мы попробуем увеличить память обычными локаторами да то нам придется копировать всю информацию из буфера из одного в другой и мы получим очень большой в этом сипри при этом непредсказуемой значит что будет рассмотрен в этом докладе в этом докладе будет предложен мы во-первых рассмотрим архитектуру торгово клининговая система московской бирже дальше мы вспомним что такое виртуальная память познакомимся собственность технологии увеличения буфера за константное время и узнаем как прошел процесс внедрения данной технологии в московской бирже небольшой глоссарий который будет использован в следующем слайде значит сокращение crm это сокращение концы нити low latency мисс мэри-джен это транспортный уровень в качестве физического используется мило ноксом tiny bang story кабитт сейчас мустанг это проприетарной а очередь сообщение московской бирже которая в качестве физического уровня используется вернет 10 гигабит в качестве транспортного уровня может быть тиц и pr пеев если . . или multicast если широковещательные пакеты на данном слайде представлена архетип архитектуры торгово клининговой системы торгово клиринговая система представляет из себя множество серверов это десятки серверов обычно каждый сервер имеет какую-то одну определенную роль вот на данном слайде как раз представлены все эти роли мы мы сейчас их рассмотрим значит и этот рэйден джен сокращение это сокращение это центральный сервер торговой системы backup это резервный сервер торговая система по сути дела у него нет никакого отлучат отличие от центрального сервера торговой системы кроме одного он не отсылает ответы на транзакции гувернер это система которая занимается выбором центрального сервера торговая система ну собственно она выбирает кто на данный момент будет центральным сервером без бэкапов и текущего торгового серы и текущего цветы сервера серверы доступа торговые системы это сервер и которые отделяют собственно торговую систему от конечных пользователей к ним подключаются непосредственно конечной пользователя они период рисуют транзакции на сервер торговой системы на центральный сервер торговой системы дальше есть сервер и клиринговые системы значит они проверяют обеспечения пользователя то есть и их основная задача понять и достаточно ли средств у пользователя чтобы выполнить заявку поставить заявку соответственно серверы доступа клиринговой системы по аналогии серверами доступе торговой системы отделяют конечно пользователи от серверов серверов клининговой системы значит есть транзакционный диспетчер клиринговые системы чем он занимается по сути дела он занимается только упорядочиванием транзакции потому что очень важно чтобы транзакций выполнялись в хронологическом порядке и есть транзакционные хранилище клиринговой системы она хранит просто на диске упорядоченные транзакций упорядочен набор транзакции здесь еще раз перечислены значит какой интерфейс доступа есть два типа сообщений есть транзакции это сообщение типа запрос ответ где ответ достаточно короткие это обычно просто сообщение об ошибке если есть ошибка или сообщение что все хорошо транзакции это команды по сути дела поставить заявку снять заявку изменить заявку плюс есть информационные запросы то есть это запросы один запрос и массив ответов значит это нужно для получения информации о сделках заявках ну и всякой биржевой другой информация теперь подробно приведу структуру центрального сервера торговой системы ну и так же вот здесь скобках указано что и backup тоже ну собственно как я объяснила это одно и то же есть несколько потоков первый поток это интернет поток обработки информационных запросов который просто возвращает по нужному алгоритму в нужном виде данные из разделяемой памяти введя ответа есть поток обработки транзакций на в торговой системе именно центральный сервер торговой системы занимается упорядочиванию не транзакций в отличие от клиринговой системы где есть отдельный диспетчер упорядоченные транзакции передаются разделяемую память сервера репликации для шлюзов для серверов доступа также дальше транзакция передаётся в поток валидации в потоке валидации проверяется корректность транзакции что-то мне мусор какой-то дальше проверяется что у есть права доступа на выполнение этой транзакции и если это заявка то посылается запрос в диспетчер специальные транзакции на проверку обеспечения у пользователя это кстати вот показано на следующем кадре то есть вот этот участок валидация мы чинг он приближен и показано что в процессе валидации заявки отправляются на диспетчер диспетчера передает на клиринговый сервера транзакцию клиринговые сервера проверяют обеспечение пользователя если все не важно хорошо ли плохо они дают ответ обратно торговой системе и дальше эта транзакция передаётся уже потоку митинга собственно дальше здесь показана если мы чем удался митинг это когда две заявки встречают друг другу и совершается сделать если они совпадают по параметрам если совершила сделка ту опять же эта сделка передается диспетчеру на правку обеспечения скажем так на изменения обеспечения пользователя и дальше поток финализации поток финализации он отправляет ответа пользователи уже и записывает транзакцию журнал транзакций это кстати тоже отличие от клиринговой системы где есть отдельный мессидж top который хранит транзакции так но здесь основные функции сервера торговой системы центрального сервера то есть это обработка информационных запросов валидация корректность все транзакции валидация правду став ну собственно чем я уже все рассказал matching в общем да это я все описал дальше что такое шлюз торговая система или сервер доступа торговой системы по сути дела они построены на одном и том же движке кроме того что шлюз если видит транзакцию на входе он соответственно и и не может обрабатывать потому что она не упорядочена и он ее просто напросто пересылает на центральный сервер торговой системы и транзакции опять же он получает сервер репликации то есть они уже выстроены в нужном порядке а так в принципе обработка все то же самое то есть транзакция также валиде руется в общем также делается свой митинг и так далее вся информация если обратили внимание всей всей системы обмениваются все потоки и всей системы обмениваются информацией через разделяемую память собственно утилиты это это могут быть утилита управление утилиты мониторинга утилиты импорта обратно в базу данных в обычную суп обеда они также подключаются к разделяемой памяти просто с правами чтения вот все отличие так ну собственно здесь опять же то что я уже перечислил дальше центральный сервер клиринговые системы на самом деле в клининговой системе все гораздо интереснее там нет по сути дела отличий между самим сервером клиринговые системы серверами доступа по сути дела это одно и то же один и тот же движок они также там также есть несколько потоков собственно поток обработки информационных запросов которые также из разделяемой памяти получают нужную информацию передает пользователю единственное отличие опять же от той же самой торговой системы мы получаем эту информацию уже из диспетчера поток упорядоченных транзакций также транзакции валиде руются и исполняются под исполнением понимается это списание обязательств добавление средств и так далее то есть в зависимости от того какая транзакция была ну и создать соответственно и так и финализации нам не нужно уже писать в традиционный лук в транс акционную журналу транзакцию мы так как этим занимается мыса часов мы просто возвращаем ответ в торговой системе так здесь по сути дела это все что я только что перечислял теперь диспетчеры мы сейчас top диспетчер как я уже неоднократно говорил занимается упорядоченной транзакций дальше поток упорядоченную виктора упорядоченных транзакции передается на риск и generis gotway то есть на серую доступа в месяц штор так дальше да здесь еще диспетчер он также поставляет метку времени и присваивать номер каждому сообщение так про массаж стоп что он умеет делать он хранит полную историю сообщения диспетчера он хранит сообщение на диске но более свежий он хранит в оперативной памяти в своей есть процедура лей join это когда шлюз подключился или перезагрузился в течение рабочего дня то чтобы наверстать упущенное он запускает процедуру ли джонс массаж скоро и получают все транзакции сначала дня ну и соответственно приходит никому консистентными состоянию дальше мыса часто умеет синхронизироваться с другими массаж шторами по сути дела используя примерно то же самое join так теперь немножко о том как создается разделяемая память есть некая специальная программа loader она запрашивает данные субд firebird у нас субд firebird хранится вся конфигурационной а информация на начало дня скажем так дальше создает в память просто no hibi всю структуру данных создают связи между данными необходимые создаёт необходимые списке выполняет создает хэш-таблицы по данным и так далее то есть создают полностью скажем так рабочая область рабочую рабочий образ разделяемой памяти и выгружает все эти данные на диск все у нас просто есть наборы бинарных файлов по сути дела и являющиеся my слепками таблиц при загрузке торговая система или клиринговая система загружает эти файлы просто путем копирования в разделяемой памятью не более того то есть создает укусов разделяемой памятью и копируют ударить в таблице плюс запускает дополнительно процедуру для дополнительной инициализации или дополнительный дополнительного создания опять же может быть хэш каких-то таблиц или про построение дерева или еще что то что такое общая разделяемая память это в общем некая заранее выделенная область памяти который может иметь доступ более чем один процесс это стандартный механизм между процессного обмена и в торговых ливинга системе он используется для обмена ну между потоками плюс между различными утилитами какие плюсы у разделяемой памяти но это во-первых наиболее быстрый способ между процессного взаимодействия из-за чего из-за того что он не использует никаких системных вызовов в операционной системы при записи в эту память или чтение из этой памяти значит соответственно нет переключения контекста ну накладных расходов на переключение контекста и плюс программисту удобно взаимодействию с разделяемой памятью потому что нет никаких отличий от взаимодействия с областью памяти на хиппи какие минусы разделяемой памяти ну безусловно минус то что он требуется дополнительной синхронизация между различными серверами то есть для этого нужны какие-то дополнительные сетевые взаимодействия дальше необходимо использовать механизмы синхронизации для доступа к одной и той же ячейки памяти иначе мы получим не консистентную информацию у них и нельзя использовать стандартные локаторы и нельзя использовать стандартный контейнер это тоже большой минус разделим ее памяти то есть более того все контейнеры разделяемой памяти должны быть интрузивные то есть все дополнительные данные которые нужны контейнеру для хранения информации они уже должны быть заложены в структуре данных в структуре каждого элемента там таблицы допустим да ну и самый главный минус для нас по крайней мере это необходимость резервировать весь объем разделяемой памяти то есть мы не можем и еду аллоцировать мы должны сразу и рассчитать какой объем таблиц нам нужен будет и сразу этот объем зарезервировать это основной минус из-за чего начались доработки торговой системе в нашей системе используется приведенная структуры разделяемой памяти то есть у нас разделяемая память отображается на память процесса двумя кусками первый кусок со служебными данными это допустим семафоры для доступа это какие-то служебной информации какая-то служебная информация об объеме памяти и так далее и область данных область данных она разбита на and tablets в нашем случае это 150 где-то примерно там 155 возможно значит первая таблица у нас опять же служебное в этой таблице хранится очень важная информация это смещение всех остальных таблиц она выглядит примерно так и естественно чтобы не нарушать индия не скажем так изменил и название и даже саму структуру данных но как говорится все герои вымышленные любые совпадения случайны но общая суть остается верной то есть каждая таблица у нас это массив структур то есть по сути дела вот здесь описаны какие примитивные структур кити потом заявки и другие сделки и как каждая таблица это просто указатель на эту структуру соответственно дальше при детализации мы настраиваем этот указатель на нужную область разделяемой памяти используя данные служебные таблице которую назовем там ты был в топе первая табличка в которой есть такая информация как смещение нужный нам таблицы в разделяемой памяти + ее размер все в принципе нам этих данных достаточно для того чтобы выстроить полную картину на в любом приложении дальше здесь показан пример того как инициализируются параметры в этой табличке тейлз и кстати в этом примере специально допущена ошибка так на будущее потому что она может привести к очень серьезным последствиям на самом деле должно быть вы должен выглядеть вот так функция определения размера таблицы обязательно должна выравнивать размер таблицы до размера страницы разделяемой памяти здесь приведён пример простейшие функции получающих параметр у операционной системы это все для linux получающий размер страницы разделяемой памяти и соответственно выравнивающие поэтому размера дальше что еще можно сказать про таблицу разделяемой памяти они часто связаны по индексу друг с другом то есть в одной таблице может быть некое свойство которое хранит в себе индекс другой таблицы но как примерно показано на данном слайде дальше все статические таблицы а несортированные для возможности применения бинарного поиска но обычно это справочника справочнике в которой не может добавляться информация для ускорения поиска в динамических таблицах используются интрузивные well деревья или закрытые хэш-таблицы для ускорения перебора данных каких-то по какой-то группе ну например все заявки фирмы используется и опять же интрузивные списке они там 1 направлено не важно но значит теперь постановки проблемы в связи с чем возникла желание что-то изменять как видно на текущем слайде это график зависимости количества заявок по дням в течение до 21 года начиналось у нас там образом мире все примерно там с 18 миллионов заявок периодически это увеличивалась дотам ну сколько там 30 миллионов заявок вот это красной линии на 5 10 миллионых заявок это по сути дела резервирования область таблица заявок то есть больше этого количества и если заявок окажется больше этого количества то по сути дела это означает останов системы потому что мы не можем продолжать у нас не хватило таблица заявок слава богу в двадцать первом году уже была введена система про которой я сейчас рассказываю поэтому вот этот пик который выходит за красную линию он не привел к установке торговой системы он привел просто увеличению таблиц в памяти вот теперь мы посмотрим количество заявок на начало 22 года вот обратите внимание здесь выбросы были ну до 50 тонн 5 52 миллионов максимум за 21 год в двадцать втором году уже в начале года уже в январе в середине января мы получили выброс более 60 миллионов заявок соответственно опять же системы отработала штатно и это не привело к остановке торговой системы если мы обратим внимание дальше на выбросы то мы увидим что выбраться доходили до 100 миллионов заявок чем эти выбросы опасны тем что они непредсказуемо они могут они возникают из-за волатильности на рынке которым мы в принципе предсказать не можем это может появиться новость в сми и все и на рынке огромная волатильность и количество заявок просто превышает все разумные пределы значит теперь сути постановки проблемы иногда требуется добавить данные справочники статические таблицы дальше невозможно предсказать требуемый объем памяти я примерно показал на графиках как это происходит и соответственно самая страшная спичка образная рост когда мы не просто не можем предсказать рост действительно просто необъяснимый какие пути решения ну собственно оставить в торги перри конфигурировать систему перезапустите то где-то на час или полтора часа времени носу что приводит к уменьшению теперь и собственно к проценту к надежности к уменьшению надежности системы ну этот путь нам соответственно не подходит дальше создать новую разделяемую память большего объема допустим дошли мы до какого-то предела там 70 процентов создаем новую раздели мою память начинаем копировать данные это тоже плохой путь во первых данных в какой то момент времени в памяти будет в 2 раза больше во-вторых это потребует определенного времени дополнительного тоже на мэтт путь не подходит третий вариант самый наверное очевидное просто поставить много памяти на каждый сервер и жить спокойно не тужить но этот путь тоже не очень хороший потому что просто банально дорого серверов примеру там около сотни и в общем поттера байтов памяти на каждый сервер будет очень дорого при этом эта память в основном не будет использоваться больше чем на 5 10 процентов что тоже не очень оптимально ну и последний вариант зарезервировать большой объем разделяемой памяти и но аллоцировать только необходимый размер это достаточно интересный путь который нам подходит что такое виртуальная память это совокупность программно-аппаратных средств которые позволяют создавать виртуальное адресное пространство которые не будет привязана к физической памяти по и плюсы объем может быть больше объема физической памяти значит вскрытия пользователей реального места расположения физической памяти и можно выделить большую последовательно расположенные область памяти даже если у нас нету участков такого объема то есть по сути дела это борьба с фрагментирования памяти но из минусов это накладные расходы на трансляцию адресов но по сути дела все современной операционной системы используют виртуальную память поэтому здесь мы здесь не будет ничего такого существенного для нас так я сейчас попробую побыстрее пройти некоторые кадры значит по полу трансляция адресов ну как я говорил доступа осуществляется по странично могут быть страничке 4 килобайта для 64 битных систем и или 2 мегабайта в режиме хищники л бим адрес виртуальной памяти прозрачно транслируется с помощью механизма трансляции на следующем слайде показана показан трансляция адресов то есть по сути дела виртуальной памяти все страницы располагаются последовательно при этом в физической памяти они могут располагаться в любой области или даже не располагаться вне я быть в свопе здесь приведён приведена структура виртуального адреса сейчас я не буду подробно на этом останавливаться просто по времени хватит для обычного режимы для режима с большими страницами значит теперь к реализации но собственно мы создаем объект большой мы выделяем резервируем большой большую разделяемую память гораздо большего объема отображаемые в процесс но не ассоциируем располагаем таблицы в памяти разрежена то есть не друг за другом уже с большими промежутками отводим на таблицу допустим 64 гигабайта вот но и делаем моники класс обертку чтобы лога секунд было легко переделать так защита значит какие функции для этого есть есть функция map on я извиняюсь а по времени я боюсь я не успею рассказать про функции здесь в принципе это стандартные функции и в докладе можно будет посмотреть все их использование параметры то есть шлем alpina это соответственно создании самой разделяемой памяти с помощью стран кейт мы резервируем большой объем допустим там 10 trabant примеру да с помощью мы по мы попируем память на отображаем память в память процесса для того чтобы мы имели доступ к ней здесь описана собственно режима защиты памяти это кстати важный режима с помощью как раз них можно аллоцировать память сейчас я перейду к этой функции это вот функция м protect она как раз позволяет аллоцировать память в процессе то есть и из допустим из выделенных 10 трогать мы можем аллоцировать примеру там 500 мегабайт допустим да ну как я уже поговорил таблицы будут разделять расположена разрежена разделяемой памяти здесь кусок кода который настраивает служебную таблицу он гораздо упростился теперь мне нужно вычислять размер памяти нужный для таблицы а теперь мы просто закладываем допустим под каждую таблицу какой-то недостижимый лимит 60 допустим 64 гигабайта примера хотя он тоже достижимой при таком лимите 150 таблиц будут для 150 таблиц нужно зарезервировать 9 и 6 2 байта памяти так насчет класса обертки наверное сейчас пропущу потому что мы не успеем иначе ну и соответственно сам самое главное вопрос нашей системе когда собственно увеличивать обычно у нас в основном все функции создания элемента в памяти они представлена на они выглядят примерно так то есть в первым делом они проверяют и если доступные места если нет возвращает ошибку если есть то создают элемент заполняют его и в конце инкрементируем счетчик текущего количества элементов в таблице это как раз нужна для того чтобы мы могли спокойно выделить элемент не боясь что процесс или поток параллельный к нему обратиться до момента пока мы его заполним мы соответственно вместо этой проверки 100 вставляем некоторую функцию которая проверяет если в табличке еще место если нет то резервирует дополнительной область какие возникли проблемы при реализации но основная проблема это из-за разреженности таблиц мы получили несколько мест с промахами по памяти обращение к отрицательным индексом дальше мы получили сильное замедление при обращении по индексу это из того что в нашей системе необходимо использовать необходимо компилировать код с отладочной информации даже релизный из-за этого оператор квадратные скобки в общем занимал достаточно приличное время но мы этот режим оставили но просто для режима отладки для тестировщиков скажем так было есть потери производительности при выделения очень большого участка памяти из-за инициализации данных которые раньше происходило в начале загрузки системы теперь это нужно делать для каждого выделенного для каждой выделенной области и соответственно проблема синхронизации данными с утилитами так в общем какие выводы можно сделать по нашему применению технологий в принципе работоспособна она показалась работоспособный изменение логотипа до оказались минимальными она такая технология позволяет выявить и легко выявить промахи по памяти производительность конечном счете практически не пострадала то есть мы привели произвол производительность к нужным то есть это примерно занимает три процента времени вот если мы будем выделять по 1000 элементов в процессе работы системы то это прибавить 3 процента времени ну и собственно придётся отказываться от закрытого хэширования в пользу открытого так как закрытые хэши здесь уже не совсем подойдут из-за того что мы не знаем какое количество данных у нас будет таблица ну в общем я выложил на гитхабе исходники которые с помощью которых можно будет так сказать на практике просмотреть то что описывалось докладе смотрите если будет интересно ну и соответственно обращайтесь ко мне если какие-то будут вопросы спасибо большое тимур друзья давайте скажем спасибо тимуру из доклад особо отмечу что один из не подавляющего большинства докладов с определенным референсом которые можно потом посмотреть на гитхабе это очень ценно спасибо тиму друзья к сожалению у нас время на доклад на слот доклада практически вышла поэтому я прошу все вопросы приготовить и задать докладчику в кулуарах конференции в цифровых culoare спасибо тимуру"
}