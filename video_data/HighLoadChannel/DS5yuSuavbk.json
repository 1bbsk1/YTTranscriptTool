{
  "video_id": "DS5yuSuavbk",
  "channel": "HighLoadChannel",
  "title": "Accord — алгоритм управления распределёнными транзакциями / Константин Осипов (ScyllaDB)",
  "views": 640,
  "duration": 3143,
  "published": "2023-10-06T07:24:04-07:00",
  "text": "так но смотрите здесь прекрасный формат Я вас не вижу это ровно то что требуется для хорошего доклада поэтому тема у меня не самая простая Я бы хотел вашего участия как обычно поэтому пожалуйста прерывайте меня и я буду во время доклада тоже пытаться какой-то получить реакцию зала вот еще раз хочу сказать абсолютно нормально меня останавливать рассказывать я буду про относительно новый Paper который бурно обсуждается в системе Кассандра Как вы наверное знаете я сейчас участвую в этой системе активно силы это реализация Кассандры поверх оперативной многозадачности вот носи плюс и в целом Я занимаюсь как раз распределенными алгоритмами поэтому тем мне достаточно интересно так вот значит о чем будет презентация есть относительно новый 2021 году вышедший алгоритм для того чтобы понять нужно как бы пройти достаточно большой путь потому что нужно понять Те ограничения которые действуют в этой среде среде распределенных транзакций есть такой проект стропи которыми тоже помогаю вот он как раз занимается тестированием распределенных транзакций в различных СУБД Зайдите на сайт с тропе это такой недовольный ребенок значит это бенчмарк всех распределенных транзакций во всех распределенных системах которые есть то есть это как роуч монго значит сейчас это Яндекс Database все базы данных которые в каком-то виде погреce используется как Эталон которым Значит есть распределен транзакции стропия в Облаке Oracle и в Облаке Яндекс умеют проверять производительность этих систем Вот и по большому счету производительность неважно у всех в разной степени У меня есть по поводу отдельный доклад так вот аккорд это возможно ответ на проблемы производительности распределенных транзакций для того чтобы понять каким он получился я пройдусь немножечко по истории самой проблематике значит и просто скажем так вот есть около есть paxos который лежит в основе аккорда для того чтобы понять алгоритм paxos то есть кто здесь вообще смотрел мой доклад или докладе прошлом году про paxos я вижу там немного рук но вот смотрите если вы не понимаете пакес он будет очень сложно понять этот доклад для того чтобы понять paxos нужно Ну мой доклад просмотреть недостаточно скорее всего после моего доклада возникает матерные ощущения и хочется посмотреть что это нормально или почитать вот поэтому нужно потратить много времени чтобы понять по акции Значит есть около 40 вариаций алгоритм пакесаренс значит flexibles и так далее То есть огромное количество вариаций алгоритма и вот аккорд нужно понимать мы сейчас будем разбирать какие-то вариации уже алгоритм Но прежде чем мы вообще к этому подойдем сама саму идею просто Представьте Как использовать вот распределенное СУБД в ней там 100.000 узлов транзакция которая изменяет данные на всех узлах она как бы по идее должна затрагивать или коммуницировать со всеми этими узлами и при этом Да есть базовый свойства транзакций мы сейчас про них поговорим Она должна коммуницировать выстраивать определенный порядок строгий порядок да значит в котором выполняется изменения вообще есть два взгляда на такой на понятие порядка есть понятие сериала и забил эти сериализуемость это когда я как человек взаимодействующий СУБД Кстати если можно брать их было бы круто Я как взаимодействующий что все изменения которые я делаю выполняется исключительно для меня это можно так сказать но в целом база данных может кровать она может переупорядочивать фактические события когда создается конечная история то есть события между собой не конфликтуют то в истории они могут оказаться не в том порядке в котором они реально произошли это серия изобилити есть такой так называемый стриг тирила изобилити Да это когда мы говорим не-не У нас есть внешние Наблюдатели внешняя судья который нам собственно и является тем Вот арбитром который выстраивают эту единую историю то есть мы историю у нас не относительно нералитивистская история получается а единая история для всех участников можно есть еще такое понятие но это уже не совсем про базы данных Но вот серия это близко к сериала забил и понять Вот и обычно возвращаясь к этой истории смотрите у нас есть очень много узлов в кластере данные фрагментированы и нужно выстроить строгий порядок требуется коммуникация всех со всеми для каждой транзакции и нам нужно строго последовательно выстраивать эту коммуникацию одно за одной но естественно такая система Не может быть производительной а нам хотелось бы добиться производительности так вот Я сейчас буду рассказывать про то как длительная эволюция распределенного контроля транзакций привела к тому что мы сейчас видим как именно к производительному распределенному управлению начну Прежде всего я веду определенную модель значит что у нас есть вот эта проблематика под капотом этой проблематики лежит так называемая durable Store то есть дюра был значит что мы не заботимся о дробите в первую очередь мы заботимся именно о выстраивании порядка только Да вот и собственно я веду какие-то простые примеры всем известные вот что у нас есть конкретный кейс что у нас есть некий значит единый регистр Да что как бы мы вот смотрите тоже очень интересная история мы когда рассуждаем о базе данных мы рассуждаем как бы мы понимаем интуитивно что это множество ячеек с данными но транзакция менеджер этого знать за нас не может они может знать какие ячейки логически связаны между собой Поэтому с точки зрения контроля транзакций мы часто пессимизируем и часто считаем что фактически мы вообще работаем с единым регистром и вот уже только потом появляется вот эти детали Как мы можем собственно увидеть что фактически мы изменяем разные данные поэтому простейший истории Это единый регистр в котором лежат деньги и мы одновременно с этим регистром что-то делаем один значит кладёт деньги другой снимает деньги вот и мы хотим оказаться не оказаться в ситуации когда собственно у нас вся эта ситуация поплыла а поплыть она очень может очень просто работает указка или дневказка значит поплыть она может очень просто мы для того чтобы изменить данные мы оперируем с операциями какими-то базами поверх этого durable kevel Store на что может дюр был кивл you Store она может прочитать и записать да то есть мы даже сначала прочитать потом записать вот мы даем прочитали вдвоем изменили баланс и потом записали какую-то ерунду У нас вышло вместо результата уточка да при этом понятно и тоже это очень многих всех конфет когда они воспринимают модель просто хотел бы чтобы мы очень четко это дальше держали в голове что у нас есть чтение записи у нас нет всяких интересных операций таких как инкремент как сплайн как операции которые пришли к нам из мира cr-дити из мира коммутативных типа данных Да И вот традиционная транзакшнаулеры они работают записях едем дальше как бы для того чтобы разбираться с конфликтами в таких вообще разбираться с корректностью такой системы уже существует очень хорошо специфицированные значит сценарии они описаны в такой библиотеке называется Эрмитаж вот эти сценарии такие как фантомные чтения грязное чтение Да вот есть otv обзор транзакций то есть сценарии взаимодействия двух-трех клиентов которые приводят к аномалиям если не соблюдается вот эти как раз свойства свойства единого наблюдателя Кстати я еще раз хочу сказать если то что я говорю слишком понятно то можно дать реплику из зала я буду проскакивать дальше но только чему я подвожу это важно Вот то что сейчас говорю это важно для того чтобы понимать каким получился аккорд значит и в принципе все менеджеры транзакции которые там есть множество стратегий оптимистичных пессимистичный контроль да у них есть вообще две фундаментальные проблемы у всех распределённых алгоритмов проблем так называемым savefty то есть безопасность корректность алгоритма и лайвность то есть это устойчивость алгоритма к различного рода аномалиям по производительности да то есть в случае выхода из строя узлов в случае если у нас все клиенты начинают обновлять один и тот же ключ То есть у нас появляется контеншн Да вот вот эти два свойства соответственно классические ответы напомню Да является теорема 2pl и не надо путать с 2 PC который говорит о том что если мы последовательно значит накапливаем блоки в процессе выполнения транзакций потом эти Локи либо разом либо освобождаем уже в на этапе Когда мы уже перестали брать новые Локи это очень важно то есть мы не освобождаем руки и набираем одновременно Мы разделяем эти две фазы чётко то такой подход гарантирует нам что есть вот каждый участник э-э значит ну он дыхаллов да на стороне каждого участника у нас накапливаются такие Локи то он гарантирует нам сериал и у этого подхода тоже есть определенная проблема это в первую очередь если мы этот подход традиционный вот как Саша липунов говорил на предыдущем докладе в принципе это обратная сторона блокировщика да то есть и там и там осуществляется координация по чтениям и записи между разными участниками поэтому так важно понимать как бы чтобы то о чем я сейчас говорю оно касается всех подходов которые так или иначе трека чтение записи лока это способ трека чтения записи у него есть проблема особенно в распределённой системы да то есть мы вообще должны это где-то накапливать накапливать мы должны надёжно система распределённая соответственно всё это может отказать в том числе это состояние на которое мы накапливаем оно может исчезнуть то есть любые участник может исчезнуть да то есть мы должны отказываться очень образом накапливать и вторая История это то что мы Вы должны реализовать дистрибуты Так что по самым же само по себе достаточно сложная задача потому что для блоки могут быть теорема есть достаточно простое доказательство я вас очень хотел бы побудить это доказательство почитать у беренштейна ньюкамера на моем github есть книжка в PDF Просто введите бирштейн-ю камер там прекрасное доказательство теоремы через прослеживание зависимости построения графа зависимости от радиоактивных транзакций Ну вот есть такие истории Вот есть такой общий подход Да что мы каким образом можно получить сериал и здесь есть одна важный момент что все эти подход все такие классические подходы Они разрабатывались во времена когда значит деревья были большими а именно вообще вся история база данных это автоматизация тех бизнес-процессов которые происходили с нами в реальной жизни то есть сначала когда с данных появлялись фактически на it перекладывали те процессы которые уже были там принцип двойной записи такой принцип транзакционных переводов все эти процедуры они были отработаны для выполнения людьми поэтому Изначально и транзакции в СУБД они мимикрировали они как бы имитировали поведение людей и вот это вот история с интерактивностью что фактически мы не знаем На момент начала транзакции что как реально она будет разворачиваться сначала начинаем транзакцию потом читаем данные Потом значит принимаем какие-то решения эти решения возможно Ведут к тому что мы читаем ещё данные ещё и меняем одно меняем другое То есть у нас не детерминированное множество ключей с которыми работает очень важный момент Вот вот для таких вот именно кейсов тогда множество ключей не детерминированное у нас создавались традиционные транзакшн-менеджеры Ты посмотри на какой-нибудь здесь у меня пример с это туториал по хайбер нейт это джававский фреймворк по значит ОРМ javask такой то есть вообще сейчас куда не придешь это очень красивая история про Сбербанк и использование базы данных А мы можем прикрутить наш кибернейт к вашему на сикву Нет не можете Ой вы нам не подходите значит вот классические э-э значит менеджеры но он детерминистика или интерактивные вот а есть и другие транзакции которые уже появились в распределённом мире Они детерминистик то есть мы знаем полностью что транзакция делает заранее вот здесь конкретно на моём примере меня удивляет отсутствие кликера я просто покажу рукой наверное онлайн Люди этого не увидит но здесь у нас есть work-клауса и Project ID там полностью специфицирован то есть мы по первичному ключу мы знаем Какое множество первичных ключей транзакция изменяет заранее то есть мы можем посмотреть на этот на этот батч увидеть все первичные ключи которые изменяют если есть руки поднимайте Я не вижу то есть более активно значит вот для таких транзакций выясняется что все может быть гораздо интереснее например Давайте посмотрим классический алгоритм 2 PC по значит коммиту распределенной транзакции интерактивные транзакции с множеством участников у него есть фаза значит prepari у него у него есть фаза коммит Зачем нужна фаза прип почему мы не можем сразу всем послать фразу камень потому что выясняется что каждый участник он может откатить транзакцию например потому что у неё произошел тот самый дедлок или Deadlock или конфликт с другой транзакцией или тайм-аут Ну и конечно есть кейсы когда участник просто сломался Но вот самое важное кейсы это то что мы не знаем заранее до препаера вообще транзакции можно удастся закомиться или нет У нас появляется это неопределенность фаза неопределенность и естественно я не знаю кто изучает 2 PSY все должны прекрасно знать два писения обладают свойством лайвс То есть если между припеверамид у нас происходит авария то фактически такую транзакцию нужно особенно координаторы такой транзакцию нужно вручную фактически восстанавливать выбирать заново координатора и давать им задачу каким-то образом этот транзакция откатывать Вот соответственно и как я уже сказал 2 PC может откатить потому что есть такие всякие штуки есть тайм-аут есть ошибки координаторы есть логические конфликты из-за которых мы в принципе их можем откатывать вот Давайте попробуем подумать А как мы можем сделать распределенные транзакции если у нас нет требования сделать их интерактивными это ток мы уже начинаем подбираться к аккорду и Тут приходит в голову как бы стандартная идея все про неё там уже знают а давайте выберем какую-то сущность в данном случае у меня написано singles Red которая будет приходить все клиенты и он будет каждым клиентом выдавать тикет то есть грубо говоря я прихожу Я говорю Я хочу изменить такие-то данные мне говорят тебе Ты такой ты в очереди Вот и я знаю уже после того как мне его долететь Я знаю уже кто там конфликтует со мной Кто не конфликтует кто получил какие-то передо мной в очереди Да я могу с ним как-то разобраться дождаться И уже потом параллельно в порядке которые мне дал этот циклсор соответственно начать делать фактически изменения Но для того чтобы это сделать для того чтобы каким-то образом получив тикет разобраться Мне нужно знать мой райцент И мой рецепт я то множество первичных или вторичных ключей которые я изменяю Заранее как-то задекларировать всем рассказать обнаружить эти конфликты и тогда уже получив тикет я пойму как бы кого я дал Кого я должен подождать и выполнится после него А с кем я могу выполняться конкурентно и мы добьемся какой-то степени параллелизм да то есть напомню если у нас не стоит задача как бы это все распараллели то есть решение очень простое берешь учишься нахренешь даешь следующему очередь да Через один глобальный Лог То есть у нас такая особая Конечно будет работать а нам хочется распараллелить вот мы говорим что транзакции у нас детерминированные риды брать заранее известны Давайте раздадим все эти какие-то побежали опять же проблема этой истории в том что у sequence у синквинг такой подхода в распределенной системе ребята все как-то еще никто не заснулся как-то не потеряли еще нить кто потерял нить Ну ладно Будем считать что вы как бы я вам верю Хотя я в принципе достаточно подозрительный тип Вот но такого подхода у сиквенсора Да у него есть тоже челленджи да то есть мы во-первых он один вот самое главное проблема он один сиквенсор должен быть один как только мы нас распределенная СУБД Да мы вынесли один кусочек маленький кусочек потому что билеты выдавать это достаточно Простая история то есть нас не нет тяжелой координации но легковесная координация нас по-прежнему централизована во-первых он один во-вторых собственно когда мы говорим по любым изменениям которые увлекают например вторичные ключи то мы уже заранее сет уже не можем сделать да тогда приходит нам голову другая история давайте сделаем так называемый драйран да то есть Давайте всухую выполним транзакции посмотрим ее сет потом будем когда выполнять Второй раз мы будем коммитить только при условии что риды не изменились и вот такого рода они возвращают нас опять же в реале конфликтов потому что у нас появляется ретра и так далее То есть такой подход тоже работает сам подход с Double execution тоже фактически удваивает издержки на СУБД потому что мы сначала должны выяснить 3 а потом уже значит вы пока дома выполняем и фактически повторно читаем все эти данные значит но тем не менее Вот если посмотреть на такие достаточно известные суды то они идут по подходу так или иначе секвенсоры они его шортируют шарнируют они его сложно делает целую иерархию то есть отдельная история с значит вот Это насколько я помню это скриншоты который используется в Google spaner и фауны потому что я так понимаю Яндекс похожим образом работает значит есть как бы двойная приписка то есть и собственно мы Да собственно зачем я вам про это рассказываю это сложно вот просто шортирование секвенсора это сложно здесь двойная иерархия все равно это не избегает коммуникации мне сейчас вам надо рассказать ещё больше сложных тем Поэтому вот Как это работает мы даём пропустим суть того чего того зачем это вам говорю что в целом у нас есть вот два глобальных подхода в распределённых транзакций налево и направо налево это сиквенсоры это сардировать да и так далее направо Это так или иначе пытаться поддерживать интерактивные транзакции пытаться поддерживать распределённые снабжатой silation и так далее вот аккорд он как бы вы пошёл по пути не то что шарнирование децентрализации это одна фундаментальная идея которая бы хотел чтобы у вас осталась да то есть вот если всё пространство распределённых менеджерах транзакций распределить разделить пополам То будет вот эти вот ущербные менеджеры для терминированных транзакций которые потенциально а-а дают гораздо большую производительность чем полноценные Ну и вот аккорд пошёл по пути таких менеджеров дальше собственно А как конкретно мы можем избежать вот эти вот повторного чтения Нам нужен какой-то синтаксис который бы позволил заранее декларировать 3D rateset Но при этом был бы достаточно гибким И в кассандре разработали такой синтаксис то есть мы там есть кондишены там есть селекты там есть значит декларации переменных Да но в любом случае перед выполнением мы можем посчитать собственно вот эти все праймерики с которыми транзакции работают очень важно Очень похоже между прочим на тарантульную историю что таранту детерминированные транзакции вот здесь тоже детерминированный подход Окей А теперь нам нужно а значит попробовать сделать сиквенсор децентрализованным То есть вторая история которую мы хотим это сделать его по-настоящему по-честному без всякого рафта и то есть использовать принципы пакеса для того чтобы его реализовать и Значит есть похожий алгоритм реализован это Paper нигде не был реализован пеперо называется темпа Вот соответственно идея этого подхода Я сейчас буду немножечко подбираться составить в том что вот смотрите как работает базовый пакса мы сейчас про это более подробно разберём Но вот на пальцах говорить что вот все участники они равноправные и тот кого самый старший кто-то является победителем в одном конкретном раунде соревнования кто-то за комиссии транзакцию Темп говорит следующее а давайте сделаем так что участники получив этот беллет если у них допустим возник конфликт они могут также этот конфликт разрешить с помощью некого внутреннего порядка который мы заранее установим они могут например отсортировать Все изменения по своему идентификатору да то есть в пределах одного конфликта Вот примерно такая идея на этой идее строится аккорд только одна из Вот соответственно по-прежнему на все равно это не решает проблемы с горячими ключами Потому что если все участники то они соревновались за беллет А теперь у нас они начинают соревноваться за хот-кейс то есть даже если у нас есть какой-то порядок в пределах одного белта если все равно идет конфликт между транзакцией по чтению записи одних тех же ключей это конфликт также надо разрешать Вот и Еще одна история которая проблемная пакеса это то что обычный пакес он все-таки выполняется за несколько раундов за два за три Вот то есть мало того у нас есть вот это неопределенность мало того нас есть этот контент для того чтобы закомитить транзакции нам нужно два-три раза пообщаться со всеми её участниками а то и со всеми узлами кластер да то есть мы по умолчанию считаем что все узлы кластеры должны все-таки принять участие в либо в лесу и вот здесь вот я бы хотел пройтись по базовому паксу да то есть смотрите базовый пакса говорит что на первом раунде Мы предлагаем некое значение даже не значение а мы просим разрешение предложить значение если мы победили на самой большой балл это на втором шаге мы на маджорите участников пытаемся это значение записать на третьем шаге если у нас все получилось Мы можем уже все majorty сказать все данные законечны в принципе третий шаг он может быть асинхронным но тем не менее он присутствует Вот и есть другая история которая говорит о том что попробовать это все сократить за меньшее число раундов Как вы знаете в принципе был предложен в своё время и если почитать сам Paper то Он предложил как бы от противного он очень во многом сформулированный от противном мы говорим о том что при если мы хотим чтобы система переживала до половины выше участников мы должны Акцепт и так далее Давайте попробуем в это заглянуть чуть поглобже А собственно Почему мы должны это делать представим себе что мы вместо prepare делаем Акцепт сразу Акцепт действительно мажорити достаточно Посмотрите можно разобраться что здесь произошло в такой системе пришло два клиента один получил другой гарантированно не получит маджорити да То есть в принципе мы можем сказать что вот первый закамметился request 2 не за комедился потому что маджорити у него нет вот как бы кто может сказать чем проблема с таким подходом Зачем нам нужен дополнительный раунд Почему нам сначала должны сделать сейчас я попробую отмотать Зачем нам нужно сначала получить беллет записать его везде а потом делать Вот эту вот фазу вторую Акцепт именно с тем Бейл этом который предварительно получили не слышу верно было репликой зала что нам нужно как-то восстанавливаться после сбоя Да вот так вот это все выглядит хорошо предположим что это надо вырубило да Если разобраться в том Кто победил вообще невозможно поэтому существует эта фаза фаза что если у нас здесь вместо Акцепт сидит прополз прополз беллад и одно из нот вырубил нас ничего страшного не произошло он нас транзакции не закатилась просто есть два белла-то но до вырубило оба этих беллата мы можем принципе не завершать транзакции либо выбрать того кто любого и завершить его это наше дело ничего страшного суда не произошло никакой неопределенности не возникает А здесь у нас получается определенное неопределенность мы не знаем как Recovery такой классный в случае выхода из строя и для того чтобы поработав с этой интуицией был предложен тем же импортом алгоритм Фаст который говорит что смотрите если мы немножечко увеличим размер кворума а немножечко это именно с половиной плюс один до трех четвертей + 1 то мы можем в принципе разобраться да то есть у нас уже при выходе строя у нас уже сохраняется этот принцип мажорити мы можем понять что действительно клиент Один он заканчился клиент давал не заметился и нам нужно просто сделать так чтобы данные клиенты один оказались на всех узлах вот мы таким образом эта интуиция которая опять же смотрите фосфакция Пеппер на 41 страницу который нужно прочитать пять раз чтобы понять сейчас просто говорю на уровне интуиции Это только один кусочек аккорда то есть мы с вами говорили мы подводили про то что мы берем пытаемся начать применять на весь кластер он у нас медленный он у нас приводит конфликтом он нас приводит к контент-шну мы сейчас разобрали только один Аспект который оптимизируется в аккорде а именно в городе по умолчанию используется необычный паксы а Fast paxi да то есть на один раунд меньше Вот и также в аккорде предложено такое понятие как флекси был кворумс мы сейчас про это тоже подробнее поговорим То есть фактически как бы Почему фаст-паксос не используется в промышленности так вот особо не внедрены смотрят шейпер существует там полтора десятка лет если не больше потому что во-первых на маленьких форумах фастфором и обычный форум Они совпадают по размеру если у тебя три реки то фаст-корум у тебя три обычный корм у тебя два Это примерно одно и то же то есть реально фастфорам у тебя ты не можешь вообще ни одной ни одного фейдера Да ты не можешь пережить даже выхода из строя нет а особо но если менять форумы динамические чем говорит аккорд тоже возможно во-вторых потому что реально у нас так кормы в геораспределённая системах могут быть гораздо больше то есть встретить там кассандру который 9 реплик вообще легко да то есть они будут три реплики в одном центре реплики в другом это актуально Поехали дальше значит А как формализовать принципы да то есть принцип фосфакса вводится понятие такая которая называется Recovery кворум то есть мы говорим что Когда произошла авария мы должны выполнить определенную процедуру А с учетом того что мы должны пережить выход из строя до половины узлов это процедура может имеет право увлекать максимум половину узлов плюс один и вот это половина узлов плюс один и есть Recovery corum процедура должна быть такая что мы собираем данные с половиной узлов плюс один и на основе этой информации можем понять комедии транзакцию или реджектить так вот если формализовать интуицию фосфакция то вот этот самый рекавери кворум он работает Ровно до тех пор пока у него есть пересечение с любым фаст-кворумом да то есть вот пересечение Что означает что он прочитает те данные которые записали транзакции которые использовали фаст-квормы Вот именно поэтому и требуется три четверти Да потому что три четверти пересечь три четверти получится половина такая вот Интуиция дальше река мы пропустим Это только один пункт мы говорили но теперь мы будем подбираться уже к истории с контеншеном да то есть мы говорим про выстраивание некого порядка хорошо мы договорились о том что у нас на один раунд меньше Но нам по-прежнему нужно получить корм из тысячи узлов чтобы заметить элементарную транзакцию Давайте попробуем разобраться Почему собственно нам требуется такой большой кворум Почему нам нужно стерилизовать все действия даже когда мы коммитим простейшие транзакции Вот это кейс классических ножниц один из классических конфликтов в менеджерах всех транзакций То есть у нас есть значит Алисы Боб и они переводят деньги друг другу перевод денег друг другу это значит я прочитал X Ты прочитал Y значит Я теперь хочу записать Y а третий переходит записать X кто из нас должен идти первым и ты не можешь идти первым я не могу идти первым потому что это будет неправильно я начал свою транзакции на основе устаревшей информации ты начал свой транзакции на основе фактический информации Вот и фактически для такого рода кейсов Есть только два валютных расписания которые совпадают Либо мы полностью поместили значит Да X Y извиняюсь Конечно я прочитал X и Y и ты прочитал и X Y потом мы пишем X Y вместе И вот это действие которое я тут выписал видео расписание есть такой более формальный подход когда мы все чтения записи вы выписываем в виде некоторой последовательности осенняя зеленая это расписание первой транзакции расписание второй транзакции да То есть можно посмотреть на эти действия то есть для выстраивания фактического порядка этих действий Есть только два валидных порядка то есть либо мы всё синее ставим сначала Либо мы всё зелёное ставим сначала Да а всякие миксы уже не допустимо Вот и за счёт того что транзакшн менеджер Он же не знает что транзакция потенциально прочитает сейчас мы подбираемся к этому ценность э-э вот этого рейда Если мы знаем заранее что транзакция считает мы можем вылавливать такие кейсы заранее вот и но в любом случае транзакция менеджер должен каким-то образом А разграничить эти процедуры и здесь а как бы в классическом фактусе У нас есть всего лишь один балл это как я уже говорил Да ради которого мы соревнуемся мы выровняв это все мы должны дать один Слот заранее и в epaxos то есть это другое совершенно Paper мы говорим о том что у нас потенциально на один и тот же балл это может быть несколько слотов вот которым мы можем пропускать не конфликтующие транзакции не конфликтующие Обратите внимание то есть вот все для этого кейсом к нему только подбираемся мы можем как минимум видеть тех транзакций которые между собой не конфликтуют значит помещать их в разные слоты 1 это уже одно и то же как бы журнала и вот эта змейка которую я нарисовал здесь как раз позволяет нам выстроить некий глобальный порядок то есть она логический порядок выстраивать среди Не конфликтующих транзакций окей а что же делать с конфликтующими транзакциями это как бы последнее как бы фактически Бастион который нам нужно взять и мы говорим о том что А что если мы вообще откуда возникает конфликт если вернуться к этому Вот к этому кейсу конфликт возникает от того что эти ребята пришли одновременно Да они сначала читали оба и мы это разрешили Потом они стали писать оба и мы им это тоже хотим разрешить А что если мы не будем не то что им разрешать читать У нас есть 30 Давайте давайте сделаем некий отстойник который будем называть ребордер буфером значит который позволит нам видеть все такие ситуации и фактически на этапе еще как бы регистрации в очереди значит выстраивать некий порядок Хорошо но у нас же распределенная система Мы же не хотим это же фактически seconcer Да а как нам сделать распределенный сектор А давайте этот сикер будем условно говоря хранить на всех узлах участники все транзакции они будут посылать свои изменения во все значит узлы которые участвуют транзакции сейчас об этом чуть подробнее расскажу не во все узлы кластер Обратите внимание Но при этом надо пройтись отдельно по умолчанию фактически Мы обязаны посылать на весь кластер у нас есть кворум и мы должны всех участников корм как бы ведомить о том что мы делаем Ну вот на всех узлах у нас появляется так называемые ордер хорошо А какого размера должен быть буфер и выясняется что рёбер буфер может быть примерно хранить историю которая равна Clock дрифту между часами у разных участников То есть если у нас есть два дата-центра в этих дата-центр чаще всего стоит какой-то способ синхронизации часов внутри дата центра более-менее корректное время Вот Но между разными серверами в дата-центре может быть какой-то отставание Вот на размер этого отставания плюс размер дистанции который должен пройти пакет между двумя дата-центрами нам нужно и нужно аллоцировать буфер на каждом узле то есть вот эта вот история с измерением незнания она очень важная причем эта штука Она работает не как корректность какая-то процедура работает Как именно Как лайвность процедуры то есть наличие такого ребер буфера на все ускоряет если у нас Даже несмотря наличие Рейдер буфера прилетела какая-то транзакция которая каким-то чудом сообщают что она из будущего Да мы просто так из прошлого Я извиняюсь из прошлого мы просто посылаем такой транзакцию нафиг говорим что нет Извини значит мы тебя выполнять будем вот ри ордер буфер на каждом узле так и этот треугольдер буфер как бы позволяет нам вот именно самое сложнейшие конфликты порядочивать хорошо но представим себе что кластер у нас действительно большой и вот здесь я написал кластер нарисовал кластер который состоит из трёх репликасетов значит и вот красный голубой и зеленый Неужели нам все транзакции нужно верифицировать на всех репликах здесь приходит еще один Paper который говорит о том что на самом деле если мы правильным образом управляем кворумами то есть нас кворум это не абана большая толпа который включается узлы а она к вам он вычисляется в зависимости от того какие какой риды брать эту транзакции в данном случае вот у меня T1 она пишет ключ бы пишет Так вот мы можем сказать что ты один может работать только с репликами для репликами для б Т2 может работать и если вот все эти принципы принципы валидации принципы принципы кворумов соблюдаются то для того чтобы закоммитить один Нам нужен фаст-квором который состоит из фосфоровым значит красного и голубого Да и Recovery кворум у него такой же будет и dt2 мы тоже можем использовать и Фаст форумы обычная Recovery форумы которые являются фактически набором из-под кормов то есть вместо того чтобы сделать один глобальный кворум для всего кольца мы создаем дерево кворумов и При учете голосов используем говорим так что у нас должен быть мажорити красных мажорити зеленых Тогда все окей и этот уже последний как бы шаг Он позволяет сделать действительно масштабируемое распределенный алгоритм который не вовлекают все узлы кластеров Комет каждой транзакции которые не приводят конфликтам и который линейно масштабируется с ростом кластера при условии что у нас есть эти самые значит детерминистых транзакции да то есть который мы риды братья до которых мы знаем заранее вот пожалуй все Все это в целом и делает аккорд аккордом Я сейчас пройдусь базовую по шагам аккорда то есть значит и мы как бы уже подведем какие-то итоги я перейду к вашим вопросам значит смотрите первый шаг реакция поместить Мы берем наш значит риде брайтсет заранее мы его знаем И отсылаем на всех участников вот эти вот голубые красные кормы корм для этого вычисляется относительно этого видать этот слайм для того чтобы А еще мы назначаем этому довольно сложный он состоит из реального времени из нашего ID из некого сиквенса про этого можно поговорить отдельно но концептуально это некий монотонный и отсылаем его на валидацию В результате валидации мы можем получить ответ О'кей У меня нет никаких конфликтов и твой тайм-стайм который ты мне предлагаешь самый большой комить если мы такой ответ получаем от всех то мы пропускаем фазу Accept Ну нету нету кликера фазу акцент пропускаем вот ту самую фазу Accept Вот а если же мы получаем ответ и такое что Слушай ты знаешь у меня есть незакомичные транзакции которые имеют значит сравнимый с тобой таймс Да и тебе там лучше во-первых увеличить чтобы он был больше всех а во-вторых нужно дождаться пока они закомятся Потому что есть конфликт по виду в этом случае мы делаем фазу Акцепт отдельно в которой мы комим фактически то есть мы выбираем самый большой таймс Темп из всех таких ответов и рассылаем на рептики Окей принято Я по-прежнему хочу закатить свою транзакцию но Пожалуйста запомни что у него будет такой там и мы также отсылаем все наши dependence Всем участникам зачем Потому что если придут следующие следующие они увидят то что пытаемся сделать мы и увидят конфликт понимаете мы вместо того чтобы спрятать конфликты мы наоборот сообщаем конфликты Всем участникам в ответ на это нам на Акцепт приходит OK то мы переходим к коммиту камин сам по себе еще не чего не выполняет он просто фиксирует транзакцию как выполнены Зачем нужно фиксировать транзакции потому что я жду другие их тоже нужно зафиксировать как выполненные Да но зафиксировать транзакцию как выполнены мы можем только зафиксировать только тогда когда все предыдущие от которых она зависит тоже выполнились успешно Окей мы сделали коммит и в конце концов до нас доходит очередь мы делаем Рид уже чтение данных вычисления транзакций создание изменений и оплаты фактически сама транзакция выполняется в самом конце А на этапе вот этих трёх раундов мы просто обмениваемся изменениями вот такой вот итог значит если говорить о недостатках но я скажу сначала преимуществах допустим поговорить о кассандре у Кассандры очень ненадежный storage да то есть Кассандры модель вот этих координатор Бейс репликации которая в принципе очень плохо работает в с точки зрения евробилось вот этот протокол идеально ложится поверх Кассандра взять тот же Тарантул там у которого есть мемчик-савинил Да пожалуйста это протокол ngnostic это протокол не требует никакого vcc он работает поверх транзакции там обычных самых которые есть Вот какие же недостатки самое главное проблема это все обновления ПО вторичного ключу значит и Ну пожалуй еще никто не реализовал есть реализация на 20 слов которые мало кто понимает вот Ну и самое наверное большое недостаток это то что мы еще не знаем Насколько большой сетевой трафик для реалистичных транзакций там вот у нас обмен этими депонентность Это же все же Касты Да Алексей всех нужно рассылать но потенциально это меньшее число равных трипов чем какого-нибудь Foundation db который делает поверх Крафта вот так Но на этом все такое вот видение пожалуйста вопрос и это было только введение Так ну что переходим к вопросам Давайте далее начнем начинаем отсюда следить Что там у нас в онлайне Я думаю там есть вопросики Спасибо бомбические доклад на последнем слайде Ты рисовал три две транзакции три цвета кластеров но Насколько я понял цвета кластеров они должны быть по данным которые задеты правильно Нет назначил свой цвет чтобы было проще чтобы нам было проще То есть фактически а это синоним красного а б это синоним голубого БЦ я еще подсветил цветами каждый цвет это реплика реплика сет понимаете что такое Это не гомогенный кластер это Три разных кластера это шортированный класть и в этом основная проблема как бы распределенных транзакций они должны работать поверх шарнированного кластера да и вот этот кворум он как бы говорит мы говорим что мы должны набрать кворум то есть мы как бы Когда я не знаю какой у вас бэкграунд Да но мы привыкли когда думать там о том же тарантуле если Гранта то вы не воспринимаете этих эти три реплики как независимых участников воспринимаете как один репликат аккорд их разрывает он говорит что каждый из них она независимая участник всему не нужен raft под капотом не нужна какая-то репликация под капотом он будет работать поверх всего этого ну просто нужна а-а durable Store на каждом узле но с точки зрения аккорда эти реплики они будут содержать копию друг другу Он уже обеспечивает эту копию её не надо как бы использовать никакой репликации для того чтобы это работает Окей Спасибо Спасибо Давайте на первый ряд передадим микрофончик может кто-то помочь сюда с микрофоном и начнем с конца вот да да Можете пожалуйста уточнить как в этом алгоритме генерируются там с темпы нет Откройте Paper и там написано там трехкомпонентный timestemp хорошо Просто если здесь проблема дрифта часов какая-нибудь или я уже об этом сказал что проблема дрифта часов решается тем что риордер буфер выбирается на размер дрифта и фактически когда мы назначаем тайм Темп мы Откройте Paper это не одно число отрезок часы таймс Темп трехкомпонентный он состоит из тех из того времени которые локальная для каждого участника она назначается координатором транзакции из его идентификатора и сиквенро но за счет того что у нас есть фаза Акцепт мы гарантируем что им перед коммитом будет скорректирован то есть фаст-паф так называемый который не имеет фазы Акцепт э работает только если мы не имеем конфликта в том числе по часам то есть мы выбираем это локальное время если мы в данный момент одни вот во всём Что называется чистом поле которое меняет эти записи только какая разница какое время мы провели нету никого поэтому локальное время сойдёт А если мы видим что кто-то ещё пришёл со своим локальным временем кто-то ещё и все эти транзакции находятся в риорде буфере то это означает что потенциальный конфликт и тогда нам возвращаются время каждого участника который с нами конфликтует Мы среди них выбираем самое большое и еще к этому прибавляем единичку в secons numberry и уже сделаем фазу Акцепт Спасибо за вопрос и это позволяет Вот вы наверное не понимаете что это не приводит к competition который то есть в паксусе и это позволяет очень элегантно выстроить глобальный порядок Потому что они все упорядочатся уже потом посикамберу и по идентификатору локального узла координатора пожалуйста тарука давайте я буду отправлять здесь сидит молодой человек давно поэтому пожалуйста первый ряд продолжить можно будет обсуждение да да микрофон здесь Здравствуйте спасибо доклад Вот как раз у меня небольшой вопрос по слайдам с кворум я правильно понимаю что интуиция такая что мы если у нас есть хоть какой-либо конфликт даже минимальный транзакции то мы должны собирать форум на все вообще если у нас есть конфликт то мы об этом узнаем Из ордер буфера и конкурировать Б поэтому выбирали например на Первом транзакции красный и голубые мы должны собрать фактически не к вам а объединение форумов то есть вот этот вот F1 это увидьте вот эту галочку перевернуты это и тот кворум этот это стандартном понимании Я понимаю что это тот корм разные и о том что любой минимальный конфликт если у нас получается большая транзакция даже если конфликт всего по одному шарду заставляет нас начинает собирать объединение вообще всех неверной партийцы под кворумс они определяются на основе вида В райта наличие или отсутствие конфликта не влияет Вот вы меняете ключи А ключице значит нам нужно получить корм со всего кластера Если вы меняете только А если у вас фактически так называемый там реплика Local транзакции вам вообще не нужна координация вы выполняете их так же как и выполняли раньше конфликт здесь не имеет никакого значения Конфликт это минутная ситуативная вещь а кворум вычисляется на основе ряда раритета Я примерно в этом просто наверное слог делюк неправильно использовал но Вы ответили вам слышно вопрос Спасибо большое за вопрос Давайте вот туда передадим и следующие вопрос может быть 1-2 еще отсюда успеем Передайте пожалуйста микрофон меня на самом деле не ошибки Спасибо большое выходите сюда тогда открой пожалуйста слайд где у тебя в одной строчке слова ну в начале там написано Да там возможно что я не туда это приписал ну да Несмотря на то что Google спанеры Кельвин Пейпер вышли в один год это Paper и про разные вещи Да да я неправильно сказал на самом деле правильно написал прям на этом слайде вернись пожалуйста Назад да то есть Я же здесь даже противопоставляю то есть есть спандер пошел налево Big Tail пошел направо Совершенно верно пойдем дальше это никому не интересно поправишь эти детали в оффлайне и здесь был вопросик с микрофоном Я надеюсь Да человек уже сидит пожалуйста Привет Спасибо за доклад Привет У меня вопрос Следующий кажется что стрикс это гарантия которую нужно в принципе далеко не всем и для неё есть более простое решение пластыри в котором только один ведущий узел да Тогда не нужно делать распределенные транзакции И вот мне интересно узнать с твоей точки зрения насколько вообще много есть там Реальных Юз кейсов которые востребованы в бизнесе когда нужна именно такая штука да именно распределенная транзакция планирую разбогатеть Я говорю без шуток Окей понял спасибо у нас Время вышло Давайте последний вопрос из онлайна чтобы ребят тоже в трансляции не обидеть а дальше всех пригласим в зону дискуссии с Константином пообщаться Да в онлайне чопин Даниил спрашивает размер reorder буфер должен вычисляться по ходу или задается заранее Нет он смотрите Не неотъемлемой частью этого алгоритма является обмен участниками Clock Drift то есть Клод дрифт вычисляется Там есть целый ряд алгоритмов в ntp используется например один из вариантов он вычисляется обмениваясь пакетиками между участниками то есть мы посылаем между дата-центрами тенге в тенге зашиваем наш текущий таймс Темп сравниваем его с локальным таймс темпом при получении и на основе этого вычисляем размер окна Вот и как бы он не в байтах он в секундах миллисекундах Спасибо за ответ Спасибо за вопрос в онлайне давайте выберем лучший вопрос из тех которые задали Я так думаю что там еще будет что спросить за пределами мне сложно выбрать лучший вопрос честно то есть я бы потроллил аудиторию ребята За это время невозможно не понять не это самое но я надеюсь что я у вас появился интерес к этому всему Вот и самое прикольное мне показался вопрос про то каким значит Каким богатством может привести знание этого алгоритма вот поэтому Давайте Вот это крайние вопросы зала пожалуйста вручим подарок и поблагодарим ещё раз Константина за доклад наконец-то было хордово подарим подарок небольшое от программного комитета Яндекса Спасибо до встречи"
}