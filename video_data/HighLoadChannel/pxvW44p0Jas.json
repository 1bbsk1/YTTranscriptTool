{
  "video_id": "pxvW44p0Jas",
  "channel": "HighLoadChannel",
  "title": "Пуш-уведомления в RuStore: как мы сделали свой транспорт на замену Google Firebase / Кирилл Алексеев",
  "views": 377,
  "duration": 3206,
  "published": "2023-10-06T07:22:53-07:00",
  "text": "друзья Всем привет Меня хорошо слышно отлично меня зовут Кирилл Алексеев Я первый раз выступаю на хайлоуиде и в целом на оффлайн конференции Мне очень приятно видеть что столько людей пришли послушать мой доклад Я думаю что будет очень интересно я сегодня буду рассказывать о том как мы в русторе сделали свои push-уведомления конкретно транспорт на замену Google firebase для Android то есть мы можем посылать путь уведомления в обход инфраструктуры Гугла Я учился на факультете вычислительной математики кибернетики в МГУ там я получил диплом бакалавра и диплом магистра параллельно с учебой я пошел на стажировку в почту mail.ru вот уже более 6 лет назад и сейчас я руковожу несколькими командами бэкендов почте сразу небольшая вставка по ширу Store откуда почта продукт сторону начинали его пилить ресурсами почты поскольку Простор был молодой проект и не сразу успели нанять достаточное количество людей так же как уже вам сказали Я играю на гитаре В группе дела поважнее И в силу своей проф-деформации я также там и карточки в научную не двигаю rustore это магазин приложений для Android подобный Google Play подобные свои функциональности но в чем-то как мне кажется даже его превосходящий мы делаем его не одним и делаем его с коллегами с другими большими компаниями в российском it и при поддержке Министерства цифрового развития на слайде вы видите qr-код Если вы разработчик Если вы пользуетесь рустом как разработчик то пожалуйста сканируйте qr-код оставьте свои контакты Если вы желаете поделиться фидбэком и помочь нам сделать продукт еще лучше выведение я расскажу о том Почему мы вообще решили ввязаться во всю эту историю Какие требования Мы предъявили к сервису которые хотели разрабатывать далее я покажу что у нас примерно получилось как этим можно пользоваться и так вам будет проще понять наша архитектурные решения в части мобильных sdk и в части бэкенда далее расскажу о том как мы эксплуатируем сервис как мы будем стараться держать высокий Sli поделюсь опытом интеграции рустора в почту расскажу какой был процесс интеграции Какие проблемы возникли и поделюсь промежуточными результатами и начнем с того Почему мы вообще решили заняться этой задачей все пуш-уведомления отправляются на мобильные устройства через IP операционных систем то есть Вот например Google есть своя пи уплате своя пи Если вы хотите послать push-уведомления на телефон Android то Для этого вам нужно сделать запрос на Гугла и дальше уже бэкенд Гугла доставляет пуш на мобильное устройство из этого следует очевидная проблема если Google решает нас заблокировать то есть не позволяет нам больше слать пуши то нас больше не ходят и естественно наши пользователи не в курсе того что там не мы виноваты в том что сломались пошли что нас заблокировали и в принципе они не обязаны этого знать для них приложение потеряла часть полезной функциональности и стала менее актуальным То есть например в приложении почты больше не приходит pushi о новых письмах Мы решили зафиксировать требования к сервису которые будем прорабатывать и самое первое требование это сервис должен предоставлять возможность подписываться на пуши для конкретного приложения на конкретном физическом устройстве и отписываться от них должна быть возможность сбытен до отправлять пуши на конкретное физическое устройство на конкретное приложение на этом устройстве и причем Push должен дойти мгновенно если устройство находится сейчас в сети если же устройство не в сети то мы должны сохранить Push во временное хранилище на диске и доставить пуш когда устройство снова появится в сети мы должны переживать уход одного до центра из трех при этом мы должны насыпать как можно меньше ошибок потерять Как можно меньше пушей и не создать дубликаты пушей сервис должен быть безопасным это значит что ну как минимум не должно быть возможности с насколько прочитать чужие пуши или там отправить Push в чужое приложение например там Back and почты отправляют Push в Back and облака и мы должны быть устойчивы к атакам типа denail of Service и вот было бы очень хорошо для всех нас если бы наш сервис нес минимальный оверхед на интеграцию в текущую схему например там для того чтобы заменить firebase на наш сервис есть уже довольно много сервисов похожих которые предоставляют такой функциональность Например у Гугла свой у эпла свой у Huawei свой но они все довольно похожи и оперируют похожими сущностями в каждом таком сервисе есть некая строчка с со случайными символами которые идентифицируют конкретное приложение на конкретном физическом устройстве и такая строчка обычно называется пустотин Сам же пуш по сути это некий произвольный payload некий Джейсон который пробрасывается на мобильные устройства и часть полей обрабатываются операционной системой а часть полей обрабатываются клиентом то есть конкретным мобильным приложением Например на этой картинке вы видите titles title и в этом случае на iOS отрисовался бы пуш Вот с таким тайтлом важно что каждый такой сервис это некоторое нативная фича операционной системы то есть встроенная в операционную систему и она пользуется теми возможностями которые нам как сторонним разработчикам недоступны и сложность нашей задачи состояла в том чтобы реализовать аналогичный сервис который будет давать не хуже производительность там по задержке доставки по Delivery рейту пользуюсь только тем что нам доступно и вот здесь могу сказать про Android про iOS в отдельности для iOS мы не нашли возможности гарантировать какую-либо задержку доставки то есть нет возможности запускать наш код на iOS устройстве в фоне через конкретные конкретные периоды времени Поэтому iOS Мы решили отложить и сконцентрироваться на Android потому что на Android такая возможность есть о чем я тоже позже расскажу подробнее для того чтобы включить push-уведомления в ростор нужно пройти в консоль разработчика и собственно включить там пуши в этом случае у вас генерируется идентификатор проекта которым вы будете пользоваться для того чтобы указывать его регенерации по штоке на при отправке пушей и несколько сервисных токенов сервисные токены это секреты сенситивные данные которые используются для авторизации на отправке Пуша с вашего бэкенда в нашем случае их можно выписать несколько для того чтобы была возможность бесшовно иммигрироваться чтобы вы сначала поддержали на бэкенде один токен и потом отозвали старый И также у нас к одному приложению можно выписать несколько пуш проектов несколько идентификаторов проекта это полезно для того чтобы разделять деф секреты и про секреты то есть для того чтобы Вы могли в деве иметь секреты для отправки пуш токенов на вашем бэкенде и не тащить их продакшена чтобы не было возможности их скомпрометировать в деве наша sdk для Андроида повторяет интерфейс sdk firebase Мы стремимся к Drop in replacement У нас есть такие же методы как у firebase токен это токен который регистрирует новый пуш токен и отдает его наверх приложению чтобы приложение его отправил на свой бэкенд метод Delete токен это противоположный ему метод который инвалидирует существующий токен и после инвалидации по нему больше ходить не будут и также можно определить несколько калбеков sift позволяет перехватить пуши обработать их произвольным способом он New token позволяет узнать о том что появился новый пуштокин и пробросить его на бэкенд он долей этот Messages позволяет узнать что какие-то пуши были потеряны например из-за того что у них стекло время жизни это все Аналогично Google firebase Так выглядит пример запроса на отправку Пуша в случае с опишкой Мы тоже стремимся к Drop in replacement мы повторяем схему запроса схему ответа Google firebase firebase есть два типа пушей первые notification позволяет отправить Push который автоматически отрисовывается операционной системой а второй дата пуш позволяет отправить Push который не будет автоматически отрисован но в него можно засунуть какой-то прилот и дальше клиент сам решает отрисовывать его или нет В данном случае будет отправлен пуш titlon Hello world здесь важно отметить что у Пуша есть какое-то количество предопределенных системой настроек таких как например цвет Пуша иконка картинка и часть из них мы поддерживаем Вот именно те которые я перечислил их отрисовывать наши языка Но есть часть полей которые мы пока не поддерживаем например приоритет ушей наша мобильный sdk состоит из двух частей клиентская и хостовая хостовая часть встраивается в рустор и она Собирает все пушины девайсы и дальше рассылает их уже конкретно приложением внутри девайса из этого следует логичное ограничение у нас не будут ходить пуши для юзеров у которых нет рустора на девайсе но зато мы имеем возможность получать все пуши ровно через один высокий и дальше рассылать их уже внутри девайса а не держать отдельный вебсок Для каждого приложения что могло бы Например потреблять аккумулятор юзера клиентская sdk это городский то есть ДК которая разработчик встраивает свое приложение подобно Google firebase sdk и оно содержит все эти методы про которые я рассказывал до этого и здесь важно отметить что клиентская их основа языка при инициализации запоминают друг друга по package name это нужно для того чтобы например не было возможности подставить какой-нибудь там третье приложение чтобы злоумышленник поставил третье приложение которое будет притворяться рустором и перехватить перехватывать пушкины у клиентского языка и соответственно когда клиентская СДК выписывает новый пуш токен оно пробрасывает его приложению приложение пробрасывает его на свой бэкенд но также оно отправляет этот токен хастовому sdk чтобы хастовой СДК получала по нему пуш уведомления Я на оффлайн прогоне понял что наверное secons диаграммы будут видны не целиком Если вы что-то из этого не поймете то не волнуйтесь у меня будет в конце ссылка на слайды Вы можете позже на слайдах посмотреть и также я каждую стрелочку и название компонентов буду проговаривать так вот когда sdk клиентская передает новый пуштокин хостому из ДК простого издака добавляют его в свой локальный кэш и начинает по нему получать уши конкретно хостовые СДК идет в наш бэкенд открывает новый веб-сокет в этот веб-сокет начинает слать запросы на подписку по всем пуш токенам которые у него есть если запрос на подписку проходит успешно то дальше в этот вебсокет нам начинают сыпаться пуши от backendo в реальности большую часть пушей мы действительно доставляем через вебсокет доставляем мгновенно но во-первых вебсокетом может не быть да телефон может быть просто в оффлайне а во-вторых довольно сложно на попса в системе реализовать стопроцентный Delivery поэтому Push может потеряться пока он летит до клиента пока он летит внутри нашей инфраструктуры и так далее поэтому есть еще вторичный механизм механизм КТП полинга то есть наша хастовая СДК также каждые 5 минут простым ХП с запросом ходит к нам на сервер И просит выгрузить те пуши которые не были получены Конечно эти два механизма синхронизируются между собой то есть не будет так что будут показаны дубли пушей они синхронизируются по айтишнику пушей и Кроме этого утп Полинка есть также вторичная функция несколько вторичных функций о которых я позже расскажу подробнее для того чтобы мы могли получать pushi в фоне для того чтобы была минимальная задержка доставки нам юзер должен дать permission на работу в фоне в этом случае для него запускается такой диалоговое окно он нажимает разрешить После этого мы можем работать фоне даже если приложение rustore на телефоне закрыли бэкен состоит из 6 основных компонентов в центре у нас апичка которая написана на языке Go она разворачивается в кабернетосе а пешка ходит в хранилище пуш токенов в хранилище пуш токенов лежат все зарегистрированные пуш токины от всех приложений с метаданными по этим токенам и это хранилище реализовано у нас на базе redisk кластер также опишко входит в хранилище пушей в хранилище хранятся все пуши на диске С ттллем пока за ними не придет клиентская клиентская клиентская хастовой СДК и хранилище пушей у нас реализовано на базе с также у нас есть хранилище проектов там хранятся все зарегистрированные проекты идентификаторы проектов сервисные токены это тоже на базе radisso есть строительный метилка тоже на базе radisso и есть попса обшина через которую доставляются пуши через websocket и это собственная разработка на которой я тоже чуть позже подробнее расскажу как я сказал хранилище пуш токенов у нас на базе radisso по сути пуш токен это вот такой словарик в редисе токены здесь представлены в сокращенном виде для того чтобы они влезли на слайд на самом деле они конечно длиннее Вы можете попытаться даже через описку в них сходить Может у вас что-то получится может не получится на базе рейтис кластер у нас это все построено и у каждого пуш Токина есть следующие Поля во-первых это идентификатор проекта к которому привязку токен далее sin это монотонно возрастающий счетчик пушей по аналогии с tcp когда к нам приходят запрос на отправку нового Пуша мы делаем инкремент Сина получаем следующее значение и это айтишник Пуша также у нас есть sinstore это по сути тоже Син Но это минимальный Син которая у нас хранится на диске нам нужно было реализовать возможность хранить ограниченное количество push-уведомлений для того чтобы у нас не забилось хранилище пушами И для этого мы храним верхнюю границу то есть sin и нижнюю границу sinstore И когда нам приходят запрос на отправку нового Пуша мы можем прям в памяти Вычесть из sin вычистим Store получить сколько у нас сейчас хранится и решить Нужно ли сохранять новый Push точнее Нужно ли удалять какой-нибудь чтобы освободить место данном случае мы делаем это все в памяти мы не идем каждый раз на диск пересчитывать сколько у нас в реальности пушей хранится и на 1 миллион пуш токенов у нас используется по статистике порядка 400 мегабайт в редисе и для приложения размера почты mail.ru на Android это потребовало бы там где-то 10-15 ГБ для того чтобы сохранить все пустоты в памяти хранилище у нас на базе сциллы все хранится там на диске на слайде вы видите схему таблички с ушами для каждого Пуша мы храним токен которому относится этот пуш мы храним его идентификатор то есть текущее значение sin payload это Собственно сам Push и Times Temp это время создания Пуша в основном используется для статистики в терминах сциллы наш первичный ключ Это связка токена и Сина не в данном случае токен выступает как Partition Key Осин выступает как ластренкий это значит что по каждому токину все пуши у нас хранятся максимально компактно И причем отсортированный в порядке возрастания вот этого монотонного счетчика ФСИН что позволяет нам делать эффективное чтение по набору токен И синдрейндж то есть вот когда приходит очередной Point и запрашивает у нас все пуши начиная с какого-то минсин у нас это работает довольно эффективно в силу специфики хранения этого в стиле в цели нету понятия ведущего и ведомого узла в цели можно писать в любой узел очевидно из-за этого могут возникать конфликты на записи например мы попробовали записать в первый узел у нас произошел тайм-аут мы не знаем удалось нам записать или нет мы retrime во второй узел во второй узел Мы записали успешно но на самом деле в первый узел тоже записали успешно с тыла разруливает такие конфликты автоматически по алгоритму lastrike Twins что в общем-то дословно означает что остается только та запись у которой таймс Темп новее и очевидно этот алгоритм не подходит В общем случае там задача разрешения конфликтов мастер она в принципе кажется в общем случае не особо решается Но именно в нашем случае нам это позволяет бай-дизайн не иметь дубликаты пушей на ретраев еще раз покажу пример отправки запроса на отправку Пуша здесь есть авторизон header который содержит тот самый сервисный токен и он конечно тоже сокращен ради того чтобы все вообще влезло на слайды есть Push Talking по которому отправляется Push есть идентификатор проекта он вот в Орле и собственно тайтл это Hello world то есть придет пусть стоит Когда у нас отправляется Push мы должны провести Некоторое количество валидации первая валидация состоит в том что апишка идет в хранилище проектов и проверяет что заданные сентилятивные а сервисный токен соответствует тому проекту в который вообще Push отправляется если эта валидация пройдена то далее нам нужно проверить что указанный проект соответствует тому пуш токину на который пуш отправляется Именно для этого мы для пуш токенов и храним Project ID потому что в противном случае злоумышленник мог бы создать свой проект выписать для него сервисные токены потом откуда-то надо быть пуш таким там допустим юзера почты и со своим сервисным токеном успешно отправить юзеру почты такого конечно быть не должно если все валидации успешно пройдены то дальше мы идем уже в хранилище пуш токенов мы делаем инкремент Вроде это работает атомарно в силу однопоточности мы получаем новый счетчик новый айдишник Пуша также мы в той же самой транзакции в той же самой ложки можем проверить как раз разницу между эти этой верхней и нижней границей и понять консистентность инкрементом счетчика Нужно ли нам удалять какой-то пуш или нет из хранилища соответственно Ложка пробрасывает на бэкент информацию о том нужно ли удалять один пуш и в том числе значение нового счетчика с этим значением нового счетчика а фишка идет в хранилище пушей и сохраняет хранилище пушей новый пуш с заданным временем жизни время жизни задается кстати в опишке её задает клиента пишет и асинхронно с этим Мы также идем в нашу пап сообщение засылаем туда Push и если устройство сейчас подключено к интернету есть веб-соки то пусть будет мгновенно доставлен Так выглядит запрос на получение пушей Это публичная фишка она торчит в интернет в нее ходят все мобилки Но вам не придется пользоваться ей напрямую она капсулирована за sdk с ним взаимодействует наша sdk тем не менее интересно рассказать то как она рассказать как она работает здесь также есть идентификатор проекта есть токен для которого нужно получить pushi есть минимальный Син то есть У меня звук пропал Я нормально слышно Спасибо Здесь также указан минимальный Син с которого опишка должна вернуть все push-уведомления когда пешку приходит такой запрос опишка идет в хранилище пуш токинов и смотрит а если там вообще какие-то пуши конкретно смотрит на значение текущее Син если Син равен минсин Это означает что никаких новых пушей не приходило и нет никакого смысла идти в хранилище пушей для того чтобы эти пуши получить если же sin больше чем минсин это значит что какие-то приходили можно пойти в хранилище пушей и эти пуши забрать это на самом деле довольно важная оптимизация которая опять же полагается на то что Сина является монотон и возрастающим счетчиком и по нашей статистике примерно 98 или 99 процентов запросов Нет обрабатываются без похода в хранилище пушей то есть без походов диск 99 процентов запросов обрабатываются просто из памяти Если запуши все-таки есть то мы идем в хранилище пушей забираем все эти пуши и отдаем клиенту далее мы асинхронно удаляем те пуши которые мы считаем подтвержденными чтобы не хранить их на диске здесь важно отметить что подтвержденными считаются не те пуши которые мы только что отправили а те пуши у которых sin не больше чем минсин то есть это контракт опишкой контракт между клиентом и а фишкой которая состоит в том что если клиент присылает указанный минсин то мы считаем что все пуши до этого Минфин он уже видел и мы можем их удалять нам нужно было также решить проблему с протухшими пуш токенами есть много причин по которым может пустотин стать протухшим например приложение удалили с устройства Телефон потеряли телефон Продали или там еще какое-то количество причин которые мы предусмотреть заранее не можем поэтому мы все пуш токены создаем в хранилище пуш токенов с наперед заданным ТТМ и спустя это время пуш токен удаляется из рейса автоматически Но только если не он действительно нужен приложению мы это понимаем по периодическим дед запросам я говорил о том что форинга есть там несколько вторичных функций и если периодически диета к нам приходят то мы автоматически продлеваем время жизни токена мы делаем Это не на каждый запрос мы делаем это раз там в сколько-то часов или дней для того чтобы не создавать лишнюю нагрузку на мастер хранилища пуш токенов потому что мы задаем довольно долгий там порядка месяца наша Фишка эксплуатируется в cubernetos трафик на нее заводится через публичный виртуальный ip-адрес с этого виртуального ip-адреса нагрузка ротица на несколько машин на которых стоят связка enginex плюс инвойс соответственно инжинкс принимает запрос проксирует его в инвой дальше его уже раскидывает по куберу кубе у нас живет в пяти дата-центрах поэтому уход одного дата-центра нам тут точно не страшен двое настроены Health чеки чекает все поды если какой-то пот оказался на плохой cuber ноде на который например там в данный момент высокие лей то Health Check SPA лица и пот будет выкинут из нагрузки нагрузка уже распределиться по нормальным подам хранилище пуш токенов у нас на базе рэдис кластер благодаря этому мы довольно легко масштабируемся горизонтально если у нас кончается запас по CPU или по памяти то мы пользуемся автоматическим решалингом В рейд если просто добавляем ноды и кластер автоматически ребалансится в случае чтениями все даже проще мы большую часть чтений направляем на реплики Поэтому если у нас кончается запас по чтениям мы просто в радиус кластер Добавляем еще реплики и начинаем балансировать нагрузку между ними и редис кластер устойчив к уходу одного дата-центра Ну если конечно вы не засунули все тачки в один дата-центр вот благодаря механизму автоматического фейловера для тех кто не знает немножко расскажу о том как это работает если какой-то мастер узел уходит то оставшееся множество мастеров проводят выборы и из доступных реплик старого мастера выбирает новую нового мастера то есть какая-то реплика промотиться до мастера в этом случае кластер будет в Down тайме по крайней мере на запись пока не выберется новый мастер но на практике мой опыт показывает что выборы занимают там порядка от 15 секунд до минуты и через минуту автоматически кластер снова доступен на запись в случае с чтениями Всё даже лучше у нас есть несколько реплик они стоят в разных дата-центров поэтому прямо в том же самом запросе если у нас шла какая-то реп на каком-то дата-центре мы можем просто притравить рукой этот центр и без downtime отдать результат юзеру в случае с хранилищем пушей здесь опечатка на слайде в случае с хранилищем пушей который реализовано на базе сциллы У нас тоже все хорошо смасштабированием поскольку сцилла довольно легко масштабируется горизонтально просто добавляется новая нода и данные раскидываются из кластера по новой ноте в случае с уходом дата-центра все еще лучше чем с рейдисом потому что как я говорил в Цели нет понятия ведущего или ведомого узла поэтому нет даунтайма пока выбирается новый Мастер и если у нас появился запрос на запись или на чтение в один дата-центр то мы можем просто притравить другой этот центр и в итоге даунта ему у нас нет мы вообще в почте активно используем сциллу по qr-коду можно посмотреть мой доклад прошлого года с конференции с цело саммит я там рассказывал о том как мы в почте добились нагрузки в 250 тысяч запросов в секунду на запись на небольшом пластыре сциллы с HDD там по-моему 8 узлов у нас всего лишь было сервис найти Файер который отправляет пуши через вебсокет разработан нами и на самом деле еще лет пять назад он у нас используется для того чтобы браузерным вкладкам на которых открыты на которые открыта вкладка со списком писем доставлять сообщения о том что юзеру пришло новое письмо Это позволяет нам во-первых снижать задержку доставки то есть юзер раньше узнает о том что ему пришло письмо А во-вторых уменьшить нагрузку на наш сторож да то есть не приходится полить storage и тут уже опытным путем доказано что этот сервис устойчив к уходу одного дата-центра на этом слайде также есть qr-код по qr-коду можно почитать статью на хабре от первоначального разработчика этого сервиса Сергея комардина статья называется миллион веб-сокет и гоно у нас с тех пор уже нагрузка несколько выросла еще одна проблема которую нам нужно было решить наша опишка на генерацию пуш токенов доступна в интернете чтобы любая мобилка могла пойти сгенерировать себя пуштокин из этого следует очевидная проблема кто-то может вооружиться курлом и пойти нам забивать базу пуш токенов Apple и Google такую проблему тоже у себя решают наши исследования показали что они используют для этого секреты зашитые в физические устройства и проводят по ним авторизацию у нас такой возможности не было но у нас есть Простор на телефоне там есть авторизация юзеры Мы решили воспользоваться этим соответственно когда мобильное приложение хочет выписать себе новый пуш токен оно берет О2 токен юзера из ростора и идет с ним в специальный сервис outsproxy outsproxy берет это два токен идет авторизацию растор в авторизации рустора проверяет токен если ток-инвалидный то возвращается ок и вместе сок возвращается User ID которому относится этот два токен Далее ausproxy идет в специальный сервис который генерирует коротко живущие одноразовые токены генерирует там токен и прикладывает к нему причем в payload User ID дальше этот промежуточный токен прокидывается по всей цепочке мобильное приложение теперь мобильному приложению для того чтобы выписать себе пуш токен нужно взять этот промежуточный токены с этим промежуточным токеном пойти в опишку а пешка пойдет сервис коротко живущих токенов проверят этот коротко живущий токен причем запрос не демпатентный поскольку токен одноразовый Да его нельзя два раза использовать если ток-инвалидный то возвращается ок и вместе сок возвращается payloat который был в токене в данном случае это User ID которому относился О2 токен Ну и дальше пишет генерирует Пушкин пробрасывает его на мобилку таким образом за счет проверки авторизации мы как минимум защитились от того что кто-то прям совсем В тупую возьмет курул пойдет нам генерировать нагрузку Но если кто-то там задался целью то ему наверное будет не очень сложно достать свою два токены с рустора с этим адвокатом ходить тоже нам создавать проблемы поэтому у нас во всей цепочке используется User ID вот на печке он сохраняется в нашу и если кто-то с одним и тем же не Пушкина два токены будут ходить и пытаться нам генерировать пустоты то он просто вряд лимиты Ну наверное не сюрприз Что первым большим потребителем разработанного сервиса стала почта mail.ru Мы решили посмотреть в общем-то А нормально ли работает то что мы разработали и стали параллельно запускать pushi по двум каналам то есть пускали Пошли по каналу с firebase и по нашему каналу послушав давлением рустор и стали замерять сколько же пушей приходит через каждый из каналов первые результаты нас очень не порадовали и мы долго-долго чинили баги в аналитике которая считает сколько к нам пошли приходит и в том числе баги в доставке пушей и пока что за чинили не до конца Об этом я расскажу подробнее чуть позже следующим этапом Мы собираемся показывать первым тот пуш который пришел раньше то есть если Push придет в firebase то покажем юзеру его Если придет в пушистую сторону то покажем его и на клиенте производится дедупликации по айтишнику Пуша тут же мы планируем начать замерять задержку доставки насколько Кто быстрее доставляет там в среднем по какому-то персентилю и опыт подсказывает что какие-то проблемы возникнут и нужно будет их чинить в данном случае разработчики почты то есть мы выступали для своего сервиса для сервиса push-уведомлений простора потребителями и могли оценить Насколько сложно Нам его интегрировать для того чтобы включить пуши достаточно просто сделать несколько кликов веб-интерфейсе сгенерируется один проект сгенерируется сервисные токены интерфейс sdk повторяет интерфейс sdk firebase и встраивать его было несложно А вот случае с опишкой вообще получилось так что мы переиспользовали коннектор от firebase заменили в нем хост и у нас все заработало из коробки за счет старта экспериментов с интеграцией в почту мы во-первых уже частично защищены на случай если Google заблокирует нам пуши совсем мы сможем продолжать слать пуши о новых письмах юзерам через канал пушей простора совсем не обязательно использовать один канал можно использовать два канала параллельно и таким образом суммарно повышать Delivery Raid всех пушей которые приходят на устройства вашим юзерам Ну и также эта интеграция позволила нам провести нагрузочное тестирование разработанного сервиса в реальных условиях найти какое-то количество проблем уже часть которых мы зафиксили эксперименты у нас все еще идут но я в принципе готов поделиться уже какими-то промежуточными результатами VK pns это название сервиса pushi здесь для краткости поскольку push-уведомления rustore наверное бы Не влезло в title вот буквально на этой неделе команда выкатила фикс на бэке который позволил на целый процент повысить количество успешных ответов на отправку Пуша до этого мы были чуть хуже на один процент хуже чем Google А сейчас уже получается у нас на одну девятку больше это все по статистике которая собирается при отправке почты спойлер Проблема была в том что в коннекторе cradiso который мы используем был дедлок и из-за этого дэдлока у нас какой-то момент начинались копиться коннекты что приводило к ому если пользуетесь радиксом то рекомендую обновиться время ответа нашей аппишки уже в три раза ниже чем у Гугла это было еще до фиксов Ома это среднее время ответа максимальная также ниже и вот пока что наша основная зона роста это доставляемость пушей То есть в принципе мы уже доставляем 60 процентов от того что доставляет Google через свой нативный канал и по нашей статистике Мы видим что для части юзеров для довольно большой части юзеров пуши от нас не доставляются вовсе Что символизирует что говорит о том что есть какой-то баг из-за которого у нас происходит рассинхронизация клиентского их основы sdk при этом те юзеры кому мы пуши доставляем получают примерно столько же сколько и от Гугла то есть где-то мы доставляем чуть меньше где-то мы доставляем чуть больше Поэтому мы считаем что текущее значение Delivery Rate вызвано не тем что нас как-то режет операционная система то есть не каким-то непреодолимыми проблемами в течение несколько недель Мы надеемся зафиксить бак о котором я сказал и тогда у нас существенно вырастет мы стартовали с довольно узкой узким подмышечным функциональности потому что запускаться нам надо было Быстро запустились мы совсем недавно и из того что мы собираемся делать в ближайшее время Это приближаться по функциональности к firebase как минимум мы должны сделать рассылку по топикам это массовые рассылки в firebase Мы хотим поддержать еще больше настроек Пуша я говорил о том что мы поддерживаем там иконку картинку цвет Пуша но пока что не все поля и в консоли разработчиков firebase можно видеть метрики доставляемости сколько там пуше отправлено сколько доставлено сколько открытым и пока что это статистику не выводим но у нас есть это в планах я говорил о том что push-уведомления приходят юзеру только если у него стоит рустор и нам понятно что это ограничение для роста нашего сервиса поэтому мы хотим сделать так чтобы push-уведомления могли приходить через Любой любой из продуктов в к который стоит на Android устройстве юзера это нам должно очень существенно повысить охват при этом важно что мы должны продолжать держать только одно соединение они из каждого там приложения ВК из Маруся отдельный вебсокет из облака отдельный высокий нам не подходит вот ну и поскольку есть еще куда расти как минимум по деливее рейту Ну и там те значения описки которые я показывал их тоже еще нужно сохранить важная задача у нас важный Вектор работ это стабилизация нашего сервиса надо по основным холст метрикам быть как минимум не хуже чем Google на этом У меня все по ссылке Вы можете спасибо по ссылке Вы можете скачать слайды мои контакты Если у вас есть какие-то технические вопросы и пожалуйста голосуйте за доклад по qr-коду сейчас готов ответить на ваши вопросы так Первый пошел Большое спасибо за доклад очень важная интересная для нас тема Вопрос такой Планируется ли выпуск каких-то устройств даже перелицованных китайских соотечественной сборкой Android в которой ваш сервис будет прошит соответствующими правами чтобы обеспечить такой же пользовательский опыт как если бы это были гугловые пуши Ну так как этого Huawei сделано Да спасибо за вопрос насколько я знаю уже в ноябре мин цифры добавила нас перечень обязательных приложений поэтому на по крайней мере каких-то новых девайсах мы будем в перечне обязательных мы будем предустановленными и насколько я понимаю это должно давать повышенные гранты на работу нашего сервиса внутри операционной системы Спасибо будьте добры раз раз Кирилл Спасибо за доклад У меня два вопроса Первый вопрос по поводу Как вы оценивали будущее да то есть Android от версии к версии ужесточает правила работы в бэкграунде или там работа с файловой системой Какие риски если Google запретит работу каких-то длительных процессов соединений бэкграунде Вот это первый вопрос и второй вопрос по поводу Я так понял что хостовая часть делает запросы пулит через некоторое интервалы стоит месяц А вот этот пуллинг он как работает ну то есть если я больше месяца клиентское приложение не запускают токен протухнет и перестанут проходить через два месяца или нет всё будет хорошо спасибо да давайте со второго вопроса если за указанный месяц не будет ни одного Гетто то пустотин протухнет и пушит по нему в том числе потеряется то есть мы решили стартовать с таким значением тем не менее оно находится в конфиге и его можно в принципе в любой момент поднять если мы увидим что слишком много ТТ или происходит вот здесь все опирается на статистику который у нас будет получена по поводу ограничений работы в Android но мы в первую очередь решили что для нас риск не имеет пушей почты Ну или там не иметь большие Группы компаний совсем он гораздо выше чем то что Android там возможно через пару лет что-то забанят плюс Android допустим отличается от iOS тем что довольно много остается устройств на старой операционной системе Да потому что Android Android довольно высокие требования предъявляет к обновлениям операционной системы Да у нас как минимум останется какое-то количество юзеров на старых операционных системах где этих ограничений не будет риск Ну есть все что мы не контролируем все есть риск спасибо Вот там Здравствуйте Кирилл Спасибо большое за интересные насущный доклад Вопрос такой в цели там было указано что используется фильтр Блума Можете ли рассказать зачем и Работаете ли вы со ссылкой напрямую или через брокер сообщений Да конечно Сейчас отвечу Давайте еще и слайд включу хранилище пушей а Блум фильтр это кажется неотъемлемая часть любой вообще динамоподобной системы То есть это есть и в кассандре это есть там в Динамо деби амазона Я предполагаю это есть в цели это то что позволяет не хранить индекс памяти да то есть он фильтр используется для того чтобы было как можно как можно меньше обращений к диску в стиле и без него в принципе сциллы отнесла вот фильтра есть основной параметр который можно крутить это величина Falls позитива вероятность соответственно чем она ниже тем выше становится размер Блум фильтра Вот и вы можете получается снижать количество бесполезных обращений к диску за счет того что у вас там в памяти будет выше значение памяти будет больше содержаться а по поводу брокера сообщений нет но помнишь целую напрямую сцилла у нас в данном случае запущена на nvme SSD у нас стоит последняя сцена 5 версии в которой были там существенные доработки по одесскому машудолеру и она у нас работает довольно хорошо довольно стабильные и низкие задержки на запись И ничего там не тайм-аут никаких таких проблем нет Если вы об этом спрашивали Спасибо за доклад Кирилл У меня вопрос такой я услышал что вы недавно запустились но какие сейчас нагрузки сколько вы отправляете по 6 секунд сколько соответственно приложить Ну телефонов Вот это приложение просторы смотрите у меня нету точных цифр по там да у мауруз Тора я могу сказать про цифры которые у нас в нашем эксперименте есть значит сейчас эксперимент раскачен на тех юзеров у которых одновременно стоит почта и одновременно стоит рустор причем почта может стоять не обязательно из Ростова она может стоять из Google Play таких уникальных ютеров за неделю по статистике у нас насчитывается порядка 200 тысяч и сервис найти Файер держит около 100 тысяч одновременных веб-сокетов при этом по шее у нас ходит Ну там график такой сезон и в течение дня он меняется в Пике сейчас около там 600-700 отправок в секунду гетов у нас получается сейчас около там полутора тысяч в секунду мы сейчас снижаем период где-то очень много запросов на проверку по штоке на при создании веб-сокета То есть когда запрос приходит на tefirentifire должен проверить что Пушкин вообще валидный Ну вот и таких вообще порядка там 7000 запросов в секунду что видимо говорит о том что в случае с мобильными устройствами websocket рвутся там сильно чаще чем в случае с браузерными вкладками вот ну то есть одновременно там 100 тысяч где-то подключенных девайсу всего умников около 200 тысяч еще какие-то цифры я упустил Спасибо Да привет Спасибо за интересный доклад у меня такой вопрос Мы размещаем свои приложения и вру Store и в Google Play и вопрос Если мы переходим на ваши уши предусмотрено ли в вашем sdk такая вероятность что на устройстве не стоит никаких ваших приложений и автоматически происходит подписка на push-gun Угловский либо это надо делать только на уровне приложения а у нас сейчас нет ничего Что связывает вместе Google и наши СДК да то есть нету никакой надстройки над этим Спасибо за вопрос Он в принципе подчёркивает что возможно нам стоит в эту сторону посмотреть и какой-то такой sdk сделать с там какими-нибудь удобным переключениям с дедупликацией может ну то есть мы своё приложение размещаем во всех магазинах но по нашей статистике всё равно больше качает из Гугла но нам конечно интереснее было бы взаимодействовать с пушом отечественным потому что неизвестно что в будущем будет но э далеко не на всех устройствах есть ваше приложение соответственно нам нужно что-то своё внутри предусмотреть для переключения туда-сюда либо это вы планируете сделать своей стороны Ну смотрите вот хостовую часть мы пока не планировали экспортировать поскольку тогда мы не можем контролировать сколько векетов открывается на телефоне У юзера да и все будут говорить что потому что держат там 100 век сокетов Мы так не очень хотим делать Вот в принципе я думаю что если мы строим это в большую часть в каждом приложений то мы довольно сильно поднимем охват и это должно уже много юзеров покрывать но все равно не всех еще раз все равно не всех не всех конечно сейчас тебе вот так вот микрофон пообещаю Да что всех Сашу там очень давно рука махните пожалуйста или вы уже не хотите А все не ходи Окей я думаю что сюда можно второй приз сразу подарить за хороший вопрос Да привет привет У меня предложение наверное прошлого вопроса А вот я отправляю я узнаю что У пользователя не стоял этот момент рустар и до него не дошел Ну смотрите значит если у юзера был рустор то просторы авторизация в Ростове то должен выписаться пуш токен да то есть если пуш токен У вас есть откуда-то в базе то значит какой-то момент точно rustore стоял далее если rustore удалился вот я здесь не уверен Будет ли у нас инвалидация пуш токена в базе то есть если пуш токен протух то Вы точно об этом узнаете подобно firebase Да firebase отвечает что токен протока и вы можете удалить его из базы А по поводу удаления в случае удаления раствора у меня вот тут есть Владимир Андроид разработчик сервиса один из специалист по спорам с Андроидом может Володь ты знаешь как у нас в этом логике в этом случае логика работает вот тебе микрофон несут уже смотри а иди к нам иди к нам Всем привет Так это если поближе в случае удаления рустора что будет ну вот я отправил пуш через API и я узнаю что У пользователя не было рустора и пуш Не дошел Ну у нас получается при инициализации sdk клиентского будет возвращаться ошибка что нетру сторону на этом девайсе то есть так или иначе sdk не инициализируется и оно будет передаваться в клиентский сервис который конечное приложение будет реализовывать но определенный callback с ошибкой соответствующие То есть если либо пользователь ВК ПВК день не авторизован либо соответственно рустора там нет и соответственно инициализации не произойдет это критическая ошибка и еще очень болела долгое время у нас гугловскими пачками можно отправлять души или только по одному Ну по сути по одному Да по одному спасибо Ну смотри Мы целились в первую очередь чтобы сделать тропин реплейсмент Я не уверен если у firebase отправка бачами в любом случае если это будет востребованная фича то мы можем ее сделать поверх того что мы сделали похожим на Google да то есть нам не обязательно ошибки тоже повторять грубо говоря что сделали дроп-ин сделайте файловер а я прям вижу ваше будущее это может быть неплохой Разговор в кулуарах друзья дальше через минуту у нас здесь тех ток где мир платформы рассказывает как ускорить разработку потом Будь здоров потом через 10 минут мы будем разговаривать Вернемся А сейчас надо определить то есть вот первый приз мы отдаем человеку раз ты сказал клёвый вопрос Мы подумаем об этом кому ещё один за хороший вопрос смотрите у меня целых два приза Но первый уже ушел я понял да поскольку у нас такая ситуация тут Простор плюс почта поэтому у меня призы от ростора и от почты я хочу от почты приз отдать человеку который спрашивал про статистику потому что это действительно важная часть доклада И хорошо что я ее озвучил вот просторовский за вклад в развитие без дефорстора отлично супер спасибо большое за выступление тебе тоже памятные призы от конференции вот этот этот сейчас прием у спикера который привлекает своего эксперта в ответе на вопрос называется перевести стрелки с улыбкой когда тебе задают вопрос на который не хочет отвечать сам выдергиваешь коллегу даешь ему микрофон и он ещё на фоточках потом маячит конференции в отчёте прекрасно мужчины Молодцы друзья продолжаем Хорошего вечера"
}