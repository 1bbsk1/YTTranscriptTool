{
  "video_id": "fNZdQ0w37fs",
  "channel": "HighLoadChannel",
  "title": "Как делать бинарно-совместимые API на компилируемых языках? / Александр Туренко (VK, Tarantool)",
  "views": 218,
  "duration": 2380,
  "published": "2024-10-29T03:08:42-07:00",
  "text": "Привет Меня зовут Александр я из Тарантула собственно Да Отвечай на вопрос откуда это всё взялось зачем это всё нужно у Тарантул это это платформа для выполнения приложений и база данных в одном флаконе для выполнения приложений Существует множество плагинов Некоторые из них достаточно низкоуровневые и им требуется работать с тарантулом используя нативные IP да и у нас соответственно возникает некоторая такая ну поставка с тарантулом Да и там поставка с плагинами Да они могут обновляться Независимо и встают вопросы расширяемость совместимости вот этого всего в том числе на низком уровне и где ещё встречаются такие задачи да как правило это какие-нибудь библиотеки скажем Open ssl Да библиотека с криптографическим примитивами Мы в принципе можем собирать вот как в год да приложение всё вот просто в один бинарник все библиотеки всё туда вот внутрь А чем это может не устраивать Да в частности с иногда у нас находят уязвимости Да в таких библиотеках за их обновление отвечает отдельно команда Security Да не та которая эксплуатирует приложение сервис А и её вообще говоря надо обновлять Независимо и вообще-то хочется чтобы обновлять её можно было без пересборка приложения Да чтобы вот совсем раздельно да такие как Lego в слоты вставил и поехало Вот другой класс задач Когда у нас само приложение Да единое какое-то грубо говоря Монолит разбивается на компонент и мы можем обновлять их Независимо вот как в тарантуле да то что я приводил пример мы можем делать во-первых разные поставки можем скажем клиенту раскатить на стейджинг какой-нибудь плагин собранный с деба информации Да можем проводить эксперименты таким образом и сри это упрощает собственно О чём поговорим сначала поговорим что обещают стандарты но они будут касаться в большей степени си и примеры в докладе в основном на си даже все все все примеры в докладе на си процентов 30 наверное информация она такое обще применима печ стно первое что куда стоит заглянуть Да это стандарт что он нам говорит о том как представляются структуры в памяти скалярные значения в памяти вообще Вот что там происходит в под капотом Да стандарт гарантирует порядок полей гарантирует что там нет панго в нача поводу того есть ли промежутки между элементами Пан Да не гарантирует ничего по поводу размеров типов выравнивания и о том Есть ли Пади в конце вот на самом деле когда я с этими задачами впервые сталкивался для меня типа вот нет почвы под ногами Да было ощущение А на что опереться Чтобы построить свой API непонятно Ну вот собственно иллюстрируют Да есть разные версии компиляторов есть разные компиляторы и по идее Ну как я наблюдаю Да я библиотеку собираю кнм а там приложения gcc и Они вроде как-то работают да А на чём это основано почему они вообще ну одинаково представляют в памяти структуры хотя мы знаем да что компилятор они любят что-нибудь по оптимизировать вот что-нибудь там поменять местами чтобы значит в одну кэш линию попало или ещё что-нибудь типа того на самом деле есть стандарты AB для ликса и ма это в основном System 5 он специфичен для архитектуры и платформы у ама у4 свой Стандарт на эту тему с типа вариантами выбора для конкретных платформ то есть типа ма говорит Вот я соответствую этому стандарту с такими-то такими-то такими-то оговорками да Вот примерно так что ещё стоит сказать System 5i есть просто System 5i без указаний архитектуры это формат файла и другая общая информация а и те которые специфичны для конкретной архитектуры они уже содержат вот представление в памяти да о котором мы будем в основном говорить Что определяет стандарт Я в качестве примера везде беру amd64 как са Ну популярную архитектуру размеры скалярных типов выравнивания здесь конечно приведены не все красным выделены те которые я буду использовать дальше в докладе Т4 байта поте и8 Вот в общем всё что нужно запомнить выравнивание слава Богу натуральная на MD 64 то есть мы выравниваем всегда по кратности которая соответствует размеру типа А у x86 это местами было не так и это было м иногда болезненно размеры составных типов они собственно можно так сказать сумма размеров полей плюс падиння Ну в данном случае там восьмибалльное выравнивание структуры равно выравниванию максимального его поля то есть да В данном случае 8 байт Поэтому нам нужно четыре в конце чтобы второй элемент был выровнен по границе с че байт это скучная теория мы её прошли рассмотрим подходы да на самом деле са первый ра не подход есть это как всё прекрасно ломается если мы не уделяем этому внимания а нерабочий подход допустим у нас есть библиотека Сошка Да У неё есть хедер и есть приложение которое использует этот хедер там есть структур из двух полей двух интов Мы хотим обновить библиотеку там появилась новая функциональность появилось новое Поле В структуре и мы его вот так не сомневаясь добавили в начало а приложение собрано со старой версии библиотеки а библиотеку нам в ран тайме подложили новую сказали что это очень важное обновление Да и что произойдёт Да когда мы Обращаемся к Полю А из приложения мы попадаем в поле X в библиотеке Да вот ну не стыкуется одно с другим Окей А что если мы Ну мы умные Да мы добавим поле в конце собственно заголовок подсказывает что-то не так будет с копированием Да посмотрим допустим в библиотеке в старой версии Ну в приложении которое использует старую версию библиотеки мы выделяем память два Режа и в библиотеке новой версии копируем Что произойдёт мы потрогаю чужую память Да если наоборот мы чего-то некопируемый на самом деле даже если вот вроде как всё вот должно быть тютелька в тютельку Да мы взяли два Инта четных заменили на восьми байт кроме вот вопросов с выравниванием в принципе да там на некоторых архитектура выровненный доступ к неровным данным там может привести к ошибке на некоторых деградации фа вот если мы там плюс-минус понятные ве опустим совсем у как мы вот говорили про выравнивание про панг Да Нам нужно добавить панг чтобы второй элемент структуры был тоже выровнен по МИ байтам структура выравнивается по МИ байтам потому что у нас там появился восьмий инт и лейт бинарный да По крайней мере для массивов он поедет в этом случае и собственно переходя к следующему подходу в ЧМ основная проблема вот все проблемы с которыми мы сталкивались они происходили от того что владение структурой было не в чьих-то одних руках да а не у приложения не у библиотеки оно было так странно расшаренный правил работы со структурой кто-то мог лоцирование собственно и заключается в том что а давайте пользователю приложению не показывать что там внутри структуры мы всё будем делать сами с ней а то есть внутри библиотеки есть полная декларация структуры а снаружи нет Э нам надо будет определить Понятно конструктор деструктор там функцию копирования акцессорные соры на чтение на запись и э в принципе всё будет хорошо Да почти Это наверное вот там 95% библиотек или около того использует именно этот подход всё закрыть за от пользователя Да и работать по поинте со структурой а там треды курл в общем какую библиотеку Не возьми используется примерно такой подход он хороший и решает почти все проблемы у него есть некоторые небольшие нюансы вот если мы хотим работать на уровне исходного кода то есть собираться с со старым хером но иметь возможность работать с новой функциональностью скажем поставка приложений у нас в некоторых случаях исходниками Да идёт и её собирают человек которого мы не можем проконтролировать возьмёт он там библиотеку старой версии или Новой Да ну или по каким-то другим примм нужно это уметь собира старом нора кодом библиотеки нам придется внести куски хедера нужно декларации прямо в приложение само это маленькая ложка ДГ столовая ложка ДГ вот здесь Нам нужно в ран тайме суметь понять мы со старой версией библиотеки Работаем или с новой есть там нужное поле заводим на функцию делаем там для удобства вытаскиваем в ран тайме функцию или да Она или есть или нет мы можем проверить и в зависимости от этого пойти ну там полнять или одну ветку кода или другую то есть если у нас есть некоторый Да который вот мы безусловно требуем библиотеки не ниже пос этого прийти или та или другая Это релевантно для каких-то активно развивающихся вещей вот-то такой параллельное развитие что можно отметить в качестве недостатков Почему вообще стоит рассматривать какой-то другой подход Вот кроме такого самого распространённого посмотрим на вот эту статическую Цивилизацию Да внутри библиотеки и посмотрим на что-то подобное вне неё если левая запись читается Ну просто взглядом Да грубо говоря то для того чтобы прочитать правую её надо читать во-первых внимательный читатель заметит что в одном случае у нас нет молока а во втором есть да у нас также возникают нюансы с локацией на стеке При таком подходе Когда нам неизвестен размер структуры можем вть Да на некоторое количество эти проблемы решаемы Я там дальше в докладе не буду решать проблему с локацией на стеки но подходы там плюс-минус понятные Да мы или выдаём размер структуры через функцию наружу чтобы там её с помощью Ало можно было Арова или заводим структуру ST которая заведомо больше чем здесь которую я хочу немножко попробовать решить в рамках следующего подхода она в отсутствии там той выразительности из коси которая ну и так не очень большая наверное да мы мы её теряем да нам приходится работать через аксессорайз accessor Set п о там вот попробуем немножко а другой подход вот всё ещё оставим закрытый внутреннюю структуру Но определим публичную вот это будет Definition Да F Definition то есть определение для структуры U публичное а для внутренней структуры которая всё ещё закрыт нам нужно заранее сказать что размер у этой структуры будет чёткий конкретный Да он не будет меняться мы заведём в конце панг и за него никогда не зайдём Да скажем так нам нужно будет определить функцию которая из внешнего определения создаёт внутренний объект нужно будет деструктор определить нужно будет определить на функцию которая реализует внутреннее представление во внешнее ещё немножко да как это определяется собственно размер падинское всего придётся посчитать руками под Каждую из поддерживаемых архитектур ну и желательно да Или в тестах или статически проверить что мы действительно правильно посчитали А есть альтернатива на Когда нам не нужно считать панг Ну вернусь немножко вернусь немножко назад надо понимать что вот это 56 Да оно было бы ну несколько разных цифр если мы поддерживали одну другую третью и пятой архитектуры да то есть на самом деле этот код Ну не такой компактный как правило в реальных случаях по сравнению с кодом на слайдах вот однажды мне хотелось решить проблему с тем что надо считать это панг вру я придумал вот такую загули на самом деле не то чтобы Я рекомендую так делать но посмотреть Можно мы определяем UN размер юниона равен размеру максимального его элемента мы засовываю панг который равен вот целевому нашему 64 да размеру 64 байта и определяем рядышком анонимную структур в ито размер вот этой этого Нина не меньше чем размер панга Да а то что он не больши мы проверяем статическим Ар не очень хорошо здесь то что в терминах языка Си Ну то есть по бинарному леау всё хорошо это вот ну именно те байты которые мы хотим определить но с точки зрения это всё-таки не совсем тоже самое что КФУ который вот бы до у на немножко отличается инициализация Кост будет Да здесь появится дополнительный и Ну работать с этим не очень приятно На что Допустим мы определили структуру так или иначе Да теперь мы в ней в каком-то порядке располагаем поля плохой способ расположения полей - это когда у нас остаются дырки у нас всего 64 Ну для примера 64 байта и байта и ско ут на Пан потому чтоэто скончания веков то вот сколько нам будет доступно памяти для этой структуры что здесь делать Ну там очевидный ответ пере сортировать чтобы выкинуть панг тут есть нюанс с выравниванием Да у нас там вот эти 8 бай становятся не выровненные это подойдёт не под все архитектуры но в принципе воспользоваться этим можно если там чётко знаешь что у меня м64 и всё да например тем не менее лучше всё-таки портировать поля в структуре с чем е можно столкнуться внутри кода библиотеки Да мы работаем в том числе счастливыми типами с ямами какими-то и вопрос как их представлять во внешней в принципе можно вять и нам у Ну во-первых да там очевидная проблема что у нас будет пространство числовых идентификаторов внутреннее и вообще говоря возможно другое пространство числовых идентификаторов для примерно той же сущности внешне в них легко запутаться Да это бывает не очень легко читать глазами во-вторых по поводу Яна мов в публичных структурах есть некоторый вопрос стандарт си достаточно ну м мягко декларирует что это такое как оно должно представляться в памяти То есть это как бы ин но можно и в принципе и побольше взять это может быть S тип А может быть тип Ну там в зависимости от того что внутри и там если почитать армо r64 стандарта ebi там прямо даётся рецепт вы Заведите там значит в я нами отрицательное число Заведите число которая будет между 2 и 232 и тогда вот этот янам у вас будет сказать бинарном не в зависимости от того что в рамках этих чисел вы туда добавляете да то есть он будет представляться так же как представлялся дото Но я лично решаю свои задачи выбрал просто хранить Перечисли мое типы строчками Да цмп на короткие строки он в общем-то быстрый особенно если задача не связана с большим количеством локаций локаций э структур е они там хорошо каширу и вс такое есть мы грубо говоря создали где-то в начале и работаем этот подход достаточно приятен в использовании пойдём дальше флаги Нам жалко одного байта на Бул Да ну то есть размер структуры у нас ограничен поэтому хочется как-то это упаковать есть вариант с бими филми но они достаточно тоже расположение битовых филдовский структуры и понять как она будет расположена в памяти уже нельзя да соответственно обновлять её ээ Ну как минимум сложно и легко ошибиться при обновлении плюс не все не у всех типов базовых битовых филдовский Да в этом случае я лично использую обычные флаги Да ну там битовые маски и флаги мы боролись за Выразительность но в этом месте проиграли Да основная вещь наверное такая Да когда мы работаем с открытой структурой она должна быть Ну расширяемая нам нужно определить правило как же нам правило в конец можно зарезервировать какое-то место ти вот здесь я буду хранить какие-то 4 байта После него заведу Войт поле нам нужно нам нельзя удалять поля и флаги Естественно да мы можем их зарезервировать если они не нужны Но Удалить не можем да ина урны поедет и ещ пара важных вопросов Это Могут ли меняться дефолтные значения У нашего объекта Да который представляется структурой Если да то мы не можем уже обойтись без функции создания структуры Да без локатора без функции локации Да инициализации Вот и вопрос нуле они все эти дефолтные значения или нет Если нули всё проще если вообще говоря нет опять же нужна своя функция Да и всегда создавать через неё какие недостатки в этом подходе Допустим мы добавляем полиси новое у нас были поля иб добавляем новое полиси и в приватную и в Новую структуру и хотим из приложения работать с и со старой версией кода И с новой Ну во-первых нам придётся взять и руками посчитать смещение и сделать не очень приятно но да вот если у нас опять же есть некоторый белай Да и набор версий с которыми мы можем работать в ран тайме приходится делать такие вещи Окей У нас есть асессоры можно что-то с этим делать И последнее наверно что хотел сказать про этот подход это если у нас осталось последние там 8 бай в Туре добавить что-то ещё не стоит их занимать под под своё поле Да нужно завести поинте на дополнительное место да и там уже заводить поле то есть мм чтобы не выкручиваться потом с тем что у нас кончается э место и больше некуда добавить поля нужно подстраховаться и ещё одна тема которая неразрывная идёт рядом с вот этой темой бинарной совместимости и совместимости вообще это А как же узнать типа старая у нас библиотека или новая есть разные подходы можно по сравнивать версии когда версии сравниваются циферка всё неплохо Когда версии сравниваются как наборы из трёх-четырёх цифр тогда приходится делать уже сложные выражения особенно если библиотека развивается в несколько параллельных веток и вотже нам сто ошибаются в этих выражениях сравнени по опыту что не так с проверкой версии на самом деле не всегда известно Какая версия в какую версию войдёт та или иная функциональность иногда разрабатывает на что тебе проверять Да поэтому посмотрим на другой подход Это проверка фич флагов хороший подход в том плане что зах тся вместе с флаги бывают не только числовые но и строковые Да они позволяют там не таскать какие-то искусные идентификаторы и проверять просто по названию фич скажем предоставляет там числовые строковую проверку фич подход хороший но иногда нам нужно знать например ели в библио к Вот но фич флага нет на баге на баге никто как правило не заводит фич флаги или в принципе разработчики могли не подумать о том что надо завести фич флаг на какую-то Ну мелкую вещь а для нас она важна поэтому рассмотрим ещё подход Это ранта проверка грубо говоря где-то на инициализации нашего приложения можем пойти и попробовать пользовать функциональность вот если о на наш сложный подход Да с открытой структурой можно сделать так создать деф для структуры присвоить какое-то поле которое вот или присутствует или нет создать внутреннюю структуру сдать её во внешнюю проверить ели наше поле во внеш знат есть это просто пример подход с проверкой он достаточно общий вот он прикольный тем что ни от чего не зависит да подумал разработчик завести флаг не подумал разработчик библиотеки залил он е под этим номером Или под этим увидели что есть стандарты Да на которые можно опереться существенная часть там в общем-то довольно небольшая их можно прочитать есть простой хороший подход закрытой структурой Да которую стоит использовать почти всегда и есть возможность заж по в конце упомяну Да вот собственно стандарты которые уже упоминал плюс мануал агне фога он сейчас немножко подстав там gc третьей версии по-моему упоминается но всё ещё собирает достаточно много информации в удобной табличке Да вот если хочется немножко побольше изучить тему Я советую его хотя бы полистать собственно Всё спасибо что послушали Александр громадный тебе спасибо за замечательный доклад маленький президент от организаторов и от подарочного спонсора компании Газпром и у нас вопросы пока пока хелпера Иду с микрофоном друзья прошу вас голосовать за доклад давать обратную связь Это реально Нам очень важно и вопрос Да здравствуйте такой вопрос я разрабатываю какую-то библиотеку Да мне важно чтобы она была Бинар совместимой как мне этот процесс встроить в ели какие-то предложенные подходы и там какие-нибудь Тулы которые бы проверяли это автоматически Ну скажем так я Поня вопро Да и рассчитываю что никто из коллег не внесёт как бы ну изменений которые мне сломают бинарную совместимость в моей библиотеке Можно ли это как-то автоматизировать на твой взгляд а окей то есть я понял я разработчик библиотеки я что-то делаю хочу узнать сломаю ли я кого-нибудь да при этом я заведомо не знаю кто именно меня использует но как бы самый простой очевидный подход - это тестировать против каких-то известных Да ребят Вот второй подход использ слизи инструменты такие как в EB laboratory Да есть вот набор лов они даже многие осор сные библиотеки проверяют автоматически на бинарную совместимость Ну собственно наверное да два ответа есть А вы пробовали вот эти Тулы то есть что они какой выхлоп они дают или Каким образом это всё работает э подробно не копал но я предполагаю что они проверяют э наличие символа в динамической библиотеке как минимум Да а как максимум возможно и какие-то более глубокие нюансы не знаю Спасибо И у нас следующий вопрос сейчас к вам придут А смотри пока идут Я хотел уточнить а это же ты не проверял Можно же проверять совместимо через обычные анализаторы кода просто на кастомных правилах Но в смысле даст ли мне gcc какой-нибудь ворнинг о том что я меняю структуру наверное и структуру Знаем мы можем же её описать вот если я её меняю да Вопрос же не в том чтобы как бы у нас есть корректный код одной версии корректный код другой версии А нас ну компилятор он видит или один или другой или статический анализатор нам нужно проверить что один совместим с другим немножко другой класс задач получается ем подумать А пока думаю у нас следующий вопрос да спасибо за доклад немного переживаю короче Ника не писал наси у меня есть два вопроса быстрых Они наверное очень глупые Вот первый вопрос А зачем вы эти падинни Вы же просто память расходует Я например пишу на более высоко уровнем языке ме есть два языка Swift и котлин я хочу для них какое-то решение либо на свифте либо на котлине которое будет совместимо с обеми языками Я же не оперирую такими низкоуровневые структурами как мне Ну как в этом случае то Ну то есть я не пишу как работать с памятью и так далее Это всё за меня делает компилятор В итоге на сначала intermed языке потом уже вот и вопрос А ну это или это доклад не об этом был я отвечу на оба я наверно сделаю маленькую ремарку ребята пишут таран Прошу прощения Это просто очень высокая нагрузка Смотри по-моему у меня есть слайд в бпе да про выравнивание да В чём сама идея это можно как про памяти так и про кши говорить Да что когда мы попадаем в начало Ну кэш линии или там набора банков памяти Мы можем за одну итерацию вытащить сразу ликом знание красненькое значение Мы за одну итерацию вытаскиваем Синенькая за две вот идея примерно такая а Отвечая на вопрос про языки высокоуровневые да скорее всего потребуется какое-то представление сериализации Да какой-то формат сериализации для того чтобы обмениваться между языками и сейчас ну там условно года с четырнадцатого развивается тема про форматы сериализации которые пытаются обойтись без де маятся прямо на структуры языка причём разных языков это ф buffers это C and proto и Simple что-то там buffers не помню точно название В общем по слову flw скорее всего можно найти эту штуку и все остальные Вот flers ловы спасибо за очень детальный ответ и у нас следующий вопрос Александр добрый день Руслан ермилов разработчик веб-сервера И ныне российского рра У меня нет к вам вопросов Я хотел поблагодарить вас за интересный очень доклад очень близкая тематика с высокими нагрузками вот Браво для меня просто Это был лучший доклад на вот на сегодняшний день очень на одном дыхании послушал могли бы мы использовать часть из ваших слайдов на наших собеседованиях если организаторы позволят я без проблем Я предлагаю отдельно после доклада связаться с организаторами и думаю всё решаемо хорошо спасибо большое ещё раз и у нас следующий вопрос Спасибо большое за доклад а у меня следующий вопрос Вот у тебя презентация называется Как сделать Бинар совместимые на компилируемый языках но ты упоминает ещё в паре слов рассказать может изучал эту тему касательно других компилируемые Да Уста я бы не сказал что специально изучал Да но немножко зацепил у есть интерфейс который жен соответствовать всем тем же стандартам Да и они даже кстати находят иногда баги в компилятора достаточно прикольная тема у них есть кстати тестовый сют на эти дела Недавно в они нашли БАГУ 128 видными целочисленными значениями по-моему у них там выравнивание по-разному могло быть вот от в вопросах подходов это тоже релевантно другим языкам скажем возм Гош плагины Да у которых Примерно вот те же самые вещи Ну отчасти те же самые вещи про которые я говорил они прописаны вот в документации Если вы используете Гош плагины то вы не можете менять это вы там не должны менять это так отчасти примм вопрос последний спасибо за доклад Вопрос такой там на одном из слайдов было Про ранта проверку фич является ли этот подход для проверки Точнее не так служит ли этот подход для проверки только самых критически важных фич библиотеки или есть какой-то подход который позволяет проверить сразу много фич и не писать Полотно кода подход с фич флагами скорее всего позволит Да в один там набор флагов упаковать здесь есть фича такая-то такая-то такая-то такая-то если это подходит прекрасно Ну как бы бывают ситуации когда Ну я не знаю мой пример мы внесли внесли добавили добавили некоторую фичу в она Ну содержа и проверка нае этой в модуле она начиналась с версии в которой был исправлен бак да то есть ну там потребовалась более сложная проверка в простых случаях Да можно пользоваться более простыми подходами Понятно спасибо только коллеги не забывают что надо будет ещё тестировать фичу флаги и мы и мы попадаем им в рекурсию и очередная у нас сегодня рекурсия вопрос Выбери лучших два вопроса один подарок от ран второй подарок от Газпрома и и яй у нас традиционно чёрно-белая Так ну собственно наверное да я бы выбрал последний вопрос про фич флаги и Прошу вас выйти на сцену и вопрос про применимость к другим языкам Прошу вас выйти на сцену Спасибо пожалуйста Спасибо за доклад"
}