{
  "video_id": "D72Ey_g2M4Q",
  "channel": "DevOops_conf",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "Всем привет Рад вас приветствовать на нашем докладе Меня зовут меркурие Дмитрий Я devops инженер в компании guber Team те бы пару слов рассказать о нас Мы it интегратор специализируемся defs devs dataops MS и всякие остальные Ops тоже хочу представить своего коллегу Алексей кунов се в нашей компании больше 20 лет опыта в it больше 10 лет внедряет различный ПС практики в продуктовых r&d компаниях Алексей прошу Спасибо коллеги Добрый день ещё не вечер Или уже вечер в общем начинаем мы решили этот доклад подготовить Вот как раз в направлении Back to Basic Вы же все знаете основы Linux по крайней мере ом - это одна из базовых так сказать функционалов которые заложено именно в Linux Прим под словом Linux Я имею в виду даже не операционную систему А кто скажет что именно я имею в виду под словом Linux ядро отлично Ну значит мы с вами на одном языке разговариваем уже неплохо Итак поехали а коротко обо мне ну Дмитрий меня уже представил поэтому не буду задерживаться Так что многие со мной со мной уже пересекались либо по работе либо где-то на курсах по линуксу но так или иначе ко мне всегда можно подойти поговорить Я может вам расскажу что-нибудь ещё интересное коротко от нашей компании опять же Дмитрий всё рассказал мы занимаемся девопсом и осом всем остальным и нам приятнее Называть себя системными инженерами Ну и такой небольшое замечание в конце доклада Когда у нас пойдёт дискуссия у нас будут розыгрыш различного ча Так что регистрируйтесь а в конце доклада я опять покажу собственно этот QR код для тех кто не успел всегда можно успеть Итак А сейчас коротко расскажу содержание нашего доклада Да вот выглядит он Примерно вот так вот когда системный инженер начинает работать с линуксом выглядит кто со мной согласен что это выглядит примерно вот так начало увлекательного весёлого пути как страшная сказка чем дальше тем страшнее поэтому так или иначе devops и ом встретятся Это я вам гарантирую но в целом я вам расскажу Кто такой Ом килер И вообще кто его нанял а но чтобы понять как он работает нам надо вообще понять Сколько памяти у нас в системе Linux кто умеет считать память в Linux Поднимите руки Это не самая тривиальная задача согласны со мной Вот что такое оверко Ну все мы знаем как работают отели Linux Дава забронируем больше чем у нас есть ме Куда и когда приходит килер то есть какой момент и как он выбирает жертву Это очень важный момент чтобы сказать так сказать выделить персон процессы которых не надо убивать То есть у нас всегда есть как бы у нас система Демократическая в общем-то об этом Ну и мы же девопс мы же про кубернетес кубернетес новый Linux поэтому Причём тут ом Киллер кубернетес естественно Мы тоже поговорим Итак неизбежные встречи Кто из вас встречался вот с таким вот сообщением Да это Это красиво это The message определённая любимая наша команда посмотреть что происходит И вам убили вот как на этом примере вашу любимую базу данных ну я Я пожалел Я не стал писать здесь искать постгрес мастером убитым Ну примерно примерно так оно и происходит второй вариант встречи Это для любителей кубера Да 137 любимый эт Код Да я согласен с вами но там ещё бывают поды я что-то забыл сделать скриншот но это тоже про укир мы расскажем Почему они разные Они разные Итак То есть все со мной согласятся что Kill встречаются однозначно практически в любой системе выглядит это так вот и здесь самое интересное видите у нас подпись B процес запомните это слово слово B нам пригодится а Итак начнём мы с простого что же такое О это Out of memory и это как бы мы можем назвать это ошибкой Но на самом деле это не только ошибка То есть у нас есть Not Enough Memory Да ошибка которая возвращается процессу В каком случае при невозможности выделить память на его запрос то есть процесс а отсылает Кто помнит какие у нас системные вызовы для выделения памяти а ещё вот отлично а и значит при этом да то есть у нас есть ошибка я покажу когда она возвращается А есть состояние и вот у нас когда то есть ядро решило что оно не может сейчас выделить память оно переходит в это состояние при отсутствии вроде бы свободной памяти но память есть её надо просто поскрести по сусекам и глядишь колобок и получится то есть и как это происходит поступает запрос на выделение памяти Да вот молок или что-то типа этого и начинается проверка наличия свобод и вот здесь получается та самая функция в Memory Memory возвращает у нас как раз два варианта либо совсем нет памяти и тогда мы получаем ошибку это стандартная Константа в линуксе или есть свободна вроде бы память и аэ но но когда он пытается выделить эту свободную иногда может не получиться и тогда у нас состоя происходит состояние Out of memory когда не получилось её вы выделить и приходится едро ещё раз убеждается что не получается выделить Нет свободной памяти а если уже совсем Ну значит надо кого-то убить это вот такой вариант но этот вариант тоже не всегда работает Мы тоже посмотрим как же это происходит вот э самая функция Откуда я её взял Ну залез просто в код ядра в данном случае я примеры брал из версии 54 и я вам скажу они таки кардинально отличатся от версии 26 и 310 А сейчас версия ядра 60 и там они перерабатывают в том числе вы там года два или три назад там изучали что-то про Out of memory Да понимали как это всё работает то сейчас я вас уверяю ваши знания немножечко устарели как и мои тоже пришлось перерыва и то я знаете так я я в надежде сижу Там последний год на ядре 5-4 всё нормально Ну я знаю что есть 515 там выше А тут Я открываю оказывается все нормальные люди уже на шестёрке сидят и проморгал этот момент ну хотя я прихожу к некоторым клиентам и вижу НТО 6 и а Илин 7 да который вот недавно стал с ядром 310 стандартное Да и они туда Кстати это ключевой момент да Когда у нас НТО 7 в ядро 310 мы туда запихнули 256 гиго памяти у на не так чуть-чуть обсудим Итак А смотрите здесь Обратите внимание Вот сейчас просто Обратите внимание на два Вот таких момента видите у нас две основные проверки на overcommit Always и Over comit Guess это две константы которые регулируются через параметры ядра очень важные они а м определяют поведение ядра в том случае когда система пришла спрашивать память и вот на Over было всегда классное такое замечание ВМХ линуса Да что это какой-то сложный эвристический алгоритм который подбирает сколько там памяти действительно можно выделить Определите посмотрите внимательно на вот этот сложный алгоритм мы просто определяем что у нас не запрашивается памяти чем физически есть у вас на сервере на вашей машине и всё а в случае overc неважно сколько вы запрашивается Да хоть петабайт вам выделят Её но потом и может быть не получится но разрешение формальное у вас будет так что вот это два момента на которые стоит обратить внимание а дальше параметры ядра сами выглядят вот так у нас есть орати это уровень Овер комита в процентах Да по умолчанию 50 и этот параметр при выставлении двух прошлых констант не работает вообще то есть он бесполезен есть оба Да когда вы в абсолютное значение окота ставите и есть стратегия окота как раз которую мы рассматривали на двух переменных Да это Over Always вотще Когда Вы начинаете настраивать систему Особенно это а есть здесь кто настраивает системы сервера под базы данных под по например вот overc Never ваша любимая опция потому что как бы её надо выставлять вы выставляете overc Never рассчитываете overc А как его считать и как оно работает а работает он по этой формуле SW а плюс Ram умножить на оверко разделить на 100 То есть если мы у нас допустим 4 гига памяти 2 гига свопа и соответственно оверко ратио 50 это у нас 2 + 2 4 гига выде в рамках 4р гигов мы можем выделять Память то есть мы уже вот в этом как-то крутимся теперь А на что ещё здесь надо обращать внимание swop кто выключает swop на сервере кубера воды что ли А у кого при этом Там же ещё база данных крутится вот есть очень весёлая история у меня про омит про ом базы данных А ещё а у кого безопасники там где-то рядом и заставляют какой-нибудь Касперский или кмд пускать вот а он очень любит память а когда он съедает память Угадайте кто приходит вот идём дальше Итак Как управлять окотом в данном случае да то есть как вот эти значения но я думаю все у вас умеют конфигурировать ядро очень просто но на случай вообще это я напоминаю у нас доклад для джунов это Back to Basic поэтому для джунов мне не грех показать вот эти две команды Да что мы можем задать собственно либо саму значение ядра либо через идм дальше как у нас работает наша функция это уже в тот момент когда у нас не сработали две наши константы и мы попали в состояние и здесь мы определяем уже вот тот самый видите ифн есть если вы ну или у вас процесс То есть кому дано чуть больше прав чем другим то у вас всегда есть там ещё на чуть-чуть побольше памяти то есть чем дозволено всем остальным То есть это небольшая привилегия она вшита в ядро то есть емия м Чем всем остальным как же считается вот здесь тоже очень интересная штука смысл В чём мы считаем да то есть Если нет то урезали память и дальше мы считаем следующее считаем Вот здесь есть у нас страни плю то есть помимо просто памяти у нас есть ещ H кто ни раз не сталкивался с hory есть такие есть Ну тогда я вам чуть-чуть дам заметку о том что такое H в данном случае это объёмный полный набор сколько у нас занимает поту в том что-то добывает Вот и затем у нас срабатывает наш омит и затем к этому мы прибавляем наш swop поэтому для тех кто любит выкручивать выключать swop не выключайте снес Выключите ближе к нулю а а своп Оставьте он вам спасёт жизнь ваших процессов тогда когда других методов будет уже не хватать может не хватить в любой момент Итак идм дальше напомним Как устроена у нас память да Linux в целом оперирует виртуальной памятью То есть он ничего не знает про вашу физическую Память про неё знает только ядро вот А ваши процессы когда запускаются они запускаются в неком виртуальном пространстве и могут там выделить вообще объём памяти нереальный даже превышающий там и диск процессора то есть но в целом там есть ограничения определённые и так далее но работаем Мы с помощью так называемых страниц памяти стандартный размер страницы памяти 4 КБ и у нас есть Frame Frame - это физическая память и там обычно тоже У нас оно мпи те же самые 4 КБ если мы посмотрим более такую картину как это происходит да то есть вот у нас картина Как идёт лнг да то есть у нас есть логические адреса там есть и есть у нас такая штука очень важно в линуксе всё на неё завязано это P Table Она кстати тоже занимает память это по факту справочник пинга Когда у вас кусочек памяти виртуальный То есть у вас есть виртуальный адрес он выделился физической памяти То есть у вас произошёл Пинг один адрес в другой адрес и этот НГ он не просто так он сохраняется вот этой page Table и собственно всегда именно через неё находится тот адрес физической памяти который нужно прочитать то есть грубо говоря у нас есть физические адреса У нас есть номер фрейма номер офсета и мы тогда можем считать наши данные У нас есть ещё мму му Да но это немножко другая история уже как именно это на уровне цпу кэшируется обрабатывается но смысл пока вот такой что вспомнить как вот памяти и у нас есть информация о памяти которую мы в любой Linux системе можем легко посмотреть это здесь вы видите как раз самое интересное всегда То есть это Total fre который очень понятно А дальше начинается не очень понятно avil да это та память которая нам вроде бы доступно Занята то есть её будут вытеснять в случае чего и дальше дополнительная уже информация Active inactive inactive это как раз то что уже можно вытеснять в принципе и так далее а дальше есть анонимное ещё да то есть анонимное - это то что занято уже не каким-то конкретным файлом а каким-то процессом а идём дальше если мы посмотрим вот помните мы говорили с Вами про H пей да то в том же фо мы можем Посмотреть информацию по H пейджа Да и в принципе чем оно отличается от обычной памяти обычная память как мы до этого с вами проговаривать это 4 КБ размер страницы hug page большая огромная страница - это 2 МБ то есть мы уже вот такими кусками оперируем для того чтобы выделить в линуксе по дефолту включен huge pages Да который позволяет это в В чём прелесть вообще huge пей Да в том что так как это большие страницы то в той же самой page Table вот этих записей сильно меньше будет то есть ну 2 МБ и 4 КБ то есть Пинг сильно меньше и сама страница меньше То есть когда мы работаем с большими объёмами данных в частности с базой данных который мы хотим выделять десятки сотни гигабайт памяти нам нужны huge пейджес они делятся на статические которые мы можем нарезать И если мы пойдём в документацию по конкретной базе данных они в ней есть чёткие указания Как включить для этой базы данных работу с H пейджа есть рапан который наоборот рекомендовано отключать при работе с различными базами данных потому что с ними система начинает работать не оптимально То есть если вдруг у вас в системе запущены такие штуки как ну база данных а одно но у многих например в куре например может быть редис у кого так поднимите руку вот или rit да то есть системы которые работают с данными они запускаются на каких-то нода на этих нода наверняка включен transp huge pages и для того чтобы увеличить оптимизацию мы можем опять же с помощью контекста пода порева параметры настроек ядра имейте это в виду это тоже классные штуки так вот к чему мы приходим если мы посмотрим вообще у нас есть функция Вот сам Out of memory не просто состояние это функция внутри ядра Linux Мы дошли нане это и в ней есть собственно структура но но это не всё вот посмотрите здесь есть специальная структура Group Да она равна на в случае глобального системного Ома а есть ещё не системный ом ам который работает СИП внутри уже версии у вас старый кубер и старые ядра у вас скорее всего си Group версии один а есть уже си Group версии два у них поменялись иерархические системы внутри А вот их файловых систем которые они строят Я то есть если C Груп V1 у нас строил иерархическую систему То есть у нас был Root и там по для каждого процесса такая вложена иерархия то в случае если групп V2 уже а всё по-другому поэтому это ещё одна тема в которую надо окунуться так вот А помните наш Бет процесс на двери так вот Бет не просто так вот он это тоже функция то есть конкретно происходит поиск Бет процесса именно как раз когда у нас происходит состояние Out of memory что как это выглядит Да что происходит ещ немного про память и про память в линуксе я тут кстати недавно проводил собеседование Да и тоже как бы я спрашиваю как легко посчитать память для процесса в Linux Ну говорят просто я говорю Ну вот по команде топ мы можем сделать и начинается уже сомния так вот смотри вот та самая виртуальная пам все Циферки у всех процессов когда мы анализируем что у нас в системе у нас будет вообще какие-то нереальные Заоблачные цифры вот резидентная так вот резидентная память - Это вроде бы чёткая Метрика которая говорит Сколько де-факто памяти процесс занимает в системе но есть нюанс а нюанс у меня отображён выше на схеме есть какая-то виртуальная память вот здесь есть резидентная и в неё входит которые у нас отражаются здесь И что это значит допустим у вас есть библиотека Да ну её используют Ну практически все системы которые у вас запущены в системе она занимает 5 МБА у вас 100 процессов например да то есть если мы будем считать грубо говоря в резидент суп 500 Это неправильный подсчёт потому что надо считать это если мы резидентную посчитаем А в неё в каждый процесс будут входить эти 5 МБ а дефакто это не 5 МБ а 5 Мб делить на 100 да то есть каждый может мы можем дефакто сказать что каждый по чуть-чуть может занимает пропорционально Но это для того чтобы нам немножко посчитать память поэтому возвращаясь к моему первому вопросу посчитать память именно найти какой же процесс у вас съел много памяти Это совершенно нетривиальная задача потому что нам надо учитывать учитывать и так далее То есть это может быть сложно но всё равно как бы система считает есть определённые метрики и мы живём сейчас в мире победившим groups поэтому переходим потихоньку к нему Итак как же мы вычисляем Лой про кандидата на роль жертвы Да все все любят игру Мафия вот собственно оно только тут тоталитарное государство ядро тоталитарный Диктатор в данном случае но можно как-то то есть мы считаем рсс видите Да вот мы считаем в целом там по памяти мы считаем всё это дем получаем некие собственно считаем дальше Вот вот примерно вот два Вот таких параметра посы то есть на всё посчитали примерно прикинули то есть что-то считается Да и дальше мы рассчитали это количество поинтов и на основе собственно rss Сколько занимает сама сколько у нас и у на один классный параметр это параметр ядра даже не параметр ядра это параметр процесса как запущенного уже adjust это даёт нам некоторые сложности потому что как бы мы не можем его выставить заранее на самом деле можем Сейчас я покажу как но то есть процесс запустился у него есть параметр мы можем про этот параметр поменять тем сам е уровень скажем так уровень защиты от Ома от ом Киллера как Мы это сделаем Ну в общем на основании этих поинтов выбирается жертва и эти поинты в целом да то есть мы когда поинты посчитано Да мы можем знать Вот посмотрев вот по вот этому пу любой процесс мым Кто у нас вероятная жертва на а убийство так вот А собственно вот с помощью вот этого параметра то есть чем выше эта цифра а эта цифра также может принимать минусовые значения тем выше вероятность О'кей то есть мы примерно поняли Кто такой он Киллер когда он случается что происходит и как он выбирает жертву да то есть в целом можно сказать что тут всё понятно что нам с этим делать и начинаем Вот вот этот самый параметр вот этот самый параметр мы начинаем регулировать и тут очень интересно Сейчас я вам расскажу вам это тоже очень понравится то есть есть параметр в ядре он оден вот этими переменными ВиДи мися до 1.000 мы можем коэффициент То есть если минуты поставили всё это бэтмен неубиваемый то есть Его невозможно убить всё и можем задать для каждого процесса и что ещё интереснее оказывается у нас есть ещё один вариант ещё одна один параметр тот у нас был omore hch а есть ещё И кстати есть вот такая команда то есть для тех кто не любит вот такие вот это олдскульные вещи есть модная команда и можно конкретному процессу выставить конкретный АСТ либо либо если мы правильные псы там пишем правильные штуки то мы в можем задать собственно памет который запу процесса правильно АСТ так вот откуда взялся Om и вот здесь классный комментарий он прямо взят собственно и в мене прописан и везде в документации ядра Linux да то есть это у нас Legacy которая тянется аж с ядра 2.6 и его выпиливают выпиливают и никак не выпили потому что до сих по Я читал сейчас в последний раз документацию как раз по redhead 99 Да и они до сих пор оперируют именно этим параметром документации redhead Так что а но на самом деле как бы неважно какой параметр вы выставляете О H или Om Score H Да только единственно один регулируется от -1000 до 1.000 а второй от -17 до 17 старый параметр Да они всё равно птся в друг друга через коэффициенты Так что имейте в виду просто у вас достаточно грубая градация будет имейте это в виду так а так в принципе вот такие константы У нас есть Можно ими использовать Поэтому в принципе в той же документации по поса Вы можете часто встретить ставьте ми1 о на по и ваш мастер будет жить вот сохраните мастеру жизнь да так вот А что ещё можно сказать про о Killer У нас есть вообще глобальные такие рычаги для управления ом киллером А вообще есть параметр Пак О вот это да А и он стоит по дефолту в ноль то есть срабатывает вот эта ситуация Kill которую я описал можно поставить о у вас тогда будет K Pic и вся система умрёт и не знаю зачем это нужно но наверное на каких-то системах это не так уж плохо да то есть на каких-то специальных где либо система живёт либо не живёт другого варианта нету а но есть гораздо более интересный параметр Вот это Om Kill alting Task а очень важный параметр и вы можете строить логику работы своего сервера потому что по дефолту вот тот самый эвристический поиск жертвы который мы описали который срабатывает Killer когда не хватает памяти он идёт убивает выбирает и так далее но если вы выставите вот этот параметр в единичку то будет всё проще кому не хватило памяти кто кто кто запросил больше чем есть тот и умирает простой подход кажется Почему бы не поставить это для всех но опять же если мы говорим про те же сервера баз данных то Это скорее всего самый нужный Селект который запустил генеральный директор и хочет выбрать не знаю там статистику за год вы конечно не хоти Ну иногда это могут быть аналитики аналитиками можно пожертвовать Но не все хотят Так ну и теперь переходим к небольшой сти вот это а как ом дружит с нашим кубернетес и как бы про си группы мы уже упомянули можно сказать что у нас есть о Killer который большой System Killer который убьёт процесс не взирая ни на что А есть вот те кто работает в рамках си Group и вот здесь очень интересно как же это работает и как это устроено я буду говорить только про си grp версии 2 Я за то чтобы мы развивались значит у вас всё равно если не сейчас то завтра появится СИП версии 2 и как бы надо иметь в виду как Как же оно всё-таки работает а вы с помощью вот такой команды то есть всегда можете посмотреть сиг конкретно взятого вашего процесса да то есть а есть параметры памяти выставлены на конкретно вашу си группу среди них если Вы посмотрите есть важные это Low High Min ма и статистический который отражает текущее состояние и так далее и отношение к какой-то ом группе Memory mean вот вот это очень интересно на самом деле у нас есть так называемые реквесты в кубе Да все пользуются с квестами это чтобы забуть какое-то место на нох чтобы сду нам наши поды правильно разместил но на самом деле как бы C grp тоже предполагает вот эту прямо защиту Да которую Он позволяет жёстко защитить по данный процесс но пока реквесты кубера И кубер даже в тридцатых версиях этими параметрами не пользуется но будем надеяться в следующих версиях это будет использоваться Потому что есть регулировка это через Memory Min через Memory Low которая позволяет в общем-то оперировать этими параметрами ЕС подробнее а то как бы здесь срабатывают следующие механизмы что даже если не будет под то есть Memory Min будет смотреть так Да допустим вот сейчас как это происходит вы забули например сделали реквест для вашего пода на гигабайт Ну допустим да Вот Но то есть скер нал по квестам других и сюда ваш процесс поместил вс хорошо Но другие процессы вдруг выжит эту память и им а у них Нет лимита им пофигу что вы рексти ваш гигабайт они не будут на это обращать внимание Но если в дальнейшем будет ильва механизм позво кна чем забитого как раз Memory Min это вот то чего Мы ждём и хотим и тогда в этом случае э память которая зарезервирована не будет выделяться и соответственно будет вызываться ом Но пока я специально проверил даже на версии 130 я вот этого не увидел вот а вот Ma то есть лимиты ра да они работают СТ они работают именно по СИ группам То есть это жёсткое ограничение да то есть есть мягкое ещё ограничение То есть когда там начинают механизмы раньше срабатывать выделение там памяти там вытеснение кого-то в своп кого-то из активных куда-то ещё где-то ищется память А есть то есть всё очень просто если мы достигли вызывается килер для си групы вот вот вот вот этот именно параметр в си группе отвечает за тот самый 137 ошибку когда у нас а происходит именно убиение всей си группы как это регулируется вообще есть очень интересна А ещё одна регулировка для си группы это параметр Memory Group А и здесь есть два варианта внезапно тоже выбрать и убить процесс в группе либо убить всю си группу Как вы знаете у кого У кого соблюдаются все Best и в поде только один процесс и у вас нету подов в которых больше одного процесса что а в есть процессы Где в кубе Я не знаю в поде какой-нибудь супервайзер D и под ним что-то страшное например ПХП вот тоже да то есть для вас имеет смысл обратить внимание на вот эту Вот потому что терять весь пот иногда обидно проще прибить конкретный процесс и Можно также мониторить то есть опять же есть Car и в принципе Почему я про эти метрики вообще говорю наши стандартные вот наш айр и иже с ними да то есть метрики которые мы собираем с подов по тому вообще когда мы наблюдаем за метриками как у нас в кубе расходуется память там тоже всё не очень тривиально я сейчас расскажу Они смотрят вот сюда на метрики именно си группы то есть то есть изначальный скажем поставщик метрик а то о занятых ресурсах у нас непосредственно ядро через все группы отдаёт вот эти данные А какие же метрики А вот здесь вот интересно то есть у нас есть это наши любимые метрики кто их узнал Поднимите руки да то есть всем знакомы да И как же их считать потому что оно всё не очень а тривиально считается вот самая та самая RS Что такое RS Мы с вами уже знаем И мы знаем что он включает в себя есть также Memory вот этот А это очень тоже интересно потому что это открытые файлы которые в кэше тоже лежат А есть вот тот самый достаточно така коварная Метрика и мы на них примерно на всех ориентируемся на вот эти метрики Да и есть собственно лимиты и собственно US by который вот этот US который включает в себя и rss дефа и ш да то есть US by считает в том числе наш кэш это важно файловый кэш то есть мы прочли он лежит там в памяти он потом вытеснит конечно через какое-то время станет неактивным и так далее но надо иметь в виду и поэтому как можно сказать как работает подвести итог Как работает он в кубернетес частности си Груп считается полный объём занятой памяти си Груп то есть rss плюс кэш вгп опять же к супервизор D возвращаемся то есть там 10 процессов мы считаем память всех проце это важно он происходит внутри группы и пытается высвободить память внутри группы если не получается пытается найти память снаружи группы То есть это вот такой вот алгоритм если ничего то приходит ом и либо убивает всю группу что в принципе мыш кубе нам пофиг нам можно прибить либо либо какой-то один процесс если мы прямо хотим чтобы оно жило Ну и ещё пару моментов Это был про вот тот маленький ом который работает внутри си группы с ним всё хорошо всё понятно но у нас кто сталкивался с подами То есть у вас всё настроено но пришли и убили и у вас даже до лимита не дошло что же такое У нас есть Иа кода лет запускает ваши поды он назначает дефа им в зависимости от их кса то есть гарантированы то есть у кого лимиты равны квестам всё понятно Они они почти Бессмертные Best это который ни квестов ни лимитов Кто попало шпана какая-то убьём в любом случае первыми подгонять значени но опять же имейте это в виду если вы не хотите чтобы ваши поды вились Обратите внимание на вот этот момент ещё раз внешний ому который большой системный ему в целом Пофиг на все группы когда не хватает памяти он приходит и начинает разбираться что же там произошло собственно у нас не так много времени осталось поэтому переходим к выводам первое Омки ваш друг и помощник без понимания как же он работает вам будет с ним сложно это однозначно ВС что мы сегодня видели это код ядра Как видите он не такой страшный Если вы туда не лазили раньше то рекомендую начать его иногда подсчитывать как я убедился тоже готовясь опять же к этому докладу ориентироваться на документацию тяжело проще заглянуть в код более веря информация ядра не только не страшно но и полезно и понимать Как устроена память в Linux нужно а в любом случае потому что без этого как бы вам будет сложно понимать что происходит у вас а в системе куда утекает память почему там срабатывает ом Почему срабатывают какие-то ещё состояния да то есть Почему у вас запустился Антивирус а а умер мастер постгрес да Ну как это достаточно То есть я не раз встречал этот случай поэтому я про него повторяюсь это очень много где сделано потому что мало кто поднаема под базу данных ну и собственно мы уже практически пришли к завершению ещё раз регистрируйтесь Кто не успел мы перейдём с вами в дискуссионный в дискуссионную сечас и там можем побуждать а с вами различные кейсы и различные параметры Ну и в целом поговорить Если у вас появились Вопросы Спасибо Алексей очень интересный доклад Ещё раз спасибо всё всем счастливо Спасибо"
}