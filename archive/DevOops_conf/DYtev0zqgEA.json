{
  "video_id": "DYtev0zqgEA",
  "channel": "DevOops_conf",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "и вот мы уже втроем в нашей виртуальной студии привет вова привет игнат игнатов как вы уже могли догадаться будет выступать спикером владимир будет техническим экспертам тем самым человеком который будет задавать интересные вопросы по ходу доклада в конце доклада возможно даже перед докладом владимир слово тебе представься пожалуйста расскажи какие то вводные слова привет всем я владимир инженер производительности в компании крокер и давайте же начнем с первого вопроса а нужно ли вообще криптография и кому она нужна и нас скажи пожалуйста вот у вас club flyer вам криптография очень-очень нужна или не очень ну нам криптографии где окажется нужно всем она нужна и нам и нужно и конечным пользователем например клал сферы то сам можете знать на из очень крупных сетей доставки контента и одна из фишек клаус и что если вы используете насколько свою сеть доставки контента ваш контент моментально будет распределен по всему миру более чем 200 дата центра ну и допустим то есть ваша информация уже будет храниться по всему миру в 200 дата-центра вам будет спокойно ли вам будет спать если вы знаете что допустим каком-нибудь какой-нибудь провинции китая любой представители местной спецслужбы может зайти в этот центр вытащить диск с вашей информации и спокойно и если вы не можете спать спокойно с такой мысли это вам конечно же шифрование надо а я вот хотел еще уточнить возможно это исключительно моя серости в ответ будет к нему очень простых но вот в описании докладу сказано про то что вы значит написали патч софтовый модуль для ядра по сути но в то же время еще затрагивается вопрос аппаратного шифрования как вроде бы всем известно что аппаратное шифрование обычно на порядок быстрее программного да то есть проще купить хранилища в котором есть какой-то свой супер шифрующая чип и он будет все за нас делать как раз таки в том числе на youtube зачем же тогда нам нужно аппаратная реализация этой программной а ну на самом деле мы используем полу аппаратную реализацию то есть мы используем для того чтоб получить быстрое шифрование в современных процессорах с 86 stories некая аппаратная поддержка но она все равно как бы реализуется на программном уровне докладе немножко затронуть этот вопрос я бы более детально там расскажу но если так коротко то есть причины почему даже например вот microsoft недавно перестал использовать аппаратное шифрование для своего решения прозрачного шифрования bitlocker и эта причина в том что это аппаратное шифрование но как бы как правило проприетарной и очень часто скажем так не столь не прошло все вот эти этапы очень и тщательного review для реализации поэтому там очень часто находят разные дыры поэтому как бы что что опасно опасно и не имеет шифрования но еще более опаснее my думать что у тебя есть шифрование когда она сама если у тебя его нет поэтому в этом плане это вопрос безопасности то лучше обезопасить себя и так сказать дельно не надеяться на сторонних разработчиков это знаете как недавно посети гуляла картинка с такой с цепочкой фаерволов и там сначала стоит firewall от китайского вендора типа для общих блокировок потом стоит firewall американского вендора для блокировок значит дырок в китайском firewall потом стоит там firewall не знаю вендора в отечественную например для блокировки значит дырок от двух предыдущих и чтобы еще товарищ майор тоже не огорчался и мог посмотреть что же все-таки у вас происходит владимир может быть у тебя тоже есть q это вопрос а то и так весь эфир то занял да как раз я хотела спросить как наш слушателя использовать шифрование линия давайте узнаем я для этого просто лига не пустил внизу и ссылочка на telegram подключайтесь и отвечайте обсудим да где и как используют шифрование и на этом давайте наверно переходить докладу полностью поддерживать привет всем спасибо что подключились меня зовут игнат и сегодня мы поговорим про прозрачное шифрование данных на linux как сделать его в два а то может быть и в 3 раза быстрее и так вперед немного о себе сначала я работаю в компании клуб эра я занимаюсь производительностью безопасности систем crossfire мне очень нравится вопросы безопасности и криптографии я также люблю заниматься низкоуровневым программированием я очень люблю колупаться в ядре linux заниматься разными так за грузчиками и другим низкоуровневым личным кодом и так шифрование данных при хранении давайте поговорим немножко про это чтобы реализовать шифрование данных для хранения можно разными способами и чтобы понять каким лучше всего способом это делать давайте рассмотрим типичные 100 с так хранения данных на типичной операционной системе то есть верху столько у нас есть некие приложения или сервисы которые непосредственно реализуют бизнес-логику им нужно записывать и читать данные с разных там носителей то есть эти приложения они записывают и читать данные файлах и то есть они общаются с файловыми системами которые файловой системы уже реализованы непосредственно вашей операционной системе и что эти файловой системы делают они берут эти файлы и разбивают их на отдельные блоки и пересылают в блочную под систему наши операционные системы и где эти должны где блочные подсистемы непосредственно присылает и дальше через драйвер и мощных устройств непосредственно на наши хранители да то есть это такое высокоуровневая модель стыка хранения данных и с точки зрения шифрования данных и его можно реализовать на любом уровне и и из этих на в любом уровне это вас так то есть допустим на самом низком уровне мы можем просто купить наши хранители до охраняя хранение наши диски которые будут реализуют аппаратную поддержку хранение данных такой есть стандарт опал и и сайт что просто расшифровывается как сэл хан крум диск также шифрование прозрачное шифрование данных можно реализовывать на ул и на уровне точный процион блочной подсистемы операционной системы и здесь у нас есть несколько вариантов то есть у нас есть лак с димкой который будет основной темой этой презентации если вы используете windows у вас есть bitlocker и на mac os у вас может быть использоваться файл волк для этого для этих целей также банной можно шифровать нового не файловой системы опять же например и в операционных системах linux есть несколько решений более старые решение это и ключе фас шифрующая файловая система также изначально каком-то какой-то момент времени их стефан начала делать поддержку шифрование и оно переросло в более такой универсальный фреймворк который поддерживает было более больше фаворский не только x тифона называется а вскоре в конце концов шифрования данных может быть элекзил на самом приложении например некие базы данных мер имеют встроенную поддержку шифрования также другие приложения могут использовать никакие крипты библиотеки и типа окон с элитой мисс чтобы шифровать данные периле чем их отправлять для записи пво ну давайте рассмотрим достоинства и недостатки быстренько каждого из подходов то есть достоинство аппаратного шифрования непосредственно ваших ваших носителях данных очевидны да то есть вы купили это железо то есть эта поддержка там есть вам принципе ничего делать не надо практически ничего конфигурировать не надо и на самом деле это полное решение полностью прозрачна для самих приложений то есть приложение не надо фильм поддержку шифрование для записи и чтения данных они просто пишу это диски диск для них это все зашифровываем и еще один еще одно достоинство в том что это как правило быстрее чем другие подходы потому что аппаратное шифрование как правило быстрее чем программное вы не тратите ресурсы вашего вашей операционной системы чтобы делать и тоже есть недостатки да как правило всех дать и реализации аппаратного шифрования в дисках они проприетарные и вы не можете заглянуть как это все реализовано и потому что практически никто туда не может заглянуть как правило получается что часто эти реализации бывают небезопасны и дней находят уязвимости и на самом деле последнее время их было на один настолько что например microsoft до своей спать системы bitlocker с какой в этом момент времени решила использовать программное шифрование по умолчанию даже если аппаратное шифрование доступна на определенном носители достоинства прозрачное шифрование на блочном уровне очень похожи на аппаратное шифрование то есть она также прозрачно для приложений то есть приложение не нужны ни какой код реализован чтобы шифровать свои данные также не нужно его достаточно легко конфигурировать но достоинством есть то что если вы используете операционную систему с открытым исходным кодом как linux то вы также можете когда заглянуть убедиться штамм все правильно реализованы есть недостатки конечно то шифровать блочные данные достаточно сложно потому что современные крипто алгоритмы разработ разработаны для шифрования и в кино швами потока данных на уровне блока у нас мы должны каким-то образом безопасно шифровать отдельные блоки данных также как так как это уже теперь программное решение у нас могут быть потери производительности потому что мы должны тратить ресурсы нашего наши операционные системы для шифрования и как у любого другого программного решения у нас еще одним недостатком места что теперь у нас ключи шифрования находится в оперативной памяти нашей главной операционной системы что не дай бог будет найдена какая-то уязвимость то есть некий злоумышленник может попробовать утащить эти ключи фронтами с нашей операционной с оперативной памяти шифрование на уровне файловой системы идет на одну ступеньку выше то есть она практически прозрачным для приложений сейчас мы поговорим допустим она позволяет более тонкую настройку шифрования то есть на одной системе можно иметь разные папки одна папка будет шифрованное другая нет то есть если приложение бутылки ровную папку на данный будет прознать зашифрованы для этого приложения если она помнит ни скромную папку но будет не зашифрован достоинства места что как и если у вас опять же операционная система с открытым кодом и тоже можете туда заглянуть более тонкие настройки то есть можно настраивать и разные школы не шифрованные папки разные ключи шифрования на разных папок разных ключа шифрования данных пользователя далее далее и больше выбор алгоритма шифрования так как файлы а система видит уже у файлы то есть он видит целый поток данных то есть она может использовать другие алгоритмы работы для потоков данных не только для блоков данных но есть и недостатки опять же как и любого программного решения у нас есть проблемы с производительностью и ключи шифрования нас в оперативной памяти так как у нас больше возможностей настроек и это тяжелее настраивается и еще один недостаток безопасности в том что ширвани и новые файлы и системе у нас есть шифруется только на и ну не метаданные например имена файлов или размер файлов зашифрованы не будет поэтому она может послужить дополнительным каналом утечки информации для потенциального злоумышленника и опять же шифрование на уровне самого приложения опять же если вы владеете кодом этого приложения можете туда заглянуть то есть она открыт только пара мере для вас она очень липкая то есть как у вас как вы хотите так и реализовывать и себе шифрованием вашем приложении ну и как же вы можете использовать любую криптографию какие хотите алгоритма такие используйте недостатки как и у других программных решений вас ключи шифрования будет в противной памяти также она уже не прозрачна это шифрование то есть если вы хотите шифровать данные в приложении вам нужен добавить код вашего приложения которые это будет делать даже и используя готовые библиотеки также у вас будет не шифрованные метаданные ну и другим недостатком также есть что вы можете использовать любую алгоритмы шифрования не все разработчики знают как правильно использовать алгоритмы шифрования даже если используя стандартной библиотеки типа у панаса сел и в итоге ваши криптосистем может быть небезопасно если вы неправильно и выберите параметры для того или иного алгоритма шифрования что касается клаус формы как и любая другая как большинство других счас компаний мы предпочитаем шифрование на блочном уровне операционной системы опять же мы хотим шифровать все данные без исключения то есть нам в принципе не очень важна гибкость настройки которые позволяют шифрование на уровне приложений или на уровне файловой системы но сафара не на уровне точно посетим предоставляют более безопасное решение трек метаданные будут зашифрованы но в тоже время мы тоже не хотим зависеть от потенциальных уязвимостей реализациях аппаратного шифрования поэтому мы как бы предпочитаем использовать вот прозрачное шифрование на уровне точной под систему про который мы на linux потому что мы используем linux про которые мы я сегодня и поговорим на linux он называется d.img рыб но чтобы говорить про game clip надо сначала рассмотреть что такое девайс mapper и 8 это очень интересный и полезный фреймворк в ядре операционной системы опять же допустим у нас есть приложения или сервисы они и читают и пишут файлы то есть они общаются с файловой системой и файловые системы транслируют эти файлы в блоки данных и в общем случае отправляя с помощью драйверов блочных устройств записывать читают эти блоки с непосредственно с нашего железо что позволяет два из мальты 8 бар позволяет вставлять модули между файловыми системами и драйверами блочных устройств и предоставлять некий дополнительный функционал например game рейд модель позволяется выделять программный рейд массивы для миру модуль позволяет прозрачное создавать бэкапы данных целого носителем ну и в этой презентации мы говорим про один клип которые позволяют вам прозрачно шифровать данные когда выходите при записи их на блочное устройство давайте рассмотрим детальности что-то делать демки опять у вас есть файловой системе есть драйвера блочных устройств когда едим клип будет вставляться посередине она файловая система хочет записать блог демкин перехватывает так запрос на запись шифрует информацию которую хочет записать файловой системы и опадает вниз по стыку и когда файловой системы хочет прочитать какой-то блок данных опять же димкой перехватывает этот запрос читает шифрованную информацию с диска расшифровывают и отправляет рифленую информацию по власти достаточно просто и в принципе им крюк модуль не реализует никакой своей криптографии он использует стандартизированной криптографию который предоставляет самую ядро linux linux культу этой который открыто стандартная и была исследована многими исследователями по безопасности во всем мире и хочется надеяться что там все реализовано правильно и безопасно ну это все конечно хорошо то есть вот мы включили нашего прозрачное шифрование стали расшифровать все подряд но что-то не то у нас получилось продакшене мы стали замечать что некоторые сервисы теперь немного менее производительные чем чем раньше то есть и всякие там измерения нам показали что одна из проблем это как раз именно прозрачное шифрование поэтому мы решили сделать некий такой benchmark и померить насколько все-таки прозрачное шифрование в linux влияет на быстродействие и на производительность ну для нашего бенчмарка чтобы исключить у нас есть много поколений разного оборудования чтобы исключить влияние непосредственно самого аппаратного железа на на наш winch марк то есть мы решили грубо говоря использовать самый быстрый диск который только можно для измерения этой производительность а какой самый быстрый диск это никакого диска и счастье на linux можно создать некий виртуальный диск виртуальное блочное устройство прямо в противные памяти аль так как оперативная память намного быстрее чем более менее современный и твердотельный носитель то есть как бы надеемся что мы получим более точные результаты вот допустим вот этой командой мы создаем виртуальный диск в оперативной памятью на 4 гигабайта теперь мы просто создаем еще один пустой файл на 2 мегабайта отдельный я сейчас скажу зачем через пару секунд и что мы делаем мы используем команду конце так чтобы отформатировать наш новосозданный виртуальный диск и создать на прозрачном зашифровать его с точки зрения операционной системы и при этом мы используем вот этот вот новый но в осознанные 2 мега бальный файл как заголовок вот это ваше право не то есть вот наш тестовый стак который мы создали для нашего бенчмарка то есть внизу стояка у нас есть наш виртусам виртуальный диск сверху с помощью клипсы так мы создаем поставили instance вот этого прозрачных шифрования game crack ну и в качестве файловой системе мы решили опять же чтобы не портить результаты нашего быть марка не подмешивать производительность той или иной файловой системы мы для этого бенчмарка не будем использовать вообще не какую файловую систему то есть что мы можем делать можем непосредственно с приложение читать и писать блоки данных вот на наше устройство encrypted рандира вал и тогда наши данные будет прозрачным зашифрованной или расшифрованной операционные системы мы также можем просто читать и писать данные непосредственно на наш виртуальный диск то дайте данные не будут зашифрованы и мы как бы можем просто мерить производительность сетевых подход разницу между производительность единых подходов и для этого мы кстати использовали вы тот 2 мегабайт них заголовок в отдельном файле потому что по умолчанию если вы не будете его использовать где клуб сетап создаст этот заголовок в первых двух мегабайтов нашего виртуального диска и когда мы просто будем читать и писать данные непосредственно наш виртуальный диск в нашем бенчмарки случайном порядке можем случайно стереть этот заголовок как бы просто разрушить нашу наш тестовый star поэтому именно для вы не нужно это делать продакшен о имена для вот этого банка марка мы делаем этот заголовок пап отдельном файле и принципе вот мы запускаем самый простой последовательный во славу и сейчас мы просто меряем производители с непосредственно нашего виртуального диска то есть производительность грубо говоря нашей оперативной памяти то есть он делает пятьдесят на пятьдесят процентов ощущение запись последующей тельные запись и после прогоны мы видим что производительность и чтение записи у нас примерно одинаковое это примерно чуть больше одного мегабайта в секунду что достаточно неплохо давайте теперь повторим этот же самый workflow только уже с использованием прозрачного шифрования то есть мы просто поменяем наш виртуальный диск на наш день creed instance то есть и все наши данные будут прозрачного зашифрованные при записи и прозрачно расшифрованы прочти и тут же мы видим что производительность и чтение записи падает примерно до 150 мегабайт секунду что есть в 7 раз медленнее чем без прозрачного шифрования да конечно мы понимаем это программное решение что мы должны ожидать некое падение производители но по моему их семь раз это слишком чересчур gun а сколько не чересчур сколько вот можно ожидать то есть какой у нас пару пару чтобы оценить его к счастью утилиты хлебцы tab есть имеет встроенный бенчмарк которые просто показывает производительность и всех криптографических алгоритмов которые можно использовать для прозрачного шифрования на linux и допустим от производительность аяз xts который по умолчанию используются в гейм крипты которые мы использовали на нашем бенчмарки его производительность где-то 18 мегабайт в секунду для шифрования 18 до 1 шифрование данных то есть и семей грубо говоря построим систему такое очень глупую что мы возьмем четыре байта и хотим его прочитать с нашего зашифрованного диска и наша система будет работать так что мы сначала просто прочитаем все все все данные все четыре гигабайта дисков зашифрованными идей просто прогоним его через наши алгоритмы как два последовательных шага то принципе производительность вот такая система у нас должна быть если мы и с учетом того что если мы читаем со скоростью 1 и 1 гигабайт секунды расшифрованы скоростью 1 8 гигабайт в секунду производились вот такой последование под систему нас должна быть примерно 350 мегабайт секунду и если учитывать что скорость чтения записи и шифрования и расшифрования одинаково то есть в обе стороны система симметрично это общая производительность пропускная способность такой системы будет 700 мегабайт секунд но из того что мы померили так как мы получаем 100 50 мегабайт секунду в каждую сторону то общая пропускная способность системы у нас всего лишь 300 мегабайт секунду что вы бы говоря более чем в два раза хуже чем наш достаточно такой очень пессимистичный наша пессимистичная оценка то есть что как-то не клеится то есть что-то надо вот здесь улучшать и мы пробовали много разных вещей то есть мы попробовали сначала чтобы улучшить производительность попробовать другие алгоритмы шифрования но а из экспресс который используется по умолчанию похоже что это самый быстрый вариант по крайней мере на платформах x86 и и за их не аппаратной поддержки этого алгоритма но также заметили что game ключ есть некоторые флаги с помощью которых можно подкрутить производительность они так и называются флаги производительности сам себе крутым совместном клип цепью на включение эти флага нам ничем не помогло практически производились практически не поменялась но мы даже рассматривали вариант окей если мы не можем сделать днк индустрии если мы перейдем на шифрование с помощью на уровне файловой системы что-нибудь поменяется ничего не поменялось продакшене это даже еще медленнее получается вид из за того что на уровне файловой системы уже не шифры метаданные она и еще и менее безопасно и что они есть ну мы были в отчаянии что же делать и мы просто решили попросить помощи у комьюнити то есть мы написали провели наши данные по измерению мы едим крупный len list ну все что мы получили в ответ это следующая что если у вас заботят эти результаты то это только потому что вы не понимаете как работает криптография что криптография это очень дорогая тяжелая операция вам просто стоит ожидать падения производительности и тут я даже задумался неужели в современной криптографии настолько ресурсоемкая и я решил произвести научное исследование по этому вопросу и под научными исследованиями я подразумеваю в то что я в гугле набрал насколько лесу писаренко и современные криптография самое интересное что один из топовых результатов которые были более-менее релевантным пойму запросу это был бог просто моего коллеги skyfire который из именно исследовал этот вопрос но в контексте tls обрабатывает очень много тело соединений как бы он хотел посмотреть насколько сколько ресурсов мы тратим чисто на шифрование вот этого всего васити вова трафика его выгод выводу в том что на самом деле немного меньше чем по моему три процента всех наших процессор ных ресурсов мы тратим на криптографию по всему миру и это благодаря тому что современный x86 платформы реализует аппаратную реализацию алгоритмов и как бы все получается быстро и дешево и тут и тут на самом деле непонятно почему же аэс в контексте тела с достаточно не ресурсоемкие но в контексте прозрачного шифрования такой ресурсоемкий то что то было не не клеилась и поэтому я решил более детально заглянуть во внутренность к все-таки в реализацию ding ли ты посмотреть что там можно может что-нибудь можно улучшить также вернемся к нашему модули game crack у нас есть файловой системы у нас есть драйверы блочных устройств посередине у нас есть наш game clip и как он будет использовать крутой пиарь поэтому как бы у нас есть два модуля который используется на самом деле когда файловая система хочет записать блок едим культово перехватывает game crack от его не сразу шифрует game крипте реализованы некие такие асинхронные потоки для разных операций и один из этих асинхронных потоком называется кейк людей это некая очередь то есть когда приходит запрос от файловой системы на запись как бы он попадает в эту очередь и ждет там пока вот этот асинхронный поток не обработает вот этот запрос когда этот на самом деле асинхронный поток обработает запрос все что он делает и направляет его в крипт ай пи ай на шифрование но современный фильтр опять тоже асинхронные там тоже есть свои синхронные потоки называется кейт любви поэтому запрос на шифрование может быть не сразу обработано опять подождет там в очереди и в конце концов будет зашифрован другим асинхронным потоком я правильно на обратном димкой ну димкой опять же не сразу отправить зашифрованные данные на диск он поставит его в другую очередь на самом деле эта структура красно-черное дерево для сортировки и немного позже есть будет еще один асинхронный поток который называется день cryptrade который возьмет эти все отсортированные запросы зашифрованными данными и отправит их непосредственно на запись похожие истории и для чтения когда файла стены хочет прочитать какой-нибудь блог он попадает дым крым и попадает другой синхронный поток очередь другого синхронного потока кейк любви и о проблем в этой очереди немножко он в итоге будет отправлен димкой в итоге прочитает эти зашифрованные данные с диска но он их не сразу расшифрует на на 5 опять поставить в эту очередь уже знакомую нам очередь кейк любви для расшифровки по синхронном потоки потом кей к любви и отправит этот запрос в крипту и пеленку пойдет на другой синхрон очередь асинхронный опыту какие к любви там будет в итоге расшифрован и расшифрованные данные попадают обратно половой систем на самом деле не много много очередей и синхронных потоков для того чтобы просто расшифровать или записать блок данных во мне кажется прошлом году я был на особняк он в сингапуре и там была очень интересная презентация этот генерал из гугла проблемы взаимоотношения между задержкой ограниченной задержкой в разных программных системах и количеством очередей или всяких там очередей в этих системах самопрезентация очень интересно и сам по себе и я рекомендую посмотреть но один из выводов которые я запомнила там что криничная задержка сильно варьируется от количества очередей в вашей программной системе и здесь на самом деле у нас один запрос может быть стоять до четырех стоять в до четырех очередях чтобы быть обработаны что как бы сильно много для на мой взгляд и я не думаю что эти все очереди синхронные потоки были добавлены просто так ну то есть должна же быть какая-то причина почему не там есть и я решил немножко заняться немножко археологией частью лидер код ядра операционной системы linux он находится в хранится в бить с полной истории контроля версий и здесь можно развернул эту историю можно понять когда что было реализованной и зачем на самом деле самое первое очередь кейко любви была добавлена в 2005 году и она как бы не было добавлено а как только сам тем как модуль был принят в главный кода person нас главный коды ядра linux там уже была вот эта очередь но она использовать только для чтения данных с комментарием что было бы не очень разумно расшифровывать данные в контекста прерывания что принципе есть смысл для кода 2005 года потому что в то время и linux культа и пьян был не асинхронными и и них не было в клипе не было своих очередей своих очередей и асинхронных потоком и поэтому если вы из контекста прерывания попросите расшифровать данные он начнет просто их расшифровывать тексты и рвания немного более синхронных потоках было добавлено 1006 году но не для того чтобы как бы распараллелить сам процесс а и для того чтобы использовать меньше степа самого hydraphase так ядра операционной системы достаточно ли nucomm достаточно маленький это такой ресурс важный и который не рекомендуют сильно много на него полагаться и поэтому если у вас сильно есть большая влажность функций так вы можете создать стать вошла в ядре и на с этой целью были добавлены литья синхронной потоки 2006 году чтобы разбить вот эту вот вложенность функций при шифровании данных вот эта сортировка запросом на запись с помощью красно-черного дерево было добавлено 2015 году и с комментарием что это лучше для крутящихся дисков потому что такие диски любят последовательную запись что в принципе имеет смысл а также она упоминает и севку шаги door это от системы которые тоже непосредственно управляет запросами на чтение и запись в операционной стиль linux и но она уже именно вот эта реализация сейф неужели не используется в современном мире поэтому как бы смысла уже нету и в это же время мы сразу увидели видим что были добавлены эти флаги которые мы пробовали использовать ранее которые нам не помогли эти флаги что они делают они выключают эти некоторые синхронные потоки потому что с комментарием что они плохо не сильно влияют на производительность то есть мы уже были не первые кто заметили что вот добавления вот эти всех асинхронных потоков каким-то образом влияет на производительность ну исходя из этого всего что можно какие можно сделать выводы что основ весь вот этот код вот эти все синхронные потоки были добавлены для крутящихся дисков где задержка чтения записи этого низко намного выше чем вот задержка запуска вот этого определенного синхронного потока к поэтому не решали другие проблемы как бы мы очень переживали за сколько задержки всей системы они добавляют добавляю вот этот асинхронный поток сортировка запросом на чтения запись наверное не соответствует принципу них сбил ван цин дует вал то есть модуль по шифрованию данных не должен сортировать запросы для этого есть другие подсистемы ведра и linux или наверное сортировка запросов должна выполняться именно там они здесь ну и сама вот это синхронный поток кейк рублей которая просто отправляет запросы на шифрование в крипто и 5 уже в принципе не нужен потому что современный крипто 5 тоже асинхронный и он современный фильтр 5 достаточно умён чтобы не шифровать и расшифровывать данные в контексте прерывания поэтому если даже вы отправите запрос из контекста прерывания он это сделает самой синхронном потоки поэтому специально для этого делать асинхронный поток вашей реализации уже не нужно что мы сделали мы решили просто выкинуть вот эту всю дополнительную этот функционал веди себя синхронные потоки и превратить вот это вот вот то что мы изначально представляли как она работает то есть ним крип модули это простой модуль который синхронно шифрует запросы на запись и синхронно расстроили допросы на чтения и чтобы добиться полностью этой синхронности мы также хотели мы хотели попробовать сделать клип taipei тоже синхронным именно для вот этого юз кейса чтобы полностью исключить влияние вот этих вот асинхронных потоков на быстродействие нашей системе что мы сделали мы просто разработали патч который принципе не удаляет код но он добавляет новый runtime флаг модуль game clip который выключает эти все асинхронные потоки если нужно скрыть то опять немного сложнее по умолчанию так как работает cryptoapi где для linux может один и тот же крипто алгоритм может иметь несколько реализаций и ядро само по умолчанию ядро само выбирает какую вам реализацию лучше всего использовать зависимости от аппаратных возможностей вашей машины но мы тут не хотели полагаться на ядро мы хотели использовать а я сам на это аппаратную реализацию алгоритма с платформы x86 и но проблема в том что это песчаная он ему нужен модуль процессора f пью которые не всегда можно использовать в некоторых контекстах прерывания из-за того вот как общая самореализованная операционная система linux ну и чтобы как бы решить этот вопрос мы написали отдельный модуль называется xtx прокси это отдельный модуль реализации с xts для linux культуры над скального круто и пьянь который делает обеспечивает синхронное шифрование аяз xts но мы реализован никакой свою новую криптографию что этот модуль просто делает это просто большой и файл statement на самом деле . нет никакой своей реализации он просто получая запрос на шифрование он просто проиграет можно ли в текущем контексте использовать модули в пью и в 99.99 процентов случаев можно и если можно он просто перенаправлять запрос на внутренней уже готовые ядра linux или готова реализацию а я sexiest который использует ясона и нашего аппаратное шифрование на x86 платформе мочи и в очень редких случаях когда f пью недоступен но просто перенаправляем этот запрос другой модуль это программная ли изоляция а я sxt сон также если уже есть в ядре но он не требует использования вот этого модуля и она немножко медными но из-за того что вот этих случаев когда нельзя использовать их при очень мало как бы вообще мы надеемся что вообще быстродействие системы не пропадает и самое главное это полностью все синхронно нету никаких асинхронных потоков мы никогда не будем стоять никакой очереди и ждать пока кто то обработаем наш код получили запрос обработали выдали окне все ну давайте посмотрим на результат давайте перезапустим наш тестовый patsou наш benchmark прелесть этого подхода в том что эта реализация обхода очередей в game clip реализовано с помощью флага фронтами поэтому его можно включать и выключать прямо под нагрузкой то есть вы вам не надо перезагружать ваш вашу машину вам не нужно останавливать ваши сервисы вот сервисы как пишет и читают данные с диска вы можете прям нашего включать и выключать этот также нам надо убедиться что наш новый модуль шифрования с xts будет доступен не друг поэтому мы его загрузим здесь ну и вот с помощью вот этой страшной команды мы включаем наш patch то есть эта команда делает две вещи первая она говорит deep fried не полагаться на ядро при выборе реализации крипто алгоритма а непосредственно использовать именно вот этот наш новый xt x proximo ду для шифрования и 2 что она делает она просто включает вот этот runtime флаг тайский она говорит земли с этого момента ты должен обходить все очереди асинхронные очереди обработки запроса на чтение записи ну после того как вы это ничего не произойдет чтобы вот это ваша конфигурация вступила в силу надо сделать вот еще вот этот цикл со спины зиван ну и вот результат это снимок с графика который мы использовали для езды этого бенчмарка и мы видим что в момент как только мы включаем наш runtime флаг наш patch производительность чтения с нашего виртуального диска вырастают более чем два раза меньше чем 100 50 мегабайт секунду аж до 300 мегабайт секунду так виртуальный диск у нас в оперативной памяти то есть при чтении записями примерно одинаковые ту же картину мы видим и для записи опять скачок производительности более чем два раза составьте steam и давать секунд до более чем 300 не давать для того чтобы не убедится что мы это benchmark мы просто не улучшаем производительность у виртуальной дисковой операционной в оперативной памяти вот снимок из реальных продакшен метрик с нашего графика когда мы включили этапа что есть эта метрика она меряет задержку в точки зрения приложения чтение записи на диск это один и тот же диск но жёлтая линия показывает задержку чтения и записи данных самого диска зеленый линия показывает задержку с точки зрения приложения записей данных дисков с game crack инстанция создана над этим диском то есть если мы видим что здесь землю увеличивает нашу задержку с точки зрения приложения чтения данных примерно в два раза как только мы включаем наш флаг мы видим что эти две линии сходятся и принципе чтение и запись данных шифрованного диска практически не отличима сочини записи данных общая задержка грубо говоря определяется только задержкой чтение записи данных самого железа и практически шифрование нас не оказывать не какое влияние на задержки ну и в конце концов чтобы убедиться что это в принципе хорошо вообще для нашей бизнес логики вот снимок из другого графика где мы мерили и 99 квантиль времени ответа с нашей системе сети доставки контента в пользователя так вот здесь мы есть 3 сервера зеленая линия это квантиль сервера с не шифрованные дисками красная линия это 99 пантин времени ответа сервера с шифрованный мне дисками с помощью стандартного немкой клипе мы видим что кто-то очень сильно она подпрыгнула синяя линия это опять же сервер синхронными дисками с кем круг но с нашими по чему мы видим что нам практически неотличима от зеленой линии то есть от не шифрованные близко то есть другими словами с точки зрения производительности нашей сети доставки контента шифрования диском нам обошлось бесплатно то есть мы не добавили никакой задержки для времени ответа это в принципе все что я хотел на сегодня рассказать то есть давайте сделаем некой выводы презентации я представил патч который может получить производительность прозрачного шифрования на операционной системе linux с помощью game crack где-то в два в некоторых случаях и в три раза и причем эту не добавляем никаких новых криптографических алгоритмов то есть он полностью совместим со стандартным game clip если вы уже использовали дим крипы зашифровали ваш диск с помощью game clip перри шифровать ву вам не надо потому что мы не меняем криптографии мы просто меняем немножко архитектуру системы и другое достоинство то что можно его включать и выключать фронтами этот режим не нужно перезагружать не сервисами сервере ничего и принципе можно включить эту поддержку грантами прямо продакшен нагрузкой вы также убедились что современные криптография она и быстро и дешевое и если вы видите некое падение производительности не надо сразу грешить на шифрование пересмотрите свою архитектуру может быть из за того что потери производя причиной потери производительности кроется где-нибудь там также поняли что добавление очередей и синхронных потоков не совсем хорошо влияет на производительность систем которые использовать современные быстрые хранители данных такие как ssd ними диске есть конечно и проблемы не все очень понятно есть еще работа которую хотелось бы провести исследование то есть с точки зрения наших текущих измерений этот патч он сильно улучшает производительность на если у вас во рту имеет очень маленький блог says размер блока чтение данных и очень делают очень много запросов на чтение данных если workflow немножко другой то есть если у вас большой размер блока чтения а запросам не так уж и много то на самом деле производительность даже не немножко падает также недостаток в том что из за того что мы используем вот этот вот кастомный xcx прокси модуль у нас вся система получается аппаратно зависимые то есть она хорошо хорошо работает и проверенно на платформах x86 но наверное надо еще посмотреть как она будет себя вести на платформах армии так далее ну и в конце концов ваши люди тотемами быть разными в зависимости от workflow зависимости от вашей архитектуры у вас могут быть другие результаты поэтому не надо сразу бежать и включать этот флаг сделайте тест по мерке производительность по мерке до после делайте эйми тест и так далее если вы учиться хорошо и если не что тоже не очень хорошо но все равно расскажите нам о своих результатах нам и очень будет интересным вот несколько ссылок которые может быть для вас полезны то есть первая ссылка это ссылка на утилиту клип сетап для настройки и форматирования дисков для прозрачного шифрования на линуксе трой ссылка это ссылка на man страницу низкого уровня утилиты game set up который мы использовали для включения нашего флага которую мы добавили с помощью патча третья ссылка это ссылка на мой блог прост где в принципе описано в читаемом виде все что я сегодня рассказал и даже больше а также оттуда можно скопировать и попробовать все команды которые просто в этой презентации 4 ссылка это nano ссылка наши репозитории на гитхабе где выложены наши патчи и вы их можете тоже взять попробовать у себя их написать свои результаты и 5 ссылка это даже не ссылка это просто коммент этот один из патчей был принят главный кода главной базе торе операционной системе ядра linux но с некоторыми изменениями то есть вот этот вот флаг обхода асинхронных потоков кем клип был разбит на два флага который они с помощью которых можно отдельно выключить асинхронной потоки для чтения синхронные потоки для записи но результат принципе один и тот же если у вас версия ядра 59 и любишь и вам уже не нужны никакие патче вы можете использовать просто ванильное ядро и попробуйте таки флаги сразу это принципе все что я хотел сегодня рассказать спасибо большое за внимание и надеюсь а сейчас сейчас онлайн и и буду готов ответить на все ваши вопросы пока что всегда большое спасибо отличный доклад очень интересный и хочу ворваться впереди владимира с вопросами чтобы далеко не уходить как раз такие вот в самом конце вы сказали что значит патч был включён в ядро в up stream это очень классно поздравляю дано далеко не каждому человеку получить такую ачивку своей инженерной карьере но у меня вопрос возник вот вы сами сказали что он был включен не полностью что один флаг был изменению изменен а какие причины этого потому что звучит это все логично я бы сказал ни один не изменен флаг просто у начальная реализации в нашем патчи был один флаг который если включить он обходит все очереди и для чтения для записи когда мы обсуждали эту проблему в моем листе там еще подключились ну другие потенциальные пользователи этой системы один из разработчиков который писал драйвер код кода м зонде ну да очень новых вот этих быстрых дисков которые как так же быстро как и для оперативной памяти и и в принципе была нужна моя нужна моя работа это как под мы с ними познакомились мы листе но как бы для него было важно чтобы именно обход очередей проходил только на записи на чтение как бы не обязательно поэтому в итоге мы решили разбить флаг который обходит все очереди на 2 флага что можно отдельно выключать обход очередей на записи обладатели дней на чтением мы допустим у себя выключаем сразу два флага не хотим никаких очередей но те пользователи которые будут использовать эти новые envy me диски им обязательно нужно выключать обход очередей на запись но обход очередей очередей на стене и они могут выключать как бы сами зависимости от их нужд а есть другая одна из главных принципов кода в ведра ядра linux и чтобы и не навязывать не какие решения потенциального пользователя просто предоставить ему необходимый набор инструментов поэтому рубля этот флаг позволяет пользователю конфигурировать как и каким как ему удобно то есть он для конкретного workflow и он видит что обход очередей на чтение не очень хорошо сказывается на его производительность он может когда-либо оставить но вот те же самые пользователи-2 envy me дисков им как-то будет сказано явным образом сотоварищ тебе обязательно надо этот флаг включить потому что если у него нет глубоких знаний поди им криптон просто пройдет мимо этой истории если он будет использовать вот этот новый memisc где нужно обязательно включить флаг the driver вот этого envy me диска обязательно включит этот флаг то есть там этот код был добавлен отлично да то есть если обязательно то система примет за вас решение но если не обязательно система просто предоставляет вам ручки и как бы вы уже можете крутить к хотите отлично отлично спасибо владимир передаю слово тебе у меня по чем она у меня как раз вопрос в эту же тему пользователи часто работают мы значения по умолчанию редко кто закапывается и ищет какие флажки по хоть и чтобы стал быстрее вопрос обсуждали ли вы вопрос включения этого режима вообще по умолчанию для всех дисков и если они включили то почему или если включили того почему до обсуждали мы очень даже сам линус подключился в наш наш 3d агентом высказывал свои мнение потому что он изначально вообще был против этих всех асинхронных потоков в системе шифрования но исходил и пока это было не включена по умолчанию исходя из того что как я уже упоминал в докладе еще пока не очень понятно как это насколько это эффективно потому что вот если у вас workflow где очень много маленьких запросов с маленьким blocks айленда там то как бы производительность и скачок производительности очень сильный но я вот делал другой тестирование на другом в колоде допустим я просто пишу очень много данных но такой очень скажем так делаю мало запросов но делаю большой блок says ну скажем так допустим вы там делаете backup restore анб отсюда ну да то получается как бы производительность или не улучшается в некоторых случаях и немножко даже падает или просто ну нужны грубо говоря нужны больше исследований почему так происходит и больше понимания почему так происходит и как бы другие пользователи в мали настя тоже как бы заметили подобные измерений бы мы сошлись на том что мы сейчас добавим эту поддержку которую и получим непосредственно выигрыш для вот хотя бы для части варп слова как только все будут больше понимать как бы нужно ли это по умолчанию то можно с каких-то следующих версиях ягер эти флаги будут стоять по умолчанию то есть мы этот вопрос очень сильно обсуждали это можно все найти в истории вот этого почерпнули листе кому интересно горло спасибо это значит по сути нужно обновляться на это самое ядро в котором есть прощу себя пробовать еще рабочие эксперементальный но не на всех случаях ускоряет я напомню слушателям можете хотя задавайте пожалуйста просится телеграммы их обязательно обсудим и давайте перейдем дальше у меня такой вопрос и говорил про большой бокс про бокса с большого размера и почему-то с ним работать хуже есть понимание или нет почему так происходит пока очень детального понимания нет у меня есть пока только гипотезы скажем так в зависимости от того сколько гонять тест я заметил что допустим если обхода череде и не выключать то допустим вот и ну и запускать этот файл workload то в разные моменты времени мы видим разную производительность ну грубо ряд допустим производительность начинает показывает где-то ну скажем так я цифры полностью с головы беру но самый порядок будет понятен то есть допустим производительность показывает один мегабайт в секунду и через грубо говоря минутки две три он падает до пол мегабайта в секунду потом опять прыгает до одного мегабайта xi если включить и обход очередей то производительность пропускная способность стабильная и она ровно в половине между одним мегабайта в секунду и полной то есть там 075 мегабайта в секунду и у меня гипотеза заключается в том что если у вас есть современные процессоры исключены хиппер трейдингом то производительность и физического ядра она ну немножко лучше чем производительность теперь трейдинга воевать его эмулированную ядра и когда workload прыгает или дизайн синхронных потоков то есть поток может обработать как на физическом и дрека так и на скажем так на а теперь трейдингом видео и производительность будет разным это моя гипотеза неправедно так можешь пояснить кратко шифрованию происходит до или после помещения данных в дисковый кэш у при чтении записи мы говорим про дисковый кэш и пракаш файловой системы сейчас давайте молодежь короче я если честно не совсем уверен вообще дисковый кэш мы потом я уверен утра по логике будем crypt вообще работает только с данными которые уже по идее должен работать только с данными которые уже идут на диск то есть который уже после всех кэшей то есть это точно после того как мы уже прошли кэш файловой системы и дисковый кэш скорее всего тоже тоже ну и разве что этот каш сами не реализован на аппаратном уровне в самом диске то есть я знаю там некоторое создать диски у них есть какой-то свой внутренне кэш то есть там данный будут лежать зашифрованные но потому что операционная система тут уже ничего не может поделать но грубо говоря идея в том что мы будем сорвать только те данные которые будут уже записаны на диск то есть нам нет смысла тратить циклы процессора на расшифровку данных который у нас останется в оперативной памяти если у нас там же рядом лежит культ шифрование вот здорово и тогда у меня вопрос а почему же а при amway не то говоришь прям обязательно смотрите конечно запись ведь наша операционная система сначала как бы по вечерней не каширского включаете шифрование синхронная при записи ведь у нас операционная система сначала помещать данные в кэш они там какое-то время лежат а после этого когда приходит время сбрасывать их на диск мы уже тогда начинаем шифровать и сбрасывать и по идее операция записи с точки зрения приложения должна быть более менее синхронный но это мы сейчас говорим про кеш java коли хочу уточнить я говорю не про in my desk где обязательно включать а про вот эти новые диски которые даже лучше чем envy me как по-русски правильно называются которые он виден вот что-то типа такого понятно это ты миша да димка verner of discourse становится димка как по выглядит к оперативная память но по сути является и про них да да я про не говорю и тут и уже на самом деле в линуксе и уже поддержка еще даже не очень хорошее в них потому что ну linux традиционный linux он работает как традиционной операционная система то есть у нее есть четкое разделение между оперативной памятью и ну persistent storage tote мтс дисковой подсистемы in видим как бы склеивает эти концепции там даже есть целая проблема что грубо говоря операционная система она хочет использовать кэш оперативной памяти но в итоге она использует один и тот же 11 ук тот же диски для записи как бы каша и для записи реальных данных просто копирует себя на себя и там я сейчас уже целый целый поток работ чтобы это как бы вот именно включить нативную поддержку и не перезаписывать каши в себя же несколько раз грубо говоря мы просто с точки зрения операционной системы мы никогда не сбрасываем каждый если мы работаем на nb диме мы никогда не сбрасываем кэш на реальный диск потому что он уже на реальном диски я понял это это очень здорово хорошие хорошее дополнение у меня такой вопрос на обычных крутящих дисках вы измеряли или нет как этот патч работает нет потому что у нас уже в процессе не их просто не осталось нужно уточняющий вопрос задам то есть возможно это совсем редкий случай но де дуплицирование стороны наверняка шани у вас есть для хранение там тоже надо шифровать или туда пишется уже заранее шифрованной информация дед дуплицирование стороны range то ли какой-то нет нет ну ты ими на архивное хранение то которое перед ленточками типа диди буйство например но возможно у вас этого просто нет у нас пробивается подругу смотри игнат допустим пользователь слова тв лпр показывают картинки с кошками и есть вероятность что тысяч или там миллион показывает одну и ту же кошку меня не вопрос это кошка приза шифрование будет наверное разное или одинаково то есть она у вас на диске будет храниться 1 или миллион раз нет но если это кошка принадлежит владельцу сайта одного сайта то это кошка будет записано один раз то есть но допустим если сайт с кошками популярные там придет 150 тысяч пользователей попросит эту картинку то это она эта картинка все равно с одного сайта и она будет записано 1а да если как бы это владельцы ну эти кошки на разных сайтах даже если это одна и та же картинка то она будет записано соответственно там столько раз сколько этих сайтов существу то есть у нас каш привязан к определенному адресу в бактерия ну то есть кэша хранит вне зависимости от того одинаково картинка или нет а вы их не дуплекс ролики на мера не не на записи нет а у меня такой вопрос пачку который ты говорил он применим для ровных и кей и есть ли какие-то ограничения на то какие пиво тоже не мы используем для того чтобы читать или писать даны нет никаких приложений нет то есть это ну он же почти реализован самой системе днк сама цель системы ген крипто сделать прозрачное шифрование то есть приложение как бы они даже не знают пишут они не вообще пишет файловую систему да то есть они даже не знают пойдет она там на зашифрованный диск на вообще виртуальный диск или вообще по сети то есть как бы никаких ограничений нет но опять-же говорю все надо мерить и с точки зрения именно конкретного workload а то есть если ваш workload приложение создает workle 1 диск где есть много запросов на чтение и запись но эти запросы маленький то как бы есть смысл попробовать этот флаг если workload другой тоже есть смысл попробовать это флаг только конечно лучше протестировать до и после или или допустим делать сайт бай сайд сравнения двух систем включены флагом с выключенным сделать замеры это всегда хорошая рекомендация давай попробуем погадать возьму и буду используйте синхронно чтение файлов с диска и тогда у меня надежда на то что данные будут понемножку подсчитываться и асинхронным будут расшифровываться и попадать в приложении в итоге картинка показывал будет непоследовательно чтение и qr шифровка параллельно до в идеале прям совсем правильно вопрос ты моя штуки наблюдал или это все мистика ей так не будет работать с я когда то делал замеры именно каким образом вот влияет если приложение там пишет асинхронно нус использованием каша файловой системы для синхронно на самом деле влияет не очень влияет но не очень то есть скажем так если я создаю workload который работает с размерами блока 4 килобайта да то есть и используя синхронно еще не запись приложения то как бы я вижу что на диск приходят запросы на чтения-записи 4 килобайта если я включаю выключаю синхронно чтение но использую стандартная синхронная с помощью каша файловой системы ну на диск приходит чуть чуть меньше запросов некоторые 4 килобайта некоторые 8 килобайт но чтобы такое чтобы пришел запрос там на 2 мегабайта я только не замечаются или то есть асинхронное чтение немножечко там может поменять ваш workload но не сильно то есть если у вас сам workload это много маленьких чтений записью они каким-то образом более-менее дойдут к вам на диск я вот опять хочу ворваться с вопросом как раз про размер блока данных то есть когда мы храним котиков картинки с котиками блок данных по 4 килобайта это конечно здорово но если мы переходим в нашем сидение к тяжелому видео контент у где в принципе чем блок больше тем он будет лучше то есть или у вас везде прибит гвоздями на всех хранилищах один вот размер блока и поэтому нет этой проблемы у нас три мины вождями размер блока на самом деле размер то блока ну когда мы говорим про размер блока нам очень важен размер блока самого вашего диска эффективно чтение и запись да то есть и в основном сам современные ssd они и onlime они работают по 4 килобайта как бы в с точки зрения эффективной реализации сидена нам важнее не быстрота чтении диска записи а эффективность каша файловой системы то есть на самом деле что чего мы хотим достичь здесь это если у нас есть очень популярные ресурсы мы вообще его не хотим читать диск моего хотим читать с каша файловой системы поэтому как бы вот исходя из этого если оптимизировать в ту сторону то размер блока не очень важно важно чтобы просто этот популярный ресурс находился в кэше были хоть на уровне выше нам сигнализирует что буквально через три минуты нас уже погонят с этого прекрасного места борьбе с вами общался владимир может у тебя есть какой-то быстрый вопрос последний да мне есть очень быстро вопрос исследование игнат которое он были докладе показывают что в ядро добавили 4 очереди с комментариями возможного через нужно возможно нет и все четыре по факту устарели что ты думаешь по поводу того чтобы в комментарии входе или в комментарии ли предоставлять такой код перепроверить через пять лет через пять лет она ломалась по да и собственно тот кто то увидел пошел и посмотрел а нужно ли еще это очередь ну это было бы конечно хорошо но я допустим очень слабо представляю себе эту реализацию допустим ну 5 лет наверно можно немножко предугадать и если там первый код был добавлен более чем 15 лет назад и допустим 15 лет назад никто даже не мог подумать что когда-то нас будет иметь низкий и которые будут там одну скорость и не записи будет скажем так тех кто добавляли эта очередь они не могли представить что когда-то будет хранилище и который скоро сечение записи будет соизмерима со скоростью типа запуска асинхронного потока на процессоре правильно поэтому как бы они вообще не заморачивались на эту поводу из габе аль диск всегда будет медленнее процессор и поэтому тут можно прийти через шипа решать наши проблемы это да то есть может для этого все-таки как этот вопрос решить для этого нужен review архитектуры да то есть на будущее предсказать тяжело а вот вернуться в прошлое легко то есть если не понятно там каждые пять лет брать посмотреть я как бы вот мы тут по добавляли вот этих всех штука нужны ли они действительно сейчас или можно это все выкинь это наверное более общая проблема разработчиков были легко добавляем новые штучки но очень тяжело прощаемся с теми штучками которые у нас уже есть да и как бы нужно забываем выделять себе время пересматривать уже готовые решения и соответствует ли те а сам шины реальности которые мы сделали пять лет назад отлично отлично что же коллеги спасибо вам большое за время было очень увлекательно игнат еще раз спасибо за доклад владимир спасибо за отличнейшую беседу слушатели зрители дорогие вы наши призываем напоминаю вот здесь вот здесь нажимаете кнопку зуб и пройти в комнату для дискуссий там беседа будет продолжена думаю можно узнать еще много что интересного нас нам расскажут в том числе club flora возможно даже не каждый день есть такая возможность и на этом я прощаюсь с вами и гнаться владимир спасибо вам ждём вас на следующих осин знак"
}