{
  "video_id": "b8rs9_r498k",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "Всем привет как слышно нормально отлично Меня зовут Шишкин Алексей Спасибо что пришли послушать мой доклад Я буду рассказывать как мы подключали Spark к нашей SQL платформе Я уже 3 года работаю в команде сыть она занимается интеграцией AP spk к системе и в связи с этим мне приходится много смотреть на с Парковый код где-то его менять Ну и в целом писать весь новый код опираясь на него Ну все мы наверное знаем что такое Spark это популярный фреймворк для обработки больших данных который поддерживает огромное число разных форматов и хранилищ и это незаменимый инструмент любого Дато инженера Однако когда мы подходим к задачам дата аналитики тут всё становится несколько сложнее потому что новоиспечённый простейший Селект запрос нужно установить с Парковый клиент нужно разобраться как подключаться к кластеру Как создавать вот эти самые сессии и вот там спустя денёк два он только сможет запустить свой Селект с другой стороны есть решения которые позволяют всё это делать из коробки буквально по одной кнопке но они как правило платные как я уже сказал Я работаю в системе в компании Яндекса Вот это платформа для хранения и обработки больших данных и у нас есть такой компонент как Он позволяет исполнить SQL запросы сокращённо мы его называем пол это и выглядит он следующим образом То есть можно написать какой-то запрос инить его Сва вид за поменять запустить заново а сверху у нас есть переключатель движков То есть можно исполнить запрос поверх какого-то классического мадса aql либо же поверх тя то есть Клик хауса и мы пришли к тому что нам нужен Spark SQL потому что многие имеют опыт с ним а с другой стороны у многих пользователей есть поднятые спарко кластера и Это хороший Шас переиспользовать ресурсы а вли ql с Парковый не имеет как таковых ограничений на гибкость на сложность запроса и с ним чуть полегче чуть полегче вкатиться для начала Давайте посмотрим как вообще qt устроен и что мы собственно будем делать к нам приходит пользователь с новым запросом он попадает в хранилище запросов он может его задать из веб интерфейса из консоли либо же из какого-то СДК затем У нас есть много инстан сов qt которые периодически отчитываются мастеру что они ещ живы и вот те что живы могут брать новые запросы и работает Это по принципу Кто первый возьмёт запрос того Он и будет Затем они берут свой запрос и идут движку и просит его исполнить а тот когда его исполнит он запишет результат обратно в персистентное хранилище Ну для истории для какого-то Наго хранения решили делать новый движок мы посмотрели на интерфейс нам нужно реализовать всего лишь два самых базовых метода нам нужно научиться запускать запрос и соответственно получать его результат А если пользователь Нажал кнопку отмена нам хотелось бы ещё и останавливать Все вычисления для экономии ресурсов но когда мы пришли к этой задаче понятное дело мы не тели какието свои велосипеды может нам ложить чтобы сделать это за минимальное время за минимальное количество действий Давайте посмотрим Ну во-первых из коробки У нас есть СФ сервер который позволяет запускать какие-то S по интерфейсу но проблема в том что он очень тесно связан с Хам и нести эту новую технологию в наш и Он позволяет по http запускать какие-то запросы либо джаб что угодно но он ориентирован на то что Спарк у вас бегает поверх ку Бернеса А у нас Спарк был в режиме и поэтому нам оно не подошло есть также те Он позволяет по http тоже что-то запускать но он только работает поверх па спарка и послед поэто http запускаться но он предоставляет целый скалой Shell то есть буквально скалою консоль где можно запускать произвольный скалой код и это звучит жутко гибко и соблазнительно Давайте посмотрим на него чуть глубже вот у нас есть поднятый ливи у нас он цепляется к какому-то спарко кластеру с Пыть Спарк в данном контексте это одно и тоже У него есть команда end по запуску сессии когда мы создаём сессию мы создаём интерпретатор который резервирует экзекьют на кластере и последующем будет запускать код мы можем запускать произвольный код и узнавать статус его исполнения то есть мы можем узнать насколько он продвинулся в целом может он пофлиртовать использовать где-то е хорошо И вот когда мы познакомились сли мы поняли что вот эти наши два сценария покрываются очень легко то есть чтобы запустить запрос нам нужно всего лишь создать сессию отправить запрос затем периодически пинговать сервер и дождаться финального статуса затем нам нужно получить результат и закрыть сессию А если пользователь исполнение то мы просто досрочно закрываем сессию Ну звучит очень легко Но на самом деле здесь есть два места где всё не так очевидно что значит отправить запрос У нас есть скалой Shell А к нам приходит SQL пользователя Что именно мы должны исполнить Какой код и Давайте в это углу есть мы можем запускать код и получать его консольный вывод что мы можем исполнить это запустить команду SQL от пользовательского запроса и вывести команду Show но мы серьёзные люди мы же не будем в конце концов парсить вот то что нам выдало имена колонок типы сами данные Ну звучит ужасно тогда мы стали думать что с этим можно сделать получше однозначно нам нужно запустить пользовательский запрос и получить датафрейм затем мы решили закодировать датафрейм в бинарный формат то есть в любую последовательность байт и мы выбрали внутренний формат для хранения таблицу просто потому что нам удобно на принимающей стороне его декодировать и сохранять но вы можете использовать там не знаю закодировать в ДСО в бинарные ДСО какие-нибудь форматы В общем что угодно а затем мы вот эти самые байти кодируем в 64 и вызываем печать в консоль и таким образом вот это вот та самая таблица которая получилась у пользователя а на принимающей стороне Мы будем её декодировать и Давайте пробежимся снова От начала до конца что у нас происходит от пользователя прилетает новый запрос затем мы создам сессию оборачиваем его в этот запрос в то что я показал пару слайдов назад затем периодически Пингу ливи о том закончился ли наш запрос когда он закончился нам прилетает в ответ закодированная таблица затем мы закрываем сессию и декорируем таблицу сохраняем её в персистентное хранилище и Аллилуйя У нас появился первый Запрос который успешно исполнился мы добились первого успеха то есть мы смогли написать какой-то запрос на спарке и получить Его ответ и Кроме того ещё один момент который стоит Сказать нам нужно как-то указывать какому кластеру мы Обращаемся Ну вот мы вынесли во всплывающее окошко можно указать кластер которому пойдёт запрос и дополнительный какой-то с Парковый конфиг но на бэнде это просто подкладывает в при создании сессии и все настройки применяются хорошо вот мы добились первого успеха Что работает из коробки работает неплохо но всё-таки для какого-то масштабного продукта хочется большего и тут Э мы стали шлифовать находить какие-то э шероховатые места которые можно сделать всё-таки получше Ну во-первых у нас запрос исполнялся 25 секунд для того чтобы считать шесть строчек это невероятно много кликхаус справится за одну секунду нужно что-то с этим сделать затем у нас был из коробки рабочий только сек А хочется побольше разных команд чтобы аналитикам было по комфортнее затем нужно подумать как максимально облегчить пользователю инсталляцию вот этого Liv сервера для того чтобы начать работу и исполнить свой первый запрос а последнее над чем мы поработали это над тем чтобы дать пользователю какой-то фидбек от исполнения его запроса потому что м кнопку ждт от 20 до бесконечности секунд в ожидании что ему назад придёт какой-то результат И сейчас мы пойдём по каждому из этих пунктов и я буду рассказывать что мы наградили чтобы этот функционал стал рабочий ну для начала Давайте подумаем Как мы можем ускорить запросы заметим что каждый запрос у нас содержит подготовительный этап то есть стадию когда мы запускаем сею и в конце мы ещ закрываем эту сессию Но на самом деле если пользователь пришёл к нам второй раз например там через пару минут мы можем использовать ранее открытую сессию снова и не тратить драгоценные секунды на вот это вот закрытие открытие и тому подобное а ливи со своей стороны может закрыть неактивные сессии по какому-то выбранному таймеру То есть например через полчаса неактивности сессии но нужно помнить что у нас много инстан сов qt которые могут брать эти Новые запросы и с другой стороны у нас один спарко вый кластер может использоваться целой командой то есть мы не хотим чтобы пользовательская сессия которая была создана для одного пользователя потом перешла ко второму потому что там могут быть какие-то сенситивные данные и это опасно Ну так как мы пишем вот какую-то сть Мы подумали что мы можем с этим сделать со стороны qt Ну во-первых мы можем создать какой-то выделенный инстанс который будет обслуживать парковые запросы но если мы так сделаем то у нас появляется точка отказа то есть упадёт он всё у нас не работает система для исполнения спарка Ну не очень хорошо с другой стороны мы можем позволить всем инстанса Q сохранять сессии запоминать какому пользователю Какая сессия принадлежит Но тогда встанет вопрос балансировки потому что нам нужно направить второй запрос пользователя туда же куда побежал первый а сейчас до этого у нас простая эффективная схема вот самый живой самый быстрый ливи быстрый qt который свободен он и возьмёт запрос и не хотелось бы так усложнять систему тогда мы стали думать А что можно сделать иначе Остаётся только модифицировать Liv А чего нам не хватает То есть как бы нам не хотелось как-то брать себе кодовую базу разбираться в ней но видимо придётся нам не хватает на самом деле одного простейшего эндпоинт по его имени и тогда вот допустим мы написали этот endp ну максимально простой там десяток строчек приходит пользователь Макс не находит сессию создаёт новую Потом приходит второй пользователь не находит сессию создаёт новую а затем приходит второй пользователь снова и мы ему отдаём эту сессию и он может поверх неё моментально исполнять какие-то запросы а затем когда все пошли спать никто больше не работает с системой эти сессии постепенно сами ото мрут хорошо Ну получается что нам нужно изменить какой-то код в ливе но нести к себе всю эту кодовую базу затем настраивать какие-то сборочные системы для того чтобы собирать чужой код нам не сильно хотелось и Поэтому вместо того чтобы делать форк и вносить туда какие-то патчи мы пришли к концепции ран тайм пачин эта механика на самом деле заслуживает отдельного доклада и сегодня расскажу о ней только в паре слов Когда приходит запрос на то чтобы подгрузить в память мки новый ливи вот этот вот класс Liv сервера он идёт к класс лору с жёсткого диска подгружаются эти самые байти и вот он уже готов отправить этот код для того чтобы в последующем его исполнить и тут мы кладём на Class Pass ещё один наш джаник который вероломно перехватывает этот запрос и добавляет буквально в байт-код э новую функцию то есть вот этот новый endpoint а затем как ни в чём не бывало отдаёт дальше и таким образом добавив использовав оригинальный дистрибутив и добавив всего лишь новый какой-то архивно урни на машинку которая поднимает ливи мы получаем что нам не нужно собирать чей-то чужой код нам нужно собрать лишь Нашу маленькую библиотеку и Зачем всё это было зачем мы так долго в этом разбирались а теперь создание сессий происходит однократно за какой-то пользовательский сеан и тогда второй последующие запрос у нас исполняются на секунд 20 быстрее То есть вы приходите со своим селекто первый Да будет там чуть больше 20 секунд но второй последующий будет секунд п а то и меньше а если мы говорим о простейшим 1 то он исполняется всего за 2 секунды то есть ВС это время стало уходить на именно Time круто Давайте посмотрим следующую главу изначально из коробки у нас поддерживается только Select а update и Delete не поддерживается спарм вообще изначально но есть ещё большое разнообразие команд которые нам хотелось бы поддержать которые было бы классно иметь для этого Давайте разберёмся Как исполняется сный код что ему для этого нужно для этого нужно две суно ней в котом будет это информация о создаваемых таблицах вьюшка и тому подобном а также нам нужно хранилище непосредственно для сырых данных и тогда Допустим мы исполняем Table нам нужно проверить существование этой таблицы и если таблица не существует то мы добавляем новую запись а затем когда мы хотим вставить данные схема таблицы получается опять же из этого каталога извлекается и только потом с хранилищем и пишем туда данные и в обычном мире вот у вас безальтернативной для хранения Мета информации Это буквально прибита в спарм коде Ну а в качестве хранилища вам всё-таки дали свободу То есть вы можете использовать hdfs либо S3 либо что-то ещё информация там схема таблиц когда она была записана и всё такое оно хранится вместе И это нельзя разорвать Поэтому нам Пришлось создать свой External каталог и делается это на самом деле не сложно Это буквально один класс где вам нужно описать как вы будете класть Мета информацию извлекать удалять Ну и вот подобные вещи и вот когда мы это сделали мы вспомнили что у нас есть ещё и вьюшки и подобные вещи а их мы тогда решили сохранять просто в памяти Пользуясь встроенным in Memory каталогом который запоминает вещи только на протяжении сессии и когда мы это сделали У нас заработали функции создания таблиц либо там до записи в них отлично Давайте пойдём дальше теперь нам нужно подумать о том как максимально упростить погружение пользователя в эту систему допустим аналитик приходит и хочет что-то поднять во что-то потыкать Ну если мы говорим о спт вых кластерах которые мы для которых мы написали клиент пользователь приходит скачивает этот самый клиент разбирается как его настроить пробивает себе сетевые доступы и вот с помощью этого клиента он поднимет машинки и поднимет на них нужные компоненты спарка то есть мастер воркеров history Север и подобное но у такого способа есть свои проблемы потому что успех зависит от окружения то есть пользователь скачивает на свою машинку клиент и с неё пытается что-то запустить но бывает такое что пользователь устанавливает Две версии клиента либо какой-то очень старый клиент и пытается поднять новый кластер То есть бывают разные случаи и с этим совсем тяжело разбираться потому что нужно задавать много уточняющих вопросов и узнавать специфику именно пользовательской системы а если мы говорим о том что мы испытываем как админы то у нас нет какого-то реестра Где мы можем посмотреть А какие у нас кластера запущены какой они конфигурации Ну вот подобные вещи и тогда мы решили посмотреть А что сделали коллеги из чит то есть кликхаус поверх тиус и они сделали интересную вещь пользователь вместо того чтобы с помощью своего клиента именно поднимать кластер как-то вот запускать его аллоцировать ресурсы он лишь помещает запись о том что ему нужен такой-то кластер в некое персистентное хранилище а затем компонент под названием Strawberry периодически смотрит в это хранилище если он видит что появились новые записи то он поднимает новые кластера если он видит что настройки каких-то существующих кластеров изменились он потушит старые и поднимет новые То есть он берёт на себя всю такую админскую работу но тут следует сказать пару слов о том как Т физически найдёт хост вот этих поднятых кластеров а для координации Мы решили использовать наши Discovery сервера это некий совсем упрощённый аналог зу кипера спарко мастер когда поднимается он вносит запись что мастер такого-то кластера сейчас находится на таком-то Хосте затем смотрит где поднят ма свою запись о том что жит на таком-то хасте и при этом используется понятный идентификатор и поэтому идентификатору может понять на каком Хосте сейчас запущен и Кроме того что мы как админы получаем реестр Где мы можем посмотреть какие кластера запущены В каком они статусе И вот все подобные плюшки со стороны пользователей это тоже имеет свои преимущества ро может сообщать пользователю о том какие кластера у него подняты Какие кластера ему доступны для запуска а пользователь из этого списка должен просто выбрать куда он хочет адресовать свой запрос а затем qt по этому шнику сходит в Discovery сервер и получит физический хост куда и пойдёт со своим запросом отлично И если мы говорим о интерфейсе то это превращается всего лишь вле достаточно тыкнуть в любой буквально кластер написать свой запрос и начать исполнение отлично И последнее о чём мы поговорим - это про визуализацию запроса к нам приходит пользователь он запускает какой-то запрос жмёт кнопку и всё у него бегает вот этот кругляшок показывает что запрос исполняется но когда он будет исполнен абсолютно Непонятно И на самом деле ливи там тут может нам минимально помочь когда Мы спрашиваем В каком статусе находится исполняемый код он возвращает нам некое число от нуля до единицы показывающие количество завершённых тасков относительно запланированных и мы можем отрисовать это в интерфейсе в виде такого прогрес бара Но если вы заходили в спарго webui то вы знаете что там есть вот такие симпатичные графы из которых можно достать много полезной информации узнать как текут ваши данные какое время занимает каждая стадия буквально количество данных пробежав и вот подобные вещи и поэтому нам пришлось снова подумать о том чтобы по патч ливе и опять это же этот патч минимальный Нам необходимо в тот ответ который нам присылает ливи на статус запроса дополнительно ещ присылать план исполнения то есть мы добавили поле Откуда можно достать этот план Ну вот у каждой с Парковой сессии есть такое поле как статус Где вы можете посмотреть достать все графы исполнения всех запущенных ранее запросов в рамках этой сессии и достать этот дф можно в двух форматах Можно либо в виде дот файла и уже на фронте использовать любой движок для отрисовки таких фов потому что это дефакто Стандарт Вы даже можете просто взять из парка готовый код для отрисовки графов и иметь за бесплатно точно такие же графы с точно такой же визуализации Ну либо Вы можете достать сырой список вершин и рёбер и самостоятельно их там рисовать на фронтенде как вам вздумается вот мы пошли вторым путём потому что нам необходимо отрисовывать графы Абсолютно идентично для разных движков и вот тут показан какой-то скеч ла хорошо на этом мой доклад постепенно приближается к концу бонусом мы получили что мы можем читать из каких-то сторонних систем достаточно просто при создании сессии подложить нужные джар подложить какие-то учётные данные и вот подобное И всё И мы можем читать из3 допустим эти данные с данными из Ну есть буквально что угодно и в заключении что хотелось бы сказать Liv - это такой состоявшийся проект То есть он уже находится на стадии что он готов и его практически не поддерживают порек не принимают и ию практически не читают но вот если вам нужно что-то жутко универсальное то Вы конечно можете его брать Он работает в целом хорошо также вам стоит обратить внимание навер если увас будете запускать запросы по gbc можете рассмотреть им потому что у него красивый интерфейс и он вам подойдёт Если вы используете спар поверх ку Бернеса он там имеет какие-то свои оптимизации и в целом выглядит классно Ну а также есть Spark Connect о котором я не сказал ранее потому что он появился относительно недавно 34 позволяет запускать какой-то пользовательский код из питонов ской либо jav среды Ну а у нас Back написан на c+ Ну и поэтому в том числе он нам не подошёл наш проект доступен на гитхабе если какие-то технические детали были неясны то можете перейти почитать код И вдохновиться спасибо за внимание Спасибо организаторам что позволили выступить Спасибо Лёша Спасибо за доклад аплодисменты обязательно голосуем за доклад задаём вопросы в чате а лучше лично за лучшие вопросы будет вручено четыре приза три Вот таких замечательных эти Завра Вот и приз А онтика - это супрематическая матрёшка и книжка Итак поехали первый ряд Алексей привет Спасибо за доклад Ткаченко Яндекс два вопросика а первое а вот не смотрели Можно ли сборку выполнение джар оторвать от сессий и чтобы на нескольких пользователях в одном жарке выполнялось это пер О каком именно жарке идёт речь Ну вот то что когда мы запрос отправляем там на первый запрос нужно жарк Ну приложение поднять чтобы оно а оно поднимается на стороне ли сервера то есть там джаки на самом деле не Ну вот от никуда не идут и там в этом плане эффективно Угу Ну всё равно получается Если если будут разные пользователи то первый запрос каждому нужно ждать да ну потому что мы не можем делить сессию между пользователями потому что он может в память сохранить свой пароль и вопрос Том Можно ли как-то сессионные данные оторвать и подгружать их в одно в одно только исполняемое приложение Ну вот Liv предоставляет интерфейс вот как будто вы запустили консоль и что-то в ней делаете то есть там нет какого-то механизма что ну то есть он буквально не понимает что вот мы из двух разных мест подключились к этой сессии и попытались там что-то поделать он просто такой Окей согласен там ещё с конкуренцией будет проблема а второй вопрос Можно ли также на го что-нибудь подложить на го да Ну вот о том что я сказал в конце то есть вот они его сейчас активно развивают если у ва СРК выше там Т иче то в целом кажется там есть Гош най клиент То есть вы можете э эн писать Вот с использовани него и возможно у вас получится а в целом Ну я не знаю Спарк - это двм най язык всё-таки всё там ну ладно это в курах продолжите Спасибо дальше в центр а потом вот девушки вот отнеси девушки Лоло раз два о появилось Спасибо за доклад у меня возник такой технический вопрос Там была речь про то что вернись пожалуйста мы извлекаем Да мы их Инком в BS 64 стягиваем их вот в этот момент просадки производительность если мы стя какой-то большой срез данных То есть как я понимаю мы сначала на этапе где-то сервера сформируем один Боль то есть мы соберём агрегат потом превратим его в b64 потом мы его СТМ только потом как бы декору там есть какие-то оптимизации посередине там вроде b64 Можно даже там блочно как-то там поточно шифровать ну в нашем случае не было замечено каких-то типа просадок потому что типично когда пользователь пишет запрос он в ответ ожидает Ну там десяток сотню строк и перенести их с сервера на н ну то есть чтобы показать пользователю это в целом не тяжело Да можно использовать какие-то дополнительные техники сжатия это будет получше Ну да А ещё можно как вариант вот в этом коде который мы исполняем на самом деле сохранять получившуюся таблицу в какой-то в hdfs А на фронте опять её подгружать в память вот Ну это тоже как вариант чтобы не вот не мучиться с этим кодированием декодирования Ну можно попробовать но я сомневаюсь что вот такая запись и чтение будет эффективно чем вот так Окей Спасибо девушка да привет Спасибо за доклад в первую очередь а у меня вопрос такой скорее наверное пользовательский про местор ты сказал что местор живёт только на протяжении сессии Но кажется что аналитики чаще всего решают свои задачи не один день несколько и возможно им нужно хранить какие-то своевременные таблички Ну хотя бы там на протяжении спринта недели там не знаю как сколько-то Ну вы сознательно отказались от этого или вы планируете всё-таки сделать какой-то может быть внешний местр чтобы можно было пользоваться и в следующей сессии тоже своими таблицами если мы говорим про таблицы то таблицы сохраняются навсегда то есть там было показано что мы только если говорим о вьюшка то есть таких временных представлениях данных Вот только такое мы пока что не умеем сохранять навсегда а именно если мы говорим про сами данные то они конечно читаются и пишутся Ну вот тут как раз про временное было потому что вряд ли это нужно всё время хранить Но вот человек сделал одну табличку следующую и потом хочет посчитать уже финальное какие-то облигационные данные а завтра к ним обратиться ещё раз но с другим запросом Это скорее временный характер Ну вы можете их сохранить навсегда потом удалить И это будет эффективно Да в центре молодой человек а потом вот Давайте вот с этой стороны Здравствуйте спасибо за доклад я фанат тя И кстати у вас неправильная ссылка на github вы недавно переехали в новый репозиторий вот вопрос на самом деле у меня такой что вы взяли проект Как я понимаю вы в него добавили два патча то есть один - Это для того чтобы разделять юзерс сессии и второй Вот который меня волнует это для отображения более правильного этапа выполнения Вот и вот он затрагивает внутреннюю оху спарка как бы сейчас насколько я знаю вы собираетесь Ну сейчас пока вы работаете со спарм 322 у вас всё хорошо то есть у вас Ну никакие методы в раз-раз никакие методы в спарке не меняются всё у вас хорошо когда вы будете переезжать на 33 34 35 40 и так далее вот вы планируете все эти по тащить за собой Или вы просто надеетесь Что ливи просто это временное решение оно сдохнет и вы потом всё Перепишите по SPAR Connect Ну пока планов переписать нет потому что А ну пока что всё работает и плюсового как бы клиента для него пока что и не предвидится А если э так можно ещё раз вопрос по в этом и был вопрос Насколько я понял давайте дальше потом в курах Обсудите Да вот нало окей Да Большое спасибо очень интересный доклад но у меня вопрос Следующий а Насколько сложно прикрутить Гранты для пользователя чтобы ограничить операции ограничить доступ к таблицам и так далее ну доступ к самим таблицам у нас ограничивается системой vus у нас разделяется доступ То есть когда вы приходите почитатели записать какие-то данные там Гуляет как бы ваш токен уникальный и благодаря этому Можем отслеживать Ну и не позволять вам почитать чужие какие-то подовые данные Спасибо здесь Добрый день Андрей Сбер Вот вы ВС скольз как раз чуть-чуть упомянули это и чуть-чуть в докладе упомянули Расскажите как вы позволяете пользователям давать для доступа в какие-то системы это ваше собственное решение или какое-то внешнее то есть вот именно речь об этом токене да вот пользователь то Ну о произвольных секретах Для чего угодно Какая у вас криптография там скользкое место но Недавно мы перестали передавать там пользовательский токен пользоваться токеном того кто запустил кластер У нас сейчас используется Так что qt он получает вот этот токен из-под которого он будет запускать запрос То есть он получает сам токен подкладывает его в сессию а затем когда Ну Спарк его использует ему конечно же нужен этот токен но на стороне спарка все данные которые касаются токенов они в целом затирают и риска что кто-то там посмотрит или что-то такое выполнив какой-то код такого нет Спасибо И извиняюсь второй вопрос позволяете ли Вы своим пользователям писать какие-то фы как и паковать их в жарки Пока нет Ну вот можно в этом в своей сессии в рамках своей сессии что-то написать можно Ну скорее всего можно упаковать свой джаник и переиспользовать его ну как бы при создании сессии вот можно его взять подложить в эту самую сессию и использовать её функцио нуно а как SQ добиться вот до каких-то Java классов наверное с этим будут проблемы Но спасибо какие-то продвинутые пользователи Да Время вышло надо выбрать три давай начнём с самого крутого вопроса какой больше всего понравился подарим антика призы вот у молодого человека в Зелёной футболке в Зелёной футболке Передайте пожалуйста Да и теперь три замечательных эти Завра выбирай вот последний вопрос про сюда доступы Так кто ещё затем вот позади молодого человека в Зелёной футболке в пятнистой чёрной Ага понятно Так и ещё один а кто задавал самый первый вопрос вот Антон насколько я помню Да и Антону А да туда да Дада правильно и Антону на первом ряду тебе тоже призы подарки А онтика приходи к нам ещё спасибо большое за доклад голосуйте за доклад L"
}