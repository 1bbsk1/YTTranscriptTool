{
  "video_id": "EjgD9cLCYsM",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "приглашаю Андрея чтобы он нам рассказал о том как нырнуть в планировщик го и зачем ему воровать рутины Да спасибо спасибо всех вас здесь рад видеть Сегодня я хочу поговорить про планировщик го и попробовать ответить на вопрос Зачем мне воровать рутины А собственно стоит начать с момента меня не работает переключал Во теперь работает собственно стоит ответить на вопрос первым очередь это кому воровать рути воровать рутины естественно мне Меня зовут как я уже представился Андрей щепилова техлит в компании ядро в направлении леком А мы разрабатываем систему управления базовыми станциями сотовой связи 5G LTE и GSM А собственно для системы управления и для Агента на этой базовой станции непосредственно мы используем язык программирования гон на котором я уже пишу около четырёх больше 4 лет а собственно если переходить собственно к самой мысли этого доклада Что значит воровать давайте рассмотрим Что значит своровать рутину для того чтобы своровать рутину первым образом нам нужно найти место в памяти виртуальной памяти процесса собственно где эта рутина у нас располагается потому что рутина это такой же объект у неё также есть какое-то место в памяти на который указывает как раз это экземпляр указатель этого объекта А если рассмотреть дальше если мы получили вот этот вот доступ к этому объекту Значит мы можем как-то с ним взаимодействовать его как-то модифицировать что-то с ним делать и тогда уже жить немножко попроще и можно попробовать как-то убрать этот объект из Пула объектов которые меджи планировщиком Go а-а и тогда этот планировщик Go больше не будет владеть этим объектом и мы можем самостоятельно делать с ним всё что нам захотим в том числе включать выключать его из планировщика собственно когда я готовил эту презентацию самый частный вопрос который мне задавали это был вопрос А зачем зачем ты это всё делаешь А ну на самом деле Просто мне пришла такая идея и потому что это красиво а вот дальше хо хочется посмотреть она конечно Красивая и интересная и мы полаем по всяким кишо рассмотрим вообще планировщик и различный го но есть ли в этом смысл да есть ли практическое применение вообще и что нам нужно сделать Какие Дебри залез чтобы это произвести собственно в дальнейшем хочется начать рассказывать про планировщик про то вообще что это такое Я полагаю что все приву зна что такое планировщик Но для того чтобы выстроить это рассказ Я просто расскажу что у нас есть процессы потоки планировщик находит какие-то конкретные потоки и распределяет их для выполнения на физических ядрах цпу а потоки они достаточно легковесные но всё-таки они занимают Некоторое количество памяти Ну и достаточно немалое Да и самое сложное - это переключение контекста так называемый Конте свинг между потоками вот этими и вот здесь вот про эти потоки это говорить Это как Кел треды треды Да потоки потоки операционной системы для того чтобы ну в дальнейшем было понятно о чём я вообще говорю А собственно если рассмотреть Да на картинке вот у нас есть какие-то треды есть какой-то процесс виртуально физическое ядро и на него как бы планируются эти треды и исполняется и собственно поэтому наша программа вообще и работает Ну естественно процес этих может быть много и треды как-то они распределяются между ними возвращаясь вообще к теме того что мы здесь программируем на го вроде как в го есть одна из самых таких интересных фич это рутины что это такое Наверняка вы сечас знаете Это просто уровень абстракции над потоками операционной системы и если суммировать они более легковесные причём не только как бы по памяти но из-за того что они работают на Ну более приближенно к юзер спейс в рамках ран тайма переключение между одной рутиной и другой рутиной происходит гораздо быстрее чем переключение между треда между керда операционной системы и собственно исходя из того что у нас есть ещё планировщик у нас получается есть планировщик операционной системы которая управляет кедами И также у нас есть планировщик который управляет рутина А если рассмотреть на картиночки вот у нас есть треды вот у нас есть рутины и горутины примерно таким же образом планируется на исполнение треды А там уже дальше треды планируются на исполнение физических ядр цпу А И вот получается Вот такая вот у нас цепочка планирования выстраивается собственно ещё планировщиков у нас возникает планировщик Go и в целом вот можно достаточно быстро сказать в принципе какие есть типы планировщиков это первой Это тип планировщиков вытесняющие это когда планирование оно происходит Ну то есть планировщик сам решает когда ему переключить тред или гурдин или всё что угодно какую-то единицу и начать выполнять другую и собственно есть кооперативное планирование когда вот эти вот единицы в том числе потоки или там рутины они сами в нужные моменты пере выполнения другим потоком говорят что ага ну я освободилась можно меня как бы переключать у меня больше пока полезной работы нет собственно А если рассмотрим о том что мы говорим про го в до 114 был Кооперативный планировщик причём работающий достаточно хорошо и немного непредсказуемо о чём мы немного поговорим дальше А теперь он кооперативно вытесняющие что это значит тоже рассмотрим но там просто добавляется дополнительный поток который может следить и вытеснить рутину если она занимает долгое время на выполнение собственно давайте рассмотрим вообще весь процесс всю Вот эту вот планирование рутин и собственно нужно начать то что существует три сущности эти сущности - это gmp И вот вот синем обозначаем G это собственно рутина у неё есть собственный стек у неё есть собственное состояние и Ну то есть стек вызовов очевидно потому что это какая-то функция там что-то ещё вызывается и у неё есть состояние она может быть как сейчас она работает сейчас она Мертвая она может быть там запущена она ждёт своей очереди и вот собственно в структуре вот этой G это просто структура объявленная в ран тайме не экспортируемая в которой как бы описаны много-много полей которая её репрезентирует и собственно планировщик он работает с этой сущностью и с другими сущностями ммп с этими структурами для того чтобы как-то их планировать связывать И вообще делать полезную работу собственно дальнейшей сущностью это п так называемый виртуальный процессор А у него есть просто локальная очередь рутин на выполнение у неё есть какая-то текущая выполняемая рутина допустим и локальная очередь на которые ждут что не будут выполнены Аа собственно просто это виртуальный процессор и какая-то очередь и дальнейшее уже начинается когда включается kernel trad который А в рамках э Go он обозначается планировщика Go обозначается как М машина Да машина для выполнения А и собственно этой машино для выполнения является ЛТД И когда у нас свя происходит связка У нас есть УП какое-то G на выполнение и принадлежит в данный момент то тогда происходит выполнение рутины она исполняется на каком-то треде Собственно как и я сказал до этого трев может быть несколько они связаны с физическими ядрами цпу и выполняются собственно непосредственно на них здесь хочется добавить небольшое уточнение что переменно окружение кото наверняка все знали это называется Run Go Ma Вот и вот это вот переменное окружение она она контролирует именно количество P а не количество общее машин или вот м которые могут быть Ну в исполнении Да это значит что это происходит Как как такой лимитинг для выполнения рутин то есть количество рутин которые одновременно исполняются оно не может быть больше чем Потому потому что оно ограничено количеством п Однако общее количество керл трев которыми владеет программа ногой ранта Наго оно как бы может быть чуть-чуть больше да и ну по умолчанию там в ран тайме проставляется на 10.000 но такого числа никогда не достигает А что значит что она может быть больше в каком м ещё варианте это если у нас одна из потоков вот этих машин керл трев был прерван и тогда ранта просто пойдёт и заведёт новый и для того чтобы выполнять вот эти вот п связывать между этими потоками и выполнять свои рутины А про несколько говорили так и изначально я сказал что там вот эти вот три основные сущности но есть дополнительная тоже не такая основная сущность которая работает в рамках уже вне То есть если у нас есть несколько вот этих машин у них у каждого есть п но у нас есть такая связующая глобальная сущность которая называется Скет а которая представляет собой ну глобальную очередь и очевидно здесь возникает проблема что так как у нас п и рутины в в рамках одного п они выполняются на одном потоки то там не нужно брать никакие не делать никакую синхронизацию не брать никакие мьютекс А томики И всё остальное Однако если мы работаем с вот этой глобальной очереди для того чтобы работать с ней и брать оттуда а рутины для выполнения а-а она собственно берутся мьютексы Локи и всё остальное А и для чего она в целом нужно Ну вот как бы для того чтобы если у нас в локальной очереди P не помещается что-то мы кладём это просто в глобальную очередь и когда-то оно будет ну добавлено на исполнение и выполнится собственно давайте рассмотрим уже поближе к коду и рассмотрим именно Как появляются рутины Да все мы знаем что в коде мы пишем допустим Main функцию и и в ней пишем это немного синтаксический сахар и делаем какую-то полезную работу в дам нашем случае неважно какую полезную работу можем просто вообще ничего не делать Просто fint вот и что что это произойдёт вообще когда компилятор очевидно увидит эту штуку и преобразует её в некий вызов функции но для начала хочется сказать про что это такое Это что запускается отдельный поток или это что-то иное собственно Main в Go - это тоже рутина и эта рутина Она работает тоже точно так же как все остальные рутины и проходит через планировщик просто при старте при инициализации ран тайма и программы Наго стартует Ну очистной планировщик и в него добавляется Ну первый естественно ме рутина которая также пройдёт через цикл планирования нам это Т который машина да которая начала исполнять рутина она потом будет ну переиспользовать на ней могут запускаться необязательно э рутина только а любая другая она просто вносится в в те машины которые используются и на неё будет планироваться рутины если немного вернуться собственно оператор проведёт собственно внутри а будет выполняться функция newp а которая вот для начала вот хочется обратить особое внимание что А вот видите GP который вызывает какой-то Get G собственно Pointer берёт и возвращает какую-то текущую G вот это вот собственно функция которая возвращает текущую G что достаточно Похоже на то что чем нам нужно делать когда мы хотели сказать что нужно своровать рутину Поэтому просто вот хочется обратить на ваше внимание и поехать дальше собственно там много очень много кода и для того чтобы впихнуть это всё безобразие на слайды пришлось немного подавать но так или иначе у нас при создании рутины там добавляется на System Stack новая собственно G которая получается у нас из функции New 1 интересное название Вот но Как назвали так и назвали И после этого как я и сказал с главной рутины наша Вот эта текущая рутина которая мы там получили из вот этой вот функции 1 она добавляется в локальную очередь и ну как бы добавляется в очередь и дальше она будет выполнена на исполнение или нет собственно давайте рассмотрим подроб собственно в ней пытается создаться новая G если тут рассмотрим вот у нас New 1 опять же Ну вот у нас получается этот в начале всё время для того чтобы получить ссылку на G и так как вот я сказал что у нас происходит это планирование планирование мо может затрагивать несколько процессов несколько потоков и всего остального здесь некоторые нало на на машину да то чтобы наш этот поток не могли дини к другому какому П И как раз вот это вот вытесняющее планирование не произошло Поэтому вот ту это как раз и вытесняющее планирование происходит поэтому мы как бы резервирует и не делаем прот юто случайную G и если это G А как бы нулевая тогда мы выделяем память А собственно как рассказывал до меня вот спикер то что выделение памяти это иногда долго дорого Да и мы не хотим этим заниматься чаще чем хотим поэтому здесь просто переиспользовать внутри одного п и в целом внутри планировщика для того чтобы лишний раз не выделять отдельные вот эти структуры рутин которые занимают Ну там достаточное количество по полей и они занимают достаточное количество памяти поэтому мы пытаемся просто получить какую-нибудь уже выделенную рутину которая у нас уже умерла и попробовать её переи Ализи просто по перезаписывать поляна какие-то новые пооно Вить там А статусы её добавить другую функцию но так или иначе не выделять новую память под эту рутину ну е ЕС этого как бы не произошло у нас первая рутина тогда мы просто берём и добавляем в глобальный эту рутину И как я уже сказал вот здесь вот берём Start PC это передаём какую-то функцию которая будет у нас собственно в рутине выполняться и сделаем что это рутина unr и у неё статус такой и мы можем с ней спокойно взаимодействовать И как я уже говорил Так мы взяли мы возвращаем этот ло Чтобы другие как бы работать конкурентно вот мы получаем получается это вот какую-то g g Да И вот в принципе хочется рассмотреть Где мы сейчас вот в нашем палай планировщика Да вот у нас есть какой-то у нас есть какая-то го функция у нас го функции создаётся Вот это G которая получается откуда-то мы переписываем добавить в локальную очередь собственно но для начала вот хочется рассмотреть что чит Вот это GF Что такое GF и вообще в принципе че происходит вот если посмотреть Да вот у нас объявление GF и здесь собственно будет пытаться периодически пока у нас не получится взять какую-то GF свободных мест А собственно если у нас в P нету каких-то вот свободных этих уже неиспользуемых G мы пойдём и посмотрим в глобальных неиспользуемых G и здесь как я упомянул ранее вот у нас это вот Скет структура Да и к не к обращени мы используем вот Локи для того чтобы взаимодействовать с этой заша най между несколькими потоками рутиной Фу не Грузино структурой Да и как раз вот то что я говорил да и мы просто берём и скопом для того чтобы не делать это каждый раз мы просто если один раз уже посмотрели в глобальную Вот эту вот структуру мы берём какое-то количество здесь 31 GF просто перемещаем в себе в своё владение для того чтобы ну дальнейшем и ими использовать их пользоваться ну и здесь вот просто дальше уже просто такой код что мы просто берём из очереди выглядит конечно немножко страшно Но в целом понятно и как бы у нас просто происходит и если у нас не получилось Мы возвращаемся в и в конечном итоге у нас в п появится какая-то свободная рутина и мы попробуем её Ну просто возьмём её из очереди так собственно если вот посмотреть на том где мы находимся то что у на есть вот это есть локаль жето чере G и там ещё есть глобальные эти fre G которые там трется и мы пытаемся всё время забаланс для того чтобы ну как-то э они не застаивалась нашу полученную рутину для того чтобы она могла быть выполнена давайте рассмотрим не будем здесь слишком долго за останавливаться только вот хочется проговорить Вот про первые тут строчки про то что у нас есть какой-то фастран да И мы берём случайно то есть для того чтобы быть Немного не предсказуемыми в том числе Когда у нас был Кооперативный А теперь кооперативно выс планировщик можем пойти ну то есть некоторое количество раз мы если нам повезёт наша груна поместится в в начало очереди и будет исполняться Но если не повезёт то поместится в конец из из-за этого как бы ну есть некоторая непредсказуемость переключения наших грудин то что грудины они ну не всегда добавляются они всегда выполняются меняются в одних и тех же местах и поэтому даже когда у нас был вытесняющие точнее Кооперативный чисто планировщик у нас как бы работало всё красиво и не было никакой предсказуемости нашей конкурентной модели собственно если рассмотреть немного дальше в целом просто мы берём и в используя указатель нап добавляем в там в поле которое является собственно какой-то очереди мы добавляем через вот наш указатель на G который мы только что передали Просто если в начало добавляем либо его как бы в конец добавляем собственно вот особенность Да вот я говорил про глобальные G про глобальную очередь и А что делать если у нас не добавилось если у нас не получилось добавить и у нас как бы очередь заполнилась на P мы просто пойдём в глобальную очередь и добавим туда естественно наши G чтобы она когда-то было исполнено а ну и для этого естественно это медленнее потому что это требует локов и всего остального а потом ещё и медленнее в исполнении Поэтому стараемся приоритизировать локальную очередь п собственно перейдём к мякотка G добавляем его в очередь А что же дальше Дальше У нас есть отдельный тред который стартует вместе с ран тайм в котором происходит планирование в нем есть функция schedule которая пытается найти рутину на исполнение и собственно непосредственно вызвать её функцию для того чтобы она была выполнена Давайте собственно её рассмотрим А как я уже упоминал здесь опять же у нас используется G причём для G из из конкретного G можно достать указатель на M на P на всё остальное Очень полезная вещь и дальше вот опять же интересная непредсказуемость в том что каждый 61 Запрос к функции планирования Мы попытаемся быть честными и будем смотреть в глобальную очередь и чтобы из неё брать на то чтобы у нас не постоянно вычитывать Только локальные п и оно также и глобальная очередь G она тоже пусте и из неё тоже читались какие-то G и исполнялись они не вечно там сидели собственно достигается вот просто случайным если Если повезёт то повезёт и опять же тут вот берётся к берётся Unlock всё как обычно если у нас не получилось её засто найти из глобального Да мы просто пытаемся убрать из локальной собственно бывает И в том числе мы не нашли ничего в локальной очереди потому что она тоже пустая Что же нам делать тогда нету ни в глобальной ни в локальной и собственно происходит следующий вот интересный метод это find Run который блокируется до того как он найдёт какую-то G для исполнения и собственно после этого всего мы когда-то как-то нашли в принципе этот рутину и затем мы можем её просто выполнить то есть выполнить её функцию для этого мы просто вызываем метод exec собственно если рассмотреть в принципе что у нас у нас находится у нас вот есть Main Go функции G P локальная P глобальная и в принципе есть какое-то количество других P со своими очередями которые принадлежат другим м также у нас есть какой-то вот процесс который за этим всем следит и пытается вытеснить или не вытеснит и в принципе балансировать наши рутины собственно давайте рассмотрим Run в котором нужно найти G для выполнения И для этого он делает э достаточно простые вещи если рассмотреть То есть он просто опять попытается посмотреть в локальном хорошо Но если в локальной ничего нету А ты тогда мы пойдём и посмотрим в глобальный Ну хорошо если у нас и там и там ничего нету А что делать нам дальше собственно тогда мы попробуем начинать воровать и собственно Откуда мне вообще придумал пришло в голову воровать рутины это из-за того что в планировщик сам Go он ворует рутины из других п а и собственно он ничего такого особого не делает он просто идёт смотрит в другие очереди других п и пытается оттуда взять что какую-нибудь рутину На исполнение вот через этот метод через эту функцию Run Steel А вот и всё собственно если рассмотреть полностью вообще как у нас выглядит кл рути ничего происходит И как у нас планировщик работает опять же есть Main есть функции есть G P глобальные локальные очереди А есть естественно Симон который делает вытесняющие планировщик и при связи вот этого всего если у нас выполняет находится рутина мы собственно её планируем и выполняем и у этой рутины вызывается какой-то метод и наша полезная работа происходит на каком-то А из потоков собственно мы достаточно сильно углубились в планировщик посмотрели на его код хоть Я попытался Там половину выкинуть оттудова А собственно Ну может быть уже некоторые забыли зачем мы собрались собственно собрались мы для того чтобы своровать рутину я буквально напомню Что значит своровать рутину это получить адрес и убрать её из планирования планировщика вот это вот Наша задача Собственно как это можно сделать а напомню что я уже привлекал Ваше внимание что есть Великолепные функция GG которая возвращает нам текущую G если бы мы выполнялись какой-то рутине могли получить адрес на неё же и что-то с ней сделать но одна незадача этот GG он выполнен в ранта Go причём как бы там нету имплементации Там просто объявление что же там происходит собственно там происходит именно то что э выполнение этого ну то есть имплементация этой функции она скрыта в ассемблере собственно это assembler Go здесь ничего особого сложного не написано а просто написано что у нас есть две функции есть GG и GM GM мы просто так для проформы добавили а рассмотреть если GG э и что мы в этим в этой функции делаем мы просто берём И на самом деле для каждой как бы архитектуры для конкретного процесса при установке там пакета или забже Наго Go Run Там просто генерируется ещё дополнительные ассемблерные файли в котором написано что Ну тут этого G будет лежать там на двадцать четвёртом месте от СТК поинте указатель на эту структуру А в этом а на будет там на сорок восьмом и поэтому можем просто это указать и туда сходить откуда вообще я узнал вот эти все места Это просто я посмотрел опять же этот Файлик но так как у нас Мы выполняем не в ранта у нас ассемблер не может подключить этот Файлик и посмотреть в него но мы можем просто знать свою как бы архитектуру процессора посмотреть как где они там ли будет лежать и собственно Добавить его здесь в виде Файв собственно А как вызывать этот ассемблерные вставки что вообще это происходит и как это работает в итоге А ну это достаточно тоже просто как и так мы смотрели в ран тайме и там не было имплементации Если у нас нету имплементации а компилятор сам попробует посмотреть есть ли там какие-нибудь ассемблерные дефиниции похожие на то как называется функцию которую хотите выполнить и если они есть то она подставит в процессе компиляции и собственно так и произойдёт Однако очевидно что вот в этом ассемблере мы возвращаем какой-то UN Pointer который Ну не то чтобы нам поможет Да просто какая-то область памяти что с ней делать И для этого определяем вот специальные такие пункции обёртки небольшие которые будут конвертировать Кать из вот этого Потера в какую-то конкретную структуру G Ну как нам быть да вот у нас есть я сказал что в ран тайме она не экспортируем мы хотим с ней работать в нашем пакете Но это вообще не вопрос у нас в поэтому можем спокойно взять и переопределить эту рутину назвать её после большой букво и все нужные поля которые нам нужны тоже назвать большой буквы так как оно будет одинаковое Да оно спокойно туда зайдёт и мы можем с ней работать при таком тайп кастинге абсолютно спокойно и вызывать любые поля и работать иметь доступ ко всему собственно вот мы получили этот так этими методами get get получили наши уза на наши структур в памяти а теперь второй шаг который был это нужно её убрать из планирования планировщика что же нужно сделать для этого есть специальная метод том же самом ран тайме Go который используется и в планировщике и во всём остальном и используется он при там когда мы ждём какой-то И когда происходит Collection паркуются все рутины для того чтобы она работала когда там мы получаем отправляем что-то в канал и ждём в этот момент собственно планировщиком этом не сделает Он берёт и получается самостоятельно вытесняет вот эти вот э точнее они сами себя вытесняют э м использова этот Go Park но опять же есть а одна проблема в том что это R Go Park она не экспортируемая Да и как нам нарушить вот эту вот инкапсуляции пакетов А до этого мы просто взяли и изобрели свою же функцию на assem тут получится или нет И что нам делать в целом вообще можем вот использовать директиву компилятора которая во время компиляции подмени нам вот эту функцию с идентичным описанием просто в другом пакете на ту функцию которая лежит в R Go и таким образом мы можем типа нарушить капитуляцию и вызывать её спокойно у себя в своих пакетах Ни о ЧМ не Дума и Роме того мы когда хотим естественно е куда-нибудь вернуть потому что ну что нам с ней делать особо непонятно Вот И для этого у нас есть тоже такая же функция которая называется которая тоже объявлена в ран тайме которая тоже используется планировщиком которая просто возвращает рутину на исполнение Ну и всё Мы как бы вроде нашли ту и ту часть можем это ВС соединять в единое для этого мы начинаем упаковывать наш пакет да в котором мы объявим вот эту вот структуру Да которая как Грабитель в котором мы укажем вот какой-то в целом и вот poin на G чтобы с ней работать затем мы объявим собственно функции это просто получить и залить Ну собственно своровать рутину где мы будем Ну просто опять же вызывать уже обсужден вызывать уже обсужден Go Park или Go Ready собственно просто обёртывание это в какой-то вот класс и затем напишем небольшой Стик как это вообще будет работать как это всё будет выглядеть если мы захотим этим пользоваться А собственно у нас есть вот этот pf у него есть New А да и просто создаём для использования затем у нас есть вот Go функция А и В этой го функции мы можем просто с помощью нашего вот этого структур своровать текущую рутину а И в этот момент как бы рутина не будет выполняться Да и планировщик не будет знать и она просто будет где-то лежать в лимбо Пока мы сами не вернём с помощью Вот и если посмотреть на вывод этого теста то вот до возвращения Мы видим что у нас просто есть рути это собственно для профайлинга и одна из этих рутин это собственно которая остановилась на стиле И вот она просто существует где-то там и Сколько бы мы Раундов планировщика не вызвали Она никогда не вернётся да А после того как мы вернули её вызываем принудительный раунд планировщика и тогда собственно эта рутина пропадает нам пишется там имы собственно довольству этим - Ну что же мы получается своровали рутину И хочется вообще-то резюмировать что мы вообще узнали что мы вообще поделаем А собственно мы вообще в принципе обсудили рутина да А в принципе обсудили как у нас работает планировщик го в его перипетии про то что у нас там есть рутины Да есть э машины процессы А всё это вместе с собой связано и работает а также мы что обсудили для того чтобы при реализации вот этой ассамблей вставки что ссылка на G она такая Константа определена для а каждой архитектуры своя и она как бы может быть оттуда до стата через если мы через assembler как бы э просто вызовем её Аа в принципе мы придумали как бы такие два способа А для того чтобы вызвать функцию либо её переписать если она там Наре да Либо мы используем Link name если Онам подходит для то чтобы подменить и нарушить цию директивы компилятора вот и в принципе узнали что у нас вот фейко структуры которую мы там переопределить всё работать потому что у нас тут и нас пин и Следующий вопрос собственно зачем зачем стоило вобще того и не задава вопро в эту рутину но стоит ли это делать да Для чего это может использоваться А лучше вообще не надо Да потому что мы нарушили инкапсуляции там какие-то ассемблерные вставки которые чисто для каких-то наших архитектур это всё будет переделывать там в другом го то есть там апдейт до 1223 там оно уже работать не будет я делал на 1.20 потому что там поменяют что-нибудь в этом планировщики но если очень хочется то можно как бы Когда нам может очень захотеть Ну например вот нас не устраивает какая-то вообще работа планировщика Да и мы такие хорошо мы сами сделаем себя планировщик просто будем э брать вот эти вот э рутины которые мы создаём и сами их туда-то добавлять и сами их возвращать сами ими работать сами как-то пытаться планировать а если нам Ну не нужен например кооператив Мы хотим чисто по времени вытеснять а но естественно делать Вот это через какие-то нарушения и капсуляции - это немного странно лучше уж тогда просто переписать ранта использовать э просто го свой какой-то переписанный вот а на этом всё всем спасибо кто послушал Вопросы Спасибо за доклад Мега интересно копнул очень глубоко странную тему Но вопрос такой после того как мы украли рутину И тем самым предотвратили её возможности исполнения где-либо пока не вернём не снесёт ли сборщик мусора от неё какие-нибудь запчасти и потом выполнение станет невозможным не должен У тебя же есть референс на эту рутину в самом вот этой вот структур и но планировщик она там где-то есть в каких-то есть в принципе трекинг всех G которые существует просто я забыл немного указать там когда паркует рутину там есть причина почему-то её за парковался поэтому го коллектор её трогать не будет но она То есть если бы там была написал Какая другая причина том что мы её там вытеснили да то её планировщик как-нибудь сам поменяет этот статус и начнёт работу с ней а так мы написали что у нас нету какой причины у нас дефолтное какое-то значение он трогать не будет он не знает что с этим делать Спасибо большое за вопрос Да я те задать вопро из того кода который ты показывал все горутины которые создаются из Main они попадают в локальную очередь и получается чтобы они выполнились на другом потоки их должны своровать То есть я правильно понимаю что в основном все рутины как раз и ворую больше чем выполняются нет Там же все эти очереди они динамически как бы масштабируется то есть там при вначале а то есть вот э в воровство Да этос у нас постоянно добавляются рутины всё это начинает работать но планировщик он будет Ну типа спланирован так чтобы ну естественно до каких-то Там первые созданные рутины они распределялись на разные процессы Да и для того чтобы таким образом работать ну то есть чтобы была какая-то конкурентность если оно будет всё постоянно добавляться потом роваться Но это просто будет долго Поэтому Там как-то просто инициализируется вначале и потом динамически расширяются эти очереди и в какой-то момент оно достигает такого какого-то Ну баланса Да и начинается вот это всё воровство и безобразие Ну потому что естественно воровать Да и ходить то есть если тебе нужно своровать ты ходишь к п которые принадлежит другому реду Да а ходить к другому реду это естественно Ну него безопасно и лучше этого не делать поэтому пытается как-то распределиться и планироваться в локальных этих очередях рути Спасибо большое вопрос с правой полови зала СБО зала их вопрос наверное первый немножко по теории которая была не совсем связаная с Темой Наверное ты упоминал что поток может воровать рутину у других потоков А что будет если например А ну рутин останется мало И поток потоки начнут воровать у других потоков как бы свободные рутины И тем самым фактически потеряется смысл в рутина есть Возможно тогда в этом какая-то логика Ну сделать ограничение в каких-то небольших там скриптах чтобы это работало быстрее Это первый вопрос Давайте остановимся пока на одном вопросе первый вопрос Да зачем собственно там не потеряется весь смысл го то есть я вот сказал что предыдущему шил вопрос в том что оно будет чуть медленнее но при этом как бы оно же будет выполняться на другом машине Да на другой этой ядре и так как их там там контекст свичинский между потоками и всего вот этого мы не выживем Да если мы хотим какую-то конкурентность оно будет просто мы пытаемся если вот у нас большое количество этих вот рутин их как-то так распределить оптимально для того чтобы вот это вот сник нулю Да если у нас вот их условно три но окей Да вот они будут друг друга переключаться друг другом работать и пытаться работать на других потоках Ну вот если у нас уже больше го там уже начинает работать да то есть считается что выигрыш от того что ты как бы Переключи из того что ты это запустишь конкурент он больше чем ты Переключи контекст так конечно атно бывает да в твоём кейсе рассматриваться Но если ты это уже как быто сделал Ты на добавлял этих рутин то ты как бы Ну понимаешь что ти тебе нужно это оно или нет А так может быть быстрее было бы написать это всё однопоточный вопрос Привет Да спасибо за заклад есть такой вопрос насколько я знаю в планировщике есть не только очерёдность выполнение рутин по очерёдности есть ещё некоторые механики например когда есть две рутины работающие обмениваю информацией через каналы то когда Ну в общем читающая рутина подстраивается под пишущая именно порядок её исполнения и вот такой способ кражи не сломает ли Вот этот тонкий механизм да Да хороший вопрос Там на самом деле на уровне вот этого синхронизации особенно каналов и то как у нас каналы взаимодействуют с рутина Как там что может кто воровать и для того чтоб лишний раз не брать Локи оно немного вот синхрони переключение на уровне каналов я вот сечас подробно тебе это не расскажу но это очень хороший поит Ну думаю там какие-то во время этого переключения берётся какой-нибудь Лок На вот эту вот который там и тогда оно как бы не может взять и как-то там вытеснить или чего-то там произойти там вот э синхронизация она всё-таки произойдёт и вс будет работать ное если что можно потом обсудить ещё в дискуссионной зоне а поднимите пожалуйста ещё руки у кого есть вопрос Давайте подойдём к девушки в первом ряду Спасибо большое за доклад Очень интересно очень нравятся такие темы когда глубоко копают но стало интересно нашло ли в продакшене применение вот всех этих знаний пошли ли сторону как-то переписывать нивк или Ну в продакшене естественно таким я не занимаюсь Да собственно как в принципе нет никаких требования рутина тем че занимается это сделал просто да потому что было интересно я услышал что там что-то внутри руется такое А если бы я вот как бы там нарушу Да вот сворую не могу из другой как бы ранта го своровать но хотя бы из своего сворую было прикольно конечно вообще из другой програ с вот в проше видел несколько проектов которые имплементировать и попробовать Ну в в планировщик Go он типа не супер быстрый оптимальный Да он очень хороший Ну там условно планирование в керл трев планировщики линкса оно там очень хорошо сделано очень нормально работает вот но при этом просто предоставляется вот пишут люди Да вот они модифицируют что-то либо вот там вот ранта парки используют как-то вот через Линней либо просто переписывают ранта форка Гог Да предлагают там Но для Вот немного тестов они вот для того чтобы запустить бенчмарки они вот чем-то подобно занимаются но в продакшене Я таким заниматься точно не стал если что-то нужно типа предложение в в го либо ФРК самого языка Но это тоже такая се если честно занятие которое надо поддерживать а либо вообще перейти на другой язык обожаю такие решения Попробуй предложить это бизнесу А хорошо у нас есть время на последний вопрос пожалуйста расстраивайтесь кто не задал вопрос можно будет уйти в дискуссионную а сейчас давайте последний вопрос Добрый день спасибо за клад такой вопрос У нас есть проблема с тем чтобы это всё дело равномерно распределить по цпу да то есть Возможен ли данный подход Чтобы ещё дальше мануально как-то чекать по м вот чтобы равномерное было размазывать цпу спасибо ну собственно эту так или иначе проблему решает именно уже планировщик операционной системы может не суп решат с такого близкого к подхода можно это решить как-то лучше но и в целом там ну контроля над вот связью этих и пу н естественно никакого нет И мы там собственно ничего поделать и не можем мы просто как-то связываем келт называем их и работаем с этим и дальше какую-то пере там деб там слами с чем-нибудь С обработкой но в целом мы не то чтобы связываем вот эти вот м с цпу да если это м хотим это модифицировать это вот как раз уже на уровне операционной системы надо заниматься отлично Спасибо большое на этом мы заканчиваем сессию вопросов в зале помните можно пройти на дискуссионную зону она находится слева от правого выхода Я вот сейчас показываю Что означает правый выход и где находится лево давайте выберем вопрос который вам больше всего понравился вот наверно больше всего понравился вопрос про синхронизацию на уровне потоков я повторяю потому что это важно говорит микрофон не убегайте пожалуйста мы выдадим вам подарок от нашего спонсора газпромнефти вас Мы тоже Хотим поблагодарить Спасибо большое что пришли Это было очень круто Давайте Поа Спасибо"
}