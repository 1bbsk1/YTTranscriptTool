{
  "video_id": "O5GvVLinMWc",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "друзья Привет Давайте ещё раз знакомиться Да меня зовут Александр и Да я технический директор компании Эрон Глядя на эту тему вы думаете блин это что очередной чувак вышел нам рассказывать про то какой раст крутой да как он обгоняет го и всё это ну и да и нет мы сегодня действительно будем говорить об обоих языках мы будем их немножко сравнивать Но не для того чтобы с вами сейчас тут поругаться вы меня выгнали отсюда Да а для того чтобы понять как в мире в котором эволюционируют информационные технологии и инструменты могут эволюционировать языки и Стоит ли смотреть на другие языки которые похожи на ваш тем не менее Гоше Мы в компании очень любим потому что golang - это ну скажем так основной инструмент который позволяет нам писать высокопроизводительные решения а а с растом как-то не задалось Ну нет коммерции Ребята в России в ра и он остатся у нас на таких задворках когда мы на нём пишем какой-то Open sce Ну или используем каких-то в наших внутренних проектах и вот как-то раз к нам приходит клиент и говорит У меня для вас классная Задачка Мне нужно сделать сервис который будет перекладывать женки из одного места в другое для того чтобы потом делать по ним аналитику мы говорим Окей но когда мы посмотрели на то что у него уже есть у него всё в питоне Ну не то что всё в питоне а прям всё в питоне потому что аналитика данных е различные правила для трансформации сущности внутри фильтрация входящих данных и их перераспределение Конечно же это ВС удобнее делать в Python и мы тут подумали нам оставим гибкость языка и попробуем Python для того чтобы хедли http запросы Или всё-таки придётся переписывать на Go и конечно же мы попробовали сначала Python Причём тут раз да Ну это очень хорошая предыстория конечно же Python вообще не взлетел какие-то скажем так 3500 запросов в секунду на о цпу это мало это прям очень мало И при этом он кушает какое-то огромное количество цпу при хендлинге вот этих постоянных запросов мы посмотрели презентацию компании которая столкнулась примерно с такими же результатами и с такими же проблемами и подумали А может быть всё-таки можно что-то выжать из pyth чтобы оставить е как основной инструмен и продолжили колоться и есть кактус в итоге шерсти весь Интернет мы увидели очень интересный инструмент который называется Gran это сверху Python А внутри на Расте на базе acx Web То есть это там Эктор ная модель Об этом я ещё немножко расскажу и он реально по табличке которая у них в документации показывает какие-то неимоверные результаты Мы подумали Давайте попробуем это же действительно настолько круто и попробовали мы сделали три реализации на чистом на фарах на фреймворке fon GR и чистый ванильный раст на базе что же у нас получилось Давайте посмотрим вообще Какие задачи мы решали всё очень просто мы получаем Валиди его с помощью схемы Ну чтобы нам его дальше прокинуть Ну и дальше соответственно везде у нас должны быть подтверждения нам нельзя потерять ни одного сообщения ни самого сообщения ни чанков которые его обогащают что у нас В итоге получилось для начала какая команда это делала команда r&d ребята очень хорошо знают Python они на этом собаку съели и много лет её едят и очень даже плодотворно видели Go и делали в Go некоторые вещи для себя для того чтобы оптимизировать какие-то процессы и первый Ну практически первый раз видит ust что у нас получилось Мы задушили когда всё это уже написали мы всё это дело раскатали в курне кластере для того чтобы рядом раскатать лно для нагрузки мы использовали СТ кузнечик Ну питани использовать инструмент на питоне нормально задушили каждый из воркеров хендлеров которые хдт запросы для апси Сколько нам нужно будет инфраструктуры чисто математически для того чтобы держать минимум 100.000 запроса в секунду То есть взяли прямо в Яндексе классические машинки у них там ну такие вот по 2 гц машинки и попробовали сделать нагрузочное тестирование как мы ожидали Дан прям довольно-таки сильно взлетел более того он залетел настолько что практически догнал поф по количеству за в секунду но мы не ожидали что у ра получится гораздо круче вот этот вот скриншот это скриншот нагрузочной системы которая это всё делала там обыч питонов ские скрипты которые нагружают вашу систему запросами генерируют различные вот эти дженки прямо рандомно Рандом подем правилам имы видим условиях примерно похожи друг на друга но имейте в виду питон там у него ра под капотом А вот Ра где-то в полтора раза на конкретном Сета начал обгонять го и мы задумались А почему так происходит вроде бы там разница небольшая и начали смотреть Граф Гоше Как вы думаете Вот вот этот прямоугольник который правом от вас углу Что это такое Да это Garbage колектор примерно 10% от всего времени А вот вот эти остальные части - Это сериализация десериализация работа с Джейсоном и превращение её в структуры А вот эти пики Видите вот эти страшные пики как Эверест только острые это лек Да там ничего страшного что они такие высокие это просто глубина стека но тем не менее довольно большое количество решена в ран тайме происходит при работе с структурами Ну то есть при сериализации и дереализации и получается что у нас 10% сборка мусора долгие преобразования рок и Дикое количество рефлекшн что-то не очень Клёво да Вы как и другие слушатели которые нас смотрят нано онлан скажут Да блин ребята просто неправильно библиотеки выбрали Вот вот прямо вот не то Нубы и всё неправильно сделали но друзья напоминают rnd команда которая с гон и с растом работали одинаково они шли в интернет смотрели документацию смотрели Ред мишечки и бенчмарки продуктов которые они выбирали и выбрали типа самые клёвые для Go которые были по документации а для ста они выбрали первые попавшиеся Ну потому что там нет такого разнообразия такого разнообразия там сериализации да Или ещ чего-то Вот и они выбрали также по таким же критериям результат Вы видели один из разработчиков мне сказал Саш ты знаешь такое ощущение что на Расте писать веб-сервисы не намного сложнее чем на го Я говорю правда говор давай разберёмся И вообще Так выглядит Да как будто ра действительно стал для людей дамы переста сложные операционные систе иже можно и он действительно такой же удобный и дышит нам в спину как го разработчиком Давайте разбираться мы с вами сегодня посмотрим на то как разработать веб-приложение классическое веб-приложение на двух языках какие-то классические моменты возьмём посмотрим на библиотеки которые там используются сравним сложность кода и это будет один из важных одно из важных качеств я покажу вам интересную ве кото выйдет естно что мы сделаем мы посмотрим на роутеры которые используются Да как использовать роутеры и там и там как работать с данными с реализацию дереализацию Ну и конечно же что-нибудь положим в базу данных погнали погнали первое берём это http и Уго и Ура огромное количество библиотек и фреймворков которые вам позволяют писать веб-сервисы Ну грубо говоря там API или классические http каких и так далее но мы сегодня выберем вот пря по вым старый наверно скажете да уже почти неподдерживаемый но классический скажем так для него больше всего туториалов и примеров которые вы можете найти в Интернете больше всего для джина и А Ура как практически идентичный аналог и посмотрим как они работают нумто или из запроса кстати вопрос Вот видите параметр си А какого типа он будет Нет он будет строчкой А что делать если я захочу числовое значение конвертировать вручную отлично посмотрим на ра как это в ра работает тоже самое роутер созда вот также лить можно функци чки Ну просто пример который я нашёл он был классический вот берём тоже функции и смотрим как у них тоже можно работать у них Также можно работать и с параметрами пути и с параметрами запроса но смотрите интересную вещь в параметрах функции Мы видим что уже готовые типизированные мы уже видим готовые типизированные параметры это кри там или часть пути и например что в что часть пути мы сразу с помощью дженериков можем говорить Мы ждём строковые данные или Мы ждём числовые данные и если вдруг у вас придёт вместо строчки число и оно не сможет в число сконвертируйте То есть Вам фреймворк не даст этого сделать Как это работает Как можно подставить в аргументы функции параметры функции Извините уже какие-то значения откуда фреймворк об этом узнает есть очень интересная штука в большинстве фреймворков на Расте это экстракторы так как раст строго типизированный язык вот вот это вот всё да с очень хорошей системой типов Я уже начал рекламировать видите то там соответственно есть возможность автоматического приведения типов и различных манипуляций с данными и вот экстракторы - это та штука которую можно использовать при хендлинге ваших функций то есть функций хендлинга и сразу говорить Что ага я ожидаю вот такие-то такие-то данные это обычный код ничего страшного в этом нет а в данном примере то есть мы например работаем с пагинацией чтобы сразу получить из э в данном случае пути и к Вере то есть и сквере то что после вопросительного знака идёт Да а получить сразу параметр пагинации и уже иметь жёсткую точную структуру с этими данными без кастинга типов без приведения типов вручную как мы любим или не любим вообще экстрактор вроде как удобно Да очень классная штука А как они работают И вообще просто ли написать свой экстрактор Вы можете даже не разбираться что тут написано Я кстати не видел как это написано нормально с первы Ридо видно может даже не разбираться под капотом когда вы загляне в простейший экстрактор вы увидите Дай бо простую но в большинстве какойто СЖ конст который состоит из трейдов из типов которые приведены к этим трейдом каких-то дополнений и так далее и так далее Если вы будете разбирать каждый фреймворк который написан на Расте то пользоваться вот это видите маленькую строчку очень удобно фишечка няшечка хоп и у вас всё готово но когда вы начинаете смотреть Под капот вы видите там сложные конструкты и Давайте сравним с go где есть сплошная читабельность кода Ну то есть если вы откроете любую часть кода на го у вас она будет по сложности Ну примерно одинакова что в хендлинге что в фреймворке который разработали в орсе и вы им пользуетесь в Расте немножко по-другому в ра вам придётся включать мозги на максимум И смотреть как же это работает внутри но вернёмся к респонс к ответам то есть запрос мы уже просмотрели Давайте посмотрим как работают длям реализация все знают да это приведение потока каких-то данных обычно текстовых Да к нашим структурам с которыми мы уже умеем и любим работать так вот в Гоше всё очень просто наглядно и все этим пользуются всегда Да у нас есть теги мы можем а назвать имя Поля с которым мы работаем в сериализации десериализации Если вдруг нам какое-то поле выводить не нужно если Оно пустое то мы можем прописать амти Ну и там куча куча всяких вот этих вещей которые Мы так любим делать когда работаем со структурами вебе что же у нас в Расте примерно тоже самое только тегов нет Те же структуры но в Расте нет маршалинг и работы с такими вещами из коробки там приходится подключать библиотеки которые с этим работают и вот одна из библиотек сет я объясню почему она так называется чуть попозже Она позволяет как раз преобразовать потоки данных в структуры и наоборот то есть занима рили мы подключаем подключаем функциональность поведения сериализации дереализации к нашим структурам есть специальный Тед который позволяет это делать Это чтобы вы понимали очень похоже на то как в питоне работают с декоратора Когда хотят какое-то общее поведение подключить или реализовать в структуре но тут тоже самое только называе подго вдм спну Мы тоже можем сделать Это непосредственно над полем над каким-то то есть понять или определить как оно преобразуется там туда или обратно видите мы именно для сериализации условия ставим что пропускать если там ничего нет и он его пропустит так вот библиотека очень интересная она называется серд потому что занимается Как ни странно сериализации и дереализации и это полноценный фреймворк если в у нас ма и вот те пики Флек которые мы видели на графе то есть оно так работает в языке и вы от этого никуда не денетесь то в такого нет там нет работы со структурами в режиме ран тайма весь фреймворк по сериализации реализации построе на дженерика и ре поведения как интерфейсов Go соответственно всё это работает на уровне comp Time то есть на уровне компиляции создаются специальные методы и поведения для каждой структуры вот Вот видите Да для структуры которую мы помечает никакой никакой рефлексии то есть мы напрямую работаем с методами которые уже предком и делают нам то что нужно для Прим так как это фво вы можете реализовать поведение сериализации дереализации вообще для любого любых данных которые у вас есть вообще конечно в ра там есть немножко другие инструменты которые с токен стримами Работают но чисто теоретически для какого-то вашего конфига Вы можете реализовать реализацию дереализацию довольно-таки просто или немного мани явори над полями Вы можете отдельно указывать Какие используются паттерны там для нейминга Да там Camel Case или snack Cas или подобные переименовывать какие-то поля и так далее То есть она очень конфигуратор как flaton когда вам по Гене надо взять и чуть-чуть выше поместить на в д сонке Ну вот то есть тоже такие вещи есть но как я говорил сложно или просто реализовать своё кастомное поведение для того чтобы либо какую-то свою структуру либо какой-то формат документов сериализовать де сериализовать и тут мы сталкиваемся опять с той же проблемой что раст довольно-таки сложен внутри для пользователя Ну вот как Если бы вы были бы продвинутым пользователем компьютера да Для вас простой интерфейс на кнопочки и всё О'кей Но как разработчикам Вам эти кнопочки ещё нужно разрабатывать Да и там уже не всё так просто врасти тоже самое как я говорил нет сплошной читабельно Когда вы погружаетесь внутрь становится сильно сложнее Вот и для того чтобы реализовать свой сериализация языка и его концепций полностью вы никогда не обойдётесь вы будете ошибаться ругаться на компилятор говорить какой Он ужасный и плюнет и не будете никогда на этом ничего разрабатывать Я кстати только с третьего ра раза в ра вошёл очень долго я сопротивлялся а вот мы видели процедурные макросы как я говорил вот то что сериализация десериализация да а что это такое процедурные макросы это довольно-таки удобная штука которая помогает нам реализовать какое-то общее поведение Ну вот например для того чтобы вывести информацию о структуре куда-нибудь в stout есть процедурный Маро deb мы его натравлю и когда пытаемся что-то вывести в sted он нам рисует красивую информацию по этим структуре по это по этим данным и так далее и так далее Как это работает когда мы добавляем процедурный макрос в дебаг А у нас в коде добавляется вот эта вот часть то есть генерируется полноценная функция или какая-то реализация какого-то поведения в данном случае й deb Ну как интерфейс как я гово и вот эта часть она сгенерирована в То есть у вас получается что одна маленькая надпись вам добавляют несколько строк кода с одной стороны это клёво и просто Давайте вот реализуем какой-нибудь свой процедурный Макс опишем нашу структуру что за тип структуры с которой мы работаем в принципе всё очень простоем позволят это делать по сути мы создаём некоторую функцию определяем её как макрос и на вход она получает поток стримов Стрим данных вернее это классический танар который разбива разбирает вашу структуру на СТО дерево и вы уже в этой функции работаете непосредственно с АСТ деревом кода который вы хотите преобразовать или добавить какое-то поведение для него но тут самое интересное в том что кроме всяких преобразований вот этого всего у вас появляется такая вещ как возможность написания кода вот то что было сгенерировано оно вот может быть написано вот так в кавычках Да и соответственно там работает и интерполяция каких-то вещей в общем вы работаете с одной стороны как с шаблонизатор а с другой стороны вся вот эта структура будет валидировать ошибиться не сможете язык вам просто не даст это сделать И таким образом можно создавать довольно-таки сложные поведения Вот и это Рае довольно Круто Вот мы добавили Да поведение добавили их к нашим структурам запустили мед и вот он нам вывел что мы работаем с этими структурами вроде бы просто и легко но опять же если вы не хотите делать какие-то более сложные вещи вот тут на листинге которые Вы точно не видите скорее всего или не понимаете да Эти строчки кода потому их счи поведени каких-то в фреймворке отра то есть процедурные макросы могут быть и очень сложными для того чтобы действительно реализовать сложное поведение и даже если бы вы видели этот код и попробовали его прочитать с первого раза Вы точно не поймёте что там происходит сложно Итак Да процедурные макросы позволяют нам отлично реализовывать какое-то кастомное поведение очень ипо или вообще реализовывать DSL в языке он помогает делать не только манипуляции над структурами но и соответственно реализовывать какие-то вещи в коде для которых ещё нет описания в семантики то есть писать свой DS и им можно сделать большинство задач с которыми вы сталкиваетесь в том числе там реализовать реализацию реализацию работу с базами данных многого сложность которая кроется под макросами вас вынуждает к тому чтобы изучать язык подробнее и смотреть как это работает чтобы потом иметь возможность изменять эти вещи или писать свои и вот тут уже сложность у нас скачком следующей ступенькой поднимается гораздо выше Чего Слава богу нет в го там мы можем очень плавно усложнять наши элементы тем не менее Кроме того ещ когда мы работаем с процедурами макросами так как это compile Time то усложняется и увеличивается время компиляции да у вас было четыре строчки кода А с помощью одного процедурного макроса ещё плюс 100 замечательно Ну и конечно же дольше будет компилировать Но скажем так это не особо критично Ну что вернёмся к ответам вот у нас уже есть запросы есть сериализация ди сериализация данных А как же в Расте тогда работать с отве посмотрим на для вас скорее всего это понятный код и вы все знаете как с ним работать ВС очень просто ошибори в Чике или ответ да тоже происходит реализация в если мы посмотрим и вот такая вот красивая Женек у нас получается Если мы посмотрим на раз там примерно тоже самое смотрим У Наско суно наме добавляем туда как раз дереализацию так как это только входной параметр то нам нет необходимости добавлять ему поведение сериализации мы не будем эту структуру превращать ВН поэтому мы можем ограничиться только дереализации и это очень удобно и как раз с помощью экстракторов о которых мы говорили да мы получаем уже готовую структуру внутри которая автоматически реализуется можем с ней работать Даше мы передам э структу или какие-то её поля в какие-то другие функции и вот тут очень интересно появляется evate и asn потому что aum - это фреймворк который позволяет писать асинхронный код с помощью классического As который во многих языках есть вот и вот тут как вы видите есть очень интересная штука это там знаки вопроса где-то вот после каждой функции Как это работает я вам покажу чуть-чуть подальше когда мы перейдём к работе с или над ошибками Вот Но тут в данном случае всё очень просто то есть мы делаем какие-то манипуляции и если вдруг что выходим с ошибкой И соответственно со статусом notf Вот и у нас автоматически будет преобразована конс У нас есть Trade в качестве возвращаемого значения и он принимает либо ошибку либо какой-то результат который имеет поведение преобразования в G ну или врен вот автоматически то есть нам достаточно передать структуру Ну или тип данных туда и он автоматически преобразуется или в данном случае сериализм удобно то есть нам не нужно прямо приводить в тексты и отправлять текст оно всё автоматически делается То есть у нас есть структура которую мы хотим получить у неё есть процедурный макрос сериализации То есть она у нас умеет превращаться в какие-то текстовый поток данных и мы её просто отдаём в качестве аргумента в один из эмо который может реализовать Trade в данном случае это не функция это и нам просто в скобках он получает параметр что он оборачивается какой тип внутри внутри он может содержать в итоге идиоматических на Go Как вы видите Да примерно тоже самое то есть для нас как пользователя фреймворка языка всё примерно идентично иче много библиотек которые это поведение реализуют работу с htp и хендлингом запросов и они все примерно работают одинаково кроме acx Web на котором ребята кстати писали сервис у него актор ная модель и там всё всё чуть-чуть по-другому то есть это передача сообщения от одного актора к другому и вот это вот всё Вот Но тем не менее библиотеки все стабильные которые вот были представлены на одном слайде сейчас самая нано популярная библиотека - это которая позволяет реализовать htp хендлинг Ну и если вы её попробуете вы увидите что она реально очень похожа на Гош библиотеки независимо от того Джин это было там или какие-то другие хорошо Из минусов то что мы увидели уже появляется asing то есть вам придётся работать свей и Об этом я тоже Расскажу какие там нюансы есть Ну и как я говорил сложность погружения Когда вы работаете с фреймворков Он позволяет вам очень просто делать но шаг внутрь вы попадаете вот в огромные конструкты которые довольно сложно модифицировать или вообще даже понимать то есть ну честно работа не для джунов Итак прон Почему я про него начал говорить если вдруг в асинхронном коде вы захотите поставить паузу и будете использовать классический слип вы заблокируется полностью весь EV и ваш ан анком не будет для того чтобы работать нормально асинхронным кодом в нужны специальные асинхронные структуры и функции которые позволяют это делать то есть в данном случае обычный слип не заработает он вам тупо всё заблокирует Или например for бесконечной вам тоже всё заблокирует очень интересно вот есть специальный э библиотека для работы с асинхронным кодом и вообще с ран таймов ней ран таймов в Rust для написания асинхронного кода Вот И там есть специальные функции которые позволяют вам делать какие-то ожидания то есть паузы ставить и так далее и так далее не блокируя основной поток но Достаточно одной ошибки неправильного импорта То есть если Вы посмотрите функции написаны одинаково у них просто разные грубо говоря на mspace с которого они идут ну вот и если вы импортирует на mspace и у вас везде будет просто слип А вам будет ну довольно-таки тяжело понять А блокирующий этот слип или не блокирующий этот слип придётся немножко углубляться и перепроверять вот и это не всегда удобно потому что очень похожи семантические функции можно сделать очень простую ошибку которая вам дальники Плохо аукнется что ж перейдём к хранению данных долгосрочному хранению данных в коде база данных Ребят а Поднимите руки кто любит ба ом а кто нет Вот кто любит ом поднимите пожалуйста руки никто не любит а есть да а почему долго медленно а почему долго медленно а потому что пусты интерфейсы потому что рефлекшн внутри Да а дженерики вам же завезли дженерики сейчас скажут блин нам завезли не то что мы хотели я вот это очень часто слышу В общем в Go никто не использует м Ну практически друзья Привет Вы единиц наверное и это ожидаемо действительно это так на протяжении нескольких лет когда Мы работали с Go к нам приходили ребята устраиваться Действительно это какая какой-то флажок того что блин Нет мы не будем использовать РМ потому что там вот это вот это вот это И вообще это не оптимально и долго и куча рефлекшн вра нет такого Помните я говорил о том что практически всё реализуется на уровне трейдов и дженериков вот и вот дженерики в расть они немножко получше видимо Вот и поведение вот такого долгого поведения по работе с динамическими данными такие как там Опя же данных из SQL результатов структуры оно гораздо проще происходит причём эти дженерики они Практически везде и вот Давайте попробуем посмотреть как в Go происходит работа с классическим sqlx Почему мы выбрали sqlx потому что он есть практически на всех языках это библиотека которая есть Практически везде и везде Она работает одинаково мы подключаем соответственно нашу базу данных делаем какой-то туда передам структуру вот ВМ и Бим скажем так параметры этой структуры поля этой структуры на параметры запроса там именованы ли именованы но тем не менее для того чтобы не работать с Интра Поля не знаю кто вообще делает в чем году интерполяцию в SQL и Отлично всё у нас возвращаются данные Либо мы хотим получить какие-то данные которые вставили Дат ВС тоже самое что в том что в этом примере передам Ну и для меня кстати было очень долгим пониманием А почему не передам Почему передам во всех примерах которые вы найдёте в интернете берут функцию туда по ссылке передают конек и говорит Работайте с конем А где л где пул соединений а он и есть оказывается тоже пул соединений просто почему-то он как Конек как тип конек идёт вот не отдельный это скажем немножко вот так вот вернёмся к выборке данных выбираем данные передаём туда ко получаем данные И что самое интересно видите Мы сначала определяем структуру а потом её грубо говоря наполняем и вот там внутри я проваливался в этот гет там вот огромная такая простыня с рефлекшн и куча всего всего всего Вот это тоже Как видите происходит в ран тайме на каждый запрос у вас будет отрабатывать вот сть с пиками фленов каждый раз на каждый запрос без кэширования без всего вот этого вот ну и соответственно возвращаются получаем данные что у нас в в Расте нам также нужно подключить sqx библиотеку кстати очень интересная штучка мы сегодня не будем касаться там всех нюансов работы с пакетами в Но вот одну вещь Я хотел бы вам показать видите ключевое слово это такой тон который вы можете использовать из библиотеки синхронная асинхронная работа работа с посо или с какой-то другой базой tls вы используете либо библиотеки tls которая у вас в системе либо реализацию tls которая вообще не привязаны никак к библиотекам и так далее и так далее и так далее Это интересный фитолин на уровне пакетов Вы можете точно указать какое поведение Вы будете использовать Ну если оно конечно же там заложено менеджер пакетов кстати довольно-таки мощно враз Я рекомендую вам смотреть на то хотя бы какие там есть концепции это очень интересно так вот мы а пока не забыл Единственное что интересно Я заметил у Go буквально недавно реализовали такую вещь как Work Spaces Да на уровне пакетов это такая попытка сделать зонтичные пакеты так же как вра это сделано в одном репозитории в одном грубо говоря в одной директории у вас разбито по модулям тире пакетам какая-то реализаци то есть не на уровне нейм спейн внутри одного пакета а прямо отдельно по нескольким пакетам Вы можете паблике отдельно делать его версионирование и дальше дальше внутри использовать Ну вот дово интересно что оно тоже перекочевала туда потому что врасти оно было изначально так вот подключаемся к базе данных всё тоже самое мы берём Connection но не просто Connection оборачиваем его сразу в пул соединений вот тут л - это отдельная структура Почему отдельная потому что дженерики потому что в этот пул Ну вот конкретно в пул Да мы можем обернуть pog Connection у myq свой пул соединений у редиса свой пул соединений есть отдельная библиотека которая реализует пул соединений практически для любых скажем так библиотек которые работают с соединениями с коннекшн Вот И там вы можете переиспользовать эти коннекшн которые сохранили в пуле Вот довольно-таки интересно И дальше Ну соответственно наш пул соединений в состояние нашего роутера вот к этому мы е тоже вернёмся про контекст как работают в с контекстом в раст контекста нет но там есть очень интересные механизмы в фреймворк которые помогают вам на уровне роутера хранить какие-то состояния в данном случае например пул соединение или что-то похожее и функция которая нам соответственно будет выбирать наши ивенты видите тут тоже экстра потому что это хендлинг классический И мы достаём этот пул соединений мы его не передаём куда-то мы его достаём из стейта текущего и можем переиспользовать вот очень удобно внутри в принципе тоже самое то есть мы получаем данные Но есть одно базовое и главное отличие смотрите мы тут ну как мы тут в Расте используются дженерики сразу на уровне указания результата ответа и вот тут рефлекшн нет так как когда-то до этого мы указали что тип А ledl может работать со структурами данных ну то есть с SQ да Или не дай Бог там РМ какой-то то для него могут быть сгенерировано уже существующие реализация по преобразованию Ну скажем так по преобразованию его из набора строчек из вектора например какого-нибудь да Или МПа в структуру и наоборот то есть мы изначально знаем что нам вернётся конкретный тип данных и указываем это на уровне компиляции то есть во время компиляции никаких рефлекшн никакого ран тайма и сложных таких выборок В итоге тоже идиоматические подходы очень похожи да потому как мы работаем вплоть до строчка в строчку мы можем построить примерно такой же код на раз как и Наго но тем не менее из-за того что есть дженерики из-за того что есть мощные инструмента верхнеуровнево функциональности мы можем гораздо проще работать с кодом меньше писать кода в итоге вот более того ну вра любит ум так как у нас есть там скажем так функциональные макросы то мы можем на уровне compile Time сгенерировать поведение для наших структур И это не будет так долгим Как вы говорите то есть это будет очень быстро и просто тем не менее есть различные сложности Когда мы уже погружаемся внутрь контекст вот в го контекст Наверное это тот инструмент тот подход в языке которого нет больше нигде это его фишечка такая Давайте посмотрим как он работает да вспомним контекст - это интерфейс который реализует несколько методов Да это дедлайны это канал Когда у нас что-то завершается Ну и ошибки соответственно и какое-то значение потому что контекст можем использовать также как й для того чтобы хранить какие-то значения тут же там соединений конек подобные вещи он появился в четырнадцатом году в отдельном пакете соответственно xnet контекст а потом уже в шестнадцатом году перебрался влип и мы с ним работаем теперь как с частью которая неотделима от языка отлично но в Растите такой штуки нет и это действительно та фишечка которая было бы классно если бы она появилась там потому что и работа с cons token и работа с какими-то дедлайна Практически во всех реализациях на Расте это ну какой-то отдельный Костыль который или какая-то отдельная функциональность с помощью отдельной библиотеки попробовали сделать кстати контекст для Токио но э штука которая не взлетела от слова совсем никто не стал использовать вот ну потому что ра разрабатывается по-другому Да там не контекст используется тем не менее всякие реу с помощью там отдельных инструментов у to например есть возможность реализации каналов также как классические каналы в go в ра можно сделать тоже разные каналы причём это mul про sle consum И вот короче варьировать их как угодно вплоть дошт Когда у вас только один раз что-то произойдёт в НМ и он закроется вот довольно-таки интересный инструмент Ну и отдель это удобно когда вы будете работать с какими-то долгими запросами которые нужно отменить этот паттерн он больше наверное у нас архитектурный получается вот и его реализует каждый по-разному ошибки вы все видели ошибки в го вам нравится ну скажите Да нет Да отлично отлично но вот вот это можно увидеть Практически везде в коде Да и скажем так честно друзя мне не очень нравится вот это первое наверно что меня оттолкнула от языка когда я начал с ним работать да сплошная читабельность И одинаковость входит отлично но вотка такие вещи иногда всё-таки напрягают что есть вра для этого и что очень классно если бы появилось в го это модные типы данных два типа Option и Option - это замена а л такая верхнеуровневое грубо говоря да то есть что она делает Если у вас есть а в дженерики в данном случае какое-то значение то он возвращает его Если нет то отдельный нам Нан Но это тип это не пустой не пустое место это не пустой указатель Да это тип с которым можно работать у лта немножко по-другому ЛТ у него примерно такое же поведение только он возвращает ещё и ошибку Если вдруг какая-то у вас внутри произошла как с этим работать Это не просто типы которые вы можете возвращать это типы которые могут взаимодействовать друг с другом и можно реализовать функциональность распространения ошибки не путать с исключениями в данном случае не происходит остановки выполнения в данном случае Например если у вас не открывается файл или он не найден или возникает какая-то либо другая ошибка внутри функциональности открытия файла Вот видите знак вопроса он означает что в этом случае остановить логику выполнения данной функции и если внутри была ошибка вернуть её выше то есть в данном случае это та же проверка не равно бла-бла-бла Тоже самое касается и лта и о Они оба работают примерно одинаково Вот только е Моть Вот это оче удобно код вот Да поведение такое же как мы говорили в го но красивее возвращает ошибки распространение вверх без остановки и это очень классно причём вот эти штуки что л что Option поддерживают комбинаторы это такие штуки Когда у вас нинг вызовов ченг методов и вы можете говорить and НН и строить такие Чейн конструкции похожие на функциональные языки Когда вам не нужно делать кучу переменных потом то есть они создаются потом удаляются Да и так далее и так далее в ченге Вы можете распространять аргументы результат выполнения одной функции как аргумент следующий Да и так далее и так далее То есть Ну это классические функциональные паттерны которые работают в разнице потому что он мульти парадигм язык Итак друзья практически Подходим к концу что мы увидели надеюсь я вам показал что на Расте Можно не только операционные системы и модули ядра писать что на Расте действительно можно писать веб-сервисы причём писать так же просто как и в го но друзья для каких-то частных задач СТ подходит Ну чуть-чуть лучше То есть это вот сериализация данных то что мы увидели Да это когенерация то есть возможность реализовывать поведение Вот мне кажется не хватает немножко макросов Да в языке для того чтобы не писать кучу леплей одинакового Вот и в общем то есть какие-то вещи действительно на расе оказывается делать проще но на вопрос сложнее ра го или нет Я могу точно сказать что ра намного сложнее го и если мы говорим о том что нам нужно прямо сегодня и сейчас запустить команду которая будет писать РС друзья это ни в коем случае не раст это го потому что язык гораздо проще на нём гораздо проще делать какие-то вещи верхнеуровневый низкоуровневые и самая главная Метрика которая для бизнеса важна это Time to maret с Go Скорее всего будет гораздо ниже то есть Вы гораздо быстрее будете доставлять ваши фичи Дада исходя из того что команда вот уровень входа в язык технологии инструмен и гораздо проще более того гораздо проще вы найте ещ людей они посмотрят на тот код который написала предыдущая команда и скажет да тут всё понятно Тут нет сложных моментов Я всё это понимаю и умею с этим работать и так оно произойдёт ну и соответственно в данном случае мы тоже практически всегда выбираем го для того чтобы писать даже сложные инструменты возвращаясь кста с тем кейсом с пинком далее остались на питоне потому что это было удобно друзья мы можем ещё долго дискутировать о том какой язык лучше какой хуже и это лучше наверное сделать в кулуарах У меня вопрос Да кто готов уже перейти и попробовать раз окей Уже два человека три человека клёво Кто больше четыре Отлично Отлично друзья Ну и я хочу чтобы вы как-нибудь и мне тоже ответили на вопрос А стоит ли го меняться этот язык таким какой он есть он и так клёвый Спасибо я жду ваши вопросы успеваем У нас есть время на один вопрос я специально это сделал друзья да один вопрос Выбери сам кто тебе нравится какая ру Вот вот очень общительный молодой человек да мы с ним общались уже практически всю презента Александр привет очень понравился твой доклад Я очень влюбился в раст У меня есть 3 с половино вопрос Ну я Ладно один задам А по поводу блин хотелось бы два по поводу маршелин вот у меня просто идея возникла что мы в горшке также можем просто сделать свой а Маршал на к на строку двух уровне первый второй уже по типам и по сути будет са но плюс д с поно строчки добавится в итоге там будет одна проблема А хотя нет проблем В принципе не будет дженерики же появились в го да я не понимаю кстати почему вы так многие скептически относятся к ним вот мне кажется их стоит использовать стоит к ним присматриваться вот может быть опять же делать пропо залы в язык да Для того чтобы как-то их переделали чтобы это было удобно Это мощный инструмент и когда мне говорят Да дженерики что там с ними делать как кто их использует Да в реальном коде использует как раз ради такого поведения который вот был показано в качестве там монат и всего остального Да и тех же процедурные макросы а сериализация десериализация та же вот а в принципе я думаю что да можно писать инструменты которые занимаются приведением потока данных к структурам более оптимально чем это делает машал Вот но нужно смотреть как это а всякие приведения типов особенно в хендлинге оно будет очень полезно Мне кажется тоже да ну и половинка вопроса не нет нет жаль но нет но у нас есть дискуссионная Зона дискуссионная зона - это отличное место задать 3 с поно вопроса потому что это именно то место где можно будет поговорить и продолжить тему только Не бейте меня там а то пришёл Я попробую с этим что-нибудь сделать но я не уверена поэтому все остальные вопросы которые у вас остались которые вам хочется обсудить можно обсудить В дискуссионной зоне у меня остался только один вопрос очень сложный Я не знаю как О я тоже не знаю как отве Какой тебе вопрос понравился больше всего я думаю мы Антону как раз подарим подарок Да это самый интересный вопрос за сегодня был пре Антон Не уходите пожалуйста Мы хотим Подарить вам прекрасную матрёшку от компании онтика конференция в этом году сделала уникальных матрёшек Вы можете собрать себе полную коллекцию вас Мы тоже Хотим поблагодарить это было супер вы даже уложились в тайминги Спасибо большое извините что во вопро Всё круто"
}