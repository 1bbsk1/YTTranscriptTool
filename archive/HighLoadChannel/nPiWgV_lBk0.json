{
  "video_id": "nPiWgV_lBk0",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "Ну а на сцену я приглашаю следующего докладчика Игорь нитай из компании криптонит он занимается исследованиями надёжности нейронных сетей надёжности и возможностями и расскажет нам сегодня об этом слоб в некоторый момент исследуя что в целом происходит с нестями при длительном обучении Я обнаружил такую вещь что если обучать нейросеть Достаточно долго она начинает сходить с ума Она перестаёт работать и перестаёт работать на самом деле просто математическая модель то есть вычисление происходит но то что происходит перет модели с обратным распространением ошибок градиентами Вот эти слова которые вы наверное много раз слышали А но по тому исследованию я там опубликовал статью Но осталось задача понять А что же происходит с вычислениями и почему мы не можем верить формулам значениям которые По формулам как мы их насчитали вот мы будем говорить о том что происходит с числами с плавающей точкой Ну хорошо известно как они устроены А вот мы видим Как устроены на примере флот 32 есть бит знака есть во битов экспоненты исть это с записанным подразумеваемых битом единицей распределены эти числа неравномерно чем близко к чем ближе к нулю тем плотнее А дальше дальше от нуля а представи флотами числа расположены так довольно далеко друг от друга и а число сплаву точка - Это некоторое конечное множество вообще говоря а при работе с этими числами возникают ошибки хороший пример - это вычитание близких чисел если мы возьмём два довольно близких числа и их вычтем то вот как мы себе представляем как числа расположены такой Гребёнка если мы возьмём два числа довольно близко разница их может быть представимо может нет но а мы получаем число у которого некоторые начальные биты имеют точное значение следующим невозможно придать никакой смысл а также мы знаем а про ошибки округления хороший самый известный пример - это машинный ноль там 1 П 1Е - 52 это снова один ошибки могут подстерегать нас до того как Мы приступили вообще К любым вычислениям А в частности А если мы используем литералы то если мы написали 03 то получаем мы не 03 А что мы получаем мы получаем число с двоичным порядком -2 и вот такой вот мантиссой Но это Примерно вот столько но это не 03 то есть мы ещё не сделали ни единого вычисления ни единое операции мы но мы уже имеем погрешность а но про это а можно почитать подробнее в а документации по питону ссылка А внизу экрана вот а ну и пример из этой документации хорошо известный что 0,1 + 01 + 01 - это Но это не 03 вот а значит ошибки в вычислениях появляются посмотрим что с ними происходит Дальше А на этом жизненный цикл ошибок не заканчивается они дальше распространяются при вычислении любой функции если у нас аргумент известен неточно то результат мы Разумеется тоже имеем неточный А с некоторой погрешностью известно как эта погрешность распространяется пропорционально модулю производной Но кто хочет об этом почитать побольше подробнее вот есть очень хорошая книга ссылка внизу а Посмотрим как это будет выглядеть а более явно начнём обозначать вопросика неточные цифры То есть те которые Пали в погрешность если мы посчитаем арксинус в а точке а там 0,69 мы получим значение а 1,56 а дальше вопросики то есть вообще говоря если мы а там что-то посчитали там на своём любимом языке программирования А мы получили много цифр и мы привыкли верить этим цифрам а но а мы обычно не задаём се вопросом Какие кием из них можно верить кем нет А если мы а в аргументе а вот в этом случае первые три цифры оставим а остальные Будем считать что они не точны то у результата останется вообще только одна точная цифра вот так работает распространение ошибок Если они у нас уже появились Так что результаты любых вычислений могут быть неточные и могут быть вообще неверны особенно тяжело работать с точностью и надеяться на точность становится если использовать чужой программный код библиотеки фреймворки что угодно и не вдаваться в подробности того как он реализован какие а в нём используются функции как Они сделаны то есть на этом можно потерять а не то что точность даже весь смысл вычислений но отвлечся от ошибок посмотрим что может влиять просто менять численное значение которое мы получаем то есть что может изменить значение нашего вычисления А как Мы помним как нас учили в школе сложение чисел не зависит от порядка когда мы начинаем работать с числами с плавающей точкой 64 32 оказывается что это уже не так сложения влияет соответственно если в наших вычислениях используются библиотеки в которых есть векторизация то То как реализована э векторизация влияет на порядок и мы можем получить другой ответ просто другое значение в разных системных библиотеках есть неско математика тем что значение тангенса изменилось при переходе с машины с унту 204 на унту на машину с унту 22204 потому что там просто разные версии ПЦ и соответственно разный тангенс а при реализации каких-то своих библиотек мы опираемся на внешний код и на значение результатов может влиять даже с какими флагами был скомпилированный код то есть есть флаги оптимизатора А ну как мы знаем если мы и работаем с FL 64 то внутри процессора ВПУ происходит работа сбит числами и с этим тоже связан ряд нюансов и на это мы не всегда можем влиять а также расхождение о вычислениях а всё по той же причине порядка слагаемых влияет любой Race Condition то есть любой а влияет реализация многопоточности А даже сетевой обмен данными тоже на это влияет Ну и не всё это мы можем учесть того мы постоянно работаем с числами с плавающей точкой видим что везде Аа нас подстерегают ошибки неточности и вообще говоря мы не знаем А что именно мы посчитали и Можем ли мы этому верить это подтолкнуло к это подтолкнуло нас в криптонит к реализации библиотеки которая работа работает с этим автоматически и проверяет точность а для этого а реализовывать мы это стали на хорошо известном а примере на библиотеке нампи и написали её расширение в котором добавили два основных класса один - это скалярный класс другой класс массива скалярный класс это класс числа с плавающей точкой который при любых операциях а хранит оценку точности в битах Ну и второй соответственно работает с массивами Ну посмотрим как это работает пусть у нас Мы умножаем 9 на 5 двоично в столбик пусть у нас у каждого числа есть один неточный бит А как работает арифметика с неточностями Вот Значит у нас есть наше вычисление Мы хотим узнать насколько точен результат мы неточные биты отметим вопросика А дальше вопросик умножить на чтото это Сложить чем-то это вопросик то есть что попало в погрешность то погрешность вот мы видим что если мы так перемножити 45 Но если посмотреть на этот 45 честно то это что-то от 32 до 47 Мы точно не знаем Вот примерно так это работает на словах на делимым просто сложить пару флотов то Вот в такой код это превращается выделена цветом одна строчка в которой происходит собственно сложение чисел всё остальное - это вычисление точности То есть если у нас была оценка точности в битах то вот так начинает выглядеть оценка точности уже полностью реализованное сложение Ну посмотрим например посложнее возьмём функцию округления вниз это код из стандартного ПЦ а стандартный сиш такой хорошо известный А если в него Не вмешиваться А все те же ветвления лать своим отдельным кодом то потеряется много производительности Поэтому вот вот так вот разбухает код если надо учесть точность и получить оценку точности результата по исходным данным библиотека реализуется на а Расте сине питоне Вот такая связка В итоге получаются а файлы расширения которые ссылки на которые э Будут дальше Где их можно получить но вернёмся Аа к тому А зачем же это всё делается а потому что можно подумать что А ну случилась ошибка округления ошиблись мы там в пся втором бите мантис может быть и не страшно может быть даже и флот 32 хватило бы ошиблись мы там в дм бити мантис какие-то мелочи но иногда это оказывается имеет Неожиданное влияние вот возьмём такой пример возьмём небольшую матрицу там 4 на4 заполним её дабла Будем считать что они все нам известны точно на все 53 Бита мантис и посчитаем определитель нампи скажет нам что вот получилось вот такое число там куча цифр Отлично мы это видим Мы в это верим мы это используем А в ЧМ смысл разработанной библиотеки что мы пота и получили число которое мы видим строкой ниже видим несколько точных цифр и мы видим что дальше даже вот в простом примере в маленькой матрице источный чисел Мы очень быстро потеряли точность а но сколько нужно математических операций чтобы вычислить определить ли такой Матрица но там копейки А если мы обучаем большую модель Аа то скорость операций А с с флотами которая нам нужна А может мериться а те терафлопсах тогда А если мы за этим не следим А вот а собственно мы реализуем задачу нахождения вот этих вопроси и обнаружения неточностей вычисления те же но увидев неточность мы можем просто не полагаться на мусорные данные вот как мы видим точность Ну во-первых просто на выводе заменяем на вопросики во-вторых точность Мы храним в количест и Ну вот видим пример что если нам случилось посчитать тригонометрическую функцию от большого аргумента вообще говоря при доведении его в период от нуля до 2 пи мы получаем уже неточный результат и вот легко потерять точность реализация простой потому что кто знает нампи там сотни разных методов это библиотеки больше 20 лет насколько я помню соответственно для версии 1 потребовалось выбрать достаточно большое подмножество вот того что войдёт в первую библиотеку а понятно что произведение вычислений с оценкой точности требует дополнительного времени на эту оценку точности потому что вычисления как проводились так и проводятся те же самые но вообще говоря мы тратим дополнительные ресурсы на то чтобы оценить точность понятно что мы не можем оть точность бесплатно давать математическую оценку точности с минимальными накладными расходами и отдельной особо содержательной сложностью оказалась оценка точности произведения матриц вот с этим оказалось всё довольно хитро потому что произведение матри нужно если мы там учим модельки но операция очень сильно оптимизирована соответственно если считать всё по определению то там получится охд в тысячи раз что а там неприемлемо ни для какого пользователя но с этим требовалась некоторая дополнительная сложная математика не очень сложная Но это Из основной части я вынес так попробовать проверить точность вычислений можно взяв по ссылке на станочники и случаев мы старались чтобы от пользователя требовалась только замена импорта соответственно вычисление будут произведены с а контролем точности на выходе можно будет узнать А можно ли верить вообще тому что было насчитал мы видели что если мы хотим оценить точность а а мы видели что происходит на примере сложения как разбухает код насколько это вообще говоря непросто А понятно что нужно понимать сколько мы за это платим по времени соответственно здесь видим бенчмарки А поскольку время сравнивается относительное Будем считать что соответствующая операци в на делается за единицу времени и здесь приводится сравнение сколько операция с контролем точности занимает в инам и сравнение на двух моделях процессора один там ноутбучный Intel Core другой серверный Ну и мы видим чтот а кода там для оценки точности требуется довольно много но там арифметика становится медленнее там в там два-три раза тригонометрия она более нагруженная поэтому на ней оверхед чувствуется не так сильно там видимо оверхед поменьше значит это бенчмарки по скам беч по массивам А ну вот такие А матри перемножение матриц в данном случае 100 на 100 в количестве там довольно много раз и видим что с перемножения матриц особо тяжёлым случаем Ну удалось там замедлением в 3-7 раз всё-таки давать математическую оценку насколько корректно корректен получается результат насколько им можно верить В каком количестве битов вот ну и для других операций А попроще тут Наверное обращает на себя момент синусом косинусом потому что оверхед на КСИ оказывается каким-то большим Но это связано с тем что просто их вычисление для массивов в напе сильно оптимизировано Вот так так Ну это всё по основной части и планы что мы хотим делать дальше с библиотекой я вынес в обсуждение собственно дальше следующие цели - это до перегрузить А из на всё ж не перегружено добавить комплексные типы преобразование фурье больше линейной алгебры А и далее перегружать другие научные инструменты это с ipn И в данный момент Также ведётся работа по перегрузке методов работы с нестями ирч и чтобы вычислять точность можно было в том числе на ГПУ переходим к вопросам Да спасибо большое Игорь за доклад похлопаем Тае доклады стя математика какая-то жёсткие нагрузки ВС посчитали сказали да тут вы вообще везде были неправы и на самом деле оценивать надо всё по-другому Вот давайте переходить к вопросам У нас есть Два подарка один от нашего партнёра Газпромнефть и второй от Игоря так вот вижу сейчас так ли необходимо Все вычисления производить в вашей библиотеке или достаточно ну Дело в том что все эти оценка погрешности и прочее она зависит от того какие вы действия делаете Что Вы Ну как от метода вот Достаточно ли например при помощи вашей библиотеки оценить метод а потом считать всё в нам и как бы не не попадать на эти зависит от Ну вычисление всегда будет зависеть от данных потому что на одних данных подготовить но на одних данных результат точный на Других данных результат неточный А вопрос какая погрешность в отдельном случае есть кайто что прерываю кажется что это вопрос прямо для большой длинной дискуссии которую мы можем продолжить в кулуарах вот я видел здесь был вопрос Да здравствуйте Спасибо за доклад У меня два вопроса первое Я так понял у вас всё это сделано на Расте Да А а и как библиотека дружит с интри сиками Ну потому что считать на фпу Ну дело такое себе скажем так а Можете пожалуйста раскрыть почему такое себе и ну ну ну нам вендер железа дал там типа 50 регистров очень больших которые быстро делают математику там сложение вычитание умножение и так далее и как-то не использовать это ну не очень хочется хочется использовать естественно и если не использовать это то в производительности можно потерять очень сильно а но это во многом используется во-первых сами вычисления где это только возможно делегирую в нам соответственно в части вычислений все интри сики используются и вся векторизация есть потому что она есть в нам а с оценкой точности но ВС зависит от конкретных математических функций Но в каких функциях это можно свести к уже готовому готовым методом где там используются по возможности это максимально использ ещё один а я вот Ну Последний пункт очень интересный это поддержка ГПУ А ну сейчас есть такой тренд то что во время вычисления там Что torch что xla они прямо на ран тайме генерируют код и компилирует его и как будто бы туда вообще невозможно строиться в таком случае но под точ э можно писать расширение на куде А и тут в этот момент вместе с растом ещё рядом встаёт куда момент в том что сам кель он генерируется на ран тайме То есть в принципе там ну мы можем только Ар уже читать Ну да как туда вклиниться очень непонятно думали вы об этом или нет для того чтобы оценивать точности нужен некоторый определённый набор лов кудос их про прописать заранее вот а их их нет Там только em коллеги Мне кажется что у нас уже Вопрос превращается в диалог А ещё есть желающие Давайте передадим слово другим вот пожалуйста на первом ряду так Спасибо за доклад А может поподробней объяснить чем как векторизация добавляет ошиб в отличие от просто умножения а векторизация меняет порядок вычисления То есть если мы а там складывали числа в массиве одно за одним то это один порядок А если мы там складываем их там условно четвёрками потом складываем результат то Ну у нас просто по-другому расставлены скобки а сложение сложение вещественных чисел оно ассоциативно сложение флотов оно не ассоциативно так что тут и векторизация что угодно может дать другой результат так ещё вопрос вижу на дальнем ряду здесь вот Спасибо большое за доклад меня такой вопрос ня допустим х операций которые я прол и понял что Ошибка вычисления очень большая что мне с этим делать дальше Есть ли какие-нибудь вспомогательные профилировщик которые бы мне подсказали что вот смотри у тебя здесь большая потеря точности или вот на этих данных такой вопрос спасибо Ну можно по ходу вычислений От операции к операции смотреть Какая точность у значени в данный момент То есть можно не только на результат смотреть Вот то есть это можно останавливать вычисления тогда когда они потеряли смысл а не доводить их до конца и не жечь лишнее электричество Вот спасибо здесь ещё Следующий вопрос Спасибо за доклад вопро вашу библиотеку использовать для Ну тестирования когда я математику переношу с архитектуры на архитектуру с там о на о и тому подобное Ну то есть результаты мне все прин и я так потом текстовые файлы скидываю Ну сравниваю или может быть есть ещё что-то данных входно ня архитектур пока что реализована версия только для x86 64 но сильные привязки там на данный момент нет Так что следующая цель видимо сделать под Арм А по операционным системам но сейчас Linux протестированы Debian like Но а вот это вот это не сильно планируется расширять А в отличие от платформ Игорь Можно я немножко дополню ровать это а таким образом возможно планируется но когда сделаем больше платформ Понятно спасибо ещё вот вопрос в серединке зала совсем у колонны Спасибо за доклад У меня вопрос А вы не думали может быть эффективнее разработать библиотеку которая внутри использует флот с более больше данных под монтис больше бит под монтис тогда бы она вычисление делала более точно Потер потеря точности происходило бы намного медленнее и результат В итоге был бы более точный на выходе и не нужно было эти вопросики выводить а проб от увеличения количества битов проблема никуда не девается То есть если мы посчитали А на флот 32 и потеряли потеряли значимость и попали в цифровой шум это не значит что на флот 64 мы не попадём а самая большая проблема что А если мы не следим за точностью то сколько бы бит монтис У нас не было а мы не узнаем о неточности то есть не очень понял почему а но у нас была Матрица Аа там 4 на4 мы а сказали Посчитайте определитель нам вывели число а нуно у нас на выходе число Аа Откуда мы знаем насколько э можно верить этому значению если мы не видим аа где цифры а где вопросики нет если вас матри 4 на4 каждое число задано с точностью например во знаков после запятой А если я их держу 1520 знаков после запятой Конечно у меня знаками после запятой точность коллеги я немножечко вас рву У нас есть ещё желающие задать вопрос и мне кажется именно углубиться в кишки этого всего можно дис пос доклада напрямую со спикером на последнем ряду пожалуйста Вопрос Да спасибо за доклад уточняющий некоторый вопрос Ну то есть понятно как нам нужно оценивать точность когда мы сложение умножение делаем чисел но у вас в библиотеке реализованы более сложные функции синус косинус которые вообще говоря будут зависеть Как вы сказали от версии нам от версии там определённо там библиотеки нампи посмотрели какие там формулы используются для синуса косинуса эти формулы зашили у себя в библиотеке оценили точность и собственно говоря её выводите То есть если допустим они что-то у себя поменяет то у вас уже будут не такие точные оценки А ну помимо оценок исходящих из реализации мы используем просто оценки исходящие из математики Потому что если аргумент известен с некоторой с некоторой погрешностью и мы считаем значение функции там вот у нас синус дифференцируемая функция можем посчитать значение производной посчитать коэффициент распространения ошибок иние это сину математически гарантирована а и а таким образом в результате где написан а оказался вопросик вместо цифры там математически обосновано и гарантировано что это мусор а не данные и с этим нельзя работать придавать этому никакой смысл спасибо Вот ещё здесь вопрос чудесной книжки Бахвалова которая соче теоретично есть ли какие-то более приближенные к программированию именно численных методов рекомендации то что книжка Похвала - это классика это как бы все знают все в университете её изучали программировали К сожалению сейчас её редко читают да Ну может быть что-то что например к программированию на GPU на интри Сика вот что-то численное Вы можете что-то порекомендовать что-то вот более приближенное к к программированию нежели чем к математике но почему-то первое что приходит на ум это читать срц греб Ну да спасибо за вопрос здесь вот ещё один Спасибо за доклад А вопрос какой-то даёт Ох по памяти а по памяти это даёт overhead значит сейчас оно хранит к flot 64 оно хранит дополнительно на точность ещё байт вот так что верх не очень большой и это заведомо лучше интервальные арифметики в разы Спасибо коллеги ещё вопросы вот здесь пожалуйста Спасибо за доклад а на самом деле всё так плохо посмотрев ваш доклад кажется что вообще ничего делать нельзя получишь какой-то мусор или это какие-то такие были специальные примеры на которых всё плохо Ну Матрица 4 на4 специальная а но а про но арксинус в 0999 Там по-настоящему просто высокая производная ничего не поделать но а в остальных случаях и в тех датасета которые нам встречаются ответ неизвестность если мы не проверяли не сделали ли мы арифметическую ошибку а не является ли результат вычисления артефактом шума пока не проверим и не узнаем Можно вопрос да спасибо Мы уже по второму кругу кажется идём Давайте вот здесь сначала а потом к вам скажите вот погрешность вычисления так как у нас двоичная арифметика она выражается в битах а вопросики вы рисуете в десятичных знаках и дело в том что чем ближе эти десятичные знаки к точке чем значит там погрешность и вы можете нарисовать что у Вас например второй знак неправильный а на самом деле там точность Ну ещё более-менее но есть такой момент что точность в битах И точность в цифрах никогда друг в друга не попадают кроме одной точки кроме нуля порено Да поэтому количество вопроси тут вообще может чуть-чуть съездить но а из биков получаете как бы как пол цифры пол десятичной цифры как пока Ну если цифра а точна наполовину как бы То то я рисую вопросик потому что цифра которую мы наполовину знаем Ну тут но да этом Нам же это же просто представление Потому что если мы в двоич представим нас будут вот такие цифры но там зато будет всё знать что вот столько у нас если мы храним всё двоично а то у нас таких проблем нет проблема только при распечатывании но да есть такой момент есть такая сложность Аа И если мы Аа захотим а там а распарсить число у которого указано точное количество цифр Вопрос сколько у него точных битов тут тоже будет неоднозначно это неоднозначность в обе стороны Спасибо И давайте вот последний вопрос из этой половины зала и перейдём к выбору лучшего двух лучших А где и как вы ваши компании сами используете точно себя это используем Когда ставим Эксперименты на нейросетях и проверяем их Надёжность соответственно а Тестируем численную устойчивость оптимизатора Смотрим как а оптимизаторы внутри устроены потому что А если почитать документацию того же торча то там можно увидеть что а там вот есть такой оптимизатор Вот есть такой но он вроде как более численно устойчив но ссылки отсылки что что-то более численно устойчиво они обычно присутствуют там в документации или где-то ещё более-менее на словах что что-то более что-то менее А откуда узнать как численная устойчивость сработала в отдельном в отдельные ситуации и как проверить накопились численные ошибки вот э чтобы знать Это точно нужен инструмент Вот это этот инструмент Спасибо Э довольно много вопросов было Игорь к тебе Выбирай э парочку лучших сначала подарим А подарок от нашего партнёра Газпромнефть Давай выбирай Какой больше понравился вопрос про а вопросики бинарные и десятичные вот кажется ваш был да и Следующий вопрос которому подарок от себя вопрос про Иринки xse так это Напомни из какой половины зала с Дальнего ряда коллеги кто задал этот вопрос поднимите руку пожалуйста вот там Спасибо Попро также пере оценить доклад Игоря и его ответы а также постепенно перемещаться в дискуссионную зону куда Игорь подойдёт сейчас Спасибо вам большое"
}