{
  "video_id": "n-KcvgCrKHM",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "Меня зовут Максим Кошкин Я занимаюсь разработкой нашего в тарантуле поддержкой старого функционала Вот иногда разработка новых фич Сегодня поговорим про обработку исключений и интероперабельность Давайте сначала введём немножко контекста Что такое таран тара решение для обработки данных под капотом у на сервер плюс in Memory Database соответственно очень возможно писать сложную логику на лу для этого у нас есть собственный for Lit внутри логика у вас произвольной сложности Может быть вы можете написать внутри Таранто хоть веб-сервер если вам очень сильно захочется и это даёт вам большую свободу В смысле работы с данными к тому же у вас язык общего назначения в виде luo и если это кому-то было мало этого функционала то э Вы ещё можете его дополнительно расширять с помощью C это приводит ещ в том числе к тому что ви старых дизайн решений многие компоненты таран написаны на си и из-за этого наш очень тесно переплетает вызовы из злу и обратно как я сказал можно расширять с помощью си И для этого есть несколько способов первый способ это написать модуль для Также можно можно вызвать функции напрямую и злу с помощью for function интерфейса просто погружаетесь оттуда какой-нибудь конкретный символ и пользуйтесь им в общем Как как будто Вы пользовались бы этим SC Также вы можете вызывать L функции C через L C э в результате у вас может быть очень сложное исполнение с несколькими слоями переходов из C в L и обратно а и это как бы очень часто затрудняет ситуацию А и вс бы хорошо и понятно но в любой программе возникают отличительные ситуации У Вас там какая-нибудь соседка сказала что интернет не нужн отрезала вам во окно ножницами у вас взорвался там какой-нибудь соседний хост И вам надо обработать эту ошибку обработка ошибок в коде может выглядеть по-разному Вот так это пряме в огород то маленькой корен У кого был Код Да вот как простыня Вот такая выгляд поднимите руку пожалуйста хочу посмотреть на этих страдальцев вот она может выглядеть вот так ну или вот так если кто не знает лу то это то есть у вас просто если влетает какой-то вы получаете стату что фун сообщение об ошибке дальше можете как-то обработать есть при полный эквивалент но всё это на самом деле мишура потому что на самом деле несмотря на всякие синтаксические сахара разных видов У вас есть только два основных способа обрабатывать ошибку и это либо исключение либо возвращаемые значения Это та очень сложно выбрать какой-то один способ Если в вашем языке поддерживаются исключения потому что вы обязательно найдёте какого-нибудь товарища который написал модуль который бросает исключение И вам придётся хоть какую-то прослоек несчастную написать дела становятся ещё интереснее в момент когда вспоминаем что у нас возможны сложные сэндвичи в исполнений например посмотрим вот на такую ситуацию у нас есть такая функция которая делает ничего выбрасывает эп с другой стороны у нас есть шный скрипт который пользуется ffi подгружает этот самый символ и соответственно мы как пользователь нашего прекрасного тарантова думаем я вот пи колом заверну вот эту функцию Она наверное не должна взорваться Я же обрабатываю здесь ошибку всё должно быть хорошо Так он думает сейчас он меня напечатает я увижу что всё плохо и начну какие-то действия предпринимать и видимо и получается вот так вот вместо того чтобы получить нормальную обработанную ошибку он получает развал всей базы звучит не очень здорово С одной стороны как бы пользователь сам дурак потому что пытался поймать влажный пил не подумав о том что это на сам деле не очень совместимая конструкция него не совместимость СК Но с другой стороны как сказал вчера в одном из рабочих чатов Мой коллега Мы хотим чтобы наши ошки были как детский крем для кожи пользователя как соляная кислота Поэтому нам всё-таки придётся позаботиться о такой ситуации поэтому сегодня мы обсудим Что такое интероперабельность исключений и как она нам такая ситуация нас спасёт Какие механизмы обработки исключений вообще есть и были исторически Вот как это всё было выстроено И как с помощью этих механизмов можно сейчас реализовать интероперабельность относительно дёшево и без були Ну и также посмотрим как э интероперабельность реализована в собственно интероперабельность - это как раз-таки возможность выбросить ошибку например из лу и поймать c+ Аналогично сделать и+ выкинуть поймать его в Ну или выбрасывать ошибку изловить обычно иг что многого свх промежуточных из разных в разные ран таймы Ну и Аналогично для плюсов собственно с интероперабельность понятно понятно как она очевидно нас спасает в этой ситуации что мы как раз-таки разрешаем вот эти все проблемы связанные с тем что пользователь ждал одного поведения но подорвался поговорим теперь про ток устроенный эксп кажется что Ну что-то примерно вот так что всё очень просто там что-то выбросили оно куда-то там полетело кем-то поймала и всё стало замечательно А да концепция примерно такая что мы там бросаем исключения ищем обработчик дальше у нас развилка мы либо обработчик нашли тогда мы передаём это управлени как это обрабатываем ждём дальше либо у нас развал там кровь термине и всё очень плохо вот на самом деле е ещё иногда упускают вот этот этап что мы обработчик в первую очередь отметить должны и вот это как раз-таки тот этап где происходит всё самое интересное самым первым способом обработки исключений был так называемый это способ ключения прямиком откуда-то вот из Восьмидесятых когда исключения только начали появляться собственно это способ Ремо двух функций стандартной библиотеки Первый из них это Конте фу текст можно восстановить попасть снова в эту же точку при этом для наружного наблюдателя это выглядит как второй возврат из Jum собственно есть парная для джампа функция называется она Long Jump Она позволяет соответственно вот этот сохранённый контекст устанавливать при этом она принимает на вход дополнительный параметр который будет новым выходным значением са джампа в первый раз когда мы сохраняем контекст если это получается успешно Jump возвращает нам ноль во второй раз вот это значение которое мы предоставим этом пот момент сохранения от момента когда мы снова попадаем в эту ситуацию отсюда возникает закономерный вывод о том как мы можем с помощью всей этой машинерии построить простенький такой возьмём просто вот такую штуку напишем что у нас будет сохраняет контекст дальше потенциально бросаю ться С единий М проваливаться не в тело в тело с Маги макросов это вообще можно превратить честный такой красивенько замечательно и вроде бы всё там всё понятно но не совсем потому что в реальной жизни конечно обычно всё сложнее устроено в коде и там бывают например вложенные й блоки не очень понятно как зде будем спи контек поддерживать какой нас активный Ну и смотре ПП кото поймать можем собственно когда мы заходим ВБ мы добавляем в наш список очередной блок соответствующий этому контексту и дальше итери собственно вкладываем в новый контекст добавляем его тоже в список дальше у нас происходит выб исключения и мы такие Ага и начинаем идти по нашему списку смотрим Что вот мы не смогли обработать смотрим Что нам не подходит первый обработчик нас есть под тип нашего исключения Значит мы поднимаемся на уровень опускаем на уровень ниже смотрим Что Да здесь у нас ти совпал Классно Это на обработчик Замечательно Что упустили Ну хотелось бы ещё объекты вот те самые объекты которые у нас вот здесь вот есть ещё иннет соединения соке и так далее ВС это надо честно уничтожать а не просто бы задирать эту память поэтому что люди приду этой ситуации Давайте ещ и список созданных объектов поддерживать что бы нет ну и ь на получается два параллельных списка которые мы точно таким же образом когда мы заходим видим что у нас какая-то новая новая объект сода добавляем это список Даше ситуация аналогична когда мы смотрим Что ага вот у нас здесь у нас не совпал тип эп который обрабатываем мы вываливается ну безумно высокие накладные расходы Вы должны поддерживать список контекстов Вы должны поддерживать список созданных объектов Вы должны перемещать значения из регистра в память наоборот чтобы когда вы там восстанавливается в сохранённый контекст вы могли переложить всё в регистры и выработать как будто ничего и не происходило ие в этом всм этот даже исключение у вас вообще не происходит то есть вы делаете Это всегда даже если ваша программа работает идеально Вы вынуждены ВС равно всем этим заниматься и по сути вы получаете постоянное замедление вашего приложения Но если посмотреть на всю концепцию Чуть более внимательно можно увидеть что по сути мы смотрим на то что вот в этой точке программы нам просто в обработчик перейти Ну в какой-то мы это вынуждены там понимать с помощью списков Ну вот нам просто надо переходить в обработчик в другой какой-то точке нам надо сначала структор для объекта вызвать а потом только перейти в обработчик тоже в какой-то там обработчик и по сути получается такая табличка причём получается так что эту табличку на самом деле Можно даже на этапе компиляции генерироваться и такая табличка и такой подход рождает основной способ для обработки эксп в настоящее время название DF exceptions exceptions устроена следующим образом у вас обработка исключения состоит теперь из двух фаз первая фаза - это вы на каждом фрейме вашего стека вызываете особенную функцию которая называется personality rutin personality R ищет обработчик если она смотрит на фрейм говорит Да в этом фрейме есть обработчик тогда Замечательно Говорите классно наш поиск завершён мы можем переходить к следующей фазе Если вы проходите по всем фрейма и на всех фрейма рутина вам говорит Тут обработчика нет мотай так дальше то всё очень грустно вот вы завершаете с термитом важно сказать что перна рути у каждого фрейма своя то есть при компиляции можно учитывать какую-то специфику если ваш фрейм какой-то ве особенный и необычный это важно запомнить потому что это то на чём будет строиться решение нашей проблемы в дальнейшем следующая фаза - это фаза очистки собственно фаза призвана для того чтобы все эти ресурсы которые у нас были вот те самые например си плюс плюсе объекты честно и аккуратно высвободить мы разматываем стек в этой фазе до вот точки Где находится наш обработчик попутно на каждом фрейме мы очищаем вот эти объекты для этого снова используется Потому что семантично считается что только она понимает что действительно у нас происходит внутри этого фрейма и умеет его правильно очищать собственно после завершения фазы очистки в самом её конце мы передаём управление в так называемый Landing пад это ещё одно специальная прослойка которая в конце обработки исключения вызывается чаще всего она особо смысла в себе не несёт Там могут производиться какие-то особенные дополнительные действия по восстановлению контекста если вас что-то очень сложное Но как правило там вызываются выбирается один из подходящих вам кэтч блоков если у вас их например может быть несколько в вашем языке собственно Давайте посмотрим как это выглядит на такой иллюстрации вот у нас есть какой-то стек У нас есть самый верхний фрейм который выбрасывает исключение и где-то там пониже у нас есть фрейм с обработчиков фрейму она нам говорит Ну в этом фрейме нету хендлера помочь ничем не могу Давай дальше мотай мы мотаем дальше лити рутина первого фрейма говорит снова у нас нет хендлера мотаем дальше мотаем дальше И вот нам персона рутина третьего фрейма сообщает что я хендлер нашла всё можешь рапортовать о том что у тебя прекрасно закончилось фаза поиска и идти и дальше очищаться И там возвращаться к нормальному исполнению свои программы запускается фаза очистки Да важная деталь которую я не сказал заметьте что здесь мы фреймы со стека не убираем мы на самом деле просто Подглядываем под них и стек при этом остаётся в неизменном виде в фазе очистки Теперь мы к уже начинаем модифицировать и прям по-честному убирать фреймы с верхушки вплоть СБО сно вызва для те самые действия по очистке говорит продолжай размот то же самое происходит на Первом фрейме на втором фрейме на третьем фрейме Мы выполняем действи по очистке и вот говорим что всё можешь выставлять контекст для того чтобы возвращаться в ту точку которая этому обработчик соответствует собственно это и происходит А ну про Landing пад Да я сказал уже что он выбирает один из подходящих Кеч блоков либо там может делать ещ какой-то специи нужно для вам в логику И в некоторых особенных ситуациях о которых мы чуть дальше поговорим он может ээ пробрасывается Вот это перебрасывание младенца туда-сюда аэ да поговорили про то какие механизмы есть Теперь давайте поймём Как с помощью всего этого нам добиться нашей цели чтобы наш пользователь мог бросить какой-нибудь c+ поймали его в или наоборот вот если у нас есть виртуальная машина другого языка в нашем случае это у вас в этой виртуальной машине есть конкретная функция которая является точкой входа в это в нашем случае это мы начинаем в этой точке интеро им просто задать ли рути для этой функции потому что для Сток это ВС равно выглядит как офре дальше с помощью рути это мы будем выполнять внутри неё всю логику которая соответствует Абсолютно аналогичным манипуляциям для стека виртуальной машины сюда входит как раз-таки поиск обработчика в стеке виртуальной машины очистка объектов из виртуальной машины и по сути Мы хотим полностью мро только на стеке виртуальной машины внутри этой ру для одной функции собственно посмотрим как это на схеме выглядит у нас есть какой-то хостой стек есть какой-то плюс фрейм который бросает исключение его персона говорит Лера нет мотай доходим процесс но теперь на стыке виртуальной машины там происходит опять же размотка мы находим найком нам персональна говорит всё найдено всё классно Ну фаза очистки выглядит абсолютно Аналогично Я поэтому оставлю её как говорят в умной литературе как упражнение читателю есть важные нюансы работы с чужими исключениями чужие исключения ни в коем случае нельзя менять даже если вы верите вы на 100% понимаете их семантику компиляторы могут делать какие-то неожиданные закладки совершенно на то что у вас лежит в этом эксп менять данные не стоит потому что вы можете разнести свой ратай в щепке Вы можете получить совершенно неожиданные сайд эффекты Поэтому если вы работаете с м исключением Вы должны его в неизменном виде оставлять соответственно чтобы его чтобы реализовать интероперабельность Вы можете выбрать один из двух путей ли вы можете остановить чужое исключение при этом создать какой-то свой эквивалент например c+ выкинуть в помойку и создать вместо него ошибку внутри это персоналити рутины и бросать дальше уже её Либо вы можете пробросить тот же самый Exception дальше неизменно собственно про голую идею реализации интепе поговорили Давайте посмотрим на реальный пример сейчас будет немножечко листингов наберите воздуха в грудь достаём контекст текущий для исполнения Вот Эта замечательная функция она занимается тем что она ищет хендлер в ке виртуальной машина это огромен функция строк на 3400 Поэтому я решил Вот её просто за одним вызовом спрятать чтобы роть людей слишком уж сильно Вот она нам соответственно либо если она не нашла нам хнр говорит мотай либо если нашла мы дальше проверяем у нас Exception какой вообще если он плюсовые тогда соответственно мы мы там выставляем всякие - коды в зависимости от того какой у нас тип ошибки удаляем теперь уже c+ Plus Exception как я и говорил раньше а потому что у нас была создана вместо него ло ошибка на предыдущем шаге и теперь Мы выполняем размот но уже с очисткой стека виртуальной машины выставляем контекст для того чтобы восстанавливаться в обработчике ошибки внутри виртуальной машины и собственно говорим что всё Мы готовы возвращаться в мир и дальше исполнять всё как ни в ЧМ не бывало но всё было бы очень просто если бы в те не было вот этих сладких трёх букв в конце которые всё очень сильно осложняют Т компилятор находит горячие участ кода в процесе исполнения записывает в нативный машинный код чтобы исполнение было побыстрее и пошустрее и это создаёт нам две новые проблемы проблема первая у нас генерируется новый код новый машинный код соответствующий этой трассе и нужно регистрировать информацию о фрейма соответствующих этому машинному коду то есть Нам нужно задавать персоналити рутину нам нужно задавать Описание о том какая персона соотвествует этому коду и так далее вторая проблема которая здесь возникает то что на выходе с трассы нам нужно привести виртуальную машину в соответствующее состояние Если в целом Ну в общем это Это целый отдельный сложный механизм про который мы сейчас тоже немножко поговорим А с регистрацией нового фрейма в целом большой проблемы нет потому что в д есть прекрасная функция register Frame которая позволяет зарегистрировать информацию о каком-то вновь сгенерировано коде информация подаётся в виде двух сущностей это так называемый Frame description entry tion это по сути структур в которой хранится информация вся нужная фрейме Это кто его Тина какого там он размера и так далее может быть что-то ещё дополнительно жать простоя энон чтобы если у вас информация дублируется о нескольких фрейма её просто вынести в какое-то общее хранилище вообще эти штуки довольно замороченный Поэтому если вам интересно вот здесь можно подробнее почитать про то как это всё внутри устроено вот нас интересует конечно же в первую очередь то что эти две структуры описывают э как нам размотать каждый нужный нам фрейм и кто его персоналити рутина а большего нам собственно и не надо а про генерацию нового кода в целом стала Понятно теперь перейдём к вкусному собственно Да концептуальная разница между виртуальной машиной итом заключается в том что у нас ВМ исполняет бай код исполняет машинный код и у нас виртуальная машина хранит данные на виртуальном стеке Лота а git хранит как можно больше значений в регистрах и соответственно на стайке хостом в связи с этим возникают определённые сложности с тем чтобы эти значения перекладывать когда мы выходим в случае эксп в неожиданном месте со стороны исполнение кода в жите для внешнего должны выглядеть так как будто на самом деле она исполняется в виртуальной машине как будто этого изменения не происходило то есть поведение и результат должен совпадать абсолютно Так конечно бывает не всегда Вот Но это то к чему Мы стремимся вот предположим у нас были такие кусочки кода и вот один из них стал горячим по нему начинает записываться трасса она записывается вот внешний пользователь думает что у него там всё ещё исполняется виртуальной машине на самом деле у нас этот средний кусочек исполняется Джим у нас сгенерирована трасса собственно вот здесь вот этот кусочек он ожидает что он получит значение результата вот этого исполнения трассы на виртуальный стек А вот тут на самом деле значение в регист е хранит выглядит так будто вот должна быть прослойка которая ВС это Нежно и аккуратно переложи и вот понимание этого механизма нам поможет честно восстанавливать состояние виртуальной машины при выходе поп тоже И этот механизм называется снапшоты снапшоты как раз таки позволяют переходить между виртуально машино трассами и всё что они делают сучки задают отображение между регистрами которые используются в этой конкретной трассе и слотами ше ВИА Маши при этом спш вте сдела достаточно Умно чтобы не занимать много пространства и не отнимать много времени на востановления они синхронизируют только те значения которые реально изменились исполнения посмотрим как это выглядит вот у нас есть какой-нибудь простенький цикл на и есть для него этото ние Здесь всё ещё ничего непонятно цифры какие-то поэтому Давайте немножко упрости для убывала чуть лучше вроде бы мы видим что мы прибавляем единичку к иксу дальше у нас вот есть какой-то там Snap Ну это вот как раз таки наш спш и дальше идёт сравнение икса с четвёркой собственно этот спш и говорит о том что если вот сейчас после этого сравнения мы выходим из цикла то есть выходим с трассы выходим в виртуальную машину то ты мне пожалуйста вот этот вот самы который мы поменяли ты мне вот в третий Слот стека Положи вот чтобы для всех последующих участков кода это выглядело как будто всё Вот честно исполнялось на виртуальной машине собственно вот этот механизм Как раз-таки нам и позволяет добиться правильного восстановления после исключения мы расставляем дополнительные снапшоты внутри виртуальной машины в точках где у нас потенциально может выть выброшенные исключения Например у вас какая-то операция слово таблиц Где вы создаёте там постоянно новые ключи там есть ограничения на количестве ключей после которого вы получите просто Exception о там очень большой порядок имеет но тем не менее наши пользователи с таким периодически сталкиваются Вот и соответственно Когда у вас Э вы получается исключение на трассе вы находите подходящий вам snaps устанавливаете с виртуальную машину А как обрабатывать исключение виртуальной машине мы уже знаем там всё понятно собственно в коде это выглядит вот так sech фаза для трассы выглядит В общем совсем простенько Потому что если мы сломали словили Exception на трассе просто говорим здесь есть обработчик Но даже если его не окажется мы потом с помощью НГ Пада переброс не проблема собственно дальше запускается фаза очистки в ней на самом деле тоже какой-то очистки не происходит Мы просто используем вторую фазу для выполнения несколько иных действий мы достаём адрес на который мы вернёмся после выхода с трассы и выполняем размот трассы но трассу размотать проблематично это сплошной кусок машинного кода поэтому на самом деле под размот трассы подразумевается просто поиск подходящего снапшота которым воспользуемся что выйти с трассы подходящий snaps подразумевает под собой тот который нам позволит наибольший Прогресс наш Сохранить то есть мы можем в целом хоть в самое начала отпрыгнул выкину в полностью всё то что мы сделали скомпилированный участке но мы так не хотим мы хотим выгодно использовать быстрые вычисления на нативные поэтому мы делаем э находим своё текущее положение в этом участке машинного кода и дальше э с помощью бинарного поиска просто ищем самый ближайший к нам по которому можно восстановиться Ну и дальше соответственно всё по классике что мы просто выставляем контекст и выпрыгивая в обработчик собственно все аспекты мы обсудили Давайте посмотрим теперь что стало с примером из начала вот у нас был такой скрипт который бросает исключение и было вот так а стало Вот так мы теперь можем обработать видеть что Да у нас функция завершилась некорректно вот там произо C теперь пользователь это может как-то обрабатывать и на это закладываться спокойно Также можно посмотреть на пример датс у нас есть какой-то код который делает большую нагрузку там на табличку записывает туда много-много ключей вот в какой-то момент у нас пройдёт так называемый Table Overflow у нас просто кончатся хэш слоты в таблице Как видно это достаточно большое нужен порядок для количества ключей но такие ситуации бывают вот и если раньше было бы вот так то Теперь стало вот так собственно подытожим на стык н таймов всегда очень сложно обрабатывать ошибки особенно когда это у вас что-то интерпретируемые и что-то нативно исполняемое одно из решений которое здесь может помочь - это интероперабельность исключений рее достаточно легко вы зате одну для в точке входа ваше виртуальную машину расставляет динг пады в нужных местах виртуальной машины где нужен какой-то дополнительный контекст востановить Если у вас есть трасса вы задаёте персоналити рутин для них с помощью рестер фрейма и расставляет дополнительные снапшоты или их эквивалент Если у вас есть тоже как-то Т компилируемый какой-то динамический язык собственно на этом всё оценивайте доклад и пожалуйста оценивайте Потому что в Питере мне не хватило двух голосов чтобы количество оценок было статистически значимым вот и мне от этого было очень грустно вот Спасибо я готов ответить на ваши вопросы Спасибо поднимайте руки у вас найдёт микрофон и вы сможете задать свой вопрос Привет подскажи а вы делали какие-то бенчмарки того как быстро стали работать исключения с c+ Plus и просто слова ещё раз да то есть какие-то замеряли ли вы время насколько исключения c+ выкидывается медленнее Ну обрабатываются медленнее чем просто слово Нет я думаю что мы это не замеряли в этом на самом деле нет большой нужды Потому что если тебе приходится бенчмарка скорость работы исключений в й программе то кажется ты что-то пишешь не так спасибо спасибо Следующий вопрос я вс-таки продолжу предыдущий вопрос хорошо если у нас нет исключений это как-то влияет на время выполнения нет потому что дворф информация при компиляции генерируется складывается в прямо наш бинарный файл в отдельную секцию соответствую иму кода лежит и всё то есть нам не надо какие-то контекст поддерживать как в случае с ничего То есть дополнительных накладных расходов не создаёт абсолютно хорошо И второй вопрос А что со стек рейсами в плане ну интересно посмотреть где как оно отлетело вот через что проходило и где свалилось Да стектрейс можно посмотреть как раз-таки потому что дворф нам предоставляет прекрасные механизмы для размотки стека Единственное что возникают сложности с трассами опять-таки потому что там при записи трассы могут онлайни какие-то функции в плане луш и мы будем терять информацию просто о том что там что-то было в плане какой-то вызов то есть с этим можно бороться но тоже есть сложности определённые и на производительность Я так понимаю это пока не реализовано Судя по примером Нет спасибо а скажите вот там вот этот механизм сатов которые мат соответственно регистры и значения стека аппаратного на стек виртуальный Вот и вы говорите что вот возникло исключение мы и дальше мы ищем ближайший этот ближайший спш чтобы сохранить там значение Вот но дело в том что этот спш ближайший который вы найдёте там из-за переиспользование регистров и прочего он может совершенно не туда Всё писать и портить всё записан в с форме поэтому такой проблемы там не будет Вот ну то есть переиспользование регистров форма в которой получается что Ну в общем долго объяснять но смысл в том что там исполняется используется каждый как бы регистр единожды то есть там локация регистров сделана так что аэ восстановление это будет корректно Но конечно там есть баги связанные с этим иногда это там работает не совсем так как ты этого ожидаешь но а это именно ограничение Lit Я просто не очень как бы в куе Нет это классический абсолютной подход из Нет нет нет я понимаю да Ну то что то что компилируемый в этом коде получается а все регистры по единожды используются Нет все регистры не используются единожды они используются в смысле единожды до до до до следующего снапшота так чтоли Ну не совсем Так ладно давайте в Спасибо Максим Спасибо большое за доклад У меня вопрос по пму слайду Вопрос такой ме что-то выполнить Нет спасибо ещё вопросы а есть у меня ещё такой вопрос был у тебя был слайд где было расписано четыре варианта где c+ Илу да когда ты мог игнорировать c+ когда ты мог его ловить и в обратную рону тоже это не проговорил чётко Как можно управлять тем пропускать Exception или ловить его это как ну пользователь уже в своём лу кода или си ко может оперировать или нет этим можно оперировать посмотрев на тип исключения Вот Но вообще подразумевалось на том слайде что если нету Если есть в общем сины фрейм который бросает исключение сиш cch плюсовой Псой Рем исключение посередине пачка фреймов где нету обработчиков что вот эту ситуацию пролет спокойно то есть что мы не поломаем интероперабельность нормальное положение дел вот что подразумевалось на том слайде обще Ма вот ну то есть если у тебя был плюсовые эсп а по пути встретился лу сколом он поймает туда и дальше от тех пор надо решать что с ним делать А ну то есть я это в лу могу описать Каким образом да Ага уже в пользовательском коде Ой спасибо вопросы поднимайте руку чтобы вас было видно ну что ж в таком случае мы можем считать что сейчас вопросов больше нет но вы Если вдруг они появятся вы всегда можете ловить спикера и задавать вам вопросы лично в дискуссионной зоне и позже сегодня в течение всего дня конференции опять же голосуйте очень важно И для нас и для спикера и Давайте же поблагодарим нашего спикера за его прекрасный доклад ну а мы же должны Мы же если быть точным Ты должен выбрать лучший вопрос Да мне понравился вопрос про стектрейс вот у вас был он кажется да и про ssa поднимите пожалуйста руку кто задал второй вопрос чтобы вас смогли найти вот здесь потому что за лучшие вопросы у нас полагаются подарки и сейчас сейчас их донесут Можете пожалуйста ещё раз руку поднять Да спасибо Ну что ж ещё раз благодарю Вас за то что вы пришли и слушали этот прекрасный доклад благодарим спикера за то что он поделился с нами этим СБО N"
}