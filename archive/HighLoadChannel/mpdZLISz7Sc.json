{
  "video_id": "mpdZLISz7Sc",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "и приглашаем Никиту Галушка из ке и он выж иго максимум Аплодисменты Всем привет Меня зовут Никита Я работаю над ВКонтакте и сегодня я вам расскажу как выжимать из максимум но для начала нам надо ответить на вопрос что значит вообще максимум производительности потому что для каждого это что-то своё но для меня это во-первых минимальное количество локаций которые делает ваш код а в идеале без них за каждый такт Ну и в целом это просто прикольно Просто прикольно знать как что-то вот устроено внутри и для чего это было сделано так А о чём вообще я буду рассказывать Сначала я вам расскажу про память мы А поговорим про Small sze объекты Я надеюсь я смогу вас убедить что интерфейсы - это зло когда мы говорим про производительность в Go и покажу ряд интересных трюков со СТК А дальше поговорим про CPU в контексте того как сильно может влиять B check elimination на производительность и почему не все for loop циклы вообще в Go одинаково полезны и немного затронем тему какие вот особенности вот реализации Go накладываются И последнее что будет мне очень жаль что экран Так низко и дальним лидам не видно мы поговорим про строки потому что в го их очень много и очень много мифов которые есть со строками связаны Да мы поговорим про том о том как оптимально конвертировать и строчки в слайс байты обратно поговорим про оптимизации связаны скато нацией и если хватит время поговорим про сортировку слайсов строк Итак перед тем как начать небольшой дисклеймер код в целом мы пишем конечно для людей но в случае если мы хотим выжить максимум вот из того что есть то увы Здесь нам прид писать код для Маши для компилятора Поэтому в целом за такой код который я буду вам показывать скорее всего вас не погладит по головке на ревью Итак поехали память а сразу Давайте с места в карьер поговорим про Small size объекты а в целом Эта история не только связана с Go но в Go Small size объекты - это объекты которые А вот объём которых занимает не более четырёх а машинных слов да то есть для шести битной системы это 32 байта и чтобы понять как сильно они могут влиять на производительность нам придётся написать пару бенчмарком А вот смотрите представим что у нас есть какой-то Small size Объект который состоит всего из четырёх интов и рядом см Объект который отличается всего лишь на оди функции у нас максимально простые это сумма двух полей объекта к этому коду будет максимально простой мы конструируем объект на месте и вызываем одну или одну или ту функцию в зависимости отти емы его зави работает объектом выполняется в 2Д с по раза быстрее А я напомню что цель у нас вот именно экономия наносекунд Потому что эти функции могут вызываться тысячи миллионы раз но почему так то есть это как-то очень странно у нас два почти вот одинаковых объекта которые отличаются лишь на вот оди ин Чтоб в этом будем мы в него лазать на протяжении всего доклада поэтому хочется рассказать как вы это можете делать сами во-первых есть такой супер ресурс как кобо мне он нравится куда больше чем собственноручно компилировать через gool тем что там можно поиграться с версие можно поиграться с архитектурой под кото будет ци Ну и давайте компилирует что за вот у нас я всякое вот лишнее убрал что не так важно для повествования Но из этого вот Амра видно что функция которая работает со SMS объектом это по факту там пару вот инструкций И что самое интересное здесь мы работаем с вот регистрами напрямую в том случае когда мы работаем с объектом который я напомню всего лишь на о и больше мы во-первых тратим много времени для того чтобы заполнить СТК а затем Мы также не работаем с регистрами напрямую нам также приходится обращаться к стеку и именно в этом и отличие то есть с объекты они позволяют не просто от экономить память и е чтото они позволят ком Да чтобы Мы работали напрямую с регистрами Но конечно весь код написать на таких объектах не получится интерфейсы я напомню что здесь я хочу вас убедить что Интерфейс - это зло у меня будет несколько несколько по иллюстраций одна из них следуя стам что такой интерс где всего ли два метода Один при принимает значение под аргумент по значению а второй под аргумент по вот указателю при этом представим что вот объект у нас будет максимально простой всего лишь два Инта представим что все те оптимизации которые работают для smalls объектов будут работать и здесь а код у нас будет тоже простой это просто сумма этих двух полей если мы запустим следующий бенчмарк который тоже максимально простой Мы очень часто видим похожий код то Увидим что метод который принимает пото объект по указателю не то что работает медленнее Да но он зачем-то лоцируется что-то на хи А во всём виноват наш друг в кавычках Escape Anal потому что он вот руководствуется в этом пото что он вот руководствуется в этом месте достаточно простым правилом что если доступ к переменной имеет более чем одна корутина то её надо надо отправлять на хип но вы скажете там не было никаких рутин Я даже вас сильнее запутаются с типом напрямую без фото интерфейса то фотолокации не будет но для дальних рядов не видно здесь ноль потому что я вас немного обманул в том правиле которые я рассказал у него есть небольшое продолжение что если анализи не может доказать что только одна рутина вот обращается к вот объекту только в этом случае он рует на хи и Здесь проблема в том заходит в нашу реализацию по интерфейса да то есть он видит что о у нас есть интерфейс есть какой-то вызов и мне нужно на месте решить а по отправляю ли я переменную на хип или нет И в случае с фото указателем а Суть в том что переменная может вот измениться дальше при вызове других функции А если мы передаём значение по аргумент по значению то у нас каждый раз происходит поверхностное копирование и фактически мы можем просто отсрочить принятие этого решение а при этом хочется ещё вот отметить Хочется ещё отметить Когда ещё интерфейсы могут давать локацию во-первых самое важное что надо запомнить это любое приведение к интерфейсу это всегда фотолокация за исключением нескольких правил Первое это то что приведение вот указателя к интерфейсу не даёт локаций это приведение интов до 65.000 с назначением тоже не вво локацию И что самое интересное а очень простые типы Да там пустой тракт или страк с полем размер которого не превышает одно машино слово тоже не даёт локации а Поэтому если можете не Используйте в интерфейс просто забудьте что они есть в го если вы хотите выжить максимум а но вы скажете что Ну как-то что-то странно да Ну какие-то там указатели интерфейсы а не очень верится почему надо вот отказываться от интерфейса а окей У меня есть ещё один пример это достаточно частый паттерн который я вижу в разных го го приложениях У нас есть какой-то Интерфейс Да и несколько его реализации в одном пакете в нашем случае там файл дампер импер в базу данных а ну с этим кодом всё хорошо Да он лёгкий он хорошо тестируется хорошо расширяется но у него есть ряд проблем представим что на вот такой Main Да где мы создаём а каждый из Перов Да и вызываем Make Dump который просто вызывает функцию на интерфейсе Если мы с компилирует код в assem и посмотрим что там есть то мы увидим вот такую историю как Go itab я напомню что Интерфейс Да это тип из двух слов состоящий Да где у нас есть вот указатель на данные указатель на тип А и проблема go атап в том что это по факту виртуальный вызов а виртуальный вызов - это всегда поиск по таблице А пока мы ищем Да чтобы нам сопоставить Тип и реализацию Да мы не выполняем никакую полезную работу а что я предлагаю я предлагаю сделать янам Да из тех реализаций которые мы хотим сделать и поставить всего лишь под один тип Да у нас не будет интерфейсов а в реализации Да мы просто по свечу будем выбирать ту или иную имплементация при этом этот код ещ не даёт локации как предыдущий но цена за производительность что это во-первых трудно тестируется тестируется Ну это просто некрасиво и не Вот расширяемой для чего это было сделано а О'кей я вот надеюсь что я вас убедил что Интерфейс - это зло и хочу показать пару трюков с со стека А первый тезис такой что обекты до 6Б будут размещены на сте Но конечно тут со звёздочкой потому что у нас есть анали который может по своим правилам отправить переменную наи вот представим есть такой код слева функции я выделяю два слайса поци больше ну кажется да Что может пойти не так а может пойти не так всё функция выполняется на порядке быстрее и делает ноль фотолокации чем бар но вы скажете Окей если мне нужно выделять на стеке какие-то большие слайсы by Мне нужно уметь жонглировать с помощью там по один слайд второй слайд какие-то индексы нет в Go есть в Go есть вот интересный Хак что мы можем инстанций слайс на месте задав конкретному индексу какое-то значение и в Go это не даёт фотолокации но для меня это ну такая серая зона Потому что есть на эту тему и го команда как как мне кажется пока сама не знает Ок это или нет И с одной стороны вроде бы тикет уже 3 с по года и ничего с ним не происходит а с другой стороны комментарии вот которые там есть говорят о том что ну есть вопросики скажем так Окей про память вроде бы всё Давайте поговорим про CPU и конкретно поговорим про ба у нас ну позиционирует себя как язык безопасный пытается нас дить от выхода за Корец массива Ну или слайса Но насколько сильно эта безопасность бьёт по по производительности представим что нас есть максимально тупой код который из слайса получает он не делает ничего сложного берёт по вот индексу элемент делает сдвиг битовый делает битовые или кажется что эта функция должна работать максимально быстро но если мы запустим а бенчмарк мы увидим что этот код выполняется целых т наносекунды а я напомню Да что аа эта функция может выполняться тысячи миллионы раз и хочется её сделать максимально быстро а и для того чтобы понять почему так нам нужно компилировать в мле и вот увидеть этот страх который нам показывает что каждое вот обращение к индексу по факту подо оборачивается в If Да где мы поем выходим Мы за границу массива Если да то вот паника Если нет то мы делаем Джамп на нужную строчку как бы нам от это под избавиться Ну то есть что если мы знаем что в нашем слайсер количество фотоэлементов Ну или если мы хотим поступить так что если мы выходим за границ массива то всё паника нам уже не важно что-то а всё просто нам достаточно потрогать самый дальний нот элемент и вот очевидно Ну как и для человека так и для го что если есть самый дальний элемент Ну в нашем случае под индексом се то есть и все остальные И если мы запустим тот самый бенчмарк ещё раз уже на эту функцию то мы увидим что поду ускорение в два раза Окей А где вот индексы там и циклы и хочется немного показать А сколько мы платим каждый раз используя for Range потому что я напомню for основан на копировании Каждый элемент по которому вы проходите слайс у вас внутри цикла приходит поверхностная копия этого объекта А вот объект у нас для теста будет максимально простой какой-то объект с индексом и два цикла один for второй for loop делают они одно и тоже но если мы запустим мы увидим что функция которая использует Обычный стандартный for loop по индексу она работает в четыре раза быстрее чем for Range и чем больше вот объект внутри слайса тем эта разница будет всё больше и больше а О'кей А какие ещё есть вот интересности с оптимизацией по CPU в Go А Первое это то что компилятор сейчас не умеет вектори зовать да то есть вот этот код который фактически это просто цикл и сумма Да всех нот элементов он очень хорошо по факту вектори зуе Но увы го сейчас это не умеет Поэтому если вы хотите это использовать вам придётся писать свой код на увы и второе это нужно Забывать про кашли когда я говорил про вот интерфейсы что у нас есть виртуальный вызов это ещё и проблема для кашли потому что мы каждый размыва те вот инструкции которые CPU уже себе взял на вот исполнение при этом вот особенность го в том что у нас как бы не треды а рутины и некоторые фишки к которым вы могли привыкнуть Если вы там на си пишите что нельзя прибить конкретную рутину к конкретному тру CPU и это очень часто делается в сетевых в сетевых приложениях увы в го сейчас это сделать нельзя строки Да мы поговорили про память мы поговорили про CPU Аа когда мы говорим про производительность и всплывает тема строк то всплывает и вот ай а но у Асей в Go есть ряд проблем Первое - это то что перевод из строки например в сй Bite вам даёт а UN Save строчку да то есть любое изменение исходного слайса пай также Вот отразится и на получаемый вам строки и второе и второе то что начиная с Go 120 вам не надо писать своих функций да которые переводят из сй строчку и строчка сй потому что это уже есть в стандартной библиотеке Да в почему это важно знать потому что очень часто Я видел Там ответы на например которые дают некорректную вот реализацию всех этих функций здесь же она максимально правильная Окей какие есть оптимизации над роками в во-первых Когда вы ите чере поке привод слай Bite или сй Room Да это не даёт пото локации А если вы хотите сравнить два слайса Bite Да как строчки и напомню что их нельзя сравнивать через вот равно равно напрямую А то это тоже не даёт пото локации вам в этом месте не нужен никакой Асей можете смело делать через равно равно и А что вот интересно поиск в строке если у нас ключ в строке это это строка ключ в пе э строка А искомый ключ У нас с то приведение одного к другому тоже не даёт локации и ещё есть вот огромный Пласт оптимизации при конкатенации Ну например а у нас есть два слайса байт бар и в строчке мы их конкани с не пустой строкой а в строчке B мы делаем тоже самое только у нас строка пустая как вы думаете а будет под исполняться оптимальная строка A как Поднимите руки кто за A вариа А кто заби чтобы чтобы по у нас конкатенация с пустой строкой даёт ы три аллокации нам нужно код компилировать в assem опять а если мы посмотрим слева конкатенация с непустой строкой справа с пустой то конкатенация с не пустой строкой это по факту просто посчитать выровненный падрес всех наших пота аргументов и позвать функцию из пакета нй в случае же конкатенации с пустой строкой то нам нужно сначала р привести к строке И уже потом вызвать Ту же самую функцию и суть тут в том что го понимая что у него же есть какая-то исходя он может на основе неё сразу фолов память да то есть ему не приходится фотолад фу для бар и уже для всей строчки а при этом если мы зайдём Вот в тот пакет где парализована эта функция А конкатенации то мы увидим что нас встречает а какая-то странная штука а которая нам говорит что есть какой-то временный буфер под размером 32 байта всегда как мы можем это использовать мы можем это использовать Так что конкатенировать строки чанка по 32 байта и нам не надо играться с конци с пустой строкой с непустой строкой это вообще вот роли не вот играет уже здесь что ЕС мы запустим конкатенация с помощью чанков по 32 байта также делает всего вот одну фотолокации строчки при этом у этого у этого знания есть ещё одна ещё одно преимущество это то что любые бенчмарки которые вы пишете обязаны использовать данные по объёму приближенную к тем данным которые у вас будут на проводе иначе Вы можете не увидеть тех фотолокации которые на самом деле есть при этом всё да этот Хак конечно же применим только при кодо генерации Потому что если вы напишите то же самое но с циклом будет работать сильно хуже Но что кстати самое интересное Я не видел ни в одном генераторе который так или иначе как-то отработает со строками этого подхода а сортировка Да этот тикет совсем недавно был и попал в доклад тоже недавно Кет говорит о том что сейчас в го STR который напрямую вот работает со строками работает на 30% быстрее чем genic решение с сй sort это вызвано тем что sort Strings делает всего вот одно сравнение вместо трёх это к тему того что Ну вот кажется я делаю там типа два сравнения или делаю чуть вот больше а чуть больше от работы как это может повлиять А вот так что сейчас по факту В Go нельзя отсортировать оптимально а список по объектов по строке Да который который в поле этого объекта О'кей выводы а мы узнали что такое Small size объекты Да что они позволяют компиляторы создавать более вот оптимальный код Я очень надеюсь не знаю уже в пятый раз наверное говорю что я вас убедил в том что Интерфейс - это зло что если вы хотите выжить максимум Вы должны про них просто забыть напрочь А я показал вам насколько сильно кажется простая проверка выхода за границы массива может влиять на производительность мы вот увидели также Наско сильно Да тот вот или иной цикл и я надеюсь я вас убедил в том что вот работа со строками в Go хорошо оптимизирована и частые случаи там сделаны достаточно хорошо чтобы о них не не думать спасибо спасибо Никита так друзья самое время задавать свои вопросы если вы онлайн воспользуетесь чатом Если вы здесь у вас есть счастливая возможность поднять руку Так давайте начнём с первого ряда и пойдём вперёд Вопросов много да привет Спасибо за доклад Вопрос такой применяете ли вы подобные инструкцию для оптимизации в реальном продуктовом коде активном да А если да то насколько у вас сильно или не сильно желание переписать на языки которые более подходят для высоко наруже таких сервисов А ещё один вопрос будет сме а у нас достаточно много уже сделано подго Да у нас часть движков пишется на c+ Plus но вся Т инфра на ного и уже много много много просто Сделано для него чтобы быстро перейти на что-то Вот другое тут тут как бы выбор-то не вот особо велик А что ну есть плюсы которые Господи пожалуйста не надо есть раст который вот туда же Поэтому вот Остаётся только с го страдать всё понял тогда смежный вопрос но применяя опять же подобное оптимизации можно очень сильно уложить прод если что-нибудь где-нибудь пропустить это либо новый разработчик пришёл не знал либо там компилятор обновился там внутри реализации изменилась вот какие-то может рецепты посоветуете что применять чтобы от себя этого оградить Спасибо даже не знаю нанимать хороших разработчиков Ну как минимум да бенчмарке надо писать всегда если вы хотите что-то по оптимизировать с первого что вы должны начать написать бенчмарк для вашего кода потому что без него Ну это база так сказать привет Спасибо большое за лекцию ты упомянул во время лекции Гош ass вот вопрос такой что ты думаешь вообще про него про документацию к нему особенно и был ли у вас опыт написания каких-либо функций как условно там нетфликсе которые написано на Амбре ускорили какой-либо прод Спасибо А в проде мы не пишем на вот Асем ничего я сам писал и Но это надо иметь очень большое желание в нём вот разобраться потому что документации Ну не Да её нет Можно сказать то есть дадада вопрос в центре Да здесь слышно вопрос возможно глуп но тем не менее задам Почему четыре машинных слова можете объяснить просто большой регистр процессора - это ж одно машинное слово ж верно Вот А почему четыре Почему четыре смотрите у меня нет ответа и я вам даже вот больше скажу что в Go Вы можете передать до дев параметров и все они будут переданы через регистры но уже ф де будет через тек Почему так у меня нет ответа то есть странно да Типа если мы возьмём функцию и придам туда Ту же самую структуру просто разбив по полям там вот де возьмём то всё будет хорошо а если мы её передадим как фото объект то только четыре а как может быть это связано с тем что Go вот умеет делать поверхностные фотокопии и чтобы это делать бы чтобы делать быстро что имеется в виду передать как объект завернуть У тебя есть тракт просто вот или у тебя предложение вопрос нене не яки про объект спрашу что имеется в виду завернуть объект Ну у тебя вот объект просто страк Поля а C D вот я про это имею в виду То есть если ты возьмёшь этот объект и попытаешься его как есть отдать функцию Да ну условно както аргумент один то он будет как стек Ну если там очень много полей но при этом Если ты их разр в де по аргумента то Всё будет ок это кстати ещё к вопросу о том что это некрасиво это ужасно но это быстро понял Хорошо Спасибо большое Давайте дадим слово молодому человеку он уже готов да Подскажите пожалуйста есть ли какой-то линтер или конфиги для Линт где это можно увидеть чтобы мне предложили это исправить это первый короткий вопрос и второй а хотелось бы услышать всё-таки какой-то какую-то метрику на реальном проекте допустим у меня высоко нагруженный сервис я провёл ряд оптимизаций сколько вс-таки я выиграю и почему я выиграю Давайте начну ответ со второй части во-первых Ну по CPU Скорее всего вы не сильно выиграете там пару процентов но по памяти то есть смотрите мы пишем на вот языке который имеет фатальный недостаток это и чем бо вы Алое Тем вы чем вы это делаете чаще тем чаще он запускается и если у вас цель минимизация LC и её предсказуемость то у вас нет выхода кроме как вот этих оптимизаций и Отвечая на первую сть Воса литеров Я не знаю Я знаю Был Была потуга от убера но он очень часто даёт fse POS и поэтому использовать его в проде Ну такое спасибо Так дальше у нас есть вопрос Здравствуйте вопрос может быть продолжение предыдущего Вставайте пожалуйста вас не видно всё вижу Вот то есть на синтетических бенчан в 5 10 раз вы применяли говорить всё это в проде там rps знаю там в каких-то макро показателях такие колдунство вам сколько принесли есть цифры а ну фактически я не могу делиться прямыми цифрами с прода а но на одном из сервисов это было до 5% в сумме а когда мы говорим про социальную сеть где сотни миллионов людей 5% - это очень много Спасибо так был Ещё вопрос чуть дальше слева центра Вот микрофон есть Вставайте задавайте вопрос пожалуйста Да спасибо за доклад А вопрос такой вот мы оптимизировали сделали локальную оптимизацию на кусок кода и дальше этот код живёт обновляются библиотеки обновляется версия Go э Может есть какие-то практики Как не потерять э взгляд на вот этот кусок кода и держать его оптимальным возможно в стандартную библиотеку подвозит что-то Что делает его ещё быстрее и так далее Первое это бенчмарки да то есть у вас меняется что-то в либе в версии вы его запускаете смотрите стал хуже или или лучше вообще как вот писать их вот правильно это вот отдельная тема Но это как один из вариантов Ну и просто читать ри то то вам придётся Ну страдать и всегда смотреть на него остался ли он Максимум Максимум Да О'кей спасибо то есть тут Тут нет какого-то чёткого плана как вот себя вот избавить от каких-то чало движения Здравствуйте спасибо за доклад очень интересный я вот хотел спросить вот если нам нужно какой-то кусок го кода оптимизировать а Казалось бы есть ещё вот один вариант переписать его на каком-то ну на си например и вызывать его через SIG вот не исследовали вот этот вариант насколько он насколько хороша эта оптимизация SE есть ряд проблем а потому что ну вот условно вы вы выделили сй Bite в Go и передали и передали его в си а очень часто Я видел как в этом месте происходила фототека и это достаточно Сложно делать Тебе нужно помнить что после того как ты вызвал сиго тебе нужно позвать с пакета который скажет го что типа О вот этот объект Ты пожалуйста не вот Убирай потому что он используется Мне кажется это ещё сложнее чем то что я рассказал друзья последний вопрос Время заканчивается но докладчика можно будет поймать в кулуарах прямо у выхода и всё спросить обязательно А нам показали вот достаточно значимую разницу между обычной конкатенации и конкатенации по чанкам А мне кажется что было бы хорошо если бы компилятор зная размер строки мог делать это сам почему он этого не делает Можно ли использовать лайфхак который был до этого что мы там можем показать что у строки есть Точно Вот столько-то символов чтобы компилятор сам понял что надо по чанкам складывать в целом к к компилятор очень много вопросов поэтому это вот один из них ну то есть Почему нет векторизации Почему нет виртуализации чтобы не вот историю Ладно я буду очень подмотать долго Почему историю с когда мы передам вот указатель в интерфейсный вызов Да по по факту Гожа Может в этот момент сделать виртуализацию И вот узнать тип но он этого не делает почему но это Это хороший вопрос возможно так как цель го это скорость компиляции они делают всё чтобы её оставить на том уровне который есть а вот эти все истории они нужны ну для очень узкой прослойки воз этого не дела имен поэто Спасибо за вопросы к сожалению время у нас сейчас уже выходит и давай выберем Два лучших вопросов было много все интерес вот там был человек который спрашивал про регистры но мне кажется ул да Значит не повезло про Хороший вопрос выходи Да на сцену Ага ага ага и Давайте вот последний вопрос про го потому что ну про компилятор Да тоже Аплодисменты первый подарок от компании докладчика держи и второе от спонсоров Сейчас сейчас вы выйдем спроси"
}