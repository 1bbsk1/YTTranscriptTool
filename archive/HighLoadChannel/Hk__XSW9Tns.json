{
  "video_id": "Hk__XSW9Tns",
  "channel": "HighLoadChannel",
  "title": "",
  "views": 0,
  "duration": 0,
  "published": "",
  "text": "Да сегодня мы поговорим про такую штуку как sqc Давайте сначала познакомимся Меня зовут А Женя я работаю в такой компании которая называется узум узум - это цифровая экосистема в Узбекистане которая стала первым единорогом из этой страны собственно Она состоит из большого количества продуктов например там есть у Zoom maret это самый большой маркетплейс в Узбекистане есть ум банк самый большой цифровой Банк в стране и вот мы делаем ум tore - это самый большой фудтех на данный момент а последние 9 лет я пишу код на го последние 5 лет занимаюсь Техо работал в Delivery Club очень долго работал в Яндекс еде очень недолго и у меня был свой собственный фудтех проект плюс вот сейчас мы делаем те скор То есть я вот как будто бы разбираюсь в фудтех последние 4 года я управляю командами разработки и Ну вообще очень люблю всё что связано с кодо генерации начиная от какого-нибудь стра дально го Сваг заканчивая го верте это генерация мапе вот сегодня мы тоже поговорим про тузу для код Гена она называется sqc то есть про что будем говорить поговорим про klc Да но вот там есть довольно подробная документация постараюсь её совсем не пересказывать плюс Я очень не хочу участвовать в Варе orm Versus чистые запросы Каждый выбирает сам инструмент который ему подходит то есть это не про меня Я вас не ангажировать поедем дальше и просто вспомним Как устроена работа с SQL Go А собственно если взять все SQL фреймворки которые есть и как-то расположить их по оси где с левой стороны будет работа с чистым SQL а правее начнутся абстракции то мы получим как бы такую схемку да то есть левая сторона - это вот типа Чем ближе тем к Data SQL Ну Database SQL Вот и sqc занимает самое близкое место к Database SQL потому что он генерирует валидный Database SQL код дальше тут там sqlx и начинается зона кри билдеров и потом начинаются мки вида там всяких бан gorm end ES boiler и так далее так вот как как эти абстракции начали появляться просто вот у нас есть чистый SQL код он замечательный потому что мы управляем SQL кодом и обычно наши сервисы упираются в производительность не из-за кода а из-за баз данных и чтобы ни это мы оптимизируем запросы и вот мы пишем чисты SQL код например вот здесь я извлекаю а все продукты из таблички продуктов получаю объект типа Rolls итерируемый есть дто в которой я мап обычно у меня есть дто для параметров и у меня есть функция которая исполняет запрос функция которая мапи результаты запроса в какую-то структуру это как бы удобно Но обычно у меня не один икел запроса там 2030 на сервис боюсь представить сколько их Монолита А ещё а у меня нет никакой валидации то есть вот я могу в строку SQL запрос написать всё что угодно там ля-ля-ля и получить кучу ошибок Вот сверху это всё обза человеческим фактором то есть есть довольно популярная ошибка Rolls CLS кто-то забыл закрыть объект типа Rolls получил большое количество ошибок падение подов проде по памяти или ещё что-то вот и довольно тоже частая ошибка когда мы используем просто Селект со звёздочкой мы написали миграцию добавили три новых колонки и у нас всё упало потому что стало на три аргумента для сканирования больше очень популярные ошибки наверное все с ними сталкивались вот дальше работа с предполагает ещё обычное управление миграция для базы данных а в какой-то момент мы хотим писать динамические запросы ну собирать запросы по кусочкам Мы хотим использовать именованные аргументы Потому что когда у нас там 20 параметров которые мы вставляем в запрос очень сложно запутаться с доллар О доллар 2 и так далее и мы хотим удобно маршалит Вот и дальше мы как бы обрастаем какими-то инструментами у нас появляется инструмент для миграций у нас появляется какой-нибудь SQL Build и у нас появляется например sqlx который даёт удобный интерфейс для исполнения запросов Ну как бы всё круто вообще как известно Да любую проблему можно решить добавив уровень абстракции кроме проблемы уровня абстракции и в какой-то момент мы выходим к orm orm отличный инструмент Он позволяет быстро писать код он даёт коробочное решение типа всё в одном миграции исполнения кода при этом мы не оперируем SQL и оперируем объектами то есть or круто но если вспомнить Почему мы вообще пишем на Go то мы пишем на Go потому что это производительный и простой язык то есть язык с низкой задержкой с эффективным управлением памятью А самое главное с типа безопасность и вот РМ он не совсем такой то есть у РМ чуть хуже производительность урм у него встречается проблема с типами когда он разваливается в ран тайме основная проблема вообще у RM во всех языках что мы не контролируем SQL то есть там будет выполняться какой-то Ну не то чтобы Рандомный но не оптимальный скел запрос и каждую RM в Go а как бы заставляет тебя учить новый API Как там сделать А ну типа эксклюзивную блокировку неизвестно надо читать документацию так А собственно А вопрос заключается в том что А если нам нужен РМ то нужен ли нам го и наоборот Нужны ли нам orm в Go как бы я предлагаю ответить самостоятельно Если у вас есть ответ А давайте пойдём дальше и собственно какие выводы мы можем сделать вот чистый SQL - это хорошо но он требует большого количество инструментов для того чтобы с ним работать вот и эти инструменты с которыми Мы работаем они должны быть идиома Go то есть они должны быть производительными и они должны сохранять нам безопасность в коде собственно в этот момент у нас появляется sqc sqc - это имати решение кстати круто да Седьмая минута доклада я начал про топик говорить собственно sqc - это генератор идиоматичность То есть у него есть там дофига звёздочек на тла Он давно существует у меня в 2021 году был доклад на от mailru Group как мы внедряли как раз-таки sqc в Delivery Club То есть это довольно зрелый уже инструмент который можно использовать Давайте посмотрим на него сначала сверху как он работает у меня есть мой оптимальный SQL запрос в файли query SQL У меня есть моя схема BD которая лежит в схеме SQL я набираю sqc generate И получаю ещё три файлика в dbg жит управляющая структура queries в которой там обычно находится Connect BD в moduls Goo у меня лежит модельки котором я буду оперировать а в query sql.sql сгенерировал мне модель sqc сгенерировал мне метод которым я буду вызывать из кода собственно А вот результат кода генерации и вот sqc сэкономил мне 10 минут жизни то есть а если у меня 30 запросов то но он мне сэкономил гораздо больше времени А главное мне очень сильно сэкономил на апдейтер это на примере того как работает sqc generate Ну что происходит вообще когда мы это запускаем то есть первым действием skc generate Файлик sqc Y он может называться как угодно и быть даже в формате J но в общем случае это sqc Y Файлик выглядит как-то Так у нас есть вторая версия Мы обычно указываем движок Ну с которым будем работать в моём случае это пос все примеры кода которые я буду показывать почти все на bosg мы указываем значение queries там лежит Папочка в которой лежат файлики с SQL на которых я буду генерировать код в схема лежит либо схема нашей BD которую мы сдам из базы данных либо а все наши миграции которые есть в сервисе а далее мы указываем язык для которого мы будем генерить и Ну типа как называется наш пакет куда мы положим этот пакет и какой-то набор а переопределение то есть оверрайд мы можем заменить а типы можем заменить какие-то колонки при генерации дальше происходит а инициализация компилятора компилятор - это та штука которая собственно и будет генерить наш код Давайте на неё посмотрим А собственно первое что происходит - это парсинг схемы данных то есть sqc знает где находятся все наши миграции и первым действием он их все склеивает чтобы определить как будет выглядеть схема BD То есть он использует Ну типа самые популярные решение там Наго для построения синтаксического дерева вырезает все ролки то есть всё то что у нас находится в migration Down и строит а такую штуку которая у него в памяти называется каталог в которой находится несколько схем баз данных вот далее каждая схема Ну как бы каждый стейтмент который обновляет эту схему проверяется на валидность то есть мы Валиди SQL и Валиди а саму схему типа нельзя изменить колонку которой нету а в базе данных на данный момент далее происходит парсинг самих запросов Аа ну то есть мы также с помощью тех же самых библиотек парсим си токсические деревья а но уже подготавливаем сами запросы извлекаем из них комменты пара запрашиваемые данные проверяем запросы на валидность проверяем запросы на то что их можно исполнить в той схеме данных которые есть собственно запросы выглядят обычно таким образом они всегда начинаются с коммента который называется quotation первым пунктом всегда типа как называется наше имя для кода генерации далее идёт команда команда - это какой шаблон использовать для Ну не шаблон А какой способ использовать для коге результат мы ожидаем есть две основных группы Либо мы просто выполняем запрос типа EX или там получаем на выходе Либо мы получаем какой-то набор строк Many или One одну строку или ошибку SQL RS Ну есть для pgx какой-то набор пакетных операций через bch ну их можно использовать собственно дальше происходит коген там как бы нету никакой кастомизации шаблонов единственный способ както поменять кодо генерацию райв это а использование плагинов но мы сейчас не будем это рассматривать А давайте Ну как бы какой-то набор батареек внутри есть то есть поддерживается три subd Это pog mysql sqlite для постгрес есть два популярных драйвера Вот lpq который сейчас уже не рекомендуется использовать потому что он не метени и pgx который Ну сейчас самый популярный драйвер можно генерить для четырёх языков Плюс через систему плагинов сделана поддержка для C Шарпа Шарпа и так далее вот поддерживаются популярные мигра и то чего нет на этом слайде поддерживается весь SK То есть можно использовать вхи можно использовать хранимые процедуры можно хорошо кастомизировать через config можно дописывать какой-то свой код в том же модуле А давайте поговорим теперь Почему код который мы генерируем безопасный сначала очень такой простой пример у нас есть получение продукта и мы случайно добавили и забыли написать аргумент для фильтра собственно sqc на этапе генерации сразу напишет вам у вас типа неправильный синтаксис проверьте себя клёво пойдём дальше А мы хотим извлечь поле которого нет в изначальной схеме То есть у нас есть табличка produc Арип там нет пишем Запрос который является неправильным и sqc говорит нам типа чувак сначала Добавь колонку description потому что её нет и на этом этапе типа наш код действительно становится бес потому что мы не можем написать и скомпилировать Запрос который является невалидный И следующий этап - это то что можно валидировать миграции Конечно они Валиди ется только на а то есть только на поднятие БД но при этом если мы пытаемся изменить какую-то таблицу которой нет то sqc тоже ругается То есть он проверяет в миграции на то что схема данных получается валидная и ещё один момент который я для меня был очень актуален когда я Переезжал с sqlx на sqc а это момент с тем что вот у меня есть схема я генер какой-то код и вижу что прайс стал нула бельм Почему так а потому что в схеме я забыл not забыл not sqc мне это показал мне естественно не понравилось мапить это поле ещё что-то я его переписываю И получаю правильную схему данных с которой лучше работать потому что продуктов без цены быть не может собственно sqc очень сильно помогает работать с этим Давайте пойдём дальше поговорим про собственно есть Прикольная статья на портале Jet brains которая сравнивала GM sqc и sqx по производительности и там внезапно горм показался лучше чем он есть И мне было очень интересно это перепроверить плюс я взял как чистый Database SQL взял skc с двумя драйверами для по pgx или взял взял B взял sqx как инструмент который можно проверять и взял XO - это такой фреймворк который позволяет тоже генерить код на основе SQL запросов то есть такой аналог для ом тоже показывается се неплохо Лучше чем остальные они высоко вот все остальные почему-то внизу далее извлекаем 1000 строк бан по-прежнему показывает себя хорошо горм падает вниз остальные все находятся внизу по производительности кода Ну дальше делаем то же самое с деся строк вот внезапно все orm скатываются вниз и остаётся наверху код Ген и чистый Database skl sqc тоже показывает Сея неплохо на 100000 строк sqc п pgx нау наверху Хотя он должен соответствовать но скорее всего мне заек что per внизу вот можно посмотреть насладиться графиком тут не так интересно наблюдать за sqc а интереснее скорее посмотреть на горм потому что он перемещается грубо говоря такого с первого места с перформанса вниз и почему так происходит есть две причины первая этом P использует pgx как дефолтный драйвер для поса у бана который тоже показывался неплохо он тоже использует либо свой драйвер либо pgx свой драйвер у него неплохой А и Вторая причина - это не использование рефлекта при работе то есть sqc а не использует рефлект А другие библиотеки естественно его используют потому что они не код гет например Это пример кода из sqx Где используется функция Scan Естественно для того чтобы сканировать любое значение надо использовать лект вот на больших объёмах данных то есть чем больше у нас колонок и чем больше у нас строк тем сильнее это начинает аффектив код в случае же sqc такой проблемы нет потому что мы знаем какие типы мы Гене И сколько у нас там аргументов и как их правильно сканировать поэтому на Большом объёмах данных код который сгенерировал sqc производительный потому что это чистый Database SQL без всего есть набор субъективных причин почему SQL быстрее Первое - это потому что мы используем подход SQL First то есть сначала SQL по эксплей поставили индексы ну типа ну оптимизировали запрос а второе - это то что sqc не даёт нам лишних абстракций то есть мы работаем только вот с моделями которые он нам сгенерировал и обычно ну как бы это ну быстрее А давайте теперь поговорим про всякие кейсы и начнём с динамических запросов А это самая больная тема которая есть А собственно допустим у нас есть та же табличка products у неё есть название цена и мы хотим либо сортировать по названию либо по цене в прямом порядке в обратном А ещё Мы хотим фильтровать по названию цене и для всего этого нам придётся написать отдельный SQL запрос Что делает какое-то Невозможное количество SQL запросов то есть а тут Важно отметить что sqc - это не quy Builder есть очень популярная дискуссия которая ведётся с 2020 года на гитхабе Аа собственно какого-то решения как бы конвенционально нет то есть если нам нужно использовать динамические параметры у нас есть всего три решения Первое - это писать SQL код и использовать там Case Zen то есть мы берём наши красивые SQL запросы и начинаем в них пихать Cas Zen они в этот момент перестают быть интересными но красивыми Если хотите я вам могу потом показать наши запросы где мы это используем выглядит не очень а следующий вариант - это использование такого макроса про макросы Расскажу потом который называется sqc nark это nullable argum то есть мы проверяем если этот аргумент задан то давайте отфильтровали который мы сгенерировать дописывая статические файлы где мы используем quy Builder и но мы получаем какой-то зоопарк то есть Теперь у нас есть и sqc который генерирует код и запрос которые мы написали руками или через quy Build не очень красиво но больше ничего нет а есть набор решений которые предлагают Первое - это например использовать какие-нибудь опциональные параметры через ри аннотации то есть берём комментом и размечаем какой-то кусочек запроса который можно использовать а такой вариант скорее всего никогда не пройдёт поэтому его не будет следующий вариант - это использование магических макросов типа SQL Switch sqc Arc Ну sqc Arc правда есть но вот какие-то вариации с макросами вот эти варианты скорее всего возможны и третий вариант который реализовали другие пользователи sqc - Это несколько вро которые можно использовать вот я бы не рискнул тащить их в прот но зато на них можно посмотреть и может быть опереться на какой-то их опыт если очень хочется остаться с sqc и с динамическими запросами А теперь поговорим про транзакции смотрите у нас есть наш сней На основе данных и у насва получение продукта и обновление цены продукта Да я знаю что это можно сделать за один запрос собственно мы получили какой-то интерфейс и собственно если мы работаем без транзакций то нам надо получить продукт обновить продукт вот это как бы может повлечь за собой какую-то гонку то есть не консистентность данных Вот И для этого мы хотим использовать транзакции и Собственно sqc как бы предполагает работу с кодом который то есть неважно этот код просто на чистом SQL коннекте или на под транзакции то есть код который мы сгенерить работать и там и там одинаково то есть никакой дополнительной код генерации магии не требуется то есть работа с транзакциями в sqc довольно удобная Там есть специальный декоратор transac который мы используем для того чтобы получить скот генины Ну типа интерфейс для работы с транзакциями это выглядит как-то так довольно удобно пойдём дальше И вот массовые операции Когда я работал в Деливери мы делали такую штуку она называлась grossery catalog А собственно это штука которая синхронизирована все там стоки все продукты в там из всяких магнитов кус вилов и так далее То есть там 30.000 магазинов их надо постоянно синхронизировать вот естественно мы пользовались всякими массовыми вставками и это был один из блоке в sqlcmd x плюс он работает для для mysql это использование команды Copy From он генерирует валидный код для pgx который можно вызывать и передавать туда Ну типа много-много значений для вставки следующий - это использование anest в асте мы используем кастинг и получаем тоже валидный код который можно использовать То есть это не так производительно но при этом это работает везде включая драйвер liq вообще в liq есть специальный метод который называется Copy in Вот Но к сожалению sqc его не поддерживает и не планирует по-моему собственно с массовой ставкой всё Пойдёмте к макросам который я обещал А есть первый макрос который вообще как бы когда его увидешь он очень нравится он называется т т позволяет делать композитные типы Например у нас есть табличка книги и авторы этих книг и мы хотим извлечь всех авторов и все их книги в какую-то одну структуру вот если это писать чистым кодом то надо написать как мы там обходим все строки мам их структуру но при этом можно использовать sqc mbet который даст нам на выходе такую композитную строку вот Ну Прикольно можно использовать дальше есть такое ну вообще популярная проблема во всяких с фреймворков Как работать с in потому что мы не можем взять и Ну то есть например Мы хотим получить автора 1 ид но мы не можем написать для код Гена и в других библиотеках просто типа игумен обычно мы используем либо any для кода генерации для поса это работает но в случае mysql нам надо использовать sqc S А И вдруг вот мы видим что наш чистый SQL обрастает каким-то новым синтаксисом синтаксисом макросов sqc и вот конкретно в этом случае для mysql у нас кажется нет альтернативы для использования типа нам придётся использовать макросы нам придётся их учить вот в этот момент чисто SQL перестаёт быть чистым но как бы мне удобно Вот Удобно ли будет вам не знаю А собственно предпоследняя проблема Проблема маппинга она очень болит у одного из моих тем ледов знакомых почему он не хотел использовать sqc вот проблема заключается в следующем если мы делаем просто Селект со звёздочкой то мы получаем модельку автора всё правильно А ну то есть у нас здесь запрос где мы получаем одного автора получаем одного автора дальше мы делаем селек со звёздочкой но извлекаем всех авторов тоже получаем типа слайс авторов Всё круто но теперь мы хотим извлечь какие-то поля которые относятся к автору например ID и name и мы получаем уже не модельку автора мы получаем Get Roll которая относится только к этому запросу и когда мы хотим получить всех авторов мы получаем слайс объектов но который называется listor Rolls и это два разных объекта и если у нас есть код который мы хотим переиспользовать то это может стать неприятно потому что нам придётся его ну как бы добавить какой-то слой на котором мы будем мапить Вот какого-то хорошего решения тут нет ну типа пишем мапе Ну вот здесь придётся поработать с руками вот есть странные решения через виз и через там оверрайд но они все довольно сложные Поэтому лучше просто сма Ну и когда у нас это одинаковые структуры Мы это можем сделать просто через скобочки поэтому это как бы в этом нет ничего страшного последняя такая я е называю Вот и покажу е на примере наследования таблиц А кто-нибудь вообще использовал в постс наследование таблиц когда-нибудь есть Так Опа О круто вам не подойдёт так смотрите пример есть табличка авторы она там состоит из ido я такой Блин хочу ещ табличку блогеров от наследовать от автора Ну типа блогер он поч же толь у него есть а потом я хочу добавить в родительскую табличку статус и вот я генер код и получаю следующий результат в БД статус у меня есть в двух таблицах А в коде который сгенерировал мне sqc статус есть только в одной таблице это баг у него есть ию и у него даже есть PR который исправляет это ию но он по-моему ещё не попал в релиз но собственно на этом можно увидеть что специфичные фичи которые редко используются в базах данных потому что ну наследование редко используется Аа можно натыкаться на проблемы То есть будут либо баги либо какая-то не поддержка это можно встретить и с языком SQL и с фичами конкретных суд Ну на этом примере А как-то так давайте подведём итоги АА А смотрите А когда нам брать если мы хотим генерить производительный код то sqc отлично с этим справляется потому что он генерирует Database SQL который самый чистый вот если мы хорошо относимся к кодо генерации потому что я знаю людей которые не любят кодо генерацию то мы берём sqc Но самое важное мы берём sqc когда мы хотим повысить безопасность кода То есть когда мы хотим закрыть работу с SQL Не только нте но и отлавливать проблемы на этапе компиляции кода то есть мы сначала генерируем код ловим там ошибки что у нас невалидный SQL потом мы сделали валидный SQL но мы забыли спить какое-то поле или у нас изменился Тип и на этом этапе на ошибках компиляции мы ловим проблемы Ну и в целом когда мы работаем с сложными но статичными запросами мы берём skc А когда мы не берём А если мы у нас мы делаем какую-то админку где у нас есть дата таблицы где мы сортируем по разным полям где у нас очень много фильтров и так далее sqc тут не подходит тут естественно надо брать риби Вот если мы делаем аналог асуры это то sqc не подходит А если нам нужна какая-то абстракция для работы с разными базами данных а то sqc нам тоже не очень подходит потому что нам придётся сделать очень большое количество усилий чтобы это всё завелось То есть если мы пишем код который должен работать и на mysql и на pog и там на SQL L то sqc плохой выбор А если мы используем специальный фичи в BD я наткнулся только на наследование но я уверен что их больше а то sqc нам подходит не очень И последнее если мы не любим писать SQL Ну по каким-то причинам мы почитаем ом или просто собирать запросы то действительно sqc тоже лучше не брать а у меня на этом всё тут есть QR кодик Можно мне написать фидбек о я вижу вопрос где-то тут ходит София София Прости я ещё не успела дойти на сцену я тебя подвал выманил меня Спасибо большое за доклад Если у вас есть вопрос поднимите пожалуйста руку к вам подойдут хелперы в мальчики в красных футболках и дадут микрофон говорите пожалуйста в микрофон держите его урта громко и чётко чтобы мы могли вас слышать и Вставайте пожалуйста чтобы мы могли вас видеть Здравствуйте меня зовут Владимир зайцев да Арена дата А вопрос такой по поводу производительности pred qu как-нибудь поддерживаются А да они поддерживаются там на уровне конфига можно дописать а ну типа там есть специальная строчка которая гери prepare statement но при этом например для драйвера pgx генерить вообще не надо потому что он работает в моде который сам пейт запросы Ну там есть несколько execution модов и в pgx по дефолту используется pred запросы и так ну он используется один раз Если я правильно понимаю я имел в виду чтобы их получить Ну в общем-то прямо в документации sqc написано что если вы используете pgx то никакого конфига указывать не надо просто типа Укажите exec Mode вот я здесь не подскажу но как бы если нужно именно запеть то указывается строчка в конфиге И Гене супер спасибо я вижу в первом ряду вопрос Хоть бы не про наследование день очень понравился твой доклад а особенно вот больное по поводу Когда нам нужно много раз много разных вариантов запросов составить А я вот свой как-то давно Ну я вообще изначально любитель рос запросов и очень понравился твой доклад и возьму на заметку Угу такой подход очень лаконично выглядит А вот по поводу того когда у нас много фильтрации ордери и тому подобно здесь ещ осложняется тем что иногда нужно нам разные варианты менять то есть or по-разному выставлять здесь ещё сложнее выходит вот я как-то реализовывался чтобы вот такие какие-то свои кусочки на стороне ран тайма собирать и передавать их в шаблон и можно ли схемой их проверять во-вторых А чтобы они были корректные в итоге и тут ещё как-то биндинг нужно прикручивать угу Там вообще у sqc есть штука которая называется V и verify но они связаны с облачной платформой которая делает sqc поэтому я их не использую вот нте обычно мы используем какие-то другие которые сами находятся лидирует его а вот про ик билдеры вообще там есть Прикольная штука которая работает через web assembly потому что skc сделали систему плагинов А там есть прикольный доклад от Кайла Каро по-моему его зовут это основной разработчик sqc вот он там рассказывает как это работает и вот можно как будто бы использовать систему плагинов чтобы что-то инжектить но при этом в вопросах динамики Мне кажется что это не поможет Я хочу сказать что это сессия вопросов ответов поэтому мы не вступаем активно В дискуссию но знаете что это прекрасный повод потом после доклада пойти в дискуссионную зону и поболтать с докладчиком или вообще любые вопросы любые вещи которые вы не знаю не можете сейчас сформулировали или вам хочется пообщаться один на один с докладчиком все эти вопросы можно будет обсудить В дискуссионной зоне дискуссионная зону находятся слева от входа или выхода это единое место и вход и выход вот а сейчас Давайте ограничимся вс-таки сессии вопросов ответов У нас есть Следующий вопрос в конце зала Да Всем привет Я Дима пин у Жень на одном из твоих последних слайдов было когда не следует использовать sqc что если ты используешь несколько баз данных сразу имеется в виду здесь что не очень удобно работать именно с разными кластерами нет имее ввиду чтоли использую неко мой код одинаково выполнялся на My и на bosg вот я это имел в виду хорошо Есть ли у sqc какие-либо фичи которые позволяют распределять запросы по мастеру и репликам или это всё равно остаётся нет Ну мы же ты должен был видеть у нас в коде мы создаём Просто у нас есть Master Connect и slave Connect и мы создаём две отдельных структуры для запросов там типа Master qu и slave qu всё хорошо с это не skc решает это мы решаем Спасибо большое за вопрос а Подойдите пожалуйста на первый ряд А сейчас давайте услышим вопрос с этой стороны зала Добрый день Меня зовут Алексей Евгений Спасибо большое за доклад очень интересно Хотя я лично не использовал ничего подобного коло генерацию никогда не использовал поэтому вопрос очень простой немножко туповатый ээ вы показали когда сама таблица создаётся и там нул значения предусмотрены если нул может возникнуть в результате самого запроса то есть Ну нету соответствия Допустим мы Джой нету соответствия в другой таблицы этой таблицы сгенерить ли он автоматом сразу ну значение по умолчанию в структуре я правильно понимаю вопрос что если мы делаем Селект с адж Будут ли все значения да дадада А да будут он на как бы получается что у нас тут кастомный запрос и он генерирует к нему д тошку которая будет ну типа название метода R при этом там можно через МД например удобно спить то что мы джом в какую-то сразу структуру то есть если мы опишем модельку то можно получить даже не просто структуру в которой будут все поля перечислены А иерархическую ну то есть какой-то Композит супер спасибо вопрос Жень привет Меня зовут Лёша Я из Яндекса и пишу какую-то странную СУБД называется собственно слайд где у тебя показано поддерживаемое уд Их всего три а в мире баз данных их просто Овер много и наверное как человек который съел собаку на этих чебуреках и долго ковырялся в репе там sqc должен понимать наверное как люди заносят или есть шанс занести Я хочу туда занести idb сколько мне усилий или там вообще ноль шансов Мне кажется что там довольно открытый комьюнити ну контрибьютор поэтому шансы есть но я своих пиаров туда не отправлял Мы туда только отправляли бак репорты То есть я на таком уровне а там треки есть Ну просто на двадцать четвёртый год всего три СУБД поддерживаются Ну да но при этом вот я Сколько лет 10 занимаюсь разработкой У меня везде постс Поэтому мои запросы покрывают целиком Хотя изначально а sqc делал это для My вот есть конкурентная библиотека потому что мне было интересно типа это единственное решение Нет она называется XO Вот и XO по-моему тоже было сделано под mysql Вот Но при этом как бы не знаю мне кажется что процентов 70 Может ты знаешь лучше это использует пос сейчас в работе А да как-то так спасибо Я же говорю Ты приносишь в жизнь других людей новые технологии у меня новая технология в компании тут собирается котб проект очень круто Мне кажется Прям вообще есть ли ещё вопросы в зала поднимите руки чтобы к Вам подошли у нас с правой стороны есть вопрос спасибо очень интересно у меня был маленький вопрос про лимит и Безопасность как он всё это учитывает но в ответах прозвучало что-то более интересное про облачную платформу и как будто бы есть что-то что не управляется я уточню вопрос насколько это безопасно потому что у нас есть опыт с а я понял что меня не интересует их облачная платформа она предназначена для тестирования и для создания быстрых тестовых БД вот там есть просто методы Push verify которые связаны Ну типа связываются с Cloud xcd Вот Но я этим не пользовался потому что мне это показалось неинтересным оно не Решало никаких моих задач Вот поэтому я облаком не пользовался вообще Вот но там очень много после того как основной контрибьютор начал заниматься sqc вот он очень много в обла Я так понимаю что там будет какая-то монетизация которая связана именно с этим но это предположение я так не знаю Спасибо Слушай а у вас сейчас вообще везде используется sqc как вы с мигрировали у нас в testore есть три направления разработки вот моё называется кастомер это всё что относится к клиентскому опыту плюс там процессинг заказов процессинг платежей во всех сервиса Где нам требуется Ну типа хранение мы используем sqc есть направление partners они всё написали на sqx и мы долго ходили к ним травили их в общем-то тогда пришёл новый лит который тоже Ну типа ему нравится sqc он пробовал понимает насколько это он экономит время новый код они пишут с skc старый код планирует переписывать но там есть критики ну их надо убеждать Вот и есть у нас логистическое направление а они выбрали горм Ну вот как бы их мы уже не переубеди Понятно Есть ли ещё вопросы в зале поднимите пожалуйста руку чтобы к Вам подошли и выдали микрофон я вот вижу вопрос в первом ряде Давайте дадим человеку возможность Спасибо за доклад Меня зовут Рафаэль Вот чуть-чуть расширьте вот этот ответ Спасибо что задали его во всём у изюме вот где вы сказали должны же быть места где используются динамические запросы вот как вы подружились с ус да у нас есть большой ум это много продуктов Но основной узум вообще написан на Джаве и как они живут Я не знаю То есть я не смогу рассказать про большой Zoom вот ничего то есть мы существуем В отдельной ифреймы пересекаемся только через там какие-то интеграции посредством http всё вот и как бы я знаю что у них Java но как у них устроен энд какие у них фреймворки и как они работают я не расскажу Спасибо е вопрос в зале я видела Давайте подойдём Добрый день доклад был очень интересный вижу что вы очень глубоко погрузились в эту тему могли рассказать как с и может ли он вообще использовать вре хинты для использования индексов и тали А вот по-моему особо никак То есть он понимает Какие типы но на индексы Я не уверен что он обращает внимание То есть он понимает там нуб не нубл Вот Но в случае там индексации я даже не знаю как это повлияет на код Ген Ну по-моему ни как то есть а кажется ответ такой Спасибо А есть ли ещё вопросы в зале поднимите пожалуйста руку чтобы вас было видно отлично У нас есть ещё один вопрос в зале кого Ага Можно можно второй всё-таки вернёмся тогда безопасный sqc и генерация большого Эля как он учитывает что в и набьёт куча значений или что там в юниона какие-нибудь просто превысят лимиты вот у каждой СУБД они свои в каждой версии это вообще учитывается Да Слушай наверно нет типа я даже не знаю как ответить тут а вот на на этом уровне Я думаю что Никакой безопасности не будет то есть ты это этим же занимаешься на каком-то уже следующем уровне абстракции вот мы можем про это поговорить отдельно наверное отличный повод поговорить в кулуар отличный повод сбежать что тебе настолько надоело стоять со мной на сцене не не не я про это сбежать из дискуссионной зоны ты не сбежишь так хорошо Есть ли ещё вопросы в зале поднимите пожалуйста высоко руку чтобы мы вас увидели нет отлично Все оставшиеся какие-то темы которые хочется обсудить и дискуссии можно обсудить В дискуссионной зоне я не дам сбежать Евгению А давай выберем с тобой вопрос который больше всего тебе понравился чтобы подарить уникальную матрёшку от конференции а пампампампам а ты же записывал вопросы ты так сказала да секретар Я всё записывала Вот смотри у нас есть 10 вопросов Ага Так ну давайте Не давайте матрёшку подарим Антону Хорошо Антон поднимите пожалуйста свою руку потому что мы должны знать кто вы вас и знать вас в лицо героев надо знать в лицо и давай выберем ещ один вопрос для того чтобы подарить подарок от узу кажется Алексей да из Яндекса наш подарок от Зума супер тоже поднимите пожалуйста руку высоко Спасибо большое блин это так всё-таки реально круто когда мотивирует людей дальше продолжать дело вас Я тоже хочу поблагодарить тебя Я тоже хочу поблагодарить я переключаюсь свой ты Давайте попло о господи мы хотим подарить тебе подарок от конференции приходи пожалуйста рассказывать нам интересные темы Я уверена у тебя что-то ещё есть там даже говорят что есть ещё вторая часть доклада про тимпол я буду её слушать её Антон расскажет Да ну это Это на будущее задело А что ж Спасибо большое что были с нами Давайте"
}